<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="cbea582f956209002e88cbc4ada27fa0d962fe95" translate="yes" xml:space="preserve">
          <source>By default, this development Notary server container runs with the testing self-signed TLS certificates. Before you can successfully connect to it, you must use the root CA file in &lt;code&gt;fixtures/root-ca.crt&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 개발 Notary 서버 컨테이너는 테스트 자체 서명 된 TLS 인증서로 실행됩니다. 성공적으로 연결하기 전에 &lt;code&gt;fixtures/root-ca.crt&lt;/code&gt; 의 루트 CA 파일을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c53079a207e51923dadf487a6a0e31e100b39a4c" translate="yes" xml:space="preserve">
          <source>By default, this renders all results in a JSON array. If a format is specified, the given template will be executed for each result.</source>
          <target state="translated">기본적으로 모든 결과가 JSON 배열로 렌더링됩니다. 형식을 지정하면 각 결과에 대해 주어진 템플릿이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f51db5b4d533e607b784cec6f3a067a0e505fdd1" translate="yes" xml:space="preserve">
          <source>By default, this renders information about a machine as JSON. If a format is specified, the given template is executed for each result.</source>
          <target state="translated">기본적으로 머신에 대한 정보를 JSON으로 렌더링합니다. 형식을 지정하면 각 결과에 대해 주어진 템플릿이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49af628ba5a483808d5b27cc35bc9caff6e40302" translate="yes" xml:space="preserve">
          <source>By default, this will render all version information in an easy to read layout. If a format is specified, the given template will be executed instead.</source>
          <target state="translated">기본적으로 모든 버전 정보를 읽기 쉬운 레이아웃으로 렌더링합니다. 형식을 지정하면 지정된 템플릿이 대신 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="95e08bbdcf1f3ff1bfea58b1ae2dd471014f72ea" translate="yes" xml:space="preserve">
          <source>By default, volumes are not removed to prevent important data from being deleted if there is currently no container using the volume. Use the &lt;code&gt;--volumes&lt;/code&gt; flag when running the command to prune volumes as well:</source>
          <target state="translated">기본적으로 볼륨을 사용하는 컨테이너가없는 경우 중요한 데이터가 삭제되지 않도록 볼륨이 제거되지 않습니다. 명령을 실행할 때 &lt;code&gt;--volumes&lt;/code&gt; 플래그를 사용하여 볼륨도 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a5698285a251cb301803c0efaee5ee3410551f36" translate="yes" xml:space="preserve">
          <source>By default, when an update to an individual task returns a state of &lt;code&gt;RUNNING&lt;/code&gt;, the scheduler schedules another task to update until all tasks are updated. If, at any time during an update a task returns &lt;code&gt;FAILED&lt;/code&gt;, the scheduler pauses the update. You can control the behavior using the &lt;code&gt;--update-failure-action&lt;/code&gt; flag for &lt;code&gt;docker service create&lt;/code&gt; or &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">기본적으로 개별 작업에 대한 업데이트가 &lt;code&gt;RUNNING&lt;/code&gt; 상태를 반환 하면 스케줄러는 모든 작업이 업데이트 될 때까지 다른 작업이 업데이트되도록 예약합니다. 업데이트 중 언제라도 작업이 &lt;code&gt;FAILED&lt;/code&gt; 를 반환 하면 스케줄러가 업데이트를 일시 중지합니다. &lt;code&gt;docker service create&lt;/code&gt; 또는 &lt;code&gt;docker service update&lt;/code&gt; 에 &lt;code&gt;--update-failure-action&lt;/code&gt; 플래그를 사용하여 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8354b32fc43b73137ebadee639f16b108477b8fc" translate="yes" xml:space="preserve">
          <source>By default, when you connect a container to an &lt;code&gt;overlay&lt;/code&gt; network, Docker also connects a bridge network to it to provide external connectivity. If you want to create an externally isolated &lt;code&gt;overlay&lt;/code&gt; network, you can specify the &lt;code&gt;--internal&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 컨테이너를 &lt;code&gt;overlay&lt;/code&gt; 네트워크에 연결하면 Docker는 브리지 네트워크를 연결하여 외부 연결을 제공합니다. 외부 적으로 고립 된 &lt;code&gt;overlay&lt;/code&gt; 네트워크 를 만들려면 &lt;code&gt;--internal&lt;/code&gt; 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87acbcf709a227d9e7363b9622887ebaccae3163" translate="yes" xml:space="preserve">
          <source>By default, when you publish a port, it is a TCP port. You can specifically publish a UDP port instead of or in addition to a TCP port. When you publish both TCP and UDP ports, If you omit the protocol specifier, the port is published as a TCP port. If you use the longer syntax (recommended for Docker 1.13 and higher), set the &lt;code&gt;protocol&lt;/code&gt; key to either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;.</source>
          <target state="translated">기본적으로 포트를 게시 할 때 TCP 포트입니다. TCP 포트 대신 또는 TCP 포트 외에 UDP 포트를 구체적으로 게시 할 수 있습니다. TCP 및 UDP 포트를 모두 게시 할 때 프로토콜 지정자를 생략하면 포트가 TCP 포트로 게시됩니다. 더 긴 구문을 사용하는 경우 (Docker 1.13 이상 권장) &lt;code&gt;protocol&lt;/code&gt; 키를 &lt;code&gt;tcp&lt;/code&gt; 또는 &lt;code&gt;udp&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3de445d9198de33b1b5e1abd1cacaae2390bcdfe" translate="yes" xml:space="preserve">
          <source>By having this flag it allows for batch cleanup. For example, use this filter to delete all user defined networks:</source>
          <target state="translated">이 플래그를 사용하면 일괄 정리가 가능합니다. 예를 들어,이 필터를 사용하여 모든 사용자 정의 네트워크를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="f740c5dd5d4ab97daaadc90e6b49355a452a8581" translate="yes" xml:space="preserve">
          <source>By using a docker-in-docker image for the &lt;code&gt;trustsandbox&lt;/code&gt; container, you also don&amp;rsquo;t pollute your real Docker daemon cache with any images you push and pull. The images are stored in an anonymous volume attached to this container, and can be destroyed after you destroy the container.</source>
          <target state="translated">&lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너에 도커 인 도커 이미지를 사용 하면 밀고 당기는 이미지로 실제 도커 데몬 캐시를 오염시키지 않습니다. 이미지는이 컨테이너에 연결된 익명의 볼륨에 저장되며 컨테이너를 파괴 한 후에 파기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="399a8ae2cc774a81a085c3e615dd0d4dd7cd51ca" translate="yes" xml:space="preserve">
          <source>Bypass file read permission checks and directory read and execute permission checks.</source>
          <target state="translated">파일 읽기 권한 점검 및 디렉토리 읽기 및 실행 권한 점검을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="db07c2e40c63332bba384355fb97919c05048d69" translate="yes" xml:space="preserve">
          <source>Bypass file read, write, and execute permission checks.</source>
          <target state="translated">파일 읽기, 쓰기 및 실행 권한 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="688bd1d15287dadde2712a82e28cc7fcde93aebe" translate="yes" xml:space="preserve">
          <source>Bypass permission checks for operations on System V IPC objects.</source>
          <target state="translated">권한 무시는 System V IPC 오브젝트에 대한 조작을 점검합니다.</target>
        </trans-unit>
        <trans-unit id="df2c011fdcc669510635c7c7e87f87ad7e8aeb36" translate="yes" xml:space="preserve">
          <source>Bypass permission checks for sending signals.</source>
          <target state="translated">신호 전송에 대한 권한 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="011dca1c2857e5a8a40248e13ec26dffab6f7307" translate="yes" xml:space="preserve">
          <source>Bypass permission checks on operations that normally require the file system UID of the process to match the UID of the file.</source>
          <target state="translated">일반적으로 프로세스의 파일 시스템 UID가 파일의 UID와 일치해야하는 작업에 대한 권한 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d43a46bc93439a36eed6bd56de27d87c84fd7540" translate="yes" xml:space="preserve">
          <source>Bypass the routing mesh</source>
          <target state="translated">라우팅 메쉬 우회</target>
        </trans-unit>
        <trans-unit id="e94da20465e0da677d6cf3ac9cb94fc7dba70dc6" translate="yes" xml:space="preserve">
          <source>CHOWN</source>
          <target state="translated">CHOWN</target>
        </trans-unit>
        <trans-unit id="00ac5337ed74f4a1145dc2e813199dafe24a6311" translate="yes" xml:space="preserve">
          <source>CLI environment variables</source>
          <target state="translated">CLI 환경 변수</target>
        </trans-unit>
        <trans-unit id="4eb763e19c12c4ef0eb3f0f22117a1d1f6386136" translate="yes" xml:space="preserve">
          <source>CLI option</source>
          <target state="translated">CLI 옵션</target>
        </trans-unit>
        <trans-unit id="08e4da4e4f3b9df4371883c2c534d94c9bbb7158" translate="yes" xml:space="preserve">
          <source>CMD</source>
          <target state="translated">CMD</target>
        </trans-unit>
        <trans-unit id="edf1318ab7906e3281e77996aa018595ff3f2807" translate="yes" xml:space="preserve">
          <source>CMD (Default Command or Options)</source>
          <target state="translated">CMD (기본 명령 또는 옵션)</target>
        </trans-unit>
        <trans-unit id="ff823d42eb8e55df458984f382e6a4124ef2e286" translate="yes" xml:space="preserve">
          <source>CMD (default command or options)</source>
          <target state="translated">CMD (기본 명령 또는 옵션)</target>
        </trans-unit>
        <trans-unit id="0ca73595d3e41a195bdc11db00a6c5e2352092ea" translate="yes" xml:space="preserve">
          <source>COMMAND should be an executable, a chained or a quoted command will not work. Example: &lt;code&gt;docker exec -ti my_container &quot;echo a &amp;amp;&amp;amp; echo b&quot;&lt;/code&gt; will not work, but &lt;code&gt;docker exec -ti my_container sh -c &quot;echo a &amp;amp;&amp;amp; echo b&quot;&lt;/code&gt; will.</source>
          <target state="translated">COMMAND는 실행 파일이어야하며 연결되거나 인용 된 명령이 작동하지 않습니다. 예 : &lt;code&gt;docker exec -ti my_container &quot;echo a &amp;amp;&amp;amp; echo b&quot;&lt;/code&gt; 는 작동하지 않지만 &lt;code&gt;docker exec -ti my_container sh -c &quot;echo a &amp;amp;&amp;amp; echo b&quot;&lt;/code&gt; 는 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c13ae391a18ea16b88f231499bcdc42ae973cc00" translate="yes" xml:space="preserve">
          <source>COMMAND will run in the default directory of the container. If the underlying image has a custom directory specified with the WORKDIR directive in its Dockerfile, this will be used instead.</source>
          <target state="translated">COMMAND는 컨테이너의 기본 디렉토리에서 실행됩니다. 기본 이미지의 Dockerfile에 WORKDIR 지시문으로 지정된 사용자 정의 디렉토리가 있으면이 디렉토리가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09c61b1bb570b8919fe1bfa6d593e36ff4a0558a" translate="yes" xml:space="preserve">
          <source>COMPOSE_API_VERSION</source>
          <target state="translated">COMPOSE_API_VERSION</target>
        </trans-unit>
        <trans-unit id="075934e990bf2de58e08cf8bc7d8405ca0df74ea" translate="yes" xml:space="preserve">
          <source>COMPOSE_CONVERT_WINDOWS_PATHS</source>
          <target state="translated">COMPOSE_CONVERT_WINDOWS_PATHS</target>
        </trans-unit>
        <trans-unit id="a490fef2862488ec598a044ef66cbaa0e6ed6651" translate="yes" xml:space="preserve">
          <source>COMPOSE_FILE</source>
          <target state="translated">COMPOSE_FILE</target>
        </trans-unit>
        <trans-unit id="9c04da925f221a57c723c7a5d71f2f43068aa84b" translate="yes" xml:space="preserve">
          <source>COMPOSE_FORCE_WINDOWS_HOST</source>
          <target state="translated">COMPOSE_FORCE_WINDOWS_HOST</target>
        </trans-unit>
        <trans-unit id="02b02f63ae8382f43f44da4438404fd6e7bb1b11" translate="yes" xml:space="preserve">
          <source>COMPOSE_HTTP_TIMEOUT</source>
          <target state="translated">COMPOSE_HTTP_TIMEOUT</target>
        </trans-unit>
        <trans-unit id="78b7173c08d665d6614297937677c7962886d548" translate="yes" xml:space="preserve">
          <source>COMPOSE_IGNORE_ORPHANS</source>
          <target state="translated">COMPOSE_IGNORE_ORPHANS</target>
        </trans-unit>
        <trans-unit id="335c7f5a80f41c4383b121b41106a8c7ab022a09" translate="yes" xml:space="preserve">
          <source>COMPOSE_INTERACTIVE_NO_CLI</source>
          <target state="translated">COMPOSE_INTERACTIVE_NO_CLI</target>
        </trans-unit>
        <trans-unit id="19959f805703be5e30548ee28eb85e39c05f2448" translate="yes" xml:space="preserve">
          <source>COMPOSE_PARALLEL_LIMIT</source>
          <target state="translated">COMPOSE_PARALLEL_LIMIT</target>
        </trans-unit>
        <trans-unit id="2635050b6bad499664faff2d6b1e86f77f24bd1f" translate="yes" xml:space="preserve">
          <source>COMPOSE_PATH_SEPARATOR</source>
          <target state="translated">COMPOSE_PATH_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="7ccecf7f48e4797ab29bb7ee4cfc9d25640a2a8b" translate="yes" xml:space="preserve">
          <source>COMPOSE_PROJECT_NAME</source>
          <target state="translated">COMPOSE_PROJECT_NAME</target>
        </trans-unit>
        <trans-unit id="8721489da6c5e16b234673e52e0a33e814d823d3" translate="yes" xml:space="preserve">
          <source>COMPOSE_TLS_VERSION</source>
          <target state="translated">COMPOSE_TLS_VERSION</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="af396b5b7c546c0a09ecc046780a7720f167b658" translate="yes" xml:space="preserve">
          <source>COPY has two forms:</source>
          <target state="translated">복사에는 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c831e7fae7388596527f17dbff20814a0d1fd001" translate="yes" xml:space="preserve">
          <source>CPU and memory limits and reservations</source>
          <target state="translated">CPU 및 메모리 제한 및 예약</target>
        </trans-unit>
        <trans-unit id="200f5c7c731f401ed6f00ff8af68860192d88c65" translate="yes" xml:space="preserve">
          <source>CPU count (Windows only)</source>
          <target state="translated">CPU 수 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="6c02cf31fa32c922fe001ab5a78ecf92e7ae40a4" translate="yes" xml:space="preserve">
          <source>CPU percent (Windows only)</source>
          <target state="translated">CPU 백분율 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="1baaafc01fcd1fa20dd909d6f145822785746ada" translate="yes" xml:space="preserve">
          <source>CPU percentage</source>
          <target state="translated">CPU 비율</target>
        </trans-unit>
        <trans-unit id="826eef91b62ab7b7180fec73d9d176fc23154845" translate="yes" xml:space="preserve">
          <source>CPU period constraint</source>
          <target state="translated">CPU 기간 제약</target>
        </trans-unit>
        <trans-unit id="f5d6decace4e7b99bf6d5bc06d4d2f3db103367d" translate="yes" xml:space="preserve">
          <source>CPU quota constraint</source>
          <target state="translated">CPU 할당량 제약</target>
        </trans-unit>
        <trans-unit id="681a20aa365b8c97d1eacd38d32b955811e8582c" translate="yes" xml:space="preserve">
          <source>CPU share constraint</source>
          <target state="translated">CPU 공유 제약</target>
        </trans-unit>
        <trans-unit id="408cf93fd244e93de9ad93777131031fb9c7c515" translate="yes" xml:space="preserve">
          <source>CPU shares (relative weight)</source>
          <target state="translated">CPU 공유 (상대 가중치)</target>
        </trans-unit>
        <trans-unit id="8629f26a763371cf20640e7221a696538b5658c3" translate="yes" xml:space="preserve">
          <source>CPUs in which to allow execution (0-3, 0,1)</source>
          <target state="translated">실행을 허용하는 CPU (0-3, 0,1)</target>
        </trans-unit>
        <trans-unit id="b5b27172fc740e15a31d844f9dc2b505dc87eeae" translate="yes" xml:space="preserve">
          <source>Caching options for volume mounts (Docker Desktop for Mac)</source>
          <target state="translated">볼륨 마운트 캐싱 옵션 (Docker Desktop for Mac)</target>
        </trans-unit>
        <trans-unit id="beb5f11d17f3f498d8ba53d407895453f2287671" translate="yes" xml:space="preserve">
          <source>Calling authorized command (allow)</source>
          <target state="translated">승인 된 명령 호출 (허용)</target>
        </trans-unit>
        <trans-unit id="4fc2f468884c0bfcbbef63dedbe3164123a41dd7" translate="yes" xml:space="preserve">
          <source>Calling unauthorized command (deny)</source>
          <target state="translated">무단 명령 호출 (거부)</target>
        </trans-unit>
        <trans-unit id="0c17dce1cc7f5b328b0ae93dce5a79dc79c30a77" translate="yes" xml:space="preserve">
          <source>Can I control service startup order?</source>
          <target state="translated">서비스 시작 순서를 제어 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3f06a09ae74025bf28f544b2f1b6b3012bdd50ce" translate="yes" xml:space="preserve">
          <source>Can I use json instead of yaml for my Compose file?</source>
          <target state="translated">작성 파일에 yaml 대신 json을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b22ecea78140bcc829d30570fc1033f11c81186e" translate="yes" xml:space="preserve">
          <source>Cancel a pull</source>
          <target state="translated">풀 취소</target>
        </trans-unit>
        <trans-unit id="76855863c476e5d1e636a20f81b7a2fe9b7e8b1c" translate="yes" xml:space="preserve">
          <source>Capabilities are just one of the many security features provided by modern Linux kernels. It is also possible to leverage existing, well-known systems like TOMOYO, AppArmor, SELinux, GRSEC, etc. with Docker.</source>
          <target state="translated">기능은 최신 Linux 커널이 제공하는 많은 보안 기능 중 하나 일뿐입니다. TOMOYO, AppArmor, SELinux, GRSEC 등과 같은 기존의 잘 알려진 시스템을 Docker와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9de03488ab597a2e4d896db6c4a5042733f44a66" translate="yes" xml:space="preserve">
          <source>Capabilities turn the binary &amp;ldquo;root/non-root&amp;rdquo; dichotomy into a fine-grained access control system. Processes (like web servers) that just need to bind on a port below 1024 do not need to run as root: they can just be granted the &lt;code&gt;net_bind_service&lt;/code&gt; capability instead. And there are many other capabilities, for almost all the specific areas where root privileges are usually needed.</source>
          <target state="translated">기능은 바이너리 &quot;루트 / 루트가 아닌&quot;이분법을 세분화 된 액세스 제어 시스템으로 전환합니다. 1024 미만의 포트에서 바인딩해야하는 웹 서버와 같은 프로세스는 루트로 실행할 필요가 없습니다 . 대신 &lt;code&gt;net_bind_service&lt;/code&gt; 기능을 부여 할 수 있습니다 . 그리고 루트 권한이 일반적으로 필요한 거의 모든 특정 영역에 대해 다른 많은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9b454f7d1c1b8d1a3b4be10aeb579549fcec25" translate="yes" xml:space="preserve">
          <source>Capability Description</source>
          <target state="translated">기능 설명</target>
        </trans-unit>
        <trans-unit id="fe9785052b609f2a0a53d9e1633acc05dd0c97e8" translate="yes" xml:space="preserve">
          <source>Capability Key</source>
          <target state="translated">기능 키</target>
        </trans-unit>
        <trans-unit id="ca62903c589b7fa47f2c2acdfd4f0b3a3ababb36" translate="yes" xml:space="preserve">
          <source>Capture container ID (--cidfile)</source>
          <target state="translated">컨테이너 ID 캡처 (--cidfile)</target>
        </trans-unit>
        <trans-unit id="5b00288fd36cd410e4f77454c64756ab782cb577" translate="yes" xml:space="preserve">
          <source>Casbin AuthZ Plugin</source>
          <target state="translated">Casbin AuthZ 플러그인</target>
        </trans-unit>
        <trans-unit id="04a4d6b5502f6f0f9b81f41e9ffe8681eb02c812" translate="yes" xml:space="preserve">
          <source>Cause of an old container breakout. Also gated by &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt;.</source>
          <target state="translated">오래된 용기 고장 원인. &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="51ad199d6352d3bb64db022bd0fbb0fcdea024f8" translate="yes" xml:space="preserve">
          <source>CentOS</source>
          <target state="translated">CentOS</target>
        </trans-unit>
        <trans-unit id="b37179a97c82948697ad0d49c7b76c411f9c0218" translate="yes" xml:space="preserve">
          <source>Certificate directory</source>
          <target state="translated">인증서 디렉토리</target>
        </trans-unit>
        <trans-unit id="b3e4eb01f159b35b99f9fe62dc4d20f8175f1cc1" translate="yes" xml:space="preserve">
          <source>Certificates</source>
          <target state="translated">Certificates</target>
        </trans-unit>
        <trans-unit id="ef29a7d24a43a235dc356f1205550a1344d0963b" translate="yes" xml:space="preserve">
          <source>Certificates can be world-readable, but you might want to remove write access to prevent accidental damage:</source>
          <target state="translated">인증서는 세계적으로 읽을 수 있지만 실수로 인한 손상을 방지하기 위해 쓰기 권한을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b91d632e95864e44f7de6e0d0e5107f0757728f" translate="yes" xml:space="preserve">
          <source>Change a device path</source>
          <target state="translated">장치 경로 변경</target>
        </trans-unit>
        <trans-unit id="193c9fb0cb02e6ef0f48edd152c2c5212018ce7c" translate="yes" xml:space="preserve">
          <source>Change an environment variable</source>
          <target state="translated">환경 변수 변경</target>
        </trans-unit>
        <trans-unit id="148e99f4df78975763a1303a4721acdfdf1fd3fd" translate="yes" xml:space="preserve">
          <source>Change into the registry storage for one of those layers (this is in a different directory):</source>
          <target state="translated">해당 계층 중 하나에 대한 레지스트리 스토리지로 변경하십시오 (이 디렉토리는 다른 디렉토리에 있음).</target>
        </trans-unit>
        <trans-unit id="a681edf94ac7dbcf190629d114bba658ef30fa09" translate="yes" xml:space="preserve">
          <source>Change into your project directory.</source>
          <target state="translated">프로젝트 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="8a09ab92670fb750892c92f0b76b0a0ca9cfb3fa" translate="yes" xml:space="preserve">
          <source>Change manager autolocking setting (true|false)</source>
          <target state="translated">변경 관리자 자동 잠금 설정 (true | false)</target>
        </trans-unit>
        <trans-unit id="5a343e008293dccc9bfd9a6189d4c101185b8dff" translate="yes" xml:space="preserve">
          <source>Change node availability</source>
          <target state="translated">노드 가용성 변경</target>
        </trans-unit>
        <trans-unit id="a6ce7413e01a89de3c83c6c7145ae263067be792" translate="yes" xml:space="preserve">
          <source>Change roles</source>
          <target state="translated">역할 변경</target>
        </trans-unit>
        <trans-unit id="523445ab7d571797e64833166abcc5af3f9e019c" translate="yes" xml:space="preserve">
          <source>Change settings for a plugin</source>
          <target state="translated">플러그인 설정 변경</target>
        </trans-unit>
        <trans-unit id="06d6ba403e5c4576b52e5e8912912b50b3ab8072" translate="yes" xml:space="preserve">
          <source>Change settings for a plugin. The plugin must be disabled.</source>
          <target state="translated">플러그인 설정을 변경하십시오. 플러그인을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fad2e5e8a9f7d5be42da23adc6313b72858ac52" translate="yes" xml:space="preserve">
          <source>Change the app behavior by editing code, then rebuild, and push the new image. (To do this, follow the same steps you took earlier to &lt;a href=&quot;../part2/index#build-the-app&quot;&gt;build the app&lt;/a&gt; and &lt;a href=&quot;../part2/index#publish-the-image&quot;&gt;publish the image&lt;/a&gt;).</source>
          <target state="translated">코드를 편집하여 앱 동작을 변경 한 다음 다시 빌드하고 새 이미지를 푸시하십시오. (이렇게하려면, 당신이 이전했다 동일한 단계에 따라 &lt;a href=&quot;../part2/index#build-the-app&quot;&gt;응용 프로그램을 구축&lt;/a&gt; 하고 &lt;a href=&quot;../part2/index#publish-the-image&quot;&gt;이미지를 게시을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f90e1a532e2ee7440d242012ee83ed31e5604946" translate="yes" xml:space="preserve">
          <source>Change the greeting in &lt;code&gt;app.py&lt;/code&gt; and save it. For example, change the &lt;code&gt;Hello World!&lt;/code&gt; message to &lt;code&gt;Hello from Docker!&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;app.py&lt;/code&gt; 에서 인사말을 변경 하고 저장하십시오. 예를 들어 &lt;code&gt;Hello World!&lt;/code&gt; &lt;code&gt;Hello from Docker!&lt;/code&gt; 에서 Hello 에게 보내는 메시지 ! :</target>
        </trans-unit>
        <trans-unit id="3e6ff36197d807db528fa8c6647c2b182ed610e1" translate="yes" xml:space="preserve">
          <source>Change the source of a mount</source>
          <target state="translated">마운트 소스 변경</target>
        </trans-unit>
        <trans-unit id="2c500e17f4b87da98a3ea0b21ec930483b1f8d1b" translate="yes" xml:space="preserve">
          <source>Change the source of the arguments</source>
          <target state="translated">인수의 소스를 변경</target>
        </trans-unit>
        <trans-unit id="afdd19eaaea7d7fb74e93441ad14a55478947a3c" translate="yes" xml:space="preserve">
          <source>Change to the root of your project directory.</source>
          <target state="translated">프로젝트 디렉토리의 루트로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="59969f9bb48d798846b57f0f098144f18b1ae9a2" translate="yes" xml:space="preserve">
          <source>Change your &lt;code&gt;sources.list&lt;/code&gt; entries to start with &lt;code&gt;http://dockerhost:3142/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;http://dockerhost:3142/&lt;/code&gt; 로 시작하도록 &lt;code&gt;sources.list&lt;/code&gt; 항목을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="c309779a945e9ddee3c5fe112fcfa5449a5ae007" translate="yes" xml:space="preserve">
          <source>Changing node availability lets you:</source>
          <target state="translated">노드 가용성을 변경하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6e9711ada7ea25e1cd23f17c92e698561118d2" translate="yes" xml:space="preserve">
          <source>Check back here for instructions after Notary Server has an official stable release. To get a head start on deploying Notary in production, see &lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;the Notary repository&lt;/a&gt;.</source>
          <target state="translated">Notary Server가 공식적으로 안정적인 릴리스를 수행 한 후 여기에서 지침을 확인하십시오. 프로덕션 환경에서 Notary를 배포하기 위해 먼저 시작하려면 &lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;Notary 저장소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="644dab178864587da5bb7f92dc65e7b971e8c5bf" translate="yes" xml:space="preserve">
          <source>Check for available engine updates</source>
          <target state="translated">사용 가능한 엔진 업데이트 확인</target>
        </trans-unit>
        <trans-unit id="a110c34d8c38423dcac540dfab62d55eaef79ab9" translate="yes" xml:space="preserve">
          <source>Check that the plugin is enabled in the output of &lt;code&gt;docker plugin ls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker plugin ls&lt;/code&gt; 출력에서 플러그인이 활성화되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0502b724f096f24d3582f7e026bedab007c4dd6b" translate="yes" xml:space="preserve">
          <source>Check that this worked by running:</source>
          <target state="translated">다음을 실행하여 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bef2e3e3c561bbd31fb824f6e5488b7912edceba" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;limitations&lt;/a&gt; on user namespaces to be sure your use case is possible.</source>
          <target state="translated">사용자 네임 스페이스 의 &lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;제한 사항&lt;/a&gt; 을 확인하여 사용 사례가 가능한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dacb428fe895b728c75fb68f86ab4a8f7dbf6293" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;Hello World&lt;/code&gt; message in a web browser again, and refresh to see the count increment.</source>
          <target state="translated">체크 &lt;code&gt;Hello World&lt;/code&gt; 다시 웹 브라우저에서 메시지를 카운트 증가를보고 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="36eeeb0689ba8b725486b43f278608eb18b0a7a0" translate="yes" xml:space="preserve">
          <source>Check the installation by displaying the Machine version:</source>
          <target state="translated">머신 버전을 표시하여 설치를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d35d5bd251abfed6056958e2b3d5a462986790e9" translate="yes" xml:space="preserve">
          <source>Check the web page at one of your nodes, such as &lt;code&gt;http://192.168.99.101&lt;/code&gt;, and take a look at the results of the visitor counter, which is now live and storing information on Redis.</source>
          <target state="translated">&lt;code&gt;http://192.168.99.101&lt;/code&gt; 과 같은 노드 중 하나의 웹 페이지를 확인하고 현재 방문하고 Redis에 정보를 저장하는 방문자 카운터의 결과를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="19d4ff6105858c4d97705c73b3992c4b1b7ddcd0" translate="yes" xml:space="preserve">
          <source>Check to prove that the delegation (Signer) now contains multiple Key IDs.</source>
          <target state="translated">위임 (서명자)에 여러 키 ID가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dd7fb0e59434adcd7432fe8c5a2ab288ba10d6e1" translate="yes" xml:space="preserve">
          <source>Check to prove that there are now 2 delegations (Signer).</source>
          <target state="translated">이제 2 개의 위임 (서명자)이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8304b78473d74216c35214672be4e65436320aaa" translate="yes" xml:space="preserve">
          <source>Cherry-pick particular tags</source>
          <target state="translated">체리 픽 특정 태그</target>
        </trans-unit>
        <trans-unit id="e77d754fed24a2c4b721366e8f41348f91322b91" translate="yes" xml:space="preserve">
          <source>Child commands</source>
          <target state="translated">자식 명령</target>
        </trans-unit>
        <trans-unit id="7151c214aba2dc1de22be22f99af83bac16dc14f" translate="yes" xml:space="preserve">
          <source>Choose a passphrase</source>
          <target state="translated">암호를 선택하십시오</target>
        </trans-unit>
        <trans-unit id="45b9ce6e2d695ff2c034093f4531d40c366e7b04" translate="yes" xml:space="preserve">
          <source>Choose an option</source>
          <target state="translated">옵션을 선택하세요</target>
        </trans-unit>
        <trans-unit id="a93c8ad4b394423a7c05f2cb2af56afa2ae1869d" translate="yes" xml:space="preserve">
          <source>Clean up (--rm)</source>
          <target state="translated">정리 (--rm)</target>
        </trans-unit>
        <trans-unit id="f45ee3cc149fd4de8b1ee347a8389efb3a5d068e" translate="yes" xml:space="preserve">
          <source>Clean up your sandbox</source>
          <target state="translated">샌드 박스 정리</target>
        </trans-unit>
        <trans-unit id="e918bbd989b5f3b69dde492dafde6c2f175ff7ef" translate="yes" xml:space="preserve">
          <source>Cleanup and reboot</source>
          <target state="translated">정리 및 재부팅</target>
        </trans-unit>
        <trans-unit id="cb1e4c2ca89462e8328c3bc0974bfcad78bf7b59" translate="yes" xml:space="preserve">
          <source>Click &lt;strong&gt;Create Virtual Switch&lt;/strong&gt; of type &lt;strong&gt;External&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;외부&lt;/strong&gt; 유형의 &lt;strong&gt;가상 스위치 작성을&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec31a3779162b65d297fd11bad098abb602ccb1c" translate="yes" xml:space="preserve">
          <source>Click &lt;strong&gt;Generate new token&lt;/strong&gt; to get to the token generator.</source>
          <target state="translated">&lt;strong&gt;새 토큰 생성을&lt;/strong&gt; 클릭 하여 토큰 생성기로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="8ab06144aed875f75ec3896dbc0f68618718e88d" translate="yes" xml:space="preserve">
          <source>Click &lt;strong&gt;Virtual Switch Manager&lt;/strong&gt; in the right-hand menu</source>
          <target state="translated">오른쪽 메뉴에서 &lt;strong&gt;Virtual Switch Manager&lt;/strong&gt; 를 클릭하십시오</target>
        </trans-unit>
        <trans-unit id="c2be7013749cabd978b773cdb7f235f2c74db5f1" translate="yes" xml:space="preserve">
          <source>Client Enforcement with Docker Content Trust</source>
          <target state="translated">Docker Content Trust를 사용하여 클라이언트 적용</target>
        </trans-unit>
        <trans-unit id="6bd793bd42bd6c765be60ff70e7463a544f0c59c" translate="yes" xml:space="preserve">
          <source>Client modes</source>
          <target state="translated">클라이언트 모드</target>
        </trans-unit>
        <trans-unit id="38947f88b77d32fe42a376ebe43953f3317fb2ac" translate="yes" xml:space="preserve">
          <source>Clients both with and without pinned trust would be vulnerable to these attacks, so long as the attacker ensures that the version number of their malicious metadata is higher than the version number of the most recent good metadata that any client may have.</source>
          <target state="translated">공격자가 악의적 인 메타 데이터의 버전 번호가 모든 클라이언트가 보유한 최신의 양호한 메타 데이터의 버전 번호보다 높은 것을 확인하는 한, 고정 된 신뢰가 있거나없는 클라이언트는 이러한 공격에 취약합니다.</target>
        </trans-unit>
        <trans-unit id="3484854f932fb32a11cd731540813de173cab0e0" translate="yes" xml:space="preserve">
          <source>Clone the Notary repository.</source>
          <target state="translated">Notary 저장소를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="becd6dae52b2df153aa08d2d6f44756bb498c1b3" translate="yes" xml:space="preserve">
          <source>Column name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="2d23d7e0e385f27dfb197e48cf6a729c5b08bad4" translate="yes" xml:space="preserve">
          <source>Combining &lt;code&gt;--restart&lt;/code&gt; (restart policy) with the &lt;code&gt;--rm&lt;/code&gt; (clean up) flag results in an error. On container restart, attached clients are disconnected. See the examples on using the &lt;a href=&quot;#clean-up-rm&quot;&gt;&lt;code&gt;--rm&lt;/code&gt; (clean up)&lt;/a&gt; flag later in this page.</source>
          <target state="translated">&lt;code&gt;--restart&lt;/code&gt; (재시작 정책)를 &lt;code&gt;--rm&lt;/code&gt; (정리) 플래그 와 결합 하면 오류가 발생합니다. 컨테이너를 다시 시작하면 연결된 클라이언트의 연결이 끊어집니다. 이 페이지 뒷부분에서 &lt;a href=&quot;#clean-up-rm&quot;&gt; &lt;code&gt;--rm&lt;/code&gt; (정리)&lt;/a&gt; 플래그 사용에 대한 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="255684026a493948394aa6e99f5955d85240c000" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;[]string&lt;/code&gt;</source>
          <target state="translated">명령 &lt;code&gt;[]string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c3a4cb0e8d5bdf5fa5b450b5630968ed5d200fa" translate="yes" xml:space="preserve">
          <source>Command line arguments to &lt;code&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt; will be appended after all elements in an &lt;em&gt;exec&lt;/em&gt; form &lt;code&gt;ENTRYPOINT&lt;/code&gt;, and will override all elements specified using &lt;code&gt;CMD&lt;/code&gt;. This allows arguments to be passed to the entry point, i.e., &lt;code&gt;docker run &amp;lt;image&amp;gt; -d&lt;/code&gt; will pass the &lt;code&gt;-d&lt;/code&gt; argument to the entry point. You can override the &lt;code&gt;ENTRYPOINT&lt;/code&gt; instruction using the &lt;code&gt;docker run --entrypoint&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt; 에 대한 명령 행 인수 는 &lt;code&gt;ENTRYPOINT&lt;/code&gt; &lt;em&gt;exec&lt;/em&gt; 양식의 모든 요소 뒤에 추가 되며 &lt;code&gt;CMD&lt;/code&gt; 를 사용하여 지정된 모든 요소를 ​​대체합니다 . 이를 통해 인수를 시작점으로 전달할 수 있습니다. 즉, &lt;code&gt;docker run &amp;lt;image&amp;gt; -d&lt;/code&gt; 는 &lt;code&gt;-d&lt;/code&gt; 인수를 시작점으로 전달합니다 . &lt;code&gt;docker run --entrypoint&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 명령을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f927f97e16b666d22e83e4b3be801cba873d9cc9" translate="yes" xml:space="preserve">
          <source>Command line flags</source>
          <target state="translated">명령 줄 플래그</target>
        </trans-unit>
        <trans-unit id="4b467d9a7efae69bd2e2955753860f0739e2c14d" translate="yes" xml:space="preserve">
          <source>Command line reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2b2838fef4e3d547080ec519b87a3653aa0758" translate="yes" xml:space="preserve">
          <source>Command options overview and help</source>
          <target state="translated">명령 옵션 개요 및 도움말</target>
        </trans-unit>
        <trans-unit id="94ccff13e302b3dec25077fee024719c64593150" translate="yes" xml:space="preserve">
          <source>Command that was used to create the image</source>
          <target state="translated">이미지를 만드는 데 사용 된 명령</target>
        </trans-unit>
        <trans-unit id="3b75ee9273d0b462d108b0dd8dfa630aa1b9b6e3" translate="yes" xml:space="preserve">
          <source>Command to run in service containers.</source>
          <target state="translated">서비스 컨테이너에서 실행하는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="4197740bef0960d67e4b2527c866cf25ac14a496" translate="yes" xml:space="preserve">
          <source>Command to run to check health</source>
          <target state="translated">상태를 확인하기 위해 실행하는 명령</target>
        </trans-unit>
        <trans-unit id="0158aa873485eb1569f3f06229005153ec03c380" translate="yes" xml:space="preserve">
          <source>Command-line changes</source>
          <target state="translated">명령 줄 변경</target>
        </trans-unit>
        <trans-unit id="36445bce193e3cada4ed3f6d24054222a746b990" translate="yes" xml:space="preserve">
          <source>Command-line completion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6085c1607f75bdd88560bcdb0f3dd9c80875db" translate="yes" xml:space="preserve">
          <source>Commands that follow this style are:</source>
          <target state="translated">이 스타일을 따르는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ec444230a3c0b36871d72148d6f3fd455f71097" translate="yes" xml:space="preserve">
          <source>Commands with flags work as well:</source>
          <target state="translated">플래그가있는 명령도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa47400dc5d6b8df67eb65c405958ea3b25950c3" translate="yes" xml:space="preserve">
          <source>Commands you use with &lt;code&gt;run&lt;/code&gt; start in new containers with configuration defined by that of the service, including volumes, links, and other details. However, there are two important differences.</source>
          <target state="translated">볼륨, 링크 및 기타 세부 사항을 포함하여 서비스 구성으로 정의 된 구성 을 사용하여 새 컨테이너에서 &lt;code&gt;run&lt;/code&gt; start 와 함께 사용하는 명령 . 그러나 두 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce8ea109d558bbcd1a98eb56cc3dab6f35f72b2" translate="yes" xml:space="preserve">
          <source>Comment for image</source>
          <target state="translated">이미지에 대한 의견</target>
        </trans-unit>
        <trans-unit id="f9721ef9c0a6422cd07cca1f0a06b7fab54c1907" translate="yes" xml:space="preserve">
          <source>Commit Used</source>
          <target state="translated">커밋 사용</target>
        </trans-unit>
        <trans-unit id="712f5914e316c02a22f0b31e36138034fd2878d3" translate="yes" xml:space="preserve">
          <source>Commit a container</source>
          <target state="translated">컨테이너 커밋</target>
        </trans-unit>
        <trans-unit id="e4e0ec028044ecb1d01e4b4f939c288997f0d197" translate="yes" xml:space="preserve">
          <source>Commit a container with new &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;EXPOSE&lt;/code&gt; instructions</source>
          <target state="translated">새로운 &lt;code&gt;CMD&lt;/code&gt; 및 &lt;code&gt;EXPOSE&lt;/code&gt; 지침 으로 컨테이너 커밋</target>
        </trans-unit>
        <trans-unit id="f7fd9771a4d3d4d3ae543f79413b8f7271b73add" translate="yes" xml:space="preserve">
          <source>Commit a container with new configurations</source>
          <target state="translated">새로운 구성으로 컨테이너 커밋</target>
        </trans-unit>
        <trans-unit id="a635957687d394ed8eb32dd7af4e9fb9ea45ae9c" translate="yes" xml:space="preserve">
          <source>Commit message</source>
          <target state="translated">커밋 메시지</target>
        </trans-unit>
        <trans-unit id="2e0131c378cd8f204b7d74bded69a39a62adcc40" translate="yes" xml:space="preserve">
          <source>Common use cases</source>
          <target state="translated">일반적인 사용 사례</target>
        </trans-unit>
        <trans-unit id="1519ab42528ad477c8b67f839c957ecdfd3a1c85" translate="yes" xml:space="preserve">
          <source>Compared to the default &lt;code&gt;bridge&lt;/code&gt; mode, the &lt;code&gt;host&lt;/code&gt; mode gives &lt;em&gt;significantly&lt;/em&gt; better networking performance since it uses the host&amp;rsquo;s native networking stack whereas the bridge has to go through one level of virtualization through the docker daemon. It is recommended to run containers in this mode when their networking performance is critical, for example, a production Load Balancer or a High Performance Web Server.</source>
          <target state="translated">기본 &lt;code&gt;bridge&lt;/code&gt; 모드 와 비교 하여 &lt;code&gt;host&lt;/code&gt; 모드는 호스트의 기본 네트워킹 스택을 사용하므로 브리지는 docker 데몬을 통해 한 수준의 가상화를 거쳐야하므로 네트워킹 성능이 &lt;em&gt;크게&lt;/em&gt; 향상됩니다. 프로덕션로드 밸런서 또는 고성능 웹 서버와 같이 네트워킹 성능이 중요한 경우이 모드에서 컨테이너를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd9e5420dea4b8056efc1bac98c632bc471f8ccc" translate="yes" xml:space="preserve">
          <source>Compatibility matrix</source>
          <target state="translated">호환성 매트릭스</target>
        </trans-unit>
        <trans-unit id="d8347536c83b0d123d4fbad5b8e521b5822871d9" translate="yes" xml:space="preserve">
          <source>Compatibility mode</source>
          <target state="translated">호환 모드</target>
        </trans-unit>
        <trans-unit id="47da6f0838f083d3a01f384d483b468a305c5a2c" translate="yes" xml:space="preserve">
          <source>Compose</source>
          <target state="translated">Compose</target>
        </trans-unit>
        <trans-unit id="d4c1e5e1652c9203185b0dac590e6c9f90cfffc7" translate="yes" xml:space="preserve">
          <source>Compose CLI environment variables</source>
          <target state="translated">CLI 환경 변수 작성</target>
        </trans-unit>
        <trans-unit id="a5f6d815c097f8f59e86d02a2ff3305ddd3e6b1d" translate="yes" xml:space="preserve">
          <source>Compose File v3.4 and under</source>
          <target state="translated">파일 v3.4 이하 작성</target>
        </trans-unit>
        <trans-unit id="ede468b8d0ca5795ebe32bd5128b4f0dfdd28033" translate="yes" xml:space="preserve">
          <source>Compose File v3.5 and above</source>
          <target state="translated">파일 v3.5 이상 작성</target>
        </trans-unit>
        <trans-unit id="f554083073f17df98a1e4473b5d09ca5670f2e7e" translate="yes" xml:space="preserve">
          <source>Compose and Docker compatibility matrix</source>
          <target state="translated">작성 및 도커 호환성 매트릭스</target>
        </trans-unit>
        <trans-unit id="34131501fff0e2e2929c7f900e60c9e42c65f4b0" translate="yes" xml:space="preserve">
          <source>Compose builds and tags it with a generated name, and use that image thereafter.</source>
          <target state="translated">작성은 생성 된 이름으로 빌드하고 태그를 지정한 후 그 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f43f2c8ee00c8071cba3be0c8dd4bb010c270263" translate="yes" xml:space="preserve">
          <source>Compose builds and tags it with a generated name, and uses that image thereafter.</source>
          <target state="translated">작성은 생성 된 이름으로 빌드하고 태그를 지정한 후 그 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8bdafad6a741f1f3d2f3e5619c920a256f8b3245" translate="yes" xml:space="preserve">
          <source>Compose caches the configuration used to create a container. When you restart a service that has not changed, Compose re-uses the existing containers. Re-using containers means that you can make changes to your environment very quickly.</source>
          <target state="translated">작성은 컨테이너를 작성하는 데 사용 된 구성을 캐시합니다. 변경되지 않은 서비스를 다시 시작하면 Compose는 기존 컨테이너를 재사용합니다. 컨테이너를 재사용하면 환경을 매우 빠르게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc930e64f16fd341dc07e516db00c19ea88f2bc0" translate="yes" xml:space="preserve">
          <source>Compose can also be run inside a container, from a small bash script wrapper. To install compose as a container run this command:</source>
          <target state="translated">작은 bash 스크립트 래퍼에서 컨테이너 내부에서 작성을 실행할 수도 있습니다. 컨테이너로 작성을 설치하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9978d0ebff1d2373fdf9e9cbf4d9d70a24b2c365" translate="yes" xml:space="preserve">
          <source>Compose can be installed from &lt;a href=&quot;https://pypi.python.org/pypi/docker-compose&quot;&gt;pypi&lt;/a&gt; using &lt;code&gt;pip&lt;/code&gt;. If you install using &lt;code&gt;pip&lt;/code&gt;, we recommend that you use a &lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;virtualenv&lt;/a&gt; because many operating systems have python system packages that conflict with docker-compose dependencies. See the &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;virtualenv tutorial&lt;/a&gt; to get started.</source>
          <target state="translated">&lt;code&gt;pip&lt;/code&gt; 를 사용하여 &lt;a href=&quot;https://pypi.python.org/pypi/docker-compose&quot;&gt;pypi&lt;/a&gt; 에서 작성을 설치할 수 있습니다 . &lt;code&gt;pip&lt;/code&gt; 를 사용하여 설치하는 경우 많은 운영 체제에 docker-compose 종속성과 충돌하는 Python 시스템 패키지가 있으므로 &lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;virtualenv&lt;/a&gt; 를 사용하는 것이 좋습니다 . 시작 하려면 &lt;a href=&quot;http://docs.python-guide.org/en/latest/dev/virtualenvs/&quot;&gt;virtualenv 튜토리얼&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d071ac46ca55130538e4e63b76ed22dcc1835f4" translate="yes" xml:space="preserve">
          <source>Compose can be used in many different ways. Some common use cases are outlined below.</source>
          <target state="translated">작성은 다양한 방법으로 사용될 수 있습니다. 일반적인 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39be4ce40abd066cedce36fe734b46c076381db9" translate="yes" xml:space="preserve">
          <source>Compose comes with &lt;a href=&quot;http://en.wikipedia.org/wiki/Command-line_completion&quot;&gt;command completion&lt;/a&gt; for the bash and zsh shell.</source>
          <target state="translated">작성은 bash 및 zsh 쉘에 대한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Command-line_completion&quot;&gt;명령 완료&lt;/a&gt; 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce1ce01b3b7d3dabc6eca5daf5450ad4876ed2d4" translate="yes" xml:space="preserve">
          <source>Compose command-line reference</source>
          <target state="translated">명령 행 참조 작성</target>
        </trans-unit>
        <trans-unit id="eaa6516c19b160e7cd7050a0912b5a095e89ac72" translate="yes" xml:space="preserve">
          <source>Compose configuration file reference</source>
          <target state="translated">구성 파일 참조 작성</target>
        </trans-unit>
        <trans-unit id="fb0c5018561dc54adab2ce3dd553936330dbdb70" translate="yes" xml:space="preserve">
          <source>Compose copies configurations from the original service over to the local one. If a configuration option is defined in both the original service and the local service, the local value &lt;em&gt;replaces&lt;/em&gt; or &lt;em&gt;extends&lt;/em&gt; the original value.</source>
          <target state="translated">작성은 원래 서비스에서 로컬 서비스로 구성을 복사합니다. 구성 옵션이 원래 서비스와 로컬 서비스 모두에 정의되어 있으면 로컬 값 이 원래 값을 &lt;em&gt;대체&lt;/em&gt; 하거나 &lt;em&gt;확장&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b78e4cfc09614792f61d82eda1e3388e3f31ac09" translate="yes" xml:space="preserve">
          <source>Compose documentation</source>
          <target state="translated">문서 작성</target>
        </trans-unit>
        <trans-unit id="c2ee48fa2aa8cd6ab55fa3df18408f4ae60243df" translate="yes" xml:space="preserve">
          <source>Compose does not give Swarm any specific scheduling instructions if a service uses only named volumes.</source>
          <target state="translated">서비스가 명명 된 볼륨 만 사용하는 경우 Compose는 Swarm에게 특정 예약 지침을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40928cd09f78232b15a856edf05aed9c21ab989f" translate="yes" xml:space="preserve">
          <source>Compose does not take advantage of &lt;a href=&quot;../../networking/index&quot;&gt;networking&lt;/a&gt; when you use version 1: every container is placed on the default &lt;code&gt;bridge&lt;/code&gt; network and is reachable from every other container at its IP address. You need to use &lt;a href=&quot;../compose-file-v1/index#links&quot;&gt;links&lt;/a&gt; to enable discovery between containers.</source>
          <target state="translated">Compose는 버전 1을 사용할 때 &lt;a href=&quot;../../networking/index&quot;&gt;네트워킹&lt;/a&gt; 을 이용하지 않습니다 . 모든 컨테이너는 기본 &lt;code&gt;bridge&lt;/code&gt; 네트워크 에 배치 되며 다른 모든 컨테이너의 IP 주소에서 도달 할 수 있습니다. 컨테이너 간 감지를 가능하게 하려면 &lt;a href=&quot;../compose-file-v1/index#links&quot;&gt;링크&lt;/a&gt; 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="77b11889093e95e7c53a40ca67fb512f4680c69b" translate="yes" xml:space="preserve">
          <source>Compose expects each line in an &lt;code&gt;env&lt;/code&gt; file to be in &lt;code&gt;VAR=VAL&lt;/code&gt; format.</source>
          <target state="translated">작성은 &lt;code&gt;env&lt;/code&gt; 파일의 각 행 이 &lt;code&gt;VAR=VAL&lt;/code&gt; 형식 일 것으로 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="015de808b3f22f273c9882ebcd68693529610759" translate="yes" xml:space="preserve">
          <source>Compose expects each line in an env file to be in &lt;code&gt;VAR=VAL&lt;/code&gt; format. Lines beginning with &lt;code&gt;#&lt;/code&gt; are processed as comments and are ignored. Blank lines are also ignored.</source>
          <target state="translated">작성은 env 파일의 각 행이 &lt;code&gt;VAR=VAL&lt;/code&gt; 형식 일 것으로 예상 합니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 주석으로 처리되며 무시됩니다. 빈 줄도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd79bf3a304d21bbf15e5bdc4c0dd5e7cdd63499" translate="yes" xml:space="preserve">
          <source>Compose expects each line in an env file to be in &lt;code&gt;VAR=VAL&lt;/code&gt; format. Lines beginning with &lt;code&gt;#&lt;/code&gt; are treated as comments and are ignored. Blank lines are also ignored.</source>
          <target state="translated">작성은 env 파일의 각 행이 &lt;code&gt;VAR=VAL&lt;/code&gt; 형식 일 것으로 예상 합니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 주석으로 취급되며 무시됩니다. 빈 줄도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a98ae9061fd805fb9bbd5cffd8e607458fba4d88" translate="yes" xml:space="preserve">
          <source>Compose file</source>
          <target state="translated">파일 작성</target>
        </trans-unit>
        <trans-unit id="7f7358ebe3ab02121530cac1e994e6b9f4e2f10f" translate="yes" xml:space="preserve">
          <source>Compose file and CLI variables</source>
          <target state="translated">파일 및 CLI 변수 작성</target>
        </trans-unit>
        <trans-unit id="f8475644c4fa3f29c6d625557f27919636334593" translate="yes" xml:space="preserve">
          <source>Compose file format references</source>
          <target state="translated">파일 형식 참조 작성</target>
        </trans-unit>
        <trans-unit id="710a68559e0d07669ddb5ec0c372036582d40b58" translate="yes" xml:space="preserve">
          <source>Compose file reference</source>
          <target state="translated">파일 참조 작성</target>
        </trans-unit>
        <trans-unit id="736373394fa8035c0a458ab0c80a67671692b263" translate="yes" xml:space="preserve">
          <source>Compose file structure and examples</source>
          <target state="translated">파일 구조 및 예제 작성</target>
        </trans-unit>
        <trans-unit id="d3609ce98d4150148cc62e8846ce191b5bf70705" translate="yes" xml:space="preserve">
          <source>Compose file version 1</source>
          <target state="translated">파일 버전 1 작성</target>
        </trans-unit>
        <trans-unit id="9b5e92b17043849cc9be5fdef48d55b213ba154c" translate="yes" xml:space="preserve">
          <source>Compose file version 1 reference</source>
          <target state="translated">파일 버전 1 참조 작성</target>
        </trans-unit>
        <trans-unit id="2f10b70dd88a4e31ddefbd1e7db817315d901c80" translate="yes" xml:space="preserve">
          <source>Compose file version 2</source>
          <target state="translated">파일 버전 2 작성</target>
        </trans-unit>
        <trans-unit id="820560bb1436716124355bf4751d66f2b41846d0" translate="yes" xml:space="preserve">
          <source>Compose file version 2 reference</source>
          <target state="translated">파일 버전 2 참조 작성</target>
        </trans-unit>
        <trans-unit id="9bf14b8307392cfae07d9d1098d0f6a7184c963f" translate="yes" xml:space="preserve">
          <source>Compose file version 3</source>
          <target state="translated">파일 버전 3 작성</target>
        </trans-unit>
        <trans-unit id="0c18f108ef1c5fee3294239c5a6c73d1abe3b7ef" translate="yes" xml:space="preserve">
          <source>Compose file version 3 reference</source>
          <target state="translated">파일 버전 3 참조 작성</target>
        </trans-unit>
        <trans-unit id="28519625026da3a01ddf395d19725d2ddf9d6506" translate="yes" xml:space="preserve">
          <source>Compose file versions and upgrading</source>
          <target state="translated">파일 버전 작성 및 업그레이드</target>
        </trans-unit>
        <trans-unit id="0de01e2191940c632830c64a7b2fa5db56aa391c" translate="yes" xml:space="preserve">
          <source>Compose files that do not declare a version are considered &amp;ldquo;version 1&amp;rdquo;. In those files, all the &lt;a href=&quot;../index#service-configuration-reference&quot;&gt;services&lt;/a&gt; are declared at the root of the document.</source>
          <target state="translated">버전을 선언하지 않은 작성 파일은&amp;ldquo;버전 1&amp;rdquo;로 간주됩니다. 이러한 파일에서 모든 &lt;a href=&quot;../index#service-configuration-reference&quot;&gt;서비스&lt;/a&gt; 는 문서의 루트에 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="e7d93af396e2115fe58e411ba710b0891a38adf6" translate="yes" xml:space="preserve">
          <source>Compose files using the version 2 syntax must indicate the version number at the root of the document. All &lt;a href=&quot;../compose-file-v2/index#service-configuration-reference&quot;&gt;services&lt;/a&gt; must be declared under the &lt;code&gt;services&lt;/code&gt; key.</source>
          <target state="translated">버전 2 구문을 사용하여 파일을 작성하면 문서 루트에 버전 번호가 표시되어야합니다. 모든 &lt;a href=&quot;../compose-file-v2/index#service-configuration-reference&quot;&gt;서비스&lt;/a&gt; 는 &lt;code&gt;services&lt;/code&gt; 키로 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf6bf130e3cee06b6fd1466fd08c297df124a2a" translate="yes" xml:space="preserve">
          <source>Compose has commands for managing the whole lifecycle of your application:</source>
          <target state="translated">작성에는 애플리케이션의 전체 수명주기를 관리하는 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0047866a9df5a3ee0faaab104145a2dc641da9ac" translate="yes" xml:space="preserve">
          <source>Compose has traditionally been focused on development and testing workflows, but with each release we&amp;rsquo;re making progress on more production-oriented features. You can use Compose to deploy to a remote Docker Engine. The Docker Engine may be a single instance provisioned with &lt;a href=&quot;../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; or an entire &lt;a href=&quot;../engine/swarm/index&quot;&gt;Docker Swarm&lt;/a&gt; cluster.</source>
          <target state="translated">Compose는 전통적으로 개발 및 테스트 워크 플로에 중점을 두었지만 각 릴리스마다보다 생산 지향적 인 기능을 개발하고 있습니다. Compose를 사용하여 원격 Docker Engine에 배포 할 수 있습니다. Docker Engine은 &lt;a href=&quot;../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; 또는 전체 &lt;a href=&quot;../engine/swarm/index&quot;&gt;Docker Swarm&lt;/a&gt; 클러스터로 프로비저닝 된 단일 인스턴스 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23b7fcc289bc9f4e64dc1869a26dc62f576346be" translate="yes" xml:space="preserve">
          <source>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application&amp;rsquo;s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see &lt;a href=&quot;index#features&quot;&gt;the list of features&lt;/a&gt;.</source>
          <target state="translated">작성은 다중 컨테이너 Docker 애플리케이션을 정의하고 실행하기위한 도구입니다. Compose에서는 YAML 파일을 사용하여 응용 프로그램 서비스를 구성합니다. 그런 다음 단일 명령으로 구성에서 모든 서비스를 작성하고 시작합니다. Compose의 모든 기능에 대한 자세한 내용은 기능 &lt;a href=&quot;index#features&quot;&gt;목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2387269a0a4d5f641373450e81f1dd6565f3d1d7" translate="yes" xml:space="preserve">
          <source>Compose preserves all volumes used by your services. When &lt;code&gt;docker-compose up&lt;/code&gt; runs, if it finds any containers from previous runs, it copies the volumes from the old container to the new container. This process ensures that any data you&amp;rsquo;ve created in volumes isn&amp;rsquo;t lost.</source>
          <target state="translated">작성은 서비스에서 사용하는 모든 볼륨을 유지합니다. 때 &lt;code&gt;docker-compose up&lt;/code&gt; 은 이전 실행에서 모든 컨테이너를 발견하면, 실행을 복사합니다 새 컨테이너에 기존 컨테이너에서 볼륨. 이 프로세스는 볼륨에서 생성 한 모든 데이터가 손실되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b3d9cc51d6c852c2f6e8b0b1d6585b0841e21fb3" translate="yes" xml:space="preserve">
          <source>Compose pulls a Redis image, builds an image for your code, and starts the services you defined. In this case, the code is statically copied into the image at build time.</source>
          <target state="translated">Compose는 Redis 이미지를 가져 와서 코드 이미지를 작성하고 정의한 서비스를 시작합니다. 이 경우 코드는 빌드시 이미지에 정적으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb7e80ee28d04009047168bf97e999f5bff7f9f" translate="yes" xml:space="preserve">
          <source>Compose stop attempts to stop a container by sending a &lt;code&gt;SIGTERM&lt;/code&gt;. It then waits for a &lt;a href=&quot;../reference/stop/index&quot;&gt;default timeout of 10 seconds&lt;/a&gt;. After the timeout, a &lt;code&gt;SIGKILL&lt;/code&gt; is sent to the container to forcefully kill it. If you are waiting for this timeout, it means that your containers aren&amp;rsquo;t shutting down when they receive the &lt;code&gt;SIGTERM&lt;/code&gt; signal.</source>
          <target state="translated">작성 중지는 &lt;code&gt;SIGTERM&lt;/code&gt; 을 보내 컨테이너를 중지하려고 시도합니다 . 그런 다음 &lt;a href=&quot;../reference/stop/index&quot;&gt;기본 시간 초과 인 10 초 동안&lt;/a&gt; 기다립니다 . 시간 초과 후 &lt;code&gt;SIGKILL&lt;/code&gt; 이 컨테이너로 전송되어 강제 종료 됩니다. 이 시간 초과를 기다리는 경우 컨테이너가 &lt;code&gt;SIGTERM&lt;/code&gt; 신호 를 수신 할 때 컨테이너가 종료되지 않았 음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e8a72bd9db2df54291aa5d31eec9bb4133649688" translate="yes" xml:space="preserve">
          <source>Compose supports declaring default environment variables in an environment file named &lt;code&gt;.env&lt;/code&gt; placed in the folder where the &lt;code&gt;docker-compose&lt;/code&gt; command is executed &lt;em&gt;(current working directory)&lt;/em&gt;.</source>
          <target state="translated">Compose는 &lt;code&gt;docker-compose&lt;/code&gt; 명령이 실행되는 폴더 &lt;em&gt;(현재 작업 디렉토리)&lt;/em&gt; 에있는 &lt;code&gt;.env&lt;/code&gt; 환경 파일에서 기본 환경 변수 선언을 지원합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e77e4f0d412182251ba07b779b9341d6dcc638be" translate="yes" xml:space="preserve">
          <source>Compose supports two methods of sharing common configuration:</source>
          <target state="translated">작성은 공통 구성을 공유하는 두 가지 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="59c27cff0aec47d16c67a7bb4fdc25bb9c7db167" translate="yes" xml:space="preserve">
          <source>Compose supports variables in the Compose file. You can use these variables to customize your composition for different environments, or different users. See &lt;a href=&quot;compose-file/index#variable-substitution&quot;&gt;Variable substitution&lt;/a&gt; for more details.</source>
          <target state="translated">작성은 작성 파일의 변수를 지원합니다. 이 변수를 사용하여 다른 환경 또는 다른 사용자에 맞게 컴포지션을 사용자 정의 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;compose-file/index#variable-substitution&quot;&gt;변수 대체&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75a2b24b028cf55b29c10a1ad79b8305ccf43f4d" translate="yes" xml:space="preserve">
          <source>Compose uses &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker links&lt;/a&gt; to expose services&amp;rsquo; containers to one another. Each linked container injects a set of environment variables, each of which begins with the uppercase name of the container.</source>
          <target state="translated">Compose는 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker 링크&lt;/a&gt; 를 사용 하여 서비스 컨테이너를 서로 노출시킵니다. 링크 된 각 컨테이너는 컨테이너의 대문자 이름으로 시작하는 환경 변수 세트를 주입합니다.</target>
        </trans-unit>
        <trans-unit id="60d9eed33ea388c450611acb15e1107146efd8e5" translate="yes" xml:space="preserve">
          <source>Compose uses a project name to isolate environments from each other. You can make use of this project name in several different contexts:</source>
          <target state="translated">작성은 프로젝트 이름을 사용하여 환경을 서로 분리합니다. 여러 프로젝트에서이 프로젝트 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc03c49509aaa7cd2e9775747d09c68fb95c3961" translate="yes" xml:space="preserve">
          <source>Compose uses an alternate file to build with. A build path must also be specified.</source>
          <target state="translated">작성은 대체 파일을 사용하여 빌드합니다. 빌드 경로도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="335079a8bd1e39bbb51752d33b8640de1dc1a819" translate="yes" xml:space="preserve">
          <source>Compose uses the project name to create unique identifiers for all of a project&amp;rsquo;s containers and other resources. To run multiple copies of a project, set a custom project name using the &lt;a href=&quot;../reference/overview/index&quot;&gt;&lt;code&gt;-p&lt;/code&gt; command line option&lt;/a&gt; or the &lt;a href=&quot;../reference/envvars/index#compose-project-name&quot;&gt;&lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">Compose는 프로젝트 이름을 사용하여 모든 프로젝트 컨테이너 및 기타 리소스에 대한 고유 식별자를 만듭니다. 프로젝트의 여러 사본을 실행하려면 &lt;a href=&quot;../reference/overview/index&quot;&gt; &lt;code&gt;-p&lt;/code&gt; 명령 행 옵션&lt;/a&gt; 또는 &lt;a href=&quot;../reference/envvars/index#compose-project-name&quot;&gt; &lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; 환경 변수를&lt;/a&gt; 사용하여 사용자 정의 프로젝트 이름을 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4677d99d4ec04c83551d372aa46d0054562ee40c" translate="yes" xml:space="preserve">
          <source>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in &lt;a href=&quot;#common-use-cases&quot;&gt;Common Use Cases&lt;/a&gt;.</source>
          <target state="translated">Compose는 생산, 준비, 개발, 테스트 및 CI 워크 플로와 같은 모든 환경에서 작동합니다. &lt;a href=&quot;#common-use-cases&quot;&gt;일반적인 사용 사례&lt;/a&gt; 에서 각 사례에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88044713189110d01cf69b668ef6881189a2fc6a" translate="yes" xml:space="preserve">
          <source>Compose&amp;rsquo;s behaviour with regards to networking</source>
          <target state="translated">네트워킹과 관련하여 작성 동작</target>
        </trans-unit>
        <trans-unit id="9b01efc8e992a37c815bc682402afdc05ee53344" translate="yes" xml:space="preserve">
          <source>Compress the build context using gzip</source>
          <target state="translated">gzip을 사용하여 빌드 컨텍스트 압축</target>
        </trans-unit>
        <trans-unit id="e6728f24442370bd4b8f27c507420910564f6d49" translate="yes" xml:space="preserve">
          <source>Compress the context using gzip</source>
          <target state="translated">gzip을 사용하여 컨텍스트 압축</target>
        </trans-unit>
        <trans-unit id="178a38e3a0933385db96b62dbd2a3bed55d0031a" translate="yes" xml:space="preserve">
          <source>Conclusion of part one</source>
          <target state="translated">1 부 결론</target>
        </trans-unit>
        <trans-unit id="047a208658bcb3f40c5800707ee3385d93096ca1" translate="yes" xml:space="preserve">
          <source>Conclusion of part two</source>
          <target state="translated">2 부 결론</target>
        </trans-unit>
        <trans-unit id="b536777ff175ae7f0dadd5ccfd9e78c00761a19e" translate="yes" xml:space="preserve">
          <source>Conclusions</source>
          <target state="translated">Conclusions</target>
        </trans-unit>
        <trans-unit id="65439542dad4b5ca3c59e27058e232d5e29170b6" translate="yes" xml:space="preserve">
          <source>Concurrent downloads</source>
          <target state="translated">동시 다운로드</target>
        </trans-unit>
        <trans-unit id="01b57e7d93f2736be7c2dd2ef48f69250a2709d8" translate="yes" xml:space="preserve">
          <source>Concurrent uploads</source>
          <target state="translated">동시 업로드</target>
        </trans-unit>
        <trans-unit id="fe0b4a63aaece517fb22a46a542d2a71ac0e943d" translate="yes" xml:space="preserve">
          <source>Config Type</source>
          <target state="translated">구성 유형</target>
        </trans-unit>
        <trans-unit id="2d01a736370127aa619954131610d5831c62780d" translate="yes" xml:space="preserve">
          <source>Config files with custom targets are not directly bind-mounted into Windows containers, since Windows does not support non-directory file bind-mounts. Instead, configs for a container are all mounted in &lt;code&gt;C:\ProgramData\Docker\internal\configs&lt;/code&gt; (an implementation detail which should not be relied upon by applications) within the container. Symbolic links are used to point from there to the desired target of the config within the container. The default target is &lt;code&gt;C:\ProgramData\Docker\configs&lt;/code&gt;.</source>
          <target state="translated">Windows는 디렉토리가 아닌 파일 바인드 마운트를 지원하지 않기 때문에 사용자 정의 대상이있는 구성 파일은 Windows 컨테이너에 직접 바인드 마운트되지 않습니다. 대신 컨테이너의 구성은 모두 컨테이너 내의 &lt;code&gt;C:\ProgramData\Docker\internal\configs&lt;/code&gt; (애플리케이션이 의존하지 않아야하는 구현 세부 사항)에 마운트됩니다 . 심볼릭 링크는 컨테이너 내에서 원하는 구성 대상을 가리 키기 위해 사용됩니다. 기본 대상은 &lt;code&gt;C:\ProgramData\Docker\configs&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6fedf5f100e546178bcf0a38ad66aac064fdfa2" translate="yes" xml:space="preserve">
          <source>Config labels</source>
          <target state="translated">구성 라벨</target>
        </trans-unit>
        <trans-unit id="c4aa28bfc178add6f157a2e8fb00ba6673b1d826" translate="yes" xml:space="preserve">
          <source>Config provides the base accessible fields for working with V0 plugin format in the registry.</source>
          <target state="translated">Config는 레지스트리에서 V0 플러그인 형식으로 작업하기위한 기본 액세스 가능 필드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="c5abc2d9778f0bfd5625816dc85c107e7bd8f465" translate="yes" xml:space="preserve">
          <source>Configs are supported on both Linux and Windows services.</source>
          <target state="translated">구성은 Linux 및 Windows 서비스 모두에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ed995dab7d3e08b5669d05da768fccc5a73064b0" translate="yes" xml:space="preserve">
          <source>Configs operate in a similar way to &lt;a href=&quot;../secrets/index&quot;&gt;secrets&lt;/a&gt;, except that they are not encrypted at rest and are mounted directly into the container&amp;rsquo;s filesystem without the use of RAM disks. Configs can be added or removed from a service at any time, and services can share a config. You can even use configs in conjunction with environment variables or labels, for maximum flexibility. Config values can be generic strings or binary content (up to 500 kb in size).</source>
          <target state="translated">구성은 유휴 상태에서 암호화되지 않고 RAM 디스크를 사용하지 않고 컨테이너의 파일 시스템에 직접 마운트된다는 점을 제외하고는 &lt;a href=&quot;../secrets/index&quot;&gt;비밀&lt;/a&gt; 과 비슷한 방식으로 작동합니다 . 구성은 언제든지 서비스에서 추가하거나 제거 할 수 있으며 서비스는 구성을 공유 할 수 있습니다. 유연성을 극대화하기 위해 환경 변수 또는 레이블과 함께 구성을 사용할 수도 있습니다. 구성 값은 일반 문자열 또는 이진 컨텐츠 (최대 500kb) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e9e2d64c5e127c299b896e015cd2b7bb4f8b5d4" translate="yes" xml:space="preserve">
          <source>Configuration files</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="9a188f2e6ce2e96857bc638594f2b181b4888d6a" translate="yes" xml:space="preserve">
          <source>Configuration of VPCs is beyond the scope of this guide. However, the first step in troubleshooting is making sure that you are using private subnets that follow the design guidance in the &lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario2.html&quot;&gt;AWS VPC User Guide&lt;/a&gt; and have some form of NAT available so that the setup process can access the internet to complete the setup.</source>
          <target state="translated">VPC 구성은이 안내서에서 다루지 않습니다. 그러나 문제 해결의 첫 번째 단계는 &lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario2.html&quot;&gt;AWS VPC 사용 설명서&lt;/a&gt; 의 설계 지침에 따라 프라이빗 서브넷을 사용 하고 설정 프로세스가 인터넷에 액세스하여 설정을 완료 할 수 있도록 NAT 형식을 사용할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="10d5d70651fbbbcc9319e228c538db9fa8de8b62" translate="yes" xml:space="preserve">
          <source>Configuration options that are applied at build time.</source>
          <target state="translated">빌드시 적용되는 구성 옵션.</target>
        </trans-unit>
        <trans-unit id="df27974f2e1b86e430d22ba5e33f4d94774fa506" translate="yes" xml:space="preserve">
          <source>Configuration reload behavior</source>
          <target state="translated">구성 재로드 동작</target>
        </trans-unit>
        <trans-unit id="ea862023c249df8faaa69c49ec83969686159be9" translate="yes" xml:space="preserve">
          <source>Configuration sections common to the Notary Server and Signer</source>
          <target state="translated">Notary Server 및 Signer에 공통적 인 구성 섹션</target>
        </trans-unit>
        <trans-unit id="9d623b43cff61d4bceb474c013736d6cc186632a" translate="yes" xml:space="preserve">
          <source>Configuration sections common to the Notary server and signer</source>
          <target state="translated">Notary 서버 및 서명자에게 공통적 인 구성 섹션</target>
        </trans-unit>
        <trans-unit id="a87f797aeeff8890a10c896d239af13817176363" translate="yes" xml:space="preserve">
          <source>Configure CPU allocation parameters using the Docker daemon realtime scheduler.</source>
          <target state="translated">Docker 데몬 실시간 스케줄러를 사용하여 CPU 할당 매개 변수를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="93102a79cad36fa3fbb4aab8f6a2a97076f871a5" translate="yes" xml:space="preserve">
          <source>Configure Compose using environment variables</source>
          <target state="translated">환경 변수를 사용하여 작성 구성</target>
        </trans-unit>
        <trans-unit id="fdc461c6eab66327cd125df5305c6d48cc030aed" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;docker-machine&lt;/code&gt; shell to the swarm manager</source>
          <target state="translated">swarm manager에 대한 &lt;code&gt;docker-machine&lt;/code&gt; shell 구성</target>
        </trans-unit>
        <trans-unit id="84395a78bf9ce076df2fc21bca07ae9da1192ba1" translate="yes" xml:space="preserve">
          <source>Configure a check that&amp;rsquo;s run to determine whether or not containers for this service are &amp;ldquo;healthy&amp;rdquo;. See the docs for the &lt;a href=&quot;../../../engine/reference/builder/index#healthcheck&quot;&gt;HEALTHCHECK Dockerfile instruction&lt;/a&gt; for details on how healthchecks work.</source>
          <target state="translated">이 서비스의 컨테이너가 &quot;정상&quot;인지 확인하기 위해 실행되는 검사를 구성하십시오. 상태 확인 작동 방법에 대한 자세한 내용 은 &lt;a href=&quot;../../../engine/reference/builder/index#healthcheck&quot;&gt;HEALTHCHECK Dockerfile 지침에&lt;/a&gt; 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76afd1968c38665f6014eefeb689098646a1ac23" translate="yes" xml:space="preserve">
          <source>Configure a check that&amp;rsquo;s run to determine whether or not containers for this service are &amp;ldquo;healthy&amp;rdquo;. See the docs for the &lt;a href=&quot;../../engine/reference/builder/index#healthcheck&quot;&gt;HEALTHCHECK Dockerfile instruction&lt;/a&gt; for details on how healthchecks work.</source>
          <target state="translated">이 서비스의 컨테이너가 &quot;정상&quot;인지 확인하기 위해 실행되는 검사를 구성하십시오. 상태 확인 작동 방법에 대한 자세한 내용 은 &lt;a href=&quot;../../engine/reference/builder/index#healthcheck&quot;&gt;HEALTHCHECK Dockerfile 지침에&lt;/a&gt; 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d78fa93516b94be5dae69461a727f4104a4a8492" translate="yes" xml:space="preserve">
          <source>Configure a service&amp;rsquo;s update behavior</source>
          <target state="translated">서비스의 업데이트 동작 구성</target>
        </trans-unit>
        <trans-unit id="b06aa1f168051cc2eaad07a1ac719cfad361bfff" translate="yes" xml:space="preserve">
          <source>Configure an external load balancer</source>
          <target state="translated">외부로드 밸런서 구성</target>
        </trans-unit>
        <trans-unit id="27c9ce7c9c1f2880d7d46f94d35c33e22770a12f" translate="yes" xml:space="preserve">
          <source>Configure and activate Swarm if applicable.</source>
          <target state="translated">해당되는 경우 Swarm을 구성하고 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="7b89618af035d488d11b00c21886ce407760f8a0" translate="yes" xml:space="preserve">
          <source>Configure credential helpers</source>
          <target state="translated">자격 증명 도우미 구성</target>
        </trans-unit>
        <trans-unit id="b39658de11c52c9e607d5518126991cfa8d96dd4" translate="yes" xml:space="preserve">
          <source>Configure namespaced kernel parameters (sysctls) at runtime</source>
          <target state="translated">런타임시 네임 스페이스 커널 매개 변수 (sysctls) 구성</target>
        </trans-unit>
        <trans-unit id="0c04d4425fc15cb7ea1711e671df4b91d2667b9d" translate="yes" xml:space="preserve">
          <source>Configure sections common to Notary server and signer</source>
          <target state="translated">공증인 서버 및 서명자에게 공통적 인 섹션 구성</target>
        </trans-unit>
        <trans-unit id="372c5d54060d22a4631b9c25031d964069a116dd" translate="yes" xml:space="preserve">
          <source>Configure the Docker Engine according to the options specified at create time.</source>
          <target state="translated">작성시 지정된 옵션에 따라 Docker Engine을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5ebf0cd9d269ce6965ab190c53f11c7f4760aed9" translate="yes" xml:space="preserve">
          <source>Configure the Nginx container</source>
          <target state="translated">Nginx 컨테이너 구성</target>
        </trans-unit>
        <trans-unit id="72ef8b1661b7a52ba5b32b85cd364e93f18378aa" translate="yes" xml:space="preserve">
          <source>Configure the advertise address</source>
          <target state="translated">광고 주소 구성</target>
        </trans-unit>
        <trans-unit id="bf2078e2684d30a4f71b5ef15622827a1ea41ba5" translate="yes" xml:space="preserve">
          <source>Configure the client</source>
          <target state="translated">클라이언트 구성</target>
        </trans-unit>
        <trans-unit id="a54e95987e14875b6e3b160c0605bd6f5fd2092f" translate="yes" xml:space="preserve">
          <source>Configure the credential spec for managed service account. This option is only used for services using Windows containers. The &lt;code&gt;credential_spec&lt;/code&gt; must be in the format &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; or &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">관리 서비스 계정에 대한 자격 증명 사양을 구성하십시오. 이 옵션은 Windows 컨테이너를 사용하는 서비스에만 사용됩니다. &lt;code&gt;credential_spec&lt;/code&gt; 는 형식이어야합니다 &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a8023b690a298ff74a0a8bbfb9118daa89717c" translate="yes" xml:space="preserve">
          <source>Configure the credentials store</source>
          <target state="translated">신임 정보 저장소 구성</target>
        </trans-unit>
        <trans-unit id="6bba6b18d7f9f3ab5298916cf23f6a1664ba76b3" translate="yes" xml:space="preserve">
          <source>Configure the default network</source>
          <target state="translated">기본 네트워크 구성</target>
        </trans-unit>
        <trans-unit id="e8d108aedf7f5c4e1216e659739269d2b8eb0fc2" translate="yes" xml:space="preserve">
          <source>Configure the manager to advertise on a static IP address</source>
          <target state="translated">고정 IP 주소를 알리도록 관리자 구성</target>
        </trans-unit>
        <trans-unit id="7831eed2c45e2ad990a3cb3d7d4e5fce50642841" translate="yes" xml:space="preserve">
          <source>Configure the root CA. Edit a new file called &lt;code&gt;root-ca.cnf&lt;/code&gt; and paste the following contents into it. This constrains the root CA to only sign leaf certificates and not intermediate CAs.</source>
          <target state="translated">루트 CA를 구성하십시오. &lt;code&gt;root-ca.cnf&lt;/code&gt; 라는 새 파일을 편집 하여 다음 내용을 붙여 넣습니다. 이는 루트 CA가 중간 CA가 아닌 리프 인증서에만 서명하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="60bab647c17da19f78d15dc7676a9ebf2321b3c2" translate="yes" xml:space="preserve">
          <source>Configure the root CA. Edit a new file called &lt;code&gt;root-ca.cnf&lt;/code&gt; and paste the following contents into it. This constrains the root CA to signing leaf certificates and not intermediate CAs.</source>
          <target state="translated">루트 CA를 구성하십시오. &lt;code&gt;root-ca.cnf&lt;/code&gt; 라는 새 파일을 편집 하여 다음 내용을 붙여 넣습니다. 이로 인해 루트 CA가 중간 CA가 아닌 리프 인증서 서명에 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="24c847f58b707be853aaefa4d435b11e9db6417a" translate="yes" xml:space="preserve">
          <source>Configure the runtime environment</source>
          <target state="translated">런타임 환경 구성</target>
        </trans-unit>
        <trans-unit id="659705b2dd4dc3c147e891d974cc408bc1400f12" translate="yes" xml:space="preserve">
          <source>Configure the site certificate. Edit a new file called &lt;code&gt;site.cnf&lt;/code&gt; and paste the following contents into it. This constrains the site certificate so that it can only be used to authenticate a server and can&amp;rsquo;t be used to sign certificates.</source>
          <target state="translated">사이트 인증서를 구성하십시오. &lt;code&gt;site.cnf&lt;/code&gt; 라는 새 파일을 편집 하여 다음 내용을 붙여 넣습니다. 이렇게하면 사이트 인증서가 서버를 인증하는 데만 사용할 수 있고 인증서를 서명하는 데 사용될 수 없도록 사이트 인증서가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f42c4bcdef007713a0bc82b3e80afb6ba7a78e00" translate="yes" xml:space="preserve">
          <source>Configure which TLS version is used for TLS communication with the &lt;code&gt;docker&lt;/code&gt; daemon. Defaults to &lt;code&gt;TLSv1&lt;/code&gt;. Supported values are: &lt;code&gt;TLSv1&lt;/code&gt;, &lt;code&gt;TLSv1_1&lt;/code&gt;, &lt;code&gt;TLSv1_2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker&lt;/code&gt; 데몬 과의 TLS 통신에 사용되는 TLS 버전을 구성하십시오 . 기본값은 &lt;code&gt;TLSv1&lt;/code&gt; 입니다. 지원되는 값은 &lt;code&gt;TLSv1&lt;/code&gt; , &lt;code&gt;TLSv1_1&lt;/code&gt; , &lt;code&gt;TLSv1_2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05912d3f38f5a3826da18c02cd2b5271daafd461" translate="yes" xml:space="preserve">
          <source>Configures how the service should be rollbacked in case of a failing update.</source>
          <target state="translated">업데이트 실패시 서비스를 롤백하는 방법을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="189102b7b5755e5d8be08034702b31d299f0936a" translate="yes" xml:space="preserve">
          <source>Configures how the service should be updated. Useful for configuring rolling updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af597658cfde53aa6c566204a031a9c9fd9c277c" translate="yes" xml:space="preserve">
          <source>Configures if and how to restart containers when they exit. Replaces &lt;a href=&quot;compose-file-v2/index#orig-resources&quot;&gt;&lt;code&gt;restart&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨테이너가 종료 될 때 컨테이너를 다시 시작할지 여부와 방법을 구성합니다. &lt;a href=&quot;compose-file-v2/index#orig-resources&quot;&gt; &lt;code&gt;restart&lt;/code&gt; 를&lt;/a&gt; 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="ec569abdda69db41ca01b8e045000691de01ab92" translate="yes" xml:space="preserve">
          <source>Configures resource constraints.</source>
          <target state="translated">리소스 제약 조건을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="42aa9f169994c3a961d0487af2abe5c0b9643e3c" translate="yes" xml:space="preserve">
          <source>Configures the path to the &lt;code&gt;ca.pem&lt;/code&gt;, &lt;code&gt;cert.pem&lt;/code&gt;, and &lt;code&gt;key.pem&lt;/code&gt; files used for TLS verification. Defaults to &lt;code&gt;~/.docker&lt;/code&gt;.</source>
          <target state="translated">TLS 확인에 사용되는 &lt;code&gt;ca.pem&lt;/code&gt; , &lt;code&gt;cert.pem&lt;/code&gt; 및 &lt;code&gt;key.pem&lt;/code&gt; 파일 의 경로를 구성합니다 . 기본값은 &lt;code&gt;~/.docker&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="62e8db3681c497de080c377d097a08860ca647a0" translate="yes" xml:space="preserve">
          <source>Configures the time (in seconds) a request to the Docker daemon is allowed to hang before Compose considers it failed. Defaults to 60 seconds.</source>
          <target state="translated">Compose가 실패한 것으로 간주하기 전에 Docker 데몬에 대한 요청이 중단 될 수있는 시간 (초)을 구성합니다. 기본값은 60 초입니다.</target>
        </trans-unit>
        <trans-unit id="60cf8fe5d1ed26cb035e32ecf63b73bdd81e61b6" translate="yes" xml:space="preserve">
          <source>Configuring CLI environment variables for a Docker host</source>
          <target state="translated">Docker 호스트에 대한 CLI 환경 변수 구성</target>
        </trans-unit>
        <trans-unit id="f5715daf8a92aa33149aa5737dcc519b00a4a9e8" translate="yes" xml:space="preserve">
          <source>Configuring credentials</source>
          <target state="translated">신임 정보 구성</target>
        </trans-unit>
        <trans-unit id="8769ece908fe3bf79c25d961711eb6e0c2fce015" translate="yes" xml:space="preserve">
          <source>Configuring default address pools</source>
          <target state="translated">기본 주소 풀 구성</target>
        </trans-unit>
        <trans-unit id="9b38fba5bf4344973caa3e73b9112107ffbf07ab" translate="yes" xml:space="preserve">
          <source>Configuring the Docker Client</source>
          <target state="translated">Docker 클라이언트 구성</target>
        </trans-unit>
        <trans-unit id="0bde84edd5e9eb453b40e4f15761cb14a3800f7f" translate="yes" xml:space="preserve">
          <source>Configuring the Notary Client</source>
          <target state="translated">공증인 클라이언트 구성</target>
        </trans-unit>
        <trans-unit id="3b3836d9d12d6ea9f27574f7bb1ee200760c96a1" translate="yes" xml:space="preserve">
          <source>Confirm that the service is running with a single replica:</source>
          <target state="translated">서비스가 단일 복제본으로 실행되고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="db237e241428746dd6040cc370e2c1874db0af6c" translate="yes" xml:space="preserve">
          <source>Confirm the version and save scripts to &lt;code&gt;/etc/bash_completion.d&lt;/code&gt; or &lt;code&gt;/usr/local/etc/bash_completion.d&lt;/code&gt;:</source>
          <target state="translated">버전을 확인하고 스크립트를 &lt;code&gt;/etc/bash_completion.d&lt;/code&gt; 또는 &lt;code&gt;/usr/local/etc/bash_completion.d&lt;/code&gt; 에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e46c44eecd640a22f01999d3ba045b41e76ceac" translate="yes" xml:space="preserve">
          <source>Congrats! You just deployed a container secured with a custom apparmor profile!</source>
          <target state="translated">축하합니다! 사용자 정의 의류 프로파일로 보안 된 컨테이너를 방금 배포했습니다!</target>
        </trans-unit>
        <trans-unit id="36b2528eb5eba749498d236019d2276436d5415a" translate="yes" xml:space="preserve">
          <source>Congratulations!</source>
          <target state="translated">Congratulations!</target>
        </trans-unit>
        <trans-unit id="dba10908f987c2b93212bc7e72407e38ac2413f6" translate="yes" xml:space="preserve">
          <source>Congratulations, you are now running two Couchdb containers, completely isolated from each other &lt;em&gt;except&lt;/em&gt; for their data.</source>
          <target state="translated">축하합니다. 이제 데이터를 &lt;em&gt;제외하고&lt;/em&gt; 서로 완전히 분리 된 두 개의 Couchdb 컨테이너를 실행 중 입니다.</target>
        </trans-unit>
        <trans-unit id="dabbf35705b08e1f470dc7f998b2bb3de37ad9ad" translate="yes" xml:space="preserve">
          <source>Congratulations, you have created your first swarm!</source>
          <target state="translated">축하합니다. 첫 번째 떼를 만들었습니다!</target>
        </trans-unit>
        <trans-unit id="9de76d2a2299444190ddfbd29d76fca5ad916555" translate="yes" xml:space="preserve">
          <source>Connect a container to a network</source>
          <target state="translated">컨테이너를 네트워크에 연결</target>
        </trans-unit>
        <trans-unit id="3d79df6ab008958ca7df5955720642c450795801" translate="yes" xml:space="preserve">
          <source>Connect a container to a network (--network)</source>
          <target state="translated">컨테이너를 네트워크 (-네트워크)에 연결</target>
        </trans-unit>
        <trans-unit id="0a626f7ed091d7b6ea8c6d521bdfd2e1a0b07818" translate="yes" xml:space="preserve">
          <source>Connect a container to a network when it starts</source>
          <target state="translated">컨테이너가 시작될 때 네트워크에 연결</target>
        </trans-unit>
        <trans-unit id="994571ab97d668d02c0a6a76aaabb68430d6651e" translate="yes" xml:space="preserve">
          <source>Connect a running container to a network</source>
          <target state="translated">실행중인 컨테이너를 네트워크에 연결</target>
        </trans-unit>
        <trans-unit id="fa6d731f5795044a238652ef49352b46e6dd9127" translate="yes" xml:space="preserve">
          <source>Connect containers</source>
          <target state="translated">컨테이너 연결</target>
        </trans-unit>
        <trans-unit id="34cca06f6198ee8b266637860307bd6005b9da74" translate="yes" xml:space="preserve">
          <source>Connect from your host system</source>
          <target state="translated">호스트 시스템에서 연결</target>
        </trans-unit>
        <trans-unit id="9fdf6083671a9baa507335308de454ced28803f1" translate="yes" xml:space="preserve">
          <source>Connect the container to the bridge via veth interfaces.</source>
          <target state="translated">veth 인터페이스를 통해 컨테이너를 브리지에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="46e846bfbb41c6ce43181debb4226e8b5e5027bd" translate="yes" xml:space="preserve">
          <source>Connect the database</source>
          <target state="translated">데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="4cd363d031376c9fb1ec3f674400aa911ef5a175" translate="yes" xml:space="preserve">
          <source>Connect the service to an overlay network</source>
          <target state="translated">서비스를 오버레이 네트워크에 연결</target>
        </trans-unit>
        <trans-unit id="bb50c88d2b349b8a14a394f1942a991a338117c6" translate="yes" xml:space="preserve">
          <source>Connect your shell to the new machine.</source>
          <target state="translated">쉘을 새 머신에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="0efc656240b5a28f753f438f1f77b66270c74472" translate="yes" xml:space="preserve">
          <source>Connecting to VMs with &lt;code&gt;docker-machine env&lt;/code&gt; and &lt;code&gt;docker-machine ssh&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;docker-machine env&lt;/code&gt; 및 &lt;code&gt;docker-machine ssh&lt;/code&gt; 를 사용하여 VM에 연결</target>
        </trans-unit>
        <trans-unit id="c67996f7b143c083c5c6eb4a6a2f6203bd862d01" translate="yes" xml:space="preserve">
          <source>Connecting to the secure Docker port using &lt;code&gt;curl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 을 사용하여 보안 Docker 포트에 연결</target>
        </trans-unit>
        <trans-unit id="5ddc2b5d55922da766cdb960dd566a3c8e91fd8d" translate="yes" xml:space="preserve">
          <source>Connects a container to a network. You can connect a container by name or by ID. Once connected, the container can communicate with other containers in the same network.</source>
          <target state="translated">컨테이너를 네트워크에 연결합니다. 이름이나 ID로 컨테이너를 연결할 수 있습니다. 연결되면 컨테이너는 동일한 네트워크의 다른 컨테이너와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e66455c20f04dd1e1177f7c9fbac38cf21742180" translate="yes" xml:space="preserve">
          <source>Connects the container to a user created network (using &lt;code&gt;docker network create&lt;/code&gt; command)</source>
          <target state="translated">컨테이너를 사용자가 만든 네트워크에 연결합니다 ( &lt;code&gt;docker network create&lt;/code&gt; 명령 사용)</target>
        </trans-unit>
        <trans-unit id="b068ddfd8c3f790416fb90c3a0a0b165924a9896" translate="yes" xml:space="preserve">
          <source>Connects to the &lt;code&gt;mysql_private&lt;/code&gt; network so it can communicate with the &lt;code&gt;mysql&lt;/code&gt; container, and also publishes port 80 to port 30000 on all swarm nodes.</source>
          <target state="translated">&lt;code&gt;mysql_private&lt;/code&gt; 네트워크에 연결 하여 &lt;code&gt;mysql&lt;/code&gt; 컨테이너 와 통신하고 모든 swarm 노드에서 포트 80을 포트 30000에 게시합니다.</target>
        </trans-unit>
        <trans-unit id="b2a75ab6ecf709b9245ec9a65c0646fee5ff8e2e" translate="yes" xml:space="preserve">
          <source>Connects to the MySQL container using the username &lt;code&gt;wordpress&lt;/code&gt; and the password in &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt; and creates the &lt;code&gt;wordpress&lt;/code&gt; database if it does not yet exist.</source>
          <target state="translated">사용자 이름 &lt;code&gt;wordpress&lt;/code&gt; 와 &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt; 의 비밀번호를 사용하여 MySQL 컨테이너에 연결하고 아직없는 경우 &lt;code&gt;wordpress&lt;/code&gt; 데이터베이스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3db8434f7702be3f23839b03f566a7f331b477f4" translate="yes" xml:space="preserve">
          <source>Consecutive failures needed to report unhealthy</source>
          <target state="translated">건강에 해로운보고를 위해 연속적인 실패가 필요함</target>
        </trans-unit>
        <trans-unit id="91a77218118e7ead06e7cce011d8a62489b88c22" translate="yes" xml:space="preserve">
          <source>Consider a situation where your image starts a lightweight web server. You could use that image as a base image, copy in your website&amp;rsquo;s HTML files, and package that into another image. Each time your website changed, you&amp;rsquo;d need to update the new image and redeploy all of the containers serving your website. A better solution is to store the website in a named volume which is attached to each of your web server containers when they start. To update the website, you just update the named volume.</source>
          <target state="translated">이미지가 간단한 웹 서버를 시작하는 상황을 고려하십시오. 이 이미지를 기본 이미지로 사용하고 웹 사이트의 HTML 파일로 복사 한 다음 다른 이미지로 패키지화 할 수 있습니다. 웹 사이트가 변경 될 때마다 새 이미지를 업데이트하고 웹 사이트를 제공하는 모든 컨테이너를 재배치해야합니다. 더 나은 솔루션은 웹 사이트를 시작할 때 각 웹 서버 컨테이너에 연결된 명명 된 볼륨에 웹 사이트를 저장하는 것입니다. 웹 사이트를 업데이트하려면 명명 된 볼륨 만 업데이트하면됩니다.</target>
        </trans-unit>
        <trans-unit id="cca4084b2119f2d40f356f45cc33c8c51f442030" translate="yes" xml:space="preserve">
          <source>Consider a situation where your swarm is running as expected, then a manager node becomes unavailable. You troubleshoot the problem and bring the physical node back online, but you need to unlock the manager by providing the unlock key to read the encrypted credentials and Raft logs.</source>
          <target state="translated">웜이 예상대로 실행되고 관리자 노드를 사용할 수없는 상황을 고려하십시오. 문제점을 해결하고 물리적 노드를 온라인으로 다시 가져 오지만, 잠금 해제 키를 제공하여 암호화 된 신임 정보 및 Raft 로그를 읽으면 관리자의 잠금을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e4336cac658aad03ed3d7f39e28b5600f9b8c04" translate="yes" xml:space="preserve">
          <source>Consider another example under the same command line:</source>
          <target state="translated">동일한 명령 줄에서 다른 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a96423729bf8c93e804a21ee587de890d532a70b" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;code&gt;config.json&lt;/code&gt; file.</source>
          <target state="translated">다음 &lt;code&gt;config.json&lt;/code&gt; 파일을 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="bf910df441117104dea7e2b42694f1b732c96d07" translate="yes" xml:space="preserve">
          <source>Consider the following example which would fail in a non-obvious way on &lt;code&gt;Windows&lt;/code&gt;. The second &lt;code&gt;\&lt;/code&gt; at the end of the second line would be interpreted as an escape for the newline, instead of a target of the escape from the first &lt;code&gt;\&lt;/code&gt;. Similarly, the &lt;code&gt;\&lt;/code&gt; at the end of the third line would, assuming it was actually handled as an instruction, cause it be treated as a line continuation. The result of this dockerfile is that second and third lines are considered a single instruction:</source>
          <target state="translated">&lt;code&gt;Windows&lt;/code&gt; 에서 명백하지 않은 방식으로 실패하는 다음 예제를 고려하십시오 . 두 번째 &lt;code&gt;\&lt;/code&gt; 두 번째 줄의 끝에 대신 처음부터 탈출의 대상으로, 줄 바꿈에 대한 탈출로 해석됩니다 &lt;code&gt;\&lt;/code&gt; . 마찬가지로, 세 번째 줄의 끝에 있는 &lt;code&gt;\&lt;/code&gt; 는 실제로 명령으로 처리되었다고 가정 할 때 줄 연속으로 취급됩니다. 이 dockerfile의 결과는 두 번째 및 세 번째 행이 단일 명령으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="406c145a25565e04397d6ca3ea205bede6b0629e" translate="yes" xml:space="preserve">
          <source>Consider the following swarm, as seen from the manager:</source>
          <target state="translated">관리자가 보았을 때 다음 무리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="411768d7c15f6e0c773741ed83c248b075d4e432" translate="yes" xml:space="preserve">
          <source>Consult the &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Getting started with multi-host networking&lt;/a&gt; to see how to set up a Swarm cluster. The cluster uses the &lt;code&gt;overlay&lt;/code&gt; driver by default, but you can specify it explicitly if you prefer - see below for how to do this.</source>
          <target state="translated">는 상담 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;멀티 호스트 네트워킹 시작하기&lt;/a&gt; 떼 클러스터를 설정하는 방법을 참조하십시오. 클러스터는 기본적으로 &lt;code&gt;overlay&lt;/code&gt; 드라이버를 사용 하지만 원하는 경우 명시 적으로 지정할 수 있습니다.이를 수행하는 방법은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="7b07858cd8374b9a836d7cb699be5e5b240ba41c" translate="yes" xml:space="preserve">
          <source>Container (covered in &lt;a href=&quot;../part2/index&quot;&gt;part 2&lt;/a&gt;)</source>
          <target state="translated">컨테이너 ( &lt;a href=&quot;../part2/index&quot;&gt;2 부&lt;/a&gt; 에서 다루어 짐 )</target>
        </trans-unit>
        <trans-unit id="fab020546f97dd4838c561646252f367e697df9c" translate="yes" xml:space="preserve">
          <source>Container ID</source>
          <target state="translated">컨테이너 ID</target>
        </trans-unit>
        <trans-unit id="19f9eb327f9e48553729e16fcfbab276c6cd3084" translate="yes" xml:space="preserve">
          <source>Container IPv4/IPv6 link-local addresses</source>
          <target state="translated">컨테이너 IPv4 / IPv6 링크 로컬 주소</target>
        </trans-unit>
        <trans-unit id="589922b2ec53ee57db5ee6be63e67455c56dbd02" translate="yes" xml:space="preserve">
          <source>Container MAC address (e.g., 92:d0:c6:0a:29:33)</source>
          <target state="translated">컨테이너 MAC 주소 (예 : 92 : d0 : c6 ​​: 0a : 29 : 33)</target>
        </trans-unit>
        <trans-unit id="e9988fcc237bece1969394402c613c4340dc4bd1" translate="yes" xml:space="preserve">
          <source>Container NIS domain name</source>
          <target state="translated">컨테이너 NIS 도메인 이름</target>
        </trans-unit>
        <trans-unit id="dd2350293081c953b598956e829aa22abd8046ce" translate="yes" xml:space="preserve">
          <source>Container disk size.</source>
          <target state="translated">컨테이너 디스크 크기</target>
        </trans-unit>
        <trans-unit id="f22bf764b81b60ce32edb50d6ac6877ee25de96a" translate="yes" xml:space="preserve">
          <source>Container host name</source>
          <target state="translated">컨테이너 호스트 이름</target>
        </trans-unit>
        <trans-unit id="b98dea0976c0defb9abe714c9fa4599debfd33e4" translate="yes" xml:space="preserve">
          <source>Container hostname</source>
          <target state="translated">컨테이너 호스트 이름</target>
        </trans-unit>
        <trans-unit id="082a73c6636248e28fccfef6d6bf4df648919c19" translate="yes" xml:space="preserve">
          <source>Container identification</source>
          <target state="translated">컨테이너 식별</target>
        </trans-unit>
        <trans-unit id="0d2f38c8334e8e09e810f43fdb21e03e77baab92" translate="yes" xml:space="preserve">
          <source>Container isolation technology</source>
          <target state="translated">컨테이너 격리 기술</target>
        </trans-unit>
        <trans-unit id="8e5af269481642c5e2a011ef986efcd672144d01" translate="yes" xml:space="preserve">
          <source>Container labels</source>
          <target state="translated">컨테이너 라벨</target>
        </trans-unit>
        <trans-unit id="7925d75c0a599cc043a9e1fb4efc5c97e7306549" translate="yes" xml:space="preserve">
          <source>Container name</source>
          <target state="translated">컨테이너 이름</target>
        </trans-unit>
        <trans-unit id="e353bf82926eed310dbf9ae9c790772757d3b18a" translate="yes" xml:space="preserve">
          <source>Container name or ID (user input)</source>
          <target state="translated">컨테이너 이름 또는 ID (사용자 입력)</target>
        </trans-unit>
        <trans-unit id="e8b3b74cd1597401c6c764fbfbdfa9c9341916ab" translate="yes" xml:space="preserve">
          <source>Container names.</source>
          <target state="translated">컨테이너 이름.</target>
        </trans-unit>
        <trans-unit id="491590dfaeb4fc91bdacff4d53b21c4c3ecf319e" translate="yes" xml:space="preserve">
          <source>Container status.</source>
          <target state="translated">컨테이너 상태.</target>
        </trans-unit>
        <trans-unit id="3c7e0bdda11c982ebf90053ec6f709ca3df7fc4a" translate="yes" xml:space="preserve">
          <source>Container&amp;rsquo;s ID</source>
          <target state="translated">컨테이너의 ID</target>
        </trans-unit>
        <trans-unit id="4ee2497ce79f8f7f6a9aa13be0a8f0032f3d9aa9" translate="yes" xml:space="preserve">
          <source>Container&amp;rsquo;s IP address, such as &lt;code&gt;DB_PORT_5432_TCP_ADDR=172.17.0.5&lt;/code&gt;</source>
          <target state="translated">컨테이너의 IP 주소 (예 : &lt;code&gt;DB_PORT_5432_TCP_ADDR=172.17.0.5&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ced53195b0df3fde79379c83b53bd2bf45b96874" translate="yes" xml:space="preserve">
          <source>Container&amp;rsquo;s name</source>
          <target state="translated">컨테이너 이름</target>
        </trans-unit>
        <trans-unit id="fa7f85b507774144400e45f500b3a7cb9f216263" translate="yes" xml:space="preserve">
          <source>Containerization is increasingly popular because containers are:</source>
          <target state="translated">컨테이너는 다음과 같은 이유로 컨테이너화가 점차 대중화되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f70921ea1d4fe353ac011eedc6a11582bc98b01" translate="yes" xml:space="preserve">
          <source>Containerization makes &lt;a href=&quot;https://www.docker.com/solutions/cicd&quot;&gt;CI/CD&lt;/a&gt; seamless. For example:</source>
          <target state="translated">컨테이너화는 &lt;a href=&quot;https://www.docker.com/solutions/cicd&quot;&gt;CI / CD를&lt;/a&gt; 매끄럽게 만듭니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="e4b8caef3ce605c81fb47ae70edae4c40e0090bd" translate="yes" xml:space="preserve">
          <source>Containers and virtual machines</source>
          <target state="translated">컨테이너 및 가상 머신</target>
        </trans-unit>
        <trans-unit id="901ef2ebf787860d5ac6f562c5dccfc6d321358a" translate="yes" xml:space="preserve">
          <source>Containers can be linked to another container&amp;rsquo;s ports directly using &lt;code&gt;-link remote_name:local_alias&lt;/code&gt; in the client&amp;rsquo;s &lt;code&gt;docker run&lt;/code&gt;. This sets a number of environment variables that can then be used to connect:</source>
          <target state="translated">클라이언트의 &lt;code&gt;docker run&lt;/code&gt; 에서 &lt;code&gt;-link remote_name:local_alias&lt;/code&gt; 를 사용하여 컨테이너를 다른 컨테이너의 포트에 직접 연결할 수 있습니다 . 연결에 사용할 수있는 여러 환경 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bc1df9d8262028c1d35803901ef8471e5b1e581b" translate="yes" xml:space="preserve">
          <source>Containers can communicate via their IP addresses by default. To communicate by name, they must be linked.</source>
          <target state="translated">컨테이너는 기본적으로 IP 주소를 통해 통신 할 수 있습니다. 이름으로 통신하려면 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8aecf7b76ac483fc194b882a9bb4f0f333cd9b34" translate="yes" xml:space="preserve">
          <source>Containers for services defined in the Compose file</source>
          <target state="translated">작성 파일에 정의 된 서비스 컨테이너</target>
        </trans-unit>
        <trans-unit id="e96a631cad9af3e620b42be51b9024d716814d31" translate="yes" xml:space="preserve">
          <source>Containers for the linked service are reachable at a hostname identical to the alias, or the service name if no alias was specified.</source>
          <target state="translated">링크 된 서비스의 컨테이너는 별명과 동일한 호스트 이름 또는 별명이 지정되지 않은 경우 서비스 이름으로 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040b49dce2c65a1a20e4bd3b48876c7887ebe58a" translate="yes" xml:space="preserve">
          <source>Containers on the same network can access each other using &lt;a href=&quot;https://docs.docker.com/network#use-swarm-mode-service-discovery&quot;&gt;service discovery&lt;/a&gt;.</source>
          <target state="translated">동일한 네트워크의 컨테이너는 &lt;a href=&quot;https://docs.docker.com/network#use-swarm-mode-service-discovery&quot;&gt;서비스 검색을&lt;/a&gt; 사용하여 서로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f433936b8f5899593532cf2afaad98bfdd98c2d" translate="yes" xml:space="preserve">
          <source>Content trust in Docker</source>
          <target state="translated">Docker의 컨텐츠 신뢰</target>
        </trans-unit>
        <trans-unit id="9f7c3e82e3f4966eaddef6dfeec59c0fbf3a643c" translate="yes" xml:space="preserve">
          <source>Continue to Part 3 &amp;gt;&amp;gt;</source>
          <target state="translated">3 부로 계속 &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4c8aae68b108adcaaf7819fe9bfa5cccdbc5827f" translate="yes" xml:space="preserve">
          <source>Contiv Networking</source>
          <target state="translated">Contiv Networking</target>
        </trans-unit>
        <trans-unit id="19369b453ceeaa7d79c7cba96e70a6004866bf6b" translate="yes" xml:space="preserve">
          <source>Contiv Volume Plugin</source>
          <target state="translated">Contiv Volume 플러그인</target>
        </trans-unit>
        <trans-unit id="bec60318652b89c3623cbfe59a2345b48c957f3c" translate="yes" xml:space="preserve">
          <source>Contribute Docker&amp;rsquo;s AppArmor code</source>
          <target state="translated">Docker의 AppArmor 코드 기여</target>
        </trans-unit>
        <trans-unit id="91a6f69a661cffc53439264d11345a8b4e5e99a1" translate="yes" xml:space="preserve">
          <source>Control Groups are another key component of Linux Containers. They implement resource accounting and limiting. They provide many useful metrics, but they also help ensure that each container gets its fair share of memory, CPU, disk I/O; and, more importantly, that a single container cannot bring the system down by exhausting one of those resources.</source>
          <target state="translated">컨트롤 그룹은 Linux 컨테이너의 또 다른 주요 구성 요소입니다. 자원 회계 및 제한을 구현합니다. 유용한 많은 메트릭을 제공하지만 각 컨테이너가 메모리, CPU, 디스크 I / O를 공평하게 공유 할 수 있도록합니다. 더 중요한 것은 단일 컨테이너가 이러한 리소스 중 하나를 모두 사용하여 시스템을 중단시킬 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8eab1cebaade7b7830a76a983b393cdb9f8ded3" translate="yes" xml:space="preserve">
          <source>Control Groups have been around for a while as well: the code was started in 2006, and initially merged in kernel 2.6.24.</source>
          <target state="translated">컨트롤 그룹도 오랫동안 사용되어 왔습니다. 코드는 2006 년에 시작되어 커널 2.6.24에 처음으로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="ad3f8b4a937008010b7821331752816b0c86ad4d" translate="yes" xml:space="preserve">
          <source>Control groups</source>
          <target state="translated">컨트롤 그룹</target>
        </trans-unit>
        <trans-unit id="fa110beff3e2e22c015c2e8502c2117da26402a1" translate="yes" xml:space="preserve">
          <source>Control service placement</source>
          <target state="translated">제어 서비스 배치</target>
        </trans-unit>
        <trans-unit id="3ba3cb0124238824108607cef72bc4221b291856" translate="yes" xml:space="preserve">
          <source>Control startup and shutdown order in Compose</source>
          <target state="translated">작성에서 제어 시작 및 종료 순서</target>
        </trans-unit>
        <trans-unit id="1d04ab53dfecfa634e22ab2d999f8be1b6fc9287" translate="yes" xml:space="preserve">
          <source>Control the network&amp;rsquo;s scope</source>
          <target state="translated">네트워크 범위 제어</target>
        </trans-unit>
        <trans-unit id="b28cab1a10a31ccf14a021fc328cb52d252d051c" translate="yes" xml:space="preserve">
          <source>Convoy plugin</source>
          <target state="translated">호송 플러그인</target>
        </trans-unit>
        <trans-unit id="291c41e8ae84bd4bc854cf3138b8670406fb4b8e" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;requirements.txt&lt;/code&gt; and install the Python dependencies.</source>
          <target state="translated">&lt;code&gt;requirements.txt&lt;/code&gt; 를 복사 하고 Python 종속성을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="7a96822e81ed4585e8f3db5b02c732e3c00b276b" translate="yes" xml:space="preserve">
          <source>Copy files from your local host to a machine, from machine to machine, or from a machine to your local host using &lt;code&gt;scp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scp&lt;/code&gt; 를 사용하여 로컬 호스트에서 시스템으로, 시스템에서 시스템으로 또는 시스템에서 로컬 호스트로 파일을 복사하십시오 .</target>
        </trans-unit>
        <trans-unit id="f336ea8f2bf71db9c2a5f8130f6d9f910cdf9147" translate="yes" xml:space="preserve">
          <source>Copy files/folders between a container and the local filesystem</source>
          <target state="translated">컨테이너와 로컬 파일 시스템간에 파일 / 폴더 복사</target>
        </trans-unit>
        <trans-unit id="3918c439905b3b402ece21aaec0bbaa4e29596e2" translate="yes" xml:space="preserve">
          <source>Copy the container IP address and paste into your browser. (For example, &lt;code&gt;172.16.240.197&lt;/code&gt;)</source>
          <target state="translated">컨테이너 IP 주소를 복사하여 브라우저에 붙여 넣습니다. (예 : &lt;code&gt;172.16.240.197&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3133460a94368cd0c629cd9aaa902165771e9fa3" translate="yes" xml:space="preserve">
          <source>Copy the current directory &lt;code&gt;.&lt;/code&gt; in the project to the workdir &lt;code&gt;.&lt;/code&gt; in the image.</source>
          <target state="translated">현재 디렉토리를 복사하십시오 &lt;code&gt;.&lt;/code&gt; 프로젝트에서 workdir &lt;code&gt;.&lt;/code&gt; 이미지에서.</target>
        </trans-unit>
        <trans-unit id="89cbe1fd0c7f5734bed32e5200ab1979795ae143" translate="yes" xml:space="preserve">
          <source>Copy the generated certificates to the server and local config directory.</source>
          <target state="translated">생성 된 인증서를 서버 및 로컬 구성 디렉토리에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="90758bd72f5cabc032466a7a4dcd876d1d052f41" translate="yes" xml:space="preserve">
          <source>Cpuset constraint</source>
          <target state="translated">CPU 제약</target>
        </trans-unit>
        <trans-unit id="bb1ef70674671bfa1d7c3d3c8f9bc9ef8a9bcbc5" translate="yes" xml:space="preserve">
          <source>Crash reporting</source>
          <target state="translated">충돌보고</target>
        </trans-unit>
        <trans-unit id="ea5bb996ed8925671d978b5067bf0492984a6f16" translate="yes" xml:space="preserve">
          <source>Create Docker machines on &lt;a href=&quot;https://www.digitalocean.com/&quot;&gt;DigitalOcean&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.digitalocean.com/&quot;&gt;DigitalOcean에서&lt;/a&gt; Docker 시스템을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e349886628499b205284ffad91ac41006c1f66f" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;./data&lt;/code&gt; directory on the manager:</source>
          <target state="translated">관리자 에서 &lt;code&gt;./data&lt;/code&gt; 디렉토리를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf668703bef08c21928ed3c1250cbbc190e9005d" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Dockerfile&lt;/code&gt; in your project folder.</source>
          <target state="translated">프로젝트 폴더에 &lt;code&gt;Dockerfile&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e6ad8e34658bbf5d0fb9939c8bda557d246cbbf" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;docker-compose.yml&lt;/code&gt; file that starts your &lt;code&gt;WordPress&lt;/code&gt; blog and a separate &lt;code&gt;MySQL&lt;/code&gt; instance with a volume mount for data persistence:</source>
          <target state="translated">데이터 지속성을 위해 볼륨 마운트가 있는 별도의 &lt;code&gt;MySQL&lt;/code&gt; 인스턴스와 &lt;code&gt;WordPress&lt;/code&gt; 블로그 를 시작 하는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="53ee88ac474b10cf32511cf94e09dc18fdd5317b" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;redis&lt;/code&gt; service and grant it access to the config. By default, the container can access the config at &lt;code&gt;/my-config&lt;/code&gt;, but you can customize the file name on the container using the &lt;code&gt;target&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;redis&lt;/code&gt; 서비스를 작성 하고 구성에 대한 액세스 권한을 부여하십시오. 기본적으로 컨테이너는 &lt;code&gt;/my-config&lt;/code&gt; 의 구성에 액세스 할 수 있지만 &lt;code&gt;target&lt;/code&gt; 옵션을 사용하여 컨테이너의 파일 이름을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b4c77fb071a420e4abddef123a1b85ac7a0d7f6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;redis&lt;/code&gt; service and grant it access to the secret. By default, the container can access the secret at &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt;, but you can customize the file name on the container using the &lt;code&gt;target&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;redis&lt;/code&gt; 서비스를 작성 하고 비밀에 대한 액세스 권한을 부여하십시오. 기본적으로 컨테이너는 &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; 의 비밀에 액세스 할 수 있지만 &lt;code&gt;target&lt;/code&gt; 옵션을 사용하여 컨테이너의 파일 이름을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6102d9aadc36bf3fa4fd1620095eead2b34bf918" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;requirements.txt&lt;/code&gt; in your project directory.</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;requirements.txt&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2afa60eb6bb78e0aa6bef3f71f5c20178e059079" translate="yes" xml:space="preserve">
          <source>Create a CA, server and client keys with OpenSSL</source>
          <target state="translated">OpenSSL을 사용하여 CA, 서버 및 클라이언트 키 생성</target>
        </trans-unit>
        <trans-unit id="4885208fb8b950bc31e70e82f4c753f946200e41" translate="yes" xml:space="preserve">
          <source>Create a Django project</source>
          <target state="translated">장고 프로젝트 만들기</target>
        </trans-unit>
        <trans-unit id="d2e11bddca4233ab493e7318ea72604a09501a26" translate="yes" xml:space="preserve">
          <source>Create a Dockerfile for an ASP.NET Core application</source>
          <target state="translated">ASP.NET Core 응용 프로그램 용 Dockerfile 만들기</target>
        </trans-unit>
        <trans-unit id="a0ef72f8541de4d53aca1e6413404d6e21c3b830" translate="yes" xml:space="preserve">
          <source>Create a VolumeDriver</source>
          <target state="translated">VolumeDriver 생성</target>
        </trans-unit>
        <trans-unit id="be9d5cff6b40a61053f0e5406264fa46192c8e76" translate="yes" xml:space="preserve">
          <source>Create a backup that can then be used with &lt;code&gt;docker load&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker load&lt;/code&gt; 와 함께 사용할 수있는 백업을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ac5bed111d26f472ea187d239f0d0efeae7087d3" translate="yes" xml:space="preserve">
          <source>Create a checkpoint from a running container</source>
          <target state="translated">실행중인 컨테이너에서 검사 점 만들기</target>
        </trans-unit>
        <trans-unit id="6440e56bd3c060e689ddfa896b09bbd0ce045bb0" translate="yes" xml:space="preserve">
          <source>Create a cluster</source>
          <target state="translated">클러스터 생성</target>
        </trans-unit>
        <trans-unit id="fd8f74092ac29cffc635d96d5c218039d01e95be" translate="yes" xml:space="preserve">
          <source>Create a config from a file or STDIN</source>
          <target state="translated">파일 또는 STDIN에서 구성 작성</target>
        </trans-unit>
        <trans-unit id="17539791df575249b8565444eca5a839b7eb0478" translate="yes" xml:space="preserve">
          <source>Create a configuration only network</source>
          <target state="translated">구성 전용 네트워크 만들기</target>
        </trans-unit>
        <trans-unit id="6613bee0926e82377a6c1df09bea6e64a5e35610" translate="yes" xml:space="preserve">
          <source>Create a context</source>
          <target state="translated">컨텍스트 만들기</target>
        </trans-unit>
        <trans-unit id="cb3fb5a057cb5d35afc9b75ea1a83f792cf3ded5" translate="yes" xml:space="preserve">
          <source>Create a custom network of an APT proxy container with Debian-based containers.</source>
          <target state="translated">Debian 기반 컨테이너를 사용하여 APT 프록시 컨테이너의 사용자 지정 네트워크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1a36817066d773a38d9c6fa39dd2b4be1dc7c6a5" translate="yes" xml:space="preserve">
          <source>Create a directory for the project:</source>
          <target state="translated">프로젝트의 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="df906deb5dfa1bee5bbeb754debc8276288cd049" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;app.py&lt;/code&gt; in your project directory and paste this in:</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;app.py&lt;/code&gt; 라는 파일을 만들고 다음 에 붙여 넣습니다.</target>
        </trans-unit>
        <trans-unit id="6e50372ee97819bfd724c04e926a28e036c80219" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;com.docker.machine.default.plist&lt;/code&gt; in the &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; directory, with the following content:</source>
          <target state="translated">라는 파일 만들기 &lt;code&gt;com.docker.machine.default.plist&lt;/code&gt; 에서 &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; 다음과 같은 내용으로 디렉토리를 :</target>
        </trans-unit>
        <trans-unit id="04df220e1f7705e9962fb93b691fbc7f28c531e1" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;docker-compose.yml&lt;/code&gt; in your project directory and paste the following:</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;docker-compose.yml&lt;/code&gt; 이라는 파일을 만들고 다음을 붙여 넣습니다.</target>
        </trans-unit>
        <trans-unit id="5bb10200f76f449f5653669f370e0669c665f114" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;docker-compose.yml&lt;/code&gt; in your project directory.</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;docker-compose.yml&lt;/code&gt; 이라는 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9cf156bc8882775c774414b4bb8ba7895b49c0d2" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;docker-compose.yml&lt;/code&gt; with your favorite editor. For example, using vim:</source>
          <target state="translated">좋아하는 편집기로 &lt;code&gt;docker-compose.yml&lt;/code&gt; 이라는 파일을 만듭니다 . 예를 들어, vim 사용 :</target>
        </trans-unit>
        <trans-unit id="bf86ea907e9d20e5c5d09f428ba556a008462132" translate="yes" xml:space="preserve">
          <source>Create a local manifest list for annotating and pushing to a registry</source>
          <target state="translated">주석을 달고 레지스트리를 푸시하기위한 로컬 매니페스트 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="97f19b47c55b754bc1d8e0164534194b00f192a6" translate="yes" xml:space="preserve">
          <source>Create a machine</source>
          <target state="translated">기계 만들기</target>
        </trans-unit>
        <trans-unit id="9917f3b67c75482216c7fb5796f625e17c7ba14d" translate="yes" xml:space="preserve">
          <source>Create a machine.</source>
          <target state="translated">기계를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f40ffe7edf4ea6bf3387372effdab6520ae62bed" translate="yes" xml:space="preserve">
          <source>Create a machine. Requires the &lt;code&gt;--driver&lt;/code&gt; flag to indicate which provider (VirtualBox, DigitalOcean, AWS, etc.) the machine should be created on, and an argument to indicate the name of the created machine.</source>
          <target state="translated">기계를 작성하십시오. 머신을 생성 할 공급자 (VirtualBox, DigitalOcean, AWS 등)를 나타내 려면 &lt;code&gt;--driver&lt;/code&gt; 플래그가 필요하고 생성 된 머신의 이름을 나타내는 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4bb8758984dbc7cfe086ef8a5ed978dcd34dfc71" translate="yes" xml:space="preserve">
          <source>Create a network</source>
          <target state="translated">네트워크 만들기</target>
        </trans-unit>
        <trans-unit id="ecf685791835be7a1b2dd9186a8211f0c3200c44" translate="yes" xml:space="preserve">
          <source>Create a network alias for a container</source>
          <target state="translated">컨테이너에 대한 네트워크 별칭 생성</target>
        </trans-unit>
        <trans-unit id="7f9353935e115784ccea5c918aff4035b198bb1e" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;trustsandbox&lt;/code&gt; directory and change into it.</source>
          <target state="translated">새 &lt;code&gt;trustsandbox&lt;/code&gt; 디렉토리를 작성 하고 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="d9112eec714b47e36f0d6b5b9e1835d40f5fdd8b" translate="yes" xml:space="preserve">
          <source>Create a new Docker config using the new &lt;code&gt;site.conf&lt;/code&gt;, called &lt;code&gt;site-v2.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;site-v2.conf&lt;/code&gt; 라는 새 &lt;code&gt;site.conf&lt;/code&gt; 를 사용하여 새 Docker 구성을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b77dbcb6258d2c2743425c762e7730cd1cee09c" translate="yes" xml:space="preserve">
          <source>Create a new container</source>
          <target state="translated">새 컨테이너 만들기</target>
        </trans-unit>
        <trans-unit id="af287a34b518c56c8359626e45a0b81efb406c43" translate="yes" xml:space="preserve">
          <source>Create a new file called &lt;code&gt;Dockerfile&lt;/code&gt; in your project directory.</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 새 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fa177c875e610844b4289c1a49633693ecc48cb" translate="yes" xml:space="preserve">
          <source>Create a new image from a container&amp;rsquo;s changes</source>
          <target state="translated">컨테이너의 변경 사항으로 새 이미지 만들기</target>
        </trans-unit>
        <trans-unit id="0f4d3abf69b050947ee350209c4858b2d70cd642" translate="yes" xml:space="preserve">
          <source>Create a new service</source>
          <target state="translated">새로운 서비스 만들기</target>
        </trans-unit>
        <trans-unit id="c69a926e4a6cbcf8ce442ec206283170a7b95825" translate="yes" xml:space="preserve">
          <source>Create a new swarm, covered in this article.</source>
          <target state="translated">이 기사에서 다루는 새 떼를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="35bccaa41ae5b58849bde62432137da30fb180e1" translate="yes" xml:space="preserve">
          <source>Create a plugin from a rootfs and configuration. Plugin data directory must contain config.json and rootfs directory.</source>
          <target state="translated">rootfs 및 구성에서 플러그인을 작성하십시오. 플러그인 데이터 디렉토리는 config.json 및 rootfs 디렉토리를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c512738a7635b8ca5e323d04812779dc696f3874" translate="yes" xml:space="preserve">
          <source>Create a secret</source>
          <target state="translated">비밀 만들기</target>
        </trans-unit>
        <trans-unit id="460585255344876d5f43a2577fad375d3bf943ea" translate="yes" xml:space="preserve">
          <source>Create a secret from a file or STDIN as content</source>
          <target state="translated">파일 또는 STDIN에서 컨텐츠로 비밀을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="67ba5e0d056d2467e8afb78991bb378980c06fce" translate="yes" xml:space="preserve">
          <source>Create a secret with a file</source>
          <target state="translated">파일로 비밀 만들기</target>
        </trans-unit>
        <trans-unit id="587aba78bbf569e9febb68f2c39d26c46b23542b" translate="yes" xml:space="preserve">
          <source>Create a secret with labels</source>
          <target state="translated">라벨이있는 비밀 만들기</target>
        </trans-unit>
        <trans-unit id="389405cf0c5dda32148ac6bf0cc140f0c2fc8aa6" translate="yes" xml:space="preserve">
          <source>Create a service</source>
          <target state="translated">서비스 만들기</target>
        </trans-unit>
        <trans-unit id="8e1e5f8e1b7edd780348917dbbe4a4110cdf331b" translate="yes" xml:space="preserve">
          <source>Create a service specifying a secret:</source>
          <target state="translated">비밀을 지정하여 서비스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9dba39db1e7a65e26c43ec4298564c9b4dcc91a1" translate="yes" xml:space="preserve">
          <source>Create a service specifying the secret, target, user/group ID, and mode:</source>
          <target state="translated">비밀, 대상, 사용자 / 그룹 ID 및 모드를 지정하여 서비스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="669e3f0e78a0ada26f5cc0acfff0918ab968f965" translate="yes" xml:space="preserve">
          <source>Create a service that runs Nginx and has access to the three secrets. The last part of the &lt;code&gt;docker service create&lt;/code&gt; command creates a symbolic link from the location of the &lt;code&gt;site.conf&lt;/code&gt; secret to &lt;code&gt;/etc/nginx.conf.d/&lt;/code&gt;, where Nginx looks for extra configuration files. This step happens before Nginx actually starts, so you don&amp;rsquo;t need to rebuild your image if you change the Nginx configuration.</source>
          <target state="translated">Nginx를 실행하고 세 가지 비밀에 액세스 할 수있는 서비스를 만듭니다. 의 마지막 부분 &lt;code&gt;docker service create&lt;/code&gt; 명령을의 위치에서 심볼릭 링크 생성 &lt;code&gt;site.conf&lt;/code&gt; 의 에 비밀 &lt;code&gt;/etc/nginx.conf.d/&lt;/code&gt; Nginx에 추가 구성 파일을 찾습니다. 이 단계는 Nginx가 실제로 시작되기 전에 발생하므로 Nginx 구성을 변경 한 경우 이미지를 다시 빌드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6db02fe70314f90c7d054d1943e014fae8c71c29" translate="yes" xml:space="preserve">
          <source>Create a service that runs Nginx and has access to the two secrets and the config. Set the mode to &lt;code&gt;0440&lt;/code&gt; so that the file is only readable by its owner and that owner&amp;rsquo;s group, not the world.</source>
          <target state="translated">Nginx를 실행하고 두 가지 비밀과 설정에 액세스 할 수있는 서비스를 만듭니다. 파일을 소유자가 아닌 해당 소유자 그룹 만 읽을 수 있도록 모드를 &lt;code&gt;0440&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c391910d7ce750b6a83f58c5f955fb9876d2069" translate="yes" xml:space="preserve">
          <source>Create a service that uses a bind-mounted host directory</source>
          <target state="translated">바인드 마운트 호스트 디렉토리를 사용하는 서비스 작성</target>
        </trans-unit>
        <trans-unit id="6511b5211018a15fa470b65c44051800089eb6c6" translate="yes" xml:space="preserve">
          <source>Create a service that uses an anonymous volume</source>
          <target state="translated">익명의 볼륨을 사용하는 서비스 만들기</target>
        </trans-unit>
        <trans-unit id="ff574951637b434810518ec67bdeafb2867247db" translate="yes" xml:space="preserve">
          <source>Create a service using a named volume</source>
          <target state="translated">명명 된 볼륨을 사용하여 서비스 생성</target>
        </trans-unit>
        <trans-unit id="fe16951e16b4287aeedebfd9b87b1520a3ae5593" translate="yes" xml:space="preserve">
          <source>Create a service using an image on a private registry</source>
          <target state="translated">개인 레지스트리의 이미지를 사용하여 서비스 작성</target>
        </trans-unit>
        <trans-unit id="61c9e6782c0d42d7c1471fc2c0fd992b3af7d70c" translate="yes" xml:space="preserve">
          <source>Create a service with 5 replica tasks (--replicas)</source>
          <target state="translated">5 개의 복제 작업 (-복제본)으로 서비스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0b7df42ff8ba2d2bc3de7223e58cf3c603457496" translate="yes" xml:space="preserve">
          <source>Create a service with a rolling update policy</source>
          <target state="translated">지속적 업데이트 정책으로 서비스 만들기</target>
        </trans-unit>
        <trans-unit id="9d3fe30066e6a47ee41a1a2afe816cd89abe8e9e" translate="yes" xml:space="preserve">
          <source>Create a service with a single replica:</source>
          <target state="translated">단일 복제본으로 서비스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0c4970087b051fa4c46b3bd5fb08e4a4eb975601" translate="yes" xml:space="preserve">
          <source>Create a service with secrets</source>
          <target state="translated">비밀이있는 서비스 만들기</target>
        </trans-unit>
        <trans-unit id="869c3cb33ddbf3030f0a4b0a238edc9c2470d198" translate="yes" xml:space="preserve">
          <source>Create a service with specific hostname (--hostname)</source>
          <target state="translated">특정 호스트 이름 (--hostname)으로 서비스 생성</target>
        </trans-unit>
        <trans-unit id="a78632a5f052275ff078c1264e99bc3dd132d789" translate="yes" xml:space="preserve">
          <source>Create a stack from a bundle</source>
          <target state="translated">번들에서 스택 생성</target>
        </trans-unit>
        <trans-unit id="52195f91546c438162bfe697230f76202475ab77" translate="yes" xml:space="preserve">
          <source>Create a swarm</source>
          <target state="translated">떼를 만들</target>
        </trans-unit>
        <trans-unit id="2d96aec7a7fe4958c98a9770005c5c231d26602d" translate="yes" xml:space="preserve">
          <source>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</source>
          <target state="translated">SOURCE_IMAGE를 참조하는 TARGET_IMAGE 태그를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7005b50794a7529159667fb0c3eb09de711b38c3" translate="yes" xml:space="preserve">
          <source>Create a user-defined overlay network which is used for communication between the MySQL and WordPress services. There is no need to expose the MySQL service to any external host or container.</source>
          <target state="translated">MySQL과 WordPress 서비스 간의 통신에 사용되는 사용자 정의 오버레이 네트워크를 만듭니다. MySQL 서비스를 외부 호스트 나 컨테이너에 노출시킬 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4dc758788555b971923af952dd41568803518bd1" translate="yes" xml:space="preserve">
          <source>Create a volume</source>
          <target state="translated">볼륨 만들기</target>
        </trans-unit>
        <trans-unit id="a03b22aee5d6ce6c4a18a64468b4987b10177008" translate="yes" xml:space="preserve">
          <source>Create a volume and then configure the container to use it:</source>
          <target state="translated">볼륨을 생성 한 다음 사용하도록 컨테이너를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="046edc7c142a9d19a94cd8e8ea99fa1aa8b55d95" translate="yes" xml:space="preserve">
          <source>Create a volume using the plugin. This example mounts the &lt;code&gt;/remote&lt;/code&gt; directory on host &lt;code&gt;1.2.3.4&lt;/code&gt; into a volume named &lt;code&gt;sshvolume&lt;/code&gt;.</source>
          <target state="translated">플러그인을 사용하여 볼륨을 작성하십시오. 이 예제는 호스트 &lt;code&gt;1.2.3.4&lt;/code&gt; 의 &lt;code&gt;/remote&lt;/code&gt; 디렉토리를 &lt;code&gt;sshvolume&lt;/code&gt; 볼륨 에 마운트합니다 .</target>
        </trans-unit>
        <trans-unit id="a7884286f80e4b48260cfab44dd17b1f15245642" translate="yes" xml:space="preserve">
          <source>Create an IAM (Identity and Access Management) administrator user, an admin group, and a key pair associated with a region.</source>
          <target state="translated">IAM (Identity and Access Management) 관리자, 관리자 그룹 및 리전과 연결된 키 페어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a98ee1ca6db8bdf6ec2879ba895f443b9a23f125" translate="yes" xml:space="preserve">
          <source>Create an IIS service and grant it access to the &lt;code&gt;homepage&lt;/code&gt; config.</source>
          <target state="translated">IIS 서비스를 작성하고 &lt;code&gt;homepage&lt;/code&gt; 구성에 대한 액세스 권한을 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef3c0c6ae7d9177620eb111ca37df4f4b11f20ff" translate="yes" xml:space="preserve">
          <source>Create an IIS service and grant it access to the &lt;code&gt;homepage&lt;/code&gt; secret.</source>
          <target state="translated">IIS 서비스를 작성하고 &lt;code&gt;homepage&lt;/code&gt; 비밀에 대한 액세스 권한을 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a46cab28e0fbbbe65d297ade97ddaaee9d71c0" translate="yes" xml:space="preserve">
          <source>Create an empty &lt;code&gt;Gemfile.lock&lt;/code&gt; to build our &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">빈 만들기 &lt;code&gt;Gemfile.lock&lt;/code&gt; 우리의 구축 &lt;code&gt;Dockerfile&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0c7ba5abbbfdf88d73359968e395df34b7f49337" translate="yes" xml:space="preserve">
          <source>Create an empty directory on your local machine. Change directories (&lt;code&gt;cd&lt;/code&gt;) into the new directory, create a file called &lt;code&gt;Dockerfile&lt;/code&gt;, copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile.</source>
          <target state="translated">로컬 머신에 빈 디렉토리를 작성하십시오. 디렉토리 ( &lt;code&gt;cd&lt;/code&gt; )를 새 디렉토리로 변경 하고 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 파일을 작성 하고 다음 컨텐츠를 해당 파일에 복사하여 붙여 넣은 후 저장하십시오. 새로운 Dockerfile의 각 문장을 설명하는 주석을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="584a4b8ac7c2c575852696f136ad38f0ba377b9f" translate="yes" xml:space="preserve">
          <source>Create an empty project directory.</source>
          <target state="translated">빈 프로젝트 디렉토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="668f42f4a55d0c35002deb9aded9ca5480e84c08" translate="yes" xml:space="preserve">
          <source>Create and push a manifest list</source>
          <target state="translated">매니페스트 목록 만들기 및 푸시</target>
        </trans-unit>
        <trans-unit id="d3122e1b698d7e459858c705f67c83491a5b2968" translate="yes" xml:space="preserve">
          <source>Create and run a Docker host on your &lt;a href=&quot;../get-started/index&quot;&gt;local system using VirtualBox&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../get-started/index&quot;&gt;VirtualBox를 사용&lt;/a&gt; 하여 로컬 시스템 에서 Docker 호스트 생성 및 실행</target>
        </trans-unit>
        <trans-unit id="846247a19b5a7de5f56cf2788d34c3e2761af368" translate="yes" xml:space="preserve">
          <source>Create and run a Docker host on your &lt;a href=&quot;../get-started/index&quot;&gt;local system using virtualization&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../get-started/index&quot;&gt;가상화를 사용&lt;/a&gt; 하여 로컬 시스템 에서 Docker 호스트 생성 및 실행</target>
        </trans-unit>
        <trans-unit id="17f9486818d2d4a68a71245de91b64d5c0d2d442" translate="yes" xml:space="preserve">
          <source>Create and start a container</source>
          <target state="translated">컨테이너 생성 및 시작</target>
        </trans-unit>
        <trans-unit id="48416b89069e0fc64a6e61bd2b5408be79429229" translate="yes" xml:space="preserve">
          <source>Create and update a stack from a &lt;code&gt;compose&lt;/code&gt; or a &lt;code&gt;dab&lt;/code&gt; file on the swarm. This command has to be run targeting a manager node.</source>
          <target state="translated">swarm 의 &lt;code&gt;compose&lt;/code&gt; 또는 &lt;code&gt;dab&lt;/code&gt; 파일에서 스택을 작성하고 업데이트하십시오 . 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="558b0d66df8ecb9aa064f7867a36041aff8013b0" translate="yes" xml:space="preserve">
          <source>Create another file called &lt;code&gt;requirements.txt&lt;/code&gt; in your project directory and paste this in:</source>
          <target state="translated">프로젝트 디렉토리에 &lt;code&gt;requirements.txt&lt;/code&gt; 라는 다른 파일을 작성 하여 다음에 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="aa4403ad0808e24547ff839d43ecda648d22b4ec" translate="yes" xml:space="preserve">
          <source>Create containers for your Docker Machine</source>
          <target state="translated">Docker Machine을위한 컨테이너 만들기</target>
        </trans-unit>
        <trans-unit id="77bd80857654a4fd1fdea0faa5de5301de018ab6" translate="yes" xml:space="preserve">
          <source>Create first database</source>
          <target state="translated">첫 번째 데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="145727fef61de61742acaa60dfd7a2190b3f1464" translate="yes" xml:space="preserve">
          <source>Create machines locally using &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt;. This driver requires VirtualBox 5+ to be installed on your host. Using VirtualBox 4.3+ should work but emits a warning. Older versions do not work.</source>
          <target state="translated">&lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox를&lt;/a&gt; 사용하여 로컬로 머신을 작성하십시오 . 이 드라이버를 사용하려면 호스트에 VirtualBox 5 이상이 설치되어 있어야합니다. VirtualBox 4.3 이상을 사용하면 작동하지만 경고가 발생합니다. 이전 버전은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca7e57dff3a5fa4ef905033f1c56719eff99e843" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;http://aws.amazon.com&quot;&gt;Amazon Web Services&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://aws.amazon.com&quot;&gt;Amazon Web Services&lt;/a&gt; 에서 머신을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="d468bd3d473bd9436abde4e06b870a3eca26cd79" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;http://softlayer.com&quot;&gt;Softlayer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://softlayer.com&quot;&gt;Softlayer에서&lt;/a&gt; 기계를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="85ee6dab3b298d00313f7acf524f1850b6c691f2" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;http://www.openstack.org/software/&quot;&gt;OpenStack&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.openstack.org/software/&quot;&gt;OpenStack에서&lt;/a&gt; 머신 생성</target>
        </trans-unit>
        <trans-unit id="73163c97d746a6bb18b4120c6ce20aca91a02238" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;http://www.rackspace.com/cloud&quot;&gt;Rackspace cloud&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.rackspace.com/cloud&quot;&gt;Rackspace 클라우드에서&lt;/a&gt; 머신 생성</target>
        </trans-unit>
        <trans-unit id="61d526bc5a920300982b2a81c274ffe701b03321" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;https://cloud.google.com/compute/&quot;&gt;Google Compute Engine&lt;/a&gt;. You need a Google account and a project ID. See &lt;a href=&quot;https://cloud.google.com/compute/docs/projects&quot;&gt;https://cloud.google.com/compute/docs/projects&lt;/a&gt; for details on projects.</source>
          <target state="translated">&lt;a href=&quot;https://cloud.google.com/compute/&quot;&gt;Google Compute Engine&lt;/a&gt; 에서 머신을 만듭니다 . Google 계정과 프로젝트 ID가 필요합니다. 프로젝트에 대한 자세한 내용 은 &lt;a href=&quot;https://cloud.google.com/compute/docs/projects&quot;&gt;https://cloud.google.com/compute/docs/projects&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5c612d63df19300ece6fe87abf701eb62abf032" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;https://www.exoscale.com/&quot;&gt;Exoscale&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.exoscale.com/&quot;&gt;Exoscale에서&lt;/a&gt; 머신을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7a9e4ab4d7459c562e540cdfd7cdfdc48858d91b" translate="yes" xml:space="preserve">
          <source>Create machines on &lt;a href=&quot;https://www.linode.com&quot;&gt;Linode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.linode.com&quot;&gt;Linode에서&lt;/a&gt; 머신을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db6088e31b93a96771b03bd1c596a4c931bded4" translate="yes" xml:space="preserve">
          <source>Create second database</source>
          <target state="translated">두 번째 데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="7aa79dde40e53ea43ccae03eb993840c0c855528" translate="yes" xml:space="preserve">
          <source>Create services requesting Generic Resources</source>
          <target state="translated">일반 자원을 요청하는 서비스 작성</target>
        </trans-unit>
        <trans-unit id="10a29c2fddcd33c74102df4acd0447c73c303b38" translate="yes" xml:space="preserve">
          <source>Create services using templates</source>
          <target state="translated">템플릿을 사용하여 서비스 만들기</target>
        </trans-unit>
        <trans-unit id="8883c00ccd5572eb15ddd1a0b30d7cc2f75e9287" translate="yes" xml:space="preserve">
          <source>Create special files using mknod(2).</source>
          <target state="translated">mknod (2)를 사용하여 특수 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f35c99777e26ab83c67386816641c33372aec8c8" translate="yes" xml:space="preserve">
          <source>Create swarm routing-mesh network</source>
          <target state="translated">스웜 라우팅 메시 네트워크 생성</target>
        </trans-unit>
        <trans-unit id="23aa664e9535105ce7d92523e4b4a9434ec81a56" translate="yes" xml:space="preserve">
          <source>Create the Django project by running the &lt;a href=&quot;../reference/run/index&quot;&gt;docker-compose run&lt;/a&gt; command as follows.</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;../reference/run/index&quot;&gt;docker-compose run&lt;/a&gt; 명령을 실행하여 Django 프로젝트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5f3402d2a1e28ada47eeeea46f6a056be4e7d3d8" translate="yes" xml:space="preserve">
          <source>Create the MySQL service. The MySQL service has the following characteristics:</source>
          <target state="translated">MySQL 서비스를 작성하십시오. MySQL 서비스는 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f7ea88c737bee2a5ae01c56af59f92e9a0128b" translate="yes" xml:space="preserve">
          <source>Create the client certificates</source>
          <target state="translated">클라이언트 인증서 생성</target>
        </trans-unit>
        <trans-unit id="049e17b3e3386b47f4997ad013a4914a0ce7a6f5" translate="yes" xml:space="preserve">
          <source>Create the new password and store it as a secret named &lt;code&gt;mysql_password_v2&lt;/code&gt;.</source>
          <target state="translated">새 비밀번호를 작성하고 &lt;code&gt;mysql_password_v2&lt;/code&gt; 라는 비밀번호로 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="108790e55117c532b044f0c51ca238d2f194f746" translate="yes" xml:space="preserve">
          <source>Create this Dockerfile:</source>
          <target state="translated">이 Dockerfile을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3721a18ebe3614603c7dd4beffa1b483545620c7" translate="yes" xml:space="preserve">
          <source>Create three secrets, representing the key, the certificate, and the &lt;code&gt;site.conf&lt;/code&gt;. You can store any file as a secret as long as it is smaller than 500 KB. This allows you to decouple the key, certificate, and configuration from the services that use them. In each of these commands, the last argument represents the path to the file to read the secret from on the host machine&amp;rsquo;s filesystem. In these examples, the secret name and the file name are the same.</source>
          <target state="translated">키, 인증서 및 &lt;code&gt;site.conf&lt;/code&gt; 를 나타내는 세 가지 비밀을 작성하십시오 . 500KB보다 작은 파일은 비밀로 저장할 수 있습니다. 이를 통해 키, 인증서 및 구성을 사용하는 서비스에서 키, 인증서 및 구성을 분리 할 수 ​​있습니다. 이러한 각 명령에서 마지막 인수는 호스트 시스템의 파일 시스템에서 비밀을 읽을 파일의 경로를 나타냅니다. 이 예에서 비밀 이름과 파일 이름은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4486b9e187758ccaa0d1c36dbafd70268d7d27ca" translate="yes" xml:space="preserve">
          <source>Create time</source>
          <target state="translated">시간 만들기</target>
        </trans-unit>
        <trans-unit id="fbe4163ac227f8a432e98459e1f9dda0f91192a0" translate="yes" xml:space="preserve">
          <source>Create two more files, &lt;code&gt;requirements.txt&lt;/code&gt; and &lt;code&gt;app.py&lt;/code&gt;, and put them in the same folder with the &lt;code&gt;Dockerfile&lt;/code&gt;. This completes our app, which as you can see is quite simple. When the above &lt;code&gt;Dockerfile&lt;/code&gt; is built into an image, &lt;code&gt;app.py&lt;/code&gt; and &lt;code&gt;requirements.txt&lt;/code&gt; is present because of that &lt;code&gt;Dockerfile&lt;/code&gt;&amp;rsquo;s &lt;code&gt;COPY&lt;/code&gt; command, and the output from &lt;code&gt;app.py&lt;/code&gt; is accessible over HTTP thanks to the &lt;code&gt;EXPOSE&lt;/code&gt; command.</source>
          <target state="translated">두 개의 파일 ( &lt;code&gt;requirements.txt&lt;/code&gt; 및 &lt;code&gt;app.py&lt;/code&gt; )을 더 만들어 Dockerfile 과 동일한 폴더에 &lt;code&gt;Dockerfile&lt;/code&gt; . 이것으로 우리 앱을 완성합니다. 위의 &lt;code&gt;Dockerfile&lt;/code&gt; 이 이미지에 빌드 되면 해당 &lt;code&gt;Dockerfile&lt;/code&gt; 의 &lt;code&gt;COPY&lt;/code&gt; 명령으로 인해 &lt;code&gt;app.py&lt;/code&gt; 및 &lt;code&gt;requirements.txt&lt;/code&gt; 가 존재 하며 &lt;code&gt;EXPOSE&lt;/code&gt; 명령으로 &lt;code&gt;app.py&lt;/code&gt; 의 출력 에 HTTP를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8a73f83be3fff2b74b9a3199cfc9d44a40faf39" translate="yes" xml:space="preserve">
          <source>Create two secrets, representing the key and the certificate. You can store any file as a secret as long as it is smaller than 500 KB. This allows you to decouple the key and certificate from the services that use them. In these examples, the secret name and the file name are the same.</source>
          <target state="translated">키와 인증서를 나타내는 두 가지 비밀을 만듭니다. 500KB보다 작은 파일은 비밀로 저장할 수 있습니다. 이를 통해 키와 인증서를 사용하는 서비스에서 키와 인증서를 분리 할 수 ​​있습니다. 이 예에서 비밀 이름과 파일 이름은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="58e376a2cd068270eb67da453726573c42d1e514" translate="yes" xml:space="preserve">
          <source>Create your swarm</source>
          <target state="translated">떼를 만드십시오</target>
        </trans-unit>
        <trans-unit id="09f1ac995e432fb7414ac73ebbceb487c823dfaa" translate="yes" xml:space="preserve">
          <source>Created services do not always run right away. A service can be in a pending state if its image is unavailable, if no node meets the requirements you configure for the service, or other reasons. See &lt;a href=&quot;../how-swarm-mode-works/services/index#pending-services&quot;&gt;Pending services&lt;/a&gt; for more information.</source>
          <target state="translated">생성 된 서비스가 항상 즉시 실행되는 것은 아닙니다. 서비스가 이미지를 사용할 수 없거나 서비스에 대해 구성한 요구 사항을 충족하는 노드가 없거나 기타 이유로 서비스가 보류 상태 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;../how-swarm-mode-works/services/index#pending-services&quot;&gt;보류중인 서비스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc0293d8ee752b3dd004a542614e81946b72c4c" translate="yes" xml:space="preserve">
          <source>Creates a Boot2Docker virtual machine locally on your Windows machine using Hyper-V.</source>
          <target state="translated">Hyper-V를 사용하여 Windows 컴퓨터에서 로컬로 Boot2Docker 가상 컴퓨터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="06ad3c9fcdf4505c8fd19beb153fd0401f191ebd" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;context&lt;/code&gt;. This allows you to quickly switch the cli configuration to connect to different clusters or single nodes.</source>
          <target state="translated">새로운 &lt;code&gt;context&lt;/code&gt; 합니다. 이를 통해 cli 구성을 신속하게 전환하여 다른 클러스터 또는 단일 노드에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31fad037f8e2341bfe0f409639bfb24cee6e904f" translate="yes" xml:space="preserve">
          <source>Creates a new docker host.</source>
          <target state="translated">새 도커 호스트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9a5f7caddfdf53feeda5d1109da9a4d38946d999" translate="yes" xml:space="preserve">
          <source>Creates a new network. The &lt;code&gt;DRIVER&lt;/code&gt; accepts &lt;code&gt;bridge&lt;/code&gt; or &lt;code&gt;overlay&lt;/code&gt; which are the built-in network drivers. If you have installed a third party or your own custom network driver you can specify that &lt;code&gt;DRIVER&lt;/code&gt; here also. If you don&amp;rsquo;t specify the &lt;code&gt;--driver&lt;/code&gt; option, the command automatically creates a &lt;code&gt;bridge&lt;/code&gt; network for you. When you install Docker Engine it creates a &lt;code&gt;bridge&lt;/code&gt; network automatically. This network corresponds to the &lt;code&gt;docker0&lt;/code&gt; bridge that Engine has traditionally relied on. When you launch a new container with &lt;code&gt;docker run&lt;/code&gt; it automatically connects to this bridge network. You cannot remove this default bridge network, but you can create new ones using the &lt;code&gt;network create&lt;/code&gt; command.</source>
          <target state="translated">새로운 네트워크를 만듭니다. &lt;code&gt;DRIVER&lt;/code&gt; 받아 &lt;code&gt;bridge&lt;/code&gt; 또는 &lt;code&gt;overlay&lt;/code&gt; 내장 된 네트워크 드라이버입니다. 타사 또는 사용자 정의 네트워크 드라이버를 설치 한 경우 여기에서도 해당 &lt;code&gt;DRIVER&lt;/code&gt; 지정할 수 있습니다. &lt;code&gt;--driver&lt;/code&gt; 옵션을 지정하지 않으면 명령이 자동으로 &lt;code&gt;bridge&lt;/code&gt; 네트워크를 만듭니다 . Docker Engine을 설치하면 &lt;code&gt;bridge&lt;/code&gt; 네트워크가 자동으로 생성 됩니다. 이 네트워크 는 엔진이 전통적으로 의존했던 &lt;code&gt;docker0&lt;/code&gt; 브리지에 해당합니다. &lt;code&gt;docker run&lt;/code&gt; 으로 새 컨테이너를 시작하면이 브리지 네트워크에 자동으로 연결됩니다. 이 기본 브리지 네트워크는 제거 할 수 없지만 &lt;code&gt;network create&lt;/code&gt; 명령을 사용하여 새 브리지 네트워크를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01a3b4ce161207a9793326499bd80a6914d65d89" translate="yes" xml:space="preserve">
          <source>Creates a new volume that containers can consume and store data in. If a name is not specified, Docker generates a random name.</source>
          <target state="translated">컨테이너가 데이터를 소비하고 저장할 수있는 새 볼륨을 만듭니다. 이름을 지정하지 않으면 Docker는 임의의 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5bc69cc247b1b1c7419c09b74786e2b484237e3c" translate="yes" xml:space="preserve">
          <source>Creates a plugin. Before creating the plugin, prepare the plugin&amp;rsquo;s root filesystem as well as &lt;a href=&quot;../../../extend/config/index&quot;&gt;the config.json&lt;/a&gt;</source>
          <target state="translated">플러그인을 만듭니다. 플러그인을 작성하기 전에 플러그인의 루트 파일 시스템과 &lt;a href=&quot;../../../extend/config/index&quot;&gt;config.json을&lt;/a&gt; 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="2c0c67ccc45d0650563cf06c791fb98759b4cc5b" translate="yes" xml:space="preserve">
          <source>Creates a secret using standard input or from a file for the secret content. You must run this command on a manager node.</source>
          <target state="translated">표준 입력을 사용하거나 비밀 컨텐츠의 파일에서 비밀을 작성합니다. 관리자 노드에서이 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="94f0b5f68b9f400f6468d2055d2b4f105e296212" translate="yes" xml:space="preserve">
          <source>Creates a service as described by the specified parameters. You must run this command on a manager node.</source>
          <target state="translated">지정된 매개 변수에 설명 된대로 서비스를 작성합니다. 관리자 노드에서이 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f37b9da31b0c5901a375a4e7d524f45bf5f5c41" translate="yes" xml:space="preserve">
          <source>Creates machines locally on &lt;a href=&quot;http://www.vmware.com/products/fusion&quot;&gt;VMware Fusion&lt;/a&gt;. Requires VMware Fusion to be installed.</source>
          <target state="translated">&lt;a href=&quot;http://www.vmware.com/products/fusion&quot;&gt;VMware Fusion&lt;/a&gt; 에서 로컬로 시스템을 생성합니다 . VMware Fusion을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd088c2100115936fa0084c0d700784a083ba767" translate="yes" xml:space="preserve">
          <source>Creates machines on &lt;a href=&quot;http://vcloud.vmware.com&quot;&gt;vCloud Air&lt;/a&gt; subscription service. You need an account within an existing subscription of vCloud Air VPC or Dedicated Cloud.</source>
          <target state="translated">&lt;a href=&quot;http://vcloud.vmware.com&quot;&gt;vCloud Air&lt;/a&gt; 구독 서비스 에서 머신을 생성합니다 . 기존 vCloud Air VPC 또는 전용 클라우드 구독 내 계정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2b040600179da3f91beffed8cef26c279c4da872" translate="yes" xml:space="preserve">
          <source>Creates machines on a &lt;a href=&quot;http://www.vmware.com/products/vsphere&quot;&gt;VMware vSphere&lt;/a&gt; Virtual Infrastructure. The machine must have a working vSphere ESXi installation. You can use a paid license or free 60 day trial license. Your installation may also include an optional VCenter server.</source>
          <target state="translated">&lt;a href=&quot;http://www.vmware.com/products/vsphere&quot;&gt;VMware vSphere&lt;/a&gt; 가상 인프라 에서 머신을 생성합니다 . 머신에 작동하는 vSphere ESXi 설치가 있어야합니다. 유료 라이센스 또는 무료 60 일 평가판 라이센스를 사용할 수 있습니다. 설치에는 선택적 VCenter 서버가 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb36cdbe0ce0d03d93791c2afa69d0f83f047b9" translate="yes" xml:space="preserve">
          <source>Creating Delegation Keys</source>
          <target state="translated">위임 키 만들기</target>
        </trans-unit>
        <trans-unit id="346b96dd2a298e8e4e58d8d7fd5ea860bb5196d8" translate="yes" xml:space="preserve">
          <source>Creating the plugin</source>
          <target state="translated">플러그인 만들기</target>
        </trans-unit>
        <trans-unit id="572c87b0f7af9ef5b0d44e74f5689d36c33bf38c" translate="yes" xml:space="preserve">
          <source>Credential helper protocol</source>
          <target state="translated">자격 증명 도우미 프로토콜</target>
        </trans-unit>
        <trans-unit id="50eff9046add9e39454939a3b21539f8d83ef2d8" translate="yes" xml:space="preserve">
          <source>Credential helpers</source>
          <target state="translated">자격 증명 도우미</target>
        </trans-unit>
        <trans-unit id="9b0e43a5d170812e639cd468740b6ffe7214476a" translate="yes" xml:space="preserve">
          <source>Credential helpers are similar to the credential store above, but act as the designated programs to handle credentials for &lt;em&gt;specific registries&lt;/em&gt;. The default credential store (&lt;code&gt;credsStore&lt;/code&gt; or the config file itself) will not be used for operations concerning credentials of the specified registries.</source>
          <target state="translated">자격 증명 도우미는 위의 자격 증명 저장소와 유사하지만 &lt;em&gt;특정 레지스트리의&lt;/em&gt; 자격 증명을 처리하는 지정된 프로그램의 역할을합니다 . 지정된 신임 정보의 신임 정보와 관련된 조작 에는 기본 신임 정보 저장소 ( &lt;code&gt;credsStore&lt;/code&gt; 또는 구성 파일 자체)가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae3d12aa496b774388ec30a2c753188ca35bf250" translate="yes" xml:space="preserve">
          <source>Credential helpers are specified in a similar way to &lt;code&gt;credsStore&lt;/code&gt;, but allow for multiple helpers to be configured at a time. Keys specify the registry domain, and values specify the suffix of the program to use (i.e. everything after &lt;code&gt;docker-credential-&lt;/code&gt;). For example:</source>
          <target state="translated">신임 헬퍼는 &lt;code&gt;credsStore&lt;/code&gt; 와 유사한 방식으로 지정 되지만 한 번에 여러 헬퍼를 구성 할 수 있습니다. 키는 레지스트리 도메인을 지정하고 값은 사용할 프로그램의 접미사를 지정합니다 (즉, &lt;code&gt;docker-credential-&lt;/code&gt; 다음의 모든 것 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61c25bc38a2e80c3955be63adb2e3e0697e9d0bf" translate="yes" xml:space="preserve">
          <source>Credential helpers can be any program or script that follows a very simple protocol. This protocol is heavily inspired by Git, but it differs in the information shared.</source>
          <target state="translated">자격 증명 도우미는 매우 간단한 프로토콜을 따르는 모든 프로그램이나 스크립트가 될 수 있습니다. 이 프로토콜은 Git에서 많은 영감을 받았지만 공유되는 정보가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="13fd7f7900c5dda9777460fab327589eef71ed3b" translate="yes" xml:space="preserve">
          <source>Credential spec files are applied at runtime, eliminating the need for host-based credential spec files or registry entries - no gMSA credentials are written to disk on worker nodes. You can make credential specs available to Docker Engine running swarm kit worker nodes before a container starts. When deploying a service using a gMSA-based config, the credential spec is passed directly to the runtime of containers in that service.</source>
          <target state="translated">자격 증명 사양 파일은 런타임에 적용되므로 호스트 기반 자격 증명 사양 파일이나 레지스트리 항목이 필요하지 않습니다. 작업자 노드의 디스크에 gMSA 자격 증명이 기록되지 않습니다. 컨테이너가 시작되기 전에 swarm kit 작업자 노드를 실행하는 Docker Engine에서 신임 정보를 사용할 수 있습니다. gMSA 기반 구성을 사용하여 서비스를 배포하면 자격 증명 사양이 해당 서비스의 컨테이너 런타임으로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1af441562a2e5c4afa1cc0f0016af18589bd06e5" translate="yes" xml:space="preserve">
          <source>Credential spec for managed service account (Windows only)</source>
          <target state="translated">관리 서비스 계정의 자격 증명 사양 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="dd097a229701c1db23e0a192b0e48637872c75b8" translate="yes" xml:space="preserve">
          <source>Credentials</source>
          <target state="translated">Credentials</target>
        </trans-unit>
        <trans-unit id="767fa29a267eb555ad1ebba7510eb40a7b8b4bcc" translate="yes" xml:space="preserve">
          <source>Credentials store</source>
          <target state="translated">자격 증명 저장소</target>
        </trans-unit>
        <trans-unit id="8e4859c8b5edd9f7a9653432d175e11b29d37990" translate="yes" xml:space="preserve">
          <source>Current state of the task</source>
          <target state="translated">작업의 현재 상태</target>
        </trans-unit>
        <trans-unit id="9089cebd2b01ef40e141969560b50dbc41018cbc" translate="yes" xml:space="preserve">
          <source>Current versions of Docker include &lt;em&gt;swarm mode&lt;/em&gt; for natively managing a cluster of Docker Engines called a &lt;em&gt;swarm&lt;/em&gt;. Use the Docker CLI to create a swarm, deploy application services to a swarm, and manage swarm behavior.</source>
          <target state="translated">부두 노동자의 현재 버전은 포함 &lt;em&gt;떼 모드&lt;/em&gt; 기본적으로 불리는 도커 엔진의 클러스터 관리 &lt;em&gt;떼&lt;/em&gt; . Docker CLI를 사용하여 웜을 생성하고, 웜에 애플리케이션 서비스를 배포하고, 웜 동작을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="27fd9c8d7cced70d9569ac86ea4587dd31b200a0" translate="yes" xml:space="preserve">
          <source>Currently Docker supports authorization, volume and network driver plugins. In the future it will support additional plugin types.</source>
          <target state="translated">현재 Docker는 인증, 볼륨 및 네트워크 드라이버 플러그인을 지원합니다. 앞으로 추가 플러그인 유형을 지원할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4081ae0c6ddced73e2afc6312874155a886aaff9" translate="yes" xml:space="preserve">
          <source>Currently supported sysctls</source>
          <target state="translated">현재 지원되는 sysctls</target>
        </trans-unit>
        <trans-unit id="47830fbe2c44c9d9b94e705b642eae728284cd29" translate="yes" xml:space="preserve">
          <source>Currently, content trust is disabled by default in the Docker Client. To enable it, set the &lt;code&gt;DOCKER_CONTENT_TRUST&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. This prevents users from working with tagged images unless they contain a signature.</source>
          <target state="translated">현재 콘텐츠 신뢰는 Docker 클라이언트에서 기본적으로 비활성화되어 있습니다. 사용 가능하게하려면 &lt;code&gt;DOCKER_CONTENT_TRUST&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하십시오 . 이렇게하면 서명이없는 사용자는 태그가 지정된 이미지로 작업 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1110f65aee995b0ee76f04363bcbd01b1f7f9c6" translate="yes" xml:space="preserve">
          <source>Currently, there is no &lt;code&gt;docker-machine create&lt;/code&gt; driver for HyperKit, so use the &lt;code&gt;virtualbox&lt;/code&gt; driver to create local machines. (See the &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;Docker Machine driver for Oracle VirtualBox&lt;/a&gt;.) You can run both HyperKit and Oracle VirtualBox on the same system. To learn more, see &lt;a href=&quot;https://docs.docker.com/docker-for-mac/docker-toolbox/&quot;&gt;Docker Desktop for Mac vs. Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">현재 HyperKit 용 &lt;code&gt;docker-machine create&lt;/code&gt; 드라이버가 없으므로 &lt;code&gt;virtualbox&lt;/code&gt; 드라이버를 사용하여 로컬 시스템을 만듭니다. ( &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;Oracle VirtualBox 용 Docker Machine 드라이버를&lt;/a&gt; 참조하십시오 .) 동일한 시스템에서 HyperKit 및 Oracle VirtualBox를 모두 실행할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/docker-toolbox/&quot;&gt;Docker Desktop for Mac 및 Docker Toolbox를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb7b0f1a420304ce3134a12e4747bb3796354c68" translate="yes" xml:space="preserve">
          <source>Currently, you can modify the &lt;code&gt;docker&lt;/code&gt; command behavior using environment variables or command-line options. You can also use options within &lt;code&gt;config.json&lt;/code&gt; to modify some of the same behavior. When using these mechanisms, you must keep in mind the order of precedence among them. Command line options override environment variables and environment variables override properties you specify in a &lt;code&gt;config.json&lt;/code&gt; file.</source>
          <target state="translated">현재 환경 변수 또는 명령 행 옵션을 사용하여 &lt;code&gt;docker&lt;/code&gt; 명령 동작을 수정할 수 있습니다. &lt;code&gt;config.json&lt;/code&gt; 내의 옵션을 사용 하여 동일한 동작을 수정할 수도 있습니다 . 이러한 메커니즘을 사용할 때는 그 중 우선 순위를 명심해야합니다. 명령 행 옵션은 환경 변수를 대체하고 환경 변수는 &lt;code&gt;config.json&lt;/code&gt; 파일 에서 지정한 특성을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="be94cef1027d7d14da80a85ed68f14cbd86aac92" translate="yes" xml:space="preserve">
          <source>Currently, you cannot use Docker Desktop for Mac or Docker Desktop for Windows alone to test a &lt;em&gt;multi-node&lt;/em&gt; swarm. However, you can use the included version of &lt;a href=&quot;../../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; to create the swarm nodes (see &lt;a href=&quot;../../../machine/get-started/index&quot;&gt;Get started with Docker Machine and a local VM&lt;/a&gt;), then follow the tutorial for all multi-node features. For this scenario, you run commands from a Docker Desktop for Mac or Docker Desktop for Windows host, but that Docker host itself is &lt;em&gt;not&lt;/em&gt; participating in the swarm. After you create the nodes, you can run all swarm commands as shown from the Mac terminal or Windows PowerShell with Docker Desktop for Mac or Docker Desktop for Windows running.</source>
          <target state="translated">현재 &lt;em&gt;다중 노드&lt;/em&gt; 떼 를 테스트하기 위해 Docker Desktop for Mac 또는 Docker Desktop for Windows 만 사용할 수 없습니다 . 그러나 포함 된 &lt;a href=&quot;../../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; 버전 을 사용하여 swarm 노드를 작성하고 ( &lt;a href=&quot;../../../machine/get-started/index&quot;&gt;Docker Machine 및 로컬 VM 시작&lt;/a&gt; 참조 ) 모든 다중 노드 기능에 대한 학습서를 따르십시오. 이 시나리오의 경우 Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop 호스트에서 명령을 실행하지만 해당 Docker 호스트 자체는 떼에 참여 &lt;em&gt;하지 않습니다&lt;/em&gt; . 노드를 만든 후에는 Mac 터미널 또는 Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop이 실행되는 Windows PowerShell에서 표시된대로 모든 swarm 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c0d790d0bfdef976a124c747237a8aee3867cf" translate="yes" xml:space="preserve">
          <source>Custom AMI and SSH username</source>
          <target state="translated">커스텀 AMI 및 SSH 사용자 이름</target>
        </trans-unit>
        <trans-unit id="100ac3f5746d5d0530f76861f4339cfa92d98c1e" translate="yes" xml:space="preserve">
          <source>Custom DNS search domains. Can be a single value or a list.</source>
          <target state="translated">맞춤 DNS 검색 도메인 단일 값 또는 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0151dc3cdbf422982bde8c987d7f7239bdf0412d" translate="yes" xml:space="preserve">
          <source>Custom DNS servers. Can be a single value or a list.</source>
          <target state="translated">사용자 지정 DNS 서버 단일 값 또는 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cbf505cb5ae88e20e2b75971982b1d7fee785d9" translate="yes" xml:space="preserve">
          <source>Custom Dockerfile implementation allows you to:</source>
          <target state="translated">사용자 정의 Dockerfile 구현을 통해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88db904dbc6313028d188c3431262ec1ca745d4d" translate="yes" xml:space="preserve">
          <source>Custom root Certificate Authority for Registry</source>
          <target state="translated">레지스트리에 대한 사용자 정의 루트 인증 기관</target>
        </trans-unit>
        <trans-unit id="8dfd1aed1794d0463377f145a366071637a21275" translate="yes" xml:space="preserve">
          <source>Custom security group</source>
          <target state="translated">사용자 정의 보안 그룹</target>
        </trans-unit>
        <trans-unit id="ae607f169f00105c98f577bd5dc1b1c41972f9b5" translate="yes" xml:space="preserve">
          <source>Customers of Docker Enterprise Edition run a stable, commercially-supported version of Docker Engine, and as an add-on they get our first-class management software, Docker Datacenter. You can manage every aspect of your application through the interface using Universal Control Plane, run a private image registry with Docker Trusted Registry, integrate with your LDAP provider, sign production images with Docker Content Trust, and many other features.</source>
          <target state="translated">Docker Enterprise Edition 고객은 안정적으로 상업적으로 지원되는 Docker Engine 버전을 실행하며 애드온으로 일류 관리 소프트웨어 인 Docker Datacenter를 제공합니다. Universal Control Plane을 사용하여 인터페이스를 통해 애플리케이션의 모든 측면을 관리하고 Docker Trusted Registry로 개인 이미지 레지스트리를 실행하며 LDAP 제공자와 통합하고 Docker Content Trust를 사용하여 프로덕션 이미지에 서명하고 기타 여러 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b0e7cd97ad2f0a9a84c790c5b344a3d0d9b9d5" translate="yes" xml:space="preserve">
          <source>Customize a service&amp;rsquo;s isolation mode</source>
          <target state="translated">서비스 격리 모드 사용자 정의</target>
        </trans-unit>
        <trans-unit id="44599269a95ae3f9a3c03eac6e1bc420a2643f9a" translate="yes" xml:space="preserve">
          <source>D-Bus Secret Service: https://github.com/docker/docker-credential-helpers/releases</source>
          <target state="translated">D- 버스 비밀 서비스 : https://github.com/docker/docker-credential-helpers/releases</target>
        </trans-unit>
        <trans-unit id="075b4a95e8c47ed7f2dfdb5df9a1d8b43f582990" translate="yes" xml:space="preserve">
          <source>DAB file</source>
          <target state="translated">DAB 파일</target>
        </trans-unit>
        <trans-unit id="3d2463fb0ec9034d839ac7d59a6a2537ebc0f169" translate="yes" xml:space="preserve">
          <source>DAC_OVERRIDE</source>
          <target state="translated">DAC_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="adf655b5664e5476ae1a4f6296573e9540cca701" translate="yes" xml:space="preserve">
          <source>DAC_READ_SEARCH</source>
          <target state="translated">DAC_READ_SEARCH</target>
        </trans-unit>
        <trans-unit id="f8d09d2312b4b561137aa82dd85a15d5e54949e7" translate="yes" xml:space="preserve">
          <source>DB storage example:</source>
          <target state="translated">DB 스토리지 예 :</target>
        </trans-unit>
        <trans-unit id="62f1da82a36956513704610758c0773de15fbc73" translate="yes" xml:space="preserve">
          <source>DCT does not verify that a running container&amp;rsquo;s filesystem has not been altered from what was in the image. For example, it does not prevent a container from writing to the filesystem, once the container is running, nor does it prevent the container&amp;rsquo;s filesystem from being altered on disk. DCT will also not prevent unsigned images from being imported, loaded, or created.</source>
          <target state="translated">DCT는 실행중인 컨테이너의 파일 시스템이 이미지의 내용과 변경되지 않았는지 확인하지 않습니다. 예를 들어, 컨테이너가 실행되면 컨테이너가 파일 시스템에 쓰지 못하도록하거나 컨테이너의 파일 시스템이 디스크에서 변경되는 것을 막지 않습니다. DCT는 또한 서명되지 않은 이미지를 가져 오거나로드하거나 만들지 못하게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5d1fe1fb36ec3406338802addf876e51617baee" translate="yes" xml:space="preserve">
          <source>DCT is associated with the &lt;code&gt;TAG&lt;/code&gt; portion of an image. Each image repository has a set of keys that image publishers use to sign an image tag. Image publishers have discretion on which tags they sign.</source>
          <target state="translated">DCT는 이미지 의 &lt;code&gt;TAG&lt;/code&gt; 부분 과 관련이 있습니다. 각 이미지 저장소에는 이미지 게시자가 이미지 태그에 서명하는 데 사용하는 키 세트가 있습니다. 이미지 게시자는 자신이 서명 한 태그에 대해 재량권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="08ebf767f3e0485c33c91186c567476a23890029" translate="yes" xml:space="preserve">
          <source>DCT is controlled by the Docker Engine&amp;rsquo;s configuration file. By default this is found at &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;. More details on this file can be found &lt;a href=&quot;../../../reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">DCT는 Docker Engine의 구성 파일에 의해 제어됩니다. 기본적으로 이것은 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 에 있습니다. 이 파일에 대한 자세한 내용은 &lt;a href=&quot;../../../reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="296737c1835c809024d82990900d3e5d52c80396" translate="yes" xml:space="preserve">
          <source>DNS misconfigurations can generate problems with &lt;code&gt;pip&lt;/code&gt;. You need to set your own DNS server address to make &lt;code&gt;pip&lt;/code&gt; work properly. You might want to change the DNS settings of the Docker daemon. You can edit (or create) the configuration file at &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; with the &lt;code&gt;dns&lt;/code&gt; key, as following:</source>
          <target state="translated">DNS 구성이 잘못되면 &lt;code&gt;pip&lt;/code&gt; 에 문제가 발생할 수 있습니다 . &lt;code&gt;pip&lt;/code&gt; 가 제대로 작동하려면 고유 한 DNS 서버 주소를 설정해야합니다 . Docker 데몬의 DNS 설정을 변경할 수 있습니다. 다음 과 같이 &lt;code&gt;dns&lt;/code&gt; 키를 사용하여 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 에서 구성 파일을 편집 (또는 작성) 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cead5494dadffd261d39591bfcce95dde62edc5" translate="yes" xml:space="preserve">
          <source>DOCKER_CERT_PATH</source>
          <target state="translated">DOCKER_CERT_PATH</target>
        </trans-unit>
        <trans-unit id="fdff43b66b8bfbd2930f9e1d19d37355d869c48b" translate="yes" xml:space="preserve">
          <source>DOCKER_CONTENT_TRUST_OFFLINE_PASSPHRASE is now named DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE</source>
          <target state="translated">DOCKER_CONTENT_TRUST_OFFLINE_PASSPHRASE의 이름이 이제 DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="e71a1ddafbc15187f16cbaee23419484701bad26" translate="yes" xml:space="preserve">
          <source>DOCKER_CONTENT_TRUST_TAGGING_PASSPHRASE is now named DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE</source>
          <target state="translated">DOCKER_CONTENT_TRUST_TAGGING_PASSPHRASE의 이름은 이제 DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE입니다.</target>
        </trans-unit>
        <trans-unit id="02709165bae45deea5d4f1dbcc6a7861b030f64e" translate="yes" xml:space="preserve">
          <source>DOCKER_HOST</source>
          <target state="translated">DOCKER_HOST</target>
        </trans-unit>
        <trans-unit id="4e7191556fb8f788a954a7325117d150a81e4416" translate="yes" xml:space="preserve">
          <source>DOCKER_TLS_VERIFY</source>
          <target state="translated">DOCKER_TLS_VERIFY</target>
        </trans-unit>
        <trans-unit id="899a3d7bf7f3a02b8c57aefbb3cda766edfdc3dc" translate="yes" xml:space="preserve">
          <source>DRBD plugin</source>
          <target state="translated">DRBD 플러그인</target>
        </trans-unit>
        <trans-unit id="efc5bc14d89eb3989b04a9a424bd8ffad65d2903" translate="yes" xml:space="preserve">
          <source>Daemon -&amp;gt; Plugin</source>
          <target state="translated">데몬-&amp;gt; 플러그인</target>
        </trans-unit>
        <trans-unit id="170e01374aaa04ddfcf6d43180f6006e03a6d43a" translate="yes" xml:space="preserve">
          <source>Daemon DNS options</source>
          <target state="translated">데몬 DNS 옵션</target>
        </trans-unit>
        <trans-unit id="1763ac0999fd3431d0ad34214bb74d73b0e8fb73" translate="yes" xml:space="preserve">
          <source>Daemon configuration file</source>
          <target state="translated">데몬 구성 파일</target>
        </trans-unit>
        <trans-unit id="bdcf17f092d88cae35bfcc96221a3237a8aaf17a" translate="yes" xml:space="preserve">
          <source>Daemon metrics</source>
          <target state="translated">데몬 메트릭</target>
        </trans-unit>
        <trans-unit id="c28beefa3df9cc47ca6b1c6928c72df36c2c8319" translate="yes" xml:space="preserve">
          <source>Daemon modes</source>
          <target state="translated">데몬 모드</target>
        </trans-unit>
        <trans-unit id="15010e3fd8304d53b48429bd60699b8b5a5d4bb3" translate="yes" xml:space="preserve">
          <source>Daemon socket option</source>
          <target state="translated">데몬 소켓 옵션</target>
        </trans-unit>
        <trans-unit id="e4241a7fcd010bef70f651afad7b555fa19843a8" translate="yes" xml:space="preserve">
          <source>Daemon storage-driver</source>
          <target state="translated">데몬 스토리지 드라이버</target>
        </trans-unit>
        <trans-unit id="0cee0969d363d5c038a459352c65ce0635eab46d" translate="yes" xml:space="preserve">
          <source>Daemon user namespace options</source>
          <target state="translated">데몬 사용자 네임 스페이스 옵션</target>
        </trans-unit>
        <trans-unit id="121a37f5f85a3a162018e843c756b5a8c8364e27" translate="yes" xml:space="preserve">
          <source>Daemons</source>
          <target state="translated">Daemons</target>
        </trans-unit>
        <trans-unit id="072949f98fcdb44a858421a260964521fe183df4" translate="yes" xml:space="preserve">
          <source>Data volumes</source>
          <target state="translated">데이터 양</target>
        </trans-unit>
        <trans-unit id="5250c90f1902307b40ae97fd9c40a5ebbc5127cf" translate="yes" xml:space="preserve">
          <source>Data volumes are storage that exist independently of a container. The lifecycle of data volumes under swarm services is similar to that under containers. Volumes outlive tasks and services, so their removal must be managed separately. Volumes can be created before deploying a service, or if they don&amp;rsquo;t exist on a particular host when a task is scheduled there, they are created automatically according to the volume specification on the service.</source>
          <target state="translated">데이터 볼륨은 컨테이너와 독립적으로 존재하는 스토리지입니다. 스웜 서비스에서 데이터 볼륨의 수명주기는 컨테이너에서와 비슷합니다. 볼륨은 작업 및 서비스보다 오래되므로 제거는 별도로 관리해야합니다. 서비스를 배포하기 전에 볼륨을 만들거나 작업을 예약 할 때 특정 호스트에 볼륨이 없으면 서비스의 볼륨 사양에 따라 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d9df769b266c487f912c433c67364fc569bb2078" translate="yes" xml:space="preserve">
          <source>Databases</source>
          <target state="translated">Databases</target>
        </trans-unit>
        <trans-unit id="ceea7263c52dfcc2b788001e480ee8b80b3222de" translate="yes" xml:space="preserve">
          <source>Dealing with dynamically created devices (--device-cgroup-rule)</source>
          <target state="translated">동적으로 생성 된 장치 다루기 (--device-cgroup-rule)</target>
        </trans-unit>
        <trans-unit id="f775329a5b94da0d8b124d7e0ac6a8c3f9336607" translate="yes" xml:space="preserve">
          <source>Debian</source>
          <target state="translated">Debian</target>
        </trans-unit>
        <trans-unit id="5367a25a69aa999b3ce10c122069b404f503c7e9" translate="yes" xml:space="preserve">
          <source>Debian 9</source>
          <target state="translated">데비안 9</target>
        </trans-unit>
        <trans-unit id="59bb0100c22f69c6fb05b7971f4898cc42672196" translate="yes" xml:space="preserve">
          <source>Debug AppArmor</source>
          <target state="translated">AppArmor 디버그</target>
        </trans-unit>
        <trans-unit id="8de98ff28fdaf7b82ad6c1a70d7f197b8522bf34" translate="yes" xml:space="preserve">
          <source>Debug the redis container by running another container that has strace in it:</source>
          <target state="translated">strace가있는 다른 컨테이너를 실행하여 redis 컨테이너를 디버그하십시오.</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="925b2b94a96df73123944669d3f72d1a02a5841e" translate="yes" xml:space="preserve">
          <source>Debugging plugins</source>
          <target state="translated">플러그인 디버깅</target>
        </trans-unit>
        <trans-unit id="55ed113c1a9eb71584f9e5ef064d9683dea9afef" translate="yes" xml:space="preserve">
          <source>Declare default environment variables in file</source>
          <target state="translated">파일에서 기본 환경 변수 선언</target>
        </trans-unit>
        <trans-unit id="0a9083b607343d5dea600f69e8998aa8c7446d64" translate="yes" xml:space="preserve">
          <source>Decrypted Delegation Key + Decrypted Snapshot Key + Notary Service write-capable credentials</source>
          <target state="translated">해독 된 위임 키 + 해독 된 스냅 샷 키 + 공증인 서비스 쓰기 가능 자격 증명</target>
        </trans-unit>
        <trans-unit id="22f3f182c4fa9138ca7c47e7e04015d9ac519af8" translate="yes" xml:space="preserve">
          <source>Decrypted Delegation Key + Decrypted Snapshot Key, only</source>
          <target state="translated">해독 된 위임 키 + 해독 된 스냅 샷 키만</target>
        </trans-unit>
        <trans-unit id="0f05f13cc57f690f4d3626a5d3ee6a0d1dcb6999" translate="yes" xml:space="preserve">
          <source>Decrypted Delegation Key + Notary Service write-capable credentials</source>
          <target state="translated">해독 된 위임 키 + 공증 서비스 쓰기 가능 자격 증명</target>
        </trans-unit>
        <trans-unit id="f68f590872f48fbf7bf7de673e48099ecda42bb2" translate="yes" xml:space="preserve">
          <source>Decrypted Delegation Key, only</source>
          <target state="translated">해독 된 위임 키만</target>
        </trans-unit>
        <trans-unit id="614dc2a91e682005d61a514639b3b4ebcc92591b" translate="yes" xml:space="preserve">
          <source>Decrypted Root Key + none or any combination of decrypted keys + Notary Service write-capable credentials</source>
          <target state="translated">암호 해독 된 루트 키 + 암호 해독 된 키 없음 또는 조합 + 공증 서비스 쓰기 가능 자격 증명</target>
        </trans-unit>
        <trans-unit id="f2db1f598756425d85209e0b65e0e51805c0a759" translate="yes" xml:space="preserve">
          <source>Decrypted Root Key + none or any combination of decrypted keys, only</source>
          <target state="translated">암호 해독 된 루트 키 + 암호 해독 된 키의 조합 또는 없음</target>
        </trans-unit>
        <trans-unit id="6adb11010fbc19c83a46949e48ef0b57c43bde49" translate="yes" xml:space="preserve">
          <source>Decrypted Targets Key + Decrypted Snapshot Key + Notary Service write-capable credentials</source>
          <target state="translated">암호 해독 된 대상 키 + 암호 해독 된 스냅 샷 키 + 공증인 서비스 쓰기 가능 자격 증명</target>
        </trans-unit>
        <trans-unit id="067add7134101a7390466c84dd84ce476968fdde" translate="yes" xml:space="preserve">
          <source>Decrypted Targets Key + Decrypted Snapshot Key, only</source>
          <target state="translated">암호 해독 된 대상 키 + 암호 해독 된 스냅 샷 키만</target>
        </trans-unit>
        <trans-unit id="abceab95ead4c757abe4dd25c4299486aba6148c" translate="yes" xml:space="preserve">
          <source>Decrypted Targets Key + Notary Service write-capable credentials</source>
          <target state="translated">암호 해독 된 대상 키 + 공증 서비스 쓰기 가능 자격 증명</target>
        </trans-unit>
        <trans-unit id="9f0cc8000bf70ceda9d6e07e8ed4740870d1f2c8" translate="yes" xml:space="preserve">
          <source>Decrypted Targets Key, only</source>
          <target state="translated">해독 된 대상 키만</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="0a094bef6479c0428967f2157a35ae720ed7491b" translate="yes" xml:space="preserve">
          <source>Default &lt;code&gt;ulimit&lt;/code&gt; settings</source>
          <target state="translated">기본 &lt;code&gt;ulimit&lt;/code&gt; 설정</target>
        </trans-unit>
        <trans-unit id="279135b160653c468c76d4d9728d88dc3cf45596" translate="yes" xml:space="preserve">
          <source>Default AMIs</source>
          <target state="translated">기본 AMI</target>
        </trans-unit>
        <trans-unit id="d595947198b2650834662c8fb4e56d2a61a2c7f5" translate="yes" xml:space="preserve">
          <source>Default IP when binding container ports</source>
          <target state="translated">컨테이너 포트 바인딩시 기본 IP</target>
        </trans-unit>
        <trans-unit id="393c57d4354177cdde7897ea5e52449416375b69" translate="yes" xml:space="preserve">
          <source>Default base operating systems for local and cloud hosts</source>
          <target state="translated">로컬 및 클라우드 호스트를위한 기본 운영 체제</target>
        </trans-unit>
        <trans-unit id="efc2b2805691dec1aa3faf903fef171b6f73830f" translate="yes" xml:space="preserve">
          <source>Default behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe71d2fcfc830bf2155cd1cd7010d2be536047ec" translate="yes" xml:space="preserve">
          <source>Default cgroup parent</source>
          <target state="translated">기본 cgroup 부모</target>
        </trans-unit>
        <trans-unit id="ad80af755576e5d21ff5ca05a9c801c7ca3fe19c" translate="yes" xml:space="preserve">
          <source>Default logging driver for Docker. Writes JSON messages to file. No logging options are supported for this driver.</source>
          <target state="translated">Docker의 기본 로깅 드라이버. JSON 메시지를 파일에 씁니다. 이 드라이버에는 로깅 옵션이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1dac81c76957fbb60942c07f71f984f66f2b7c9" translate="yes" xml:space="preserve">
          <source>Default orchestrator for stack operations to use with this context (swarm|kubernetes|all)</source>
          <target state="translated">이 컨텍스트에서 사용할 스택 작업의 기본 오케 스트레이터 (swarm | kubernetes | all)</target>
        </trans-unit>
        <trans-unit id="0f881f0e3ec5f9d6f1fc0fd8fc366e10d34bf05c" translate="yes" xml:space="preserve">
          <source>Default output</source>
          <target state="translated">기본 출력</target>
        </trans-unit>
        <trans-unit id="5aaa1749bd9c10a1961c032f08b68e8abb43acfe" translate="yes" xml:space="preserve">
          <source>Default user authorization mechanism</source>
          <target state="translated">기본 사용자 인증 메커니즘</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="dbbd33f643700a75519791f9f5797932592b72e1" translate="yes" xml:space="preserve">
          <source>Deferred device removal means that if device is busy when devices are being removed/deactivated, then a deferred removal is scheduled on device. And devices automatically go away when last user of the device exits.</source>
          <target state="translated">지연된 장치 제거는 장치를 제거 / 비활성화 할 때 장치가 사용 중이면 지연된 제거가 장치에서 예약됨을 의미합니다. 장치의 마지막 사용자가 종료되면 장치가 자동으로 사라집니다.</target>
        </trans-unit>
        <trans-unit id="73abda24c0ca3b8b8dde92ba2c40a6e7c395a507" translate="yes" xml:space="preserve">
          <source>Define a container with &lt;code&gt;Dockerfile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 을 사용 하여 컨테이너 정의</target>
        </trans-unit>
        <trans-unit id="e9ef13a71018b21569a2657f0a83cc28c745a0a2" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;webnet&lt;/code&gt; network with the default settings (which is a load-balanced overlay network).</source>
          <target state="translated">기본 설정 (로드 밸런싱 된 오버레이 네트워크)으로 &lt;code&gt;webnet&lt;/code&gt; 네트워크를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec12be71d16f96b224856153fa1ed155d38f5c49" translate="yes" xml:space="preserve">
          <source>Define the application dependencies.</source>
          <target state="translated">응용 프로그램 종속성을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="8b7bdebcf7615752dcfb6a5981210d8062e89d32" translate="yes" xml:space="preserve">
          <source>Define the project</source>
          <target state="translated">프로젝트 정의</target>
        </trans-unit>
        <trans-unit id="14380fa68255a99f324216d75f14ef1b093c0e4c" translate="yes" xml:space="preserve">
          <source>Define the project components</source>
          <target state="translated">프로젝트 구성 요소 정의</target>
        </trans-unit>
        <trans-unit id="ab00f55acb5995d4bf4b48fcef49616fdbb68d1a" translate="yes" xml:space="preserve">
          <source>Define the services that make up your app in &lt;code&gt;docker-compose.yml&lt;/code&gt; so they can be run together in an isolated environment.</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 에서 앱을 구성하는 서비스를 정의하여 격리 된 환경에서 함께 실행될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="dfe60b12f4c42255cae1d7032c7cd57ccbadb142" translate="yes" xml:space="preserve">
          <source>Define your app&amp;rsquo;s environment with a &lt;code&gt;Dockerfile&lt;/code&gt; so it can be reproduced anywhere.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 로 앱 환경을 정의하여 어디서나 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f77aac34490836f9e4b92ffcd90923896678636d" translate="yes" xml:space="preserve">
          <source>Defining and using configs in compose files</source>
          <target state="translated">작성 파일에서 구성 정의 및 사용</target>
        </trans-unit>
        <trans-unit id="20b545fdca1f77ab80641fe58ad90683099206ec" translate="yes" xml:space="preserve">
          <source>Defining and using secrets in compose files</source>
          <target state="translated">작성 파일에서 비밀 정의 및 사용</target>
        </trans-unit>
        <trans-unit id="3d444b9766eb82d8e17757d014e4b7aee539493a" translate="yes" xml:space="preserve">
          <source>Delay between restart attempts (ns|us|ms|s|m|h)</source>
          <target state="translated">다시 시작 시도 간 지연 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="1a4f8c4609c63bc9e603df6cb4df236265bc3b5e" translate="yes" xml:space="preserve">
          <source>Delay between restart attempts (ns|us|ms|s|m|h) (default 5s)</source>
          <target state="translated">재시작 시도 간 지연 (ns | us | ms | s | m | h) (기본값 5s)</target>
        </trans-unit>
        <trans-unit id="6c31e7e76dd7558090a1077fb7f838ddab9948cf" translate="yes" xml:space="preserve">
          <source>Delay between task rollbacks (ns|us|ms|s|m|h)</source>
          <target state="translated">작업 롤백 사이의 지연 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="8a8c1562fe07fb41a58d185552616acfef1d7cf8" translate="yes" xml:space="preserve">
          <source>Delay between task rollbacks (ns|us|ms|s|m|h) (default 0s)</source>
          <target state="translated">작업 롤백 사이의 지연 (ns | us | ms | s | m | h) (기본값 0)</target>
        </trans-unit>
        <trans-unit id="cc0534877bdcbedd89091d53051e5073e6ea167a" translate="yes" xml:space="preserve">
          <source>Delay between updates (ns|us|ms|s|m|h)</source>
          <target state="translated">업데이트 간 지연 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="c7deed47d8e10b7f9df976e44e885c304a3d9b7e" translate="yes" xml:space="preserve">
          <source>Delay between updates (ns|us|ms|s|m|h) (default 0s)</source>
          <target state="translated">업데이트 간 지연 (ns | us | ms | s | m | h) (기본 0s)</target>
        </trans-unit>
        <trans-unit id="b53c64fe6a857cc55a10677529e5d1f621745f8b" translate="yes" xml:space="preserve">
          <source>Delegation key</source>
          <target state="translated">위임 키</target>
        </trans-unit>
        <trans-unit id="e1203146ef7d1cb8a3527086cafb0315eb15c1ed" translate="yes" xml:space="preserve">
          <source>Delegation key, Snapshot key</source>
          <target state="translated">위임 키, 스냅 샷 키</target>
        </trans-unit>
        <trans-unit id="3d4cd78a02c93af009004ad314829a3688c08dbc" translate="yes" xml:space="preserve">
          <source>Delegation keys are optional tagging keys and allow you to delegate signing image tags to other publishers without having to share your targets key.</source>
          <target state="translated">위임 키는 선택적인 태그 키이며 대상 키를 공유하지 않고도 서명 이미지 태그를 다른 게시자에게 위임 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc81b039085920d00adc579665e69e4b7b1f0660" translate="yes" xml:space="preserve">
          <source>Delegation keys are optional, and not generated as part of the normal &lt;code&gt;docker&lt;/code&gt; workflow. They need to be &lt;a href=&quot;../trust_delegation/index#generating-delegation-keys&quot;&gt;manually generated and added to the repository&lt;/a&gt;.</source>
          <target state="translated">위임 키는 선택 사항이며 일반 &lt;code&gt;docker&lt;/code&gt; 워크 플로의 일부로 생성되지 않습니다 . 그들은 할 필요가 &lt;a href=&quot;../trust_delegation/index#generating-delegation-keys&quot;&gt;수동으로 생성 저장소에 추가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5025b6581b8de46618baedb125e788e71d0b00b" translate="yes" xml:space="preserve">
          <source>Delegation keys sign &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;delegation metadata files&lt;/a&gt;, which lists filenames in the collection, and their sizes and respective &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;hashes&lt;/a&gt;. These files are used to verify the integrity of some or all of the actual contents of the repository. They are also used to [delegate trust to other collaborators via lower level &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;delegation roles&lt;/a&gt;. Delegation keys are held by anyone from the collection owner or administrator to collection collaborators.</source>
          <target state="translated">위임 키는 &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;위임 메타 데이터 파일에&lt;/a&gt; 서명합니다. 위임 메타 데이터 파일 에는 컬렉션의 파일 이름과 크기 및 각각의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;해시&lt;/a&gt; 가 나열 됩니다. 이 파일은 리포지토리의 일부 또는 모든 실제 내용의 무결성을 확인하는 데 사용됩니다. 또한 하위 수준 &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;위임 역할을&lt;/a&gt; 통해 다른 공동 작업자에게 신뢰를 위임하는 데에도 사용됩니다 . 컬렉션 키 소유자 또는 관리자가 컬렉션 공동 작업자에게 위임 키를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6151626d831da994a329fff0144b59699f2fbec3" translate="yes" xml:space="preserve">
          <source>Delegation roles simplify collaborator workflows in notary trusted collections, and also allow for fine-grained permissions within a collection&amp;rsquo;s contents across delegations. In essence, delegation roles are restricted versions of the targets role that are only allowed to sign targets within certain filepaths.</source>
          <target state="translated">위임 역할은 공증 된 신뢰할 수있는 컬렉션에서 공동 작업자 워크 플로를 단순화하고 위임 전체의 컬렉션 내용 내에서 세분화 된 권한을 허용합니다. 본질적으로 위임 역할은 특정 파일 경로 내에서만 대상에 서명 할 수있는 제한된 버전의 대상 역할입니다.</target>
        </trans-unit>
        <trans-unit id="a9d305daf767e532550292a9ae3e2b283a73a090" translate="yes" xml:space="preserve">
          <source>Delegations for content trust</source>
          <target state="translated">콘텐츠 신뢰 위임</target>
        </trans-unit>
        <trans-unit id="327c8749d53afe957468edd419507d208d02097e" translate="yes" xml:space="preserve">
          <source>Delegations in Docker Content Trust (DCT) allow you to control who can and cannot sign an image tag. A delegation will have a pair of private and public delegation keys. A delegation could contain multiple pairs of keys and contributors in order to a) allow multiple users to be part of a delegation, and b) to support key rotation.</source>
          <target state="translated">Docker Content Trust (DCT)의 위임을 사용하면 이미지 태그에 서명 할 수있는 사람과 서명 할 수없는 사람을 제어 할 수 있습니다. 위임에는 개인 및 공개 위임 키 쌍이 있습니다. 위임은 a) 여러 사용자가 위임의 일부가 될 수 있도록하고 b) 키 순환을 지원하기 위해 여러 쌍의 키와 기고자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb92738ab53c6cbeff384e0a24a2cfd9a45dc16" translate="yes" xml:space="preserve">
          <source>Delete a tag</source>
          <target state="translated">태그 삭제</target>
        </trans-unit>
        <trans-unit id="2a38e729c3088c2f3c0a9056be8fd2133c61ace6" translate="yes" xml:space="preserve">
          <source>Delete the service running on the swarm</source>
          <target state="translated">떼에서 실행되는 서비스 삭제</target>
        </trans-unit>
        <trans-unit id="5160893bc61c21be5ddbaac22f60eecb08a0a476" translate="yes" xml:space="preserve">
          <source>Delete the specified volume from disk. This request is issued when a user invokes &lt;code&gt;docker rm -v&lt;/code&gt; to remove volumes associated with a container.</source>
          <target state="translated">디스크에서 지정된 볼륨을 삭제하십시오. 이 요청은 사용자가 &lt;code&gt;docker rm -v&lt;/code&gt; 를 호출 하여 컨테이너와 연관된 볼륨을 제거 할 때 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e37c7b3569ede2bbe1e3a5ffc7fa9e0e3793ca2" translate="yes" xml:space="preserve">
          <source>Demote one or more nodes from manager in the swarm</source>
          <target state="translated">떼의 관리자에서 하나 이상의 노드 강등</target>
        </trans-unit>
        <trans-unit id="a67996643297c2d757052881da1a13340799d1db" translate="yes" xml:space="preserve">
          <source>Demotes an existing manager so that it is no longer a manager. This command targets a docker engine that is a manager in the swarm.</source>
          <target state="translated">더 이상 관리자가되지 않도록 기존 관리자를 강등시킵니다. 이 명령은 swarm의 관리자 인 도커 엔진을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="562e8903063ed8770f6527d563bca3ab2868b0d9" translate="yes" xml:space="preserve">
          <source>Denial of Service</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657ec7161ca0893a8398727168d9a686f396c71b" translate="yes" xml:space="preserve">
          <source>Deny &lt;code&gt;pivot_root&lt;/code&gt;, should be privileged operation.</source>
          <target state="translated">&lt;code&gt;pivot_root&lt;/code&gt; 거부 는 권한있는 작업이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c91e0e2afc67a1726aabdabd1c6bbb8ffb1917a" translate="yes" xml:space="preserve">
          <source>Deny associating a thread with a namespace. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">스레드와 네임 스페이스 연결을 거부합니다. &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="e33d1c27b0f058d56e6066a514c65ecf336af269" translate="yes" xml:space="preserve">
          <source>Deny cloning new namespaces for processes. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;, with the exception of &lt;code&gt;unshare --user&lt;/code&gt;.</source>
          <target state="translated">프로세스의 새 네임 스페이스 복제를 거부합니다. &lt;code&gt;unshare --user&lt;/code&gt; 를 제외 하고 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="c26eb5e0718364a0a48f0cbe7e98393d84533464" translate="yes" xml:space="preserve">
          <source>Deny cloning new namespaces. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; for CLONE_* flags, except &lt;code&gt;CLONE_USERNS&lt;/code&gt;.</source>
          <target state="translated">새 네임 스페이스 복제를 거부합니다. CLONE_USERNS를 제외하고 &lt;code&gt;CLONE_USERNS&lt;/code&gt; * 플래그에 대해 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e492f056ddf2974291b2bd148606f3490e46c284" translate="yes" xml:space="preserve">
          <source>Deny interaction with the kernel nfs daemon. Obsolete since Linux 3.1.</source>
          <target state="translated">커널 nfs 데몬과의 상호 작용을 거부합니다. Linux 3.1부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2304d3fa80630e2e2b2bde48b253e40a47990c11" translate="yes" xml:space="preserve">
          <source>Deny loading a new kernel for later execution. Also gated by &lt;code&gt;CAP_SYS_BOOT&lt;/code&gt;.</source>
          <target state="translated">나중에 실행할 새 커널로드를 거부하십시오. &lt;code&gt;CAP_SYS_BOOT&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2478e82e010014119a01de72284e09d752b9839" translate="yes" xml:space="preserve">
          <source>Deny loading potentially persistent bpf programs into kernel, already gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 이미 게이트 된 잠재적 bpf 프로그램을 커널로로드하는 것을 거부하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb64c5e7729411408bee7d652e6469d381b16346" translate="yes" xml:space="preserve">
          <source>Deny manipulation and functions on kernel modules. Also gated by &lt;code&gt;CAP_SYS_MODULE&lt;/code&gt;.</source>
          <target state="translated">커널 모듈에서의 조작 및 기능 거부 &lt;code&gt;CAP_SYS_MODULE&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="a741e056ec871bc4ae62b34ad516e40c5699c87d" translate="yes" xml:space="preserve">
          <source>Deny manipulation and functions on kernel modules. Obsolete.</source>
          <target state="translated">커널 모듈에서의 조작 및 기능 거부 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="338b8dcb44072b70c3e9bde2caf37fe69bb5d142" translate="yes" xml:space="preserve">
          <source>Deny manipulation and functions on kernel modules. Obsolete. Also gated by &lt;code&gt;CAP_SYS_MODULE&lt;/code&gt;.</source>
          <target state="translated">커널 모듈에서의 조작 및 기능 거부 더 이상 사용되지 않습니다. &lt;code&gt;CAP_SYS_MODULE&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d148a4612cc99fe95bbad92867e133ea7e828fb" translate="yes" xml:space="preserve">
          <source>Deny mounting, already gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">이미에 의해 문이 장착 거부 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e23e44ceaf53ce30a77cac3e490d16999cc985" translate="yes" xml:space="preserve">
          <source>Deny retrieval of exported kernel and module symbols. Obsolete.</source>
          <target state="translated">내 보낸 커널 및 모듈 기호 검색을 거부합니다. 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5b350b48b4c47e3b693e5c2f2b651243a8f9ae4" translate="yes" xml:space="preserve">
          <source>Deny start/stop swapping to file/device. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">파일 / 장치로의 스와핑 시작 / 중지를 거부합니다. &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="406c8b24550593c1ded264d86b0c221004518847" translate="yes" xml:space="preserve">
          <source>Depending on the storage driver in use, additional information can be shown, such as pool name, data file, metadata file, data space used, total data space, metadata space used, and total metadata space.</source>
          <target state="translated">사용중인 스토리지 드라이버에 따라 풀 이름, 데이터 파일, 메타 데이터 파일, 사용 된 데이터 공간, 총 데이터 공간, 사용 된 메타 데이터 공간 및 총 메타 데이터 공간과 같은 추가 정보가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b44ac62807270ffa3b0eb5af71fb9c649df3e7" translate="yes" xml:space="preserve">
          <source>Depending on what you typed on the command line so far, it completes:</source>
          <target state="translated">지금까지 명령 행에 입력 한 내용에 따라 다음이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf58c1f4b33f044c1285cab326d14f589767825" translate="yes" xml:space="preserve">
          <source>Depending on your Docker system configuration, you may be required to preface each &lt;code&gt;docker&lt;/code&gt; command with &lt;code&gt;sudo&lt;/code&gt;. To avoid having to use &lt;code&gt;sudo&lt;/code&gt; with the &lt;code&gt;docker&lt;/code&gt; command, your system administrator can create a Unix group called &lt;code&gt;docker&lt;/code&gt; and add users to it.</source>
          <target state="translated">Docker 시스템 구성에 따라 각 &lt;code&gt;docker&lt;/code&gt; 명령 앞에 &lt;code&gt;sudo&lt;/code&gt; 가 있어야합니다 . &lt;code&gt;docker&lt;/code&gt; 명령 과 함께 &lt;code&gt;sudo&lt;/code&gt; 를 사용하지 않으 려면 시스템 관리자가 &lt;code&gt;docker&lt;/code&gt; 라는 Unix 그룹을 만들어 사용자를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3c6d5ceacc608627ca4286e64130ca8c1fe4a7" translate="yes" xml:space="preserve">
          <source>Depending on your environment&amp;rsquo;s networking configuration, it may take up to 30 seconds for the containers to respond to HTTP requests. This is not indicative of Docker or swarm performance, but rather an unmet Redis dependency that we address later in the tutorial. For now, the visitor counter isn&amp;rsquo;t working for the same reason; we haven&amp;rsquo;t yet added a service to persist data.</source>
          <target state="translated">환경의 네트워킹 구성에 따라 컨테이너가 HTTP 요청에 응답하는 데 최대 30 초가 걸릴 수 있습니다. 이것은 Docker 또는 swarm 성능을 나타내는 것이 아니라 나중에 자습서에서 다루는 충족되지 않은 Redis 종속성입니다. 현재 방문자 카운터는 같은 이유로 작동하지 않습니다. 아직 데이터를 유지하기위한 서비스를 추가하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="feb6d59317d621b62a1a989fc25c55eed2939fa3" translate="yes" xml:space="preserve">
          <source>Deploy Notary Server with Compose</source>
          <target state="translated">작성과 함께 Notary Server 배포</target>
        </trans-unit>
        <trans-unit id="60fcf58f4b5938c6de9d37bdd4bba09360988c57" translate="yes" xml:space="preserve">
          <source>Deploy a new stack or update an existing stack</source>
          <target state="translated">새 스택 배포 또는 기존 스택 업데이트</target>
        </trans-unit>
        <trans-unit id="c2d985f55ebd5738261815a6cbabac66e090c549" translate="yes" xml:space="preserve">
          <source>Deploy a service to the swarm</source>
          <target state="translated">떼에 서비스 배포</target>
        </trans-unit>
        <trans-unit id="f307d98e89b280d66c49a9cf5ad2c3591c1d2d29" translate="yes" xml:space="preserve">
          <source>Deploy services to a swarm</source>
          <target state="translated">떼에 서비스 배포</target>
        </trans-unit>
        <trans-unit id="205b1c97708b7bd3b0f025a0ab73c95d6b343570" translate="yes" xml:space="preserve">
          <source>Deploy the app on the swarm manager</source>
          <target state="translated">떼 관리자에 앱 배포</target>
        </trans-unit>
        <trans-unit id="9e32a684f4f58a4b260b5af40fa57e381e1ebf53" translate="yes" xml:space="preserve">
          <source>Deploy your Redis tag to the swarm and configure the swarm with a 10 second update delay. Note that the following example shows an older Redis tag:</source>
          <target state="translated">Redis 태그를 웜에 배포하고 10 초의 업데이트 지연으로 웜을 구성하십시오. 다음 예제는 이전 Redis 태그를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f5b30162ed997446ef7b9a0210679b50205d94b3" translate="yes" xml:space="preserve">
          <source>Deploy your app</source>
          <target state="translated">앱 배포</target>
        </trans-unit>
        <trans-unit id="9e1c2f275184364df174a066f2ce3479bf0f4a3f" translate="yes" xml:space="preserve">
          <source>Deploy your app on the swarm cluster</source>
          <target state="translated">웜 클러스터에 앱 배포</target>
        </trans-unit>
        <trans-unit id="4880d2aaca6e2f874e6f134c3a20570f7b643e02" translate="yes" xml:space="preserve">
          <source>Deploy your app to production</source>
          <target state="translated">프로덕션에 앱 배포</target>
        </trans-unit>
        <trans-unit id="f1cadfa9b366b3a865227c5370a417d91728ace4" translate="yes" xml:space="preserve">
          <source>Deploying changes</source>
          <target state="translated">변경 사항 배포</target>
        </trans-unit>
        <trans-unit id="36c50ec2616202c90ec5420c454225d71164c71d" translate="yes" xml:space="preserve">
          <source>Deprecated Engine Features</source>
          <target state="translated">더 이상 사용되지 않는 엔진 기능</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="8562043fa00f1093b84876923bf31bf0f1ccfaf2" translate="yes" xml:space="preserve">
          <source>Description of the context</source>
          <target state="translated">문맥에 대한 설명</target>
        </trans-unit>
        <trans-unit id="3a0f23557d568989c44602a98c65506ae979691b" translate="yes" xml:space="preserve">
          <source>Designed to be cross-compatible between Compose and the Docker Engine&amp;rsquo;s &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt;, version 3 removes several options and adds several more.</source>
          <target state="translated">Compose와 Docker Engine의 &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;swarm 모드&lt;/a&gt; 간에 상호 호환되도록 설계된 버전 3은 여러 옵션을 제거하고 여러 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="97cc99e36c88e1878a13d320faca5bf42543ad96" translate="yes" xml:space="preserve">
          <source>Designed to provide an optimized development framework for apps that are deployed to the cloud or run on-premises</source>
          <target state="translated">클라우드에 배포되거나 온 프레미스에서 실행되는 앱에 최적화 된 개발 프레임 워크를 제공하도록 설계</target>
        </trans-unit>
        <trans-unit id="34b1b65ff33062c33552dee2d781d0c3070584c3" translate="yes" xml:space="preserve">
          <source>Desired state of the task (&lt;code&gt;running&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;accepted&lt;/code&gt;)</source>
          <target state="translated">원하는 작업 상태 ( &lt;code&gt;running&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;accepted&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eb873665742106d8005a64c16c377ea1ddf3c282" translate="yes" xml:space="preserve">
          <source>Detached (-d)</source>
          <target state="translated">분리됨 (-d)</target>
        </trans-unit>
        <trans-unit id="44abfdb180f5badff2b40061cc6133e8c09f4ea9" translate="yes" xml:space="preserve">
          <source>Detached mode: run command in the background</source>
          <target state="translated">분리 모드 : 백그라운드에서 명령 실행</target>
        </trans-unit>
        <trans-unit id="9fda204518bb6ba59ac898d6bec1e68ef7e1e9e5" translate="yes" xml:space="preserve">
          <source>Detached vs foreground</source>
          <target state="translated">분리 대 전경</target>
        </trans-unit>
        <trans-unit id="cc1278a0424b43637549a039f376c1d44bb8f18a" translate="yes" xml:space="preserve">
          <source>Detailed run output will be emitted when using the LinodeGo &lt;code&gt;LINODE_DEBUG=1&lt;/code&gt; option along with the &lt;code&gt;docker-machine&lt;/code&gt;&lt;code&gt;--debug&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; &lt;code&gt;--debug&lt;/code&gt; 옵션 과 함께 LinodeGo &lt;code&gt;LINODE_DEBUG=1&lt;/code&gt; 옵션을 사용하면 자세한 실행 출력이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c923b376c93bfa25d2dc92f8dd72a0ba1b98d69c" translate="yes" xml:space="preserve">
          <source>Detect and skip executing unused build stages</source>
          <target state="translated">사용하지 않는 빌드 단계 감지 및 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="84f09c20040f8fa64429e6f0a515948c9abecf0d" translate="yes" xml:space="preserve">
          <source>Detect and skip transferring unused files in your build context</source>
          <target state="translated">빌드 컨텍스트에서 사용하지 않는 파일 전송 감지 및 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="9c29be74391cd3cf42657d8a2f8ec0deb68878f4" translate="yes" xml:space="preserve">
          <source>Develop and run your ASP.NET Core apps cross-platform on Windows, MacOS, and Linux</source>
          <target state="translated">Windows, MacOS 및 Linux에서 ASP.NET Core 앱 크로스 플랫폼 개발 및 실행</target>
        </trans-unit>
        <trans-unit id="7ad0b1a2a2a4624b67402d68603274adc4149a46" translate="yes" xml:space="preserve">
          <source>Developing a plugin</source>
          <target state="translated">플러그인 개발</target>
        </trans-unit>
        <trans-unit id="86930051e532fb0f8e3c6625a84ff35c9022b9ba" translate="yes" xml:space="preserve">
          <source>Development environments</source>
          <target state="translated">개발 환경</target>
        </trans-unit>
        <trans-unit id="93554d18e30c224881b1bf32fd74aa81f4df0a43" translate="yes" xml:space="preserve">
          <source>Devicemapper options</source>
          <target state="translated">장치 매퍼 옵션</target>
        </trans-unit>
        <trans-unit id="4e0d301763da9ac2f4eda478cafe4d96db009aa4" translate="yes" xml:space="preserve">
          <source>Devices available to a container are assigned at creation time. The assigned devices will both be added to the cgroup.allow file and created into the container once it is run. This poses a problem when a new device needs to be added to running container.</source>
          <target state="translated">컨테이너에 사용 가능한 장치는 생성시 할당됩니다. 할당 된 장치는 모두 cgroup.allow 파일에 추가되고 일단 실행되면 컨테이너에 생성됩니다. 이는 실행중인 컨테이너에 새 장치를 추가해야 할 때 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="af944f45bc6a580c2ff86b7c4ccd15c6e6ed05af" translate="yes" xml:space="preserve">
          <source>Differences between &amp;ldquo;--mount&amp;rdquo; and &amp;ldquo;--volume&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;--mount&amp;rdquo;와&amp;ldquo;--volume&amp;rdquo;의 차이점</target>
        </trans-unit>
        <trans-unit id="4d28a823646dad4fa5ce7ae04d766cba5537b95e" translate="yes" xml:space="preserve">
          <source>Different environments</source>
          <target state="translated">다른 환경</target>
        </trans-unit>
        <trans-unit id="2e826a504cf976ac0033b44871860b7f0a480229" translate="yes" xml:space="preserve">
          <source>Different types of SSH</source>
          <target state="translated">다양한 유형의 SSH</target>
        </trans-unit>
        <trans-unit id="9fadd39087d0ca9c53d5821d56db509753e0d4b7" translate="yes" xml:space="preserve">
          <source>Digest can also be used in the &lt;code&gt;FROM&lt;/code&gt; of a Dockerfile, for example:</source>
          <target state="translated">Digest는 Dockerfile 의 &lt;code&gt;FROM&lt;/code&gt; 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed3183e8512b7affbb7cb7e4056e54c3847f73e" translate="yes" xml:space="preserve">
          <source>DigitalOcean</source>
          <target state="translated">DigitalOcean</target>
        </trans-unit>
        <trans-unit id="da5b989b773fd438d038d9f19b95190051448370" translate="yes" xml:space="preserve">
          <source>DigitalOcean Block Storage plugin</source>
          <target state="translated">DigitalOcean Block Storage 플러그인</target>
        </trans-unit>
        <trans-unit id="2267bb09bb2d215c2cadaff92cd40b54aa23f0c9" translate="yes" xml:space="preserve">
          <source>DigitalOcean Example</source>
          <target state="translated">DigitalOcean 예</target>
        </trans-unit>
        <trans-unit id="2fbf521cf611cf54e00144de6fac8b89da8251d3" translate="yes" xml:space="preserve">
          <source>DigitalOcean example</source>
          <target state="translated">DigitalOcean 예제</target>
        </trans-unit>
        <trans-unit id="e0da718dd50c57c4dd15dfaa8613d31738e2fa4e" translate="yes" xml:space="preserve">
          <source>Directly afterwards, run &lt;code&gt;docker service ls&lt;/code&gt;, to see the actual number of replicas.</source>
          <target state="translated">그 후 직접 &lt;code&gt;docker service ls&lt;/code&gt; 를 실행 하여 실제 복제본 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4a8e254f27fd61aa7aeae26c72e12b77f4bf6cb2" translate="yes" xml:space="preserve">
          <source>Directory to generate key in, defaults to current directory</source>
          <target state="translated">키를 생성하는 디렉토리, 기본값은 현재 디렉토리</target>
        </trans-unit>
        <trans-unit id="b5f8767c9eb2602757acda4037e8086b640e6698" translate="yes" xml:space="preserve">
          <source>Disable OOM Killer</source>
          <target state="translated">OOM Killer 비활성화</target>
        </trans-unit>
        <trans-unit id="7d4feaf27871e9c812ca3e3ef7d23778dcdb7f5f" translate="yes" xml:space="preserve">
          <source>Disable a plugin</source>
          <target state="translated">플러그인 비활성화</target>
        </trans-unit>
        <trans-unit id="613720c88836f37026fdc86f600ca13cc1447ae3" translate="yes" xml:space="preserve">
          <source>Disable any container-specified HEALTHCHECK</source>
          <target state="translated">컨테이너 지정 건강 점검 비활성화</target>
        </trans-unit>
        <trans-unit id="a8b75a59c22f29961a07212202124834ba5cb4dc" translate="yes" xml:space="preserve">
          <source>Disable namespace remapping for a container</source>
          <target state="translated">컨테이너에 네임 스페이스 리매핑 비활성화</target>
        </trans-unit>
        <trans-unit id="d2bbc4ec6c38c2c7beb72c5c113c67fe22790940" translate="yes" xml:space="preserve">
          <source>Disable streaming stats and only pull the first result</source>
          <target state="translated">스트리밍 통계를 비활성화하고 첫 번째 결과 만 가져옵니다</target>
        </trans-unit>
        <trans-unit id="c12b28c385f915cd8f2e9fd788f271e431cf00a6" translate="yes" xml:space="preserve">
          <source>Disables a plugin. The plugin must be installed before it can be disabled, see &lt;a href=&quot;../plugin_install/index&quot;&gt;&lt;code&gt;docker plugin install&lt;/code&gt;&lt;/a&gt;. Without the &lt;code&gt;-f&lt;/code&gt; option, a plugin that has references (e.g., volumes, networks) cannot be disabled.</source>
          <target state="translated">플러그인을 비활성화합니다. 플러그인을 사용하지 않으려면 먼저 &lt;a href=&quot;../plugin_install/index&quot;&gt; &lt;code&gt;docker plugin install&lt;/code&gt; &lt;/a&gt; 합니다 ( docker plugin install 참조) . &lt;code&gt;-f&lt;/code&gt; 옵션이 없으면 참조 (예 : 볼륨, 네트워크)가있는 플러그인을 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfc3329cca1108589feb31bcb7ac986e5ee88e4c" translate="yes" xml:space="preserve">
          <source>Disables any logging for the container. &lt;code&gt;docker logs&lt;/code&gt; won&amp;rsquo;t be available with this driver.</source>
          <target state="translated">컨테이너에 대한 로깅을 비활성화합니다. 이 드라이버에서는 &lt;code&gt;docker logs&lt;/code&gt; 를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0baa2a33988fcfcedb8e46916b7af29c8fca8bf" translate="yes" xml:space="preserve">
          <source>Disables the user namespace for this service, if Docker daemon is configured with user namespaces. See &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#disable-user-namespace-for-a-container&quot;&gt;dockerd&lt;/a&gt; for more information.</source>
          <target state="translated">Docker 데몬이 사용자 네임 스페이스로 구성된 경우이 서비스의 사용자 네임 스페이스를 비활성화합니다. 자세한 내용은 &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#disable-user-namespace-for-a-container&quot;&gt;dockerd&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4cc71b070a575bc09f6bbdaaa67034910a051b50" translate="yes" xml:space="preserve">
          <source>Disables the user namespace for this service, if Docker daemon is configured with user namespaces. See &lt;a href=&quot;../../engine/reference/commandline/dockerd/index#disable-user-namespace-for-a-container&quot;&gt;dockerd&lt;/a&gt; for more information.</source>
          <target state="translated">Docker 데몬이 사용자 네임 스페이스로 구성된 경우이 서비스의 사용자 네임 스페이스를 비활성화합니다. 자세한 내용은 &lt;a href=&quot;../../engine/reference/commandline/dockerd/index#disable-user-namespace-for-a-container&quot;&gt;dockerd&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94c45cefffd88bec5229a69467a90582834ffa77" translate="yes" xml:space="preserve">
          <source>Disabling this on loopback can lead to &lt;em&gt;much&lt;/em&gt; faster container removal times, but will make the space used in &lt;code&gt;/var/lib/docker&lt;/code&gt; directory not be returned to the system for other use when containers are removed.</source>
          <target state="translated">루프백에서이를 비활성화하면 컨테이너 제거 시간 이 &lt;em&gt;훨씬&lt;/em&gt; 빨라지지만 컨테이너를 제거 할 때 &lt;code&gt;/var/lib/docker&lt;/code&gt; 디렉토리에 사용 된 공간 이 시스템으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1627486fa2639ec721369ca9e01d91f76c2e3f2" translate="yes" xml:space="preserve">
          <source>Disconnect a container from a network</source>
          <target state="translated">네트워크에서 컨테이너 연결 끊기</target>
        </trans-unit>
        <trans-unit id="7eeea272f53ee873457e2694b4a5fc7a09e6a91c" translate="yes" xml:space="preserve">
          <source>Disconnects a container from a network. The container must be running to disconnect it from the network.</source>
          <target state="translated">컨테이너를 네트워크에서 분리합니다. 컨테이너를 네트워크에서 분리하려면 컨테이너가 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="07c518009e6b759e1550a87ab619b2f5c56814c4" translate="yes" xml:space="preserve">
          <source>Discover Docker&amp;rsquo;s features;</source>
          <target state="translated">Docker의 기능을 발견하십시오.</target>
        </trans-unit>
        <trans-unit id="25a158a70b1fbaeddada5e2abc2e644c98030502" translate="yes" xml:space="preserve">
          <source>Dispatcher heartbeat period (ns|us|ms|s|m|h)</source>
          <target state="translated">디스패처 하트 비트 기간 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="fe8622ee5935b394c4ec0dbdba739bf9d87a3089" translate="yes" xml:space="preserve">
          <source>Display a live stream of container(s) resource usage statistics</source>
          <target state="translated">컨테이너 리소스 사용량 통계의 실시간 스트림 표시</target>
        </trans-unit>
        <trans-unit id="8c350304680fa74e86d2662995e4779f7dfa56a5" translate="yes" xml:space="preserve">
          <source>Display an image manifest, or manifest list</source>
          <target state="translated">이미지 매니페스트 또는 매니페스트 목록 표시</target>
        </trans-unit>
        <trans-unit id="196d16bc9a94dd281ee7e1b88522f43c7fc180ca" translate="yes" xml:space="preserve">
          <source>Display and rotate the root CA</source>
          <target state="translated">루트 CA 표시 및 회전</target>
        </trans-unit>
        <trans-unit id="b7661095c1f0cb0821b8534662f936e0c3338c56" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more configs</source>
          <target state="translated">하나 이상의 구성에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="937d200c8568444b7e1d77461975f2f17b266504" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more containers</source>
          <target state="translated">하나 이상의 컨테이너에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="deb98de8c58a9d2db2ca41e63488ffefbd98a3fd" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more contexts</source>
          <target state="translated">하나 이상의 컨텍스트에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="2668d4e4910e4edecd6782eff98c7e80c5d82dfb" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more images</source>
          <target state="translated">하나 이상의 이미지에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="7a8b978bdfece1e933094d3ed6f83779f497c857" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more networks</source>
          <target state="translated">하나 이상의 네트워크에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="7edb6519c7b2ab35dda46f17cf30660dd2c72b77" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more nodes</source>
          <target state="translated">하나 이상의 노드에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="e43c44f126e612084c6551bc26e876d68fae1c4b" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more plugins</source>
          <target state="translated">하나 이상의 플러그인에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="0e25e2904bffd4aeef7f96bd0abbcc70e9313975" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more secrets</source>
          <target state="translated">하나 이상의 비밀에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="319af85fb8a8442e35170f717ac7e5a6dc6b2199" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more services</source>
          <target state="translated">하나 이상의 서비스에 대한 자세한 정보 표시</target>
        </trans-unit>
        <trans-unit id="abc5f31476724eb1c6d859b1c21010a78c660011" translate="yes" xml:space="preserve">
          <source>Display detailed information on one or more volumes</source>
          <target state="translated">하나 이상의 볼륨에 대한 자세한 정보를 표시합니다</target>
        </trans-unit>
        <trans-unit id="4c357e1bceec8c70eb54f83b50e6e92950edeb4a" translate="yes" xml:space="preserve">
          <source>Display help text</source>
          <target state="translated">도움말 텍스트 표시</target>
        </trans-unit>
        <trans-unit id="549c42e224f69e7d08f0e869d8833f7fd100921e" translate="yes" xml:space="preserve">
          <source>Display non-truncated description (--no-trunc)</source>
          <target state="translated">잘리지 않은 설명 표시 (-잘리지 않음)</target>
        </trans-unit>
        <trans-unit id="586adf04949d2f549650a7d8f0049daf7c9015cb" translate="yes" xml:space="preserve">
          <source>Display system-wide information</source>
          <target state="translated">시스템 전체 정보 표시</target>
        </trans-unit>
        <trans-unit id="a6455fdd8367bd89702457e99115dfd41f1df1ef" translate="yes" xml:space="preserve">
          <source>Display the running processes of a container</source>
          <target state="translated">컨테이너의 실행중인 프로세스 표시</target>
        </trans-unit>
        <trans-unit id="254d69a896b1e37f344391db12b7f8b9567eacb8" translate="yes" xml:space="preserve">
          <source>Display total file sizes</source>
          <target state="translated">총 파일 크기 표시</target>
        </trans-unit>
        <trans-unit id="38c62f3cd8a8fb642f2b55d18b2d6ebf6c85d6e4" translate="yes" xml:space="preserve">
          <source>Display total file sizes if the type is container</source>
          <target state="translated">유형이 컨테이너 인 경우 총 파일 크기 표시</target>
        </trans-unit>
        <trans-unit id="b00c674694a0b6016c070ba9ffd6f0f766b4c103" translate="yes" xml:space="preserve">
          <source>Displays a machine&amp;rsquo;s details.</source>
          <target state="translated">기계의 세부 사항을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7c316974af7c72efeec84970883a301976f0dae2" translate="yes" xml:space="preserve">
          <source>Displays help and usage instructions for a command.</source>
          <target state="translated">명령에 대한 도움말 및 사용법 지침을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ff8ae8d24d6f2086995a2be9c38368319dbaae82" translate="yes" xml:space="preserve">
          <source>Displays log output from services.</source>
          <target state="translated">서비스의 로그 출력을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e7344edcdd12520d1689713bcf2135adb9dfb995" translate="yes" xml:space="preserve">
          <source>Displays shell commands needed to configure your shell to interact with a machine</source>
          <target state="translated">쉘이 기계와 상호 작용하도록 구성하는 데 필요한 쉘 명령을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5d51e0b86fa5da409b5652ab07623b1022ba0914" translate="yes" xml:space="preserve">
          <source>Displays the machine&amp;rsquo;s IP address.</source>
          <target state="translated">기기의 IP 주소를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="07abc9d3b92908122382b69289aca3ffcc385cf6" translate="yes" xml:space="preserve">
          <source>Displays the running processes.</source>
          <target state="translated">실행중인 프로세스를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="70eb77b0158ae604788216b0675fb2940f7028b4" translate="yes" xml:space="preserve">
          <source>Distribute manager nodes</source>
          <target state="translated">분배 관리자 노드</target>
        </trans-unit>
        <trans-unit id="2d5d87f319af5eda92849e5802171b6295f8b415" translate="yes" xml:space="preserve">
          <source>Distribute your app across a cluster</source>
          <target state="translated">클러스터에 앱 배포</target>
        </trans-unit>
        <trans-unit id="9adee3b6973caa2d769cacbade5ef134cf3a4626" translate="yes" xml:space="preserve">
          <source>Distributed application bundles are described in a JSON format. When bundles are persisted as files, the file extension is &lt;code&gt;.dab&lt;/code&gt;.</source>
          <target state="translated">분산 애플리케이션 번들은 JSON 형식으로 설명됩니다. 번들이 파일로 지속되면 파일 확장자는 &lt;code&gt;.dab&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7b5a8a5361a87b31c4635582c5bf43f1e30dd3c" translate="yes" xml:space="preserve">
          <source>Do not attach STDIN</source>
          <target state="translated">STDIN을 부착하지 마십시오</target>
        </trans-unit>
        <trans-unit id="ed0a01bab5e9eae4d9b35cb8e35e740d22d6d30e" translate="yes" xml:space="preserve">
          <source>Do not automatically restart the container when it exits. This is the default.</source>
          <target state="translated">컨테이너가 종료 될 때 컨테이너를 자동으로 다시 시작하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b3637a8ff42a1be1edb83618f6ca24fa82d198c1" translate="yes" xml:space="preserve">
          <source>Do not check if specified remote plugin matches existing plugin image</source>
          <target state="translated">지정된 원격 플러그인이 기존 플러그인 이미지와 일치하는지 확인하지 마십시오</target>
        </trans-unit>
        <trans-unit id="5b463b465c661680b234c6255af34edff02d793a" translate="yes" xml:space="preserve">
          <source>Do not clean up any services or secrets if you intend to proceed to the next example, which demonstrates how to rotate the MySQL root password.</source>
          <target state="translated">MySQL 루트 암호를 교체하는 방법을 보여주는 다음 예를 진행하려면 서비스 나 비밀을 정리하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2f8acf4dbae86e42e4c8a7b10c573cf3fd2a6340" translate="yes" xml:space="preserve">
          <source>Do not delete untagged parents</source>
          <target state="translated">태그가없는 부모를 삭제하지 마십시오</target>
        </trans-unit>
        <trans-unit id="cf9b5732f0664e9e630faf3b43668481db027799" translate="yes" xml:space="preserve">
          <source>Do not enable the plugin on install</source>
          <target state="translated">설치시 플러그인을 활성화하지 마십시오</target>
        </trans-unit>
        <trans-unit id="586c22687cbcaa65c4838ac382d89606fe147a74" translate="yes" xml:space="preserve">
          <source>Do not include task IDs in output</source>
          <target state="translated">출력에 작업 ID를 포함시키지 마십시오</target>
        </trans-unit>
        <trans-unit id="d302fff8a8a54c9485ffc10b6cfe7adc479b5ba6" translate="yes" xml:space="preserve">
          <source>Do not map IDs to Names</source>
          <target state="translated">ID를 이름에 매핑하지 마십시오</target>
        </trans-unit>
        <trans-unit id="610636b144c29090bad4c3c223d958431ab8bf74" translate="yes" xml:space="preserve">
          <source>Do not map IDs to Names in output</source>
          <target state="translated">출력에서 ID를 이름에 맵핑하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e89564f443c675d61ddbdab2f81386622c91ca59" translate="yes" xml:space="preserve">
          <source>Do not neatly format logs</source>
          <target state="translated">깔끔하게 로그를 포맷하지 마십시오</target>
        </trans-unit>
        <trans-unit id="027bc8b10f773570babb5fea0a9cb7c9458edff5" translate="yes" xml:space="preserve">
          <source>Do not pass a &lt;code&gt;service x start&lt;/code&gt; command to a detached container. For example, this command attempts to start the &lt;code&gt;nginx&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;service x start&lt;/code&gt; 명령을 분리 된 컨테이너에 전달하지 마십시오 . 예를 들어,이 명령은 &lt;code&gt;nginx&lt;/code&gt; 서비스 를 시작하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c60eef8b14975ad0bba8d5ad419ddc7da2e0f4bc" translate="yes" xml:space="preserve">
          <source>Do not prompt for confirmation</source>
          <target state="translated">확인을 요구하지 않습니다</target>
        </trans-unit>
        <trans-unit id="10145045b5c0b244e12c4477a82d2bc769c5c08b" translate="yes" xml:space="preserve">
          <source>Do not prompt for confirmation before removing the most recent signer</source>
          <target state="translated">가장 최근 서명자를 제거하기 전에 확인 메시지를 표시하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e1cd949866ccfaa5e8f0c255356910547fc479b9" translate="yes" xml:space="preserve">
          <source>Do not query the registry to resolve image digest and supported platforms</source>
          <target state="translated">이미지 다이제스트 및 지원되는 플랫폼을 해결하기 위해 레지스트리를 쿼리하지 마십시오</target>
        </trans-unit>
        <trans-unit id="c589024137fa6f2b5053f673a30a7fd374ac1281" translate="yes" xml:space="preserve">
          <source>Do not truncate output</source>
          <target state="translated">출력을 자르지 마십시오</target>
        </trans-unit>
        <trans-unit id="af4812a5813b02f556c71cdc99b7c81d1e74198a" translate="yes" xml:space="preserve">
          <source>Do not truncate the output</source>
          <target state="translated">출력을 자르지 마십시오</target>
        </trans-unit>
        <trans-unit id="a71e39ca8baf6485c17d49f457e3be2c4451f183" translate="yes" xml:space="preserve">
          <source>Do not use cache when building the image</source>
          <target state="translated">이미지를 만들 때 캐시를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="9df82311645e18c702563d988f036f055e354cbc" translate="yes" xml:space="preserve">
          <source>Do not use this in production!</source>
          <target state="translated">프로덕션에서는 이것을 사용하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="30a7ab5d3d82e8d8969094c1104df7528bd4c209" translate="yes" xml:space="preserve">
          <source>Do this quickly and move on to the next step, because WordPress loses the ability to connect to MySQL.</source>
          <target state="translated">워드 프레스가 MySQL에 연결하는 기능을 상실하기 때문에이 작업을 빠르게 수행하고 다음 단계로 넘어가십시오.</target>
        </trans-unit>
        <trans-unit id="9f1141549f7c054b71516937d3febc77d991d59b" translate="yes" xml:space="preserve">
          <source>Docker</source>
          <target state="translated">Docker</target>
        </trans-unit>
        <trans-unit id="15b3ee6f96cffd907e4df852496f6c39417fba5f" translate="yes" xml:space="preserve">
          <source>Docker 17.05.0 added an optional &lt;code&gt;--detach=false&lt;/code&gt; option to make the &lt;code&gt;docker service create&lt;/code&gt; and &lt;code&gt;docker service update&lt;/code&gt; work synchronously. This option will be enabled by default in Docker 17.10, at which point the &lt;code&gt;--detach&lt;/code&gt; flag can be used to use the previous (asynchronous) behavior.</source>
          <target state="translated">Docker 17.05.0에는 선택적인 &lt;code&gt;--detach=false&lt;/code&gt; 옵션이 추가 되어 &lt;code&gt;docker service create&lt;/code&gt; 및 &lt;code&gt;docker service update&lt;/code&gt; 동 기적으로 작동합니다. 이 옵션은 Docker 17.10에서 기본적으로 활성화 &lt;code&gt;--detach&lt;/code&gt; 시점에서 --detach 플래그를 사용하여 이전 (비동기식) 동작을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c84930c94be78898371b68cb18016a8340fecd42" translate="yes" xml:space="preserve">
          <source>Docker 17.06 and higher include support for configs on Windows containers. Where there are differences in the implementations, they are called out in the examples below. Keep the following notable differences in mind:</source>
          <target state="translated">Docker 17.06 이상에는 Windows 컨테이너에서 구성을 지원합니다. 구현에 차이점이있는 경우 아래 예에서 설명합니다. 다음과 같은 차이점을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="ea0bf75369b594541fb33e60727c241a45a14360" translate="yes" xml:space="preserve">
          <source>Docker 17.06 and higher include support for secrets on Windows containers. Where there are differences in the implementations, they are called out in the examples below. Keep the following notable differences in mind:</source>
          <target state="translated">Docker 17.06 이상에는 Windows 컨테이너의 비밀 지원이 포함되어 있습니다. 구현에 차이점이있는 경우 아래 예에서 설명합니다. 다음과 같은 차이점을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="38fa6aaa54e8aeab5d846ca367e409da3befe487" translate="yes" xml:space="preserve">
          <source>Docker 17.06 introduces swarm service configs, which allow you to store non-sensitive information, such as configuration files, outside a service&amp;rsquo;s image or running containers. This allows you to keep your images as generic as possible, without the need to bind-mount configuration files into the containers or use environment variables.</source>
          <target state="translated">Docker 17.06에는 swarm 서비스 구성이 도입되어 구성 파일과 같은 중요하지 않은 정보를 서비스 이미지 외부 또는 컨테이너 실행 외부에 저장할 수 있습니다. 이를 통해 구성 파일을 컨테이너에 바인드 마운트하거나 환경 변수를 사용할 필요없이 이미지를 가능한 한 일반적으로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44a5dee83dada219bd1cc01e548c67cc651fc9b2" translate="yes" xml:space="preserve">
          <source>Docker 17.12 CE and higher allow you to specify a swarm service&amp;rsquo;s isolation mode. &lt;strong&gt;This setting applies to Windows hosts only and is ignored for Linux hosts.&lt;/strong&gt; The isolation mode can be one of the following:</source>
          <target state="translated">Docker 17.12 CE 이상에서는 웜 서비스의 격리 모드를 지정할 수 있습니다. &lt;strong&gt;이 설정은 Windows 호스트에만 적용되며 Linux 호스트에서는 무시됩니다. &lt;/strong&gt;격리 모드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50a2527e5f78dd83f3b538a56d07b975248c326a" translate="yes" xml:space="preserve">
          <source>Docker Compose and &lt;a href=&quot;https://docs.docker.com/swarm/overview/&quot;&gt;Docker Swarm&lt;/a&gt; aim to have full integration, meaning you can point a Compose app at a Swarm cluster and have it all just work as if you were using a single Docker host.</source>
          <target state="translated">Docker Compose와 &lt;a href=&quot;https://docs.docker.com/swarm/overview/&quot;&gt;Docker Swarm&lt;/a&gt; 은 완전한 통합을 목표로합니다. 즉, Swarm 클러스터에서 Compose 앱을 가리키고 마치 단일 Docker 호스트를 사용하는 것처럼 작동하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36380209e82f9571b4b3a6ebdf25588a96db096d" translate="yes" xml:space="preserve">
          <source>Docker Compose is under active development. If you need help, would like to contribute, or simply want to talk about the project with like-minded individuals, we have a number of open channels for communication.</source>
          <target state="translated">Docker Compose는 현재 개발 중입니다. 도움이 필요하거나 공헌하고 싶거나 단순히 같은 생각을 가진 사람들과 프로젝트에 대해 이야기하고 싶다면 의사 소통을위한 다양한 공개 채널이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3599b00f041ba89cd599683ac3c0362fa9489d4d" translate="yes" xml:space="preserve">
          <source>Docker Compose relies on Docker Engine for any meaningful work, so make sure you have Docker Engine installed either locally or remote, depending on your setup.</source>
          <target state="translated">Docker Compose는 의미있는 작업을 위해 Docker Engine을 사용하므로 설정에 따라 Docker Engine을 로컬 또는 원격으로 설치했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="caf414726c189aa3cb27a2290240b5c7c6c010be" translate="yes" xml:space="preserve">
          <source>Docker Compose&amp;rsquo;s &lt;code&gt;extends&lt;/code&gt; keyword enables sharing of common configurations among different files, or even different projects entirely. Extending services is useful if you have several services that reuse a common set of configuration options. Using &lt;code&gt;extends&lt;/code&gt; you can define a common set of service options in one place and refer to it from anywhere.</source>
          <target state="translated">Docker Compose의 &lt;code&gt;extends&lt;/code&gt; 키워드를 사용하면 다른 파일 또는 다른 프로젝트간에 공통 구성을 공유 할 수 있습니다. 서비스 확장은 공통 구성 옵션 세트를 재사용하는 여러 서비스가있는 경우 유용합니다. &lt;code&gt;extends&lt;/code&gt; 을 사용하면 한 곳에서 공통 서비스 옵션 세트를 정의하고 어디에서나이를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b032dee91964d42ad5d0c2a849a576e80c5c7284" translate="yes" xml:space="preserve">
          <source>Docker Content Trust (DCT) provides the ability to use digital signatures for data sent to and received from remote Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific image tags.</source>
          <target state="translated">Docker Content Trust (DCT)는 원격 Docker 레지스트리와주고받는 데이터에 디지털 서명을 사용하는 기능을 제공합니다. 이러한 서명을 통해 특정 이미지 태그의 무결성 및 게시자에 대한 클라이언트 측 또는 런타임 검증이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cb875ec0273f1a25d29dd355397274d5c3a53f9e" translate="yes" xml:space="preserve">
          <source>Docker Content Trust ENV passphrase variables name change</source>
          <target state="translated">Docker Content Trust ENV 비밀번호 문구 변수 이름 변경</target>
        </trans-unit>
        <trans-unit id="bf8434b10a2aeb8b173e492d087491b97e6caef0" translate="yes" xml:space="preserve">
          <source>Docker Content Trust Keys</source>
          <target state="translated">도커 컨텐츠 트러스트 키</target>
        </trans-unit>
        <trans-unit id="fc20720914a0d008c69a1814e27e881b01440539" translate="yes" xml:space="preserve">
          <source>Docker Content Trust Signature Verification</source>
          <target state="translated">도커 컨텐츠 신뢰 서명 검증</target>
        </trans-unit>
        <trans-unit id="bd8d2a2e04165d2c6e430e3a0562465ad41d91a7" translate="yes" xml:space="preserve">
          <source>Docker Content Trust can store and sign with root keys from a Yubikey 4. The Yubikey is prioritized over keys stored in the filesystem. When you initialize a new repository with content trust, Docker Engine looks for a root key locally. If a key is not found and the Yubikey 4 exists, Docker Engine creates a root key in the Yubikey 4. Consult the &lt;a href=&quot;../../../../notary/advanced_usage/index#use-a-yubikey&quot;&gt;Notary documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Docker Content Trust는 Yubikey 4의 루트 키로 저장하고 서명 할 수 있습니다. Yubikey는 파일 시스템에 저장된 키보다 우선 순위가 높습니다. 컨텐츠 신뢰로 새 저장소를 초기화하면 Docker Engine은 로컬에서 루트 키를 찾습니다. 키를 찾을 수없고 Yubikey 4가 존재하면 Docker Engine은 Yubikey 4에서 루트 키를 생성합니다 . 자세한 내용 은 &lt;a href=&quot;../../../../notary/advanced_usage/index#use-a-yubikey&quot;&gt;공증 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a74411c07df2f364781dfac0d0f3b4e44e1d7ac" translate="yes" xml:space="preserve">
          <source>Docker Content Trust within the Docker Enterprise Engine prevents a user from using a container image from an unknown source, it will also prevent a user from building a container image from a base layer from an unknown source. Trusted sources could include Official Docker Images, found on the &lt;a href=&quot;https://hub.docker.com/search?image_filter=official&amp;amp;type=image&quot;&gt;Docker Hub&lt;/a&gt;, or User trusted sources, with repositories and tags signed with the commands &lt;a href=&quot;#signing-images-with-docker-content-trust&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">Docker Enterprise Engine 내의 Docker Content Trust는 사용자가 알 수없는 소스의 컨테이너 이미지를 사용하지 못하게하고, 사용자가 알 수없는 소스의 기본 레이어에서 컨테이너 이미지를 빌드하지 못하게합니다. 신뢰할 수있는 출처에는 &lt;a href=&quot;https://hub.docker.com/search?image_filter=official&amp;amp;type=image&quot;&gt;Docker Hub&lt;/a&gt; 에있는 공식 Docker 이미지 또는 &lt;a href=&quot;#signing-images-with-docker-content-trust&quot;&gt;위&lt;/a&gt; 의 명령으로 서명 된 리포지토리와 태그가있는 사용자가 신뢰할 수있는 출처가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="717f4e5351ce2920e77e76450655b92cb390ae71" translate="yes" xml:space="preserve">
          <source>Docker Daemon version</source>
          <target state="translated">도커 데몬 버전</target>
        </trans-unit>
        <trans-unit id="c7d61bc2dfc8916b1f53db41e16531364ac12126" translate="yes" xml:space="preserve">
          <source>Docker Desktop for Mac and Docker Desktop for Windows both require newer versions of their respective operating systems, so users with older OS versions must use Docker Toolbox.</source>
          <target state="translated">Mac 용 Docker Desktop과 Windows 용 Docker Desktop에는 최신 버전의 각 운영 체제가 필요하므로 이전 OS 버전의 사용자는 Docker Toolbox를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0318d66c6f26409e430441e81b32bcb46d07e07" translate="yes" xml:space="preserve">
          <source>Docker Desktop for Mac uses &lt;a href=&quot;https://github.com/docker/HyperKit/&quot;&gt;HyperKit&lt;/a&gt;, a lightweight macOS virtualization solution built on top of the &lt;a href=&quot;https://developer.apple.com/reference/hypervisor&quot;&gt;Hypervisor.framework&lt;/a&gt;.</source>
          <target state="translated">Mac 용 Docker Desktop 은 &lt;a href=&quot;https://developer.apple.com/reference/hypervisor&quot;&gt;Hypervisor.framework&lt;/a&gt; 위에 구축 된 가벼운 macOS 가상화 솔루션 인 &lt;a href=&quot;https://github.com/docker/HyperKit/&quot;&gt;HyperKit을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0dffa00d5d260607cc8f3821272f56896d5a9ae2" translate="yes" xml:space="preserve">
          <source>Docker Desktop for Windows uses &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/windows_welcome&quot;&gt;Microsoft Hyper-V&lt;/a&gt; for virtualization, and Hyper-V is not compatible with Oracle VirtualBox. Therefore, you cannot run the two solutions simultaneously. But you can still use &lt;code&gt;docker-machine&lt;/code&gt; to create more local VMs by using the Microsoft Hyper-V driver.</source>
          <target state="translated">Windows 용 Docker Desktop은 가상화를 위해 &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/windows_welcome&quot;&gt;Microsoft Hyper-V&lt;/a&gt; 를 사용 하며 Hyper-V는 Oracle VirtualBox와 호환되지 않습니다. 따라서 두 솔루션을 동시에 실행할 수 없습니다. 그러나 여전히 Microsoft Hyper-V 드라이버를 사용하여 &lt;code&gt;docker-machine&lt;/code&gt; 을 사용하여 더 많은 로컬 VM을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73c6b07c9355c7390db745c20bd91ceb1abe53a1" translate="yes" xml:space="preserve">
          <source>Docker Documentation</source>
          <target state="translated">도커 문서</target>
        </trans-unit>
        <trans-unit id="b6d7a6ee9c405b3694f4b40f6c27dbed71d91c40" translate="yes" xml:space="preserve">
          <source>Docker Engine - Community</source>
          <target state="translated">도커 엔진-커뮤니티</target>
        </trans-unit>
        <trans-unit id="aa10a3bfababca53f5fd0204a3d9f4518710ac0f" translate="yes" xml:space="preserve">
          <source>Docker Engine 1.10 and above supports the usage of the &lt;code&gt;targets/releases&lt;/code&gt; delegation as the canonical source of a trusted image tag, if it exists.</source>
          <target state="translated">Docker Engine 1.10 이상은 &lt;code&gt;targets/releases&lt;/code&gt; 위임을 신뢰할 수있는 이미지 태그 (있는 경우)의 정식 소스로 사용하도록 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="01d702b3faac9f63d084e080a075b069289a9487" translate="yes" xml:space="preserve">
          <source>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</source>
          <target state="translated">Docker Engine 1.12에는 swarm이라고하는 하나 이상의 Docker Engine 클러스터를 작성할 수있는 swarm 모드가 도입되었습니다. 웜은 하나 이상의 노드로 구성됩니다 : 웜 모드에서 Docker Engine 1.12 이상을 실행하는 물리적 또는 가상 머신.</target>
        </trans-unit>
        <trans-unit id="fe6a2c5b264914ab5eadc944ce369ebe707aac57" translate="yes" xml:space="preserve">
          <source>Docker Engine 1.12 or later installed</source>
          <target state="translated">Docker Engine 1.12 이상 설치</target>
        </trans-unit>
        <trans-unit id="9f8a4143e0d9d14b1f219d38ba1ded99fe280444" translate="yes" xml:space="preserve">
          <source>Docker Engine 1.12 or newer</source>
          <target state="translated">Docker Engine 1.12 이상</target>
        </trans-unit>
        <trans-unit id="ed849467d13e888852bc27f255fcdb6370a90d63" translate="yes" xml:space="preserve">
          <source>Docker Engine command line reference</source>
          <target state="translated">Docker Engine 명령 행 참조</target>
        </trans-unit>
        <trans-unit id="fd0da34319e387ca46fd20dff39ae670a6a8914c" translate="yes" xml:space="preserve">
          <source>Docker Engine managed plugin system</source>
          <target state="translated">Docker Engine 관리 형 플러그인 시스템</target>
        </trans-unit>
        <trans-unit id="5f255d50d6539853caf74cc09261dc57ffa7150b" translate="yes" xml:space="preserve">
          <source>Docker Engine network plugins enable Engine deployments to be extended to support a wide range of networking technologies, such as VXLAN, IPVLAN, MACVLAN or something completely different. Network driver plugins are supported via the LibNetwork project. Each plugin is implemented as a &amp;ldquo;remote driver&amp;rdquo; for LibNetwork, which shares plugin infrastructure with Engine. Effectively, network driver plugins are activated in the same way as other plugins, and use the same kind of protocol.</source>
          <target state="translated">Docker Engine 네트워크 플러그인을 사용하면 VXLAN, IPVLAN, MACVLAN 또는 완전히 다른 것과 같은 광범위한 네트워킹 기술을 지원하도록 엔진 배치를 확장 할 수 있습니다. 네트워크 드라이버 플러그인은 LibNetwork 프로젝트를 통해 지원됩니다. 각 플러그인은 엔진과 플러그인 인프라를 공유하는 LibNetwork의 &quot;원격 드라이버&quot;로 구현됩니다. 효과적으로, 네트워크 드라이버 플러그인은 다른 플러그인과 같은 방식으로 활성화되며 동일한 종류의 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f64b19a832bcdc3a4356df589519ca61049f9fc4" translate="yes" xml:space="preserve">
          <source>Docker Engine runs natively on Linux systems. If you have a Linux box as your primary system, and want to run &lt;code&gt;docker&lt;/code&gt; commands, all you need to do is download and install Docker Engine. However, if you want an efficient way to provision multiple Docker hosts on a network, in the cloud or even locally, you need Docker Machine.</source>
          <target state="translated">Docker Engine은 기본적으로 Linux 시스템에서 실행됩니다. Linux 시스템을 기본 시스템으로 사용하고 &lt;code&gt;docker&lt;/code&gt; 명령 을 실행 하려면 Docker Engine을 다운로드하여 설치하기 만하면됩니다. 그러나 네트워크, 클라우드 또는 로컬에서 여러 Docker 호스트를 효율적으로 프로비저닝하려면 Docker Machine이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="58c77391b3acb8cff3bba10fafbf58e62fc2dfc5" translate="yes" xml:space="preserve">
          <source>Docker Engine swarm mode automatically names the node for the machine host name. The tutorial covers other columns in later steps.</source>
          <target state="translated">Docker Engine swarm 모드는 시스템 호스트 이름의 노드 이름을 자동으로 지정합니다. 이 자습서는 이후 단계에서 다른 열을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="0bbf0223c6fb1c1cafb06b7f64045bf07ff34dad" translate="yes" xml:space="preserve">
          <source>Docker Engine swarm mode makes it easy to publish ports for services to make them available to resources outside the swarm. All nodes participate in an ingress &lt;strong&gt;routing mesh&lt;/strong&gt;. The routing mesh enables each node in the swarm to accept connections on published ports for any service running in the swarm, even if there&amp;rsquo;s no task running on the node. The routing mesh routes all incoming requests to published ports on available nodes to an active container.</source>
          <target state="translated">Docker Engine swarm 모드를 사용하면 swarm 외부의 리소스에서 서비스를 사용할 수 있도록 포트를 쉽게 게시 할 수 있습니다. 모든 노드는 수신 &lt;strong&gt;라우팅 메쉬에&lt;/strong&gt; 참여 합니다. 라우팅 메시를 사용하면 노드에서 실행중인 작업이 없더라도 웜의 각 노드가 웜에서 실행중인 모든 서비스에 대해 게시 된 포트에서 연결을 수락 할 수 있습니다. 라우팅 메시는 모든 수신 요청을 사용 가능한 노드의 게시 된 포트로 활성 컨테이너로 라우팅합니다.</target>
        </trans-unit>
        <trans-unit id="b2c13f5a5d9b78e83d36fce8030a4a2366617386" translate="yes" xml:space="preserve">
          <source>Docker Engine volume plugins enable Engine deployments to be integrated with external storage systems such as Amazon EBS, and enable data volumes to persist beyond the lifetime of a single Docker host. See the &lt;a href=&quot;../legacy_plugins/index&quot;&gt;plugin documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Docker Engine 볼륨 플러그인을 사용하면 Engine 배포를 Amazon EBS와 같은 외부 스토리지 시스템과 통합 할 수 있으며 데이터 볼륨이 단일 Docker 호스트 수명보다 오래 지속될 수 있습니다. 자세한 내용은 &lt;a href=&quot;../legacy_plugins/index&quot;&gt;플러그인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e41c3832a435c434851d3063bb07a88d07e535c5" translate="yes" xml:space="preserve">
          <source>Docker Engine&amp;rsquo;s plugin system allows you to install, start, stop, and remove plugins using Docker Engine.</source>
          <target state="translated">Docker Engine의 플러그인 시스템을 사용하면 Docker Engine을 사용하여 플러그인을 설치, 시작, 중지 및 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fba150e54cff0eec41fdee94731e5dd5eb39acf" translate="yes" xml:space="preserve">
          <source>Docker Engine's labels</source>
          <target state="translated">도커 엔진의 라벨</target>
        </trans-unit>
        <trans-unit id="572957b87156643096b3f6ef6253fbf2c6355c1f" translate="yes" xml:space="preserve">
          <source>Docker Enterprise</source>
          <target state="translated">도커 엔터프라이즈</target>
        </trans-unit>
        <trans-unit id="13c010ccd4f2d2bbb372c0bfd71d9d72f00244f8" translate="yes" xml:space="preserve">
          <source>Docker Machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d4d28187d9be67d2ca80e103da027f1a9fac35" translate="yes" xml:space="preserve">
          <source>Docker Machine Overview</source>
          <target state="translated">도커 머신 개요</target>
        </trans-unit>
        <trans-unit id="fcde8d59c209e4b1686e13c44f0342acf8a2cbcc" translate="yes" xml:space="preserve">
          <source>Docker Machine allows you to provision Docker machines in a variety of environments, including virtual machines that reside on your local system, on cloud providers, or on bare metal servers (physical computers). Docker Machine creates a Docker host, and you use the Docker Engine client as needed to build images and create containers on the host.</source>
          <target state="translated">Docker Machine을 사용하면 로컬 시스템, 클라우드 공급자 또는 베어 메탈 서버 (실제 컴퓨터)에 상주하는 가상 머신을 포함하여 다양한 환경에서 Docker 머신을 프로비저닝 할 수 있습니다. Docker Machine은 Docker 호스트를 작성하고 필요에 따라 Docker Engine 클라이언트를 사용하여 이미지를 빌드하고 호스트에서 컨테이너를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d72bffc2203e4a1dacfc765e999f28a08d9d211a" translate="yes" xml:space="preserve">
          <source>Docker Machine command-line reference</source>
          <target state="translated">Docker Machine 명령 행 참조</target>
        </trans-unit>
        <trans-unit id="8688c99c7ccbe0996771b295fd75e8224d2e206c" translate="yes" xml:space="preserve">
          <source>Docker Machine commmand line reference</source>
          <target state="translated">Docker Machine 명령 행 참조</target>
        </trans-unit>
        <trans-unit id="5a56c924c68a2f36f632b6c51dc99155e5f34069" translate="yes" xml:space="preserve">
          <source>Docker Machine driver for Microsoft Hyper-V</source>
          <target state="translated">Microsoft Hyper-V 용 Docker Machine 드라이버</target>
        </trans-unit>
        <trans-unit id="b70b0c352857dcadb319b900fac00c1ffe58d0cd" translate="yes" xml:space="preserve">
          <source>Docker Machine driver for Oracle VirtualBox</source>
          <target state="translated">Oracle VirtualBox 용 Docker Machine 드라이버</target>
        </trans-unit>
        <trans-unit id="8fed77ce7ac5f681613ba574d4d5c2ecf8496d2e" translate="yes" xml:space="preserve">
          <source>Docker Machine driver plugins are available for many cloud platforms, so you can use Machine to provision cloud hosts. When you use Docker Machine for provisioning, you create cloud hosts with Docker Engine installed on them.</source>
          <target state="translated">Docker Machine 드라이버 플러그인은 많은 클라우드 플랫폼에서 사용할 수 있으므로 Machine을 사용하여 클라우드 호스트를 프로비저닝 할 수 있습니다. 프로비저닝에 Docker Machine을 사용하면 Docker Engine이 설치된 클라우드 호스트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b44f3fbe45580363d9450ec91ef790ad7d100edc" translate="yes" xml:space="preserve">
          <source>Docker Machine driver reference</source>
          <target state="translated">Docker Machine 드라이버 참조</target>
        </trans-unit>
        <trans-unit id="0988385498a51e24d58d1def06fae10241319329" translate="yes" xml:space="preserve">
          <source>Docker Machine enables you to provision multiple remote Docker hosts on various flavors of Linux.</source>
          <target state="translated">Docker Machine을 사용하면 다양한 Linux 버전에서 여러 원격 Docker 호스트를 프로비저닝 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d0914e4c8dae74ec8b500625417c23cb4962b9" translate="yes" xml:space="preserve">
          <source>Docker Machine has &lt;a href=&quot;../../machine/reference/ssh/index#different-types-of-ssh&quot;&gt;the option to let you use your own system&amp;rsquo;s SSH&lt;/a&gt;, if for some reason you&amp;rsquo;re having trouble sending commands to your Swarm manager. Just specify the &lt;code&gt;--native-ssh&lt;/code&gt; flag when invoking the &lt;code&gt;ssh&lt;/code&gt; command:</source>
          <target state="translated">Docker Machine에는 어떤 이유로 든 Swarm 관리자에게 명령을 보내는 데 문제가있는 경우 &lt;a href=&quot;../../machine/reference/ssh/index#different-types-of-ssh&quot;&gt;자신의 시스템 SSH를 사용할 수있는 옵션이 있습니다&lt;/a&gt; . &lt;code&gt;ssh&lt;/code&gt; 명령을 호출 할 때 &lt;code&gt;--native-ssh&lt;/code&gt; 플래그를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="30a9a99fff8b0e86159cc1fdbdce6a67a52bd3c5" translate="yes" xml:space="preserve">
          <source>Docker Machine has these two broad use cases.</source>
          <target state="translated">Docker Machine에는이 두 가지 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bcadd07d9793947a9ccf4aaf7bb39fcf2ad3b93" translate="yes" xml:space="preserve">
          <source>Docker Machine is a tool that lets you install Docker Engine on virtual hosts, and manage the hosts with &lt;code&gt;docker-machine&lt;/code&gt; commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or DigitalOcean.</source>
          <target state="translated">Docker Machine은 가상 호스트에 Docker Engine을 설치하고 &lt;code&gt;docker-machine&lt;/code&gt; 명령으로 호스트를 관리 할 수있는 도구입니다 . Machine을 사용하여 로컬 Mac 또는 Windows 박스, 회사 네트워크, 데이터 센터 또는 Azure, AWS 또는 DigitalOcean과 같은 클라우드 공급자에서 Docker 호스트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c353031039191dcf70cddd0324a3eb9362d35d12" translate="yes" xml:space="preserve">
          <source>Docker Machine is still in its infancy and under active development. If you need help, would like to contribute, or simply want to talk about the project with like-minded individuals, we have a number of open channels for communication.</source>
          <target state="translated">Docker Machine은 아직 초기 단계에 있으며 개발 중에 있습니다. 도움이 필요하거나 공헌하고 싶거나 단순히 같은 생각을 가진 사람들과 프로젝트에 대해 이야기하고 싶다면 의사 소통을위한 다양한 공개 채널이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9239d8916c5c5c4c9001c8ef20c4a2f53088421d" translate="yes" xml:space="preserve">
          <source>Docker Machine list of reference pages for all supported drivers</source>
          <target state="translated">지원되는 모든 드라이버에 대한 Docker Machine 참조 페이지 목록</target>
        </trans-unit>
        <trans-unit id="8dd2970f2d2c16a490129a161e878963262b5128" translate="yes" xml:space="preserve">
          <source>Docker Machine only sets the configured parameters on the daemon and does not set up any of the &amp;ldquo;dependencies&amp;rdquo; for you. For instance, if you specify that the created daemon should use &lt;code&gt;btrfs&lt;/code&gt; as a storage driver, you still must ensure that the proper dependencies are installed, the BTRFS filesystem has been created, and so on.</source>
          <target state="translated">Docker Machine은 데몬에서 구성된 매개 변수 만 설정하고 &quot;종속성&quot;을 설정하지 않습니다. 예를 들어, 작성된 디먼이 &lt;code&gt;btrfs&lt;/code&gt; 를 스토리지 드라이버로 사용하도록 지정한 경우 에도 적절한 종속성이 설치되어 있고 BTRFS 파일 시스템이 작성되었는지 등을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad47b6b352b1ac679883107670f089f0acb63723" translate="yes" xml:space="preserve">
          <source>Docker Machine overview</source>
          <target state="translated">도커 머신 개요</target>
        </trans-unit>
        <trans-unit id="cee1b2adcf7f278c41ac3e239b7e9eef04c13988" translate="yes" xml:space="preserve">
          <source>Docker Machine subcommand reference</source>
          <target state="translated">Docker Machine 부속 명령 참조</target>
        </trans-unit>
        <trans-unit id="c246ffd3fe124c2fc6e6ae5b5eba91b06d2f5e66" translate="yes" xml:space="preserve">
          <source>Docker Machine uses SSH to complete the set up of instances in EC2 and requires the ability to access the instance directly.</source>
          <target state="translated">Docker Machine은 SSH를 사용하여 EC2에서 인스턴스 설정을 완료하며 인스턴스에 직접 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ead56b39dee7ef3d59ba310f67983e1ebbc10799" translate="yes" xml:space="preserve">
          <source>Docker Plugin API</source>
          <target state="translated">도커 플러그인 API</target>
        </trans-unit>
        <trans-unit id="4e71b63b949540dbd45960e1a9b3a7720b904c15" translate="yes" xml:space="preserve">
          <source>Docker Stacks and Distributed Application Bundles started as experimental features introduced in Docker 1.12 and Docker Compose 1.8, alongside the concept of swarm mode, and nodes and services in the Engine API. Neither Docker Engine nor the Docker Registry support distribution of bundles, and the concept of a &lt;code&gt;bundle&lt;/code&gt; is not the emphasis for new releases going forward.</source>
          <target state="translated">Docker 스택 및 분산 응용 프로그램 번들은 Swamer 모드 개념과 Engine API의 노드 및 서비스와 함께 Docker 1.12 및 Docker Compose 1.8에 도입 된 실험 기능으로 시작되었습니다. 도커 엔진도 번들의 부두 노동자 레지스트리 지원 유통 및 개념 어느 &lt;code&gt;bundle&lt;/code&gt; 향후 새로운 릴리스에 대한 강조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a06825d079ab2849cd767d10505f8e64cb3a6485" translate="yes" xml:space="preserve">
          <source>Docker Tools for Visual Studio</source>
          <target state="translated">Visual Studio 용 도커 도구</target>
        </trans-unit>
        <trans-unit id="cc02628d6a1178aeb13e6439ce9ec843b98a3172" translate="yes" xml:space="preserve">
          <source>Docker Trust allows you to configure multiple delegations per repository, allowing you to manage the lifecycle of delegations. When adding additional delegations with &lt;code&gt;$ docker trust&lt;/code&gt; the collaborators key is once again added to the &lt;code&gt;targets/release&lt;/code&gt; role.</source>
          <target state="translated">Docker Trust를 사용하면 리포지토리 당 여러 위임을 구성하여 위임의 수명주기를 관리 할 수 ​​있습니다. &lt;code&gt;$ docker trust&lt;/code&gt; 로 추가 위임을 추가 하면 공동 작업자 키가 다시 &lt;code&gt;targets/release&lt;/code&gt; 역할에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="7aa58adea32a9f7a4bc781d957e50b1b0949739b" translate="yes" xml:space="preserve">
          <source>Docker Volume Driver for vSphere enables customers to address persistent storage requirements for Docker containers in vSphere environments.</source>
          <target state="translated">vSphere 용 Docker Volume Driver를 통해 고객은 vSphere 환경에서 Docker 컨테이너에 대한 지속적인 스토리지 요구 사항을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e40a9a8660d369ea358fc5cfa50f1913f1b9637" translate="yes" xml:space="preserve">
          <source>Docker allocates subnet addresses from the address ranges specified by the &lt;code&gt;--default-addr-pool&lt;/code&gt; option. For example, a command line option &lt;code&gt;--default-addr-pool 10.10.0.0/16&lt;/code&gt; indicates that Docker will allocate subnets from that &lt;code&gt;/16&lt;/code&gt; address range. If &lt;code&gt;--default-addr-pool-mask-len&lt;/code&gt; were unspecified or set explicitly to 24, this would result in 256 &lt;code&gt;/24&lt;/code&gt; networks of the form &lt;code&gt;10.10.X.0/24&lt;/code&gt;.</source>
          <target state="translated">Docker는 &lt;code&gt;--default-addr-pool&lt;/code&gt; 옵션으로 지정된 주소 범위에서 서브넷 주소를 할당합니다 . 예를 들어 &lt;code&gt;--default-addr-pool 10.10.0.0/16&lt;/code&gt; 명령 줄 옵션 은 Docker가 해당 &lt;code&gt;/16&lt;/code&gt; 주소 범위 에서 서브넷을 할당 함을 나타냅니다 . 경우 &lt;code&gt;--default-addr-pool-mask-len&lt;/code&gt; 불특정 있었다 24에 명시 적으로 설정이 256 초래 &lt;code&gt;/24&lt;/code&gt; 형태의 네트워크 &lt;code&gt;10.10.X.0/24&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6278038acc032e7953c6df8aad186ebc1002fdd4" translate="yes" xml:space="preserve">
          <source>Docker also prints the digest of an image when &lt;em&gt;pushing&lt;/em&gt; to a registry. This may be useful if you want to pin to a version of the image you just pushed.</source>
          <target state="translated">Docker는 또한 레지스트리로 &lt;em&gt;푸시&lt;/em&gt; 할 때 이미지 요약을 인쇄합니다 . 방금 누른 이미지 버전에 고정하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5324a93ff598c142e2e98933ac188a461609f133" translate="yes" xml:space="preserve">
          <source>Docker always searches for unix sockets in &lt;code&gt;/run/docker/plugins&lt;/code&gt; first. It checks for spec or json files under &lt;code&gt;/etc/docker/plugins&lt;/code&gt; and &lt;code&gt;/usr/lib/docker/plugins&lt;/code&gt; if the socket doesn&amp;rsquo;t exist. The directory scan stops as soon as it finds the first plugin definition with the given name.</source>
          <target state="translated">Docker는 항상 &lt;code&gt;/run/docker/plugins&lt;/code&gt; 에서 유닉스 소켓을 먼저 검색합니다. 소켓이 존재하지 않으면 &lt;code&gt;/etc/docker/plugins&lt;/code&gt; 및 &lt;code&gt;/usr/lib/docker/plugins&lt;/code&gt; 에서 spec 또는 json 파일을 확인 합니다. 지정된 이름의 첫 번째 플러그인 정의를 찾으면 디렉토리 스캔이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e2c184a58d7fa6986d5c5fb9c54fd2bcedcb08" translate="yes" xml:space="preserve">
          <source>Docker and Kubernetes endpoints configurations, as well as default stack orchestrator and description can be modified with &lt;code&gt;docker context update&lt;/code&gt;</source>
          <target state="translated">Docker 및 Kubernetes 엔드 포인트 구성과 기본 스택 오케 스트레이터 및 설명은 &lt;code&gt;docker context update&lt;/code&gt; 로 수정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="19c6a327829e80ff2849f300b8be119aad185da8" translate="yes" xml:space="preserve">
          <source>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.</source>
          <target state="translated">Docker 및 Docker 로고는 미국 및 / 또는 기타 국가에서 Docker, Inc.의 상표 또는 등록 상표입니다.</target>
        </trans-unit>
        <trans-unit id="5fd261f97c0753dd9d2677012873eff0de835e50" translate="yes" xml:space="preserve">
          <source>Docker automatically generates and loads a default profile for containers named &lt;code&gt;docker-default&lt;/code&gt;. On Docker versions &lt;code&gt;1.13.0&lt;/code&gt; and later, the Docker binary generates this profile in &lt;code&gt;tmpfs&lt;/code&gt; and then loads it into the kernel. On Docker versions earlier than &lt;code&gt;1.13.0&lt;/code&gt;, this profile is generated in &lt;code&gt;/etc/apparmor.d/docker&lt;/code&gt; instead.</source>
          <target state="translated">Docker는 &lt;code&gt;docker-default&lt;/code&gt; 라는 컨테이너에 대한 기본 프로파일을 자동으로 생성하고로드합니다 . Docker 버전 &lt;code&gt;1.13.0&lt;/code&gt; 이상 에서 Docker 바이너리는 &lt;code&gt;tmpfs&lt;/code&gt; 에서이 프로파일을 생성 한 다음이를 커널에로드합니다. &lt;code&gt;1.13.0&lt;/code&gt; 이전의 Docker 버전 에서는이 프로파일이 대신 &lt;code&gt;/etc/apparmor.d/docker&lt;/code&gt; 에 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="36aab98cac3b30264c30a3b8c1ab2a8492bf6b01" translate="yes" xml:space="preserve">
          <source>Docker automatically sets some environment variables when creating a Linux container. Docker does not set any environment variables when creating a Windows container.</source>
          <target state="translated">Docker는 Linux 컨테이너를 만들 때 일부 환경 변수를 자동으로 설정합니다. Docker는 Windows 컨테이너를 만들 때 환경 변수를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26f7ed16f22034c85a3924a533800947d612d3c0" translate="yes" xml:space="preserve">
          <source>Docker build supports experimental features like cache mounts, build secrets and ssh forwarding that are enabled by using an external implementation of the builder with a syntax directive. To learn about these features, &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental/&quot;&gt;refer to the documentation in BuildKit repository&lt;/a&gt;.</source>
          <target state="translated">Docker 빌드는 구문 지시문과 함께 빌더의 외부 구현을 사용하여 사용 가능한 캐시 마운트, 빌드 비밀 및 ssh 전달과 같은 실험 기능을 지원합니다. 이러한 기능에 대해 배우려면 &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental/&quot;&gt;BuildKit 리포지토리의 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9670987a72aa3ffadf269680e48b2636d70046ab" translate="yes" xml:space="preserve">
          <source>Docker can build images automatically by reading the instructions from a &lt;code&gt;Dockerfile&lt;/code&gt;. A &lt;code&gt;Dockerfile&lt;/code&gt; is a text document that contains all the commands a user could call on the command line to assemble an image. Using &lt;code&gt;docker build&lt;/code&gt; users can create an automated build that executes several command-line instructions in succession.</source>
          <target state="translated">Docker는 &lt;code&gt;Dockerfile&lt;/code&gt; 의 지침을 읽어 이미지를 자동으로 빌드 할 수 있습니다 . &lt;code&gt;Dockerfile&lt;/code&gt; 는 사용자가 이미지를 조립하는 명령 줄에서 호출 할 수있는 모든 명령을 포함하는 텍스트 문서입니다. 사용하여 &lt;code&gt;docker build&lt;/code&gt; 연속적으로 여러 명령 줄 명령을 실행하는 자동화 된 빌드를 만들 수있는 사용자를.</target>
        </trans-unit>
        <trans-unit id="4bb9b20862141b3f6d322dbb6a74161a410cc1e2" translate="yes" xml:space="preserve">
          <source>Docker client flows</source>
          <target state="translated">도커 클라이언트 흐름</target>
        </trans-unit>
        <trans-unit id="d20e070a888708ac804bb7f3478c403e44b83956" translate="yes" xml:space="preserve">
          <source>Docker concepts</source>
          <target state="translated">도커 개념</target>
        </trans-unit>
        <trans-unit id="d3b52a967f6c76cee08c0e14a2a11be4d550ea2d" translate="yes" xml:space="preserve">
          <source>Docker configs report the following events:</source>
          <target state="translated">Docker 구성은 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ce44a37fd4d945806f8253598f57605800cac7ac" translate="yes" xml:space="preserve">
          <source>Docker considers a private registry either secure or insecure. In the rest of this section, &lt;em&gt;registry&lt;/em&gt; is used for &lt;em&gt;private registry&lt;/em&gt;, and &lt;code&gt;myregistry:5000&lt;/code&gt; is a placeholder example for a private registry.</source>
          <target state="translated">Docker는 개인 레지스트리가 안전하거나 안전하지 않은 것으로 간주합니다. 이 섹션의 나머지 부분에서 &lt;em&gt;레지스트리&lt;/em&gt; 는 &lt;em&gt;개인 레지스트리&lt;/em&gt; 에 사용되며 &lt;code&gt;myregistry:5000&lt;/code&gt; 은 개인 레지스트리의 자리 표시 자 예입니다.</target>
        </trans-unit>
        <trans-unit id="88b4598a5ff96f31828992a3d683ccb7e14868af" translate="yes" xml:space="preserve">
          <source>Docker consists of:</source>
          <target state="translated">도커는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa864f6d63b7920d5feeea58ebe98aacc779ad5" translate="yes" xml:space="preserve">
          <source>Docker containers are lightweight and fast! Containers have sub-second launch times, reducing the cycle time of development, testing, and deployment.</source>
          <target state="translated">Docker 컨테이너는 가볍고 빠릅니다! 컨테이너의 시작 시간은 1 초 미만이므로 개발, 테스트 및 배포주기가 단축됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b8e47dc472b543da346bab4e80d9953fa94e72" translate="yes" xml:space="preserve">
          <source>Docker containers are very similar to LXC containers, and they have similar security features. When you start a container with &lt;code&gt;docker run&lt;/code&gt;, behind the scenes Docker creates a set of namespaces and control groups for the container.</source>
          <target state="translated">Docker 컨테이너는 LXC 컨테이너와 매우 유사하며 유사한 보안 기능이 있습니다. &lt;code&gt;docker run&lt;/code&gt; 으로 컨테이너를 시작하면 배경 뒤에서 Docker는 컨테이너에 대한 네임 스페이스 및 제어 그룹 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ae9ccf1da58c4c1d2b47b81602d33c9dc573c01c" translate="yes" xml:space="preserve">
          <source>Docker containers are, by default, quite secure; especially if you run your processes as non-privileged users inside the container.</source>
          <target state="translated">Docker 컨테이너는 기본적으로 매우 안전합니다. 특히 컨테이너 내에서 권한이없는 사용자로 프로세스를 실행하는 경우.</target>
        </trans-unit>
        <trans-unit id="0f06c8666f97517a7d3d00d4ebb45d7ef312ed79" translate="yes" xml:space="preserve">
          <source>Docker containers don&amp;rsquo;t need a hypervisor, so you can pack more of them onto your hosts. This means you get more value out of every server and can potentially reduce what you spend on equipment and licenses.</source>
          <target state="translated">Docker 컨테이너에는 하이퍼 바이저가 필요하지 않으므로 호스트에 더 많은 것을 포장 할 수 있습니다. 즉, 모든 서버에서 더 많은 가치를 얻을 수 있으며 장비 및 라이센스 비용을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="620d948bfb0604a71c82ef396e99a3de6f366d2b" translate="yes" xml:space="preserve">
          <source>Docker containers report the following events:</source>
          <target state="translated">Docker 컨테이너는 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2610ade2da99a839eecc387366205cd50b64e532" translate="yes" xml:space="preserve">
          <source>Docker containers run (almost) everywhere. You can deploy containers on desktops, physical servers, virtual machines, into data centers, and up to public and private clouds.</source>
          <target state="translated">도커 컨테이너는 거의 모든 곳에서 실행됩니다. 데스크톱, 물리적 서버, 가상 머신, 데이터 센터 및 퍼블릭 및 프라이빗 클라우드에 컨테이너를 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876ee5a178115a1a05ba51423ede3227412455fe" translate="yes" xml:space="preserve">
          <source>Docker daemon attack surface</source>
          <target state="translated">도커 데몬 공격 표면</target>
        </trans-unit>
        <trans-unit id="75fb7248a691100473dcf0175bed3b866cf3a543" translate="yes" xml:space="preserve">
          <source>Docker daemon restarts which kills all running containers</source>
          <target state="translated">Docker 데몬이 다시 시작되어 실행중인 모든 컨테이너가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="70c8555a506aabefb4688f4ef0118ace6220b6eb" translate="yes" xml:space="preserve">
          <source>Docker daemons report the following events:</source>
          <target state="translated">Docker 데몬은 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4251677d657a5c553e466fb729e810325a9c2c64" translate="yes" xml:space="preserve">
          <source>Docker defaults to using a &lt;code&gt;bridge&lt;/code&gt; network on a single host. For examples of how to work with bridge networks, see the Docker Labs tutorial on &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A2-bridge-networking/&quot;&gt;Bridge networking&lt;/a&gt;.</source>
          <target state="translated">Docker는 기본적으로 단일 호스트에서 &lt;code&gt;bridge&lt;/code&gt; 네트워크 를 사용 합니다. 브리지 네트워크로 작업하는 방법에 대한 예제는 &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A2-bridge-networking/&quot;&gt;브리지 네트워킹&lt;/a&gt; 에 대한 Docker Labs 자습서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="351bf0b8a014056cbddc02e7e25c41dac8157210" translate="yes" xml:space="preserve">
          <source>Docker discovers plugins by looking for them in the plugin directory whenever a user or container tries to use one by name.</source>
          <target state="translated">Docker는 사용자 또는 컨테이너가 이름별로 플러그인을 사용하려고 할 때마다 플러그인 디렉토리에서 플러그인을 찾아서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9d2c047a9f4640206b9ae1ad934af06ef13db28a" translate="yes" xml:space="preserve">
          <source>Docker distributes official versions of the images that can be used for building Dockerfiles under &lt;code&gt;docker/dockerfile&lt;/code&gt; repository on Docker Hub. There are two channels where new images are released: stable and experimental.</source>
          <target state="translated">Docker 는 Docker Hub의 &lt;code&gt;docker/dockerfile&lt;/code&gt; 저장소에 Dockerfile 을 빌드하는 데 사용할 수있는 공식 버전의 이미지를 배포 합니다. 새로운 이미지가 출시되는 채널은 안정적이고 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="c5432cb10accede4d487ad4c951b076e34b61ead" translate="yes" xml:space="preserve">
          <source>Docker does not re-download images that it already has cached, but we want Docker to attempt to download the tampered image from the registry and reject it because it is invalid.</source>
          <target state="translated">Docker는 이미 캐시 한 이미지를 다시 다운로드하지 않지만 Docker가 변조 된 이미지를 레지스트리에서 다운로드하여 잘못된 이미지를 거부하려고합니다.</target>
        </trans-unit>
        <trans-unit id="732b5ffc4585e751646589a16ffc8acce2e7c130" translate="yes" xml:space="preserve">
          <source>Docker generates a cross-signed certificate. This means that a version of the new root CA certificate is signed with the old root CA certificate. This cross-signed certificate is used as an intermediate certificate for all new node certificates. This ensures that nodes that still trust the old root CA can still validate a certificate signed by the new CA.</source>
          <target state="translated">Docker는 교차 서명 된 인증서를 생성합니다. 이것은 새 루트 CA 인증서의 버전이 이전 루트 CA 인증서로 서명되었음을 의미합니다. 이 교차 서명 된 인증서는 모든 새 노드 인증서의 중간 인증서로 사용됩니다. 이를 통해 여전히 기존 루트 CA를 신뢰하는 노드가 새 CA가 서명 한 인증서의 유효성을 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a752842ad719d2a10386b20f1e29b257d090521b" translate="yes" xml:space="preserve">
          <source>Docker has a set of predefined &lt;code&gt;ARG&lt;/code&gt; variables that you can use without a corresponding &lt;code&gt;ARG&lt;/code&gt; instruction in the Dockerfile.</source>
          <target state="translated">Docker에는 Dockerfile에서 해당 &lt;code&gt;ARG&lt;/code&gt; 명령어 없이 사용할 수있는 사전 정의 된 &lt;code&gt;ARG&lt;/code&gt; 변수 세트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a9ab3b5144c01d2cf064a01fa77d77bca73fafe" translate="yes" xml:space="preserve">
          <source>Docker images can consist of multiple layers. In the example above, the image consists of two layers; &lt;code&gt;fdd5d7827f33&lt;/code&gt; and &lt;code&gt;a3ed95caeb02&lt;/code&gt;.</source>
          <target state="translated">도커 이미지는 여러 레이어로 구성 될 수 있습니다. 위의 예에서 이미지는 두 개의 레이어로 구성됩니다. &lt;code&gt;fdd5d7827f33&lt;/code&gt; 및 &lt;code&gt;a3ed95caeb02&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d088fbf44d726100ad0f41c1f23e4e05581f501a" translate="yes" xml:space="preserve">
          <source>Docker images have intermediate layers that increase reusability, decrease disk usage, and speed up &lt;code&gt;docker build&lt;/code&gt; by allowing each step to be cached. These intermediate layers are not shown by default.</source>
          <target state="translated">도커 이미지에는 중간 계층이있어 재사용 성을 높이고 디스크 사용량을 줄이며 각 단계를 캐시하여 &lt;code&gt;docker build&lt;/code&gt; 속도를 높 입니다. 이러한 중간 레이어는 기본적으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01c99cd4e6b6524d11e77af6915fc44a7fe11e1c" translate="yes" xml:space="preserve">
          <source>Docker images report the following events:</source>
          <target state="translated">Docker 이미지는 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="05529fa5b2f6c8c756fb80473a93b0a74a7271be" translate="yes" xml:space="preserve">
          <source>Docker inspect provides detailed information on constructs controlled by Docker.</source>
          <target state="translated">Docker inspect는 Docker가 제어하는 ​​구문에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7d816c70aa6a50e18998939d4c8f412747557dd" translate="yes" xml:space="preserve">
          <source>Docker is a platform for developers and sysadmins to &lt;strong&gt;develop, deploy, and run&lt;/strong&gt; applications with containers. The use of Linux containers to deploy applications is called &lt;em&gt;containerization&lt;/em&gt;. Containers are not new, but their use for easily deploying applications is.</source>
          <target state="translated">Docker는 개발자와 시스템 관리자 가 컨테이너를 사용하여 응용 프로그램 을 &lt;strong&gt;개발, 배포 및 실행할 수&lt;/strong&gt; 있는 플랫폼입니다 . 응용 프로그램을 배포하는 리눅스 용기의 사용이라고 &lt;em&gt;컨테이너 수송&lt;/em&gt; . 컨테이너는 새로운 것이 아니지만 응용 프로그램을 쉽게 배포하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4630f4f6b9bb350d6435927aabbb527fa315450e" translate="yes" xml:space="preserve">
          <source>Docker is licensed under the Apache License, Version 2.0. See &lt;a href=&quot;https://github.com/moby/moby/blob/master/LICENSE&quot;&gt;LICENSE&lt;/a&gt; for the full license text.</source>
          <target state="translated">Docker는 Apache 라이센스 버전 2.0에 따라 라이센스가 부여됩니다. 전체 라이센스 텍스트는 &lt;a href=&quot;https://github.com/moby/moby/blob/master/LICENSE&quot;&gt;라이센스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41eb805f7f5ce74c0136241ce201f4359fdc1b5a" translate="yes" xml:space="preserve">
          <source>Docker is no longer using the named volume. &lt;code&gt;Unmount&lt;/code&gt; is called once per container stop. Plugin may deduce that it is safe to deprovision the volume at this point.</source>
          <target state="translated">Docker는 더 이상 명명 된 볼륨을 사용하지 않습니다. 컨테이너 정지 당 &lt;code&gt;Unmount&lt;/code&gt; 가 한 번 호출됩니다. 플러그인은이 시점에서 볼륨을 프로비저닝 해제하는 것이 안전하다고 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea8c3af456a588aa615fe42a9efcc72125aba99" translate="yes" xml:space="preserve">
          <source>Docker machine shell environment on Mac or Linux</source>
          <target state="translated">Mac 또는 Linux의 Docker 시스템 셸 환경</target>
        </trans-unit>
        <trans-unit id="834d9eb820d510688500bc9822bc4f6013ff27d6" translate="yes" xml:space="preserve">
          <source>Docker machine shell environment on Windows</source>
          <target state="translated">Windows의 Docker 시스템 쉘 환경</target>
        </trans-unit>
        <trans-unit id="153a53ca45c6ac5f58f492b5ce3d25d78f6a46ba" translate="yes" xml:space="preserve">
          <source>Docker manager nodes store the swarm state and manager logs in the &lt;code&gt;/var/lib/docker/swarm/&lt;/code&gt; directory. In 1.13 and higher, this data includes the keys used to encrypt the Raft logs. Without these keys, you cannot restore the swarm.</source>
          <target state="translated">Docker 관리자 노드는 swarm 상태 및 관리자 로그를 &lt;code&gt;/var/lib/docker/swarm/&lt;/code&gt; 디렉토리에 저장합니다. 1.13 이상에서이 데이터에는 Raft 로그를 암호화하는 데 사용되는 키가 포함됩니다. 이 키가 없으면 떼를 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d8c8020848a1bc698d9ebd74c79180b0d8fb55f" translate="yes" xml:space="preserve">
          <source>Docker manages most of the files in the configuration directory and you should not modify them. However, you &lt;em&gt;can modify&lt;/em&gt; the &lt;code&gt;config.json&lt;/code&gt; file to control certain aspects of how the &lt;code&gt;docker&lt;/code&gt; command behaves.</source>
          <target state="translated">Docker는 구성 디렉토리에서 대부분의 파일을 관리하므로 수정해서는 안됩니다. 그러나, 당신은 &lt;em&gt;수정할 수 &lt;/em&gt; &lt;code&gt;config.json&lt;/code&gt; 의 방법의 특정 측면을 제어하기 위해 파일을 &lt;code&gt;docker&lt;/code&gt; 명령 동작합니다을.</target>
        </trans-unit>
        <trans-unit id="a702cba7106194c03e0367bdc1ffd7b882680096" translate="yes" xml:space="preserve">
          <source>Docker network driver plugins</source>
          <target state="translated">도커 네트워크 드라이버 플러그인</target>
        </trans-unit>
        <trans-unit id="de85e84b42d67d5eafe125abbb5ac9ea7d7002d8" translate="yes" xml:space="preserve">
          <source>Docker networks feature overview</source>
          <target state="translated">도커 네트워크 기능 개요</target>
        </trans-unit>
        <trans-unit id="65b01032e0693c656e6a408b50ae27aa4b93819a" translate="yes" xml:space="preserve">
          <source>Docker networks report the following events:</source>
          <target state="translated">Docker 네트워크는 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="868564ce7af93236022670b074a3f1505f5debbb" translate="yes" xml:space="preserve">
          <source>Docker nodes report the following events:</source>
          <target state="translated">도커 노드는 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1fc1d746218b957768b329fc69b99ad3a97b0387" translate="yes" xml:space="preserve">
          <source>Docker now connects securely by default:</source>
          <target state="translated">Docker는 이제 기본적으로 안전하게 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="0671294b90d6a2729f187a3420f9b4c77e962850" translate="yes" xml:space="preserve">
          <source>Docker performs an in-place update, no need to tear the stack down first or kill any containers.</source>
          <target state="translated">Docker는 전체 업데이트를 수행하므로 스택을 먼저 해제하거나 컨테이너를 죽일 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="84aefc06cc0cbabc59eed166a320a96c6b7b735c" translate="yes" xml:space="preserve">
          <source>Docker plugins are out-of-process extensions which add capabilities to the Docker Engine.</source>
          <target state="translated">Docker 플러그인은 Docker Engine에 기능을 추가하는 프로세스 외부 확장입니다.</target>
        </trans-unit>
        <trans-unit id="c36900e7cef6b121ca0ce592e13fb920c49e319d" translate="yes" xml:space="preserve">
          <source>Docker plugins report the following events:</source>
          <target state="translated">Docker 플러그인은 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="631b67106b47b10afeb3855dca09866284d583c8" translate="yes" xml:space="preserve">
          <source>Docker predefines a set of &lt;code&gt;ARG&lt;/code&gt; variables with information on the platform of the node performing the build (build platform) and on the platform of the resulting image (target platform). The target platform can be specified with the &lt;code&gt;--platform&lt;/code&gt; flag on &lt;code&gt;docker build&lt;/code&gt;.</source>
          <target state="translated">Docker 는 빌드를 수행하는 노드의 플랫폼 (빌드 플랫폼) 및 결과 이미지의 플랫폼 (대상 플랫폼)에 대한 정보 로 &lt;code&gt;ARG&lt;/code&gt; 변수 세트를 사전 정의합니다 . &lt;code&gt;docker build&lt;/code&gt; 에서 &lt;code&gt;--platform&lt;/code&gt; 플래그를 사용하여 대상 플랫폼을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc0e08864d7ec1ddba1cadd269e1368821c375d8" translate="yes" xml:space="preserve">
          <source>Docker prints the digest of the image after the pull has finished. In the example above, the digest of the image is:</source>
          <target state="translated">Docker는 당기기가 완료된 후 이미지의 요약을 인쇄합니다. 위의 예에서 이미지의 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcf96fb035e7bc5ae306abe9393d3cb0903ab5ea" translate="yes" xml:space="preserve">
          <source>Docker recommends a maximum of seven manager nodes for a swarm.</source>
          <target state="translated">Docker는 스웜에 최대 7 개의 관리자 노드를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="f96906f4bb592181dbe9a39c15c8f9ea527f5635" translate="yes" xml:space="preserve">
          <source>Docker recommends three or five manager nodes per cluster to implement high availability. Because swarm mode manager nodes share data using Raft, there must be an odd number of managers. The swarm can continue to function after as long as a quorum of more than half of the manager nodes are available.</source>
          <target state="translated">Docker는 고 가용성을 구현하기 위해 클러스터 당 3 개 또는 5 개의 관리자 노드를 권장합니다. 스웜 모드 관리자 노드는 Raft를 사용하여 데이터를 공유하므로 홀수의 관리자가 있어야합니다. 관리자 노드의 절반 이상이 사용 가능한 한 웜은 계속 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e57a0616687d980e1a126195a0a5e1df3f0cdb4" translate="yes" xml:space="preserve">
          <source>Docker requires the plugin to provide a volume, given a user specified volume name. &lt;code&gt;Mount&lt;/code&gt; is called once per container start. If the same &lt;code&gt;volume_name&lt;/code&gt; is requested more than once, the plugin may need to keep track of each new mount request and provision at the first mount request and deprovision at the last corresponding unmount request.</source>
          <target state="translated">Docker는 사용자 지정 볼륨 이름이 지정된 경우 플러그인에서 볼륨을 제공해야합니다. 컨테이너 시작마다 &lt;code&gt;Mount&lt;/code&gt; 가 한 번 호출됩니다. 동일한 &lt;code&gt;volume_name&lt;/code&gt; 이 두 번 이상 요청되면 플러그인은 각각의 새로운 마운트 요청을 추적하고 첫 번째 마운트 요청에서 프로비저닝하고 마지막 해당 언 마운트 요청에서 프로비저닝을 해제해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f5da00bd131d9b5f72ea571b68ed8ed5938eb30" translate="yes" xml:space="preserve">
          <source>Docker run reference</source>
          <target state="translated">도커 실행 참조</target>
        </trans-unit>
        <trans-unit id="a3467015c714f0f2eec0a42f643e6952535a32e0" translate="yes" xml:space="preserve">
          <source>Docker runs instructions in a &lt;code&gt;Dockerfile&lt;/code&gt; in order. A &lt;code&gt;Dockerfile&lt;/code&gt;&lt;strong&gt;must start with a `FROM` instruction&lt;/strong&gt;. The &lt;code&gt;FROM&lt;/code&gt; instruction specifies the &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;Base Image&lt;/em&gt;&lt;/a&gt; from which you are building. &lt;code&gt;FROM&lt;/code&gt; may only be preceded by one or more &lt;code&gt;ARG&lt;/code&gt; instructions, which declare arguments that are used in &lt;code&gt;FROM&lt;/code&gt; lines in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">Docker는 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 명령을 순서대로 실행합니다 . &lt;code&gt;Dockerfile&lt;/code&gt; 은&lt;strong&gt;앞에`FROM` 명령으로 시작해야합니다&lt;/strong&gt; . &lt;code&gt;FROM&lt;/code&gt; 명령은 지정 &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;기본 이미지&lt;/em&gt;&lt;/a&gt; 당신이 구축하고있는합니다. &lt;code&gt;FROM&lt;/code&gt; 앞에는 하나 이상의 &lt;code&gt;ARG&lt;/code&gt; 명령어 만있을 수 있습니다.이 명령어 는 &lt;code&gt;Dockerfile&lt;/code&gt; 의 &lt;code&gt;FROM&lt;/code&gt; 행에 사용되는 인수를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="f7dfe54475fab92a3e82ad34c021ab33e93916f9" translate="yes" xml:space="preserve">
          <source>Docker runs processes in isolated containers. A container is a process which runs on a host. The host may be local or remote. When an operator executes &lt;code&gt;docker run&lt;/code&gt;, the container process that runs is isolated in that it has its own file system, its own networking, and its own isolated process tree separate from the host.</source>
          <target state="translated">Docker는 격리 된 컨테이너에서 프로세스를 실행합니다. 컨테이너는 호스트에서 실행되는 프로세스입니다. 호스트는 로컬 또는 원격 일 수 있습니다. 운영자가 &lt;code&gt;docker run&lt;/code&gt; 을 실행할 때 실행 되는 컨테이너 프로세스는 자체 파일 시스템, 자체 네트워킹 및 호스트와 분리 된 자체 격리 된 프로세스 트리를 갖기 때문에 격리됩니다.</target>
        </trans-unit>
        <trans-unit id="1bc79d0dc0a7f1f2b47d20cf6eef0c0378cf1728" translate="yes" xml:space="preserve">
          <source>Docker runtime execution options</source>
          <target state="translated">도커 런타임 실행 옵션</target>
        </trans-unit>
        <trans-unit id="bb5c7c92c94eedb039ab7e24f249362401f74e58" translate="yes" xml:space="preserve">
          <source>Docker secrets report the following events:</source>
          <target state="translated">Docker 비밀은 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="eff5599afc94cd79ffdef38b7838c922b9530085" translate="yes" xml:space="preserve">
          <source>Docker security</source>
          <target state="translated">도커 보안</target>
        </trans-unit>
        <trans-unit id="668e503dedbd5e9512ec49949d3a1985d4e340a8" translate="yes" xml:space="preserve">
          <source>Docker services report the following events:</source>
          <target state="translated">Docker 서비스는 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ed6989a1777de6ed159693207cffb0235412baf3" translate="yes" xml:space="preserve">
          <source>Docker stacks and distributed application bundles (experimental)</source>
          <target state="translated">Docker 스택 및 분산 응용 프로그램 번들 (실험적)</target>
        </trans-unit>
        <trans-unit id="b37ea7c142dd122eb29c5b75066d8ea4046db002" translate="yes" xml:space="preserve">
          <source>Docker supports softlinks for the Docker data directory (&lt;code&gt;/var/lib/docker&lt;/code&gt;) and for &lt;code&gt;/var/lib/docker/tmp&lt;/code&gt;. The &lt;code&gt;DOCKER_TMPDIR&lt;/code&gt; and the data directory can be set like this:</source>
          <target state="translated">Docker는 Docker 데이터 디렉토리 ( &lt;code&gt;/var/lib/docker&lt;/code&gt; ) 및 &lt;code&gt;/var/lib/docker/tmp&lt;/code&gt; 에 대한 소프트 링크를 지원합니다 . &lt;code&gt;DOCKER_TMPDIR&lt;/code&gt; 및 데이터 디렉토리는 다음과 같이 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="faafa781465c97af3b7790acd7e65b291e131cdd" translate="yes" xml:space="preserve">
          <source>Docker supports the addition and removal of capabilities, allowing use of a non-default profile. This may make Docker more secure through capability removal, or less secure through the addition of capabilities. The best practice for users would be to remove all capabilities except those explicitly required for their processes.</source>
          <target state="translated">Docker는 기능 추가 및 제거를 지원하여 기본이 아닌 프로파일을 사용할 수 있습니다. 이것은 기능 제거를 통해 Docker를 더 안전하게 만들거나 기능을 추가하여 덜 안전 할 수 있습니다. 사용자에게 가장 좋은 방법은 프로세스에 명시 적으로 필요한 기능을 제외한 모든 기능을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99a0efd6be62ff276e3630887ac2f70ed894f5c5" translate="yes" xml:space="preserve">
          <source>Docker supports the following restart policies:</source>
          <target state="translated">Docker는 다음 재시작 정책을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="027b46244a43e72d45ab57807d2f6dac54af37a6" translate="yes" xml:space="preserve">
          <source>Docker supports three different kinds of mounts, which allow containers to read from or write to files or directories, either on the host operating system, or on memory filesystems. These types are &lt;em&gt;data volumes&lt;/em&gt; (often referred to simply as volumes), &lt;em&gt;bind mounts&lt;/em&gt;, &lt;em&gt;tmpfs&lt;/em&gt;, and &lt;em&gt;named pipes&lt;/em&gt;.</source>
          <target state="translated">Docker는 세 가지 다른 종류의 마운트를 지원하여 컨테이너가 호스트 운영 체제 또는 메모리 파일 시스템에서 파일이나 디렉토리를 읽거나 쓸 수 있도록합니다. 이러한 유형은 &lt;em&gt;데이터 볼륨&lt;/em&gt; (종종 간단히 볼륨이라고 함), &lt;em&gt;바인드 마운트&lt;/em&gt; , &lt;em&gt;tmpfs&lt;/em&gt; 및 &lt;em&gt;명명 된 파이프&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9d1c0f4559e2cac2257d9f69a1a5ce24ec2dd3c" translate="yes" xml:space="preserve">
          <source>Docker swarm mode overlay network security model</source>
          <target state="translated">도커 스웜 모드 오버레이 네트워크 보안 모델</target>
        </trans-unit>
        <trans-unit id="984ccf852a89f0fcd495e2cac824009025386e21" translate="yes" xml:space="preserve">
          <source>Docker treats lines that &lt;em&gt;begin&lt;/em&gt; with &lt;code&gt;#&lt;/code&gt; as a comment, unless the line is a valid &lt;a href=&quot;#parser-directives&quot;&gt;parser directive&lt;/a&gt;. A &lt;code&gt;#&lt;/code&gt; marker anywhere else in a line is treated as an argument. This allows statements like:</source>
          <target state="translated">Docker는 줄이 유효한 &lt;a href=&quot;#parser-directives&quot;&gt;파서 지시문&lt;/a&gt; 이 아닌 경우 &lt;code&gt;#&lt;/code&gt; 으로 &lt;em&gt;시작&lt;/em&gt; 하는 줄을 주석으로 처리합니다 . &lt;code&gt;#&lt;/code&gt; 의 라인에서 다른 곳 마커는 인수로 처리됩니다. 이것은 다음과 같은 진술을 허용합니다 :</target>
        </trans-unit>
        <trans-unit id="6fc652cfb42eea3121ea7094e3e49d78901d3e1e" translate="yes" xml:space="preserve">
          <source>Docker trust has a built-in generator for a delegation key pair, &lt;code&gt;$ docker trust generate &amp;lt;name&amp;gt;&lt;/code&gt;. Running this command will automatically load the delegation private key in to the local Docker trust store.</source>
          <target state="translated">Docker trust에는 위임 키 쌍을위한 내장 생성기가 있으며 &lt;code&gt;$ docker trust generate &amp;lt;name&amp;gt;&lt;/code&gt; 입니다. 이 명령을 실행하면 위임 개인 키가 로컬 Docker 신뢰 저장소에 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e18ce2b318155498923998a10a647781b37d97" translate="yes" xml:space="preserve">
          <source>Docker user guide</source>
          <target state="translated">도커 사용 설명서</target>
        </trans-unit>
        <trans-unit id="7cf0c8985f554a2ab43c541ad5d5654b5853f203" translate="yes" xml:space="preserve">
          <source>Docker uses a content-addressable image store, and the image ID is a SHA256 digest covering the image&amp;rsquo;s configuration and layers. In the example above, &lt;code&gt;debian:jessie&lt;/code&gt; and &lt;code&gt;debian:latest&lt;/code&gt; have the same image ID because they are actually the &lt;em&gt;same&lt;/em&gt; image tagged with different names. Because they are the same image, their layers are stored only once and do not consume extra disk space.</source>
          <target state="translated">Docker는 컨텐츠 주소 지정 가능 이미지 저장소를 사용하며 이미지 ID는 이미지의 구성 및 레이어를 포함하는 SHA256 다이제스트입니다. 위의 예에서 &lt;code&gt;debian:jessie&lt;/code&gt; 및 &lt;code&gt;debian:latest&lt;/code&gt; 는 실제로 다른 이름으로 태그가 지정된 &lt;em&gt;동일한&lt;/em&gt; 이미지 이므로 동일한 이미지 ID를 갖습니다 . 동일한 이미지이므로 레이어는 한 번만 저장되며 추가 디스크 공간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="443f071bf808fd15c344b1fbe1bf2930114552cd" translate="yes" xml:space="preserve">
          <source>Docker uses the &lt;code&gt;https://&lt;/code&gt; protocol to communicate with a registry, unless the registry is allowed to be accessed over an insecure connection. Refer to the &lt;a href=&quot;../dockerd/index#insecure-registries&quot;&gt;insecure registries&lt;/a&gt; section for more information.</source>
          <target state="translated">Docker는 &lt;code&gt;https://&lt;/code&gt; 프로토콜을 사용하여 레지스트리에 안전하지 않은 연결을 통해 액세스 할 수없는 경우 레지스트리와 통신합니다. 자세한 정보 는 &lt;a href=&quot;../dockerd/index#insecure-registries&quot;&gt;안전하지 않은 레지스트리&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b751958c100c7de7c22737834416e1fd56107444" translate="yes" xml:space="preserve">
          <source>Docker volume plugins</source>
          <target state="translated">도커 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="4606af6de220606ce501f303c6559e2261c61fad" translate="yes" xml:space="preserve">
          <source>Docker volumes report the following events:</source>
          <target state="translated">Docker 볼륨은 다음과 같은 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="7d98d6a033d4e26ddc2c12fc65210ef05a32ca92" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s &lt;a href=&quot;../plugin_api/index&quot;&gt;plugin infrastructure&lt;/a&gt; enables extending Docker by loading, removing and communicating with third-party components using a generic API. The access authorization subsystem was built using this mechanism.</source>
          <target state="translated">Docker의 &lt;a href=&quot;../plugin_api/index&quot;&gt;플러그인 인프라를&lt;/a&gt; 사용하면 일반 API를 사용하여 타사 구성 요소를로드, 제거 및 통신하여 Docker를 확장 할 수 있습니다. 액세스 인증 서브 시스템은이 메커니즘을 사용하여 빌드되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b2afdd95105633b8f91194763ac61dd13f359f3" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s access authorization can be extended by authorization plugins that your organization can purchase or build themselves. You can install one or more authorization plugins when you start the Docker &lt;code&gt;daemon&lt;/code&gt; using the &lt;code&gt;--authorization-plugin=PLUGIN_ID&lt;/code&gt; option.</source>
          <target state="translated">Docker의 액세스 권한은 조직에서 직접 구매하거나 빌드 할 수있는 권한 플러그인으로 확장 할 수 있습니다. &lt;code&gt;--authorization-plugin=PLUGIN_ID&lt;/code&gt; 옵션을 사용하여 Docker &lt;code&gt;daemon&lt;/code&gt; 을 시작할 때 하나 이상의 인증 플러그인을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8812524181e240b29c523eaa6071906a718eea45" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s authorization subsystem supports multiple &lt;code&gt;--authorization-plugin&lt;/code&gt; parameters.</source>
          <target state="translated">Docker의 인증 하위 시스템은 여러 &lt;code&gt;--authorization-plugin&lt;/code&gt; 매개 변수를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="04d227915ed4556b72a81c69397c4672ce57e948" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s default seccomp profile is a whitelist which specifies the calls that are allowed. The table below lists the significant (but not all) syscalls that are effectively blocked because they are not on the whitelist. The table includes the reason each syscall is blocked rather than white-listed.</source>
          <target state="translated">Docker의 기본 seccomp 프로파일은 허용되는 호출을 지정하는 화이트리스트입니다. 아래 표에는 화이트리스트에 없기 때문에 효과적으로 차단 된 중요한 (그러나 전부는 아님) syscall이 나열되어 있습니다. 이 표에는 화이트리스트가 아닌 각 시스템 콜이 차단 된 이유가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b847750c1d2ed81302ec7ea1f562bf90ed2b5393" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s lightweight containers also make scaling up and down fast and easy. You can quickly launch more containers when needed and then shut them down easily when they&amp;rsquo;re no longer needed.</source>
          <target state="translated">Docker의 경량 컨테이너는 또한 빠르고 쉽게 확장 및 축소 할 수 있습니다. 필요할 때 더 많은 컨테이너를 빠르게 시작한 다음 더 이상 필요없는 컨테이너를 쉽게 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcd710262e8728d2cdb3fc51c476cdaf6c2089b" translate="yes" xml:space="preserve">
          <source>Docker&amp;rsquo;s out-of-the-box authorization model is all or nothing. Any user with permission to access the Docker daemon can run any Docker client command. The same is true for callers using Docker&amp;rsquo;s Engine API to contact the daemon. If you require greater access control, you can create authorization plugins and add them to your Docker daemon configuration. Using an authorization plugin, a Docker administrator can configure granular access policies for managing access to the Docker daemon.</source>
          <target state="translated">Docker의 기본 인증 모델은 전부 또는 아무것도 아닙니다. Docker 데몬에 액세스 할 수있는 권한이있는 모든 사용자는 모든 Docker 클라이언트 명령을 실행할 수 있습니다. Docker의 Engine API를 사용하여 데몬에 연락하는 호출자도 마찬가지입니다. 더 많은 액세스 제어가 필요한 경우 인증 플러그인을 작성하여 Docker 데몬 구성에 추가 할 수 있습니다. 인증 플러그인을 사용하여 Docker 관리자는 Docker 데몬에 대한 액세스를 관리하기 위해 세분화 된 액세스 정책을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b384df8c9095dc1d5ee30c7a2997988b4d311cbd" translate="yes" xml:space="preserve">
          <source>Docker, Inc. and other parties may also have trademark rights in other terms used herein.</source>
          <target state="translated">Docker, Inc. 및 기타 당사자도 여기에 사용 된 다른 용어로 상표권을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6651ddff6eb82c840ced7c1dddee15c6e1913dd4" translate="yes" xml:space="preserve">
          <source>Dockerfile</source>
          <target state="translated">Dockerfile</target>
        </trans-unit>
        <trans-unit id="ebd579a5756c1f559e79a1bd43d69b702990a3a7" translate="yes" xml:space="preserve">
          <source>Dockerfile examples</source>
          <target state="translated">도커 파일 예제</target>
        </trans-unit>
        <trans-unit id="f164e275f12c58fb053600677577c996297db57b" translate="yes" xml:space="preserve">
          <source>Dockerfile reference</source>
          <target state="translated">도커 파일 참조</target>
        </trans-unit>
        <trans-unit id="96e071ae656bb862be892e05a7f4dceaebcc6252" translate="yes" xml:space="preserve">
          <source>Dockerfile should specify at least one of &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;ENTRYPOINT&lt;/code&gt; commands.</source>
          <target state="translated">Dockerfile은 &lt;code&gt;CMD&lt;/code&gt; 또는 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 명령 중 하나 이상을 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6710996fbc943377b9f326a252a8fc870442c545" translate="yes" xml:space="preserve">
          <source>Dockerize PostgreSQL</source>
          <target state="translated">Dockerize PostgreSQL</target>
        </trans-unit>
        <trans-unit id="f522617514b0faa2a1a00723ae5d71b42a83ed32" translate="yes" xml:space="preserve">
          <source>Dockerize a CouchDB service</source>
          <target state="translated">CouchDB 서비스도 커화</target>
        </trans-unit>
        <trans-unit id="53faf3cb66cc0848ff1ed7d72721c35f93befffb" translate="yes" xml:space="preserve">
          <source>Dockerize an ASP.NET Core application</source>
          <target state="translated">ASP.NET Core 응용 프로그램 고정</target>
        </trans-unit>
        <trans-unit id="7dc9d5fd4f0db1a0f934fb7cd570ecf366b29eea" translate="yes" xml:space="preserve">
          <source>Dockerize an application</source>
          <target state="translated">응용 프로그램 도커</target>
        </trans-unit>
        <trans-unit id="cc2d41256b7df192f9235517c4a22bb447581976" translate="yes" xml:space="preserve">
          <source>Dockerize an apt-cacher-ng service</source>
          <target state="translated">apt-cacher-ng 서비스 도킹</target>
        </trans-unit>
        <trans-unit id="e1787e2991c7c57aea620420b24b740abd78acae" translate="yes" xml:space="preserve">
          <source>Dockerizing PostgreSQL</source>
          <target state="translated">PostgreSQL 도킹</target>
        </trans-unit>
        <trans-unit id="e59d1fb14fd39cd54a3427a54381767e8f9dee2c" translate="yes" xml:space="preserve">
          <source>Dockerizing a CouchDB service</source>
          <target state="translated">CouchDB 서비스 도킹</target>
        </trans-unit>
        <trans-unit id="5104f17bddb874a5f496e34a963f7c2acccddefa" translate="yes" xml:space="preserve">
          <source>Dockerizing an ASP.NET Core application</source>
          <target state="translated">ASP.NET Core 응용 프로그램 도킹</target>
        </trans-unit>
        <trans-unit id="da05b2de152a55abb340ddf6e2195c5afcbda127" translate="yes" xml:space="preserve">
          <source>Dockerizing an apt-cacher-ng service</source>
          <target state="translated">apt-cacher-ng 서비스 도킹</target>
        </trans-unit>
        <trans-unit id="65a094b0363a85cb7e0cb44baec4c0a53171ef92" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t clear set-user-ID and set-group-ID permission bits when a file is modified.</source>
          <target state="translated">파일이 수정 될 때 set-user-ID 및 set-group-ID 권한 비트를 지우지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f09df74b71932e7ccae31d1ae0c37aad556a5785" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t let containers reboot the host. Also gated by &lt;code&gt;CAP_SYS_BOOT&lt;/code&gt;.</source>
          <target state="translated">컨테이너가 호스트를 재부팅하지 못하게하십시오. &lt;code&gt;CAP_SYS_BOOT&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c6134ff9ce78244820bbca45a71e71ba3ab910e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t truncate output</source>
          <target state="translated">출력을 자르지 마십시오</target>
        </trans-unit>
        <trans-unit id="6962cf79c6381a85a2a514c11b44290383e7dec4" translate="yes" xml:space="preserve">
          <source>Double check what you have in the ports section under your web service and make sure the ip addresses you enter in your browser or curl reflects that</source>
          <target state="translated">웹 서비스의 포트 섹션에있는 내용을 다시 확인하고 브라우저 또는 curl에 입력 한 IP 주소가 다음을 반영하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="be4e5ba4a3ea4d0c241bbc8d66a24e9c251a8bb4" translate="yes" xml:space="preserve">
          <source>Download a &lt;code&gt;docker&lt;/code&gt; image to test with.</source>
          <target state="translated">테스트 할 &lt;code&gt;docker&lt;/code&gt; 이미지를 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfbf148f90529dad9825aed5f1dbd161aebca5e6" translate="yes" xml:space="preserve">
          <source>Download all tagged images in the repository</source>
          <target state="translated">저장소에서 태그가 지정된 이미지를 모두 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="987841e8f6296f9c01a31ac8e9715f0f8086ece7" translate="yes" xml:space="preserve">
          <source>Download an &lt;code&gt;ubuntu&lt;/code&gt; image:</source>
          <target state="translated">&lt;code&gt;ubuntu&lt;/code&gt; 이미지 다운로드 :</target>
        </trans-unit>
        <trans-unit id="449a13186a2f61dafc8a4085b58b02b8e07afd95" translate="yes" xml:space="preserve">
          <source>Download the Docker Machine binary and extract it to your PATH.</source>
          <target state="translated">Docker Machine 바이너리를 다운로드하여 PATH에 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="4cbdb9690ada90270949b9b9c2ab410dc16b546e" translate="yes" xml:space="preserve">
          <source>Drain a node on the swarm</source>
          <target state="translated">떼에서 노드를 배수</target>
        </trans-unit>
        <trans-unit id="b5c7d8b545ea7fdba609234ce2324aa0c0d6dbb0" translate="yes" xml:space="preserve">
          <source>Driver</source>
          <target state="translated">Driver</target>
        </trans-unit>
        <trans-unit id="58623e02e26a5eecacd7ec6d29cbc2da6cf829be" translate="yes" xml:space="preserve">
          <source>Driver Specific Log Tags</source>
          <target state="translated">드라이버 별 로그 태그</target>
        </trans-unit>
        <trans-unit id="63a7342acd4948df144843654bb4f58b3c0934e9" translate="yes" xml:space="preserve">
          <source>Driver name</source>
          <target state="translated">운전사 이름</target>
        </trans-unit>
        <trans-unit id="82f820e3ae879e421ed356bdaeb83cb74f60b8e8" translate="yes" xml:space="preserve">
          <source>Driver options and operating system defaults</source>
          <target state="translated">드라이버 옵션 및 운영 체제 기본값</target>
        </trans-unit>
        <trans-unit id="988f30538766cc86e0b1714347b5186cdbcbaf7d" translate="yes" xml:space="preserve">
          <source>Driver to manage the Network</source>
          <target state="translated">네트워크 관리 드라이버</target>
        </trans-unit>
        <trans-unit id="dcf380a033027a26c2e3ddd55737f95eab21addf" translate="yes" xml:space="preserve">
          <source>Driver-specific options</source>
          <target state="translated">드라이버 별 옵션</target>
        </trans-unit>
        <trans-unit id="089b71742f71efa9494ba163a9af65ed77d86c46" translate="yes" xml:space="preserve">
          <source>Drivers for cloud providers</source>
          <target state="translated">클라우드 제공 업체를위한 드라이버</target>
        </trans-unit>
        <trans-unit id="624db526c9888ba34387475c520773e8d7f6c797" translate="yes" xml:space="preserve">
          <source>Drivers for creating machines</source>
          <target state="translated">기계를 만들기위한 드라이버</target>
        </trans-unit>
        <trans-unit id="a8e62c51b2b545ed908d99a99d2a81a9fecc1415" translate="yes" xml:space="preserve">
          <source>Drop Linux capabilities</source>
          <target state="translated">Linux 기능 삭제</target>
        </trans-unit>
        <trans-unit id="0133959e0fe28ab7df28ee900d281cb45688219d" translate="yes" xml:space="preserve">
          <source>Due to these rules, the following examples are all invalid:</source>
          <target state="translated">이러한 규칙으로 인해 다음 예제는 모두 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1203cbad7d464de9bf142430c50fba1897215d2" translate="yes" xml:space="preserve">
          <source>Dump raw JSON data</source>
          <target state="translated">원시 JSON 데이터 덤프</target>
        </trans-unit>
        <trans-unit id="5fcbce098b3631017ceed4386fb90b26949078a6" translate="yes" xml:space="preserve">
          <source>Duplicate keys with conflicting values in engine labels</source>
          <target state="translated">엔진 레이블에서 충돌하는 값을 가진 중복 키</target>
        </trans-unit>
        <trans-unit id="034eba109fdd840d7987f2f7935b670a859ce55a" translate="yes" xml:space="preserve">
          <source>Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h)</source>
          <target state="translated">실패를 모니터링하기 위해 각 작업 롤백 후 지속 시간 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="c59ac303e72ea0ef7a170c402f88f45692524572" translate="yes" xml:space="preserve">
          <source>Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h) (default 5s)</source>
          <target state="translated">실패를 모니터링하기 위해 각 작업 롤백 후 지속 시간 (ns | us | ms | s | m | h) (기본값 5s)</target>
        </trans-unit>
        <trans-unit id="da4c7e39ba8c23e5e0cd899639175471eebf78e6" translate="yes" xml:space="preserve">
          <source>Duration after each task rollback to monitor for failure. If a task stops before this time period has elapsed, the rollback is considered to have failed.</source>
          <target state="translated">각 작업 롤백 후 실패를 모니터링하기위한 기간입니다. 이 기간이 경과하기 전에 작업이 중지되면 롤백이 실패한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0a61c50c913a6678b1bfd7c31c73581a705f1488" translate="yes" xml:space="preserve">
          <source>Duration after each task update to monitor for failure (ns|us|ms|s|m|h)</source>
          <target state="translated">각 작업 업데이트 후 실패를 모니터링하기위한 기간 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="6f49c2a3a35daff2e829e9af1525f2881741bf33" translate="yes" xml:space="preserve">
          <source>Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 5s)</source>
          <target state="translated">각 작업 업데이트 후 실패를 모니터링하기위한 기간 (ns | us | ms | s | m | h) (기본값 5s)</target>
        </trans-unit>
        <trans-unit id="53554785487e58cd3cefb0f6ceb88e2b6bd04dfe" translate="yes" xml:space="preserve">
          <source>During request/response processing, some authorization flows might need to do additional queries to the Docker daemon. To complete such flows, plugins can call the daemon API similar to a regular user. To enable these additional queries, the plugin must provide the means for an administrator to configure proper authentication and security policies.</source>
          <target state="translated">요청 / 응답 처리 중에 일부 권한 부여 흐름은 Docker 데몬에 대한 추가 쿼리를 수행해야 할 수도 있습니다. 이러한 흐름을 완료하기 위해 플러그인은 일반 사용자와 비슷한 데몬 API를 호출 할 수 있습니다. 이러한 추가 쿼리를 활성화하려면 플러그인은 관리자가 적절한 인증 및 보안 정책을 구성 할 수있는 수단을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="405e980d070ffd80ef37d8db39f5de068a7257fb" translate="yes" xml:space="preserve">
          <source>Dynamic IP addresses are OK for worker nodes.</source>
          <target state="translated">작업자 노드에는 동적 IP 주소가 정상입니다.</target>
        </trans-unit>
        <trans-unit id="faef57a22f7dc2e4b79a848b00f33490f12e5bd3" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT</source>
          <target state="translated">ENTRYPOINT</target>
        </trans-unit>
        <trans-unit id="04d4562bb62de255ce2134b682c3ab49d92a1184" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT (Default Command to Execute at Runtime)</source>
          <target state="translated">ENTRYPOINT (런타임에서 실행되는 기본 명령)</target>
        </trans-unit>
        <trans-unit id="1677e962b49d802523d196bc91db93a12cdada42" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT (default command to execute at runtime)</source>
          <target state="translated">ENTRYPOINT (런타임에 실행되는 기본 명령)</target>
        </trans-unit>
        <trans-unit id="83f5abde9a6352351a80acadba39616daafb7b93" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT [&amp;ldquo;exec_entry&amp;rdquo;, &amp;ldquo;p1_entry&amp;rdquo;]</source>
          <target state="translated">ENTRYPOINT [&amp;ldquo;exec_entry&amp;rdquo;,&amp;ldquo;p1_entry&amp;rdquo;]</target>
        </trans-unit>
        <trans-unit id="92fd4ff5517c94179eb9833675bd0b743beeb4fd" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT exec_entry p1_entry</source>
          <target state="translated">ENTRYPOINT exec_entry p1_entry</target>
        </trans-unit>
        <trans-unit id="7f184d5c4b1062456981688cae02931835eb9712" translate="yes" xml:space="preserve">
          <source>ENTRYPOINT has two forms:</source>
          <target state="translated">ENTRYPOINT는 두 가지 형태가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="086bfb42cb0e1f0682c42f25c92a8f7e76b5bda4" translate="yes" xml:space="preserve">
          <source>ENV</source>
          <target state="translated">ENV</target>
        </trans-unit>
        <trans-unit id="03e04fbf0b8725a53a6cbe38461c5e03bae0c5b7" translate="yes" xml:space="preserve">
          <source>ENV (Environment Variables)</source>
          <target state="translated">ENV (환경 변수)</target>
        </trans-unit>
        <trans-unit id="8dce721662f75046379d078561daafe3ba721934" translate="yes" xml:space="preserve">
          <source>ENV (environment variables)</source>
          <target state="translated">ENV (환경 변수)</target>
        </trans-unit>
        <trans-unit id="4fb971f0e169071591da240f314bc6257187853c" translate="yes" xml:space="preserve">
          <source>EXPOSE</source>
          <target state="translated">EXPOSE</target>
        </trans-unit>
        <trans-unit id="205f373e190ef924849c88ee768b689f00154d1e" translate="yes" xml:space="preserve">
          <source>EXPOSE (Incoming Ports)</source>
          <target state="translated">EXPOSE (수신 포트)</target>
        </trans-unit>
        <trans-unit id="f9ece15f75c59e80e6a67c5b0f0021430e495c12" translate="yes" xml:space="preserve">
          <source>EXPOSE (incoming ports)</source>
          <target state="translated">EXPOSE (수신 포트)</target>
        </trans-unit>
        <trans-unit id="fec76ceae8ec767e98d00e461960272da2b038cd" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; may contain wildcards and matching will be done using Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/path/filepath#Match&quot;&gt;filepath.Match&lt;/a&gt; rules. For example:</source>
          <target state="translated">각 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 는 와일드 카드를 포함 할 수 있으며 일치는 Go의 &lt;a href=&quot;http://golang.org/pkg/path/filepath#Match&quot;&gt;filepath.Match&lt;/a&gt; 규칙을 사용하여 수행 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f939d974bc27b2998fc295acd174f5d1d234214a" translate="yes" xml:space="preserve">
          <source>Each configuration has a project name. If you supply a &lt;code&gt;-p&lt;/code&gt; flag, you can specify a project name. If you don&amp;rsquo;t specify the flag, Compose uses the current directory name. See also the &lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME environment variable&lt;/a&gt;.</source>
          <target state="translated">각 구성에는 프로젝트 이름이 있습니다. 당신이 제공하는 경우 &lt;code&gt;-p&lt;/code&gt; 플래그를, 당신은 프로젝트 이름을 지정할 수 있습니다. 플래그를 지정하지 않으면 작성은 현재 디렉토리 이름을 사용합니다. &lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME 환경 변수&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d05d3dac7850e88121b8c8657cbb82c0c48d319d" translate="yes" xml:space="preserve">
          <source>Each container can now look up the hostname &lt;code&gt;web&lt;/code&gt; or &lt;code&gt;db&lt;/code&gt; and get back the appropriate container&amp;rsquo;s IP address. For example, &lt;code&gt;web&lt;/code&gt;&amp;rsquo;s application code could connect to the URL &lt;code&gt;postgres://db:5432&lt;/code&gt; and start using the Postgres database.</source>
          <target state="translated">각 컨테이너는 이제 호스트 이름 &lt;code&gt;web&lt;/code&gt; 또는 &lt;code&gt;db&lt;/code&gt; 를 조회 하고 적절한 컨테이너의 IP 주소를 가져올 수 있습니다. 예를 들어, &lt;code&gt;web&lt;/code&gt; 애플리케이션 코드는 URL &lt;code&gt;postgres://db:5432&lt;/code&gt; 에 연결 하여 Postgres 데이터베이스 사용을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d3059d71a3c7e0018a7f1eac3dab7fc01b8dc7" translate="yes" xml:space="preserve">
          <source>Each driver has a set of options specific to that provider. These options provide information to machine such as connection credentials, ports, and so forth. For example, to create an Azure machine:</source>
          <target state="translated">각 드라이버에는 해당 공급자에 특정한 옵션 세트가 있습니다. 이 옵션은 연결 자격 증명, 포트 등과 같은 정보를 컴퓨터에 제공합니다. 예를 들어 Azure 컴퓨터를 만들려면</target>
        </trans-unit>
        <trans-unit id="0a9ac250ed75a8fea3b23e453a93e4a9adcf7d4b" translate="yes" xml:space="preserve">
          <source>Each file contains three fields: the username or ID of the user, followed by a beginning UID or GID (which is treated as UID or GID 0 within the namespace) and a maximum number of UIDs or GIDs available to the user. For instance, given the following entry:</source>
          <target state="translated">각 파일에는 사용자의 사용자 이름 또는 ID, 시작 UID 또는 GID (이름 공간 내 UID 또는 GID 0으로 처리됨) 및 사용자가 사용할 수있는 최대 UID 또는 GID의 세 가지 필드가 있습니다. 예를 들어 다음과 같은 항목이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="48d29e9b7dc895f5241f8439eda539b51c5c11c4" translate="yes" xml:space="preserve">
          <source>Each machine is created with a public dynamic IP address for external connectivity. All its ports (except Docker and SSH) are closed by default. You can use &lt;code&gt;--azure-open-port&lt;/code&gt; argument to specify multiple port numbers to be accessible from Internet.</source>
          <target state="translated">각 컴퓨터는 외부 연결을위한 공개 동적 IP 주소로 생성됩니다. Docker 및 SSH를 제외한 모든 포트는 기본적으로 닫혀 있습니다. 당신은 사용할 수 있습니다 &lt;code&gt;--azure-open-port&lt;/code&gt; 인터넷에서 액세스 할 수 있도록 여러 개의 포트 번호를 지정하는 인수를.</target>
        </trans-unit>
        <trans-unit id="f7cf7abc3625e74684dcb7c2a7f5ea37a6f32e52" translate="yes" xml:space="preserve">
          <source>Each of these commands has the same result.</source>
          <target state="translated">이러한 각 명령의 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="72688ceb1a686a8383bd3bad94e7f07926f95bba" translate="yes" xml:space="preserve">
          <source>Each of these is a single value, analogous to its &lt;a href=&quot;../../../engine/reference/run/index&quot;&gt;docker run&lt;/a&gt; counterpart.</source>
          <target state="translated">이들 각각은 단일 값으로 &lt;a href=&quot;../../../engine/reference/run/index&quot;&gt;도커 실행&lt;/a&gt; 대응 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c05fb1ce12f08ea9d8319a0b5cb6bbed623d709f" translate="yes" xml:space="preserve">
          <source>Each of these is a single value, analogous to its &lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;docker service create&lt;/a&gt; counterpart.</source>
          <target state="translated">이들 각각은 단일 값으로, &lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;도커 서비스 생성&lt;/a&gt; 대응 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="112493318b697fbb6df3f82f76f9734a97e10cf2" translate="yes" xml:space="preserve">
          <source>Each of these is a single value, analogous to its &lt;a href=&quot;../../engine/reference/run/index&quot;&gt;docker run&lt;/a&gt; counterpart. Note that &lt;code&gt;mac_address&lt;/code&gt; is a legacy option.</source>
          <target state="translated">이들 각각은 단일 값으로 &lt;a href=&quot;../../engine/reference/run/index&quot;&gt;도커 실행&lt;/a&gt; 대응 과 유사합니다 . 참고 것을 &lt;code&gt;mac_address&lt;/code&gt; 는 레거시 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="8547c75aa80e0153efd29d3adb473078942ffb32" translate="yes" xml:space="preserve">
          <source>Each plugin must support two request authorization messages formats, one from the daemon to the plugin and then from the plugin to the daemon. The tables below detail the content expected in each message.</source>
          <target state="translated">각 플러그인은 데몬에서 플러그인으로, 플러그인에서 데몬으로 두 가지 요청 권한 부여 메시지 형식을 지원해야합니다. 아래 표에는 각 메시지에 필요한 내용이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="68288698f702142daab7d4db0b2579a134118a4f" translate="yes" xml:space="preserve">
          <source>Each request sent to the plugin includes the authenticated user, the HTTP headers, and the request/response body. Only the user name and the authentication method used are passed to the plugin. Most importantly, no user credentials or tokens are passed. Finally, not all request/response bodies are sent to the authorization plugin. Only those request/response bodies where the &lt;code&gt;Content-Type&lt;/code&gt; is either &lt;code&gt;text/*&lt;/code&gt; or &lt;code&gt;application/json&lt;/code&gt; are sent.</source>
          <target state="translated">플러그인으로 전송 된 각 요청에는 인증 된 사용자, HTTP 헤더 및 요청 / 응답 본문이 포함됩니다. 사용 된 사용자 이름과 인증 방법 만 플러그인으로 전달됩니다. 가장 중요한 것은 사용자 자격 증명이나 토큰이 전달되지 않습니다. 마지막으로 모든 요청 / 응답 본문이 권한 부여 플러그인으로 전송되는 것은 아닙니다. &lt;code&gt;Content-Type&lt;/code&gt; 이 &lt;code&gt;text/*&lt;/code&gt; 또는 &lt;code&gt;application/json&lt;/code&gt; 인 요청 / 응답 본문 만 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ede8414aac2a8f9c014fb055a6c15ef89760961c" translate="yes" xml:space="preserve">
          <source>Each service can specify what networks to connect to with the &lt;em&gt;service-level&lt;/em&gt;&lt;code&gt;networks&lt;/code&gt; key, which is a list of names referencing entries under the &lt;em&gt;top-level&lt;/em&gt;&lt;code&gt;networks&lt;/code&gt; key.</source>
          <target state="translated">각 서비스는과에 연결하기 위해 어떤 네트워크를 지정할 수 있습니다 &lt;em&gt;서비스 수준의 &lt;/em&gt; &lt;code&gt;networks&lt;/code&gt; 세 이하 항목 참조 이름의 목록입니다 키, &lt;em&gt;최고 수준의 &lt;/em&gt; &lt;code&gt;networks&lt;/code&gt; 키.</target>
        </trans-unit>
        <trans-unit id="ddf861ab76baae722957a31e0c09819c1c81b9da" translate="yes" xml:space="preserve">
          <source>Each service uses environment variables to specify where the service should look for that secret data.</source>
          <target state="translated">각 서비스는 환경 변수를 사용하여 서비스가 해당 비밀 데이터를 찾아야하는 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cd8f61abf8393e15d2e53da309cf37cc9e034baf" translate="yes" xml:space="preserve">
          <source>Each tag represents a digest, similar to a Git hash. Some tags, such as &lt;code&gt;latest&lt;/code&gt;, are updated often to point to a new digest. Others, such as &lt;code&gt;ubuntu:16.04&lt;/code&gt;, represent a released software version and are not expected to update to point to a new digest often if at all. In Docker 1.13 and higher, when you create a service, it is constrained to create tasks using a specific digest of an image until you update the service using &lt;code&gt;service update&lt;/code&gt; with the &lt;code&gt;--image&lt;/code&gt; flag. If you use an older version of Docker Engine, you must remove and re-create the service to update its image.</source>
          <target state="translated">각 태그는 Git 해시와 유사한 다이제스트를 나타냅니다. &lt;code&gt;latest&lt;/code&gt; 와 같은 일부 태그 는 종종 새로운 다이제스트를 가리 키도록 업데이트됩니다. &lt;code&gt;ubuntu:16.04&lt;/code&gt; 와 같은 다른 소프트웨어는 출시 된 소프트웨어 버전을 나타내며 새로운 다이제스트를 가리 키도록 업데이트되지 않을 것으로 예상됩니다. Docker 1.13 이상에서 서비스를 작성할 때 &lt;code&gt;--image&lt;/code&gt; 플래그 와 함께 &lt;code&gt;service update&lt;/code&gt; 를 사용하여 서비스를 업데이트 할 때까지 특정 이미지 요약을 사용하여 태스크를 작성하도록 제한됩니다 . 이전 버전의 Docker Engine을 사용하는 경우 이미지를 업데이트하려면 서비스를 제거한 후 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6f2f4704f62df79d585dc4ffe564572ce2ba51b" translate="yes" xml:space="preserve">
          <source>Each time a new node joins the swarm, the manager issues a certificate to the node. The certificate contains a randomly generated node ID to identify the node under the certificate common name (CN) and the role under the organizational unit (OU). The node ID serves as the cryptographically secure node identity for the lifetime of the node in the current swarm.</source>
          <target state="translated">새 노드가 웜에 가입 할 때마다 관리자는 노드에 인증서를 발급합니다. 인증서에는 CN (인증서 공통 이름) 아래의 노드와 OU (조직 구성 단위) 아래의 노드를 식별하기 위해 임의로 생성 된 노드 ID가 포함됩니다. 노드 ID는 현재 떼에서 노드의 수명 동안 암호로 안전한 노드 ID 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="659da81d9c19635927de8c105a82812d63c281f0" translate="yes" xml:space="preserve">
          <source>Edit &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;. Assuming the file was previously empty, the following entry enables &lt;code&gt;userns-remap&lt;/code&gt; using user and group called &lt;code&gt;testuser&lt;/code&gt;. You can address the user and group by ID or name. You only need to specify the group name or ID if it is different from the user name or ID. If you provide both the user and group name or ID, separate them by a colon (&lt;code&gt;:&lt;/code&gt;) character. The following formats all work for the value, assuming the UID and GID of &lt;code&gt;testuser&lt;/code&gt; are &lt;code&gt;1001&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 을 편집 하십시오 . 파일이 이전에 비어 있다고 가정하면 다음 항목은 &lt;code&gt;testuser&lt;/code&gt; 라는 사용자 및 그룹을 사용하여 &lt;code&gt;userns-remap&lt;/code&gt; 을 활성화 합니다. ID 또는 이름으로 사용자 및 그룹을 지정할 수 있습니다. 사용자 이름 또는 ID와 다른 경우 그룹 이름 또는 ID 만 지정하면됩니다. (당신이 사용자 및 그룹 이름이나 ID 모두를 제공하는 경우, 콜론으로 구분 &lt;code&gt;:&lt;/code&gt; ) 문자. &lt;code&gt;testuser&lt;/code&gt; 의 UID 및 GID 가 &lt;code&gt;1001&lt;/code&gt; 이라고 가정하면 다음 형식이 모두 값에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="16e51a30d5c7085e75eb2ed76ad0ee16781ee86d" translate="yes" xml:space="preserve">
          <source>Edit &lt;code&gt;docker-compose.yml&lt;/code&gt; in your project directory to add a &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;bind mount&lt;/a&gt; for the &lt;code&gt;web&lt;/code&gt; service:</source>
          <target state="translated">&lt;code&gt;web&lt;/code&gt; 서비스에 대한 &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;바인드 마운트&lt;/a&gt; 를 추가하려면 프로젝트 디렉토리에서 &lt;code&gt;docker-compose.yml&lt;/code&gt; 을 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="030ba073945e9a4d524dd24469171822bc1bba7b" translate="yes" xml:space="preserve">
          <source>Edit the &lt;code&gt;site.conf&lt;/code&gt; file locally. Add &lt;code&gt;index.php&lt;/code&gt; to the &lt;code&gt;index&lt;/code&gt; line, and save the file.</source>
          <target state="translated">&lt;code&gt;site.conf&lt;/code&gt; 파일을 로컬에서 편집하십시오 . &lt;code&gt;index.php&lt;/code&gt; 를 &lt;code&gt;index&lt;/code&gt; 행에 추가 하고 파일을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="6bce1d3a05a28e804e1f31329955f70786fe93e5" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;global&lt;/code&gt; (exactly one container per swarm node) or &lt;code&gt;replicated&lt;/code&gt; (a specified number of containers). The default is &lt;code&gt;replicated&lt;/code&gt;. (To learn more, see &lt;a href=&quot;../../engine/swarm/how-swarm-mode-works/services/index#replicated-and-global-services&quot;&gt;Replicated and global services&lt;/a&gt; in the &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm&lt;/a&gt; topics.)</source>
          <target state="translated">어느 &lt;code&gt;global&lt;/code&gt; (정확히 하나 개의 무리 노드 당 컨테이너) 또는 &lt;code&gt;replicated&lt;/code&gt; (용기 지정된 수). 기본값은 &lt;code&gt;replicated&lt;/code&gt; 입니다. 자세한 내용 은 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm&lt;/a&gt; 주제의 &lt;a href=&quot;../../engine/swarm/how-swarm-mode-works/services/index#replicated-and-global-services&quot;&gt;복제 및 글로벌 서비스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="034fd3d633edbf5f3d71596084aedf716e386c5d" translate="yes" xml:space="preserve">
          <source>Either a path to a directory containing a Dockerfile, or a url to a git repository.</source>
          <target state="translated">Dockerfile을 포함하는 디렉토리의 경로 또는 git 저장소의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="4e54b82b5409478679f33467cdc36837f8bd9108" translate="yes" xml:space="preserve">
          <source>Either connect the external container to your app&amp;rsquo;s &lt;a href=&quot;../networking/index&quot;&gt;default network&lt;/a&gt;, or connect both the external container and your service&amp;rsquo;s containers to an &lt;a href=&quot;../networking/index#using-a-pre-existing-network&quot;&gt;external network&lt;/a&gt;.</source>
          <target state="translated">외부 컨테이너를 앱의 &lt;a href=&quot;../networking/index&quot;&gt;기본 네트워크&lt;/a&gt; 에 연결하거나 외부 컨테이너와 서비스 컨테이너를 모두 &lt;a href=&quot;../networking/index#using-a-pre-existing-network&quot;&gt;외부 네트워크에 연결하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0459cd16db81041abea3871a268e6cc405528079" translate="yes" xml:space="preserve">
          <source>Either specify both ports (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or just the container port (an ephemeral host port is chosen).</source>
          <target state="translated">두 포트 ( &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ) 또는 컨테이너 포트만 지정하십시오 (일시적인 호스트 포트가 선택됨).</target>
        </trans-unit>
        <trans-unit id="81cc40da1ba6b25ccfd5e40ffbd683b8fdb1e64c" translate="yes" xml:space="preserve">
          <source>Either way, the container ID changes, demonstrating the load-balancing; with each request, one of the 5 tasks is chosen, in a round-robin fashion, to respond. The container IDs match your output from the previous command (&lt;code&gt;docker container ls -q&lt;/code&gt;).</source>
          <target state="translated">어느 쪽이든 컨테이너 ID가 변경되어로드 밸런싱을 보여줍니다. 각 요청마다 5 개의 작업 중 하나가 라운드 로빈 방식으로 선택되어 응답합니다. 컨테이너 ID는 이전 명령의 출력과 일치합니다 ( &lt;code&gt;docker container ls -q&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dcfce7f7a7b6f391557239cc872516341c580a8b" translate="yes" xml:space="preserve">
          <source>Elapsed time since the container was started.</source>
          <target state="translated">컨테이너가 시작된 이후 경과 시간</target>
        </trans-unit>
        <trans-unit id="f871297e2664ceb7970d1a447ad4542a616c52ac" translate="yes" xml:space="preserve">
          <source>Elapsed time since the image was created</source>
          <target state="translated">이미지가 생성 된 후 경과 된 시간</target>
        </trans-unit>
        <trans-unit id="ca17c24def8e4372a838d5bfe0a0e0bfbb4b76c7" translate="yes" xml:space="preserve">
          <source>Elapsed time since the image was created if &lt;code&gt;--human=true&lt;/code&gt;, otherwise timestamp of when image was created</source>
          <target state="translated">&lt;code&gt;--human=true&lt;/code&gt; 인 경우 이미지가 생성 된 후 경과 된 시간 , 그렇지 않은 경우 이미지가 생성 된 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="2c3492f51f4fa3e7ecfaa09607bfe1811b868dda" translate="yes" xml:space="preserve">
          <source>Employ features that can block system suspend.</source>
          <target state="translated">시스템 일시 중단을 차단할 수있는 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b93df846d96019fa32d739accbe1fb399b6c23a7" translate="yes" xml:space="preserve">
          <source>Enable Docker experimental</source>
          <target state="translated">도커 실험 사용</target>
        </trans-unit>
        <trans-unit id="b1b96feffa71f19ade959ce82c01db18aca86230" translate="yes" xml:space="preserve">
          <source>Enable IP masquerading</source>
          <target state="translated">IP 마스커레이딩 사용</target>
        </trans-unit>
        <trans-unit id="ea3a8f185eac3902f4b71a4b69ec9adc6b95b2f1" translate="yes" xml:space="preserve">
          <source>Enable IPv6 networking</source>
          <target state="translated">IPv6 네트워킹 활성화</target>
        </trans-unit>
        <trans-unit id="8b6bab18a4495a9f6f662faef1b93be08e1f4126" translate="yes" xml:space="preserve">
          <source>Enable IPv6 networking on this network.</source>
          <target state="translated">이 네트워크에서 IPv6 네트워킹을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5fb64ad03e43c38f193b35e2090ba0f5d7d81090" translate="yes" xml:space="preserve">
          <source>Enable a plugin</source>
          <target state="translated">플러그인 사용</target>
        </trans-unit>
        <trans-unit id="12489120255975ffad5d0dfeb58120a9ca6e21db" translate="yes" xml:space="preserve">
          <source>Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering rules.</source>
          <target state="translated">커널 감사를 활성화 및 비활성화합니다. 감사 필터 규칙 변경; 감사 상태 및 필터링 규칙을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0c04a3ee9ec392fb3a8d83b2a032948695456223" translate="yes" xml:space="preserve">
          <source>Enable content trust.</source>
          <target state="translated">콘텐츠 신뢰를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="03bb6120d33e7d454f7c3f8c75cc6e2f71bfe924" translate="yes" xml:space="preserve">
          <source>Enable manager autolocking (requiring an unlock key to start a stopped manager)</source>
          <target state="translated">관리자 자동 잠금 사용 (중지 된 관리자를 시작하려면 잠금 해제 키 필요)</target>
        </trans-unit>
        <trans-unit id="687bf24cbad4ddbe97dff925d9be8e557ad3c710" translate="yes" xml:space="preserve">
          <source>Enable manual container attachment</source>
          <target state="translated">수동 컨테이너 부착 사용</target>
        </trans-unit>
        <trans-unit id="5b310e38a9ad3a2b0b920d01a78f6b533ac50926" translate="yes" xml:space="preserve">
          <source>Enable or Disable Inter Container Connectivity</source>
          <target state="translated">컨테이너 간 연결 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="4afbb8b67d2f281a99ccb340341111363cb1bf22" translate="yes" xml:space="preserve">
          <source>Enable or disable autolock on an existing swarm</source>
          <target state="translated">기존 떼에서 자동 잠금 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="f069781d967febc4ff6f8ed4e19b46dc73ebe6e2" translate="yes" xml:space="preserve">
          <source>Enable path conversion from Windows-style to Unix-style in volume definitions. Users of Docker Machine and Docker Toolbox on Windows should always set this. Defaults to &lt;code&gt;0&lt;/code&gt;. Supported values: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">볼륨 정의에서 Windows 스타일에서 Unix 스타일로 경로를 변환 할 수 있습니다. Windows의 Docker Machine 및 Docker Toolbox 사용자는 항상 이것을 설정해야합니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 지원되는 값 : &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; ( 활성화), &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; ( 비활성화)</target>
        </trans-unit>
        <trans-unit id="7b26ab87d29ba39e5169ffcad08a66bc67488042" translate="yes" xml:space="preserve">
          <source>Enable the authorization plugin with a dedicated command line flag in the &lt;code&gt;--authorization-plugin=PLUGIN_ID&lt;/code&gt; format. The flag supplies a &lt;code&gt;PLUGIN_ID&lt;/code&gt; value. This value can be the plugin&amp;rsquo;s socket or a path to a specification file. Authorization plugins can be loaded without restarting the daemon. Refer to the &lt;a href=&quot;../../reference/commandline/dockerd/index#configuration-reloading&quot;&gt;&lt;code&gt;dockerd&lt;/code&gt; documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;--authorization-plugin=PLUGIN_ID&lt;/code&gt; 형식 의 전용 명령 줄 플래그를 사용하여 권한 부여 플러그인을 활성화하십시오 . 플래그는 &lt;code&gt;PLUGIN_ID&lt;/code&gt; 값을 제공합니다. 이 값은 플러그인의 소켓이거나 사양 파일의 경로 일 수 있습니다. 데몬을 다시 시작하지 않고도 권한 부여 플러그인을로드 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../reference/commandline/dockerd/index#configuration-reloading&quot;&gt; &lt;code&gt;dockerd&lt;/code&gt; 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b483056614dd2499f92b4d9d440f9e2798fbbcc" translate="yes" xml:space="preserve">
          <source>Enable userns-remap on the daemon</source>
          <target state="translated">데몬에서 userns-remap 활성화</target>
        </trans-unit>
        <trans-unit id="bbc0a1ee61521c138c75b9c237d4994fc3fd6f6d" translate="yes" xml:space="preserve">
          <source>Enables a plugin. The plugin must be installed before it can be enabled, see &lt;a href=&quot;../plugin_install/index&quot;&gt;&lt;code&gt;docker plugin install&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그인을 활성화합니다. 플러그인을 사용하려면 먼저 &lt;a href=&quot;../plugin_install/index&quot;&gt; &lt;code&gt;docker plugin install&lt;/code&gt; &lt;/a&gt; 합니다 ( docker plugin install 참조) .</target>
        </trans-unit>
        <trans-unit id="3a1cf1630ffda1cf99ca4a5d913d2bea4156ff36" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of &lt;code&gt;blkdiscard&lt;/code&gt; when removing devicemapper devices. This is enabled by default (only) if using loopback devices and is required to resparsify the loopback file on image/container removal.</source>
          <target state="translated">&lt;code&gt;blkdiscard&lt;/code&gt; 장치를 제거 할 때 blkdiscard 사용을 활성화 또는 비활성화합니다 . 이것은 루프백 장치를 사용하는 경우 기본적으로 활성화되며 이미지 / 컨테이너 제거시 루프백 파일을 재분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="60e8ec556f1b1efdd9cde6a8e7c6346f818592a0" translate="yes" xml:space="preserve">
          <source>Enables use of deferred device deletion for thin pool devices. By default, thin pool device deletion is synchronous. Before a container is deleted, the Docker daemon removes any associated devices. If the storage driver can not remove a device, the container deletion fails and daemon returns.</source>
          <target state="translated">씬 풀 장치에 대해 지연된 장치 삭제를 사용할 수 있습니다. 기본적으로 씬 풀 장치 삭제는 동 기적입니다. 컨테이너가 삭제되기 전에 Docker 데몬은 관련된 모든 장치를 제거합니다. 스토리지 드라이버가 디바이스를 제거 할 수없는 경우 컨테이너 삭제에 실패하고 디먼이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6bad1fc1ebc05187b9c5d1bcffd98fcc36e7e086" translate="yes" xml:space="preserve">
          <source>Enables use of deferred device removal if &lt;code&gt;libdm&lt;/code&gt; and the kernel driver support the mechanism.</source>
          <target state="translated">&lt;code&gt;libdm&lt;/code&gt; 및 커널 드라이버가 메커니즘을 지원하는 경우 지연된 장치 제거를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="407c321f923d222152ab1d34fcc71de67e6b8f8e" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--insecure-registry&lt;/code&gt;, i.e., allowing un-encrypted and/or untrusted communication, can be useful when running a local registry. However, because its use creates security vulnerabilities it should ONLY be enabled for testing purposes. For increased security, users should add their CA to their system&amp;rsquo;s list of trusted CAs instead of enabling &lt;code&gt;--insecure-registry&lt;/code&gt;.</source>
          <target state="translated">로컬 레지스트리를 실행할 때 &lt;code&gt;--insecure-registry&lt;/code&gt; 를 활성화 하면 (즉, 암호화되지 않은 및 / 또는 신뢰할 수없는 통신 허용) 유용 할 수 있습니다. 그러나 보안 취약점을 사용하면 테스트 목적으로 만 사용하도록 설정해야합니다. 보안 강화를 위해 사용자는 &lt;code&gt;--insecure-registry&lt;/code&gt; 를 활성화하는 대신 시스템의 신뢰할 수있는 CA 목록에 CA를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="479b71dbee892668c1f80cc6251c8e81c7bc1e0e" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;userns-remap&lt;/code&gt; effectively masks existing image and container layers, as well as other Docker objects within &lt;code&gt;/var/lib/docker/&lt;/code&gt;. This is because Docker needs to adjust the ownership of these resources and actually stores them in a subdirectory within &lt;code&gt;/var/lib/docker/&lt;/code&gt;. It is best to enable this feature on a new Docker installation rather than an existing one.</source>
          <target state="translated">사용자 &lt;code&gt;userns-remap&lt;/code&gt; 활성화 하면 기존 이미지 및 컨테이너 레이어뿐만 아니라 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 내의 다른 Docker 객체도 효과적으로 마스크 됩니다. Docker는 이러한 자원의 소유권을 조정하고 실제로 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 내의 하위 디렉토리에 저장해야하기 때문 입니다. 기존 기능이 아닌 새로운 Docker 설치에서이 기능을 활성화하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8df41410f0e69c3b669c6b0c90fd203bf9aa13dd" translate="yes" xml:space="preserve">
          <source>Enabling DCT within the Docker Enterprise Engine</source>
          <target state="translated">Docker Enterprise Engine 내에서 DCT 활성화</target>
        </trans-unit>
        <trans-unit id="77b7c0b80a55a6a3bbed07276ee02a49e018b49c" translate="yes" xml:space="preserve">
          <source>Endpoint mode (vip or dnsrr)</source>
          <target state="translated">엔드 포인트 모드 (vip 또는 dnsrr)</target>
        </trans-unit>
        <trans-unit id="c1f65ddb75ed7d97e701168af35171410be8f9e7" translate="yes" xml:space="preserve">
          <source>Engine</source>
          <target state="translated">Engine</target>
        </trans-unit>
        <trans-unit id="c7ca0168639b26558608f71306fbcfc59170c974" translate="yes" xml:space="preserve">
          <source>Engine Signature Verification prevents the following:</source>
          <target state="translated">엔진 서명 확인은 다음을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="bb5b74c5ab88f1844f3d33bc8aada0e5ae1e4bc8" translate="yes" xml:space="preserve">
          <source>Engine labels, however, are still useful because some features that do not affect secure orchestration of containers might be better off set in a decentralized manner. For instance, an engine could have a label to indicate that it has a certain type of disk device, which may not be relevant to security directly. These labels are more easily &amp;ldquo;trusted&amp;rdquo; by the swarm orchestrator.</source>
          <target state="translated">그러나 컨테이너의 안전한 오케스트레이션에 영향을 미치지 않는 일부 기능이 분산 방식으로 더 잘 설정 될 수 있기 때문에 엔진 레이블은 여전히 ​​유용합니다. 예를 들어 엔진에는 특정 유형의 디스크 장치가 있음을 나타내는 레이블이있을 수 있으며 이는 보안과 직접 ​​관련이 없을 수 있습니다. 이 레이블은 웜 오케 스트레이터가보다 쉽게 ​​&quot;신뢰할 수 있습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="6110771211754965a99627f5efceaae01c3623bb" translate="yes" xml:space="preserve">
          <source>Engine version</source>
          <target state="translated">엔진 버전</target>
        </trans-unit>
        <trans-unit id="8dc56c74fb98052210621189c5f8286d06e5d247" translate="yes" xml:space="preserve">
          <source>Engine: CLI</source>
          <target state="translated">엔진 : CLI</target>
        </trans-unit>
        <trans-unit id="233a0fc8e1e9435025bf34accd0b6fd84de93f5c" translate="yes" xml:space="preserve">
          <source>Engine: Extend</source>
          <target state="translated">엔진 : 확장</target>
        </trans-unit>
        <trans-unit id="e2a0889b3a84740853205595574538dfa4e36613" translate="yes" xml:space="preserve">
          <source>Engine: Security</source>
          <target state="translated">엔진 : 보안</target>
        </trans-unit>
        <trans-unit id="3a5cf14888a952dd25e7d0bd8b009362bf336170" translate="yes" xml:space="preserve">
          <source>Enjoy working with Compose faster and with fewer typos!</source>
          <target state="translated">작성 시간을 단축하고 오타를 줄이면서 Compose 작업을 즐기십시오!</target>
        </trans-unit>
        <trans-unit id="cb0d2ab53d82a94125c6eba2fc2d44118e26a662" translate="yes" xml:space="preserve">
          <source>Ensure that you ran hello-world on aws-sandbox (and not localhost or some other machine):</source>
          <target state="translated">로컬 호스트 나 다른 시스템이 아닌 aws-sandbox에서 hello-world를 실행했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9f45880843193cbed95cd4a2f28cc693f125f063" translate="yes" xml:space="preserve">
          <source>Ensure that your new machine is the active host.</source>
          <target state="translated">새 머신이 활성 호스트인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="07ba826bff5d02d3be3fdfe8c72d338c2e592a78" translate="yes" xml:space="preserve">
          <source>Enter http://localhost:5000/ in a browser to see the application running.</source>
          <target state="translated">브라우저에서 http : // localhost : 5000 /을 입력하여 애플리케이션이 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f98c86359b348a7eb1389606655f5679dba4563c" translate="yes" xml:space="preserve">
          <source>Enter the encryption key that was generated and shown in the command output when you locked the swarm or rotated the key, and the swarm unlocks.</source>
          <target state="translated">떼를 잠 그거나 키를 돌릴 때 명령 출력에 생성되어 표시된 암호화 키를 입력하면 떼가 잠금 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="038719f6ceb54de987547575fd78d6a1f65751b2" translate="yes" xml:space="preserve">
          <source>Entries for &lt;code&gt;volumes&lt;/code&gt; and &lt;code&gt;devices&lt;/code&gt; are merged using the mount path in the container:</source>
          <target state="translated">&lt;code&gt;volumes&lt;/code&gt; 및 &lt;code&gt;devices&lt;/code&gt; 대한 항목 은 컨테이너의 마운트 경로를 사용하여 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="b56277a540bec60ac935f8adc8f0ea1f1cd3de64" translate="yes" xml:space="preserve">
          <source>Env &lt;code&gt;[]string&lt;/code&gt;</source>
          <target state="translated">환경 &lt;code&gt;[]string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="384a6e9623ee89d57bf379a1678db79477e198f0" translate="yes" xml:space="preserve">
          <source>Environment Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b32271fa672079e69cc48ae73aa09818054726" translate="yes" xml:space="preserve">
          <source>Environment file</source>
          <target state="translated">환경 파일</target>
        </trans-unit>
        <trans-unit id="ded050a86ce618b1ff5f973718a6edcdca017e9c" translate="yes" xml:space="preserve">
          <source>Environment replacement</source>
          <target state="translated">환경 교체</target>
        </trans-unit>
        <trans-unit id="1fd9ebabc73d44769bebe3309979c884ce26c72d" translate="yes" xml:space="preserve">
          <source>Environment variable</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="2633fc9fd8270cc5536df6749eb8eade14cccb45" translate="yes" xml:space="preserve">
          <source>Environment variable substitution will use the same value for each variable throughout the entire instruction. In other words, in this example:</source>
          <target state="translated">환경 변수 대체는 전체 명령어에서 각 변수에 대해 동일한 값을 사용합니다. 즉,이 예에서</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6cc86bda2422be1d2b6e534666c5d5ccb6df68" translate="yes" xml:space="preserve">
          <source>Environment variables (declared with &lt;a href=&quot;#env&quot;&gt;the &lt;code&gt;ENV&lt;/code&gt; statement&lt;/a&gt;) can also be used in certain instructions as variables to be interpreted by the &lt;code&gt;Dockerfile&lt;/code&gt;. Escapes are also handled for including variable-like syntax into a statement literally.</source>
          <target state="translated">(선언 환경 변수 &lt;a href=&quot;#env&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; 의&lt;/a&gt; 문 )도 해석 할 변수로 특정 명령에 사용할 수 있습니다 &lt;code&gt;Dockerfile&lt;/code&gt; . 변수형 구문을 문자 그대로 명령문에 포함시키기 위해 이스케이프도 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d93d5d2fffd283412c0966df71ddf7b43bf1c517" translate="yes" xml:space="preserve">
          <source>Environment variables (optional)</source>
          <target state="translated">환경 변수 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="50f422458c43c16ae69c377dcb83836cc310187a" translate="yes" xml:space="preserve">
          <source>Environment variables (required if using MySQL)</source>
          <target state="translated">환경 변수 (MySQL을 사용하는 경우 필요)</target>
        </trans-unit>
        <trans-unit id="cbe0d5e919b6a128c10d17af4582d0d520c868fd" translate="yes" xml:space="preserve">
          <source>Environment variables and default values</source>
          <target state="translated">환경 변수 및 기본값</target>
        </trans-unit>
        <trans-unit id="cec02bad93bef151c0e9f8f2ad0e696543ac132d" translate="yes" xml:space="preserve">
          <source>Environment variables and default values:</source>
          <target state="translated">환경 변수 및 기본값 :</target>
        </trans-unit>
        <trans-unit id="98c8743e32427484df297dacd0030f32d7f96b74" translate="yes" xml:space="preserve">
          <source>Environment variables are notated in the &lt;code&gt;Dockerfile&lt;/code&gt; either with &lt;code&gt;$variable_name&lt;/code&gt; or &lt;code&gt;${variable_name}&lt;/code&gt;. They are treated equivalently and the brace syntax is typically used to address issues with variable names with no whitespace, like &lt;code&gt;${foo}_bar&lt;/code&gt;.</source>
          <target state="translated">환경 변수는 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 &lt;code&gt;$variable_name&lt;/code&gt; 또는 &lt;code&gt;${variable_name}&lt;/code&gt; 됩니다. 이들은 동등하게 취급되며 중괄호 구문은 일반적으로 &lt;code&gt;${foo}_bar&lt;/code&gt; 와 같이 공백이없는 변수 이름 관련 문제를 해결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7363226e41bca724f2ac6994d0c896add3a42942" translate="yes" xml:space="preserve">
          <source>Environment variables are only populated if you&amp;rsquo;re using the &lt;a href=&quot;../compose-file/index#versioning&quot;&gt;legacy version 1 Compose file format&lt;/a&gt;.</source>
          <target state="translated">환경 변수는 &lt;a href=&quot;../compose-file/index#versioning&quot;&gt;레거시 버전 1 Compose 파일 형식을&lt;/a&gt; 사용하는 경우에만 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="a879855e2250c0dcadb45e02162ad90df764c36f" translate="yes" xml:space="preserve">
          <source>Environment variables are supported by the following list of instructions in the &lt;code&gt;Dockerfile&lt;/code&gt;:</source>
          <target state="translated">환경 변수는 &lt;code&gt;Dockerfile&lt;/code&gt; 의 다음 명령어 목록에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cfc8cf023d2279187be1345aa21369d20be0b00" translate="yes" xml:space="preserve">
          <source>Environment variables created by links</source>
          <target state="translated">링크로 생성 된 환경 변수</target>
        </trans-unit>
        <trans-unit id="1a086129101965a6f5b3b985ba7f2580bc600e7a" translate="yes" xml:space="preserve">
          <source>Environment variables declared in the &lt;a href=&quot;#environment&quot;&gt;environment&lt;/a&gt; section &lt;em&gt;override&lt;/em&gt; these values &amp;ndash; this holds true even if those values are empty or undefined.</source>
          <target state="translated">환경 변수가 선언 &lt;a href=&quot;#environment&quot;&gt;환경&lt;/a&gt; 섹션 &lt;em&gt;재정&lt;/em&gt; 이 값을 -이 그 값이 비어 있거나 정의되지 않은 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0a4aa18ae3a8ba8135d0de809c3beae27f33c740" translate="yes" xml:space="preserve">
          <source>Environment variables defined in the &lt;code&gt;.env&lt;/code&gt; file are not automatically visible inside containers. To set container-applicable environment variables, follow the guidelines in the topic &lt;a href=&quot;../environment-variables/index&quot;&gt;Environment variables in Compose&lt;/a&gt;, which describes how to pass shell environment variables through to containers, define environment variables in Compose files, and more.</source>
          <target state="translated">&lt;code&gt;.env&lt;/code&gt; 파일에 정의 된 환경 변수 는 컨테이너 내부에서 자동으로 표시되지 않습니다. 컨테이너 적용 가능 환경 변수를 설정하려면 &lt;a href=&quot;../environment-variables/index&quot;&gt;작성 환경 변수&lt;/a&gt; 주제의 지침을 따르십시오. 여기에는 쉘 환경 변수를 컨테이너로 전달하고 작성 파일에서 환경 변수를 정의하는 방법 등이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1b7aa23246ecaa27a33e76f42622a81113062fa" translate="yes" xml:space="preserve">
          <source>Environment variables in Compose</source>
          <target state="translated">작성의 환경 변수</target>
        </trans-unit>
        <trans-unit id="bafb6ea2b5f7c40cbf95f1202a73ba2c834e8f7f" translate="yes" xml:space="preserve">
          <source>Environment variables specified in &lt;a href=&quot;#environment&quot;&gt;environment&lt;/a&gt;&lt;em&gt;override&lt;/em&gt; these values.</source>
          <target state="translated">에 지정된 환경 변수 &lt;a href=&quot;#environment&quot;&gt;환경이 &lt;/a&gt;&lt;em&gt;우선&lt;/em&gt; 이 값을.</target>
        </trans-unit>
        <trans-unit id="18e8d17988a2b3356c73297e5900d60db7c71b85" translate="yes" xml:space="preserve">
          <source>Environment variables with only a key are resolved to their values on the machine Compose is running on, which can be helpful for secret or host-specific values.</source>
          <target state="translated">키만있는 환경 변수는 Compose가 실행중인 시스템의 해당 값으로 해석되므로 비밀 또는 호스트 별 값에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="203b28516ac07f6fafa23caa84894494350505ec" translate="yes" xml:space="preserve">
          <source>Environment variables.</source>
          <target state="translated">환경 변수.</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="b7f3c6993982d24c6c080b5c9817e705a665831d" translate="yes" xml:space="preserve">
          <source>Err</source>
          <target state="translated">Err</target>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="2cfd83f7d33121ed8f0aa5f45b0405b08231a306" translate="yes" xml:space="preserve">
          <source>Error condition: cannot copy a directory to a file</source>
          <target state="translated">오류 조건 : 디렉토리를 파일로 복사 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="088340cdc2e4a3c29613256618dcf783f03fdc51" translate="yes" xml:space="preserve">
          <source>Error condition: the destination directory must exist.</source>
          <target state="translated">오류 조건 : 대상 디렉토리가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c7b46b8fc0793e0698c3959386bb12272df7e26" translate="yes" xml:space="preserve">
          <source>Error from plugins</source>
          <target state="translated">플러그인 오류</target>
        </trans-unit>
        <trans-unit id="a2448e42d079ba159017705ad66afbca205bd1de" translate="yes" xml:space="preserve">
          <source>Error message (will be returned to the client in case the plugin encounter an error. The string value supplied may appear in logs, so should not include confidential information)</source>
          <target state="translated">오류 메시지 (플러그인에 오류가 발생하면 클라이언트에 반환됩니다. 제공된 문자열 값이 로그에 나타날 수 있으므로 기밀 정보를 포함하지 않아야합니다)</target>
        </trans-unit>
        <trans-unit id="e76a5333a10bc19db1ec4744208c436dd13e1195" translate="yes" xml:space="preserve">
          <source>Escaping is possible by adding a &lt;code&gt;\&lt;/code&gt; before the variable: &lt;code&gt;\$foo&lt;/code&gt; or &lt;code&gt;\${foo}&lt;/code&gt;, for example, will translate to &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;${foo}&lt;/code&gt; literals respectively.</source>
          <target state="translated">이스케이프는 &lt;code&gt;\$foo&lt;/code&gt; 또는 &lt;code&gt;\${foo}&lt;/code&gt; 변수 앞에 &lt;code&gt;\&lt;/code&gt; 를 추가하여 가능 합니다. 예를 들어 &lt;code&gt;$foo&lt;/code&gt; 와 &lt;code&gt;${foo}&lt;/code&gt; 리터럴로 각각 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b3c06778e0c2c2862df06d5bfc9860dfff53283" translate="yes" xml:space="preserve">
          <source>Establish leases on arbitrary files (see fcntl(2)).</source>
          <target state="translated">임의의 파일에 임대를 설정하십시오 (fcntl (2) 참조).</target>
        </trans-unit>
        <trans-unit id="f5cd08a796c40eee9db51e74c952a41e938009fe" translate="yes" xml:space="preserve">
          <source>Even if a swarm loses the quorum of managers, swarm tasks on existing worker nodes continue to run. However, swarm nodes cannot be added, updated, or removed, and new or existing tasks cannot be started, stopped, moved, or updated.</source>
          <target state="translated">떼가 관리자 쿼럼을 잃어도 기존 작업자 노드의 떼 떼 작업은 계속 실행됩니다. 그러나 스웜 노드는 추가, 업데이트 또는 제거 할 수 없으며 새 작업이나 기존 작업을 시작, 중지, 이동 또는 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2761c876d57866f158edbdc9b1dbd8daadc82089" translate="yes" xml:space="preserve">
          <source>Even though the MySQL service has access to both the old and new secrets now, the MySQL password for the WordPress user has not yet been changed.</source>
          <target state="translated">MySQL 서비스가 이전 및 새 비밀에 모두 액세스 할 수 있지만 WordPress 사용자의 MySQL 비밀번호는 아직 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cef284c9e16d89ac74d0473dcc0be44064fca38e" translate="yes" xml:space="preserve">
          <source>Even though the service no longer exists, the task containers take a few seconds to clean up. You can use &lt;code&gt;docker ps&lt;/code&gt; on the nodes to verify when the tasks have been removed.</source>
          <target state="translated">서비스가 더 이상 존재하지 않아도 작업 컨테이너를 정리하는 데 몇 초가 걸립니다. 노드에서 &lt;code&gt;docker ps&lt;/code&gt; 를 사용 하여 작업이 제거 된시기를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10b3e860d1ad6efd6c00f519fdd4ef72be63f023" translate="yes" xml:space="preserve">
          <source>Even though there is no plan to deprecate &lt;code&gt;--volume&lt;/code&gt;, usage of &lt;code&gt;--mount&lt;/code&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;--volume&lt;/code&gt; 을 폐기 할 계획은 없지만 &lt;code&gt;--mount&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="c071e354e38bffd4802a52115ca5ff6db771af2b" translate="yes" xml:space="preserve">
          <source>Example (parsed representation is displayed after the &lt;code&gt;#&lt;/code&gt;):</source>
          <target state="translated">예 (구문 분석 된 표현은 &lt;code&gt;#&lt;/code&gt; 뒤에 표시됨 ) :</target>
        </trans-unit>
        <trans-unit id="6ceeb4c4e97d57377e75337a4b59245541e569bd" translate="yes" xml:space="preserve">
          <source>Example Compose file version 3</source>
          <target state="translated">작성 파일 버전 3의 예</target>
        </trans-unit>
        <trans-unit id="bc1515e6fa46ada277f22dc81464579676446a91" translate="yes" xml:space="preserve">
          <source>Example Config</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139f4b6a4052f9708c21edba14f3122a3d5c4d92" translate="yes" xml:space="preserve">
          <source>Example client-server-signer interaction</source>
          <target state="translated">클라이언트-서버-서명자 상호 작용의 예</target>
        </trans-unit>
        <trans-unit id="338ed17778e90e709bd066617a2cacbed222a9f3" translate="yes" xml:space="preserve">
          <source>Example create:</source>
          <target state="translated">작성 예 :</target>
        </trans-unit>
        <trans-unit id="ee8284b11d76d24a002d6a868d6126c02b388c3f" translate="yes" xml:space="preserve">
          <source>Example gMSA configuration</source>
          <target state="translated">gMSA 구성 예</target>
        </trans-unit>
        <trans-unit id="ec1136270e452edec85ece96cdcd819465f02495" translate="yes" xml:space="preserve">
          <source>Example of usage:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">출력 예 :</target>
        </trans-unit>
        <trans-unit id="db20e067f795bbd6b56b86e35b7ce062f901b50e" translate="yes" xml:space="preserve">
          <source>Example running a Redis container with Redis binding to &lt;code&gt;localhost&lt;/code&gt; then running the &lt;code&gt;redis-cli&lt;/code&gt; command and connecting to the Redis server over the &lt;code&gt;localhost&lt;/code&gt; interface.</source>
          <target state="translated">Redis가 &lt;code&gt;localhost&lt;/code&gt; 에 바인딩 된 Redis 컨테이너 를 실행 한 다음 &lt;code&gt;redis-cli&lt;/code&gt; 명령 을 실행 하고 &lt;code&gt;localhost&lt;/code&gt; 인터페이스를 통해 Redis 서버에 연결하는 예제 .</target>
        </trans-unit>
        <trans-unit id="6168f7c7ad028811fb0ce4a03682a3e3592e0e04" translate="yes" xml:space="preserve">
          <source>Example script for a separate &amp;ldquo;bootstrap&amp;rdquo; instance of the Docker daemon without network:</source>
          <target state="translated">네트워크가없는 Docker 데몬의 별도의 &quot;부트 스트랩&quot;인스턴스에 대한 예제 스크립트 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="1de832bb703ac987e5fa7e3d02c956d7deaa09b3" translate="yes" xml:space="preserve">
          <source>Example use case</source>
          <target state="translated">사용 사례 예</target>
        </trans-unit>
        <trans-unit id="f926e8aa381c9473da8ffa66ceaa3620c768d1fd" translate="yes" xml:space="preserve">
          <source>Example value</source>
          <target state="translated">예제 값</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="664362fa57340d48ec0da855b0665ff34e077389" translate="yes" xml:space="preserve">
          <source>Example: Provision Dockerized &lt;a href=&quot;../examples/aws/index&quot;&gt;AWS EC2 Instances&lt;/a&gt;</source>
          <target state="translated">예 :도 커화 된 &lt;a href=&quot;../examples/aws/index&quot;&gt;AWS EC2 인스턴스&lt;/a&gt; 프로비저닝</target>
        </trans-unit>
        <trans-unit id="bdce96b6b9386dec00c034ce9e9a7d2cbda1e7cf" translate="yes" xml:space="preserve">
          <source>Example: Provision Dockerized &lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean Droplets&lt;/a&gt;</source>
          <target state="translated">예 : Dockerized &lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean Droplets&lt;/a&gt; 프로비저닝</target>
        </trans-unit>
        <trans-unit id="71d90aece061cf2e5c39c514d9cfeff63fe2af8a" translate="yes" xml:space="preserve">
          <source>Example: Rotate a config</source>
          <target state="translated">예 : 구성 회전</target>
        </trans-unit>
        <trans-unit id="1ed7ee8b68f0da1a14f5a46fa471b5aad664d698" translate="yes" xml:space="preserve">
          <source>Example: Rotate a secret</source>
          <target state="translated">예 : 비밀 회전</target>
        </trans-unit>
        <trans-unit id="d21676198100926724dfe34ab94f7da07f9cd3d6" translate="yes" xml:space="preserve">
          <source>Example: Run a three-task Nginx service on 10-node swarm</source>
          <target state="translated">예 : 10 노드 떼에서 3 가지 작업 Nginx 서비스 실행</target>
        </trans-unit>
        <trans-unit id="4c10f3fbce5993c9b2e736544f3d5572f04c59f1" translate="yes" xml:space="preserve">
          <source>Example: Run an &lt;code&gt;nginx&lt;/code&gt; web server service on every swarm node</source>
          <target state="translated">예 : 모든 스웜 노드에서 &lt;code&gt;nginx&lt;/code&gt; 웹 서버 서비스 실행</target>
        </trans-unit>
        <trans-unit id="5f79bdee5c02bb8cdebac3f70f4ae8e095295adb" translate="yes" xml:space="preserve">
          <source>Example: run htop inside a container</source>
          <target state="translated">예 : 컨테이너 내부에서 호프 실행</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f97f83622db711aab2f971320864edd01da3ec1d" translate="yes" xml:space="preserve">
          <source>Exclude files and directories in the root directory whose names are a one-character extension of &lt;code&gt;temp&lt;/code&gt;. For example, &lt;code&gt;/tempa&lt;/code&gt; and &lt;code&gt;/tempb&lt;/code&gt; are excluded.</source>
          <target state="translated">이름이 &lt;code&gt;temp&lt;/code&gt; 의 한 문자 확장자 인 루트 디렉토리에서 파일 및 디렉토리를 제외하십시오 . 예를 들어, &lt;code&gt;/tempa&lt;/code&gt; 및 &lt;code&gt;/tempb&lt;/code&gt; 는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f7032f8f2adb5d72efd818375c7be71d02dd4d18" translate="yes" xml:space="preserve">
          <source>Exclude files and directories starting with &lt;code&gt;temp&lt;/code&gt; from any subdirectory that is two levels below the root. For example, &lt;code&gt;/somedir/subdir/temporary.txt&lt;/code&gt; is excluded.</source>
          <target state="translated">루트 아래 두 레벨에있는 서브 디렉토리에서 &lt;code&gt;temp&lt;/code&gt; 로 시작하는 파일 및 디렉토리를 제외하십시오 . 예를 들어, &lt;code&gt;/somedir/subdir/temporary.txt&lt;/code&gt; 는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="48b4ef53636d589b01b9eaacfada2d4b7b355498" translate="yes" xml:space="preserve">
          <source>Exclude files and directories whose names start with &lt;code&gt;temp&lt;/code&gt; in any immediate subdirectory of the root. For example, the plain file &lt;code&gt;/somedir/temporary.txt&lt;/code&gt; is excluded, as is the directory &lt;code&gt;/somedir/temp&lt;/code&gt;.</source>
          <target state="translated">루트의 직계 서브 디렉토리에서 이름이 &lt;code&gt;temp&lt;/code&gt; 로 시작하는 파일 및 디렉토리를 제외하십시오 . 예를 들어, &lt;code&gt;/somedir/temp&lt;/code&gt; 디렉토리와 같이 일반 파일 &lt;code&gt;/somedir/temporary.txt&lt;/code&gt; 는 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="db6e820f9a9836d70cab544f31abf0e3b7bcd72c" translate="yes" xml:space="preserve">
          <source>Excluding the created machine from proxies</source>
          <target state="translated">프록시에서 생성 된 머신 제외</target>
        </trans-unit>
        <trans-unit id="447072a385a9153c3aabef979557e86e963d1dae" translate="yes" xml:space="preserve">
          <source>Exec form ENTRYPOINT example</source>
          <target state="translated">ENTRYPOINT 예제 실행</target>
        </trans-unit>
        <trans-unit id="9da9fb624d36bd73b6e426d60c0bcd634b3f007f" translate="yes" xml:space="preserve">
          <source>Exec into the running container.</source>
          <target state="translated">실행중인 컨테이너로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6f147bbcdc2ea57f6c81bec669ec536b253dc54b" translate="yes" xml:space="preserve">
          <source>Exit Status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352bcb04af63aaef9b26863916e01fa35f9e3cea" translate="yes" xml:space="preserve">
          <source>Exit immediately instead of waiting for the root rotation to converge</source>
          <target state="translated">루트 회전이 수렴되기를 기다리지 않고 즉시 종료</target>
        </trans-unit>
        <trans-unit id="627ec4c7ad09baf49d325f7ddbdfdf249ad127bf" translate="yes" xml:space="preserve">
          <source>Exit immediately instead of waiting for the service to converge</source>
          <target state="translated">서비스가 수렴되기를 기다리는 대신 즉시 종료</target>
        </trans-unit>
        <trans-unit id="4f367efe0739c603d5fcf7f5b4be3a2504347102" translate="yes" xml:space="preserve">
          <source>Exoscale</source>
          <target state="translated">Exoscale</target>
        </trans-unit>
        <trans-unit id="586f8b18954c3f69d4bde8087ca20d84933e6460" translate="yes" xml:space="preserve">
          <source>Experimental features are now included in the standard Docker binaries as of version 1.13.0. For enabling experimental features, you need to start the Docker daemon with &lt;code&gt;--experimental&lt;/code&gt; flag. You can also enable the daemon flag via /etc/docker/daemon.json. e.g.</source>
          <target state="translated">실험 기능은 이제 버전 1.13.0부터 표준 Docker 바이너리에 포함됩니다. 실험 기능을 사용하려면 &lt;code&gt;--experimental&lt;/code&gt; 플래그를 사용 하여 Docker 데몬을 시작해야합니다 . /etc/docker/daemon.json을 통해 데몬 플래그를 활성화 할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="881daf02462f851103387305cf576374cd0143a0" translate="yes" xml:space="preserve">
          <source>Experimental features provide early access to future product functionality. These features are intended for testing and feedback only as they may change between releases without warning or can be removed entirely from a future release. Experimental features must not be used in production environments. Docker does not offer support for experimental features. For more information, see &lt;a href=&quot;https://success.docker.com/article/experimental-features&quot;&gt;Experimental features&lt;/a&gt;.</source>
          <target state="translated">실험적인 기능은 향후 제품 기능에 대한 조기 액세스를 제공합니다. 이 기능은 경고없이 릴리스간에 변경되거나 향후 릴리스에서 완전히 제거 될 수 있으므로 테스트 및 피드백을위한 것입니다. 프로덕션 환경에서는 실험적인 기능을 사용해서는 안됩니다. Docker는 실험 기능을 지원하지 않습니다. 자세한 내용은 &lt;a href=&quot;https://success.docker.com/article/experimental-features&quot;&gt;실험 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37233e9e2203edceb13c353b8dc5beadafa61b7f" translate="yes" xml:space="preserve">
          <source>Experimental mode can be enabled by using the &lt;code&gt;--experimental&lt;/code&gt; flag when starting the Docker daemon or setting &lt;code&gt;experimental: true&lt;/code&gt; in the &lt;code&gt;daemon.json&lt;/code&gt; configuration file.</source>
          <target state="translated">Docker 데몬을 시작할 때 &lt;code&gt;--experimental&lt;/code&gt; 플래그 를 사용 하거나 &lt;code&gt;daemon.json&lt;/code&gt; 구성 파일 에서 &lt;code&gt;experimental: true&lt;/code&gt; 를 설정 하여 실험 모드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f2118aa77bf9068468b97641408509e2b04dff0" translate="yes" xml:space="preserve">
          <source>Explore swarm mode CLI commands</source>
          <target state="translated">스웜 모드 CLI 명령 탐색</target>
        </trans-unit>
        <trans-unit id="832780f2db43b4e090fc20f00f93f0282825d56e" translate="yes" xml:space="preserve">
          <source>Explore the full list of Compose commands</source>
          <target state="translated">작성 명령의 전체 목록 탐색</target>
        </trans-unit>
        <trans-unit id="cba3ce3d0b8ccd99428ac4035ee99da16a827628" translate="yes" xml:space="preserve">
          <source>Export a container&amp;rsquo;s filesystem as a tar archive</source>
          <target state="translated">컨테이너의 파일 시스템을 tar 아카이브로 내보내기</target>
        </trans-unit>
        <trans-unit id="981f20848eaf7b8bce28d9d707538d4d3e42962e" translate="yes" xml:space="preserve">
          <source>Export a context to a tar or kubeconfig file</source>
          <target state="translated">컨텍스트를 tar 또는 kubeconfig 파일로 내보내기</target>
        </trans-unit>
        <trans-unit id="db1a9e6cf20056bdb2c6daaf1f6612266bb04f61" translate="yes" xml:space="preserve">
          <source>Export as a kubeconfig file</source>
          <target state="translated">kubeconfig 파일로 내보내기</target>
        </trans-unit>
        <trans-unit id="3364bb95aa5e8866b190dab6e92407bc2e3e5135" translate="yes" xml:space="preserve">
          <source>Exports a context in a file that can then be used with &lt;code&gt;docker context import&lt;/code&gt; (or with &lt;code&gt;kubectl&lt;/code&gt; if &lt;code&gt;--kubeconfig&lt;/code&gt; is set). Default output filename is &lt;code&gt;&amp;lt;CONTEXT&amp;gt;.dockercontext&lt;/code&gt;, or &lt;code&gt;&amp;lt;CONTEXT&amp;gt;.kubeconfig&lt;/code&gt; if &lt;code&gt;--kubeconfig&lt;/code&gt; is set. To export to &lt;code&gt;STDOUT&lt;/code&gt;, you can run &lt;code&gt;docker context export my-context -&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker context import&lt;/code&gt; (또는 &lt;code&gt;--kubeconfig&lt;/code&gt; 가 설정된 경우 kubectl ) 와 함께 사용할 수있는 컨텍스트를 파일 로 내 &lt;code&gt;kubectl&lt;/code&gt; . 기본 출력 파일 이름은 &lt;code&gt;&amp;lt;CONTEXT&amp;gt;.dockercontext&lt;/code&gt; 또는 &lt;code&gt;--kubeconfig&lt;/code&gt; 가 설정된 경우 &lt;code&gt;&amp;lt;CONTEXT&amp;gt;.kubeconfig&lt;/code&gt; 입니다. &lt;code&gt;STDOUT&lt;/code&gt; 으로 내보내려면 &lt;code&gt;docker context export my-context -&lt;/code&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6851d6895d0099c40915873297c67ea84b9cab59" translate="yes" xml:space="preserve">
          <source>Expose a port or a range of ports</source>
          <target state="translated">포트 또는 포트 범위 노출</target>
        </trans-unit>
        <trans-unit id="10cc55b4e5a8d47bdbcdbe70d599e97ab931b718" translate="yes" xml:space="preserve">
          <source>Expose ports without publishing them to the host machine - they&amp;rsquo;ll only be accessible to linked services. Only the internal port can be specified.</source>
          <target state="translated">호스트 컴퓨터에 포트를 게시하지 않고 포트를 노출합니다. 링크 된 서비스에만 액세스 할 수 있습니다. 내부 포트만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e767ce644c04911f18c98b70d31d374b9eb56cd3" translate="yes" xml:space="preserve">
          <source>Expose ports.</source>
          <target state="translated">포트를 노출하십시오.</target>
        </trans-unit>
        <trans-unit id="1619f9c5566c78e1d11c4ff900380478003ac635" translate="yes" xml:space="preserve">
          <source>Expose ports. Either specify both ports (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or just the container port (an ephemeral host port is chosen).</source>
          <target state="translated">포트를 노출하십시오. 두 포트 ( &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ) 또는 컨테이너 포트만 지정하십시오 (일시적인 호스트 포트가 선택됨).</target>
        </trans-unit>
        <trans-unit id="1fbc71f7387278269f1d957e28390616407593f9" translate="yes" xml:space="preserve">
          <source>Exposed port number, such as &lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt;</source>
          <target state="translated">노출 된 포트 번호 (예 : &lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d62bff054d1ae4b7900a38f3e9ee0b3444fd521c" translate="yes" xml:space="preserve">
          <source>Exposed ports.</source>
          <target state="translated">노출 된 포트.</target>
        </trans-unit>
        <trans-unit id="3105862e09650234250b61444f5ddb0b9b8b7c98" translate="yes" xml:space="preserve">
          <source>Exposes WordPress on port 30000 of the host machine, so that you can access it from external hosts. You can expose port 80 instead if you do not have a web server running on port 80 of the host machine.</source>
          <target state="translated">외부 호스트에서 액세스 할 수 있도록 호스트 시스템의 포트 30000에 WordPress를 표시합니다. 호스트 시스템의 포트 80에서 웹 서버를 실행하지 않는 경우 포트 80을 대신 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c7c7ba02689bdfe8fac698936944594767c963" translate="yes" xml:space="preserve">
          <source>Express dependency between services, Service dependencies cause the following behaviors:</source>
          <target state="translated">서비스 간 Express 종속성, 서비스 종속성은 다음과 같은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="68a134f7e49c8860c88eb0b67bcd14cb443270ec" translate="yes" xml:space="preserve">
          <source>Express dependency between services, which has two effects:</source>
          <target state="translated">서비스 간 특급 종속성. 두 가지 영향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64ffe047868ebb24ac6b257af5f051e7f6caf40" translate="yes" xml:space="preserve">
          <source>Extend another service, in the current file or another, optionally overriding configuration.</source>
          <target state="translated">현재 파일 또는 다른 선택적으로 구성을 대체하는 다른 서비스를 확장하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
