<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="1df3ba93d2676b08b400f1a692d58c61031a8ae6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disabled By Default In Release: v17.06&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 기본적으로 비활성화 됨 : v17.06&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc50f03a241bb4db5d29e7a9a5f1bfd1463812b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disabled In Release: v17.12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 비활성화 됨 : v17.12&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="992261d9248a0d70eb9ceb2c35fb772eab5fee9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disabled by default in release: &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.10.0-ce&quot;&gt;v17.10&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서는 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.10.0-ce&quot;&gt;v17.10&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98a979a2b32e82857eeb31ebe8c2b6970a9f0454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker 17.05 and earlier&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Docker 17.05 이하&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4c0cc03947ee68c0d0e3f4ba850cf231c16157a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker 17.06 and higher&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;도커 17.06 이상&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c221df0ba77c278b817ce9030f36ae9b643009dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Desktop for Mac&lt;/strong&gt; - You can use &lt;code&gt;docker-machine create&lt;/code&gt; with the &lt;code&gt;virtualbox&lt;/code&gt; driver to create additional local machines.</source>
          <target state="translated">&lt;strong&gt;Mac 용 고정 표시기 데스크톱&lt;/strong&gt; - 당신이 사용할 수있는 &lt;code&gt;docker-machine create&lt;/code&gt; 와 &lt;code&gt;virtualbox&lt;/code&gt; 추가 로컬 시스템을 만들 드라이버.</target>
        </trans-unit>
        <trans-unit id="b4d454d395aca4e5f2ed8fe3362c95e4cb424462" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Desktop for Mac&lt;/strong&gt; and &lt;strong&gt;Docker Toolbox&lt;/strong&gt; already include Compose along with other Docker apps, so Mac users do not need to install Compose separately. Docker install instructions for these are here:</source>
          <target state="translated">&lt;strong&gt;Mac 용 Docker Desktop&lt;/strong&gt; 및 &lt;strong&gt;Docker Toolbox&lt;/strong&gt; 에는 다른 Docker 앱과 함께 Compose가 이미 포함되어 있으므로 Mac 사용자는 Compose를 별도로 설치할 필요가 없습니다. 이에 대한 Docker 설치 지침은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1a3516abcc267a12449e59afce49cab6c76b00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Desktop for Windows&lt;/strong&gt; - You can use &lt;code&gt;docker-machine create&lt;/code&gt; with the &lt;code&gt;hyperv&lt;/code&gt; driver to create additional local machines.</source>
          <target state="translated">&lt;strong&gt;Windows 용 고정 표시기 데스크톱&lt;/strong&gt; - 당신이 사용할 수있는 &lt;code&gt;docker-machine create&lt;/code&gt; 와 &lt;code&gt;hyperv&lt;/code&gt; 추가 로컬 시스템을 만들 드라이버.</target>
        </trans-unit>
        <trans-unit id="24ecd6d649c46efdc4873b77f38fc9615b4e5b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Desktop for Windows&lt;/strong&gt; and &lt;strong&gt;Docker Toolbox&lt;/strong&gt; already include Compose along with other Docker apps, so most Windows users do not need to install Compose separately. Docker install instructions for these are here:</source>
          <target state="translated">&lt;strong&gt;Windows 용 Docker Desktop&lt;/strong&gt; 및 &lt;strong&gt;Docker Toolbox&lt;/strong&gt; 에는 다른 Docker 앱과 함께 Compose가 이미 포함되어 있으므로 대부분의 Windows 사용자는 Compose를 별도로 설치할 필요가 없습니다. 이에 대한 Docker 설치 지침은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d582f798b9c2ef75ddf0786397ebf6898aa29d8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Engine release&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;도커 엔진 출시&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9ff657fd2db4a9561ed1c62a1a21706c4d80d07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docker Machine&lt;/strong&gt; is a tool for provisioning and managing your Dockerized hosts (hosts with Docker Engine on them). Typically, you install Docker Machine on your local system. Docker Machine has its own command line client &lt;code&gt;docker-machine&lt;/code&gt; and the Docker Engine client, &lt;code&gt;docker&lt;/code&gt;. You can use Machine to install Docker Engine on one or more virtual systems. These virtual systems can be local (as when you use Machine to install and run Docker Engine in VirtualBox on Mac or Windows) or remote (as when you use Machine to provision Dockerized hosts on cloud providers). The Dockerized hosts themselves can be thought of, and are sometimes referred to as, managed &amp;ldquo;&lt;strong&gt;&lt;em&gt;machines&lt;/em&gt;&lt;/strong&gt;&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;Docker Machine&lt;/strong&gt; 은 Dockerized 호스트 (Docker Engine이있는 호스트)를 프로비저닝하고 관리하기위한 도구입니다. 일반적으로 로컬 시스템에 Docker Machine을 설치합니다. Docker Machine에는 자체 명령 줄 클라이언트 &lt;code&gt;docker-machine&lt;/code&gt; 및 Docker Engine 클라이언트 인 &lt;code&gt;docker&lt;/code&gt; 가 있습니다. Machine을 사용하여 하나 이상의 가상 시스템에 Docker Engine을 설치할 수 있습니다. 이러한 가상 시스템은 로컬 (기계를 사용하여 Mac 또는 Windows의 VirtualBox에서 Docker Engine을 설치 및 실행할 때) 또는 원격 (기계를 사용하여 클라우드 제공자에 Dockerized 호스트를 프로비저닝 할 때) 일 수 있습니다. Dockerized 호스트 자체는 관리되는 &quot; &lt;strong&gt;&lt;em&gt;컴퓨터&lt;/em&gt;&lt;/strong&gt; &quot; 라고 생각할 수 있으며 때로는 &quot; &lt;strong&gt;&lt;em&gt;기계&lt;/em&gt;&lt;/strong&gt; &quot; 라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="45ce684e0681f9bee310885446fa2bafe3038204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Each container also gets its own network stack&lt;/strong&gt;, meaning that a container doesn&amp;rsquo;t get privileged access to the sockets or interfaces of another container. Of course, if the host system is setup accordingly, containers can interact with each other through their respective network interfaces &amp;mdash; just like they can interact with external hosts. When you specify public ports for your containers or use &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;links&lt;/em&gt;&lt;/a&gt; then IP traffic is allowed between containers. They can ping each other, send/receive UDP packets, and establish TCP connections, but that can be restricted if necessary. From a network architecture point of view, all containers on a given Docker host are sitting on bridge interfaces. This means that they are just like physical machines connected through a common Ethernet switch; no more, no less.</source>
          <target state="translated">&lt;strong&gt;각 컨테이너는 또한 자체 네트워크 스택을 얻습니다.&lt;/strong&gt; 즉, 컨테이너는 다른 컨테이너의 소켓이나 인터페이스에 대한 액세스 권한을 갖지 않습니다. 물론 호스트 시스템을 적절히 설정하면 컨테이너는 외부 호스트와 상호 작용할 수있는 것처럼 해당 네트워크 인터페이스를 통해 서로 상호 작용할 수 있습니다. 컨테이너의 공용 포트를 지정하거나 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;링크&lt;/em&gt;&lt;/a&gt; 를 사용하면 컨테이너간에 IP 트래픽이 허용됩니다. 서로 핑하고 UDP 패킷을 송수신하며 TCP 연결을 설정할 수 있지만 필요한 경우 제한 될 수 있습니다. 네트워크 아키텍처 관점에서, 주어진 Docker 호스트의 모든 컨테이너는 브리지 인터페이스에 있습니다. 이는 공통 이더넷 스위치를 통해 연결된 물리적 시스템과 같습니다. 그 이상도 이하도 아닌.</target>
        </trans-unit>
        <trans-unit id="9321defb5f93ef3ffb6e93d77f966336cd8d8999" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expose a port&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;포트 노출&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="532e62419bc06b864339a03e6926ecd6ba93ac61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Files are actually being stored on the machine, &lt;em&gt;not&lt;/em&gt; on the host.&lt;/strong&gt; So make sure to make a copy of any files you want to keep, before removing it!</source>
          <target state="translated">&lt;strong&gt;파일은 실제로 호스트가 &lt;em&gt;아닌&lt;/em&gt; 컴퓨터에 저장됩니다 . &lt;/strong&gt;따라서 보관하려는 파일을 제거하기 전에 복사본을 만들어야합니다!</target>
        </trans-unit>
        <trans-unit id="8d5745d66878e56e23a3f4d09708237f9f5f9359" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Formatting details:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서식 세부 정보 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2067d16d0ad3faebc92cac0ead240338deb24516" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Get a machine&amp;rsquo;s IP address:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;머신의 IP 주소를 얻습니다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="599925f2d7859bef5d3ec51e9d67434087b304da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I have an older desktop system and want to run Docker on Mac or Windows&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구형 데스크탑 시스템이 있고 Mac 또는 Windows에서 Docker를 실행하고 싶습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85548f338f9800291c56266baf5557f553149ad8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want to provision Docker hosts on remote systems&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;원격 시스템에서 Docker 호스트를 프로비저닝하고 싶습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00bb35297248c13a608b055f5394856982af505b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you don&amp;rsquo;t like sudo&lt;/strong&gt; then see &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#giving-non-root-access&quot;&gt;&lt;em&gt;Giving non-root access&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;sudo가 마음에 들지 않으면 &lt;/strong&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#giving-non-root-access&quot;&gt;&lt;em&gt;루트가 아닌 액세스 권한 부여&lt;/em&gt;&lt;/a&gt; 를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a48a2b70d8ba3e3b69d1586ca1338a3c9d24ae56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you don&amp;rsquo;t like sudo&lt;/strong&gt; then see &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#giving-non-root-access&quot;&gt;&lt;em&gt;Giving non-root access&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;sudo가 마음에 들지 않으면 &lt;/strong&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#giving-non-root-access&quot;&gt;&lt;em&gt;루트가 아닌 액세스 권한 부여&lt;/em&gt;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="134d8740912c52e1ff7ba98934460af06a9bbdda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re using macOS or docker via TCP&lt;/strong&gt; then you shouldn&amp;rsquo;t use sudo.</source>
          <target state="translated">&lt;strong&gt;TCP&lt;/strong&gt; 를 &lt;strong&gt;통해 macOS 또는 docker를&lt;/strong&gt; 사용하는 경우 sudo를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e9da3266741dbe46b85911891757ceeba9446a5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important Note&lt;/strong&gt;: Adding more managers does NOT mean increased scalability or higher performance. In general, the opposite is true.</source>
          <target state="translated">&lt;strong&gt;중요 참고&lt;/strong&gt; : 관리자를 더 추가한다고해서 확장 성이 향상되거나 성능이 향상되는 것은 아닙니다. 일반적으로 그 반대입니다.</target>
        </trans-unit>
        <trans-unit id="0a7d6d7c1ba8b9e93aba6b9d151bde74d307543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: Bind mounts can be useful but they can also cause problems. In most cases, it is recommended that you architect your application such that mounting paths from the host is unnecessary. The main risks include the following:</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; : 바인드 마운트는 유용 할 수 있지만 문제를 일으킬 수도 있습니다. 대부분의 경우 호스트에서 마운트 경로가 필요하지 않도록 응용 프로그램을 설계하는 것이 좋습니다. 주요 위험은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e31016881275111e4fe796eaf0d9a37a9394f36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: Setting a node to &lt;code&gt;DRAIN&lt;/code&gt; does not remove standalone containers from that node, such as those created with &lt;code&gt;docker run&lt;/code&gt;, &lt;code&gt;docker-compose up&lt;/code&gt;, or the Docker Engine API. A node&amp;rsquo;s status, including &lt;code&gt;DRAIN&lt;/code&gt;, only affects the node&amp;rsquo;s ability to schedule swarm service workloads.</source>
          <target state="translated">&lt;strong&gt;중요 사항&lt;/strong&gt; : 노드를 &lt;code&gt;DRAIN&lt;/code&gt; 으로 설정해도 &lt;code&gt;docker run&lt;/code&gt; , &lt;code&gt;docker-compose up&lt;/code&gt; 또는 Docker Engine API로 작성된 컨테이너와 같은 독립형 컨테이너는 해당 노드에서 제거되지 않습니다 . &lt;code&gt;DRAIN&lt;/code&gt; 을 포함한 노드의 상태는 스웜 서비스 작업을 예약하는 노드의 기능에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b4c26f7397a39cb026e859cfe979b9327b327c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: The &lt;code&gt;.env file&lt;/code&gt; feature only works when you use the &lt;code&gt;docker-compose up&lt;/code&gt; command and does not work with &lt;code&gt;docker stack deploy&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;중요 사항&lt;/strong&gt; : &lt;code&gt;.env file&lt;/code&gt; 기능은 &lt;code&gt;docker-compose up&lt;/code&gt; 명령 을 사용하는 경우에만 작동 하며 &lt;code&gt;docker stack deploy&lt;/code&gt; 에서는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="57623dd41f597fb471c7d22578171476cc6ae413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In v2.1+, overlay networks are always &lt;code&gt;attachable&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;v2.1 이상에서는 오버레이 네트워크를 항상 &lt;code&gt;attachable&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55286279721fccbe21632df141f118ee6d7cd9a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSON formatting&lt;/strong&gt;: The list is parsed as a JSON array. You must enclose words with double quotes (&lt;code&gt;&quot;&lt;/code&gt;) rather than single quotes (&lt;code&gt;'&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;JSON 형식&lt;/strong&gt; : 목록이 JSON 배열로 구문 분석됩니다. 당신은 큰 따옴표 (와 단어로 묶어야합니다 &lt;code&gt;&quot;&lt;/code&gt; )보다는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ae154aad8c43c4b4749dc4528db65414b2799027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;KNOWN ISSUE:&lt;/strong&gt; There is a known issue with Azure Active Directory causing stored credentials to expire within hours rather than 14 days when the user logs in with personal Microsoft Account (formerly &lt;em&gt;Live ID&lt;/em&gt;) instead of an Active Directory account. Currently, there is no ETA for resolution, however in the meanwhile you can &lt;a href=&quot;https://azure.microsoft.com/documentation/articles/virtual-machines-windows-create-aad-work-id/&quot;&gt;create an AAD account&lt;/a&gt; and login with that as a workaround.</source>
          <target state="translated">&lt;strong&gt;알려진 문제 :&lt;/strong&gt; 사용자 가 Active Directory 계정 대신 개인 Microsoft 계정 (이전의 &lt;em&gt;Live ID&lt;/em&gt; )으로 로그인하면 14 일이 아닌 몇 시간 내에 저장된 자격 증명이 만료되는 Azure Active Directory의 알려진 문제가 있습니다. 현재 해결을위한 ETA는 없지만 &lt;a href=&quot;https://azure.microsoft.com/documentation/articles/virtual-machines-windows-create-aad-work-id/&quot;&gt;AAD 계정을 생성&lt;/a&gt; 하고 해결 방법으로 로그인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="700c937dc637f70d0cdd61900fb2c2d13bc7c72d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Compromise&lt;/strong&gt; - If the Notary signer uses a database as its backend, an attacker can exfiltrate all the (timestamp and snapshot) private material. The capabilities of an attacker are the same as of a Notary server compromise in terms of signing arbitrary metadata, with the important detail that in this particular case key rotations are necessary to recover from the attack.</source>
          <target state="translated">&lt;strong&gt;주요 손상&lt;/strong&gt; &amp;ndash; 공증인이 데이터베이스를 백엔드로 사용하는 경우 공격자는 모든 (타임 스탬프 및 스냅 샷) 개인 자료를 유출 할 수 있습니다. 공격자의 기능은 임의의 메타 데이터 서명 측면에서 Notary 서버 손상과 동일하며,이 경우 공격으로부터 복구하려면 키 회전이 필요하다는 중요한 세부 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f9a8ead9ec8af271b5edda613d7152c17cd4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;List all the details of a machine:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기계의 모든 세부 사항을 나열하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8123230b9ee9bb169f79307ba58bf884110a0922" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Load balancing:&lt;/strong&gt; You can expose the ports for services to an external load balancer. Internally, the swarm lets you specify how to distribute service containers between nodes.</source>
          <target state="translated">&lt;strong&gt;로드 밸런싱 :&lt;/strong&gt; 서비스 포트를 외부로드 밸런서에 노출시킬 수 있습니다. 내부적으로 스웜을 사용하면 노드간에 서비스 컨테이너를 배포하는 방법을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1770d9f1e594a5f43ffe036986ec9291d5227067" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Long syntax:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;긴 구문 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee310707ad9f646a6a3cb3962831ca572414d209" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Looking for Compose file reference?&lt;/strong&gt;&lt;a href=&quot;compose-file/index&quot;&gt;Find the latest version here&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;작성 파일 참조를 찾고 계십니까? &lt;/strong&gt;&lt;a href=&quot;compose-file/index&quot;&gt;여기에서 최신 버전을 찾으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59a432b7ef1f1dba081790101e5b4389344f94fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Malicious Content&lt;/strong&gt; - An attacker can create, store, and serve arbitrary metadata content for one or more trusted collections. However, the attacker has no access to any client-side keys, such as root, targets, and potentially the snapshot keys for the existing trusted collections.</source>
          <target state="translated">&lt;strong&gt;악성 콘텐츠&lt;/strong&gt; -공격자는 하나 이상의 신뢰할 수있는 컬렉션에 대한 임의의 메타 데이터 콘텐츠를 생성, 저장 및 제공 할 수 있습니다. 그러나 공격자는 루트, 대상 및 기존의 신뢰할 수있는 컬렉션에 대한 스냅 샷 키와 같은 클라이언트 쪽 키에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88f5ba0d743dd24fff9c78769b7dc0550e90e8de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multi-host networking:&lt;/strong&gt; You can specify an overlay network for your services. The swarm manager automatically assigns addresses to the containers on the overlay network when it initializes or updates the application.</source>
          <target state="translated">&lt;strong&gt;멀티 호스트 네트워킹 :&lt;/strong&gt; 서비스에 오버레이 네트워크를 지정할 수 있습니다. 스웜 관리자는 애플리케이션을 초기화하거나 업데이트 할 때 오버레이 네트워크의 컨테이너에 주소를 자동으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="34d9e2a87ad8738ee24843c309f17c07733f866b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB:&lt;/strong&gt; Docker doesn&amp;rsquo;t work for non-Linux machines like OpenBSD or Windows Server.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; Docker는 OpenBSD 또는 Windows Server와 같은 Linux 이외의 시스템에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="054d1416daf1321199c8a5fae722a57d05efb978" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB:&lt;/strong&gt; the &lt;em&gt;instance profile&lt;/em&gt;, &lt;em&gt;image&lt;/em&gt;, and &lt;em&gt;availability zone&lt;/em&gt; are case insensitive.</source>
          <target state="translated">&lt;strong&gt;NB : &lt;/strong&gt;&lt;em&gt;인스턴스 프로필&lt;/em&gt; , &lt;em&gt;이미지&lt;/em&gt; , 및 &lt;em&gt;가용 영역이&lt;/em&gt; 케이스 둔감하다.</target>
        </trans-unit>
        <trans-unit id="7eb066d0c0bba4f741cb1675bfb1c4907c37285b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NETWORK&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NETWORK&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbed07e692ed64905f3cb397145d741b11f3262" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Namespaces provide the first and most straightforward form of isolation&lt;/strong&gt;: processes running within a container cannot see, and even less affect, processes running in another container, or in the host system.</source>
          <target state="translated">&lt;strong&gt;네임 스페이스는 가장 단순하고 간단한 형태의 격리를 제공합니다&lt;/strong&gt; . 컨테이너 내에서 실행되는 프로세스는 다른 컨테이너 또는 호스트 시스템에서 실행중인 프로세스를 볼 수 없으며 영향을 덜받습니다.</target>
        </trans-unit>
        <trans-unit id="75049b0fde783a76f0012a6f69ce2731ae7b21b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No CMD&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CMD 없음&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="182ba4c98628e456c9013df1600bef8f1f5b2f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; A process running as PID 1 inside a container is treated specially by Linux: it ignores any signal with the default action. So, the process will not terminate on &lt;code&gt;SIGINT&lt;/code&gt; or &lt;code&gt;SIGTERM&lt;/code&gt; unless it is coded to do so.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 컨테이너 내에서 PID 1로 실행되는 프로세스는 Linux에서 특별히 처리합니다. 기본 동작의 신호는 무시합니다. 따라서 프로세스는 &lt;code&gt;SIGINT&lt;/code&gt; 또는 &lt;code&gt;SIGTERM&lt;/code&gt; 에서 코드화되지 않으면 종료되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="73ce8ba4ec04c00a3c01249c26918681776f0cf6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the &lt;code&gt;URL&lt;/code&gt; parameter contains a fragment the system will recursively clone the repository and its submodules using a &lt;code&gt;git clone --recursive&lt;/code&gt; command.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;URL&lt;/code&gt; 의 매개 변수가 조각이 들어있는 시스템이 반복적으로 저장소 및 사용하여 서브 모듈 복제해야합니다 &lt;code&gt;git clone --recursive&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fb39fe933f0ab0df1f2781334b20d1998650dad9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Running multiple daemons on a single host is considered as &amp;ldquo;experimental&amp;rdquo;. The user should be aware of unsolved problems. This solution may not work properly in some cases. Solutions are currently under development and will be delivered in the near future.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 단일 호스트에서 여러 데몬을 실행하는 것은 &quot;실험적인&quot;것으로 간주됩니다. 사용자는 해결되지 않은 문제를 알고 있어야합니다. 경우에 따라이 솔루션이 제대로 작동하지 않을 수 있습니다. 솔루션은 현재 개발 중이며 가까운 시일 내에 제공 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="287a48cba4d2ef35c9e5ecd9dbcec435e784cc41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;/run/docker/plugins&lt;/code&gt; directory is mandatory inside of the plugin&amp;rsquo;s filesystem for docker to communicate with the plugin.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;/run/docker/plugins&lt;/code&gt; 디렉토리가 고정 표시기는 플러그인과 통신하기위한 플러그인의 파일 시스템의 필수 내부입니다.</target>
        </trans-unit>
        <trans-unit id="4bc0308bed74e55409d3e32cdc4a66732b3c81d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;attach&lt;/code&gt; command will display the output of the &lt;code&gt;ENTRYPOINT/CMD&lt;/code&gt; process. This can appear as if the attach command is hung when in fact the process may simply not be interacting with the terminal at that time.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; (가) &lt;code&gt;attach&lt;/code&gt; 명령의 출력이 표시됩니다 &lt;code&gt;ENTRYPOINT/CMD&lt;/code&gt; 과정을. 실제로 프로세스가 단순히 터미널과 상호 작용하지 않을 때 attach 명령이 중단 된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb127c237c093aadc80b2933ca4e74ca085f4f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The blkio weight setting is only available for direct IO. Buffered IO is not currently supported.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; blkio 가중치 설정은 직접 IO에만 사용할 수 있습니다. 버퍼링 된 IO는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7c63377cd9332fed81bd563cebd62813c926a56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You cannot set options in &lt;code&gt;daemon.json&lt;/code&gt; that have already been set on daemon startup as a flag. On systems that use &lt;code&gt;systemd&lt;/code&gt; to start the Docker daemon, &lt;code&gt;-H&lt;/code&gt; is already set, so you cannot use the &lt;code&gt;hosts&lt;/code&gt; key in &lt;code&gt;daemon.json&lt;/code&gt; to add listening addresses. See https://docs.docker.com/engine/admin/systemd/#custom-docker-daemon-options for how to accomplish this task with a systemd drop-in file.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;daemon.json&lt;/code&gt; 에서 데몬 시작시 이미 설정된 옵션을 플래그로 설정할 수 없습니다 . &lt;code&gt;systemd&lt;/code&gt; 를 사용 하여 Docker 데몬을 시작하는 시스템 에서는 &lt;code&gt;-H&lt;/code&gt; 가 이미 설정되어 있으므로 &lt;code&gt;daemon.json&lt;/code&gt; 의 &lt;code&gt;hosts&lt;/code&gt; 키를 사용하여 수신 주소를 추가 할 수 없습니다 . 시스템 드롭 인 파일로이 작업을 수행하는 방법은 https://docs.docker.com/engine/admin/systemd/#custom-docker-daemon-options를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d37f02d88fcab3da23d3f51500e36eb5fb5a2041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if you pass a numeric uid, it must be in the range of 0-2147483647.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 숫자 uid를 전달하는 경우 0-2147483647 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="922a06ac88f83c9bf8fcaf0d5617854c254780cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can override the &lt;code&gt;ENTRYPOINT&lt;/code&gt; setting using &lt;code&gt;--entrypoint&lt;/code&gt;, but this can only set the binary to &lt;em&gt;exec&lt;/em&gt; (no &lt;code&gt;sh -c&lt;/code&gt; will be used).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 당신이 무시할 수 있습니다 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 사용 설정 &lt;code&gt;--entrypoint&lt;/code&gt; 을 하지만, 이것은 단지에 바이너리 설정할 수 있습니다 &lt;em&gt;간부&lt;/em&gt; (NO &lt;code&gt;sh -c&lt;/code&gt; 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="bb62d44e5db27018f1fa9b63bcb4de8a540be584" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;docker build&lt;/code&gt; will return a &lt;code&gt;no such file or directory&lt;/code&gt; error if the file or directory does not exist in the uploaded context. This may happen if there is no context, or if you specify a file that is elsewhere on the Host system. The context is limited to the current directory (and its children) for security reasons, and to ensure repeatable builds on remote Docker hosts. This is also the reason why &lt;code&gt;ADD ../file&lt;/code&gt; will not work.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 파일이나 디렉토리가 업로드 된 컨텍스트에 존재하지 않으면 &lt;code&gt;docker build&lt;/code&gt; 는 &lt;code&gt;no such file or directory&lt;/code&gt; 오류를 반환하지 않습니다. 컨텍스트가 없거나 호스트 시스템의 다른 곳에 파일을 지정한 경우에 발생할 수 있습니다. 컨텍스트는 보안상의 이유로 현재 디렉토리 (및 그 하위)로 제한되며 원격 Docker 호스트에서 반복 가능한 빌드를 보장합니다. &lt;code&gt;ADD ../file&lt;/code&gt; 이 작동하지 않는 이유이기도 합니다.</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbb904cc34693f284c7465ded9635f604fa54ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; Since Docker may live update the container&amp;rsquo;s &lt;code&gt;/etc/hosts&lt;/code&gt; file, there may be situations when processes inside the container can end up reading an empty or incomplete &lt;code&gt;/etc/hosts&lt;/code&gt; file. In most cases, retrying the read again should fix the problem.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; Docker는 컨테이너의 &lt;code&gt;/etc/hosts&lt;/code&gt; 파일을 실시간으로 업데이트 할 수 있으므로 컨테이너 내부 프로세스가 비어 있거나 불완전한 &lt;code&gt;/etc/hosts&lt;/code&gt; 파일을 읽을 수있는 상황이있을 수 있습니다 . 대부분의 경우 읽기를 다시 시도하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="abd92687b99044b4eddf773d671c4667439b4622" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="e2ebbdefb7c25a45066b00fe6f7d6091883af601" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;--device&lt;/code&gt; cannot be safely used with ephemeral devices. Block devices that may be removed should not be added to untrusted containers with &lt;code&gt;--device&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--device&lt;/code&gt; 는 임시 장치와 함께 안전하게 사용할 수 없습니다. 제거 될 수있는 블록 장치는 &lt;code&gt;--device&lt;/code&gt; 를 사용 하여 신뢰할 수없는 컨테이너에 추가해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba3ed3a7ac6e837b705cfc99db0c7736a417d99a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;--network=&quot;host&quot;&lt;/code&gt; gives the container full access to local system services such as D-bus and is therefore considered insecure.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--network=&quot;host&quot;&lt;/code&gt; 는 컨테이너에 D 버스와 같은 로컬 시스템 서비스에 대한 전체 액세스 권한을 부여하므로 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca9b75d31953aa7998c5806fa9534f404cb2501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;ENTRYPOINT&lt;/code&gt; and &lt;code&gt;CMD&lt;/code&gt; in the &lt;em&gt;shell&lt;/em&gt; form run as a subcommand of &lt;code&gt;/bin/sh -c&lt;/code&gt;, which does not pass signals. This means that the executable is not the container&amp;rsquo;s PID 1 and does not receive Unix signals.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;셸&lt;/em&gt; 형식 의 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 및 &lt;code&gt;CMD&lt;/code&gt; 는 신호를 전달하지 않는 &lt;code&gt;/bin/sh -c&lt;/code&gt; 의 하위 명령으로 실행됩니다 . 이는 실행 파일이 컨테이너의 PID 1이 아니며 Unix 신호를 수신하지 않음을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a55b0e51cd22b98f04629eb3cff653d5d87becf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;config&lt;/code&gt; definitions are only supported in version 3.3 and higher of the compose file format.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;config&lt;/code&gt; 정의는 작성 파일 형식의 버전 3.3 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d519f1f6a0b7a3198b86e31e89c40282548a9c3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;depends_on&lt;/code&gt; does not wait for &lt;code&gt;db&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt; to be &amp;ldquo;ready&amp;rdquo; before starting &lt;code&gt;web&lt;/code&gt; - only until they have been started. If you need to wait for a service to be ready, see &lt;a href=&quot;../../startup-order/index&quot;&gt;Controlling startup order&lt;/a&gt; for more on this problem and strategies for solving it.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;depends_on&lt;/code&gt; 은 &lt;code&gt;web&lt;/code&gt; 을 시작하기 전에 &lt;code&gt;db&lt;/code&gt; 및 &lt;code&gt;redis&lt;/code&gt; 가&amp;ldquo;준비&amp;rdquo;될 때까지 기다리지 않습니다 . 서비스가 준비 될 때까지 기다려야 하는 경우이 문제에 대한 자세한 내용 및 해결 전략은 &lt;a href=&quot;../../startup-order/index&quot;&gt;시작 순서 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f153c32c4cfdc2f9acfe7c15f2eb89c80def926" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;order&lt;/code&gt; is only supported for v3.4 and higher of the compose file format.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;order&lt;/code&gt; 는 작성 파일 형식의 v3.4 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="17be54eb0c7bca6cde419016b4a8900b3ee0e3ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;process&lt;/code&gt; isolation mode is only supported on Windows Server. Windows 10 only supports &lt;code&gt;hyperv&lt;/code&gt; isolation mode.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;process&lt;/code&gt; 격리 모드는 Windows Server에서만 지원됩니다. Windows 10은 &lt;code&gt;hyperv&lt;/code&gt; 격리 모드 만 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="0a913e907cec552192adfb1c3bbb1cd26f86382c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;seccomp&lt;/code&gt; profiles require seccomp 2.2.1 which is not available on Ubuntu 14.04, Debian Wheezy, or Debian Jessie. To use &lt;code&gt;seccomp&lt;/code&gt; on these distributions, you must download the &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce&quot;&gt;latest static Linux binaries&lt;/a&gt; (rather than packages).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;seccomp&lt;/code&gt; 프로파일에는 seccomp 2.2.1이 필요하며 Ubuntu 14.04, Debian Wheezy 또는 Debian Jessie에서는 사용할 수 없습니다. 이러한 배포에서 &lt;code&gt;seccomp&lt;/code&gt; 를 사용하려면 패키지가 아닌 &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce&quot;&gt;최신 정적 Linux 바이너리를&lt;/a&gt; 다운로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e14d88502de45a9a3845acf3c215f746646e458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;start_period&lt;/code&gt; is only supported for v3.4 and higher of the compose file format.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;start_period&lt;/code&gt; 는 작성 파일 형식의 v3.4 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b5f3f9524abce4b876ff84e992c09029d0db7e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A network-wide alias can be shared by multiple containers, and even by multiple services. If it is, then exactly which container the name resolves to is not guaranteed.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 네트워크 전체 별명은 여러 컨테이너와 여러 서비스에서 공유 할 수 있습니다. 그렇다면 이름이 확인되는 컨테이너가 정확히 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9fbbcd76a1917a93abca4d2a6c8370e50512eab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A process running as PID 1 inside a container is treated specially by Linux: it ignores any signal with the default action. So, the process will not terminate on &lt;code&gt;SIGINT&lt;/code&gt; or &lt;code&gt;SIGTERM&lt;/code&gt; unless it is coded to do so.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 컨테이너 내에서 PID 1로 실행되는 프로세스는 Linux에서 특별히 처리합니다. 기본 동작의 신호는 무시합니다. 따라서 프로세스는 &lt;code&gt;SIGINT&lt;/code&gt; 또는 &lt;code&gt;SIGTERM&lt;/code&gt; 에서 코드화되지 않으면 종료되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="24294655272b70a23a4b81cf84dcee98913fe09d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 컨테이너 내부에서 호스트 이름에 액세스하면 실행중인 실행 파일의 프로세스 ID와 같은 컨테이너 ID를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="fc65bece9a7828ca54def38a1f807f5fb6769c9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional IPAM configurations, such as &lt;code&gt;gateway&lt;/code&gt;, are only honored for version 2 at the moment.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;gateway&lt;/code&gt; 와 같은 추가 IPAM 구성 은 현재 버전 2에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22da25d072c1b48af88adf67107c20f3b6790f48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: After you create a secret, you cannot update it. You can only remove and re-create it, and you cannot remove a secret that a service is using. However, you can grant or revoke a running service&amp;rsquo;s access to secrets using &lt;code&gt;docker service update&lt;/code&gt;. If you need the ability to update a secret, consider adding a version component to the secret name, so that you can later add a new version, update the service to use it, then remove the old version.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 비밀을 만든 후에는 업데이트 할 수 없습니다. 이를 제거하고 다시 작성할 수 있으며 서비스가 사용중인 비밀을 제거 할 수 없습니다. 그러나 &lt;code&gt;docker service update&lt;/code&gt; 를 사용하여 실행중인 서비스의 비밀에 대한 액세스 권한을 부여하거나 취소 할 수 있습니다 . 비밀 정보를 업데이트 할 수있는 기능이 필요한 경우 비밀 번호에 버전 구성 요소를 추가하여 나중에 새 버전을 추가하고 사용하도록 서비스를 업데이트 한 다음 이전 버전을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="776fb9703fdf0740da25664ba55be2fb470d1060" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a point of information, the &lt;code&gt;config.json&lt;/code&gt;, certificates, and other data related to each virtual machine created by &lt;code&gt;docker-machine&lt;/code&gt; is stored in &lt;code&gt;~/.docker/machine/machines/&lt;/code&gt; on Mac and Linux and in &lt;code&gt;~\.docker\machine\machines\&lt;/code&gt; on Windows. We recommend that you do not edit or remove those files directly as this only affects information for the Docker CLI, not the actual VMs, regardless of whether they are local or on remote servers.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 정보의 관점에서, &lt;code&gt;docker-machine&lt;/code&gt; 으로 작성된 각 가상 머신과 관련된 &lt;code&gt;config.json&lt;/code&gt; , 인증서 및 기타 데이터 는 Mac 및 Linux의 &lt;code&gt;~/.docker/machine/machines/&lt;/code&gt; 및 &lt;code&gt;~\.docker\machine\machines\&lt;/code&gt; Windows의 \ machine \ machines \ 이러한 파일은 로컬 또는 원격 서버에 관계없이 실제 VM이 아닌 Docker CLI에 대한 정보에만 영향을 미치므로 해당 파일을 직접 편집하거나 제거하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d42761bf8b31ecf9cf2fa7cef7065d7785ffc3d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As of Docker 1.13, on Linux any root certificates authorities are merged with the system defaults, including as the host&amp;rsquo;s root CA set. On prior versions of Docker, and on Docker Enterprise Edition for Windows Server, the system default certificates are only used when no custom root certificates are configured.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 1.13부터 Linux에서 모든 루트 인증 기관은 호스트의 루트 CA 세트를 포함하여 시스템 기본값과 병합됩니다. 이전 버전의 Docker 및 Windows Server 용 Docker Enterprise Edition에서 시스템 기본 인증서는 사용자 정의 루트 인증서가 구성되지 않은 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f02addadcbd22891b9f7c4ab0b6734145674d2e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As promising as &lt;code&gt;overlay&lt;/code&gt; is, the feature is still quite young and should not be used in production. Most notably, using &lt;code&gt;overlay&lt;/code&gt; can cause excessive inode consumption (especially as the number of images grows), as well as being incompatible with the use of RPMs.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;overlay&lt;/code&gt; 처럼 유망한 기능은 여전히 ​​젊기 때문에 프로덕션 환경에서 사용해서는 안됩니다. 특히 &lt;code&gt;overlay&lt;/code&gt; 를 사용하면 과도한 inode 소비 (특히 이미지 수가 증가함에 따라)가 발생하고 RPM 사용과 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8372f16240191613e13ba16089ff19e107f7aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Automatic translation of MLS labels is not currently supported.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : MLS 레이블의 자동 번역은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4618c9408cd5ae834ca8958b5824e0148a20ab1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Be sure to maintain the quorum of swarm managers. During the time that a manager is shut down, your swarm is more vulnerable to losing the quorum if further nodes are lost. The number of managers you run is a trade-off. If you regularly take down managers to do backups, consider running a 5-manager swarm, so that you can lose an additional manager while the backup is running, without disrupting your services.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 떼 관리자의 정족수를 유지하십시오. 관리자가 종료되는 동안 추가 노드가 손실되면 웜은 쿼럼을 잃을 수 있습니다. 귀하가 운영하는 관리자의 수는 상충 관계입니다. 관리자가 정기적으로 백업을 중단하면 5 관리자 떼를 실행하여 백업이 실행되는 동안 서비스를 중단하지 않고 추가 관리자를 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff845e7c0c158dec3d09154fd0f0e807eda5dd04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Because support for stacks and bundles is in the experimental stage, you need to install an experimental build of Docker Engine to use it.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 스택 및 번들에 대한 지원은 실험 단계이므로 Docker Engine의 실험 빌드를 설치하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55e9d40d06cf7bfaa10beb313bfa77449f55036f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Both &lt;code&gt;overlay&lt;/code&gt; and &lt;code&gt;overlay2&lt;/code&gt; are currently unsupported on &lt;code&gt;btrfs&lt;/code&gt; or any Copy on Write filesystem and should only be used over &lt;code&gt;ext4&lt;/code&gt; partitions.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;overlay&lt;/code&gt; 및 &lt;code&gt;overlay2&lt;/code&gt; 는 현재 &lt;code&gt;btrfs&lt;/code&gt; 또는 Copy on Write 파일 시스템에서 지원되지 않으며 &lt;code&gt;ext4&lt;/code&gt; 파티션 에서만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7097849d13a479d1192f6816ca57a1183be1bf76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Changing the password on a MySQL database involves running extra queries or commands, as opposed to just changing a single environment variable or a file, since the image only sets the MySQL password if the database doesn&amp;rsquo;t already exist, and MySQL stores the password within a MySQL database by default. Rotating passwords or other secrets may involve additional steps outside of Docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : MySQL 데이터베이스에서 비밀번호를 변경하면 데이터베이스가 존재하지 않는 경우 이미지가 MySQL 비밀번호 만 설정하고 MySQL은 이미지를 저장하기 때문에 단일 환경 변수 또는 파일 변경과 달리 추가 쿼리 또는 명령 실행 기본적으로 MySQL 데이터베이스 내의 비밀번호. 암호 또는 기타 비밀을 회전하면 Docker 외부의 추가 단계가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ff50fb0b8cd2d039d6fb0da4833fd1999c3eba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compose files like this are used to define applications with Docker, and can be uploaded to cloud providers using &lt;a href=&quot;https://docs.docker.com/docker-hub&quot;&gt;Docker Cloud&lt;/a&gt;, or on any hardware or cloud provider you choose with &lt;a href=&quot;https://www.docker.com/enterprise-edition&quot;&gt;Docker Enterprise Edition&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이와 같은 작성 파일은 Docker로 애플리케이션을 정의하는 데 사용되며 &lt;a href=&quot;https://docs.docker.com/docker-hub&quot;&gt;Docker Cloud를&lt;/a&gt; 사용하여 클라우드 제공자 또는 &lt;a href=&quot;https://www.docker.com/enterprise-edition&quot;&gt;Docker Enterprise Edition에서&lt;/a&gt; 선택한 하드웨어 또는 클라우드 제공자에 업로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a373c170a6bb61ca04a84ae38aa5b7de84972676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Containers on the default bridge network must be linked to communicate by name.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 기본 브리지 네트워크의 컨테이너는 이름으로 통신하도록 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="982193f2b40d0b0ff37c2b5b2c5d4ed1278042ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Defining runtime arguments via the command line is not supported.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 명령 행을 통한 런타임 인수 정의는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3311377d7997f7cd5b3a86916c66bbe331e51a1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Depending on your Docker system configuration, you may be required to preface the &lt;code&gt;docker run&lt;/code&gt; command with &lt;code&gt;sudo&lt;/code&gt;. To avoid having to use &lt;code&gt;sudo&lt;/code&gt; with the &lt;code&gt;docker&lt;/code&gt; command, your system administrator can create a Unix group called &lt;code&gt;docker&lt;/code&gt; and add users to it. For more information about this configuration, refer to the Docker installation documentation for your operating system.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 시스템 구성에 따라 &lt;code&gt;sudo&lt;/code&gt; 로 &lt;code&gt;docker run&lt;/code&gt; 명령을 시작 해야 할 수도 있습니다 . 사용하지 않도록하려면 &lt;code&gt;sudo&lt;/code&gt; 를을 와 &lt;code&gt;docker&lt;/code&gt; 명령, 시스템 관리자는 유닉스 그룹에라는 만들 수 있습니다 &lt;code&gt;docker&lt;/code&gt; 하고 여기에 사용자를 추가합니다. 이 구성에 대한 자세한 정보는 운영 체제의 Docker 설치 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="09d70aad2a98b7edda4ae32b94ce6600d459b60d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Do not use the &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-a stderr&lt;/code&gt; options together due to limitations in the &lt;code&gt;pty&lt;/code&gt; implementation. All &lt;code&gt;stderr&lt;/code&gt; in &lt;code&gt;pty&lt;/code&gt; mode simply goes to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;pty&lt;/code&gt; 구현의 제한 사항으로 인해 &lt;code&gt;-t&lt;/code&gt; 및 &lt;code&gt;-a stderr&lt;/code&gt; 옵션을 함께 사용하지 마십시오 . &lt;code&gt;pty&lt;/code&gt; 모드의 모든 &lt;code&gt;stderr&lt;/code&gt; 는 단순히 &lt;code&gt;stdout&lt;/code&gt; 으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf84459085a4288d1c75151385e301bffdc1c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker Engine managed plugins are currently not supported on Windows daemons.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker Engine 관리 플러그인은 현재 Windows 데몬에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5a1686f29686edf3cdcb2496bbc521d1a9960cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker configs are only available to swarm services, not to standalone containers. To use this feature, consider adapting your container to run as a service with a scale of 1.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 구성은 독립형 컨테이너가 아닌 스웜 서비스에만 사용할 수 있습니다. 이 기능을 사용하려면 규모가 1 인 서비스로 실행되도록 컨테이너를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="17e704ae5cfc77cfa2a52ae5b6b4b9542a85642c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker engine allows a non-FIPS node to join a FIPS-enabled swarm cluster.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 엔진을 사용하면 비 FIPS 노드가 FIPS 지원 스웜 클러스터에 가입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9636d10e039511c52a32bf34ba11df4f198c998b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker over TLS should run on TCP port 2376.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : TLS를 통한 Docker는 TCP 포트 2376에서 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="48e5a720d1467b1fb055d26a2e836987581f1320" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker secrets are only available to swarm services, not to standalone containers. To use this feature, consider adapting your container to run as a service. Stateful containers can typically run with a scale of 1 without changing the container code.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 비밀은 독립형 컨테이너가 아닌 스웜 서비스에만 사용할 수 있습니다. 이 기능을 사용하려면 서비스로 실행되도록 컨테이너를 조정하십시오. 상태 저장 컨테이너는 일반적으로 컨테이너 코드를 변경하지 않고 스케일 1로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46646beb8c759aba8cf26ff1ffe4a9bdd01e8ad0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker secrets do not set environment variables directly. This was a conscious decision, because environment variables can unintentionally be leaked between containers (for instance, if you use &lt;code&gt;--link&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 비밀은 환경 변수를 직접 설정하지 않습니다. 컨테이너간에 환경 변수가 실수로 누수 될 수 있기 때문에 이는 의도적 인 결정이었습니다 (예 : &lt;code&gt;--link&lt;/code&gt; 를 사용하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="bad84e9c0a825ba3a95545adc7a71a8eab275bb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Docker warns you if any containers exist that are using these untagged images.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 태그가 지정되지 않은 이미지를 사용하는 컨테이너가 있으면 Docker가 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0cf701065a4dec8098681f0082dfe4a16551e1c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Don&amp;rsquo;t confuse &lt;code&gt;RUN&lt;/code&gt; with &lt;code&gt;CMD&lt;/code&gt;. &lt;code&gt;RUN&lt;/code&gt; actually runs a command and commits the result; &lt;code&gt;CMD&lt;/code&gt; does not execute anything at build time, but specifies the intended command for the image.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;RUN&lt;/code&gt; 과 &lt;code&gt;CMD&lt;/code&gt; 를 혼동하지 마십시오 . &lt;code&gt;RUN&lt;/code&gt; 은 실제로 명령을 실행하고 결과를 커밋합니다. &lt;code&gt;CMD&lt;/code&gt; 는 빌드시 아무 것도 실행하지 않지만 이미지의 의도 된 명령을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="87a9a82830d9603a0a8c962393832931117df0dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Environment persistence can cause unexpected side effects. For example, setting &lt;code&gt;ENV DEBIAN_FRONTEND noninteractive&lt;/code&gt; may confuse apt-get users on a Debian-based image. To set a value for a single command, use &lt;code&gt;RUN &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 환경 지속성으로 인해 예기치 않은 부작용이 발생할 수 있습니다. 예를 들어, &lt;code&gt;ENV DEBIAN_FRONTEND noninteractive&lt;/code&gt; 설정 하면 데비안 기반 이미지에서 apt-get 사용자를 혼동 할 수 있습니다. 단일 명령의 값을 설정하려면 &lt;code&gt;RUN &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0acf69c85ea2bb18eca4533bc8ed4438b48e6252" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Environment variables are no longer the recommended method for connecting to linked services. Instead, you should use the link name (by default, the name of the linked service) as the hostname to connect to. See the &lt;a href=&quot;../compose-file/index#links&quot;&gt;docker-compose.yml documentation&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 환경 변수는 더 이상 링크 된 서비스에 연결하는 데 권장되는 방법이 아닙니다. 대신 연결할 호스트 이름으로 링크 이름 (기본적으로 링크 된 서비스 이름)을 사용해야합니다. 자세한 내용은 &lt;a href=&quot;../compose-file/index#links&quot;&gt;docker-compose.yml 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d724c8412478a6d8ee6a0e2d724ed24d2fb8661" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For all aws create flags, run: &lt;code&gt;docker-machine create --driver amazonec2 --help&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 모든 aws create 플래그에 대해 다음을 실행하십시오. &lt;code&gt;docker-machine create --driver amazonec2 --help&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46832f0e686ba99e144e68f641f5f30f66015507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons, the pattern &lt;code&gt;.&lt;/code&gt; is ignored.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 역사적 이유로 패턴 &lt;code&gt;.&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="443f6a6b80d637f1176e0116535c76c38f4d3f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For simplicity of the next couple of steps, you may perform this step on the Docker daemon&amp;rsquo;s host machine as well.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 다음 두 단계를 단순화하기 위해 Docker 데몬의 호스트 시스템에서도이 단계를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bd68ab82458d46dde2eee0ae14be4e16da7609" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For version 2 file format, the externally-created containers must be connected to at least one of the same networks as the service which is linking to them.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 버전 2 파일 형식의 경우 외부에서 작성된 컨테이너는 해당 컨테이너와 연결되는 서비스와 동일한 네트워크 중 하나 이상에 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a52e6d50012ace809967ece277c295a1ef6aa01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If &lt;a href=&quot;../../security/trust/content_trust/index&quot;&gt;content trust&lt;/a&gt; is enabled, the client actually resolves the image&amp;rsquo;s tag to a digest before contacting the swarm manager, to verify that the image is signed. Thus, if you use content trust, the swarm manager receives the request pre-resolved. In this case, if the client cannot resolve the image to a digest, the request fails.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;../../security/trust/content_trust/index&quot;&gt;콘텐츠 신뢰&lt;/a&gt; 가 활성화 된 경우 클라이언트는 swarm manager에 문의하기 전에 실제로 이미지의 태그를 요약으로 분석하여 이미지가 서명되었는지 확인합니다. 따라서 컨텐츠 신뢰를 사용하는 경우 스웜 관리자는 사전 해결 된 요청을 수신합니다. 이 경우 클라이언트가 이미지를 다이제스트로 해석 할 수 없으면 요청이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9dcc04aaf42ca81fa8c9fa9d50edd153a881b572" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If &lt;code&gt;CMD&lt;/code&gt; is defined from the base image, setting &lt;code&gt;ENTRYPOINT&lt;/code&gt; will reset &lt;code&gt;CMD&lt;/code&gt; to an empty value. In this scenario, &lt;code&gt;CMD&lt;/code&gt; must be defined in the current image to have a value.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 기본 이미지에서 &lt;code&gt;CMD&lt;/code&gt; 를 정의한 경우 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 를 설정하면 &lt;code&gt;CMD&lt;/code&gt; 가 빈 값으로 재설정됩니다 . 이 시나리오에서 &lt;code&gt;CMD&lt;/code&gt; 는 현재 이미지에서 값을 갖도록 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ba4993a61db55edee5efbebc5977b3306919b3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If &lt;code&gt;CMD&lt;/code&gt; is used to provide default arguments for the &lt;code&gt;ENTRYPOINT&lt;/code&gt; instruction, both the &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt; instructions should be specified with the JSON array format.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;CMD&lt;/code&gt; 를 사용하여 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 명령어에 대한 기본 인수를 제공 하는 경우 &lt;code&gt;CMD&lt;/code&gt; 및 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 명령어 모두 JSON 배열 형식으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72704511c031b767c4a07b81bf5357d75a08991" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If multiple certificates exist, each is tried in alphabetical order. If there is a 4xx-level or 5xx-level authentication error, Docker continues to try with the next certificate.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 여러 인증서가있는 경우 각 인증서는 알파벳 순서로 시도됩니다. 4xx 수준 또는 5xx 수준 인증 오류가 있으면 Docker는 다음 인증서로 계속 시도합니다.</target>
        </trans-unit>
        <trans-unit id="25ad23cd5f3ebad3e9b0351dd7d1f88b913a58da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If multiple networks have the same priority, the connection order is undefined.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 여러 네트워크의 우선 순위가 같은 경우 연결 순서가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="094fe0de28c390a3b7825ff0da8a0098971e3cff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If the command &lt;code&gt;docker-compose&lt;/code&gt; fails after installation, check your path. You can also create a symbolic link to &lt;code&gt;/usr/bin&lt;/code&gt; or any other directory in your path.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 설치 후 &lt;code&gt;docker-compose&lt;/code&gt; 명령 이 실패하면 경로를 확인하십시오. &lt;code&gt;/usr/bin&lt;/code&gt; 또는 경로의 다른 디렉토리에 대한 심볼릭 링크를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18c638e78c9a7e4a3107abaf7ae32a28464b5b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you already have an external network switch, skip this setup and use that one instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이미 외부 네트워크 스위치가있는 경우이 설정을 건너 뛰고 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01d34c0d83328fe1e57215478e63798c0cb34c7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are on a Windows system that has Hyper-V installed, such as Windows 10, there is no need to install VirtualBox and you should use Hyper-V instead. View the instructions for Hyper-V systems by clicking the Hyper-V tab above. If you are using &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;, you should already have VirtualBox installed as part of it, so you are good to go.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Windows 10과 같이 Hyper-V가 설치된 Windows 시스템에있는 경우 VirtualBox를 설치할 필요가 없으며 대신 Hyper-V를 사용해야합니다. 위의 Hyper-V 탭을 클릭하여 Hyper-V 시스템에 대한 지침을보십시오. &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox를&lt;/a&gt; 사용하는 경우 VirtualBox가 이미 그 일부로 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0555aab5b76f3795c3b5098975934045a7c14f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using &lt;code&gt;fish&lt;/code&gt;, or a Windows shell such as Powershell/&lt;code&gt;cmd.exe&lt;/code&gt;, the above method does not work as described. Instead, see &lt;a href=&quot;../reference/env/index&quot;&gt;the &lt;code&gt;env&lt;/code&gt; command&amp;rsquo;s documentation&lt;/a&gt; to learn how to set the environment variables for your shell.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;fish&lt;/code&gt; 또는 Powershell / &lt;code&gt;cmd.exe&lt;/code&gt; 와 같은 Windows 셸을 사용 하는 경우 위의 방법은 설명 된대로 작동하지 않습니다. 대신, 쉘의 환경 변수를 설정하는 방법을 배우 &lt;a href=&quot;../reference/env/index&quot;&gt;려면 &lt;code&gt;env&lt;/code&gt; 명령 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1cca979a9450e53703ff3fa484527a69ea3afe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using Docker Desktop for Mac or Docker Desktop for Windows to test single-node swarm, simply run &lt;code&gt;docker swarm init&lt;/code&gt; with no arguments. There is no need to specify &lt;code&gt;--advertise-addr&lt;/code&gt; in this case. To learn more, see the topic on how to &lt;a href=&quot;../index#use-docker-for-mac-or-docker-for-windows&quot;&gt;Use Docker Desktop or Mac or Docker Desktop for Windows&lt;/a&gt; with Swarm.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop을 사용하여 단일 노드 떼를 테스트 하는 경우 인수없이 &lt;code&gt;docker swarm init&lt;/code&gt; 를 실행하면 됩니다. 이 경우 &lt;code&gt;--advertise-addr&lt;/code&gt; 을 지정할 필요가 없습니다 . 자세한 내용은 &lt;a href=&quot;../index#use-docker-for-mac-or-docker-for-windows&quot;&gt;Docker Desktop 또는 Mac 또는&lt;/a&gt; Swarm과 함께 Windows 용 Docker Desktop 을 사용 하는 방법에 대한 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2e19359bb35b1cd29aa5631efd8f85016cb5287" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using Docker Toolbox on Windows 7, use the Docker Machine IP instead of &lt;code&gt;localhost&lt;/code&gt;. For example, http://192.168.99.100:4000/. To find the IP address, use the command &lt;code&gt;docker-machine ip&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Windows 7에서 Docker Toolbox를 사용하는 경우 &lt;code&gt;localhost&lt;/code&gt; 대신 Docker Machine IP를 사용하십시오 . 예를 들면 http://192.168.99.100:4000/입니다. IP 주소를 찾으려면 &lt;code&gt;docker-machine ip&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd2b287d482748f3d2b7f024d146e526b7a3f21c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using a custom boot2docker ISO specified using &lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; or an equivalent flag, running an upgrade on that machine completely replaces the specified ISO with the latest &amp;ldquo;vanilla&amp;rdquo; boot2docker ISO available.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; 또는 동등한 플래그를 사용하여 지정된 사용자 정의 boot2docker ISO를 사용하는 경우 해당 시스템에서 업그레이드를 실행하면 지정된 ISO가 사용 가능한 최신 &quot;vanilla&quot;boot2docker ISO로 완전히 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="c42fe3b777173c904022041efbc8d4cd3c057868" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you build by passing a &lt;code&gt;Dockerfile&lt;/code&gt; through STDIN (&lt;code&gt;docker build - &amp;lt; somefile&lt;/code&gt;), there is no build context, so the &lt;code&gt;Dockerfile&lt;/code&gt; can only contain a URL based &lt;code&gt;ADD&lt;/code&gt; instruction. You can also pass a compressed archive through STDIN: (&lt;code&gt;docker build - &amp;lt; archive.tar.gz&lt;/code&gt;), the &lt;code&gt;Dockerfile&lt;/code&gt; at the root of the archive and the rest of the archive will be used as the context of the build.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : STDIN ( &lt;code&gt;docker build - &amp;lt; somefile&lt;/code&gt; &lt;code&gt;Dockerfile&lt;/code&gt; &amp;lt;somefile )을 통해 Dockerfile 을 전달하여 빌드하는 경우 빌드 컨텍스트가 없으므로 &lt;code&gt;Dockerfile&lt;/code&gt; 은 URL 기반 &lt;code&gt;ADD&lt;/code&gt; 명령어 만 포함 할 수 있습니다 . 압축 된 아카이브를 STDIN : ( &lt;code&gt;docker build - &amp;lt; archive.tar.gz&lt;/code&gt; &lt;code&gt;Dockerfile&lt;/code&gt; &amp;lt;archive.tar.gz ), 아카이브의 루트에있는 Dockerfile 및 나머지 아카이브가 빌드의 컨텍스트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="60e98b4819136854ac2f3d217c660a765a718558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you build using STDIN (&lt;code&gt;docker build - &amp;lt; somefile&lt;/code&gt;), there is no build context, so &lt;code&gt;COPY&lt;/code&gt; can&amp;rsquo;t be used.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : STDIN ( &lt;code&gt;docker build - &amp;lt; somefile&lt;/code&gt; )을 사용하여 빌드하면 빌드 컨텍스트가 없으므로 &lt;code&gt;COPY&lt;/code&gt; 를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fddc00dbc8dd4a1244a6f4516bc9be6e2635a72f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you define both links and &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt;, services with links between them must share at least one network in common in order to communicate.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 링크와 &lt;a href=&quot;#networks&quot;&gt;네트워크를&lt;/a&gt; 모두 정의하는 경우 링크가있는 서비스는 통신하기 위해 하나 이상의 네트워크를 공통으로 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="4df6985c2b4ab5e7f110baad4086d713d8d2b225" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you define both links and &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt;, services with links between them must share at least one network in common in order to communicate. We recommend using networks instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 링크와 &lt;a href=&quot;#networks&quot;&gt;네트워크를&lt;/a&gt; 모두 정의하는 경우 링크가있는 서비스는 통신하기 위해 하나 이상의 네트워크를 공통으로 공유해야합니다. 대신 네트워크를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="979aa41b4cc0f00d20de3a0d650ae2da509c03f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you do not provide a &lt;code&gt;hard limit&lt;/code&gt;, the &lt;code&gt;soft limit&lt;/code&gt; will be used for both values. If no &lt;code&gt;ulimits&lt;/code&gt; are set, they will be inherited from the default &lt;code&gt;ulimits&lt;/code&gt; set on the daemon. &lt;code&gt;as&lt;/code&gt; option is disabled now. In other words, the following script is not supported:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 당신이 제공하지 않는 경우 &lt;code&gt;hard limit&lt;/code&gt; 는 &lt;code&gt;soft limit&lt;/code&gt; 두 값에 사용됩니다. &lt;code&gt;ulimits&lt;/code&gt; 를 설정 하지 않으면 디먼에 설정된 기본 &lt;code&gt;ulimits&lt;/code&gt; 에서 상속됩니다 . &lt;code&gt;as&lt;/code&gt; 옵션이 이제 사용되지 않습니다. 즉, 다음 스크립트는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483666ec2880a8afdc70b03520db105621cb9289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you publish a service&amp;rsquo;s ports directly on the swarm node using &lt;code&gt;mode=host&lt;/code&gt; and also set &lt;code&gt;published=&amp;lt;PORT&amp;gt;&lt;/code&gt; this creates an implicit limitation that you can only run one task for that service on a given swarm node. You can work around this by specifying &lt;code&gt;published&lt;/code&gt; without a port definition, which causes Docker to assign a random port for each task.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;mode=host&lt;/code&gt; 를 사용하여 swarm 노드에 서비스 포트를 직접 게시하고 publish &lt;code&gt;published=&amp;lt;PORT&amp;gt;&lt;/code&gt; 설정 하면 지정된 swarm 노드에서 해당 서비스에 대해 하나의 작업 만 실행할 수 있다는 암시 적 제한이 생성됩니다. 포트 정의없이 &lt;code&gt;published&lt;/code&gt; 를 지정하면이 문제를 해결할 수 있습니다. 이렇게 하면 Docker가 각 작업에 임의의 포트를 할당하게됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce6626bbd8ca5791618c2654abbbeb2af7c2e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you use &lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt;, the Docker client resolves image and the swarm manager receives the image and digest, rather than a tag.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt; 를 사용 하면 Docker 클라이언트가 이미지를 확인하고 swarm manager는 태그가 아닌 이미지를 수신하고 요약합니다.</target>
        </trans-unit>
        <trans-unit id="e6210c06d506f4959a35ba5a99a76c71c9296dfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you&amp;rsquo;re using &lt;a href=&quot;../../extends/index#multiple-compose-files&quot;&gt;multiple Compose files&lt;/a&gt; or &lt;a href=&quot;../../extends/index#extending-services&quot;&gt;extending services&lt;/a&gt;, each file must be of the same version - you cannot, for example, mix version 1 and 2 in a single project.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;../../extends/index#multiple-compose-files&quot;&gt;여러 개의 Compose 파일을 사용&lt;/a&gt; 하거나 &lt;a href=&quot;../../extends/index#extending-services&quot;&gt;서비스를 확장하는&lt;/a&gt; 경우 각 파일의 버전이 동일해야합니다 (예 : 단일 프로젝트에서 버전 1과 2를 혼합 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="8b75f484782691421b26f04714624e077c10ebb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you&amp;rsquo;re using an HTTPS encrypted socket, keep in mind that only TLS1.0 and greater are supported. Protocols SSLv3 and under are not supported anymore for security reasons.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : HTTPS 암호화 소켓을 사용하는 경우 TLS1.0 이상 만 지원됩니다. 보안상의 이유로 SSLv3 이하 프로토콜은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed2c7dbc4d199efcef3bd39bd4ad6416dc09db05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your URL files are protected using authentication, you will need to use &lt;code&gt;RUN wget&lt;/code&gt;, &lt;code&gt;RUN curl&lt;/code&gt; or use another tool from within the container as the &lt;code&gt;ADD&lt;/code&gt; instruction does not support authentication.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 인증을 사용하여 URL 파일을 보호하는 경우 &lt;code&gt;ADD&lt;/code&gt; 명령이 인증을 지원하지 않으므로 &lt;code&gt;RUN wget&lt;/code&gt; , &lt;code&gt;RUN curl&lt;/code&gt; 을 사용하거나 컨테이너 내에서 다른 도구를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e06b6ac20194adeb61aa743fbd46a99e114b7c8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your image is stored on a private registry instead of Docker Hub, you need to be logged in using &lt;code&gt;docker login &amp;lt;your-registry&amp;gt;&lt;/code&gt; and then you need to add the &lt;code&gt;--with-registry-auth&lt;/code&gt; flag to the above command. For example:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이미지가 Docker Hub 대신 개인 레지스트리에 저장된 경우 &lt;code&gt;docker login &amp;lt;your-registry&amp;gt;&lt;/code&gt; 를 사용하여 로그인 한 다음 위 명령에 &lt;code&gt;--with-registry-auth&lt;/code&gt; 플래그를 추가해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25a4340aa9746a829e7ec15b32cd323b5279f3f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your new machine is not the active host, connect to it by running &lt;code&gt;docker-machine env aws-sandbox&lt;/code&gt; and the returned eval command: &lt;code&gt;eval $(docker-machine env aws-sandbox)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 새 시스템이 활성 호스트가 아닌 경우 &lt;code&gt;docker-machine env aws-sandbox&lt;/code&gt; 및 &lt;code&gt;eval $(docker-machine env aws-sandbox)&lt;/code&gt; 반환 된 eval 명령 을 실행하여 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="444e762799138a78cc4b90b90c259b82bf45f8eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your only intention is to prevent a service from being deployed, scale the service to 0 instead of trying to configure it in such a way that it remains in &lt;code&gt;pending&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 서비스가 배포되지 않도록하려면 서비스를 &lt;code&gt;pending&lt;/code&gt; 상태로 구성하지 말고 서비스를 0으로 조정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5883b400c3e2f8e71c575fac8f63f18c019eb7b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your service specifies a &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt; option, variables defined in &lt;code&gt;environment&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; automatically visible during the build.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 서비스에서 &lt;a href=&quot;#build&quot;&gt;빌드&lt;/a&gt; 옵션을 지정하면 빌드 중에 &lt;code&gt;environment&lt;/code&gt; 에 정의 된 변수 가 자동으로 표시 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2b4a7277c782eddb1bf4e843b339a86c4869e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your service specifies a &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt; option, variables defined in &lt;code&gt;environment&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; automatically visible during the build. Use the &lt;a href=&quot;#args&quot;&gt;args&lt;/a&gt; sub-option of &lt;code&gt;build&lt;/code&gt; to define build-time environment variables.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 서비스에서 &lt;a href=&quot;#build&quot;&gt;빌드&lt;/a&gt; 옵션을 지정하면 빌드 중에 &lt;code&gt;environment&lt;/code&gt; 에 정의 된 변수 가 자동으로 표시 &lt;em&gt;되지 않습니다&lt;/em&gt; . 사용 &lt;a href=&quot;#args&quot;&gt;인수의&lt;/a&gt; 의 하위 옵션 &lt;code&gt;build&lt;/code&gt; 빌드 타임 환경 변수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="489f7fd5ff3dbf0d488cf64ab1b36bebe07bf110" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your service specifies a &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt; option, variables defined in environment files are &lt;em&gt;not&lt;/em&gt; automatically visible during the build.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 서비스에서 &lt;a href=&quot;#build&quot;&gt;빌드&lt;/a&gt; 옵션을 지정하면 빌드 중에 환경 파일에 정의 된 변수가 자동으로 표시 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff70c114ae2575b10f2d62283a82f919a3aabc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your service specifies a &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt; option, variables defined in environment files are &lt;em&gt;not&lt;/em&gt; automatically visible during the build. Use the &lt;a href=&quot;#args&quot;&gt;args&lt;/a&gt; sub-option of &lt;code&gt;build&lt;/code&gt; to define build-time environment variables.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 서비스에서 &lt;a href=&quot;#build&quot;&gt;빌드&lt;/a&gt; 옵션을 지정하면 빌드 중에 환경 파일에 정의 된 변수가 자동으로 표시 &lt;em&gt;되지 않습니다&lt;/em&gt; . 사용 &lt;a href=&quot;#args&quot;&gt;인수의&lt;/a&gt; 의 하위 옵션 &lt;code&gt;build&lt;/code&gt; 빌드 타임 환경 변수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12653b0bcf8d1cc8802571bf8c1e816835f82ccb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If your swarm has nodes with different Docker versions, the following two things are true:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : swarm에 다른 Docker 버전의 노드가있는 경우 다음 두 가지 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="95d3a5ec81189b4a4303da994004b7541698f797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;version 2 files&lt;/a&gt;, this option only applies to anonymous volumes (those specified in the image, or specified under &lt;code&gt;volumes&lt;/code&gt; without an explicit named volume or host path). To configure the driver for a named volume, use the &lt;code&gt;driver&lt;/code&gt; key under the entry in the &lt;a href=&quot;#volume-configuration-reference&quot;&gt;top-level &lt;code&gt;volumes&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;버전 2 파일&lt;/a&gt; 에서이 옵션은 익명 볼륨 (이미지에 지정되었거나 명시 적으로 명명 된 볼륨 또는 호스트 경로가없는 &lt;code&gt;volumes&lt;/code&gt; 에서 지정된 볼륨)에만 적용됩니다 . 명명 된 볼륨에 대한 드라이버를 구성하려면 &lt;a href=&quot;#volume-configuration-reference&quot;&gt;최상위 &lt;/a&gt; &lt;code&gt;volumes&lt;/code&gt; 옵션 의 항목 아래에서 &lt;code&gt;driver&lt;/code&gt; 키를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1031022d8be7439c1a9c628ad2a5f331cd7890b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In Docker 1.13 and higher, enable experimental features by starting &lt;code&gt;dockerd&lt;/code&gt; with the &lt;code&gt;--experimental&lt;/code&gt; flag or adding &lt;code&gt;&quot;experimental&quot;: true&lt;/code&gt; to the &lt;code&gt;daemon.json&lt;/code&gt; file. In earlier Docker versions, a different build was required to enable experimental features.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 1.13 이상 에서 &lt;code&gt;--experimental&lt;/code&gt; 플래그로 &lt;code&gt;dockerd&lt;/code&gt; 를 시작 하거나 &lt;code&gt;daemon.json&lt;/code&gt; 파일에 &lt;code&gt;&quot;experimental&quot;: true&lt;/code&gt; 를 추가 하여 실험 기능을 사용 하십시오. 이전 Docker 버전에서는 실험 기능을 사용하기 위해 다른 빌드가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="03741c45a14bb20850a3374e67a122d829c902f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In newer versions of Compose, the &lt;code&gt;external.name&lt;/code&gt; property is deprecated in favor of simply using the &lt;code&gt;name&lt;/code&gt; property.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 최신 버전의 Compose에서는 단순히 &lt;code&gt;name&lt;/code&gt; 속성을 사용하기 위해 &lt;code&gt;external.name&lt;/code&gt; 속성이 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e408f257576901da27d2258b191c488963957074" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 file format&lt;/a&gt;, using &lt;a href=&quot;#build&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; together with &lt;code&gt;image&lt;/code&gt; is not allowed. Attempting to do so results in an error.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1 파일 형식&lt;/a&gt; 에서는 &lt;code&gt;image&lt;/code&gt; 와 함께 &lt;a href=&quot;#build&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 사용할 수 없습니다. 이렇게하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d9e923b4a1499e4fdf7a307412fc084bc801468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the &lt;em&gt;JSON&lt;/em&gt; form, it is necessary to escape backslashes. This is particularly relevant on Windows where the backslash is the path separator. The following line would otherwise be treated as &lt;em&gt;shell&lt;/em&gt; form due to not being valid JSON, and fail in an unexpected way: &lt;code&gt;RUN [&quot;c:\windows\system32\tasklist.exe&quot;]&lt;/code&gt; The correct syntax for this example is: &lt;code&gt;RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;JSON&lt;/em&gt; 형식에서는 백 슬래시를 이스케이프해야합니다. 이것은 백 슬래시가 경로 구분 기호 인 Windows에서 특히 관련이 있습니다. 그렇지 않으면 다음 행은 유효한 JSON이 아니기 때문에 &lt;em&gt;쉘&lt;/em&gt; 형식으로 처리되며 예기치 않은 방식으로 실패합니다. &lt;code&gt;RUN [&quot;c:\windows\system32\tasklist.exe&quot;]&lt;/code&gt; 이 예제의 올바른 구문은 다음과 같습니다. &lt;code&gt;RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b2b99cd41cad0142a3059594c1bca8732d1beb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the above example output, there is a hidden column of &lt;code&gt;.Self&lt;/code&gt; that indicates if the node is the same node as the current docker daemon. A &lt;code&gt;*&lt;/code&gt; (e.g., &lt;code&gt;e216jshn25ckzbvmwlnh5jr3g *&lt;/code&gt;) means this node is the current docker daemon.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 위의 출력 예 에는 노드가 현재 docker 데몬과 동일한 노드인지 나타내는 &lt;code&gt;.Self&lt;/code&gt; 의 숨겨진 열이 있습니다. &lt;code&gt;*&lt;/code&gt; (예 &lt;code&gt;e216jshn25ckzbvmwlnh5jr3g *&lt;/code&gt; 는 )이 노드가 현재 고정 표시기 데몬 의미한다.</target>
        </trans-unit>
        <trans-unit id="e53462e0c991e1f3a282f5d9aec894c2aae0d89a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In this example, we use port &lt;code&gt;8000&lt;/code&gt; which we added to the docker-machine AWS Security Group during &lt;code&gt;docker-machine create&lt;/code&gt;. To run your container on another port, update the security group to reflect that.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예에서는 &lt;code&gt;docker-machine create&lt;/code&gt; 동안 docker-machine AWS Security Group에 추가 한 포트 &lt;code&gt;8000&lt;/code&gt; 을 사용 합니다. 다른 포트에서 컨테이너를 실행하려면 보안 그룹을 업데이트하여 해당 포트를 반영하십시오.</target>
        </trans-unit>
        <trans-unit id="dca29ec00af8d5205fa6a0739643091d193665b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In your Dockerfile, if you specify &lt;code&gt;ARG&lt;/code&gt; before the &lt;code&gt;FROM&lt;/code&gt; instruction, &lt;code&gt;ARG&lt;/code&gt; is not available in the build instructions under &lt;code&gt;FROM&lt;/code&gt;. If you need an argument to be available in both places, also specify it under the &lt;code&gt;FROM&lt;/code&gt; instruction. See &lt;a href=&quot;../../engine/reference/builder/index#understand-how-arg-and-from-interact&quot;&gt;Understand how ARGS and FROM interact&lt;/a&gt; for usage details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 사용자가 지정한 경우 Dockerfile에서, &lt;code&gt;ARG&lt;/code&gt; 를 전과 &lt;code&gt;FROM&lt;/code&gt; 명령, &lt;code&gt;ARG&lt;/code&gt; 는 아래의 빌드 지침에서 사용할 수 없습니다 &lt;code&gt;FROM&lt;/code&gt; . 두 위치 모두에서 인수를 사용할 수 있어야하는 경우 &lt;code&gt;FROM&lt;/code&gt; 명령 에서 인수를 지정하십시오 . 사용법에 대한 자세한 내용은 &lt;a href=&quot;../../engine/reference/builder/index#understand-how-arg-and-from-interact&quot;&gt;ARGS와 FROM의 상호 작용 이해를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c12d60dd41dac6899e77298ba326d89c05e37298" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In your Dockerfile, if you specify &lt;code&gt;ARG&lt;/code&gt; before the &lt;code&gt;FROM&lt;/code&gt; instruction, If you need an argument to be available in both places, also specify it under the &lt;code&gt;FROM&lt;/code&gt; instruction. See &lt;a href=&quot;../../../engine/reference/builder/index#understand-how-arg-and-from-interact&quot;&gt;Understand how ARGS and FROM interact&lt;/a&gt; for usage details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 당신의 Dockerfile, 당신은 지정하면 &lt;code&gt;ARG&lt;/code&gt; 를 전과 &lt;code&gt;FROM&lt;/code&gt; 당신이 두 곳 모두에서 사용할 수 인수를해야하는 경우도, 지시 세 이하를 지정 &lt;code&gt;FROM&lt;/code&gt; 명령. 사용법에 대한 자세한 내용은 &lt;a href=&quot;../../../engine/reference/builder/index#understand-how-arg-and-from-interact&quot;&gt;ARGS와 FROM의 상호 작용 이해를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8aed1bf4bd99360849ee0ed84c4c13533f62f571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Network information is not shown because it doesn&amp;rsquo;t consume the disk space.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 네트워크 정보는 디스크 공간을 소비하지 않기 때문에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="934e7619247f847ff3e03e8b0fc000a925fc67a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Normally you would create a Dockerfile which copies the &lt;code&gt;site.conf&lt;/code&gt; into place, build the image, and run a container using your custom image. This example does not require a custom image. It puts the &lt;code&gt;site.conf&lt;/code&gt; into place and runs the container all in one step.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 일반적으로 당신이 어떤 사본은 A Dockerfile 만들 것 &lt;code&gt;site.conf&lt;/code&gt; , 제자리를 이미지를 구축하고, 사용자 정의 이미지를 사용하여 컨테이너를 실행합니다. 이 예에는 사용자 정의 이미지가 필요하지 않습니다. 그것은두고 &lt;code&gt;site.conf&lt;/code&gt; 을 제자리에 모두 한 번에 컨테이너를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8a77ab2457ff28e22f35da5d5ae5cd3550f9d124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Not all sysctls are namespaced. Docker does not support changing sysctls inside of a container that also modify the host system. As the kernel evolves we expect to see more sysctls become namespaced.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 모든 sysctls가 네임 스페이스 인 것은 아닙니다. Docker는 호스트 시스템도 수정하는 컨테이너 내부의 sysctls 변경을 지원하지 않습니다. 커널이 발전함에 따라 더 많은 sysctls가 네임 스페이스가 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="fd2d1cdc40aeb9ea894f35c61bc5091100d7d248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On Docker 17.09 and older, the &lt;code&gt;{{.Container}}&lt;/code&gt; column was used, instead of &lt;code&gt;{{.ID}}\t{{.Name}}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker 17.09 이전에서는 &lt;code&gt;{{.ID}}\t{{.Name}}&lt;/code&gt; 대신 &lt;code&gt;{{.Container}}&lt;/code&gt; 열이 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e4a373912b5bf1cdc4a66f6c78b37bef09d4c634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On Linux, the Docker CLI reports memory usage by subtracting page cache usage from the total memory usage. The API does not perform such a calculation but rather provides the total memory usage and the amount from the page cache so that clients can use the data as needed.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Linux에서 Docker CLI는 총 메모리 사용량에서 페이지 캐시 사용량을 빼서 메모리 사용량을보고합니다. API는 이러한 계산을 수행하지 않고 클라이언트가 필요에 따라 데이터를 사용할 수 있도록 총 메모리 사용량과 페이지 캐시의 양을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e9b7b536533dd3d55ebc357987556aeffb43660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On Windows Server 2019, you can add the Compose executable to &lt;code&gt;$Env:ProgramFiles\Docker&lt;/code&gt;. Because this directory is registered in the system &lt;code&gt;PATH&lt;/code&gt;, you can run the &lt;code&gt;docker-compose --version&lt;/code&gt; command on the subsequent step with no additional configuration.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Windows Server 2019에서는 &lt;code&gt;$Env:ProgramFiles\Docker&lt;/code&gt; Compose 실행 파일을 추가 할 수 있습니다 . 이 디렉토리는 시스템 &lt;code&gt;PATH&lt;/code&gt; 에 등록되어 있으므로 추가 구성없이 후속 단계 에서 &lt;code&gt;docker-compose --version&lt;/code&gt; 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4127535848756ac5aa6fd1f79dc166338ad468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On version of Ubuntu &amp;gt; 14.04 this is all fine and well, but Trusty users might run into some issues when trying to &lt;code&gt;docker container exec&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Ubuntu&amp;gt; 14.04 버전에서는 문제가 없지만 잘 작동하지만 신뢰할 수있는 사용자는 &lt;code&gt;docker container exec&lt;/code&gt; 시도 할 때 몇 가지 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="330c35b2e56a36fd93e9e2d3595cd52920ce87c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Only supported for v3.2 and higher.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : v3.2 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1fd3fa77109b1be6d0d50afb81cf513a3ff00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Only the &lt;code&gt;json-file&lt;/code&gt; and &lt;code&gt;journald&lt;/code&gt; drivers make the logs available directly from &lt;code&gt;docker-compose up&lt;/code&gt; and &lt;code&gt;docker-compose logs&lt;/code&gt;. Using any other driver does not print any logs.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;json-file&lt;/code&gt; 및 &lt;code&gt;journald&lt;/code&gt; 드라이버 만 &lt;code&gt;docker-compose up&lt;/code&gt; 및 &lt;code&gt;docker-compose logs&lt;/code&gt; 에서 직접 로그를 사용할 수 있습니다 . 다른 드라이버를 사용해도 로그가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f63e43080b60d4b8e55089fcf3389f489756442" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing &lt;code&gt;--entrypoint&lt;/code&gt; will clear out any default command set on the image (i.e. any &lt;code&gt;CMD&lt;/code&gt; instruction in the Dockerfile used to build it).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--entrypoint&lt;/code&gt; 를 전달 하면 이미지에 설정된 기본 명령 (즉 , Dockerfile에서 &lt;code&gt;CMD&lt;/code&gt; 명령을 빌드하는 데 사용되는 모든 명령) 이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="85c449c8e7c3c07119e54256fc4d71012d707aaf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Port mapping is incompatible with &lt;code&gt;network_mode: host&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 포트 매핑은 &lt;code&gt;network_mode: host&lt;/code&gt; 와 호환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="15d6dfe97f0577699b034a904c76c8271d702787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Prior to Docker Engine 1.11, the snapshot key was also generated and stored locally client-side. &lt;a href=&quot;../../../../notary/advanced_usage/index#rotate-keys&quot;&gt;Use the Notary CLI to manage your snapshot key locally again&lt;/a&gt; for repositories created with newer versions of Docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker Engine 1.11 이전에는 스냅 샷 키가 생성되어 로컬 클라이언트 측에 저장되었습니다. 최신 버전의 Docker로 생성 된 리포지토리에 &lt;a href=&quot;../../../../notary/advanced_usage/index#rotate-keys&quot;&gt;대해 Notary CLI를 사용하여 스냅 샷 키를 다시 로컬로 관리하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d79aa1c83579414c35d7b10e03a745ace9fc777" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Regardless of your reason to promote or demote a node, you must always maintain a quorum of manager nodes in the swarm. For more information refer to the &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm administration guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 노드를 승격 시키거나 강등시키는 이유에 관계없이 항상 웜에 관리자 쿼럼 관리자 노드를 유지해야합니다. 자세한 내용은 &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm 관리 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dfef6fd107de84c64a31147501f7e50a548b76b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Replace all instances of &lt;code&gt;$HOST&lt;/code&gt; in the following example with the DNS name of your Docker daemon&amp;rsquo;s host.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 다음 예제에서 &lt;code&gt;$HOST&lt;/code&gt; 의 모든 인스턴스를 Docker 데몬 호스트의 DNS 이름으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="9a67c7b9e9bbef95c5c66f11cfea52dfb978da57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Running Windows containers? View our &lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;Windows Server setup guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Windows 컨테이너를 실행 중입니까? 우리의보기 &lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;윈도우 서버 설치 가이드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8f714c417142e6515a04f26694771c20812c671" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Search queries return a maximum of 25 results.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 검색어는 최대 25 개의 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eca4f07ee42427db4986f32b67c556b330078f3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: See &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Use volumes&lt;/a&gt; and &lt;a href=&quot;../../engine/extend/plugins_volume/index&quot;&gt;Volume Plugins&lt;/a&gt; for general information on volumes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;볼륨에&lt;/a&gt; 대한 일반적인 정보는 볼륨 및 &lt;a href=&quot;../../engine/extend/plugins_volume/index&quot;&gt;볼륨 플러그인 &lt;/a&gt;사용을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8c0e169161a81a91e3d2de59e55decdd7b597d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Service discovery is unavailable on the default bridge network. Containers can communicate via their IP addresses by default. To communicate by name, they must be linked.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 기본 브리지 네트워크에서는 서비스 검색을 사용할 수 없습니다. 컨테이너는 기본적으로 IP 주소를 통해 통신 할 수 있습니다. 이름으로 통신하려면 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6df5a02c8fb7f78198e4aca4b433a25d4a00360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Setting &lt;code&gt;entrypoint&lt;/code&gt; both overrides any default entrypoint set on the service&amp;rsquo;s image with the &lt;code&gt;ENTRYPOINT&lt;/code&gt; Dockerfile instruction, &lt;em&gt;and&lt;/em&gt; clears out any default command on the image - meaning that if there&amp;rsquo;s a &lt;code&gt;CMD&lt;/code&gt; instruction in the Dockerfile, it is ignored.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 설정 &lt;code&gt;entrypoint&lt;/code&gt; 모두 무시 어떤 기본 엔트리 포인트 상기와 서비스의 이미지를 설정 &lt;code&gt;ENTRYPOINT&lt;/code&gt; Dockerfile 명령, &lt;em&gt;및&lt;/em&gt; 이미지에 어떤 기본 명령 클리어 -가 있다면 의미 &lt;code&gt;CMD&lt;/code&gt; 의 Dockerfile의 지시가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d22036e840ed2f51a060e744298b356c73aaeaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Since only &lt;code&gt;path&lt;/code&gt; is settable in &lt;code&gt;mydevice&lt;/code&gt;, &lt;code&gt;docker plugins set mydevice=/dev/bar myplugin&lt;/code&gt; would work too.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 단지 때문에 &lt;code&gt;path&lt;/code&gt; 에서 설정 가능하다 &lt;code&gt;mydevice&lt;/code&gt; , &lt;code&gt;docker plugins set mydevice=/dev/bar myplugin&lt;/code&gt; 도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f8ead8a866b35fe0a2350eedd5c1baf88c8a8f60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Since only &lt;code&gt;source&lt;/code&gt; is settable in &lt;code&gt;mymount&lt;/code&gt;, &lt;code&gt;docker plugins set mymount=/bar myplugin&lt;/code&gt; would work too.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 만 있기 때문에 &lt;code&gt;source&lt;/code&gt; 에서 설정 가능하다 &lt;code&gt;mymount&lt;/code&gt; , &lt;code&gt;docker plugins set mymount=/bar myplugin&lt;/code&gt; 도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="327c6f184f1de0aaf220ebe26aac7215fe91a175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Some configuration options are not yet supported in the DAB format, including volume mounts.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 볼륨 마운트를 포함한 일부 구성 옵션은 아직 DAB 형식으로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5015230e164db4b6926687635a10a15f5ebcd149" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Some of these variables can also be provided using an &lt;a href=&quot;../../env-file/index&quot;&gt;environment file&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; : 이러한 변수 중 일부는 &lt;a href=&quot;../../env-file/index&quot;&gt;환경 파일을&lt;/a&gt; 사용하여 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d18f776701fb6c2e00881cdd59a9a5ee4b340b42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Technically, the Engine terminates a pull operation when the connection between the Docker Engine daemon and the Docker Engine client initiating the pull is lost. If the connection with the Engine daemon is lost for other reasons than a manual interaction, the pull is also aborted.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 기술적으로 Docker Engine 데몬과 끌어 오기를 시작하는 Docker Engine 클라이언트 간의 연결이 끊어지면 엔진이 끌어 오기 작업을 종료합니다. 수동 상호 작용 이외의 이유로 엔진 데몬과의 연결이 끊어지면 풀도 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="6d91748032bfc6dc0dc18d47a4c8ce8f88d5aa60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;--chown&lt;/code&gt; feature is only supported on Dockerfiles used to build Linux containers, and will not work on Windows containers. Since user and group ownership concepts do not translate between Linux and Windows, the use of &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/group&lt;/code&gt; for translating user and group names to IDs restricts this feature to only be viable for Linux OS-based containers.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--chown&lt;/code&gt; 기능은 Linux 컨테이너를 빌드하는 데 사용되는 Dockerfile에서만 지원되며 Windows 컨테이너에서는 작동하지 않습니다. 사용자 및 그룹 소유권 개념은 Linux와 Windows간에 변환되지 않으므로 사용자 및 그룹 이름을 ID로 변환하기 위해 &lt;code&gt;/etc/passwd&lt;/code&gt; 및 &lt;code&gt;/etc/group&lt;/code&gt; 을 사용하면이 기능이 Linux OS 기반 컨테이너에서만 실행 가능하도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="465ad87abdc4fb6a9fc06829647256c5d2447f28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;--rm&lt;/code&gt; removes the container and its image when the container exits successfully.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--rm&lt;/code&gt; 은 컨테이너가 성공적으로 종료되면 컨테이너와 이미지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0366b4a053b820d1e38beb68562d4212e9cdb3ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;--volumes&lt;/code&gt; option was added in Docker 17.06.1. Older versions of Docker prune volumes by default, along with other Docker objects. On older versions, run &lt;code&gt;docker container prune&lt;/code&gt;, &lt;code&gt;docker network prune&lt;/code&gt;, and &lt;code&gt;docker image prune&lt;/code&gt; separately to remove unused containers, networks, and images, without removing volumes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--volumes&lt;/code&gt; 옵션은 Docker 17.06.1에 추가되었습니다. 이전 버전의 Docker는 기본적으로 다른 Docker 객체와 함께 볼륨을 정리합니다. 이전 버전에서는 &lt;code&gt;docker container prune&lt;/code&gt; , &lt;code&gt;docker network prune&lt;/code&gt; 및 &lt;code&gt;docker image prune&lt;/code&gt; 을 별도로 실행하여 볼륨을 제거하지 않고 사용하지 않는 컨테이너, 네트워크 및 이미지를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="8a39298498f717e8c88604f0a822dfa8120cf8f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;PIDS&lt;/code&gt; column contains the number of processes and kernel threads created by that container. Threads is the term used by Linux kernel. Other equivalent terms are &amp;ldquo;lightweight process&amp;rdquo; or &amp;ldquo;kernel task&amp;rdquo;, etc. A large number in the &lt;code&gt;PIDS&lt;/code&gt; column combined with a small number of processes (as reported by &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt;) may indicate that something in the container is creating many threads.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;PIDS&lt;/code&gt; 열에는 해당 컨테이너에서 생성 한 프로세스 및 커널 스레드 수가 포함됩니다. 스레드는 Linux 커널에서 사용하는 용어입니다. 다른 동등한 용어는 &quot;가벼운 프로세스&quot;또는 &quot;커널 작업&quot;등입니다. &lt;code&gt;PIDS&lt;/code&gt; 열에 많은 수의 프로세스 ( &lt;code&gt;ps&lt;/code&gt; 또는 &lt;code&gt;top&lt;/code&gt; 에 의해보고 됨 )가 결합되면 컨테이너의 무언가가 많은 스레드를 생성하고 있음을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee22f5d13b8d8cbd6d453bfe3db15993da17578" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;extends&lt;/code&gt; keyword is supported in earlier Compose file formats up to Compose file version 2.1 (see &lt;a href=&quot;../compose-file/compose-file-v1/index#extends&quot;&gt;extends in v1&lt;/a&gt; and &lt;a href=&quot;../compose-file/compose-file-v2/index#extends&quot;&gt;extends in v2&lt;/a&gt;), but is not supported in Compose version 3.x. See the &lt;a href=&quot;../compose-file/compose-versioning/index#version-3&quot;&gt;Version 3 summary&lt;/a&gt; of keys added and removed, along with information on &lt;a href=&quot;../compose-file/compose-versioning/index#upgrading&quot;&gt;how to upgrade&lt;/a&gt;. See &lt;a href=&quot;https://github.com/moby/moby/issues/31101&quot;&gt;moby/moby#31101&lt;/a&gt; to follow the discussion thread on possibility of adding support for &lt;code&gt;extends&lt;/code&gt; in some form in future versions.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;extends&lt;/code&gt; 키워드는 이전 Compose 파일 형식에서 Compose 파일 버전 2.1 ( &lt;a href=&quot;../compose-file/compose-file-v1/index#extends&quot;&gt;v1&lt;/a&gt; 에서 &lt;a href=&quot;../compose-file/compose-file-v2/index#extends&quot;&gt;확장&lt;/a&gt; 및 v2에서 확장 참조 )에서 지원되지만 Compose 버전 3.x에서는 지원되지 않습니다. &lt;a href=&quot;../compose-file/compose-versioning/index#upgrading&quot;&gt;업그레이드 방법&lt;/a&gt; 에 대한 정보와 함께 추가 및 제거 된 키 의 &lt;a href=&quot;../compose-file/compose-versioning/index#version-3&quot;&gt;버전 3 요약&lt;/a&gt; 을 참조하십시오 . 향후 버전에서 &lt;code&gt;extends&lt;/code&gt; 에 대한 지원을 추가 할 가능성에 대한 토론 스레드를 따르려면 &lt;a href=&quot;https://github.com/moby/moby/issues/31101&quot;&gt;moby / moby # 31101&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ce5b562808c66c91c7aa5296941a80da45bc2c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;start_period&lt;/code&gt; option is a more recent feature and is only available with the &lt;a href=&quot;../compose-versioning/index#version-23&quot;&gt;2.3 file format&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;start_period&lt;/code&gt; 옵션은 최신 기능이며 &lt;a href=&quot;../compose-versioning/index#version-23&quot;&gt;2.3 파일 형식&lt;/a&gt; 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0f85ce6aa27b05326b0b5062757b45f759d6a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;em&gt;exec&lt;/em&gt; form is parsed as a JSON array, which means that you must use double-quotes (&amp;ldquo;) around words not single-quotes (&amp;lsquo;).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;exec&lt;/em&gt; 양식은 JSON 배열로 구문 분석되므로 작은 따옴표 ( ')가 아닌 단어 주위에 큰 따옴표 (&amp;ldquo;)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a3cc1847b0a8d9258867747694b7dedaf1b2579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The WordPress site is not immediately available on port &lt;code&gt;8000&lt;/code&gt; because the containers are still being initialized and may take a couple of minutes before the first load.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 컨테이너가 아직 초기화되고 있으며 첫 번째로드까지 몇 분이 걸릴 수 있으므로 포트 &lt;code&gt;8000&lt;/code&gt; 에서 WordPress 사이트를 즉시 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b96b0744c978702d6462ce9abbad9050239e647e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The config must already exist or be &lt;a href=&quot;#configs-configuration-reference&quot;&gt;defined in the top-level &lt;code&gt;configs&lt;/code&gt; configuration&lt;/a&gt; of this stack file, or stack deployment fails.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 구성이 이미 존재 &lt;a href=&quot;#configs-configuration-reference&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt; 스택 파일의 최상위 구성 구성 에 정의되어 있어야 합니다. 그렇지 않으면 스택 배치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e4a6fdb6faca6cd116929bd690c18db826e43085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The directory itself is not copied, just its contents.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 디렉토리 자체는 내용 만 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d606df431ecd765df311ef29ce0a4f3a75ee84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The first encountered &lt;code&gt;ADD&lt;/code&gt; instruction will invalidate the cache for all following instructions from the Dockerfile if the contents of &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; have changed. This includes invalidating the cache for &lt;code&gt;RUN&lt;/code&gt; instructions. See the &lt;a href=&quot;https://docs.docker.com/develop/develop-images#/build-cache&quot;&gt;&lt;code&gt;Dockerfile&lt;/code&gt; Best Practices guide&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 의 내용 이 변경된 경우 처음 발견 된 &lt;code&gt;ADD&lt;/code&gt; 명령은 Dockerfile에서 다음의 모든 명령에 대한 캐시를 무효화합니다 . 여기에는 &lt;code&gt;RUN&lt;/code&gt; 명령에 대한 캐시 무효화가 포함됩니다 . 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/develop/develop-images#/build-cache&quot;&gt; &lt;code&gt;Dockerfile&lt;/code&gt; &lt;/a&gt; 모범 사례 안내서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb5dcd6c9192afbd8e4eba3452ad7a816696cbc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The following options were added in &lt;a href=&quot;../compose-versioning/index#version-22&quot;&gt;version 2.2&lt;/a&gt;: &lt;code&gt;cpu_count&lt;/code&gt;, &lt;code&gt;cpu_percent&lt;/code&gt;, &lt;code&gt;cpus&lt;/code&gt;. The following options were added in &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt;: &lt;code&gt;oom_kill_disable&lt;/code&gt;, &lt;code&gt;cpu_period&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 다음 옵션이 &lt;a href=&quot;../compose-versioning/index#version-22&quot;&gt;버전 2.2에&lt;/a&gt; 추가되었습니다 : &lt;code&gt;cpu_count&lt;/code&gt; , &lt;code&gt;cpu_percent&lt;/code&gt; , &lt;code&gt;cpus&lt;/code&gt; . 다음 옵션이 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;버전 2.1에&lt;/a&gt; 추가되었습니다 . &lt;code&gt;oom_kill_disable&lt;/code&gt; , &lt;code&gt;cpu_period&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c51fbd70a5d544b5056972771f93bfbb19b23ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The ideal is to pursue a &lt;code&gt;docker&lt;/code&gt; daemon and environment that does support synchronizing with &lt;code&gt;udev&lt;/code&gt;. For further discussion on this topic, see &lt;a href=&quot;https://github.com/docker/docker/issues/4036&quot;&gt;docker#4036&lt;/a&gt;. Otherwise, set this flag for migrating existing Docker daemons to a daemon with a supported environment.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; : 이상적인 것은 &lt;code&gt;udev&lt;/code&gt; 와의 동기화를 지원 하는 &lt;code&gt;docker&lt;/code&gt; 데몬 및 환경 을 추구하는 것입니다 . 이 주제에 대한 자세한 설명은 &lt;a href=&quot;https://github.com/docker/docker/issues/4036&quot;&gt;docker # 4036을&lt;/a&gt; 참조하십시오 . 그렇지 않으면 기존 Docker 데몬을 지원되는 환경의 데몬으로 마이그레이션하려면이 플래그를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fdbc592cdb0221c878e4ebd7579098479a564af9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The implicit pulls and runs performed by worker nodes for a &lt;a href=&quot;../../../swarm/services/index&quot;&gt;Swarm service&lt;/a&gt; on &lt;code&gt;$ docker service create&lt;/code&gt; and &lt;code&gt;$ docker service update&lt;/code&gt; are also verified. Tag resolution of services requires that all nodes in the Swarm including managers have content trust enabled and similarly configured.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;$ docker service create&lt;/code&gt; 및 &lt;code&gt;$ docker service update&lt;/code&gt; 의 &lt;a href=&quot;../../../swarm/services/index&quot;&gt;Swarm 서비스&lt;/a&gt; 에 대해 작업자 노드가 수행하는 암시 적 끌어 오기 및 실행 도 확인됩니다. 서비스의 태그 확인을 위해서는 관리자를 포함한 Swarm의 모든 노드에 컨텐츠 신뢰가 활성화되고 유사하게 구성되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c766b27aebabffd966cc1260ed30dffaa1edf5f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The instructions in this section refer to &lt;a href=&quot;../swarm/index&quot;&gt;legacy Docker Swarm&lt;/a&gt; operations, and only work when targeting a legacy Swarm cluster. For instructions on deploying a compose project to the newer integrated swarm mode, consult the &lt;a href=&quot;../bundles/index&quot;&gt;Docker Stacks&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 섹션의 지침은 &lt;a href=&quot;../swarm/index&quot;&gt;레거시 Docker Swarm&lt;/a&gt; 작업을 나타내며 레거시 Swarm 클러스터를 대상으로하는 경우에만 작동합니다. 최신 통합 웜 모드에 작성 프로젝트를 배포하는 방법에 대한 지침은 &lt;a href=&quot;../bundles/index&quot;&gt;Docker Stacks&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7b808ba74bf7f12f6bd0288cc343f67a1bb8037" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The long syntax is new in v3.2</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 긴 구문은 v3.2의 새로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="314474d42346ac44b76ec1994ef64759c03477a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The new node uses the same encryption key for on-disk storage as the old one. It is not possible to change the on-disk storage encryption keys at this time.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 새 노드는 온 디스크 스토리지에 이전과 동일한 암호화 키를 사용합니다. 현재 온 디스크 스토리지 암호화 키를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fa19546218955bb27a05393c980b17f83916621" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The older form of this syntax is a colon-separated string, where the published port is first and the target port is second, such as &lt;code&gt;-p 8080:80&lt;/code&gt;. The new syntax is preferred because it is easier to read and allows more flexibility.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 구문의 이전 형식은 콜론으로 구분 된 문자열이며, 게시 된 포트는 첫 번째이고 대상 포트는 두 번째입니다 (예 : &lt;code&gt;-p 8080:80&lt;/code&gt; ) . 새로운 구문은 읽기 쉽고 유연성이 뛰어나므로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="802d42a52717d37135abbfd90b80e7027c0c210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The secret must already exist or be &lt;a href=&quot;#secrets-configuration-reference&quot;&gt;defined in the top-level &lt;code&gt;secrets&lt;/code&gt; configuration&lt;/a&gt; of this stack file, or stack deployment fails.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 비밀이 이미 존재 &lt;a href=&quot;#secrets-configuration-reference&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 스택 파일의 최상위 비밀 구성 에 정의되어 있어야 합니다. 그렇지 않으면 스택 배치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7840cbb08655bb5f110c892a76dc8e6e939b6f50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The top-level &lt;a href=&quot;#volume-configuration-reference&quot;&gt;volumes&lt;/a&gt; key defines a named volume and references it from each service&amp;rsquo;s &lt;code&gt;volumes&lt;/code&gt; list. This replaces &lt;code&gt;volumes_from&lt;/code&gt; in earlier versions of the Compose file format. See &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Use volumes&lt;/a&gt; and &lt;a href=&quot;../../engine/extend/plugins_volume/index&quot;&gt;Volume Plugins&lt;/a&gt; for general information on volumes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 최상위 &lt;a href=&quot;#volume-configuration-reference&quot;&gt;볼륨&lt;/a&gt; 키는 명명 된 볼륨을 정의하고 각 서비스의 &lt;code&gt;volumes&lt;/code&gt; 목록 에서이를 참조 합니다. 이전 버전의 Compose 파일 형식에서 &lt;code&gt;volumes_from&lt;/code&gt; 을 대체 합니다. &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;볼륨에&lt;/a&gt; 대한 일반 정보는 볼륨 및 &lt;a href=&quot;../../engine/extend/plugins_volume/index&quot;&gt;볼륨 플러그인 &lt;/a&gt;사용을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8bc235b2924f4e65c3b35f98f03eba082b9ab85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is currently no way to deploy a plugin to a swarm using the Docker CLI or Docker Compose. In addition, it is not possible to install plugins from a private repository.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 Docker CLI 또는 Docker Compose를 사용하여 플러그인을 웜에 배포하는 방법이 없습니다. 또한 개인 저장소에서 플러그인을 설치할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="984ee8355d3d6ed56911a38d68b626d3e0d36b89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is technically no reason to use secrets for this example. With Docker 17.06 and higher, &lt;a href=&quot;../configs/index&quot;&gt;configs&lt;/a&gt; are a better fit. This example is for illustration only.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예에서는 비밀을 사용할 이유가 없습니다. Docker 17.06 이상에서는 &lt;a href=&quot;../configs/index&quot;&gt;구성&lt;/a&gt; 이 더 적합합니다. 이 예는 설명을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="43b0067b3f4577746a8e8bde5356ae5f1f3642d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: These TLS commands only generate a working set of certificates on Linux. The version of OpenSSL in macOS is incompatible with the type of certificate Docker requires.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 TLS 명령은 Linux에서 작동하는 인증서 세트 만 생성합니다. macOS의 OpenSSL 버전이 Docker에 필요한 인증서 유형과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d46dd39020f7fbaa5a4e4af0f2703f576a35fa51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: These examples use a single-Engine swarm and unscaled services for simplicity. The examples use Linux containers, but Windows containers also support configs.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 단순성을 위해 단일 엔진 스웜 및 비 스케일 서비스를 사용합니다. 예제는 Linux 컨테이너를 사용하지만 Windows 컨테이너도 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f517a6aad0c5e55c37e8bb4baf9d678333447427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: These examples use a single-Engine swarm and unscaled services for simplicity. The examples use Linux containers, but Windows containers also support secrets in Docker 17.06 and higher. See &lt;a href=&quot;#windows-support&quot;&gt;Windows support&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 단순성을 위해 단일 엔진 스웜 및 비 스케일 서비스를 사용합니다. 예제는 Linux 컨테이너를 사용하지만 Windows 컨테이너는 Docker 17.06 이상에서도 비밀을 지원합니다. &lt;a href=&quot;#windows-support&quot;&gt;Windows 지원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="636755a6512a5f305bfbc70ea22abc1c64a07065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: These options are ignored when &lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3) 작성 파일을 사용 &lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="91907b1118633584263212489ce8461f38d9b19b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: These options are ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e136ed5d2dc9ffedf0db0e980a3f1ef53a70b5f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This PostgreSQL setup is for development-only purposes. Refer to the PostgreSQL documentation to fine-tune these settings so that it is suitably secure.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 PostgreSQL 설정은 개발 전용입니다. 이러한 설정이 적절하게 보안되도록 PostgreSQL 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ea89846ef9e1d4d235869e176a9c9dfdcf986e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This command is deprecated. Use the &lt;a href=&quot;../up/index&quot;&gt;up&lt;/a&gt; command with the &lt;code&gt;--scale&lt;/code&gt; flag instead. Beware that using &lt;code&gt;up&lt;/code&gt; with &lt;code&gt;--scale&lt;/code&gt; flag has some &lt;a href=&quot;https://github.com/docker/compose/issues/5251&quot;&gt;subtle differences&lt;/a&gt; with the &lt;code&gt;scale&lt;/code&gt; command as it incorporates the behaviour of &lt;code&gt;up&lt;/code&gt; command.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 명령은 더 이상 사용되지 않습니다. 대신 &lt;code&gt;--scale&lt;/code&gt; 플래그 와 함께 &lt;a href=&quot;../up/index&quot;&gt;up&lt;/a&gt; 명령을 사용하십시오 . 사용하는 것을주의 &lt;code&gt;up&lt;/code&gt; 로 &lt;code&gt;--scale&lt;/code&gt; 플래그 것은 몇 가지가 &lt;a href=&quot;https://github.com/docker/compose/issues/5251&quot;&gt;미묘한 차이&lt;/a&gt; 와 &lt;code&gt;scale&lt;/code&gt; 가의 동작 통합으로 명령을 &lt;code&gt;up&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d8dedbde92c70347bdf36e5def5c5b649eeadb3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This command is only functional for services that are started with the &lt;code&gt;json-file&lt;/code&gt; or &lt;code&gt;journald&lt;/code&gt; logging driver.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 명령은 &lt;code&gt;json-file&lt;/code&gt; 또는 &lt;code&gt;journald&lt;/code&gt; 로깅 드라이버 로 시작된 서비스에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7a094be29cc565b2d5a3cf01ad42bc48ca52ef47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This documentation is for the new version of the Azure driver, which started shipping with v0.7.0. This driver is not backwards-compatible with the old Azure driver. If you want to continue managing your existing Azure machines, please download and use machine versions prior to v0.7.0.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 설명서는 v0.7.0과 함께 제공되는 새로운 버전의 Azure 드라이버 용입니다. 이 드라이버는 이전 Azure 드라이버와 호환되지 않습니다. 기존 Azure 컴퓨터를 계속 관리하려면 v0.7.0 이전의 컴퓨터 버전을 다운로드하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfe386a965379d6e5f31788a54894b602d9c599" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This example does not rotate the MySQL &lt;code&gt;root&lt;/code&gt; password.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 MySQL &lt;code&gt;root&lt;/code&gt; 비밀번호를 교체하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd4979e5615d1757fe97dba011dc152d5b54832d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This example is intended for instructional purposes only. Once the volume is created, your SSH password to the remote host will be exposed as plaintext when inspecting the volume. You should delete the volume as soon as you are done with the example.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예는 설명을위한 것입니다. 볼륨이 생성되면 볼륨을 검사 할 때 원격 호스트에 대한 SSH 암호가 일반 텍스트로 노출됩니다. 예제를 마치면 바로 볼륨을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd3712da96517decb9f350f6973905aaf355e857" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This example uses a single-Engine swarm for simplicity, and uses a single-node MySQL service because a single MySQL server instance cannot be scaled by simply using a replicated service, and setting up a MySQL cluster is beyond the scope of this example.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 단순성을 위해 단일 엔진 스웜을 사용하고 단일 서비스 MySQL 서버 인스턴스는 단순히 복제 된 서비스를 사용하여 확장 할 수 없으므로 MySQL 클러스터 설정은이 예제의 범위를 벗어납니다. .</target>
        </trans-unit>
        <trans-unit id="959902d4aa55cde3ca4bf3d09a063777b635e852" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a modified copy of the &lt;a href=&quot;https://github.com/moby/moby/blob/v1.12.0-rc4/experimental/docker-stacks-and-bundles/&quot;&gt;Docker Stacks and Distributed Application Bundles&lt;/a&gt; document in the &lt;a href=&quot;https://github.com/docker/docker-ce&quot;&gt;docker/docker-ce repo&lt;/a&gt;. It&amp;rsquo;s been updated to accurately reflect newer releases.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 &lt;a href=&quot;https://github.com/docker/docker-ce&quot;&gt;docker / docker-ce repo&lt;/a&gt; 에있는 &lt;a href=&quot;https://github.com/moby/moby/blob/v1.12.0-rc4/experimental/docker-stacks-and-bundles/&quot;&gt;Docker Stacks 및 Distributed Application Bundles&lt;/a&gt; 문서 의 수정 된 사본입니다 . 최신 릴리스를 정확하게 반영하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="4efb2be128f0d63913cdbf35bee8d977234e8756" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a naive example. Creating an application-layer routing framework for a multi-tiered service is complex and out of scope for this topic.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 순진한 예입니다. 다 계층 서비스를위한 응용 프로그램 계층 라우팅 프레임 워크 생성은 복잡하며이 주제에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c86f21e6029f55005c8467fda83353bfb033123" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option configures devicemapper loopback, which should not be used in production.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 프로덕션에서 사용해서는 안되는 devicemapper 루프백을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f305c8f78d52e2ada903c7ad8319c69a50aa4e81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f65300822b2e134dfc3c4074e3b0e2b6160a1d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file. The &lt;code&gt;docker stack&lt;/code&gt; command accepts only pre-built images.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 . &lt;code&gt;docker stack&lt;/code&gt; 명령은 사전 구축 된 이미지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b11dd9d63126afdb4d9d419fe49a60d0e1aa948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file. Use &lt;a href=&quot;#restart_policy&quot;&gt;restart_policy&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 . 대신 &lt;a href=&quot;#restart_policy&quot;&gt;restart_policy&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="00f3e827020bec3e27b203c9fb3446c8449c211e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3-3.5) Compose file.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 (버전 3-3.5) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e91b1347c744d8b97199d2e8d209d463292ff137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is new in v3.2</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 v3.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="b337257dc7bbb4c686dd1b62589741aa1e29124d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is new in v3.3</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 v3.3의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="694275cf3fe402842ebddee290388287db14db39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option is only applicable to services using Windows containers.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 Windows 컨테이너를 사용하는 서비스에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1435c3e58b00c041075a41f7d300497a5fa24b57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This option was added in v3.3. Using group Managed Service Account (gMSA) configurations with compose files is supported in Compose version 3.8.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 옵션은 v3.3에서 추가되었습니다. 작성 파일과 함께 gMSA (그룹 관리 서비스 계정) 구성 사용은 작성 버전 3.8에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="73cb18611a73e3502a3484ed6f73deceb9364679" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This profile is used on containers, &lt;em&gt;not&lt;/em&gt; on the Docker Daemon.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 프로파일은 Docker 데몬이 &lt;em&gt;아닌&lt;/em&gt; 컨테이너에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7615a187d50c5b3258ea3b5b62ffab8baa41244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This replaces the &lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;older resource constraint options&lt;/a&gt; for non swarm mode in Compose files prior to version 3 (&lt;code&gt;cpu_shares&lt;/code&gt;, &lt;code&gt;cpu_quota&lt;/code&gt;, &lt;code&gt;cpuset&lt;/code&gt;, &lt;code&gt;mem_limit&lt;/code&gt;, &lt;code&gt;memswap_limit&lt;/code&gt;, &lt;code&gt;mem_swappiness&lt;/code&gt;), as described in &lt;a href=&quot;compose-versioning/index#upgrading&quot;&gt;Upgrading version 2.x to 3.x&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;compose-versioning/index#upgrading&quot;&gt;버전 2.x에서 3.x&lt;/a&gt; 로 업그레이드에 설명 된대로 버전 3 이전의 파일 작성 ( &lt;code&gt;cpu_shares&lt;/code&gt; , &lt;code&gt;cpu_quota&lt;/code&gt; , &lt;code&gt;cpuset&lt;/code&gt; , &lt;code&gt;mem_limit&lt;/code&gt; , &lt;code&gt;memswap_limit&lt;/code&gt; , &lt;code&gt;mem_swappiness&lt;/code&gt; )의 비 swarm 모드에 대한 &lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;이전 자원 제한 조건 옵션&lt;/a&gt; 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="c2e1736f88bf6eaa52c7e3881b1e17e9c031b26b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: To ensure that you see your new instance, select your region from the menu in the upper right. If you did not specify a region as part of &lt;code&gt;docker-machine create&lt;/code&gt; (with the optional &lt;code&gt;--amazonec2-region&lt;/code&gt; flag), select the default, US East (N. Virginia).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 새 인스턴스가 표시되도록하려면 오른쪽 상단의 메뉴에서 지역을 선택하십시오. &lt;code&gt;docker-machine create&lt;/code&gt; 의 일부로 영역을 지정하지 않은 경우 (선택 사항 &lt;code&gt;--amazonec2-region&lt;/code&gt; 플래그 사용) 기본값 인 미국 동부 (버지니아 북부)를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="56d1319eb49ef5b15a43fc6015d26c8687051b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: To use a different shell, other than &amp;lsquo;/bin/sh&amp;rsquo;, use the &lt;em&gt;exec&lt;/em&gt; form passing in the desired shell. For example, &lt;code&gt;RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : '/ bin / sh'이외의 다른 쉘을 사용하려면 원하는 쉘로 전달 되는 &lt;em&gt;exec&lt;/em&gt; 양식을 사용하십시오 . 예를 들어, &lt;code&gt;RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1f57f2b0012c5010ae7a01aabc6509fc4014a06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: To use the &lt;code&gt;dockremap&lt;/code&gt; user and have Docker create it for you, set the value to &lt;code&gt;default&lt;/code&gt; rather than &lt;code&gt;testuser&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;dockremap&lt;/code&gt; 사용자 를 사용하고 Docker가 자동으로 만들려면 &lt;code&gt;testuser&lt;/code&gt; 대신 &lt;code&gt;default&lt;/code&gt; 값을 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a8ba5c0852fe0c899d72a2dd3bffa1967f15fbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike the &lt;em&gt;shell&lt;/em&gt; form, the &lt;em&gt;exec&lt;/em&gt; form does not invoke a command shell. This means that normal shell processing does not happen. For example, &lt;code&gt;CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; will not do variable substitution on &lt;code&gt;$HOME&lt;/code&gt;. If you want shell processing then either use the &lt;em&gt;shell&lt;/em&gt; form or execute a shell directly, for example: &lt;code&gt;CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt;. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;셸&lt;/em&gt; 양식 과 달리 &lt;em&gt;exec&lt;/em&gt; 양식은 명령 셸을 호출하지 않습니다. 이는 정상적인 쉘 처리가 발생하지 않음을 의미합니다. 예를 들어, &lt;code&gt;CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; 는 &lt;code&gt;$HOME&lt;/code&gt; 에서 변수 대체를 수행하지 않습니다 . 당신은 쉘 처리를하려면 다음 중 하나를 사용 &lt;em&gt;쉘&lt;/em&gt; : 양식을하거나 예를 들어, 직접 쉘을 실행 &lt;code&gt;CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt; . 쉘 양식의 경우와 같이 exec 양식을 사용하고 쉘을 직접 실행하는 경우도 커가 아닌 환경 변수 확장을 수행하는 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="5dcabe51b011e45cd55f55cade914596db6a9cf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike the &lt;em&gt;shell&lt;/em&gt; form, the &lt;em&gt;exec&lt;/em&gt; form does not invoke a command shell. This means that normal shell processing does not happen. For example, &lt;code&gt;ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; will not do variable substitution on &lt;code&gt;$HOME&lt;/code&gt;. If you want shell processing then either use the &lt;em&gt;shell&lt;/em&gt; form or execute a shell directly, for example: &lt;code&gt;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt;. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;셸&lt;/em&gt; 양식 과 달리 &lt;em&gt;exec&lt;/em&gt; 양식은 명령 셸을 호출하지 않습니다. 이는 정상적인 쉘 처리가 발생하지 않음을 의미합니다. 예를 들어, &lt;code&gt;ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; 는 &lt;code&gt;$HOME&lt;/code&gt; 에서 변수 대체를 수행하지 않습니다 . 당신은 쉘 처리를하려면 다음 중 하나를 사용 &lt;em&gt;쉘&lt;/em&gt; : 양식을하거나 예를 들어, 직접 쉘을 실행 &lt;code&gt;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt; . 쉘 양식의 경우와 같이 exec 양식을 사용하고 쉘을 직접 실행하는 경우도 커가 아닌 환경 변수 확장을 수행하는 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="3b3a2b8057ebbd6c4c2fcf2e2c03414714bd5a6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike the &lt;em&gt;shell&lt;/em&gt; form, the &lt;em&gt;exec&lt;/em&gt; form does not invoke a command shell. This means that normal shell processing does not happen. For example, &lt;code&gt;RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; will not do variable substitution on &lt;code&gt;$HOME&lt;/code&gt;. If you want shell processing then either use the &lt;em&gt;shell&lt;/em&gt; form or execute a shell directly, for example: &lt;code&gt;RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt;. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;셸&lt;/em&gt; 양식 과 달리 &lt;em&gt;exec&lt;/em&gt; 양식은 명령 셸을 호출하지 않습니다. 이는 정상적인 쉘 처리가 발생하지 않음을 의미합니다. 예를 들어, &lt;code&gt;RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]&lt;/code&gt; 은 &lt;code&gt;$HOME&lt;/code&gt; 에서 변수 대체를 수행하지 않습니다 . 당신은 쉘 처리를하려면 다음 중 하나를 사용 &lt;em&gt;쉘&lt;/em&gt; 형태 또는 예를 들어, 직접 쉘을 실행 &lt;code&gt;RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]&lt;/code&gt; . 쉘 양식의 경우와 같이 exec 양식을 사용하고 쉘을 직접 실행하는 경우도 커가 아닌 환경 변수 확장을 수행하는 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="c277a3ff84491aa07b77495e2ada709f04be2b47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Using this feature &amp;ldquo;pins&amp;rdquo; an image to a specific version in time. Docker will therefore not pull updated versions of an image, which may include security updates. If you want to pull an updated image, you need to change the digest accordingly.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 기능을 사용하면 이미지를 특정 버전으로 &quot;고정&quot;합니다. 따라서 Docker는 보안 업데이트를 포함하여 업데이트 된 이미지 버전을 가져 오지 않습니다. 업데이트 된 이미지를 가져 오려면 다이제스트를 적절히 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecd5f555cdc3d6996145d8f92ef0168a88d8f230" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Volume plugins should &lt;em&gt;not&lt;/em&gt; write data to the &lt;code&gt;/var/lib/docker/&lt;/code&gt; directory, including &lt;code&gt;/var/lib/docker/volumes&lt;/code&gt;. The &lt;code&gt;/var/lib/docker/&lt;/code&gt; directory is reserved for Docker.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 볼륨 플러그인해야 &lt;em&gt;하지&lt;/em&gt; 쓰기 데이터 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 를 포함한 디렉토리 &lt;code&gt;/var/lib/docker/volumes&lt;/code&gt; . &lt;code&gt;/var/lib/docker/&lt;/code&gt; 디렉토리 도커 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="363edd013fb64b98137d2c84467bf3003d85244d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: We get into the meaning of that command in &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt;. If you don&amp;rsquo;t run &lt;code&gt;docker swarm init&lt;/code&gt; you get an error that &amp;ldquo;this node is not a swarm manager.&amp;rdquo;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 우리는 &lt;a href=&quot;../part4/index&quot;&gt;4 부에서이&lt;/a&gt; 명령의 의미를 이해합니다 . &lt;code&gt;docker swarm init&lt;/code&gt; 을 실행하지 않으면 &quot;이 노드는 swarm manager가 아닙니다&quot;라는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a93dbaf40e7e4d0ec8175b5b89de3e7ec2505fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: We use Docker&amp;rsquo;s public registry here just because it&amp;rsquo;s free and pre-configured, but there are many public ones to choose from, and you can even set up your own private registry using &lt;a href=&quot;https://docs.docker.com/datacenter/dtr/2.2/guides/&quot;&gt;Docker Trusted Registry&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Docker의 공개 레지스트리는 무료이며 사전 구성되어 있기 때문에 여기에서 사용하지만 선택할 수있는 공개 레지스트리가 많으며 &lt;a href=&quot;https://docs.docker.com/datacenter/dtr/2.2/guides/&quot;&gt;Docker Trusted Registry를&lt;/a&gt; 사용하여 자체 개인 레지스트리를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8ce70ad5c1da013665144d76dff89ab45cd4f7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When creating bind mounts, using the long syntax requires the referenced folder to be created beforehand. Using the short syntax creates the folder on the fly if it doesn&amp;rsquo;t exist. See the &lt;a href=&quot;https://docs.docker.com/storage#differences-between--v-and---mount-behavior&quot;&gt;bind mounts documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 바인드 마운트를 작성할 때 긴 구문을 사용하려면 참조 된 폴더를 미리 작성해야합니다. 짧은 구문을 사용하면 폴더가 없으면 즉시 폴더를 만듭니다. 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/storage#differences-between--v-and---mount-behavior&quot;&gt;바인드 마운트 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d54fe8a3f8ff016105156db087587dc6d9accf58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When mapping ports in the &lt;code&gt;HOST:CONTAINER&lt;/code&gt; format, you may experience erroneous results when using a container port lower than 60, because YAML parses numbers in the format &lt;code&gt;xx:yy&lt;/code&gt; as a base-60 value. For this reason, we recommend always explicitly specifying your port mappings as strings.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;HOST:CONTAINER&lt;/code&gt; 형식으로 포트를 매핑 할 때 YAML은 &lt;code&gt;xx:yy&lt;/code&gt; 형식의 숫자를 base-60 값 으로 구문 분석하기 때문에 60보다 낮은 컨테이너 포트를 사용할 때 잘못된 결과가 발생할 수 있습니다 . 따라서 포트 매핑을 항상 명시 적으로 문자열로 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7fc034d8260bf53174dddb16f3ab9a5f5e2b5fe4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When specifying the Compose file version to use, make sure to specify both the &lt;em&gt;major&lt;/em&gt; and &lt;em&gt;minor&lt;/em&gt; numbers. If no minor version is given, &lt;code&gt;0&lt;/code&gt; is used by default and not the latest minor version.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 사용할 파일 작성 버전을 지정할 때 &lt;em&gt;주&lt;/em&gt; 번호 와 &lt;em&gt;부&lt;/em&gt; 번호를 모두 지정하십시오 . 부 버전이 제공 되지 않으면 기본적으로 최신 부 버전이 아닌 &lt;code&gt;0&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f0be874060ada41f82efc02090c1c99ac69d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When specifying the Compose file version to use, make sure to specify both the &lt;em&gt;major&lt;/em&gt; and &lt;em&gt;minor&lt;/em&gt; numbers. If no minor version is given, &lt;code&gt;0&lt;/code&gt; is used by default and not the latest minor version. As a result, features added in later versions will not be supported. For example:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 사용할 파일 작성 버전을 지정할 때 &lt;em&gt;주&lt;/em&gt; 번호 와 &lt;em&gt;부&lt;/em&gt; 번호를 모두 지정하십시오 . 부 버전이 제공 되지 않으면 기본적으로 최신 부 버전이 아닌 &lt;code&gt;0&lt;/code&gt; 이 사용됩니다. 결과적으로 이후 버전에 추가 된 기능은 지원되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e572c7256a7519c26f1d097f1c24142413ce7615" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When using systemd to manage the Docker daemon&amp;rsquo;s start and stop, in the systemd unit file there is an option to control mount propagation for the Docker daemon itself, called &lt;code&gt;MountFlags&lt;/code&gt;. The value of this setting may cause Docker to not see mount propagation changes made on the mount point. For example, if this value is &lt;code&gt;slave&lt;/code&gt;, you may not be able to use the &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;rshared&lt;/code&gt; propagation on a volume.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : systemd를 사용하여 Docker 데몬의 시작 및 중지를 관리 할 때 systemd 단위 파일에는 Docker 데몬 자체의 마운트 전파 ( &lt;code&gt;MountFlags&lt;/code&gt; ) 를 제어하는 ​​옵션이 있습니다. 이 설정의 값으로 인해 Docker가 마운트 지점에서 마운트 전파 변경 사항을 보지 못할 수 있습니다. 예를 &lt;code&gt;rshared&lt;/code&gt; 값이 &lt;code&gt;slave&lt;/code&gt; 인 경우 볼륨 에서 &lt;code&gt;shared&lt;/code&gt; 또는 rshared 전파 를 사용하지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f7330c64e72a203d3ff1a7cad39ed48a53b7dc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When you set the &lt;code&gt;--rm&lt;/code&gt; flag, Docker also removes the anonymous volumes associated with the container when the container is removed. This is similar to running &lt;code&gt;docker rm -v my-container&lt;/code&gt;. Only volumes that are specified without a name are removed. For example, with &lt;code&gt;docker run --rm -v /foo -v awesome:/bar busybox top&lt;/code&gt;, the volume for &lt;code&gt;/foo&lt;/code&gt; will be removed, but the volume for &lt;code&gt;/bar&lt;/code&gt; will not. Volumes inherited via &lt;code&gt;--volumes-from&lt;/code&gt; will be removed with the same logic -- if the original volume was specified with a name it will &lt;strong&gt;not&lt;/strong&gt; be removed.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--rm&lt;/code&gt; 플래그 를 설정하면 Docker는 컨테이너를 제거 할 때 컨테이너와 관련된 익명 볼륨도 제거합니다. 이것은 &lt;code&gt;docker rm -v my-container&lt;/code&gt; 실행과 유사합니다 . 이름없이 지정된 볼륨 만 제거됩니다. 예를 들어 &lt;code&gt;docker run --rm -v /foo -v awesome:/bar busybox top&lt;/code&gt; 을 사용하면 &lt;code&gt;/foo&lt;/code&gt; 볼륨 이 제거되지만 &lt;code&gt;/bar&lt;/code&gt; 볼륨은 제거 되지 않습니다. &lt;code&gt;--volumes-from&lt;/code&gt; 을 통해 상속 된 볼륨 은 동일한 논리 로 제거됩니다. 원래 볼륨이 이름으로 지정된 경우 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="01e2ff1a77a3d3ec7fa39c9bf17a5a96009f6e8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Whether a file is identified as a recognized compression format or not is done solely based on the contents of the file, not the name of the file. For example, if an empty file happens to end with &lt;code&gt;.tar.gz&lt;/code&gt; this will not be recognized as a compressed file and &lt;strong&gt;will not&lt;/strong&gt; generate any kind of decompression error message, rather the file will simply be copied to the destination.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 파일이 인식 된 압축 형식으로 식별되는지 여부는 파일 이름이 아니라 파일 내용만으로 수행됩니다. 예를 들어, 빈 파일 이 &lt;code&gt;.tar.gz&lt;/code&gt; 로 끝나는 경우 압축 파일로 인식 &lt;strong&gt;되지 않고&lt;/strong&gt; 압축 해제 오류 메시지가 생성 &lt;strong&gt;되지&lt;/strong&gt; 않고 파일이 대상으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="5781452bf003987fe2e63d3558248e252847ff80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: WordPress Multisite works only on ports &lt;code&gt;80&lt;/code&gt; and/or &lt;code&gt;443&lt;/code&gt;. If you get an error message about binding &lt;code&gt;0.0.0.0&lt;/code&gt; to port &lt;code&gt;80&lt;/code&gt; or &lt;code&gt;443&lt;/code&gt; (depending on which one you specified), it is likely that the port you configured for WordPress is already in use by another service.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : WordPress Multisite는 포트 &lt;code&gt;80&lt;/code&gt; 및 / 또는 &lt;code&gt;443&lt;/code&gt; 에서만 작동합니다 . &lt;code&gt;0.0.0.0&lt;/code&gt; 을 포트 &lt;code&gt;80&lt;/code&gt; 또는 &lt;code&gt;443&lt;/code&gt; 에 바인딩하는 방법 (지정한 포트 에 따라 다름)에 대한 오류 메시지가 표시되면 WordPress에 대해 구성한 포트가 이미 다른 서비스에서 사용 중일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78dde25b0dc22d9aeef14ab830f0b26f50c285f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: YAML boolean values (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;) must be enclosed in quotes, so that the parser interprets them as strings.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 파서가이를 문자열로 해석 할 수 있도록 YAML 부울 값 ( &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; )은 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee88bcbd5e7305353f88d1c20dadfa270137d135" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: You are prompted for confirmation before the &lt;code&gt;prune&lt;/code&gt; removes anything, but you are not shown a list of what will potentially be removed. In addition, &lt;code&gt;docker image ls&lt;/code&gt; does not support negative filtering, so it difficult to predict what images will actually be removed.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;prune&lt;/code&gt; 는 무엇이든 제거 하기 전에 확인 메시지가 표시 되지만 제거 될 수있는 항목의 목록은 표시되지 않습니다. 또한 &lt;code&gt;docker image ls&lt;/code&gt; 는 네거티브 필터링을 지원하지 않으므로 실제로 제거 할 이미지를 예측하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="b5d2d34da23e0a96602a5d2f79c3d587d5a771a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: You can follow many of the tutorial steps to test single-node swarm as well, in which case you need only one host. Multi-node commands do not work, but you can initialize a swarm, create services, and scale them.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 많은 자습서 단계에 따라 단일 노드 떼도 테스트 할 수 있으며이 경우 호스트가 하나만 필요합니다. 다중 노드 명령은 작동하지 않지만 스웜을 초기화하고 서비스를 생성하고 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce837f94cb42f68568c0ce665b2d320f49687158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: You don&amp;rsquo;t need to unlock the swarm when a new node joins the swarm, because the key is propagated to it over mutual TLS.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 키가 상호 TLS를 통해 전파되기 때문에 새 노드가 스웜에 참여할 때 스웜을 잠금 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="72b7068f339cf0d5eb0a7857ba3b69c4903bad31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: You would have to write policy defining a &lt;code&gt;svirt_apache_t&lt;/code&gt; type.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;svirt_apache_t&lt;/code&gt; 유형을 정의하는 정책을 작성 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e8631649e293482e1b9d38917ebd450169684fc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Your app&amp;rsquo;s network is given a name based on the &amp;ldquo;project name&amp;rdquo;, which is based on the name of the directory it lives in. You can override the project name with either the &lt;a href=&quot;../reference/overview/index&quot;&gt;&lt;code&gt;--project-name&lt;/code&gt; flag&lt;/a&gt; or the &lt;a href=&quot;../reference/envvars/index#compose-project-name&quot;&gt;&lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 앱의 네트워크에는&amp;ldquo;프로젝트 이름&amp;rdquo;을 기반으로 이름이 지정됩니다.이 이름은 해당 디렉토리의 이름을 기반으로합니다. &lt;a href=&quot;../reference/overview/index&quot;&gt; &lt;code&gt;--project-name&lt;/code&gt; 플래그&lt;/a&gt; 또는 &lt;a href=&quot;../reference/envvars/index#compose-project-name&quot;&gt; &lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; 환경 변수로&lt;/a&gt; 프로젝트 이름을 재정의 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="740caa74a5d0755b8420f40464bed5d2484b9853" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: prior to 1.4, &lt;code&gt;ONBUILD&lt;/code&gt; instructions did &lt;strong&gt;NOT&lt;/strong&gt; support environment variable, even when combined with any of the instructions listed above.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이전 1.4에 &lt;code&gt;ONBUILD&lt;/code&gt; 지침 않았다 &lt;strong&gt;NOT&lt;/strong&gt; 환경 변수를 지원, 심지어 위에 나열된 명령어의와 결합.</target>
        </trans-unit>
        <trans-unit id="a2d93cb760bb7f77bded8f7a7ab4512c57189032" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: the &lt;code&gt;--device&lt;/code&gt; option is only supported on process-isolated Windows containers. This option fails if the container isolation is &lt;code&gt;hyperv&lt;/code&gt; or when running Linux Containers on Windows (LCOW).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--device&lt;/code&gt; 옵션은 프로세스 분리 Windows 컨테이너에서만 지원됩니다. 컨테이너 격리가 &lt;code&gt;hyperv&lt;/code&gt; 이거나 Windows (LCOW)에서 Linux 컨테이너를 실행하는 경우이 옵션이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="dee1e48475b29730c88ed43f35b9bd00c3edc6f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: the &lt;code&gt;service:&lt;/code&gt; and &lt;code&gt;container:&lt;/code&gt; forms require &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; or above</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;service:&lt;/code&gt; 및 &lt;code&gt;container:&lt;/code&gt; 양식에는 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;버전 2.1&lt;/a&gt; 이상이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac92399638ab2c0e2b6806b6f0c022e0a3cb220" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: the abbreviations &lt;code&gt;AuthZ&lt;/code&gt; and &lt;code&gt;AuthN&lt;/code&gt; mean authorization and authentication respectively.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 약어 &lt;code&gt;AuthZ&lt;/code&gt; 및 &lt;code&gt;AuthN&lt;/code&gt; 은 각각 권한 부여 및 인증을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a3bce66dbdadafda3d51a9bfb5cbde06089aed60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: the timestamp and snapshot keys cannot be compromised in a server-only compromise, so a key rotation would not be necessary. Once the Server compromise is mitigated, an attacker cannot generate valid timestamp or snapshot metadata and serve them on a malicious mirror, for example.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 타임 스탬프 및 스냅 샷 키는 서버 전용 손상에서 손상 될 수 없으므로 키 회전이 필요하지 않습니다. 서버 손상이 완화되면 공격자는 예를 들어 유효한 타임 스탬프 또는 스냅 샷 메타 데이터를 생성하여 악성 미러에 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66c80e14f11d0eb114de652f033935f18310a061" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this command is only functional for containers that are started with the &lt;code&gt;json-file&lt;/code&gt; or &lt;code&gt;journald&lt;/code&gt; logging driver.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 명령은 &lt;code&gt;json-file&lt;/code&gt; 또는 &lt;code&gt;journald&lt;/code&gt; 로깅 드라이버 로 시작된 컨테이너에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e73ff3a6b79ea3b58c07f0356e1d144be148482e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: you need to run the following as administrator or else you don&amp;rsquo;t get any reasonable output (only &amp;ldquo;UNKNOWN&amp;rdquo;).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 관리자 권한으로 다음을 실행해야합니다. 그렇지 않으면 합리적인 결과를 얻지 못합니다 (&amp;ldquo;UNKNOWN&amp;rdquo;만 해당).</target>
        </trans-unit>
        <trans-unit id="860a6db8165fd2ab76ccc11a9a0da60af5df280a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: you need to run the following as administrator or else you don&amp;rsquo;t have the permission to create hyperv VMs!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 관리자로 다음을 실행해야합니다. 그렇지 않으면 hyperv VM을 만들 수있는 권한이 없습니다!</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e42fbe4240560deae4f59c3edc3b41aa2d7beba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="666b51bbb1916a1c4c2a63e6b177f66f72ae938a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 1&lt;/strong&gt; injects the settings safely into your apt configuration in a local version of a common base:</source>
          <target state="translated">&lt;strong&gt;옵션 1&lt;/strong&gt; 은 로컬 버전의 공통 기반에서 적절한 구성으로 설정을 안전하게 주입합니다.</target>
        </trans-unit>
        <trans-unit id="6b5016834aab6108f72ea462a5234fbe0dffecfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 2&lt;/strong&gt; is good for testing, but breaks other HTTP clients which obey &lt;code&gt;http_proxy&lt;/code&gt;, such as &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt; and others:</source>
          <target state="translated">&lt;strong&gt;옵션 2&lt;/strong&gt; 는 테스트에는 좋지만 &lt;code&gt;curl&lt;/code&gt; , &lt;code&gt;wget&lt;/code&gt; 및 기타 와 같이 &lt;code&gt;http_proxy&lt;/code&gt; 를 준수하는 다른 HTTP 클라이언트를 중단 합니다.</target>
        </trans-unit>
        <trans-unit id="047895552fed83c69d46858a3b4751fddc1fc1d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 3&lt;/strong&gt; is the least portable, but you might need to do it and you can do it from your &lt;code&gt;Dockerfile&lt;/code&gt; too.</source>
          <target state="translated">&lt;strong&gt;옵션 3&lt;/strong&gt; 은 휴대 성이 가장 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 수행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1a7f7bc66f4bc95bdf6c9e6e1d09be89582b7b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 4&lt;/strong&gt; links Debian-containers to the proxy server using following command:</source>
          <target state="translated">&lt;strong&gt;옵션 4&lt;/strong&gt; 는 다음 명령을 사용하여 데비안 컨테이너를 프록시 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f651a64f0c441c0f8adfde01a753a9eed0c14724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Option 5&lt;/strong&gt; creates a custom network of APT proxy server and Debian-based containers:</source>
          <target state="translated">&lt;strong&gt;옵션 5&lt;/strong&gt; 는 APT 프록시 서버 및 데비안 기반 컨테이너의 사용자 지정 네트워크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="02c4f786a341ffc46a95174f66fe6659f110ea8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Predicting what will be removed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;무엇을 제거할지 예측&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a932ad96d57b00d27a6d65cebaa78e02ae6777c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference file&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참조 파일&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5725a00c56fca093270ee615aa336764c32b524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce&quot;&gt;v17.06&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.06.0-ce&quot;&gt;v17.06&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="388c41f079e50abce32831ab3b810a143234c8a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.09.0-ce&quot;&gt;v17.09&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : &lt;a href=&quot;https://github.com/docker/docker-ce/releases/tag/v17.09.0-ce&quot;&gt;v17.09&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be6a463353bc2bdad21935d540bb7e09ab4516bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.10.0&quot;&gt;v1.10.0&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.10.0&quot;&gt;v1.10.0&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2e3bdc09a243b0ad697927481b6c90ab73be9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.12.0&quot;&gt;v1.12.0&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.12.0&quot;&gt;v1.12.0&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1770775ed0be8cadb17245d4ecc4683cc97fbfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.13.0&quot;&gt;v1.13.0&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : &lt;a href=&quot;https://github.com/docker/docker/releases/tag/v1.13.0&quot;&gt;v1.13.0&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a515407c2c7361ad887d84fe922d4d617380612" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removed In Release: v17.12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 : v17.12&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24ec39a4cc531757a7e7698b5d8c5cd4928a264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request:&lt;/strong&gt; empty body</source>
          <target state="translated">&lt;strong&gt;요청 :&lt;/strong&gt; 빈 몸</target>
        </trans-unit>
        <trans-unit id="f4da174bcb126ec9f594065e7ee6a6fc5900979e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="26468e762b2455c6ece554a3efee4bd2213193e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="840d79ed30ab86347aa15088b8588c646ad92b31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="0f56d3022d7e82fb262c3690fca7a23e4abde6a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rollback, Freeze, Mix and Match&lt;/strong&gt; - The attacker can request that the Notary signer sign any arbitrary timestamp (and maybe snapshot) metadata they want. Attackers can launch a freeze attack, and, depending on whether the snapshot key is available, a mix-and-match attack up to the expiration of the targets file.</source>
          <target state="translated">&lt;strong&gt;롤백, 고정, 혼합 및 일치&lt;/strong&gt; -공격자는 Notary 서명자가 원하는 임의의 타임 스탬프 (및 스냅 샷) 메타 데이터에 서명하도록 요청할 수 있습니다. 공격자는 동결 공격을 시작하고 스냅 샷 키의 사용 가능 여부에 따라 대상 파일이 만료 될 때까지 혼합 및 일치 공격을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d957a02eb88b030c107a12efefa601e3abae99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling updates:&lt;/strong&gt; At rollout time you can apply service updates to nodes incrementally. The swarm manager lets you control the delay between service deployment to different sets of nodes. If anything goes wrong, you can roll-back a task to a previous version of the service.</source>
          <target state="translated">&lt;strong&gt;롤링 업데이트 :&lt;/strong&gt; 롤아웃시 서비스 업데이트를 노드에 점차적으로 적용 할 수 있습니다. swarm manager를 사용하면 다른 노드 세트에 대한 서비스 배치 간 지연을 제어 할 수 있습니다. 문제가 발생하면 작업을 이전 버전의 서비스로 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5325bb9532e901313d17babf478b6b4ba2c5f99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scaling:&lt;/strong&gt; For each service, you can declare the number of tasks you want to run. When you scale up or down, the swarm manager automatically adapts by adding or removing tasks to maintain the desired state.</source>
          <target state="translated">&lt;strong&gt;스케일링 :&lt;/strong&gt; 각 서비스에 대해 실행할 태스크 수를 선언 할 수 있습니다. 규모를 늘리거나 줄이면 웜 관리자가 작업을 추가하거나 제거하여 원하는 상태를 유지함으로써 자동으로 적응합니다.</target>
        </trans-unit>
        <trans-unit id="7679f06ac3df9ca0b34e48a1cca243034dd4e429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Secure by default:&lt;/strong&gt; Each node in the swarm enforces TLS mutual authentication and encryption to secure communications between itself and all other nodes. You have the option to use self-signed root certificates or certificates from a custom root CA.</source>
          <target state="translated">&lt;strong&gt;기본적으로 보안 :&lt;/strong&gt; 스웜의 각 노드는 TLS 상호 인증 및 암호화를 적용하여 자신과 다른 모든 노드 간의 통신을 보호합니다. 자체 서명 된 루트 인증서 또는 사용자 지정 루트 CA의 인증서를 사용하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b40d6df2d613b34ad65a73d5a15855383e1e30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service discovery:&lt;/strong&gt; Swarm manager nodes assign each service in the swarm a unique DNS name and load balances running containers. You can query every container running in the swarm through a DNS server embedded in the swarm.</source>
          <target state="translated">&lt;strong&gt;서비스 검색 :&lt;/strong&gt; Swarm Manager 노드는 swarm의 각 서비스에 고유 한 DNS 이름과 컨테이너를 실행하는 부하 분산을 할당합니다. 웜에 포함 된 DNS 서버를 통해 웜에서 실행중인 모든 컨테이너를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0cdf0e97b97a1045455240a535ddfa05fe312c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services&lt;/strong&gt; (you are here)</source>
          <target state="translated">&lt;strong&gt;서비스&lt;/strong&gt; (현재 위치)</target>
        </trans-unit>
        <trans-unit id="270ea8527a39d6b4ef0bdb041320cfe2faa48f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shell 1: (Again .. now showing events):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;쉘 1 : (다시 .. 지금 이벤트를 보여줍니다) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd213219a57add33a6b419769fb6cc96b0dda586" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shell 1: Listening for events:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;쉘 1 : 이벤트 청취 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4c4527d779d4625fa9355e12e5f9d832708b9f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shell 2: Start and Stop containers:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;쉘 2 : 컨테이너 시작 및 중지 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94e8ebbdbb4db84420c443a03647e13886866582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short syntax:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;짧은 구문 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1136b44b3fcd26add9b1c5d77d156a36e6cd7170" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Specify a region&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지역을 지정하십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5bbb589698d6645fe11319b116ae7ea6474d9d7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Specify keys at the command line&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;명령 행에서 키를 지정하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad1baf2f89dade25da2da12c6544d10893eb1fd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TCP port 2377&lt;/strong&gt; for cluster management communications</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;클러스터 관리 통신을위한 &lt;strong&gt;TCP 포트 2377&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="410c283f6120f3050a9a0ce08b1410c1215ee8d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TCP&lt;/strong&gt; and &lt;strong&gt;UDP port 7946&lt;/strong&gt; for communication among nodes</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;노드 간 통신을위한 &lt;strong&gt;TCP&lt;/strong&gt; 및 &lt;strong&gt;UDP 포트 7946&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3945f1aded1099cdce8322d9d51ee1f090d081ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Target For Removal In Release: v17.06&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 대상 : v17.06&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ad1bbe7d06d90dca6a61d4f82f7386c1ec58d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Target For Removal In Release: v17.09&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 대상 : v17.09&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aaeb1b6a0ac57dd86edbd2047a40c29f97eef701" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Target For Removal In Release: v17.12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 대상 : v17.12&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7b137ee8862ea30070985635ead62398cf83233" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Target For Removal In Release: v18.03&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 대상 : v18.03&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85789b6c0456ede50b2fe3c7009bdec56e47e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Target For Removal In Release: v19.09.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;릴리스에서 제거 대상 : v19.09.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b2d7f837d9c05925e8bf40ce0b6712ebf832ab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The host directory is declared at container run-time&lt;/strong&gt;: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can&amp;rsquo;t be guaranteed to be available on all hosts. For this reason, you can&amp;rsquo;t mount a host directory from within the Dockerfile. The &lt;code&gt;VOLUME&lt;/code&gt; instruction does not support specifying a &lt;code&gt;host-dir&lt;/code&gt; parameter. You must specify the mountpoint when you create or run the container.</source>
          <target state="translated">&lt;strong&gt;호스트 디렉토리는 컨테이너 런타임에 선언됩니다&lt;/strong&gt; . 호스트 디렉토리 (마운트 포인트)는 본질적으로 호스트에 따라 다릅니다. 지정된 호스트 디렉토리가 모든 호스트에서 사용 가능한 것은 아니기 때문에 이미지 이식성을 유지하기위한 것입니다. 이러한 이유로 Dockerfile 내에서 호스트 디렉토리를 마운트 할 수 없습니다. &lt;code&gt;VOLUME&lt;/code&gt; 명령은 지정을 지원하지 않는 &lt;code&gt;host-dir&lt;/code&gt; 매개 변수를. 컨테이너를 만들거나 실행할 때 마운트 지점을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23595ce9423e36619af452d118d2b089aa15f603" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The main purpose of a &lt;code&gt;CMD&lt;/code&gt; is to provide defaults for an executing container.&lt;/strong&gt; These defaults can include an executable, or they can omit the executable, in which case you must specify an &lt;code&gt;ENTRYPOINT&lt;/code&gt; instruction as well.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;CMD&lt;/code&gt; 의 주요 목적은 실행 컨테이너에 대한 기본값을 제공하는 것입니다. &lt;/strong&gt;이러한 기본값은 실행 파일을 포함하거나 실행 파일을 생략 할 수 있으며,이 경우 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 명령도 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72da5beed690ac2af6597d81b5852ff65ce62da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip:&lt;/strong&gt; See also, how to &lt;a href=&quot;../../get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;unset environment variables in the current shell&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;팁 : &lt;/strong&gt;&lt;a href=&quot;../../get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;현재 쉘에서 환경 변수&lt;/a&gt; 를 설정 해제 하는 방법도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7b2bb78454524856e698ea312e3791b425ed309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip:&lt;/strong&gt; See the section on &lt;a href=&quot;#volumes-for-services-swarms-and-stack-files&quot;&gt;how to configure volumes for services, swarms, and docker-stack.yml files&lt;/a&gt;. Volumes &lt;em&gt;are&lt;/em&gt; supported but to work with swarms and services, they must be configured as named volumes or associated with services that are constrained to nodes with access to the requisite volumes.</source>
          <target state="translated">&lt;strong&gt;팁 : &lt;/strong&gt;&lt;a href=&quot;#volumes-for-services-swarms-and-stack-files&quot;&gt;서비스, ​​스웜 및 docker-stack.yml 파일의 볼륨을 구성하는 방법에&lt;/a&gt; 대한 섹션을 참조하십시오 . 볼륨 &lt;em&gt;은&lt;/em&gt; 지원되지만 스웜 및 서비스와 함께 작동하려면 명명 된 볼륨으로 구성되거나 필수 볼륨에 액세스 할 수있는 노드로 제한되는 서비스와 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6b75d947176c38bac014dc1febe716e865b7606" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: Alternatively, in &lt;a href=&quot;../../compose-file/index&quot;&gt;Compose file version 3.x&lt;/a&gt;, you can specify &lt;a href=&quot;../../compose-file/index#replicas&quot;&gt;replicas&lt;/a&gt; under the &lt;a href=&quot;../../compose-file/index#deploy&quot;&gt;deploy&lt;/a&gt; key as part of a service configuration for &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;Swarm mode&lt;/a&gt;. The &lt;code&gt;deploy&lt;/code&gt; key and its sub-options (including &lt;code&gt;replicas&lt;/code&gt;) only works with the &lt;code&gt;docker stack deploy&lt;/code&gt; command, not &lt;code&gt;docker-compose up&lt;/code&gt; or &lt;code&gt;docker-compose run&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; : 또는 &lt;a href=&quot;../../compose-file/index&quot;&gt;Compose file version 3.x의&lt;/a&gt; 경우 &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;Swarm 모드&lt;/a&gt; 서비스 구성의 일부로 &lt;a href=&quot;../../compose-file/index#deploy&quot;&gt;deploy&lt;/a&gt; 키 아래에 &lt;a href=&quot;../../compose-file/index#replicas&quot;&gt;복제본&lt;/a&gt; 을 지정할 수 있습니다 . &lt;code&gt;deploy&lt;/code&gt; 키 (포함 하위 옵션 &lt;code&gt;replicas&lt;/code&gt; )에서만 작동 &lt;code&gt;docker stack deploy&lt;/code&gt; 명령이 아닌 &lt;code&gt;docker-compose up&lt;/code&gt; 또는 &lt;code&gt;docker-compose run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d00503612f118b4aed0271d5902f9069a7fad68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: If &lt;code&gt;helloworld&lt;/code&gt; is running on a node other than your manager node, you must ssh to that node.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; : &lt;code&gt;helloworld&lt;/code&gt; 가 관리자 노드 이외의 노드에서 실행중인 경우 해당 노드로 ssh해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a3a05c41b9b920285e98709b09ec989e4db3972" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: There are limitations to this first solution. For example, it doesn&amp;rsquo;t verify when a specific service is really ready. If you add more arguments to the command, use the &lt;code&gt;bash shift&lt;/code&gt; command with a loop, as shown in the next example.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; :이 첫 번째 솔루션에는 제한이 있습니다. 예를 들어 특정 서비스가 실제로 준비된 시점을 확인하지 않습니다. 명령에 인수를 더 추가하는 경우 다음 예와 같이 루프와 함께 &lt;code&gt;bash shift&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fc92e8ae91b3b37720e6e026b7167051612df5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: To return the service details in json format, run the same command without the &lt;code&gt;--pretty&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; : 서비스 세부 사항을 json 형식으로 리턴하려면 &lt;code&gt;--pretty&lt;/code&gt; 플래그 없이 동일한 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="53ea79ad5a8d6c4ff82d8ca706e888beb978a0b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: You can use either a &lt;code&gt;.yml&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt; extension for this file.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; : 이 파일에 &lt;code&gt;.yml&lt;/code&gt; 또는 &lt;code&gt;.yaml&lt;/code&gt; 확장자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93736125a47e10bd6f6f628aa96574dc75cd0d7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tip&lt;/strong&gt;: You can use either a &lt;code&gt;.yml&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt; extension for this file. They both work.</source>
          <target state="translated">&lt;strong&gt;팁&lt;/strong&gt; : 이 파일에 &lt;code&gt;.yml&lt;/code&gt; 또는 &lt;code&gt;.yaml&lt;/code&gt; 확장자를 사용할 수 있습니다 . 그들은 둘 다 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d98ff9b2d101d0b04cc4cf17295efa00308e0f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Token authentication:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;토큰 인증 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9778c61ee569d73dd219433d6978e99d6a5453a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;U != 0, K &amp;gt; U&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;U! = 0, K&amp;gt; U&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c86b65feae586b2cad654190edd17558d3a8a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;U != 0, K &amp;lt; U&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;U! = 0, K &amp;lt;U&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c004656b61d1fb41bd06d77bfbae38ff349b28b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;U != 0, K = inf&lt;/strong&gt; (default)</source>
          <target state="translated">&lt;strong&gt;U! = 0, K = inf&lt;/strong&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="ed20973b6213001601db3bd076e054170ed0a886" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UDP port 4789&lt;/strong&gt; for overlay network traffic</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;오버레이 네트워크 트래픽 용 &lt;strong&gt;UDP 포트 4789&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0734def832757a1a96edf1e57953d0efdf45009" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use aws credentials file&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AWS 자격 증명 파일 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccc6eb82d1f1a89d693cef0221d9b19212afa759" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Volumes on Windows-based containers&lt;/strong&gt;: When using Windows-based containers, the destination of a volume inside the container must be one of:</source>
          <target state="translated">&lt;strong&gt;Windows 기반 컨테이너의 볼륨&lt;/strong&gt; : &lt;strong&gt;Windows 기반 컨테이너를&lt;/strong&gt; 사용할 때 컨테이너 내부의 볼륨 대상은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ac9c12d7b6cce5e2835c550d5a2dc12ca7c88283" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Loss of the root key is &lt;strong&gt;very difficult&lt;/strong&gt; to recover from. Correcting this loss requires intervention from &lt;a href=&quot;https://support.docker.com&quot;&gt;Docker Support&lt;/a&gt; to reset the repository state. This loss also requires &lt;strong&gt;manual intervention&lt;/strong&gt; from every consumer that used a signed tag from this repository prior to the loss.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 루트 키 손실은 복구 &lt;strong&gt;하기&lt;/strong&gt; 가 &lt;strong&gt;매우 어렵습니다&lt;/strong&gt; . 이 손실을 수정하려면 저장소 상태를 재설정하기 위해 &lt;a href=&quot;https://support.docker.com&quot;&gt;Docker 지원의&lt;/a&gt; 개입이 필요합니다 . 이 손실 에는 손실 전에이 저장소에서 서명 된 태그를 사용한 모든 소비자의 &lt;strong&gt;수동 개입&lt;/strong&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="44a20a5c705df1169b0a49a950055580ffcfdd88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It is not recommended to use build-time variables for passing secrets like github keys, user credentials etc. Build-time variable values are visible to any user of the image with the &lt;code&gt;docker history&lt;/code&gt; command.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; github 키, 사용자 자격 증명 등과 같은 비밀을 전달하는 데 빌드 시간 변수를 사용하지 않는 것이 좋습니다. 빌드 시간 변수 값은 &lt;code&gt;docker history&lt;/code&gt; 명령으로 이미지의 모든 사용자에게 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fcec958c645c09941c1f79a6f055d0a5c1831c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: As shown in the example above, you don&amp;rsquo;t need to run the &lt;code&gt;docker&lt;/code&gt; client with &lt;code&gt;sudo&lt;/code&gt; or the &lt;code&gt;docker&lt;/code&gt; group when you use certificate authentication. That means anyone with the keys can give any instructions to your Docker daemon, giving them root access to the machine hosting the daemon. Guard these keys as you would a root password!</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 위의 예와 같이 인증서 인증을 사용할 때 &lt;code&gt;sudo&lt;/code&gt; 또는 &lt;code&gt;docker&lt;/code&gt; 그룹으로 &lt;code&gt;docker&lt;/code&gt; client 를 실행할 필요가 없습니다 . 즉, 키를 가진 사람은 Docker 데몬에 대한 지침을 제공하여 데몬을 호스팅하는 컴퓨터에 대한 루트 액세스 권한을 부여 할 수 있습니다. 루트 암호처럼이 키를 보호하십시오!</target>
        </trans-unit>
        <trans-unit id="4c2969c5665ab21e147f71a6334a1837b0267041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Chaining &lt;code&gt;ONBUILD&lt;/code&gt; instructions using &lt;code&gt;ONBUILD ONBUILD&lt;/code&gt; isn&amp;rsquo;t allowed.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;ONBUILD ONBUILD&lt;/code&gt; 를 사용한 체인 &lt;code&gt;ONBUILD&lt;/code&gt; 명령 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1e9c68f9d6ac5f445522fe1c1e188ec49db7f40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Changing the default &lt;code&gt;docker&lt;/code&gt; daemon binding to a TCP port or Unix &lt;em&gt;docker&lt;/em&gt; user group will increase your security risks by allowing non-root users to gain &lt;em&gt;root&lt;/em&gt; access on the host. Make sure you control access to &lt;code&gt;docker&lt;/code&gt;. If you are binding to a TCP port, anyone with access to that port has full Docker access; so it is not advisable on an open network.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 기본 &lt;code&gt;docker&lt;/code&gt; 데몬 바인딩을 TCP 포트 또는 Unix &lt;em&gt;도커&lt;/em&gt; 사용자 그룹으로 변경하면 루트가 아닌 사용자가 호스트에서 &lt;em&gt;루트&lt;/em&gt; 액세스 권한 을 얻을 수 있으므로 보안 위험이 높아집니다 . &lt;code&gt;docker&lt;/code&gt; 에 대한 액세스를 제어하십시오 . TCP 포트에 바인딩하는 경우 해당 포트에 액세스 할 수있는 모든 사람은 전체 Docker 액세스 권한을 갖습니다. 따라서 개방형 네트워크에서는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a06e3a9f11a371cb18bd56bfba151210b8762d8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Do not use your root directory, &lt;code&gt;/&lt;/code&gt;, as the &lt;code&gt;PATH&lt;/code&gt; as it causes the build to transfer the entire contents of your hard drive to the Docker daemon.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 루트 디렉토리 &lt;code&gt;/&lt;/code&gt; 를 &lt;code&gt;PATH&lt;/code&gt; 로 사용하지 마십시오 . 빌드로 인해 하드 드라이브의 전체 내용이 Docker 데몬으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d9aeebaa36b653eee4843ac88683c96d458435bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Nondistributable artifacts typically have restrictions on how and where they can be distributed and shared. Only use this feature to push artifacts to private registries and ensure that you are in compliance with any terms that cover redistributing nondistributable artifacts.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 배포 불가능한 아티팩트에는 일반적으로 배포 및 공유 할 수있는 방법과 위치에 제한이 있습니다. 이 기능을 사용하여 아티팩트를 개인 레지스트리로 푸시하고 분배 불가능한 아티팩트 재배포에 관한 조항을 준수하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9916e6499286db28dc1f362d91fdaaa3a0085f5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Raft data is encrypted in Docker 1.13 and higher. If any of your Swarm managers run an earlier version, and one of those managers becomes the manager of the swarm, the secrets are stored unencrypted in that node&amp;rsquo;s Raft logs. Before adding any secrets, update all of your manager nodes to Docker 1.13 or higher to prevent secrets from being written to plain-text Raft logs.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : Raft 데이터는 Docker 1.13 이상에서 암호화됩니다. Swarm 관리자 중 하나가 이전 버전을 실행하고 해당 관리자 중 하나가 swarm의 관리자가되면 비밀은 해당 노드의 Raft 로그에 암호화되지 않은 상태로 저장됩니다. 비밀을 추가하기 전에 비밀이 일반 텍스트 Raft 로그에 기록되지 않도록 모든 관리자 노드를 Docker 1.13 이상으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="65b811cf4e7c950539bc1aa6aca24765fdc00df2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some distributions, such as RHEL and CentOS 7.3, do not automatically add the new group to the &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt; files. You are responsible for editing these files and assigning non-overlapping ranges, in this case. This step is covered in &lt;a href=&quot;#prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : RHEL 및 CentOS 7.3과 같은 일부 배포는 새 그룹을 &lt;code&gt;/etc/subuid&lt;/code&gt; 및 &lt;code&gt;/etc/subgid&lt;/code&gt; 파일에 자동으로 추가하지 않습니다 . 이 경우 이러한 파일을 편집하고 겹치지 않는 범위를 할당해야합니다. 이 단계는 &lt;a href=&quot;#prerequisites&quot;&gt;전제 조건&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="7d4384e2330ae330ecaa17c10905b113d1860df8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;--link&lt;/code&gt; flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use &lt;a href=&quot;https://docs.docker.com/network#user-defined-networks&quot;&gt;user-defined networks&lt;/a&gt; to facilitate communication between two containers instead of using &lt;code&gt;--link&lt;/code&gt;. One feature that user-defined networks do not support that you can do with &lt;code&gt;--link&lt;/code&gt; is sharing environmental variables between containers. However, you can use other mechanisms such as volumes to share environment variables between containers in a more controlled way.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;--link&lt;/code&gt; 플래그는 Docker의 레거시 기능입니다. 결국 제거 될 수 있습니다. 계속해서 사용해야하는 경우가 아니라면 &lt;code&gt;--link&lt;/code&gt; 를 사용하는 대신 &lt;a href=&quot;https://docs.docker.com/network#user-defined-networks&quot;&gt;사용자 정의 네트워크&lt;/a&gt; 를 사용하여 두 컨테이너 간 통신을 용이하게 하는 것이 좋습니다 . &lt;code&gt;--link&lt;/code&gt; 로 사용자 정의 네트워크가 지원하지 않는 기능 중 하나 는 컨테이너간에 환경 변수를 공유하는 것입니다. 그러나 볼륨과 같은 다른 메커니즘을 사용하여 컨테이너간에 환경 변수를보다 제어 된 방식으로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784f0c89eac49f29357855e002ea932ed45bd7c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;ONBUILD&lt;/code&gt; instruction may not trigger &lt;code&gt;FROM&lt;/code&gt; or &lt;code&gt;MAINTAINER&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;ONBUILD&lt;/code&gt; 명령어는 &lt;code&gt;FROM&lt;/code&gt; 또는 &lt;code&gt;MAINTAINER&lt;/code&gt; 명령어를 트리거하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="013f49863545613fd0c3ba921d7372632f0e59e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;docker update&lt;/code&gt; and &lt;code&gt;docker container update&lt;/code&gt; commands are not supported for Windows containers.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;docker update&lt;/code&gt; 및 &lt;code&gt;docker container update&lt;/code&gt; 명령은 Windows 컨테이너에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37796bb5243a1e901c0ce4093ea26ed961e12626" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Unlike &lt;code&gt;docker rm&lt;/code&gt;, this command does not ask for confirmation before removing a running service.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;docker rm&lt;/code&gt; 과 달리이 명령은 실행중인 서비스를 제거하기 전에 확인을 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79c4364b5822a1715dfc3a42ef5688fe96d43ac1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Unlike &lt;code&gt;docker rm&lt;/code&gt;, this command does not ask for confirmation before removing a secret.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;docker rm&lt;/code&gt; 과 달리이 명령은 비밀을 제거하기 전에 확인을 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e9818b7d854ae3d17756d10dd8cbe87d6c586b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When the user doesn&amp;rsquo;t have a primary group then the image (or the next instructions) will be run with the &lt;code&gt;root&lt;/code&gt; group.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 사용자에게 기본 그룹이 없으면 &lt;code&gt;root&lt;/code&gt; 그룹 과 함께 이미지 (또는 다음 지침)가 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a20daf01ea0b942664771d640cebb40d25c9abe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When you rotate the unlock key, keep a record of the old key around for a few minutes, so that if a manager goes down before it gets the new key, it may still be unlocked with the old one.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 잠금 해제 키를 회전 할 때 이전 키의 기록을 몇 분 동안 유지하여 새 키를 받기 전에 관리자가 다운 된 경우 여전히 이전 키로 잠금이 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="145b5280954901a6cf213442dfe520bab05b0ddb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What changed in this version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 버전에서 변경된 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09861ea01799f47381a5b4474ab8a29940e3486a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worker nodes&lt;/strong&gt; receive and execute tasks dispatched from manager nodes. By default manager nodes also run services as worker nodes, but you can configure them to run manager tasks exclusively and be manager-only nodes. An agent runs on each worker node and reports on the tasks assigned to it. The worker node notifies the manager node of the current state of its assigned tasks so that the manager can maintain the desired state of each worker.</source>
          <target state="translated">&lt;strong&gt;작업자 노드&lt;/strong&gt; 는 관리자 노드에서 디스패치 된 작업을 받고 실행합니다. 기본적으로 관리자 노드는 서비스를 작업자 노드로 실행하지만 관리자 작업을 단독으로 실행하고 관리자 전용 노드가되도록 서비스를 구성 할 수 있습니다. 에이전트는 각 작업자 노드에서 실행되고 할당 된 작업에 대해보고합니다. 작업자 노드는 관리자에게 각 작업의 원하는 상태를 유지할 수 있도록 할당 된 작업의 현재 상태를 관리자 노드에 알립니다.</target>
        </trans-unit>
        <trans-unit id="665c3c14c52657fa3d863ce1976c82579f6e3377" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are viewing docs for legacy standalone Swarm.&lt;/strong&gt; These topics describe standalone Docker Swarm. In Docker 1.12 and higher, &lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm mode&lt;/a&gt; is integrated with Docker Engine. Most users should use integrated Swarm mode &amp;mdash; a good place to start is &lt;a href=&quot;../../engine/swarm/swarm-tutorial/index&quot;&gt;Getting started with swarm mode&lt;/a&gt;, &lt;a href=&quot;../../engine/swarm/index#swarm-mode-cli-commands&quot;&gt;Swarm mode CLI commands&lt;/a&gt;, and the &lt;a href=&quot;../../get-started/index&quot;&gt;Get started with Docker walkthrough&lt;/a&gt;). Standalone Docker Swarm is not integrated into the Docker Engine API and CLI commands.</source>
          <target state="translated">&lt;strong&gt;기존 독립형 Swarm 문서를보고 있습니다. &lt;/strong&gt;이 주제에서는 독립형 Docker Swarm에 대해 설명합니다. Docker 1.12 이상에서 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm 모드&lt;/a&gt; 는 Docker Engine과 통합되었습니다. 대부분의 사용자는 통합 Swarm 모드를 사용해야합니다. 시작 &lt;a href=&quot;../../engine/swarm/swarm-tutorial/index&quot;&gt;하기&lt;/a&gt; 좋은 곳은 swarm 모드 시작 , &lt;a href=&quot;../../engine/swarm/index#swarm-mode-cli-commands&quot;&gt;Swarm 모드 CLI 명령&lt;/a&gt; 및 &lt;a href=&quot;../../get-started/index&quot;&gt;Docker 시작하기&lt;/a&gt; )입니다. 독립형 Docker Swarm은 Docker Engine API 및 CLI 명령에 통합되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2922227ea3803475a2a06f8f8e62a5ca4ff06057" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You must acquire your own certificates to use in a production deployment.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로덕션 배포에 사용할 고유 한 인증서를 얻어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c282119bc2aa895f52c7f6ac872b27a2fe59a5dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;always&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;always&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be04d5759cb3e9f034e7710801493e5de0aad956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bridge&lt;/strong&gt; (default)</source>
          <target state="translated">&lt;strong&gt;브릿지&lt;/strong&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="32980ca40c6b2de8f489d5015a8cbabc7d91c869" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;container&lt;/strong&gt;:&amp;lt;name|id&amp;gt;</source>
          <target state="translated">&lt;strong&gt;container&lt;/strong&gt;:&amp;lt;name|id&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cec612b3c02215b4ab0bc579db6fe5cbe9aa9413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker-compose.override.yml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker-compose.override.yml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4135fce6a1ba02d1fb67cddef07dd9e6e8268aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker-compose.prod.yml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker-compose.prod.yml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56675832af5aa64f1c97e97fe5b2b3290bee6068" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker-compose.yml&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker-compose.yml&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f9ae2660ba0eca969fac024a490ea9c952ed36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.authz/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.authz/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8cf198e9e9376cfa1fbc7d3d52ef71aa64747e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.ipamdriver/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.ipamdriver/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac899b19b94ba03af90d03fe99947d225fae2fdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.logdriver/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.logdriver/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7caf1e461af64e756be14c377d77f2d7bb74137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.metricscollector/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.metricscollector/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30d00cfc6abbf78dfa4262ed02b0f5da7c0a588c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.networkdriver/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.networkdriver/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d4ce6b2e4d51e7621d74b7addec3ddb305a0fde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;docker.volumedriver/1.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;docker.volumedriver/1.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="79d83ec565ede982247fd84bf5206a790d8c5ae9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;host&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;host&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="907b05b6df0cbf1d57962a56c0a45dd40693bdb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;memory=L&amp;lt;inf, memory-swap=2*L&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메모리 = L &amp;lt;inf, 메모리 스왑 = 2 * L&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="368b5cc95e10846f9e87276ed9c67144ad397d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;memory=L&amp;lt;inf, memory-swap=S&amp;lt;inf, L&amp;lt;=S&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메모리 = L &amp;lt;inf, 메모리 스왑 = S &amp;lt;inf, L &amp;lt;= S&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83005d4fd1d4981c3fe94d991c3c87e224711aed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;memory=L&amp;lt;inf, memory-swap=inf&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메모리 = L &amp;lt;inf, 메모리 스왑 = inf&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54cc434f3482ba334e9e86e720c90fe75ea0e616" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;memory=inf, memory-swap=inf&lt;/strong&gt; (default)</source>
          <target state="translated">&lt;strong&gt;memory = inf, memory-swap = inf&lt;/strong&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="aaf1afe6d2b7d1f6ad546430f85db817e6eed3f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;no&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;no&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45f86d696eef9707d4d1d19a233bcbe71a9320e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;none&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;none&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="849bcc3124c6417cf3803693e51c2ddf105b796b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;on-failure&lt;/strong&gt;[:max-retries]</source>
          <target state="translated">&lt;strong&gt;on-failure&lt;/strong&gt;[:max-retries]</target>
        </trans-unit>
        <trans-unit id="b877efc1abec5fafbf17d946a230a9e4c89a8790" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;or&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="196d7bd3434fce155f481b1ed67088d4a5fd3fe0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;required&lt;/strong&gt; Linode APIv4 Token (see &lt;a href=&quot;https://developers.linode.com/api/v4#section/Personal-Access-Token&quot;&gt;here&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;필요한&lt;/strong&gt; Linode APIv4 토큰 ( &lt;a href=&quot;https://developers.linode.com/api/v4#section/Personal-Access-Token&quot;&gt;여기&lt;/a&gt; 참조) )</target>
        </trans-unit>
        <trans-unit id="332e3d32aea18609885819458fc1870574183579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start period&lt;/strong&gt; provides initialization time for containers that need time to bootstrap. Probe failure during that period will not be counted towards the maximum number of retries. However, if a health check succeeds during the start period, the container is considered started and all consecutive failures will be counted towards the maximum number of retries.</source>
          <target state="translated">&lt;strong&gt;시작 기간&lt;/strong&gt; 은 부트 스트랩에 시간이 필요한 컨테이너의 초기화 시간을 제공합니다. 해당 기간 동안의 프로브 실패는 최대 재시도 횟수에 포함되지 않습니다. 그러나 시작 기간 동안 상태 점검에 성공하면 컨테이너가 시작된 것으로 간주되고 모든 연속 실패는 최대 재시도 횟수로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="fb9939b41b6abf1868d5272a2a942a112741e83c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unless-stopped&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;unless-stopped&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fac39cb00e07f9f2beb179f6fc7ae8c7a06df518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;v1&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;v1&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ab5dad2d03896025d96ad267b16627fcae60069d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;v2&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;v2&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="0fab2d32db719b7c6b5b34b934ccb17bc755bcf2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-networks-overview/&quot;&gt;Virtual Network&lt;/a&gt; and a subnet under it is created to place your machines into. This establishes a local network between your docker machines.</source>
          <target state="translated">&lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-networks-overview/&quot;&gt;가상 네트워크&lt;/a&gt; 와 그 아래 서브넷으로 시스템을 배치하는 생성됩니다. 그러면 도커 시스템간에 로컬 네트워크가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dbae38e7b0ba27bfa2b34688c7cf59ba103f7fee" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#container&quot;&gt;container&lt;/a&gt; definition contains configuration which are applied to each container started for that service, much like passing command-line parameters to &lt;code&gt;docker run&lt;/code&gt;. Likewise, network and volume definitions are analogous to &lt;code&gt;docker network create&lt;/code&gt; and &lt;code&gt;docker volume create&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#container&quot;&gt;컨테이너&lt;/a&gt; 정의는 훨씬에 명령 줄 매개 변수를 전달하는 것처럼, 그 서비스를 시작 각 컨테이너에 적용되는 설정이 포함되어 &lt;code&gt;docker run&lt;/code&gt; . 마찬가지로 네트워크 및 볼륨 정의는 &lt;code&gt;docker network create&lt;/code&gt; 및 &lt;code&gt;docker volume create&lt;/code&gt; 와 유사합니다. .</target>
        </trans-unit>
        <trans-unit id="b641406ba2ebca3237bd6c3820ced3b4f2efe47e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;docker-compose.yml&lt;/code&gt; file is a YAML file that defines how Docker containers should behave in production.</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 정의는 부두 노동자 용기 생산에서 행동하는 방법을하는 YAML 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f65c674d5c9c4753253d6b84f8a215ab79b9ec24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;docker-compose.yml&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="1cb893d99ff59a897f92dc91e966493a632ab708" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;linode-root-pass&lt;/code&gt; will be generated if not provided. This password will not be shown. Rely on &lt;code&gt;docker-machine ssh&lt;/code&gt; or &lt;a href=&quot;https://www.linode.com/docs/quick-answers/linode-platform/reset-the-root-password-on-your-linode/&quot;&gt;Linode&amp;rsquo;s Rescue features&lt;/a&gt; to access the node directly.</source>
          <target state="translated">&lt;code&gt;linode-root-pass&lt;/code&gt; 제공되지 않는 경우에 생성됩니다. 이 비밀번호는 표시되지 않습니다. &lt;code&gt;docker-machine ssh&lt;/code&gt; 또는 &lt;a href=&quot;https://www.linode.com/docs/quick-answers/linode-platform/reset-the-root-password-on-your-linode/&quot;&gt;Linode의 Rescue 기능&lt;/a&gt; 에 의존 직접 노드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f68ec35af86f3d1d18f8fa5758d23fd01a04192" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;name&lt;/code&gt; value must start with an alphanumeric character, followed by &lt;code&gt;a-z0-9&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; (underscore), &lt;code&gt;.&lt;/code&gt; (period) or &lt;code&gt;-&lt;/code&gt; (hyphen). An absolute path starts with a &lt;code&gt;/&lt;/code&gt; (forward slash).</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 값 영숫자 문자로 시작하며, 다음에 &lt;code&gt;a-z0-9&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; (밑줄) &lt;code&gt;.&lt;/code&gt; (마침표) 또는 &lt;code&gt;-&lt;/code&gt; (하이픈). 절대 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작합니다 (슬래시) .</target>
        </trans-unit>
        <trans-unit id="946cab89fd2b928227aa47cea2655c8cbf9bf82a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;targets&lt;/code&gt; key and a &lt;code&gt;snapshot&lt;/code&gt; key. The same password encrypts both of these as the security profile of them (when both held by the author of the trusted collection) is identical. This is why are not prompted for a snapshot key password.</source>
          <target state="translated">&lt;code&gt;targets&lt;/code&gt; 키와 &lt;code&gt;snapshot&lt;/code&gt; 키를 누릅니다. 동일한 비밀번호는 이들 모두의 보안 프로파일 (신뢰할 수있는 콜렉션의 작성자가 보유한 경우)이 동일하므로 두 비밀번호를 모두 암호화합니다. 스냅 샷 키 암호를 묻는 메시지가 표시되지 않는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="75ca5e6199a3a0f94fe171c130e4306ba7bde7fd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;timestamp&lt;/code&gt; key. This is generated by the server on a request from the client, returning just the public key. The server holds the private key and signs timestamps on behalf of the user.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 키를 누릅니다. 이것은 클라이언트의 요청에 따라 서버에서 생성되며 공개 키만 반환합니다. 서버는 개인 키를 보유하고 사용자 대신 타임 스탬프에 서명합니다.</target>
        </trans-unit>
        <trans-unit id="0ac9507130c1dd3c63ce54ec3c5f8b18a9811016" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bind mount&lt;/strong&gt; makes a file or directory on the host available to the container it is mounted within. A bind mount may be either read-only or read-write. For example, a container might share its host&amp;rsquo;s DNS information by means of a bind mount of the host&amp;rsquo;s &lt;code&gt;/etc/resolv.conf&lt;/code&gt; or a container might write logs to its host&amp;rsquo;s &lt;code&gt;/var/log/myContainerLogs&lt;/code&gt; directory. If you use bind mounts and your host and containers have different notions of permissions, access controls, or other such details, you will run into portability issues.</source>
          <target state="translated">&lt;strong&gt;바인드 마운트는&lt;/strong&gt; 그 내부에 장착 된 용기에 사용할 수있는 호스트의 파일이나 디렉토리를 만든다. 바인드 마운트는 읽기 전용이거나 읽기 / 쓰기 일 수 있습니다. 예를 들어, 컨테이너는 호스트의 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 의 바인드 마운트를 통해 호스트의 DNS 정보를 공유 하거나 컨테이너는 호스트의 &lt;code&gt;/var/log/myContainerLogs&lt;/code&gt; 디렉토리에 로그를 쓸 수 있습니다 . 바인드 마운트를 사용하고 호스트 및 컨테이너에 다른 권한, 액세스 제어 또는 기타 세부 사항 개념이있는 경우 이식성 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ae714d37ae203477e4ee8ebbbf5a726f2c28255" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;container&lt;/strong&gt; is a runtime instance of an image--what the image becomes in memory when executed (that is, an image with state, or a user process). You can see a list of your running containers with the command, &lt;code&gt;docker ps&lt;/code&gt;, just as you would in Linux.</source>
          <target state="translated">&lt;strong&gt;컨테이너가&lt;/strong&gt; 실행될 때, 이미지 (이미지 상태, 또는 사용자 프로세스하다) 메모리에 무슨해진다 - 화상의 실행 예이다. Linux에서와 마찬가지로 &lt;code&gt;docker ps&lt;/code&gt; 명령으로 실행중인 컨테이너 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d072ac8f7789595ca596bc7b93972fca88f55f13" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;container&lt;/strong&gt; runs &lt;em&gt;natively&lt;/em&gt; on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.</source>
          <target state="translated">&lt;strong&gt;컨테이너는&lt;/strong&gt; 실행 &lt;em&gt;기본적으로&lt;/em&gt; 리눅스와 다른 컨테이너와 호스트 시스템의 커널을 공유합니다. 별도의 프로세스를 실행하여 다른 실행 파일보다 더 많은 메모리를 사용하지 않아 경량화됩니다.</target>
        </trans-unit>
        <trans-unit id="57283f17589ff7848c8bcfa5ab23912563bc865c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;named volume&lt;/strong&gt; is a mechanism for decoupling persistent data needed by your container from the image used to create the container and from the host machine. Named volumes are created and managed by Docker, and a named volume persists even when no container is currently using it. Data in named volumes can be shared between a container and the host machine, as well as between multiple containers. Docker uses a &lt;em&gt;volume driver&lt;/em&gt; to create, manage, and mount volumes. You can back up or restore volumes using Docker commands.</source>
          <target state="translated">&lt;strong&gt;라는 이름의 볼륨&lt;/strong&gt; 컨테이너를 만드는 데 사용되는 이미지와 호스트 컴퓨터에서 컨테이너에 필요한 영구 데이터 디커플링하는 메커니즘이다. 명명 된 볼륨은 Docker에 의해 생성 및 관리되며 현재 사용중인 컨테이너가없는 경우에도 명명 된 볼륨이 유지됩니다. 명명 된 볼륨의 데이터는 컨테이너와 호스트 시스템간에뿐만 아니라 여러 컨테이너간에 공유 할 수 있습니다. Docker는 &lt;em&gt;볼륨 드라이버&lt;/em&gt; 를 사용하여 &lt;em&gt;볼륨&lt;/em&gt; 을 생성, 관리 및 마운트합니다. Docker 명령을 사용하여 볼륨을 백업하거나 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b744a3b1ecdc66091fecbe647f27ec1c7302d938" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;node&lt;/strong&gt; is an instance of the Docker engine participating in the swarm. You can also think of this as a Docker node. You can run one or more nodes on a single physical computer or cloud server, but production swarm deployments typically include Docker nodes distributed across multiple physical and cloud machines.</source>
          <target state="translated">&lt;strong&gt;노드는&lt;/strong&gt; 떼에 참여하는 도커 엔진의 인스턴스입니다. 이것을 도커 노드라고 생각할 수도 있습니다. 단일 물리적 컴퓨터 또는 클라우드 서버에서 하나 이상의 노드를 실행할 수 있지만 프로덕션 스웜 배포에는 일반적으로 여러 물리적 및 클라우드 시스템에 분산 된 Docker 노드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="74b7fb709ab73779365adef7153fc43a5a456fe2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;npipe&lt;/strong&gt; mounts a named pipe from the host into the container.</source>
          <target state="translated">&lt;strong&gt;NPIPE는&lt;/strong&gt; 컨테이너에 호스트에서 명명 된 파이프를 탑재합니다.</target>
        </trans-unit>
        <trans-unit id="0196ccf2f485d5051f91c337b8390103fe3b4d84" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;service&lt;/strong&gt; is the definition of the tasks to execute on the manager or worker nodes. It is the central structure of the swarm system and the primary root of user interaction with the swarm.</source>
          <target state="translated">&lt;strong&gt;서비스는&lt;/strong&gt; 관리자 또는 근로자 노드에서 실행할 수있는 작업의 정의입니다. 웜 시스템의 중심 구조이며 웜과의 사용자 상호 작용의 기본 루트입니다.</target>
        </trans-unit>
        <trans-unit id="e28994b461ea0bfba4c4a0b3a3f6fe047d34864b" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;task&lt;/strong&gt; carries a Docker container and the commands to run inside the container. It is the atomic scheduling unit of swarm. Manager nodes assign tasks to worker nodes according to the number of replicas set in the service scale. Once a task is assigned to a node, it cannot move to another node. It can only run on the assigned node or fail.</source>
          <target state="translated">&lt;strong&gt;작업은&lt;/strong&gt; 도커 컨테이너와 컨테이너 내에서 실행할 수있는 명령을 수행합니다. 떼의 원자 예약 단위입니다. 관리자 노드는 서비스 스케일에 설정된 복제본 수에 따라 작업자 노드에 작업을 할당합니다. 작업이 노드에 할당되면 다른 노드로 이동할 수 없습니다. 지정된 노드에서만 실행되거나 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a76c43b2bf3abb14df71bc3970ce643d403537fe" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;tmpfs&lt;/strong&gt; mounts a tmpfs inside a container for volatile data.</source>
          <target state="translated">&lt;strong&gt;의 tmpfs&lt;/strong&gt; 마운트 휘발성 데이터의 컨테이너 내부의 tmpfs.</target>
        </trans-unit>
        <trans-unit id="193a652621e100153723f725393d5377b321a159" translate="yes" xml:space="preserve">
          <source>A Dockerfile can be built into an image, and containers can be created from that image. Similarly, a &lt;code&gt;docker-compose.yml&lt;/code&gt; can be built into a &lt;strong&gt;distributed application bundle&lt;/strong&gt;, and &lt;strong&gt;stacks&lt;/strong&gt; can be created from that bundle. In that sense, the bundle is a multi-services distributable image format.</source>
          <target state="translated">Dockerfile을 이미지에 내장 할 수 있으며 해당 이미지에서 컨테이너를 만들 수 있습니다. 마찬가지로, &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 내장 할 수있는 &lt;strong&gt;분산 응용 프로그램 번들&lt;/strong&gt; 및 &lt;strong&gt;스택은&lt;/strong&gt; 해당 번들 만들 수 있습니다. 그런 의미에서 번들은 다중 서비스 배포 가능 이미지 형식입니다.</target>
        </trans-unit>
        <trans-unit id="33131594abab424d13f57d17d4b6702afdbf934f" translate="yes" xml:space="preserve">
          <source>A Dockerfile may include one or more &lt;code&gt;ARG&lt;/code&gt; instructions. For example, the following is a valid Dockerfile:</source>
          <target state="translated">Dockerfile은 하나 이상의 &lt;code&gt;ARG&lt;/code&gt; 명령어를 포함 할 수 있습니다 . 예를 들어, 다음은 유효한 Dockerfile입니다.</target>
        </trans-unit>
        <trans-unit id="403de8e0b59f809d231aefa1976431f8c56e6893" translate="yes" xml:space="preserve">
          <source>A JSON string specifying data that is passed (via UDF) to the selected StackScript.</source>
          <target state="translated">UDF를 통해 선택된 StackScript로 전달되는 데이터를 지정하는 JSON 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ef5fa4738170cf1bb47600bee90f3b8996d99ef9" translate="yes" xml:space="preserve">
          <source>A Notary service consists of a Notary server, which stores and updates the signed &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L348&quot;&gt;TUF metadata files&lt;/a&gt; for multiple trusted collections in an associated database, and a Notary signer, which stores private keys for and signs metadata for the Notary server. The following diagram illustrates this architecture:</source>
          <target state="translated">Notary 서비스는 관련 데이터베이스에있는 여러 신뢰할 수있는 컬렉션에 대한 서명 된 &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L348&quot;&gt;TUF 메타 데이터 파일&lt;/a&gt; 을 저장하고 업데이트하는 Notary 서버와 Notary 서버의 개인 키를 저장하고 메타 데이터를 서명하는 Notary 서명자로 구성됩니다. 다음 다이어그램은이 아키텍처를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6e6c25c72c49f31db9a37c3667171bbd8674a06d" translate="yes" xml:space="preserve">
          <source>A basic extendable authorization plugin that runs directly on the host or inside a container. This plugin allows you to define user policies that it evaluates during authorization. Basic authorization is provided if Docker daemon is started with the --tlsverify flag (username is extracted from the certificate common name).</source>
          <target state="translated">호스트 또는 컨테이너 내에서 직접 실행되는 기본 확장 가능 인증 플러그인입니다. 이 플러그인을 사용하면 권한 부여 중에 평가되는 사용자 정책을 정의 할 수 있습니다. Docker 데몬이 --tlsverify 플래그로 시작되면 기본 인증이 제공됩니다 (사용자 이름은 인증서 공통 이름에서 추출 됨).</target>
        </trans-unit>
        <trans-unit id="7683a3a4862e80b036580150073af523e3ecc5a1" translate="yes" xml:space="preserve">
          <source>A bundle has two top-level fields: &lt;code&gt;version&lt;/code&gt; and &lt;code&gt;services&lt;/code&gt;. The version used by Docker 1.12 tools is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="translated">번들에는 &lt;code&gt;version&lt;/code&gt; 및 &lt;code&gt;services&lt;/code&gt; 의 두 가지 최상위 필드가 있습니다 . Docker 1.12 도구에서 사용하는 버전은 &lt;code&gt;0.1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e740b6356a13dab5ed0ca6268ce3c798d98c5688" translate="yes" xml:space="preserve">
          <source>A client can only be tricked into downloading and trusting the malicious content for these trusted collections if it has never seen the trusted collections and does not have any form of pinned trust.</source>
          <target state="translated">신뢰할 수있는 컬렉션을 본 적이없고 고정 된 트러스트 형식이없는 경우 클라이언트는 이러한 신뢰할 수있는 컬렉션에 대한 악의적 인 콘텐츠를 다운로드하고 신뢰하도록 속일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9a0de440c468d07d7b76b57d56c889d03fd9933" translate="yes" xml:space="preserve">
          <source>A cluster of hosts with connectivity to the key-value store.</source>
          <target state="translated">키-값 저장소에 연결된 호스트 클러스터</target>
        </trans-unit>
        <trans-unit id="b545647f9098bf616bdec46c3f127fb073ae81c8" translate="yes" xml:space="preserve">
          <source>A cluster should only have 3-7 managers at most, because a majority of managers must be available for the cluster to function. Nodes that aren&amp;rsquo;t meant to participate in this management quorum should join as workers instead. Managers should be stable hosts that have static IP addresses.</source>
          <target state="translated">클러스터가 작동하려면 대부분의 관리자를 사용할 수 있어야하므로 클러스터에는 최대 3-7 명의 관리자 만 있어야합니다. 이 관리 쿼럼에 참여하지 않는 노드는 대신 작업자로 참여해야합니다. 관리자는 고정 IP 주소가있는 안정적인 호스트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f377f1423645c71de3f90927cdeb8025c7869a24" translate="yes" xml:space="preserve">
          <source>A cluster-aware volume plugin that provides volume management for file and block storage solutions. It implements a vendor neutral specification for implementing extensions such as CoS, encryption, and snapshots. It has example drivers based on FUSE, NFS, NBD and EBS to name a few.</source>
          <target state="translated">파일 및 블록 스토리지 솔루션에 대한 볼륨 관리를 제공하는 클러스터 인식 볼륨 플러그인입니다. CoS, 암호화 및 스냅 샷과 같은 확장을 구현하기 위해 공급 업체 중립 사양을 구현합니다. FUSE, NFS, NBD 및 EBS를 기반으로 한 예제 드라이버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d350379ea8f6adf808892e1b5cb39a4d16e58ead" translate="yes" xml:space="preserve">
          <source>A colon (&lt;code&gt;:&lt;/code&gt;) is used as a delimiter between &lt;code&gt;CONTAINER&lt;/code&gt; and its path. You can also use &lt;code&gt;:&lt;/code&gt; when specifying paths to a &lt;code&gt;SRC_PATH&lt;/code&gt; or &lt;code&gt;DEST_PATH&lt;/code&gt; on a local machine, for example &lt;code&gt;file:name.txt&lt;/code&gt;. If you use a &lt;code&gt;:&lt;/code&gt; in a local machine path, you must be explicit with a relative or absolute path, for example:</source>
          <target state="translated">콜론 ( &lt;code&gt;:&lt;/code&gt; ) 간 구분자로서 사용된다 &lt;code&gt;CONTAINER&lt;/code&gt; 및 경로. 로컬 시스템에서 &lt;code&gt;SRC_PATH&lt;/code&gt; 또는 &lt;code&gt;DEST_PATH&lt;/code&gt; 에 경로를 지정할 때 &lt;code&gt;:&lt;/code&gt; 을 사용할 수도 있습니다 ( 예 &lt;code&gt;file:name.txt&lt;/code&gt; . 로컬 컴퓨터 경로에서 &lt;code&gt;:&lt;/code&gt; 를 사용하는 경우 상대 경로 또는 절대 경로로 명시 적이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2e6b6d355d3dae6633b5d9dbd35261d8ec06706" translate="yes" xml:space="preserve">
          <source>A comma separated list of tags to apply to the the Linode resource</source>
          <target state="translated">Linode 자원에 적용 할 쉼표로 구분 된 태그 목록</target>
        </trans-unit>
        <trans-unit id="70487cf7645d271aab56a1635b375725aa91830a" translate="yes" xml:space="preserve">
          <source>A common use case for multiple files is changing a development Compose app for a production-like environment (which may be production, staging or CI). To support these differences, you can split your Compose configuration into a few different files:</source>
          <target state="translated">여러 파일의 일반적인 사용 사례는 프로덕션 환경 (프로덕션, 준비 또는 CI 일 수 있음)에 대한 개발 작성 앱을 변경하는 것입니다. 이러한 차이점을 지원하기 위해 작성 구성을 몇 개의 다른 파일로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f86dc6254be46e6157b294e860bcab075bb5e4" translate="yes" xml:space="preserve">
          <source>A compromised worker could not compromise these special workloads because it cannot change node labels.</source>
          <target state="translated">손상된 작업자는 노드 레이블을 변경할 수 없으므로 이러한 특수한 워크로드를 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae65ae71a3eacc12e6e1e8baf0ee997944436410" translate="yes" xml:space="preserve">
          <source>A configuration file is required by Notary server, and the path to the configuration file must be specified using the &lt;code&gt;-config&lt;/code&gt; option on the command line.</source>
          <target state="translated">Notary 서버에는 구성 파일이 필요 하며 명령 행 에서 &lt;code&gt;-config&lt;/code&gt; 옵션을 사용하여 구성 파일의 경로를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d52e56a710845555f6f285cd8c67b33d61e210be" translate="yes" xml:space="preserve">
          <source>A container is an isolated process. In the swarm mode model, each task invokes exactly one container. A task is analogous to a &amp;ldquo;slot&amp;rdquo; where the scheduler places a container. Once the container is live, the scheduler recognizes that the task is in a running state. If the container fails health checks or terminates, the task terminates.</source>
          <target state="translated">컨테이너는 격리 된 프로세스입니다. 스웜 모드 모델에서 각 작업은 정확히 하나의 컨테이너를 호출합니다. 작업은 스케줄러가 컨테이너를 배치하는 &quot;슬롯&quot;과 유사합니다. 컨테이너가 활성화되면 스케줄러는 작업이 실행중인 상태임을 인식합니다. 컨테이너가 상태 확인에 실패하거나 종료되면 작업이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c63702d51da6703ddb3406f349142b890909a73c" translate="yes" xml:space="preserve">
          <source>A container is created using &lt;code&gt;db&lt;/code&gt;&amp;rsquo;s configuration. It joins the network &lt;code&gt;myapp_default&lt;/code&gt; under the name &lt;code&gt;db&lt;/code&gt;.</source>
          <target state="translated">컨테이너는 &lt;code&gt;db&lt;/code&gt; 의 구성을 사용하여 생성됩니다 . 이름이 &lt;code&gt;db&lt;/code&gt; 인 네트워크 &lt;code&gt;myapp_default&lt;/code&gt; 에 조인합니다 .</target>
        </trans-unit>
        <trans-unit id="eef9a0da52f0be9a9493f89131c65530d59efe38" translate="yes" xml:space="preserve">
          <source>A container is created using &lt;code&gt;web&lt;/code&gt;&amp;rsquo;s configuration. It joins the network &lt;code&gt;myapp_default&lt;/code&gt; under the name &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">컨테이너는 &lt;code&gt;web&lt;/code&gt; 구성을 사용하여 생성됩니다 . 이름이 &lt;code&gt;web&lt;/code&gt; 인 네트워크 &lt;code&gt;myapp_default&lt;/code&gt; 에 가입합니다 .</target>
        </trans-unit>
        <trans-unit id="334cfa7a683fe9636d3dab0789cafb63171a2803" translate="yes" xml:space="preserve">
          <source>A container is launched by running an image. An &lt;strong&gt;image&lt;/strong&gt; is an executable package that includes everything needed to run an application--the code, a runtime, libraries, environment variables, and configuration files.</source>
          <target state="translated">이미지를 실행하여 컨테이너가 시작됩니다. &lt;strong&gt;이미지&lt;/strong&gt; 코드, 런타임, 도서관, 환경 변수 및 구성 파일 - 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 실행 가능한 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="55a541be4023e1a0a568d79a5aa70ff59da9dab7" translate="yes" xml:space="preserve">
          <source>A container with the latest version of Docker Engine and with some preconfigured certificates. This is your sandbox where you can use the &lt;code&gt;docker&lt;/code&gt; client to test trust operations.</source>
          <target state="translated">최신 버전의 Docker Engine 및 일부 사전 구성된 인증서가있는 컨테이너입니다. &lt;code&gt;docker&lt;/code&gt; 클라이언트를 사용하여 트러스트 작업을 테스트 할 수있는 샌드 박스 입니다.</target>
        </trans-unit>
        <trans-unit id="990312b86dc23e3b4f3a535122b0c2c59b9b077f" translate="yes" xml:space="preserve">
          <source>A context is processed recursively. So, a &lt;code&gt;PATH&lt;/code&gt; includes any subdirectories and the &lt;code&gt;URL&lt;/code&gt; includes the repository and its submodules. This example shows a build command that uses the current directory as context:</source>
          <target state="translated">컨텍스트는 재귀 적으로 처리됩니다. 따라서 &lt;code&gt;PATH&lt;/code&gt; 에는 하위 디렉토리가 포함되고 &lt;code&gt;URL&lt;/code&gt; 에는 저장소 및 해당 하위 모듈이 포함됩니다. 이 예제는 현재 디렉토리를 컨텍스트로 사용하는 빌드 명령을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b9699a7ef4ff3a0d022f1c0672900786307d90ce" translate="yes" xml:space="preserve">
          <source>A custom certificate is configured by creating a directory under &lt;code&gt;/etc/docker/certs.d&lt;/code&gt; using the same name as the registry&amp;rsquo;s hostname, such as &lt;code&gt;localhost&lt;/code&gt;. All &lt;code&gt;*.crt&lt;/code&gt; files are added to this directory as CA roots.</source>
          <target state="translated">레지스트리 호스트 이름과 동일한 이름 (예 : &lt;code&gt;localhost&lt;/code&gt; )을 사용하여 &lt;code&gt;/etc/docker/certs.d&lt;/code&gt; 아래에 디렉토리를 작성하여 사용자 정의 인증서를 구성합니다 . 모든 &lt;code&gt;*.crt&lt;/code&gt; 파일은이 디렉토리에 CA 루트로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="265f656265abbaa6d790a27bc516264c5cb3eb6b" translate="yes" xml:space="preserve">
          <source>A delegation role is given its own keys, such that each collaborator can keep his own private key without the administrator having to share the targets key or allow a collaborator write access to all targets of the collection.</source>
          <target state="translated">위임 역할에는 자체 키가 제공되므로 각 공동 작업자는 관리자가 대상 키를 공유하거나 공동 작업자가 컬렉션의 모든 대상에 대한 쓰기 권한을 부여하지 않고도 자신의 개인 키를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3249ab430b18b297ad345a0ae55e51a5af4b5c68" translate="yes" xml:space="preserve">
          <source>A digest takes the place of the tag when pulling an image, for example, to pull the above image by digest, run the following command:</source>
          <target state="translated">다이제스트는 이미지를 가져올 때 태그를 대신합니다. 예를 들어 다이제스트하여 위의 이미지를 가져 오려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8250d11fe74e6ceb5cc0fff28814b733a43504d2" translate="yes" xml:space="preserve">
          <source>A file or directory was added</source>
          <target state="translated">파일 또는 디렉토리가 추가되었습니다</target>
        </trans-unit>
        <trans-unit id="1db055bb56b0d4ccd0c25bcce5483e14ac0bf8be" translate="yes" xml:space="preserve">
          <source>A file or directory was changed</source>
          <target state="translated">파일 또는 디렉토리가 변경되었습니다</target>
        </trans-unit>
        <trans-unit id="d07e422ff95840cb57a1086e490c1394adceef2f" translate="yes" xml:space="preserve">
          <source>A file or directory was deleted</source>
          <target state="translated">파일 또는 디렉토리가 삭제되었습니다</target>
        </trans-unit>
        <trans-unit id="be7684b0e597741bac7e547f2ccd663c92957670" translate="yes" xml:space="preserve">
          <source>A five-manager swarm tolerates a maximum simultaneous loss of two manager nodes.</source>
          <target state="translated">5 명의 관리자 떼는 두 명의 관리자 노드의 최대 동시 손실을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="80ae11678f99f0aa57f0b510d6523d224ac24c4d" translate="yes" xml:space="preserve">
          <source>A flag specifying to create private IP for the Linode instance.</source>
          <target state="translated">Linode 인스턴스의 프라이빗 IP를 작성하도록 지정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="1a7175f763d75a32108334f6e0c7506222f56810" translate="yes" xml:space="preserve">
          <source>A full example:</source>
          <target state="translated">전체 예 :</target>
        </trans-unit>
        <trans-unit id="87d26a383808d93ab9f011822c3bde1340a8e43d" translate="yes" xml:space="preserve">
          <source>A global service is a service that runs one task on every node. There is no pre-specified number of tasks. Each time you add a node to the swarm, the orchestrator creates a task and the scheduler assigns the task to the new node. Good candidates for global services are monitoring agents, an anti-virus scanners or other types of containers that you want to run on every node in the swarm.</source>
          <target state="translated">글로벌 서비스는 모든 노드에서 하나의 작업을 실행하는 서비스입니다. 미리 지정된 수의 작업이 없습니다. 웜에 노드를 추가 할 때마다 오케 스트레이터는 작업을 생성하고 스케줄러는 새 노드에 작업을 할당합니다. 글로벌 서비스에 적합한 대상은 모니터링 에이전트, 안티 바이러스 스캐너 또는 떼의 모든 노드에서 실행하려는 다른 유형의 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="ccb6f51ccc6c69f8bd2f9f08a8e9017f2c5c26bf" translate="yes" xml:space="preserve">
          <source>A good example is &lt;code&gt;http_proxy&lt;/code&gt; or source versions for pulling intermediate files. The &lt;code&gt;ARG&lt;/code&gt; instruction lets Dockerfile authors define values that users can set at build-time using the &lt;code&gt;--build-arg&lt;/code&gt; flag:</source>
          <target state="translated">좋은 예는 중간 파일을 가져 &lt;code&gt;http_proxy&lt;/code&gt; 위한 http_proxy 또는 소스 버전입니다. Dockerfile 작성자 는 &lt;code&gt;ARG&lt;/code&gt; 명령어를 사용하여 &lt;code&gt;--build-arg&lt;/code&gt; 플래그를 사용하여 빌드시 사용자가 설정할 수있는 값을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4064609f278320d6ebc37fe734bebad678e4b1c1" translate="yes" xml:space="preserve">
          <source>A good place to start is the &lt;a href=&quot;../../get-started/index&quot;&gt;Getting Started&lt;/a&gt; tutorial which uses version 3 Compose stack files to implement multi-container apps, service definitions, and swarm mode. Here are some Compose files used in the tutorial.</source>
          <target state="translated">&lt;a href=&quot;../../get-started/index&quot;&gt;시작하기&lt;/a&gt; 좋은 곳 은 버전 3 Compose 스택 파일을 사용하여 다중 컨테이너 앱, 서비스 정의 및 스웜 모드를 구현하는 시작하기 자습서입니다. 학습서에서 사용되는 일부 작성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57123a678f7ee32dadb34a83dadeeced46736e2d" translate="yes" xml:space="preserve">
          <source>A healthcheck indicates that you want a dependency to wait for another container to be &amp;ldquo;healthy&amp;rdquo; (as indicated by a successful state from the healthcheck) before starting.</source>
          <target state="translated">상태 확인은 시작하기 전에 종속성이 다른 컨테이너가 &quot;상태&quot;(상태 확인에서 성공한 상태로 표시됨)가되기를 기다리는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="86b57ac0afcd2ec3453e1527057f7159db50236a" translate="yes" xml:space="preserve">
          <source>A label is a &lt;code&gt;key=value&lt;/code&gt; pair that applies metadata to a container. To label a container with two labels:</source>
          <target state="translated">레이블은 컨테이너에 메타 데이터를 적용 하는 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 두 개의 레이블로 컨테이너에 레이블을 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a2db541b701d8cde05f2bde86c071f6710b9375a" translate="yes" xml:space="preserve">
          <source>A label is a &lt;code&gt;key=value&lt;/code&gt; pair that applies metadata to a service. To label a service with two labels:</source>
          <target state="translated">라벨은 &lt;code&gt;key=value&lt;/code&gt; 서비스에 메타 데이터를 적용 키 = 값 쌍입니다. 두 개의 레이블로 서비스에 레이블을 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="31ffffe8f0585c55dec29f5912017c85b4963540" translate="yes" xml:space="preserve">
          <source>A list of GUN prefixes accepted by this server. POST operations on an image beginning with any other prefix are rejected with a 400, and GET/DELETE operations are rejected with a 404.</source>
          <target state="translated">이 서버가 승인 한 GUN 접두사 목록. 다른 접두사로 시작하는 이미지의 POST 작업은 400으로 거부되고 GET / DELETE 작업은 404로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="4658aa030a14de9486ed225578ba0b2994f8d9f4" translate="yes" xml:space="preserve">
          <source>A list of images that the engine uses for cache resolution.</source>
          <target state="translated">엔진이 캐시 확인에 사용하는 이미지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3d43e8a3c6823d2baef11ad532cd9e2aeb648bb0" translate="yes" xml:space="preserve">
          <source>A local registry service.</source>
          <target state="translated">로컬 레지스트리 서비스</target>
        </trans-unit>
        <trans-unit id="e02a2f30bb2800eac76fe4b8d6f3fb97dc62851c" translate="yes" xml:space="preserve">
          <source>A manager node must be demoted to a worker node (using &lt;code&gt;docker node demote&lt;/code&gt;) before you can remove it from the swarm.</source>
          <target state="translated">관리자 노드는 작업자 노드로 강등되어야합니다 ( &lt;code&gt;docker node demote&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="97d9689329548d74d466b7025edd390221a46859" translate="yes" xml:space="preserve">
          <source>A manifest list is a list of image layers that is created by specifying one or more (ideally more than one) image names. It can then be used in the same way as an image name in &lt;code&gt;docker pull&lt;/code&gt; and &lt;code&gt;docker run&lt;/code&gt; commands, for example.</source>
          <target state="translated">매니페스트 목록은 하나 이상의 이미지 이름을 지정하여 만든 이미지 레이어 목록입니다. 그런 다음 &lt;code&gt;docker pull&lt;/code&gt; 및 &lt;code&gt;docker run&lt;/code&gt; 의 이미지 이름과 동일한 방식으로 사용할 수 있습니다 예를 들어 명령 .</target>
        </trans-unit>
        <trans-unit id="60487e181e3e99a1b32fc04e231b37269a491f13" translate="yes" xml:space="preserve">
          <source>A more detailed view can be requested using the &lt;code&gt;-v, --verbose&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;-v, --verbose&lt;/code&gt; 사용하여 더 자세한보기를 요청할 수 있습니다. 플래그를 .</target>
        </trans-unit>
        <trans-unit id="ab64a5afc130de3156b74aca4ad11b1e50921623" translate="yes" xml:space="preserve">
          <source>A more extended example, defining volumes and networks:</source>
          <target state="translated">볼륨과 네트워크를 정의하는보다 확장 된 예 :</target>
        </trans-unit>
        <trans-unit id="5bbf65455fe2146c2d358cde3ccef3eeb0e31028" translate="yes" xml:space="preserve">
          <source>A network called &lt;code&gt;myapp_default&lt;/code&gt; is created.</source>
          <target state="translated">&lt;code&gt;myapp_default&lt;/code&gt; 라는 네트워크 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="96e33400b5598a9d21af8286542eb28d6649a470" translate="yes" xml:space="preserve">
          <source>A network plugin is developed as part of the OpenStack Kuryr project and implements the Docker networking (libnetwork) remote driver API by utilizing Neutron, the OpenStack networking service. It includes an IPAM driver as well.</source>
          <target state="translated">네트워크 플러그인은 OpenStack Kuryr 프로젝트의 일부로 개발되었으며 OpenStack 네트워킹 서비스 인 Neutron을 사용하여 Docker 네트워킹 (libnetwork) 원격 드라이버 API를 구현합니다. IPAM 드라이버도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="39f0f68a9704a751749ae44b7f16a8a3386d6722" translate="yes" xml:space="preserve">
          <source>A network plugin that creates a virtual network that connects your Docker containers - across multiple hosts or clouds and enables automatic discovery of applications. Weave networks are resilient, partition tolerant, secure and work in partially connected networks, and other adverse environments - all configured with delightful simplicity.</source>
          <target state="translated">여러 호스트 또는 클라우드에서 Docker 컨테이너를 연결하고 애플리케이션을 자동으로 검색 할 수있는 가상 네트워크를 작성하는 네트워크 플러그인입니다. 직조 네트워크는 탄력적이고 파티션에 견딜 수 있으며 부분적으로 연결된 네트워크 및 기타 불리한 환경에서 안전하고 작동합니다. 모두 단순하고 단순하게 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca5e1d97407afa25a47f55ebae7a8cbf028965d" translate="yes" xml:space="preserve">
          <source>A new plugin can be created by running &lt;code&gt;docker plugin create &amp;lt;plugin-name&amp;gt; ./path/to/plugin/data&lt;/code&gt; where the plugin data contains a plugin configuration file &lt;code&gt;config.json&lt;/code&gt; and a root filesystem in subdirectory &lt;code&gt;rootfs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker plugin create &amp;lt;plugin-name&amp;gt; ./path/to/plugin/data&lt;/code&gt; 를 실행하여 새 플러그인을 작성할 수 있습니다. 여기서 플러그인 데이터에는 플러그인 구성 파일 &lt;code&gt;config.json&lt;/code&gt; 및 루트 디렉토리가 &lt;code&gt;rootfs&lt;/code&gt; 서브 시스템에 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e81110dfaaffcbcf035c22948c5a4d14dc3a56" translate="yes" xml:space="preserve">
          <source>A node only has access to (encrypted) secrets if the node is a swarm manager or if it is running service tasks which have been granted access to the secret. When a container task stops running, the decrypted secrets shared to it are unmounted from the in-memory filesystem for that container and flushed from the node&amp;rsquo;s memory.</source>
          <target state="translated">노드가 스웜 관리자이거나 비밀에 대한 액세스 권한이 부여 된 서비스 작업을 실행중인 경우 노드는 (암호화 된) 비밀에 액세스 할 수 있습니다. 컨테이너 작업이 중지되면 공유 된 암호 해독 된 비밀이 해당 컨테이너의 메모리 내 파일 시스템에서 마운트 해제되고 노드의 메모리에서 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="978f377e3716077c3355246c73f00f1ef902a743" translate="yes" xml:space="preserve">
          <source>A node only has access to configs if the node is a swarm manager or if it is running service tasks which have been granted access to the config. When a container task stops running, the configs shared to it are unmounted from the in-memory filesystem for that container and flushed from the node&amp;rsquo;s memory.</source>
          <target state="translated">노드가 swarm manager이거나 구성에 대한 액세스 권한이 부여 된 서비스 태스크를 실행중인 경우 노드는 구성에 액세스 할 수 있습니다. 컨테이너 작업의 실행이 중지되면 공유 된 구성이 해당 컨테이너의 메모리 내 파일 시스템에서 마운트 해제되고 노드의 메모리에서 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="46246e0b7ee24b4188cf9de04b42a74c8a203675" translate="yes" xml:space="preserve">
          <source>A particular image &lt;code&gt;REPOSITORY&lt;/code&gt; can have multiple tags. For example, &lt;code&gt;latest&lt;/code&gt; and &lt;code&gt;3.1.2&lt;/code&gt; are both tags on the &lt;code&gt;mongo&lt;/code&gt; image. An image publisher can build an image and tag combination many times changing the image with each build.</source>
          <target state="translated">특정 이미지 &lt;code&gt;REPOSITORY&lt;/code&gt; 에는 여러 개의 태그가있을 수 있습니다. 예를 들어, &lt;code&gt;latest&lt;/code&gt; 및 &lt;code&gt;3.1.2&lt;/code&gt; 는 &lt;code&gt;mongo&lt;/code&gt; 이미지의 태그입니다 . 이미지 게시자는 각 빌드마다 이미지를 변경하여 이미지와 태그 조합을 여러 번 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c02e9d2874c71186b7b9739cb0290fddf16cc2" translate="yes" xml:space="preserve">
          <source>A plugin is a process running on the same or a different host as the docker daemon, which registers itself by placing a file on the same docker host in one of the plugin directories described in &lt;a href=&quot;#plugin-discovery&quot;&gt;Plugin discovery&lt;/a&gt;.</source>
          <target state="translated">플러그인은 docker 데몬과 동일하거나 다른 호스트에서 실행되는 프로세스로, &lt;a href=&quot;#plugin-discovery&quot;&gt;플러그인 감지에&lt;/a&gt; 설명 된 플러그인 디렉토리 중 하나의 동일한 도커 호스트에 파일을 배치하여 자체적으로 등록합니다. .</target>
        </trans-unit>
        <trans-unit id="63abd67756dd77707cbe809bf44503abebed5e25" translate="yes" xml:space="preserve">
          <source>A plugin that provides credentials and secret management using Keywhiz as a central repository.</source>
          <target state="translated">Keywhiz를 중앙 저장소로 사용하여 자격 증명 및 비밀 관리를 제공하는 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="9f57c80c59b3a82fbd3fef93741c0569e084aeaf" translate="yes" xml:space="preserve">
          <source>A prerequisite for signing an image is a Docker Registry with a Notary server attached (Such as the Docker Hub or Docker Trusted Registry). Instructions for standing up a self-hosted environment can be found &lt;a href=&quot;../deploying_notary/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이미지 서명을위한 전제 조건은 Notary 서버가 연결된 Docker Registry입니다 (Docker Hub 또는 Docker Trusted Registry와 같은). 자체 호스팅 환경을 세우는 방법은 &lt;a href=&quot;../deploying_notary/index&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee865f34820c94686cc75eca1ff8e6083e00862" translate="yes" xml:space="preserve">
          <source>A prerequisite to adding your first contributor is a pair of delegation keys. These keys can either be generated locally using &lt;code&gt;$ docker trust&lt;/code&gt;, generated by a certificate authority, or can be taken from a Universal Control Plane&amp;rsquo;s &lt;a href=&quot;../ee/ucp/user-access/cli/index#download-client-certificates&quot;&gt;Client Bundle&lt;/a&gt;.</source>
          <target state="translated">첫 번째 기고자를 추가하기위한 전제 조건은 한 쌍의 위임 키입니다. 이 키는 &lt;code&gt;$ docker trust&lt;/code&gt; 를 사용하여 로컬로 생성하거나 인증 기관에서 생성하거나 Universal Control Plane의 &lt;a href=&quot;../ee/ucp/user-access/cli/index#download-client-certificates&quot;&gt;클라이언트 번들&lt;/a&gt; 에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75ce05c2da88f4d2e482cede13d9067c26fd5550" translate="yes" xml:space="preserve">
          <source>A profile for the Docker Engine daemon exists but it is not currently installed with the &lt;code&gt;deb&lt;/code&gt; packages. If you are interested in the source for the daemon profile, it is located in &lt;a href=&quot;https://github.com/moby/moby/tree/master/contrib/apparmor&quot;&gt;contrib/apparmor&lt;/a&gt; in the Docker Engine source repository.</source>
          <target state="translated">Docker Engine 데몬의 프로필이 존재하지만 현재 &lt;code&gt;deb&lt;/code&gt; 패키지 와 함께 설치되어 있지 않습니다 . 데몬 프로필의 소스에 관심이 있다면 Docker Engine 소스 저장소의 &lt;a href=&quot;https://github.com/moby/moby/tree/master/contrib/apparmor&quot;&gt;contrib / apparmor&lt;/a&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c142cb791d9d531874b53d29c2d4bd8745bf083" translate="yes" xml:space="preserve">
          <source>A properly configured Engine &lt;code&gt;daemon&lt;/code&gt; on each host in the cluster.</source>
          <target state="translated">클러스터의 각 호스트에서 올바르게 구성된 엔진 &lt;code&gt;daemon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16c5cf0ab9c5c7a90882d12fbc88563e4347f37" translate="yes" xml:space="preserve">
          <source>A registry is a collection of repositories, and a repository is a collection of images&amp;mdash;sort of like a GitHub repository, except the code is already built. An account on a registry can create many repositories. The &lt;code&gt;docker&lt;/code&gt; CLI uses Docker&amp;rsquo;s public registry by default.</source>
          <target state="translated">레지스트리는 리포지토리의 모음이며 리포지토리는 코드가 이미 빌드 된 것을 제외하고는 GitHub 리포지토리와 같은 이미지 모음입니다. 레지스트리의 계정은 많은 저장소를 작성할 수 있습니다. &lt;code&gt;docker&lt;/code&gt; CLI는 기본적으로 부두 노동자의 공개 레지스트리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="36faf2054a0c401d9640fd524b60b86a882758b8" translate="yes" xml:space="preserve">
          <source>A secure registry uses TLS and a copy of its CA certificate is placed on the Docker host at &lt;code&gt;/etc/docker/certs.d/myregistry:5000/ca.crt&lt;/code&gt;. An insecure registry is either not using TLS (i.e., listening on plain text HTTP), or is using TLS with a CA certificate not known by the Docker daemon. The latter can happen when the certificate was not found under &lt;code&gt;/etc/docker/certs.d/myregistry:5000/&lt;/code&gt;, or if the certificate verification failed (i.e., wrong CA).</source>
          <target state="translated">보안 레지스트리는 TLS를 사용하며 해당 CA 인증서 사본은 Docker 호스트의 &lt;code&gt;/etc/docker/certs.d/myregistry:5000/ca.crt&lt;/code&gt; 에 있습니다. 안전하지 않은 레지스트리는 TLS를 사용하지 않거나 (즉, 일반 텍스트 HTTP에서 청취) Docker 데몬이 알 수없는 CA 인증서와 함께 TLS를 사용하고 있습니다. 후자는 인증서가 &lt;code&gt;/etc/docker/certs.d/myregistry:5000/&lt;/code&gt; 에 없거나 인증서 확인에 실패한 경우 (즉, 잘못된 CA)에 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f86a8dd2cad966075588273e695950c5e25ea93" translate="yes" xml:space="preserve">
          <source>A security group is created and associated to the host. This security group has the following ports opened inbound:</source>
          <target state="translated">보안 그룹이 생성되어 호스트와 연결됩니다. 이 보안 그룹에는 다음 포트가 인바운드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="7c71ecfd8bfab76fa91003924dc53e8fd33a8d1a" translate="yes" xml:space="preserve">
          <source>A service definition contains configuration that is applied to each container started for that service, much like passing command-line parameters to &lt;code&gt;docker container create&lt;/code&gt;. Likewise, network and volume definitions are analogous to &lt;code&gt;docker network create&lt;/code&gt; and &lt;code&gt;docker volume create&lt;/code&gt;.</source>
          <target state="translated">서비스 정의에는 명령 행 매개 변수를 &lt;code&gt;docker container create&lt;/code&gt; 로 전달하는 것과 같이 해당 서비스를 위해 시작된 각 컨테이너에 적용되는 구성이 포함 됩니다. 마찬가지로 네트워크 및 볼륨 정의는 &lt;code&gt;docker network create&lt;/code&gt; 및 &lt;code&gt;docker volume create&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1d1b3eafbe92cd5d7d0f9b8b26efefd656eaf142" translate="yes" xml:space="preserve">
          <source>A service definition contains configuration which is applied to each container started for that service, much like passing command-line parameters to &lt;code&gt;docker run&lt;/code&gt;.</source>
          <target state="translated">서비스 정의에는 명령 행 매개 변수를 &lt;code&gt;docker run&lt;/code&gt; 에 전달하는 것과 같이 해당 서비스를 위해 시작된 각 컨테이너에 적용되는 구성이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="714323c6237755de214964cfebd871287cfb7904" translate="yes" xml:space="preserve">
          <source>A service has the following fields:</source>
          <target state="translated">서비스에는 다음과 같은 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e4bdb8577941b3005f75e540b4e3b7d8e41781" translate="yes" xml:space="preserve">
          <source>A service may be configured in such a way that no node currently in the swarm can run its tasks. In this case, the service remains in state &lt;code&gt;pending&lt;/code&gt;. Here are a few examples of when a service might remain in state &lt;code&gt;pending&lt;/code&gt;.</source>
          <target state="translated">현재 웜에있는 노드가 해당 작업을 실행할 수 없도록 서비스를 구성 할 수 있습니다. 이 경우 서비스는 &lt;code&gt;pending&lt;/code&gt; 상태로 유지됩니다 . 다음은 서비스가 상태 &lt;code&gt;pending&lt;/code&gt; 상태에있을 수있는 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="790336543c1f0b254b854297b1a1d799e3ecc617" translate="yes" xml:space="preserve">
          <source>A set of configuration options to set block IO limits for this service.</source>
          <target state="translated">이 서비스에 대한 블록 IO 제한을 설정하기위한 구성 옵션 세트.</target>
        </trans-unit>
        <trans-unit id="80bc14b6ca900454fbfc580851784f2dc998bb4b" translate="yes" xml:space="preserve">
          <source>A single container running in a service is called a &lt;strong&gt;task&lt;/strong&gt;. Tasks are given unique IDs that numerically increment, up to the number of &lt;code&gt;replicas&lt;/code&gt; you defined in &lt;code&gt;docker-compose.yml&lt;/code&gt;. List the tasks for your service:</source>
          <target state="translated">서비스에서 실행되는 단일 컨테이너를 &lt;strong&gt;작업&lt;/strong&gt; 이라고합니다 . 작업에는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 정의한 &lt;code&gt;replicas&lt;/code&gt; 수까지 숫자가 증가하는 고유 한 ID가 제공 됩니다. 서비스 작업을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="314502d692a97fd9ac461bf62119cb0994ff00d3" translate="yes" xml:space="preserve">
          <source>A single manifest is information about an image, such as layers, size, and digest. The docker manifest command also gives users additional information such as the os and architecture an image was built for.</source>
          <target state="translated">단일 매니페스트는 레이어, 크기 및 다이제스트와 같은 이미지에 대한 정보입니다. docker manifest 명령은 또한 이미지가 작성된 OS 및 아키텍처와 같은 추가 정보를 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32305c55480ff92cc38469d2ce32b8272d930e09" translate="yes" xml:space="preserve">
          <source>A stack is created using the &lt;code&gt;docker deploy&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;docker deploy&lt;/code&gt; 명령을 사용하여 스택을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="592b67f53343fd60311a21fcdd663ba05e949d5e" translate="yes" xml:space="preserve">
          <source>A summary of the changes in each release in the current series can now be found on the separate &lt;a href=&quot;https://docs.docker.com/release-notes&quot;&gt;Release Notes page&lt;/a&gt;</source>
          <target state="translated">현재 시리즈의 각 릴리스에서 변경된 사항에 대한 요약은 이제 별도의 &lt;a href=&quot;https://docs.docker.com/release-notes&quot;&gt;릴리스 노트 페이지에서 확인할 수 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9801c04ed5a41b03aa842b8f896e2bb7a8bdb94f" translate="yes" xml:space="preserve">
          <source>A swarm consists of multiple Docker hosts which run in &lt;strong&gt;swarm mode&lt;/strong&gt; and act as managers (to manage membership and delegation) and workers (which run &lt;a href=&quot;index#services-and-tasks&quot;&gt;swarm services&lt;/a&gt;). A given Docker host can be a manager, a worker, or perform both roles. When you create a service, you define its optimal state (number of replicas, network and storage resources available to it, ports the service exposes to the outside world, and more). Docker works to maintain that desired state. For instance, if a worker node becomes unavailable, Docker schedules that node&amp;rsquo;s tasks on other nodes. A &lt;em&gt;task&lt;/em&gt; is a running container which is part of a swarm service and managed by a swarm manager, as opposed to a standalone container.</source>
          <target state="translated">스웜은 &lt;strong&gt;스웜 모드&lt;/strong&gt; 에서 실행 되고 관리자 (멤버십 및 위임을 관리하기 위해) 및 작업자 ( &lt;a href=&quot;index#services-and-tasks&quot;&gt;스웜 서비스&lt;/a&gt; 를 실행하는) 역할을 하는 여러 Docker 호스트로 구성됩니다 . 주어진 Docker 호스트는 관리자, 작업자 또는 두 역할을 모두 수행 할 수 있습니다. 서비스를 만들 때 최적 상태 (사용 가능한 복제본, 네트워크 및 스토리지 리소스 수, 서비스가 외부에 노출하는 포트 등)를 정의합니다. Docker는 원하는 상태를 유지하기 위해 노력합니다. 예를 들어 작업자 노드를 사용할 수 없게되면 Docker는 해당 노드의 작업을 다른 노드에서 예약합니다. &lt;em&gt;작업은&lt;/em&gt; 독립형 컨테이너에 반대, 떼 서비스의 일부이며 떼 관리자에 의해 관리 실행중인 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="43717673da3a4c6e8e011b16bf81f846fad6d59c" translate="yes" xml:space="preserve">
          <source>A swarm is a group of machines that are running Docker and joined into a cluster. After that has happened, you continue to run the Docker commands you&amp;rsquo;re used to, but now they are executed on a cluster by a &lt;strong&gt;swarm manager&lt;/strong&gt;. The machines in a swarm can be physical or virtual. After joining a swarm, they are referred to as &lt;strong&gt;nodes&lt;/strong&gt;.</source>
          <target state="translated">swarm은 Docker를 실행하고 클러스터에 결합 된 시스템 그룹입니다. 그 후에도 익숙한 Docker 명령을 계속 실행하지만 이제는 &lt;strong&gt;swarm manager&lt;/strong&gt; 가 클러스터에서 실행합니다 . 스웜의 머신은 물리적 또는 가상 일 수 있습니다. 떼에 합류 한 후 &lt;strong&gt;노드&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="1023a496f347237d2b757b124973f9865b3b0b3c" translate="yes" xml:space="preserve">
          <source>A swarm is made up of multiple nodes, which can be either physical or virtual machines. The basic concept is simple enough: run &lt;code&gt;docker swarm init&lt;/code&gt; to enable swarm mode and make your current machine a swarm manager, then run &lt;code&gt;docker swarm join&lt;/code&gt; on other machines to have them join the swarm as workers. Choose a tab below to see how this plays out in various contexts. We use VMs to quickly create a two-machine cluster and turn it into a swarm.</source>
          <target state="translated">스웜은 물리적 또는 가상 머신 일 수있는 여러 노드로 구성됩니다. 기본 개념은 간단합니다. &lt;code&gt;docker swarm init&lt;/code&gt; 을 실행하여 swarm 모드를 활성화하고 현재 시스템을 swarm manager로 만든 다음 다른 시스템에서 &lt;code&gt;docker swarm join&lt;/code&gt; 을 실행 하여 작업자로 swarm에 가입시킵니다. 다양한 상황에서 어떻게 작동하는지 보려면 아래 탭을 선택하십시오. 우리는 VM을 사용하여 2 머신 클러스터를 신속하게 생성하고 떼로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="3ce0accada4f97487efbfadb02844b19dc846eb9" translate="yes" xml:space="preserve">
          <source>A tag name must be valid ASCII and may contain lowercase and uppercase letters, digits, underscores, periods and dashes. A tag name may not start with a period or a dash and may contain a maximum of 128 characters.</source>
          <target state="translated">태그 이름은 유효한 ASCII 여야하며 소문자와 대문자, 숫자, 밑줄, 마침표 및 대시를 포함 할 수 있습니다. 태그 이름은 마침표 나 대시로 시작할 수 없으며 최대 128자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08bfe77f61ecc1f94a15bb38024cb474413d82dc" translate="yes" xml:space="preserve">
          <source>A task is a one-directional mechanism. It progresses monotonically through a series of states: assigned, prepared, running, etc. If the task fails the orchestrator removes the task and its container and then creates a new task to replace it according to the desired state specified by the service.</source>
          <target state="translated">작업은 단방향 메커니즘입니다. 할당, 준비, 실행 등 일련의 상태를 통해 단조롭게 진행됩니다. 작업이 실패하면 오케 스트레이터는 작업과 해당 컨테이너를 제거한 다음 서비스에서 지정한 원하는 상태에 따라 새 작업을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="309d0407badd9343850a3d8e63be27e3eb9e1b6b" translate="yes" xml:space="preserve">
          <source>A task is the atomic unit of scheduling within a swarm. When you declare a desired service state by creating or updating a service, the orchestrator realizes the desired state by scheduling tasks. For instance, you define a service that instructs the orchestrator to keep three instances of an HTTP listener running at all times. The orchestrator responds by creating three tasks. Each task is a slot that the scheduler fills by spawning a container. The container is the instantiation of the task. If an HTTP listener task subsequently fails its health check or crashes, the orchestrator creates a new replica task that spawns a new container.</source>
          <target state="translated">작업은 무리 내에서 스케줄링의 원자 단위입니다. 서비스를 만들거나 업데이트하여 원하는 서비스 상태를 선언하면 오케 스트레이터는 작업을 예약하여 원하는 상태를 실현합니다. 예를 들어, 오케 스트레이터가 항상 3 개의 HTTP 리스너 인스턴스를 계속 실행하도록 지시하는 서비스를 정의합니다. 오케 스트레이터는 세 가지 작업을 만들어 응답합니다. 각 작업은 컨테이너를 생성하여 스케줄러가 채우는 슬롯입니다. 컨테이너는 작업의 인스턴스입니다. HTTP 리스너 태스크가 상태 점검에 실패하거나 충돌하는 경우 오케 스트레이터는 새 컨테이너를 생성하는 새 복제본 태스크를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="8ad1e3f8b15f65258fcf755ad618554339543c4c" translate="yes" xml:space="preserve">
          <source>A three-manager swarm tolerates a maximum loss of one manager.</source>
          <target state="translated">3 명의 관리자 떼는 한 명의 관리자의 최대 손실을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="92106bd3f603a0dab749bf611487973a0b748787" translate="yes" xml:space="preserve">
          <source>A threshold of &lt;code&gt;1&lt;/code&gt; indicates that only one of the keys specified in &lt;code&gt;KEY IDS&lt;/code&gt; is required to publish to this delegation. Thresholds other than 1 are not currently supported. To remove a delegation role entirely, or just individual keys and/or paths, use the &lt;code&gt;notary delegation remove&lt;/code&gt; command:</source>
          <target state="translated">임계 값 &lt;code&gt;1&lt;/code&gt; 은이 위임에 게시하기 위해 &lt;code&gt;KEY IDS&lt;/code&gt; 에 지정된 키 중 하나만 필요함을 나타냅니다 . 1 이외의 임계 값은 현재 지원되지 않습니다. 위임 역할을 완전히 제거하거나 개별 키 및 / 또는 경로 만 &lt;code&gt;notary delegation remove&lt;/code&gt; 하려면 공증인 위임 remove 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1405be282e960035c2e49a3fe17958267755e3b" translate="yes" xml:space="preserve">
          <source>A user builds this file by calling:</source>
          <target state="translated">사용자는 다음을 호출하여이 파일을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="48f365e17e1139cdeec957ee0b113044a97090c5" translate="yes" xml:space="preserve">
          <source>A value is optional:</source>
          <target state="translated">값은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1e5b4a75e128dc84adfdb499678694ec7751861b" translate="yes" xml:space="preserve">
          <source>A volume plug-in that integrates with Nimble Storage Unified Flash Fabric arrays. The plug-in abstracts array volume capabilities to the Docker administrator to allow self-provisioning of secure multi-tenant volumes and clones.</source>
          <target state="translated">Nimble Storage Unified Flash Fabric 어레이와 통합되는 볼륨 플러그인. 플러그인은 어레이 볼륨 기능을 Docker 관리자에게 추상화하여 안전한 멀티 테넌트 볼륨 및 클론의 자체 프로비저닝을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="76933dfd3c519777c7e5fce4842da9ecf881ea36" translate="yes" xml:space="preserve">
          <source>A volume plugin able to attach, format and mount Google Compute &lt;a href=&quot;https://cloud.google.com/compute/docs/disks/persistent-disks&quot;&gt;persistent-disks&lt;/a&gt;.</source>
          <target state="translated">수 플러그인 볼륨은 첨부 형식과 구글 컴퓨 트를 탑재 &lt;a href=&quot;https://cloud.google.com/compute/docs/disks/persistent-disks&quot;&gt;지속적인-디스크를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98dd42a130f100ec81df9ec048cf0ba6738fd181" translate="yes" xml:space="preserve">
          <source>A volume plugin for a variety of storage back-ends including device mapper and NFS. It&amp;rsquo;s a simple standalone executable written in Go and provides the framework to support vendor-specific extensions such as snapshots, backups and restore.</source>
          <target state="translated">장치 맵퍼 ​​및 NFS를 포함한 다양한 스토리지 백엔드를위한 볼륨 플러그인. Go로 작성된 간단한 독립 실행 형 실행 파일이며 스냅 샷, 백업 및 복원과 같은 공급 업체별 확장을 지원하는 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93f75902d5093d2d8222915aeb075f9bc89dd1f8" translate="yes" xml:space="preserve">
          <source>A volume plugin that allows on-demand, version controlled access to your data. Horcrux is an open-source plugin, written in Go, and supports SCP, &lt;a href=&quot;https://www.minio.io&quot;&gt;Minio&lt;/a&gt; and Amazon S3.</source>
          <target state="translated">주문형 버전으로 데이터에 액세스 할 수있는 볼륨 플러그인입니다. Horcrux는 Go로 작성된 오픈 소스 플러그인이며 SCP, &lt;a href=&quot;https://www.minio.io&quot;&gt;Minio&lt;/a&gt; 및 Amazon S3를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2991ca01a0dfcb3cb8abdbf99799e5d4a483f0c5" translate="yes" xml:space="preserve">
          <source>A volume plugin that connects Docker to &lt;a href=&quot;http://www.quobyte.com/containers&quot;&gt;Quobyte&lt;/a&gt;&amp;rsquo;s data center file system, a general-purpose scalable and fault-tolerant storage platform.</source>
          <target state="translated">Docker를 범용 확장 가능 및 내결함성 스토리지 플랫폼 인 &lt;a href=&quot;http://www.quobyte.com/containers&quot;&gt;Quobyte&lt;/a&gt; 의 데이터 센터 파일 시스템에 연결하는 볼륨 플러그인 .</target>
        </trans-unit>
        <trans-unit id="885b18dd051ca453adc1396df3190391a2cd7602" translate="yes" xml:space="preserve">
          <source>A volume plugin that extends the default &lt;code&gt;local&lt;/code&gt; driver&amp;rsquo;s functionality by allowing you specify a mountpoint anywhere on the host, which enables the files to &lt;em&gt;always persist&lt;/em&gt;, even if the volume is removed via &lt;code&gt;docker volume rm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker volume rm&lt;/code&gt; 통해 볼륨을 제거하더라도 파일을 &lt;em&gt;항상 유지할&lt;/em&gt; 수 있도록 호스트의 어느 위치 에나 마운트 포인트를 지정할 수 있도록 하여 기본 &lt;code&gt;local&lt;/code&gt; 드라이버 기능 을 확장하는 볼륨 플러그인 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91d92ffa8c2371ff0e8c3ce65266c16352729254" translate="yes" xml:space="preserve">
          <source>A volume plugin that is developed as part of the OpenStack Kuryr project and implements the Docker volume plugin API by utilizing Cinder, the OpenStack block storage service.</source>
          <target state="translated">OpenStack Kuryr 프로젝트의 일부로 개발 된 볼륨 플러그인이며 OpenStack 블록 스토리지 서비스 인 Cinder를 사용하여 Docker 볼륨 플러그인 API를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2a73e4c6ba946ee48cdcca240f380aad6775d787" translate="yes" xml:space="preserve">
          <source>A volume plugin that makes it easy to mount and manage Infinit volumes using Docker.</source>
          <target state="translated">Docker를 사용하여 Infinit 볼륨을 쉽게 마운트하고 관리 할 수있는 볼륨 플러그인.</target>
        </trans-unit>
        <trans-unit id="db5355f8120d579d8f7d297a7ebe58984f9f949b" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides access to an extensible set of container-based persistent storage options. It supports single and multi-host Docker environments with features that include tenant isolation, automated provisioning, encryption, secure deletion, snapshots and QoS.</source>
          <target state="translated">확장 가능한 컨테이너 기반 영구 스토리지 옵션 세트에 대한 액세스를 제공하는 볼륨 플러그인. 테넌트 격리, 자동화 된 프로비저닝, 암호화, 보안 삭제, 스냅 샷 및 QoS를 포함하는 기능으로 단일 및 다중 호스트 Docker 환경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4d4a53a99c3090b98f4bac641dcd9565907791ad" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides direct integration with the Docker ecosystem for the NetApp storage portfolio. The nDVP package supports the provisioning and management of storage resources from the storage platform to Docker hosts, with a robust framework for adding additional platforms in the future.</source>
          <target state="translated">NetApp 스토리지 포트폴리오를 위해 Docker 에코 시스템과 직접 통합 할 수있는 볼륨 플러그인입니다. nDVP 패키지는 향후 플랫폼을 추가 할 수있는 강력한 프레임 워크를 통해 스토리지 플랫폼에서 Docker 호스트로의 스토리지 리소스 프로비저닝 및 관리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1f0389cfc248bc08ca8572dc3ff03c325b624fe7" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides highly available storage replicated by &lt;a href=&quot;https://www.drbd.org&quot;&gt;DRBD&lt;/a&gt;. Data written to the docker volume is replicated in a cluster of DRBD nodes.</source>
          <target state="translated">&lt;a href=&quot;https://www.drbd.org&quot;&gt;DRBD에&lt;/a&gt; 의해 복제 된 고 가용성 스토리지를 제공하는 볼륨 플러그인 . 도커 볼륨에 기록 된 데이터는 DRBD 노드 클러스터에 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="42015e9bac08c89ffd2b487b66cb360bbf843e52" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides multi-host portable volumes for Docker, enabling you to run databases and other stateful containers and move them around across a cluster of machines.</source>
          <target state="translated">Docker에 멀티 호스트 휴대용 볼륨을 제공하는 볼륨 플러그인으로 데이터베이스 및 기타 상태 저장 컨테이너를 실행하고 시스템 클러스터간에 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="589708953079c041a154b6813d9e073a1dd8390c" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides multi-host volumes management for Docker using GlusterFS.</source>
          <target state="translated">GlusterFS를 사용하여 Docker에 멀티 호스트 볼륨 관리를 제공하는 볼륨 플러그인.</target>
        </trans-unit>
        <trans-unit id="9c7ca66727ab87bbc538582b0a4c637397aaf3c6" translate="yes" xml:space="preserve">
          <source>A volume plugin that provides volume management for NFS 3/4, AWS EFS and CIFS file systems.</source>
          <target state="translated">NFS 3/4, AWS EFS 및 CIFS 파일 시스템에 대한 볼륨 관리를 제공하는 볼륨 플러그인.</target>
        </trans-unit>
        <trans-unit id="019d0d3f0e36cc3f3679319217999dc440cc6cfc" translate="yes" xml:space="preserve">
          <source>A volume plugin that supports HPE 3Par and StoreVirtual iSCSI storage arrays.</source>
          <target state="translated">HPE 3Par 및 StoreVirtual iSCSI 스토리지 배열을 지원하는 볼륨 플러그인.</target>
        </trans-unit>
        <trans-unit id="eb324c38b0b3d991cb28265d41ea4cf850467a3a" translate="yes" xml:space="preserve">
          <source>A volume plugin that turns any server into a scale-out converged compute/storage node, providing container granular storage and highly available volumes across any node, using a shared-nothing storage backend that works with any docker scheduler.</source>
          <target state="translated">모든 서버를 스케일 아웃 수렴 컴퓨팅 / 스토리지 노드로 전환하는 볼륨 플러그인은 모든 도커 스케줄러와 함께 작동하는 비공유 스토리지 백엔드를 사용하여 컨테이너 단위의 스토리지 및 고 가용성 볼륨을 모든 노드에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a6be768aa9e012cbf533c9ac9bb5577b5809230d" translate="yes" xml:space="preserve">
          <source>A volume plugin which is written in Go and provides advanced storage functionality for many platforms including VirtualBox, EC2, Google Compute Engine, OpenStack, and EMC.</source>
          <target state="translated">Go로 작성되었으며 VirtualBox, EC2, Google Compute Engine, OpenStack 및 EMC를 포함한 많은 플랫폼에 고급 스토리지 기능을 제공하는 볼륨 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="51b358e4f995d73ec3fd2d2847517cfd6f17cb1c" translate="yes" xml:space="preserve">
          <source>A volume plugin with support for Virtuozzo Storage distributed cloud file system as well as ploop devices.</source>
          <target state="translated">Virtuozzo 스토리지 분산 클라우드 파일 시스템 및 ploop 장치를 지원하는 볼륨 플러그인.</target>
        </trans-unit>
        <trans-unit id="5401e35164563e306c57021aa422669b990c3af5" translate="yes" xml:space="preserve">
          <source>A warning will be issued when trying to remove a network that has containers attached.</source>
          <target state="translated">컨테이너가 연결된 네트워크를 제거하려고하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f9460492306d4b99cd31848c3a99a26a7e978d96" translate="yes" xml:space="preserve">
          <source>ADD</source>
          <target state="translated">ADD</target>
        </trans-unit>
        <trans-unit id="10f571c6c77d08827749c133055b4edec5fc902c" translate="yes" xml:space="preserve">
          <source>ADD has two forms:</source>
          <target state="translated">ADD에는 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49148fe39b957b64b85fec42c39c73cb52061869" translate="yes" xml:space="preserve">
          <source>AMI ID</source>
          <target state="translated">AMI ID</target>
        </trans-unit>
        <trans-unit id="12a69074f664e7cf68612bda87862c8089c375c3" translate="yes" xml:space="preserve">
          <source>API 1.25+</source>
          <target state="translated">API 1.25 이상</target>
        </trans-unit>
        <trans-unit id="ff4579249b8d9f7debc17d0f0f684985d2824f72" translate="yes" xml:space="preserve">
          <source>API 1.28+</source>
          <target state="translated">API 1.28+</target>
        </trans-unit>
        <trans-unit id="dfe30fb03aa8c8b845cf5943bb461b184aa42c39" translate="yes" xml:space="preserve">
          <source>API 1.29+</source>
          <target state="translated">API 1.29+</target>
        </trans-unit>
        <trans-unit id="3e27dfca5d242d13593fbec8398fdfc33a56ac17" translate="yes" xml:space="preserve">
          <source>API 1.30+</source>
          <target state="translated">API 1.30+</target>
        </trans-unit>
        <trans-unit id="cfde678c3d1fe18898d7d703ec2dc9765660eed8" translate="yes" xml:space="preserve">
          <source>API 1.31+</source>
          <target state="translated">API 1.31+</target>
        </trans-unit>
        <trans-unit id="4a401ce70ba03f346ad843e2c9d595f0df3a221b" translate="yes" xml:space="preserve">
          <source>API 1.32+</source>
          <target state="translated">API 1.32+</target>
        </trans-unit>
        <trans-unit id="064ede72370a332c334a0911b1138ce53fe65d4b" translate="yes" xml:space="preserve">
          <source>API 1.35+</source>
          <target state="translated">API 1.35 이상</target>
        </trans-unit>
        <trans-unit id="ea6d62aa0c3c24f2d56088e186f628bc02b46a70" translate="yes" xml:space="preserve">
          <source>API 1.37+</source>
          <target state="translated">API 1.37+</target>
        </trans-unit>
        <trans-unit id="0296d868dea3b52307e857ecebd4b8590e5db353" translate="yes" xml:space="preserve">
          <source>API 1.39+</source>
          <target state="translated">API 1.39 이상</target>
        </trans-unit>
        <trans-unit id="1f79548cb033f910a04e8541c0beaf081afa0f3d" translate="yes" xml:space="preserve">
          <source>API 1.40+</source>
          <target state="translated">API 1.40 이상</target>
        </trans-unit>
        <trans-unit id="09d192ff4c45f5ed8beb0aa83bf1919268257c0e" translate="yes" xml:space="preserve">
          <source>API calls without a version</source>
          <target state="translated">버전이없는 API 호출</target>
        </trans-unit>
        <trans-unit id="dc97af49600bc4b8179ef57578d026a044873f5c" translate="yes" xml:space="preserve">
          <source>API design</source>
          <target state="translated">API 디자인</target>
        </trans-unit>
        <trans-unit id="3f01ac39310b73346755e6a308c0ec4f2b84f709" translate="yes" xml:space="preserve">
          <source>API schema and implementation</source>
          <target state="translated">API 스키마 및 구현</target>
        </trans-unit>
        <trans-unit id="4df80bd4632ed783fad4a198f80e597ab173a602" translate="yes" xml:space="preserve">
          <source>API versions should be supplied to all API calls to ensure compatibility with future Engine versions. Instead of just requesting, for example, the URL &lt;code&gt;/containers/json&lt;/code&gt;, you must now request &lt;code&gt;/v1.25/containers/json&lt;/code&gt;.</source>
          <target state="translated">향후 엔진 버전과의 호환성을 보장하기 위해 모든 API 호출에 API 버전을 제공해야합니다. 예를 들어 URL &lt;code&gt;/containers/json&lt;/code&gt; 을 요청하는 대신 이제 &lt;code&gt;/v1.25/containers/json&lt;/code&gt; 을 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bf4bfe19973cd654ca0a93d9dc35151a746ed63" translate="yes" xml:space="preserve">
          <source>ARG</source>
          <target state="translated">ARG</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">ASP.NET 코어</target>
        </trans-unit>
        <trans-unit id="20fb62b552209fd4bb699daab1e48515b1652639" translate="yes" xml:space="preserve">
          <source>ASP.NET Core apps can run on &lt;a href=&quot;https://www.microsoft.com/net/core/platform&quot;&gt;.NET Core&lt;/a&gt; or on the full &lt;a href=&quot;https://www.microsoft.com/net/framework&quot;&gt;.NET Framework&lt;/a&gt;</source>
          <target state="translated">ASP.NET Core 앱은 &lt;a href=&quot;https://www.microsoft.com/net/core/platform&quot;&gt;.NET Core&lt;/a&gt; 또는 전체 &lt;a href=&quot;https://www.microsoft.com/net/framework&quot;&gt;.NET Framework&lt;/a&gt; 에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7320635dd0577d4df5010f5608689b0d13c76886" translate="yes" xml:space="preserve">
          <source>AUDIT_CONTROL</source>
          <target state="translated">AUDIT_CONTROL</target>
        </trans-unit>
        <trans-unit id="3cbe25fba0585b12e45ae6cc453bcdf45d27c655" translate="yes" xml:space="preserve">
          <source>AUDIT_WRITE</source>
          <target state="translated">AUDIT_WRITE</target>
        </trans-unit>
        <trans-unit id="eedae416c84fcc5844c467785c996ec59ee924cc" translate="yes" xml:space="preserve">
          <source>AWS Example</source>
          <target state="translated">AWS 예</target>
        </trans-unit>
        <trans-unit id="3854b9820877f3d7a09fd456be64c37b449a62d5" translate="yes" xml:space="preserve">
          <source>AWS credential file</source>
          <target state="translated">AWS 자격 증명 파일</target>
        </trans-unit>
        <trans-unit id="9031f8bfdd26a14218a2a026cb8a1d63b064859a" translate="yes" xml:space="preserve">
          <source>About Docker Content Trust (DCT)</source>
          <target state="translated">Docker Content Trust (DCT) 정보</target>
        </trans-unit>
        <trans-unit id="18a115b03e0d6ab03bb1d134602ed2f2b52c14a3" translate="yes" xml:space="preserve">
          <source>About Docker Engine</source>
          <target state="translated">Docker Engine 정보</target>
        </trans-unit>
        <trans-unit id="77541314ec7db8ea068f98f7de083af81c664f9f" translate="yes" xml:space="preserve">
          <source>About configs</source>
          <target state="translated">구성 정보</target>
        </trans-unit>
        <trans-unit id="b1d848c664fa7ecc91f00f70fa167d9319ea99e5" translate="yes" xml:space="preserve">
          <source>About remapping and subordinate user and group IDs</source>
          <target state="translated">재 맵핑 및 종속 사용자 및 그룹 ID</target>
        </trans-unit>
        <trans-unit id="99260a6c5c53e1697f0fcf0ad4c613390a035ebc" translate="yes" xml:space="preserve">
          <source>About secrets</source>
          <target state="translated">비밀에 대하여</target>
        </trans-unit>
        <trans-unit id="7d7409b2000c507d27daa77b02fcbfe7ea01f5d7" translate="yes" xml:space="preserve">
          <source>About services</source>
          <target state="translated">서비스에 대하여</target>
        </trans-unit>
        <trans-unit id="eb504ba616a4717b3ecb24820c6b3de4e3cc9b0d" translate="yes" xml:space="preserve">
          <source>About this guide</source>
          <target state="translated">이 안내서에 대하여</target>
        </trans-unit>
        <trans-unit id="f34ab42c13e12220027bc3634f92c80a5c3f4086" translate="yes" xml:space="preserve">
          <source>Access &lt;code&gt;http://localhost:30000/&lt;/code&gt; from any swarm node and set up WordPress using the web-based wizard. All of these settings are stored in the MySQL &lt;code&gt;wordpress&lt;/code&gt; database. WordPress automatically generates a password for your WordPress user, which is completely different from the password WordPress uses to access MySQL. Store this password securely, such as in a password manager. You need it to log into WordPress after &lt;a href=&quot;#example-rotate-a-secret&quot;&gt;rotating the secret&lt;/a&gt;.</source>
          <target state="translated">모든 swarm 노드에서 &lt;code&gt;http://localhost:30000/&lt;/code&gt; 액세스 하고 웹 기반 마법사를 사용하여 WordPress를 설정하십시오. 이 모든 설정은 MySQL &lt;code&gt;wordpress&lt;/code&gt; 데이터베이스에 저장 됩니다. WordPress는 WordPress 사용자의 비밀번호를 자동으로 생성하는데, 이는 WordPress가 MySQL에 액세스하기 위해 사용하는 비밀번호와는 완전히 다릅니다. 이 비밀번호는 비밀번호 관리자와 같이 안전하게 저장하십시오. 당신 &lt;a href=&quot;#example-rotate-a-secret&quot;&gt;은 비밀&lt;/a&gt; 을 회전 한 후 워드 프레스에 로그인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc92eb7c8f0d2977b991977ad6a26c7af7154b9" translate="yes" xml:space="preserve">
          <source>Access an NVIDIA GPU</source>
          <target state="translated">NVIDIA GPU에 액세스</target>
        </trans-unit>
        <trans-unit id="123bfe1e74ad3d95bf8da6e76afb4574b91a2087" translate="yes" xml:space="preserve">
          <source>Access authorization</source>
          <target state="translated">액세스 권한</target>
        </trans-unit>
        <trans-unit id="74dd8ffbd5d11c80e27a72e73b82424d6c5fe2a6" translate="yes" xml:space="preserve">
          <source>Access authorization plugin</source>
          <target state="translated">액세스 권한 플러그인</target>
        </trans-unit>
        <trans-unit id="4f128e0de4cb25db137b2f212e263926501e771a" translate="yes" xml:space="preserve">
          <source>Access the IIS service at &lt;code&gt;http://localhost:8000/&lt;/code&gt;. It should serve the HTML content from the first step.</source>
          <target state="translated">&lt;code&gt;http://localhost:8000/&lt;/code&gt; 에서 IIS 서비스에 액세스하십시오 . 첫 번째 단계부터 HTML 컨텐츠를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6db3f1c0cb2e875e72b68dd485618bfdab930a02" translate="yes" xml:space="preserve">
          <source>Access to a key-value store. Engine supports Consul, Etcd, and ZooKeeper (Distributed store) key-value stores.</source>
          <target state="translated">키-값 저장소에 액세스 엔진은 Consul, Etcd 및 ZooKeeper (분산 저장소) 키-값 저장소를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6ffba44826c32609aea24e8eac639e162ab8fb14" translate="yes" xml:space="preserve">
          <source>Accessing driver-specific flags in the help text</source>
          <target state="translated">도움말 텍스트에서 드라이버 별 플래그에 액세스</target>
        </trans-unit>
        <trans-unit id="d5869382d7d41391c8dda94346e42825ca9ddbb0" translate="yes" xml:space="preserve">
          <source>Accessing your cluster</source>
          <target state="translated">클러스터에 액세스</target>
        </trans-unit>
        <trans-unit id="ab7d78e36c72f9952567a92a535eae6514599390" translate="yes" xml:space="preserve">
          <source>Account verification and security credentials (for cloud providers), specific to the cloud service you are using</source>
          <target state="translated">사용중인 클라우드 서비스와 관련된 계정 확인 및 보안 자격 증명 (클라우드 공급자 용)</target>
        </trans-unit>
        <trans-unit id="c12f226d2182c5c5d84e15be877820efabf2fc84" translate="yes" xml:space="preserve">
          <source>Accounting syscall which could let containers disable their own resource limits or process accounting. Also gated by &lt;code&gt;CAP_SYS_PACCT&lt;/code&gt;.</source>
          <target state="translated">컨테이너가 자체 리소스 제한을 해제하거나 계정을 처리 할 수있는 계정 시스템 콜. 또한 &lt;code&gt;CAP_SYS_PACCT&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="c193e7e9bf2ca4d2846394e9bd0d0b62debdc1a3" translate="yes" xml:space="preserve">
          <source>Action on rollback failure (&amp;ldquo;pause&amp;rdquo;|&amp;rdquo;continue&amp;rdquo;)</source>
          <target state="translated">롤백 실패에 대한 조치 ( &quot;일시 정지&quot;| &quot;계속&quot;)</target>
        </trans-unit>
        <trans-unit id="cb24aa7767a429fa54eabcb5d7fa710fc08c1510" translate="yes" xml:space="preserve">
          <source>Action on rollback failure (&amp;ldquo;pause&amp;rdquo;|&amp;rdquo;continue&amp;rdquo;) (default &amp;ldquo;pause&amp;rdquo;)</source>
          <target state="translated">롤백 실패에 대한 조치 ( &quot;일시 정지&quot;| &quot;계속&quot;) (기본 &quot;일시 정지&quot;)</target>
        </trans-unit>
        <trans-unit id="737e3eaf263f49c9aa048558ff1072bab5b48241" translate="yes" xml:space="preserve">
          <source>Action on update failure (&amp;ldquo;pause&amp;rdquo;|&amp;rdquo;continue&amp;rdquo;|&amp;rdquo;rollback&amp;rdquo;)</source>
          <target state="translated">업데이트 실패시 조치 ( &quot;일시 정지&quot;| &quot;계속&quot;| &quot;롤백&quot;)</target>
        </trans-unit>
        <trans-unit id="a7b19b293f68407fa86c1ee12850d2df89b955ee" translate="yes" xml:space="preserve">
          <source>Action on update failure (&amp;ldquo;pause&amp;rdquo;|&amp;rdquo;continue&amp;rdquo;|&amp;rdquo;rollback&amp;rdquo;) (default &amp;ldquo;pause&amp;rdquo;)</source>
          <target state="translated">업데이트 실패시 조치 ( &quot;일시 중지&quot;| &quot;계속&quot;| &quot;롤백&quot;) (기본 &quot;일시 중지&quot;)</target>
        </trans-unit>
        <trans-unit id="73ebb1c72ccdeae40133b6674f0b49f1626ea85b" translate="yes" xml:space="preserve">
          <source>Activate Enterprise Edition</source>
          <target state="translated">Enterprise Edition 활성화</target>
        </trans-unit>
        <trans-unit id="6d364d2d4387dedc61f1b1400b23e1d5de77220a" translate="yes" xml:space="preserve">
          <source>Activate Enterprise Edition.</source>
          <target state="translated">Enterprise Edition을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="355b449c8e0d200d611ed73375f21748e051f9cf" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Status&lt;/code&gt; field to &lt;code&gt;VolumeDriver.Get&lt;/code&gt; response (&lt;a href=&quot;https://github.com/docker/docker/pull/21006#&quot;&gt;#21006&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;VolumeDriver.Get&lt;/code&gt; &lt;code&gt;Status&lt;/code&gt; 필드 추가 응답 가져 오기 ( &lt;a href=&quot;https://github.com/docker/docker/pull/21006#&quot;&gt;# 21006&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="23d44f6105529d01f3cda73fa267b0195a28b2d2" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;VolumeDriver.Capabilities&lt;/code&gt; to get capabilities of the volume driver (&lt;a href=&quot;https://github.com/docker/docker/pull/22077&quot;&gt;#22077&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;VolumeDriver.Capabilities&lt;/code&gt; 를 추가 하여 볼륨 드라이버의 기능을 사용하십시오 ( &lt;a href=&quot;https://github.com/docker/docker/pull/22077&quot;&gt;# 22077&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="17b2e7948e67188a4452d41e5b43c90ea7e4bea5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;VolumeDriver.Get&lt;/code&gt; which gets the details about the volume (&lt;a href=&quot;https://github.com/docker/docker/pull/16534&quot;&gt;#16534&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;VolumeDriver.Get&lt;/code&gt; 를 추가 합니다. 볼륨에 대한 세부 정보를 가져옵니다 ( &lt;a href=&quot;https://github.com/docker/docker/pull/16534&quot;&gt;# 16534&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4dc267f5daed97042654e4cf70dd0419bb85a3f3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;VolumeDriver.List&lt;/code&gt; which lists all volumes owned by the driver (&lt;a href=&quot;https://github.com/docker/docker/pull/16534&quot;&gt;#16534&lt;/a&gt;)</source>
          <target state="translated">드라이버가 소유 한 모든 볼륨을 나열하는 &lt;code&gt;VolumeDriver.List&lt;/code&gt; 추가 ( &lt;a href=&quot;https://github.com/docker/docker/pull/16534&quot;&gt;# 16534&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="348ad7434edc37eb05d9deb3437bdf568a77d89f" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;docker-compose&lt;/code&gt; to the plugins list in &lt;code&gt;~/.zshrc&lt;/code&gt; to run autocompletion within the oh-my-zsh shell. In the following example, &lt;code&gt;...&lt;/code&gt; represent other Zsh plugins you may have installed.</source>
          <target state="translated">&lt;code&gt;~/.zshrc&lt;/code&gt; 의 플러그인 목록에 &lt;code&gt;docker&lt;/code&gt; 및 &lt;code&gt;docker-compose&lt;/code&gt; 를 추가 하여 oh-my-zsh 셸 내에서 자동 완성을 실행합니다. 다음 예에서 &lt;code&gt;...&lt;/code&gt; 는 설치 한 다른 Zsh 플러그인을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb72c9884d5d1c600df37817db02aa66487ec234" translate="yes" xml:space="preserve">
          <source>Add Linux capabilities</source>
          <target state="translated">리눅스 기능 추가</target>
        </trans-unit>
        <trans-unit id="0d542177d61e7a2b014c7fb95c2f197b01940cba" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;version: '2'&lt;/code&gt; line at the top of the file.</source>
          <target state="translated">파일 상단에 &lt;code&gt;version: '2'&lt;/code&gt; 줄 버전을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="8e018d7ad94b14e693d2aa7a3335f660b3f6d795" translate="yes" xml:space="preserve">
          <source>Add a Generic resource</source>
          <target state="translated">일반 자원 추가</target>
        </trans-unit>
        <trans-unit id="0be6b081e2cafd9f7cb2185f98cf0f5eb1f71b63" translate="yes" xml:space="preserve">
          <source>Add a config to Docker. The &lt;code&gt;docker config create&lt;/code&gt; command reads standard input because the last argument, which represents the file to read the config from, is set to &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Docker에 구성을 추가하십시오. &lt;code&gt;docker config create&lt;/code&gt; 에서 설정을 읽을 수있는 파일을 나타내는 마지막 인수는, 설정되어 있기 때문에 명령은 표준 입력을 읽습니다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e877c502f1270858e2060b33697fc8e8497cf1" translate="yes" xml:space="preserve">
          <source>Add a custom host-to-IP mapping (host:ip)</source>
          <target state="translated">사용자 정의 호스트 -IP 매핑 추가 (host : ip)</target>
        </trans-unit>
        <trans-unit id="b665c2001f223f166f9534b1eae4d7bad33a0e24" translate="yes" xml:space="preserve">
          <source>Add a delegation private key</source>
          <target state="translated">위임 개인 키 추가</target>
        </trans-unit>
        <trans-unit id="5b3d2d5568b63a5f4e7fb0faa66870ee24264c3a" translate="yes" xml:space="preserve">
          <source>Add a delegation public key</source>
          <target state="translated">위임 공개 키 추가</target>
        </trans-unit>
        <trans-unit id="96b15c535256d2f90c033602379c46f57390244d" translate="yes" xml:space="preserve">
          <source>Add a host device to the container</source>
          <target state="translated">컨테이너에 호스트 장치 추가</target>
        </trans-unit>
        <trans-unit id="762a670ea782c752c0dc150972e09c685758ec08" translate="yes" xml:space="preserve">
          <source>Add a host without a driver</source>
          <target state="translated">드라이버없이 호스트 추가</target>
        </trans-unit>
        <trans-unit id="7464111e21132fb5db817d6ec323bf9ac1991e2b" translate="yes" xml:space="preserve">
          <source>Add a link-local address for the container</source>
          <target state="translated">컨테이너의 링크 로컬 주소 추가</target>
        </trans-unit>
        <trans-unit id="445c99c3b840ea63787ee25d31c91c152c88b842" translate="yes" xml:space="preserve">
          <source>Add a network</source>
          <target state="translated">네트워크 추가</target>
        </trans-unit>
        <trans-unit id="693e83ea169f4f0fa53a90d456d75cfe3222e246" translate="yes" xml:space="preserve">
          <source>Add a new service and redeploy</source>
          <target state="translated">새로운 서비스 추가 및 재배치</target>
        </trans-unit>
        <trans-unit id="659586781d56c2cbd076a7514ac477c510c30e7e" translate="yes" xml:space="preserve">
          <source>Add a placement preference</source>
          <target state="translated">게재 위치 환경 설정 추가</target>
        </trans-unit>
        <trans-unit id="e7b336fde52dea9820d6c1d49f4fe47847d34844" translate="yes" xml:space="preserve">
          <source>Add a rule to the cgroup allowed devices list</source>
          <target state="translated">cgroup allowed devices 목록에 규칙 추가</target>
        </trans-unit>
        <trans-unit id="78bf3766c89ae3127114f37939e931f9567a72f0" translate="yes" xml:space="preserve">
          <source>Add a secret to Docker. The &lt;code&gt;docker secret create&lt;/code&gt; command reads standard input because the last argument, which represents the file to read the secret from, is set to &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Docker에 비밀을 추가하십시오. &lt;code&gt;docker secret create&lt;/code&gt; 에서 비밀을 읽을 수있는 파일을 나타내는 마지막 인수는, 설정되어 있기 때문에 명령은 표준 입력을 읽습니다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="792f83a8fcdd10d44c27fe412d779ea488ff7ca3" translate="yes" xml:space="preserve">
          <source>Add a signer</source>
          <target state="translated">서명자 추가</target>
        </trans-unit>
        <trans-unit id="cd24dccef3f5663205e2aaedcd4f510979df0fcd" translate="yes" xml:space="preserve">
          <source>Add additional groups to join</source>
          <target state="translated">가입 할 다른 그룹 추가</target>
        </trans-unit>
        <trans-unit id="90106c55cb35fd04cec2c8a40ac04df1e1893ff3" translate="yes" xml:space="preserve">
          <source>Add additional information to a local image manifest</source>
          <target state="translated">로컬 이미지 매니페스트에 추가 정보 추가</target>
        </trans-unit>
        <trans-unit id="ad790d1833df1cfba354e9dcf7b54d35a45d621d" translate="yes" xml:space="preserve">
          <source>Add an additional supplementary user group to the container</source>
          <target state="translated">컨테이너에 추가 사용자 그룹 추가</target>
        </trans-unit>
        <trans-unit id="c243500e71bfcae68b152972b8c1415b2d116334" translate="yes" xml:space="preserve">
          <source>Add an apt Proxy setting &lt;code&gt;echo 'Acquire::http { Proxy &quot;http://dockerhost:3142&quot;; };' &amp;gt;&amp;gt; /etc/apt/conf.d/01proxy&lt;/code&gt;</source>
          <target state="translated">적절한 프록시 설정 &lt;code&gt;echo 'Acquire::http { Proxy &quot;http://dockerhost:3142&quot;; };' &amp;gt;&amp;gt; /etc/apt/conf.d/01proxy&lt;/code&gt; 추가 'Acquire :: http {프록시 &quot;http : // dockerhost : 3142&quot;; }; ' &amp;gt;&amp;gt; /etc/apt/conf.d/01proxy</target>
        </trans-unit>
        <trans-unit id="308b55836e1d5704af1ca9565ae0777d595c49b1" translate="yes" xml:space="preserve">
          <source>Add and remove Targets</source>
          <target state="translated">대상 추가 및 제거</target>
        </trans-unit>
        <trans-unit id="7edd6a54bf5081f28aea598695e1b7df528029e5" translate="yes" xml:space="preserve">
          <source>Add bind mounts or volumes using the --mount flag</source>
          <target state="translated">--mount 플래그를 사용하여 바인드 마운트 또는 볼륨 추가</target>
        </trans-unit>
        <trans-unit id="5c2c0908db1aa15746aa6444ce18eb19501fe9c8" translate="yes" xml:space="preserve">
          <source>Add bind mounts, volumes or memory filesystems</source>
          <target state="translated">바인드 마운트, 볼륨 또는 메모리 파일 시스템 추가</target>
        </trans-unit>
        <trans-unit id="11a66b99e0f86b138040b0969dfacaaf1eeac834" translate="yes" xml:space="preserve">
          <source>Add build arguments, which are environment variables accessible only during the build process.</source>
          <target state="translated">빌드 프로세스 중에 만 액세스 할 수있는 환경 변수 인 빌드 인수를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ebaeba6e5ca14c17a9775a8d93fcca571ad4e02a" translate="yes" xml:space="preserve">
          <source>Add data to the first database</source>
          <target state="translated">첫 번째 데이터베이스에 데이터 추가</target>
        </trans-unit>
        <trans-unit id="79cd9e15ede3734298a0cc3dc83fc1184d8a5df7" translate="yes" xml:space="preserve">
          <source>Add entries to container hosts file (--add-host)</source>
          <target state="translated">컨테이너 호스트 파일에 항목 추가 (--add-host)</target>
        </trans-unit>
        <trans-unit id="9af4e37f8e16a48f83f00e24500a14d8c5f5e3b0" translate="yes" xml:space="preserve">
          <source>Add environment variables from a file. Can be a single value or a list.</source>
          <target state="translated">파일에서 환경 변수를 추가하십시오. 단일 값 또는 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f93891b9b92df5f4602118b58ad63dbbe94eed" translate="yes" xml:space="preserve">
          <source>Add environment variables. You can use either an array or a dictionary. Any boolean values; true, false, yes no, need to be enclosed in quotes to ensure they are not converted to True or False by the YML parser.</source>
          <target state="translated">환경 변수를 추가하십시오. 배열이나 사전을 사용할 수 있습니다. 모든 부울 값; true, false, yes no는 YML 파서에 의해 True 또는 False로 변환되지 않도록 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e3cb9fa33c7edfdbad5134df71757a2c841ea28" translate="yes" xml:space="preserve">
          <source>Add host device to container (--device)</source>
          <target state="translated">컨테이너에 호스트 장치 추가 (--device)</target>
        </trans-unit>
        <trans-unit id="63ff3d4a8e01389be53f4b0af8593d954c7536fb" translate="yes" xml:space="preserve">
          <source>Add hostname mappings at build-time. Use the same values as the docker client &lt;code&gt;--add-host&lt;/code&gt; parameter.</source>
          <target state="translated">빌드시 호스트 이름 매핑을 추가하십시오. docker client &lt;code&gt;--add-host&lt;/code&gt; 매개 변수 와 동일한 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6fcce64c7195ada22087f7419fa7cfeaef51c70" translate="yes" xml:space="preserve">
          <source>Add hostname mappings. Use the same values as the docker client &lt;code&gt;--add-host&lt;/code&gt; parameter.</source>
          <target state="translated">호스트 이름 매핑을 추가하십시오. docker client &lt;code&gt;--add-host&lt;/code&gt; 매개 변수 와 동일한 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0fb28a43b46a45e8801166b9255e6126a923540" translate="yes" xml:space="preserve">
          <source>Add label metadata to a node</source>
          <target state="translated">노드에 레이블 메타 데이터 추가</target>
        </trans-unit>
        <trans-unit id="fc199410df6aec8d5c4e512fc8a4f14c59f4646a" translate="yes" xml:space="preserve">
          <source>Add link to another container</source>
          <target state="translated">다른 컨테이너에 링크 추가</target>
        </trans-unit>
        <trans-unit id="1aeedaad02eb48ae85bc97ac750271e9e5dc197a" translate="yes" xml:space="preserve">
          <source>Add malicious data to one of the &lt;code&gt;trusttest&lt;/code&gt; layers:</source>
          <target state="translated">&lt;code&gt;trusttest&lt;/code&gt; 계층 중 하나에 악성 데이터를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fed39208b1bd5b7ed4a6336987a5c15a201e4943" translate="yes" xml:space="preserve">
          <source>Add manager and worker nodes to bring your new swarm up to operating capacity.</source>
          <target state="translated">관리자 및 작업자 노드를 추가하여 새 떼를 운영 용량으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f75fe9adc97551f5a04b842d6406787d6c1d4b40" translate="yes" xml:space="preserve">
          <source>Add manager nodes for fault tolerance</source>
          <target state="translated">내결함성을 위해 관리자 노드 추가</target>
        </trans-unit>
        <trans-unit id="f954604d83214fdaa6e2833a7fd81ce7f2c95889" translate="yes" xml:space="preserve">
          <source>Add metadata to a swarm node using node labels. You can specify a node label as a key with an empty value:</source>
          <target state="translated">노드 레이블을 사용하여 웜 노드에 메타 데이터를 추가하십시오. 빈 값을 가진 키로 노드 레이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac744b13fc68b03c5d65c16a15be1019f3c72f2f" translate="yes" xml:space="preserve">
          <source>Add metadata to containers using &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;Docker labels&lt;/a&gt;. You can use either an array or a dictionary.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/config&quot;&gt;Docker 레이블을&lt;/a&gt; 사용하여 컨테이너에 메타 데이터를 추가하십시오 . 배열이나 사전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b8c7500e7f58035202de70b218c7f1dc844a8d8" translate="yes" xml:space="preserve">
          <source>Add metadata to the resulting image using &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;Docker labels&lt;/a&gt;. You can use either an array or a dictionary.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/config&quot;&gt;Docker 레이블을&lt;/a&gt; 사용하여 결과 이미지에 메타 데이터를 추가하십시오 . 배열이나 사전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15de7fdc23591c3e58963ac3f1285c72c69eb56" translate="yes" xml:space="preserve">
          <source>Add network-scoped alias for the container</source>
          <target state="translated">컨테이너에 대한 네트워크 범위 별명 추가</target>
        </trans-unit>
        <trans-unit id="8f069db98b1b1d570b2795c21746c4251d93445f" translate="yes" xml:space="preserve">
          <source>Add nodes to the swarm</source>
          <target state="translated">떼에 노드 추가</target>
        </trans-unit>
        <trans-unit id="31d1991e2a2507f87be264cdaf1d9adebab803cb" translate="yes" xml:space="preserve">
          <source>Add or drop container capabilities. See &lt;code&gt;man 7 capabilities&lt;/code&gt; for a full list.</source>
          <target state="translated">컨테이너 기능을 추가하거나 삭제하십시오. 전체 목록 은 &lt;code&gt;man 7 capabilities&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b4220a48635861c75fb31949892c154447c9ab4" translate="yes" xml:space="preserve">
          <source>Add or remove label metadata</source>
          <target state="translated">라벨 메타 데이터 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="c983346d918c4884b65a307bcd01728c2b0d4bb3" translate="yes" xml:space="preserve">
          <source>Add or remove mounts</source>
          <target state="translated">마운트 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="d1fb885bd2556f30f32b1387adf1d5dee1e36366" translate="yes" xml:space="preserve">
          <source>Add or remove network</source>
          <target state="translated">네트워크 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="ec22caa7a2eed8ff9500ba02d7f84ad20f138d2c" translate="yes" xml:space="preserve">
          <source>Add or remove published service ports</source>
          <target state="translated">게시 된 서비스 포트 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="912d6206951b9385c143c07d06b891cf67d3a6ba" translate="yes" xml:space="preserve">
          <source>Add or remove secrets</source>
          <target state="translated">비밀 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="7c38f52121eaaf997018cb14fa7134ced9b30b9c" translate="yes" xml:space="preserve">
          <source>Add or update a DNS option</source>
          <target state="translated">DNS 옵션 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="d1855ce1e09db8fa6420038738f8c6fc330ae4ab" translate="yes" xml:space="preserve">
          <source>Add or update a Sysctl option</source>
          <target state="translated">Sysctl 옵션 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="53a951aa96a9db8b02a56f65c1164114b8dede6d" translate="yes" xml:space="preserve">
          <source>Add or update a config file on a service</source>
          <target state="translated">서비스에서 구성 파일 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="75f8fb98353c31087426aa07e4dd536e234cf022" translate="yes" xml:space="preserve">
          <source>Add or update a container label</source>
          <target state="translated">컨테이너 라벨 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="ac54ef34418c2237303d45b73ac396ce12551089" translate="yes" xml:space="preserve">
          <source>Add or update a custom DNS search domain</source>
          <target state="translated">맞춤 DNS 검색 도메인 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="1b3b9e1d2fa9b19302387f8c686f8415943e2236" translate="yes" xml:space="preserve">
          <source>Add or update a custom DNS server</source>
          <target state="translated">사용자 지정 DNS 서버 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="872b75ee8859d1a98d05b85150cc69922d0cb067" translate="yes" xml:space="preserve">
          <source>Add or update a mount on a service</source>
          <target state="translated">서비스에서 마운트 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="d87d7f30eb8270d4992300f19039dde41f6fcf24" translate="yes" xml:space="preserve">
          <source>Add or update a node label (key=value)</source>
          <target state="translated">노드 레이블 추가 또는 업데이트 (키 = 값)</target>
        </trans-unit>
        <trans-unit id="2d2cdec2a9b62979cfd1f674d9099b8b827b5d72" translate="yes" xml:space="preserve">
          <source>Add or update a placement constraint</source>
          <target state="translated">게재 위치 제약 조건 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="309361dc3ac025038f103348c2700db98471d28c" translate="yes" xml:space="preserve">
          <source>Add or update a published port</source>
          <target state="translated">게시 된 포트 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="57be8057e7e2396061645e7ac4432f12185c0aae" translate="yes" xml:space="preserve">
          <source>Add or update a secret on a service</source>
          <target state="translated">서비스에서 비밀 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="ea4f8164104a6cfc0fc2f6001985502d009ebd8a" translate="yes" xml:space="preserve">
          <source>Add or update a service label</source>
          <target state="translated">서비스 레이블 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="d4968a8fab74902c8ab0bcd3a0b6defb77ea80a0" translate="yes" xml:space="preserve">
          <source>Add or update an environment variable</source>
          <target state="translated">환경 변수 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="63194b660a6482c7b98c9a03d7252a180cb14d86" translate="yes" xml:space="preserve">
          <source>Add rules to the cgroup allowed devices list.</source>
          <target state="translated">cgroup allowed devices 목록에 규칙을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e5852d80a15721705ed8de5771b8759b77771458" translate="yes" xml:space="preserve">
          <source>Add the following configuration to the file.</source>
          <target state="translated">파일에 다음 구성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3442e66441e8d1254e2fbd529a09d839efbc7b51" translate="yes" xml:space="preserve">
          <source>Add the following content to the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 에 다음 내용을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6eeb742bf37855c672abb4edd1a996ffc6d8a9d" translate="yes" xml:space="preserve">
          <source>Add the following lines to &lt;code&gt;~/.bash_profile&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~/.bash_profile&lt;/code&gt; 에 다음 행을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e1200bf27baa5a6332804b4ac748492b1b5e32e" translate="yes" xml:space="preserve">
          <source>Add the following to the new file.</source>
          <target state="translated">새 파일에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="651d30fe95c3deb3f59e2c338055c14590bb6653" translate="yes" xml:space="preserve">
          <source>Add the following to your &lt;code&gt;~/.bash_profile&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~/.bash_profile&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d12a820fc716367983c2e6966446e5f4265038d" translate="yes" xml:space="preserve">
          <source>Add the required software in the file.</source>
          <target state="translated">파일에 필요한 소프트웨어를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb53ffa9b40bba5e7fa723402ab76dbe2960434" translate="yes" xml:space="preserve">
          <source>Add the text below to your &lt;code&gt;Dockerfile&lt;/code&gt; for either Linux or &lt;a href=&quot;https://docs.microsoft.com/virtualization/windowscontainers/about/&quot;&gt;Windows Containers&lt;/a&gt;. The tags below are multi-arch meaning they pull either Windows or Linux containers depending on what mode is set in &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt;. Read more on &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers&quot;&gt;switching containers&lt;/a&gt;.</source>
          <target state="translated">Linux 또는 &lt;a href=&quot;https://docs.microsoft.com/virtualization/windowscontainers/about/&quot;&gt;Windows 컨테이너&lt;/a&gt; 의 &lt;code&gt;Dockerfile&lt;/code&gt; 에 아래 텍스트를 추가하십시오 . 아래 태그는 다중 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;아키텍처로 Windows 용 Docker Desktop에&lt;/a&gt; 설정된 모드에 따라 Windows 또는 Linux 컨테이너를 가져옵니다 . &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers&quot;&gt;컨테이너 전환&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="d1b2c6fe0bf3119ef9e21f39424ce8410e34fd3b" translate="yes" xml:space="preserve">
          <source>Add worker nodes for load balancing</source>
          <target state="translated">로드 밸런싱을위한 작업자 노드 추가</target>
        </trans-unit>
        <trans-unit id="117285c7d2683e441c7dda8a21a16812c12b654e" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; file format</source>
          <target state="translated">에 추가 된 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;버전 2.1&lt;/a&gt; 파일 형식</target>
        </trans-unit>
        <trans-unit id="acffb90cbc404310dacd7a6387ae851914cdec97" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;../compose-versioning/index#version-22&quot;&gt;version 2.2&lt;/a&gt; file format</source>
          <target state="translated">에 추가 된 &lt;a href=&quot;../compose-versioning/index#version-22&quot;&gt;버전 2.2&lt;/a&gt; 파일 형식</target>
        </trans-unit>
        <trans-unit id="566cd049546b4f028f1bef95287e26700924ba8a" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;../compose-versioning/index#version-23&quot;&gt;version 2.3&lt;/a&gt; file format</source>
          <target state="translated">에 추가 된 &lt;a href=&quot;../compose-versioning/index#version-23&quot;&gt;버전 2.3&lt;/a&gt; 파일 형식</target>
        </trans-unit>
        <trans-unit id="0d1d6bb8dff73b58a25fbf09d2f10b5efaee67bd" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;version 3.4&lt;/a&gt; file format</source>
          <target state="translated">에 추가 된 &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;버전 3.4&lt;/a&gt; 파일 형식</target>
        </trans-unit>
        <trans-unit id="e53433fbfc954845ed7334838e953f836af21dc0" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;compose-versioning/index#version-35&quot;&gt;version 3.5&lt;/a&gt; file format</source>
          <target state="translated">에 추가 된 &lt;a href=&quot;compose-versioning/index#version-35&quot;&gt;버전 3.5&lt;/a&gt; 파일 형식</target>
        </trans-unit>
        <trans-unit id="0549db205d6a5a7484dba020627e6aec8787cfee" translate="yes" xml:space="preserve">
          <source>Added in version 2.1 file format</source>
          <target state="translated">버전 2.1 파일 형식으로 추가</target>
        </trans-unit>
        <trans-unit id="7a9fe3425cf0f8a840958954849c54c811710d87" translate="yes" xml:space="preserve">
          <source>Added in version 2.2 file format</source>
          <target state="translated">버전 2.2 파일 형식으로 추가</target>
        </trans-unit>
        <trans-unit id="3853c67a5f13ad3cfc9db35dce6995e06baafd6a" translate="yes" xml:space="preserve">
          <source>Added in version 2.3 file format</source>
          <target state="translated">버전 2.3 파일 형식으로 추가</target>
        </trans-unit>
        <trans-unit id="be66e69980841aaafdfc539421594f067a5d4c97" translate="yes" xml:space="preserve">
          <source>Added in version 3.4 file format</source>
          <target state="translated">버전 3.4 파일 형식으로 추가</target>
        </trans-unit>
        <trans-unit id="c8f2134a1dd8d94b2a5cff2aca939e02974297c2" translate="yes" xml:space="preserve">
          <source>Added in version 3.5 file format</source>
          <target state="translated">버전 3.5 파일 형식으로 추가</target>
        </trans-unit>
        <trans-unit id="976fb50c29ef116fd1eac2c53ec5282818041edf" translate="yes" xml:space="preserve">
          <source>Added: &lt;a href=&quot;../index#deploy&quot;&gt;deploy&lt;/a&gt;</source>
          <target state="translated">추가 : &lt;a href=&quot;../index#deploy&quot;&gt;배포&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947285abd02c945d38711602fb759345c4b0a67d" translate="yes" xml:space="preserve">
          <source>Adding Additional Signers</source>
          <target state="translated">추가 서명자 추가</target>
        </trans-unit>
        <trans-unit id="422b736e01b39b6ab07a6797204c44f13f0e68a2" translate="yes" xml:space="preserve">
          <source>Adding Keys to an Existing Delegation</source>
          <target state="translated">기존 위임에 키 추가</target>
        </trans-unit>
        <trans-unit id="c6bf4b965cf3c07a2884f8ad662040501afe8df2" translate="yes" xml:space="preserve">
          <source>Adding and overriding configuration</source>
          <target state="translated">구성 추가 및 재정의</target>
        </trans-unit>
        <trans-unit id="4637360a2f26efbf7dfa759e0af34f7fcd77c93c" translate="yes" xml:space="preserve">
          <source>Adding extra services such as a log aggregator</source>
          <target state="translated">로그 수집기와 같은 추가 서비스 추가</target>
        </trans-unit>
        <trans-unit id="2a57f5a8b95fc5a97aebdfe063e6ed6da15b8e93" translate="yes" xml:space="preserve">
          <source>Adding worker nodes increases capacity. When you deploy a service to a swarm, the Engine schedules tasks on available nodes whether they are worker nodes or manager nodes. When you add workers to your swarm, you increase the scale of the swarm to handle tasks without affecting the manager raft consensus.</source>
          <target state="translated">작업자 노드를 추가하면 용량이 증가합니다. 웜에 서비스를 배포 할 때 엔진은 사용 가능한 노드에서 작업자 노드인지 관리자 노드인지에 대한 작업을 예약합니다. 웜에 작업자를 추가하면 관리자 뗏목 합의에 영향을 미치지 않고 작업을 처리하기 위해 웜의 규모를 늘립니다.</target>
        </trans-unit>
        <trans-unit id="d0a694f7c28c778e3c2176738d910ee232fafccc" translate="yes" xml:space="preserve">
          <source>Additional groups</source>
          <target state="translated">추가 그룹</target>
        </trans-unit>
        <trans-unit id="a153a760c3db04d40060e73f0aea37ea5ca987d3" translate="yes" xml:space="preserve">
          <source>Additionally, Docker Machine supports a flag, &lt;code&gt;--engine-env&lt;/code&gt;, which can be used to specify arbitrary environment variables to be set within the engine with the syntax &lt;code&gt;--engine-env name=value&lt;/code&gt;. For example, to specify that the engine should use &lt;code&gt;example.com&lt;/code&gt; as the proxy server, you could run the following create command:</source>
          <target state="translated">또한 Docker Machine은 &lt;code&gt;--engine-env&lt;/code&gt; 플래그를 지원하며 &lt;code&gt;--engine-env name=value&lt;/code&gt; 구문을 사용하여 엔진 내에서 설정할 임의의 환경 변수를 지정하는 데 사용할 수 있습니다 . 예를 들어 엔진이 &lt;code&gt;example.com&lt;/code&gt; 을 프록시 서버로 사용하도록 지정 하려면 다음 create 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa57e8764887c39a8c1eee7e4cbdb51e31207481" translate="yes" xml:space="preserve">
          <source>Additionally, Machine allows you to run Docker on older Mac or Windows systems, as described in the previous topic.</source>
          <target state="translated">또한 Machine을 사용하면 이전 주제에서 설명한대로 이전 Mac 또는 Windows 시스템에서 Docker를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca70189b7b0634c1b6420f299b8c1a95aef88f50" translate="yes" xml:space="preserve">
          <source>Additionally, drivers can specify flags that Machine can accept as part of their plugin code. These allow users to customize the provider-specific parameters of the created machine, such as size (&lt;code&gt;--amazonec2-instance-type m1.medium&lt;/code&gt;), geographical region (&lt;code&gt;--amazonec2-region us-west-1&lt;/code&gt;), and so on.</source>
          <target state="translated">또한 드라이버는 Machine이 플러그인 코드의 일부로 수락 할 수있는 플래그를 지정할 수 있습니다. 이를 통해 사용자는 크기 ( &lt;code&gt;--amazonec2-instance-type m1.medium&lt;/code&gt; ), 지리적 지역 ( &lt;code&gt;--amazonec2-region us-west-1&lt;/code&gt; ) 등과 같이 생성 된 시스템의 공급자 별 매개 변수를 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="168446422f6db7c714786ac9f4b1878978ce0460" translate="yes" xml:space="preserve">
          <source>Additionally, it is a best practice to implement a regular rotation schedule for any secret including swarm join tokens. We recommend that you rotate your tokens at least every 6 months.</source>
          <target state="translated">또한 swarm join 토큰을 포함한 모든 비밀에 대해 정기적 인 로테이션 일정을 구현하는 것이 가장 좋습니다. 최소한 6 개월마다 토큰을 교체하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0ae466a21b2baded78d12a9b2e0cb4759a4b680c" translate="yes" xml:space="preserve">
          <source>Additionally, the operator can &lt;strong&gt;set any environment variable&lt;/strong&gt; in the container by using one or more &lt;code&gt;-e&lt;/code&gt; flags, even overriding those mentioned above, or already defined by the developer with a Dockerfile &lt;code&gt;ENV&lt;/code&gt;. If the operator names an environment variable without specifying a value, then the current value of the named variable is propagated into the container&amp;rsquo;s environment:</source>
          <target state="translated">또한 운영자는 하나 이상의 &lt;code&gt;-e&lt;/code&gt; 플래그 를 사용하여 위에서 언급 한 것보다 우선하거나 개발자가 Dockerfile &lt;code&gt;ENV&lt;/code&gt; 로 이미 정의한 컨테이너를 통해 &lt;strong&gt;환경 변수&lt;/strong&gt; 를 &lt;strong&gt;설정할 수 있습니다&lt;/strong&gt; . 연산자가 값을 지정하지 않고 환경 변수의 이름을 지정하면 명명 된 변수의 현재 값이 컨테이너의 환경으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="204b2eca8f9469892c2732d422bef1690486eabf" translate="yes" xml:space="preserve">
          <source>Additionally, you also specify the &lt;code&gt;--gateway&lt;/code&gt;&lt;code&gt;--ip-range&lt;/code&gt; and &lt;code&gt;--aux-address&lt;/code&gt; options.</source>
          <target state="translated">또한 &lt;code&gt;--gateway&lt;/code&gt; &lt;code&gt;--ip-range&lt;/code&gt; 및 &lt;code&gt;--aux-address&lt;/code&gt; 옵션 도 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="15b719a1b42a0f1709cfb47d3c5c9b1fe1ba8f05" translate="yes" xml:space="preserve">
          <source>Address or interface to use for data path traffic (format: &amp;lt;ip|interface&amp;gt;)</source>
          <target state="translated">데이터 경로 트래픽에 사용할 주소 또는 인터페이스 (형식 : &amp;lt;ip | 인터페이스&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="d0b0f3793cccb907e44ae5fb72c742506f93c123" translate="yes" xml:space="preserve">
          <source>Administer and maintain a swarm of Docker Engines</source>
          <target state="translated">Docker Engine의 떼를 관리하고 유지하십시오</target>
        </trans-unit>
        <trans-unit id="055d39fd2ad7aeccde47c276d039c83375ab7acf" translate="yes" xml:space="preserve">
          <source>Administrative tasks</source>
          <target state="translated">관리 작업</target>
        </trans-unit>
        <trans-unit id="99fdcaf2f83c60be8f0d37e953d11e5f70c42e38" translate="yes" xml:space="preserve">
          <source>Advanced configuration options</source>
          <target state="translated">고급 구성 옵션</target>
        </trans-unit>
        <trans-unit id="aeb27319a830e16a9a03ac7001a8d3e971ec4cad" translate="yes" xml:space="preserve">
          <source>Advanced example: Use configs with a Nginx service</source>
          <target state="translated">고급 예 : Nginx 서비스와 함께 구성 사용</target>
        </trans-unit>
        <trans-unit id="cde5680415116458ff9da2833d77d26665b798af" translate="yes" xml:space="preserve">
          <source>Advanced example: Use secrets with a WordPress service</source>
          <target state="translated">고급 예 : WordPress 서비스에서 비밀 사용</target>
        </trans-unit>
        <trans-unit id="bfcafb5d48e2aa06aba698931d8de1036ca54389" translate="yes" xml:space="preserve">
          <source>Advanced topic</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="8b97c94041f50678759f3b0771e21b1d3b1e1b42" translate="yes" xml:space="preserve">
          <source>Advanced users and package managers can find a profile for &lt;code&gt;/usr/bin/docker&lt;/code&gt; (Docker Engine Daemon) underneath &lt;a href=&quot;https://github.com/moby/moby/tree/master/contrib/apparmor&quot;&gt;contrib/apparmor&lt;/a&gt; in the Docker Engine source repository.</source>
          <target state="translated">고급 사용자 및 패키지 관리자는 Docker Engine 소스 저장소의 &lt;a href=&quot;https://github.com/moby/moby/tree/master/contrib/apparmor&quot;&gt;contrib / apparmor&lt;/a&gt; 아래 에서 &lt;code&gt;/usr/bin/docker&lt;/code&gt; (Docker Engine Daemon)에 대한 프로파일을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="871757cecf5047275a3829f1d28e2f2324259e5d" translate="yes" xml:space="preserve">
          <source>Advertised address (format: &amp;lt;ip|interface&amp;gt;[:port])</source>
          <target state="translated">보급 주소 (형식 : &amp;lt;ip | 인터페이스&amp;gt; [: 포트])</target>
        </trans-unit>
        <trans-unit id="65c1c445a92b7f9319aa250e37c17c11ab09baf9" translate="yes" xml:space="preserve">
          <source>After a node leaves the swarm, you can run the &lt;code&gt;docker node rm&lt;/code&gt; command on a manager node to remove the node from the node list.</source>
          <target state="translated">노드가 떼에서 나간 후 관리자 노드 에서 &lt;code&gt;docker node rm&lt;/code&gt; 명령을 실행 하여 노드 목록에서 노드를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a3a24efe9f9944fd06fa739f1fd82cbb1dc4b75" translate="yes" xml:space="preserve">
          <source>After a plugin is installed, you can use it as an option for another Docker operation, such as creating a volume.</source>
          <target state="translated">플러그인이 설치된 후에는 볼륨 생성과 같은 다른 Docker 작업을위한 옵션으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ead23caadb59db8dd2ab6226fb470849dff3ba58" translate="yes" xml:space="preserve">
          <source>After adding your user, check &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt; to see if your user has an entry in each. If not, you need to add it, being careful to avoid overlap.</source>
          <target state="translated">사용자를 추가 한 후 &lt;code&gt;/etc/subuid&lt;/code&gt; 및 &lt;code&gt;/etc/subgid&lt;/code&gt; 를 확인하여 사용자에게 각각 항목이 있는지 확인하십시오. 그렇지 않은 경우 겹치지 않도록주의하면서 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="333371dbc9fcccec5190b14a86ab6054906c722f" translate="yes" xml:space="preserve">
          <source>After authenticating, the driver remembers your credentials up to two weeks.</source>
          <target state="translated">인증 후 드라이버는 최대 2 주까지 자격 증명을 기억합니다.</target>
        </trans-unit>
        <trans-unit id="39d2f5aed56fda66e55861091c50653cc47d27aa" translate="yes" xml:space="preserve">
          <source>After backing up the swarm as described in &lt;a href=&quot;#back-up-the-swarm&quot;&gt;Back up the swarm&lt;/a&gt;, use the following procedure to restore the data to a new swarm.</source>
          <target state="translated">에 설명 된대로 떼를 백업 한 후 &lt;a href=&quot;#back-up-the-swarm&quot;&gt;떼을 백업&lt;/a&gt; , 새 떼에 데이터를 복원하려면 다음 절차를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97552c94570d89f808e6b913a6288ce1ebd0ae9d" translate="yes" xml:space="preserve">
          <source>After every node in the swarm has a new TLS certificate signed by the new CA, Docker forgets about the old CA certificate and key material, and tells all the nodes to trust the new CA certificate only.</source>
          <target state="translated">swarm의 모든 노드에 새 CA가 서명 한 새 TLS 인증서가 있으면 Docker는 이전 CA 인증서와 키 자료를 잊어 버리고 모든 노드에 새 CA 인증서 만 신뢰하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1e473b918343496c6294b4ba3020910b90febc7a" translate="yes" xml:space="preserve">
          <source>After generating &lt;code&gt;cert.pem&lt;/code&gt; and &lt;code&gt;server-cert.pem&lt;/code&gt; you can safely remove the two certificate signing requests and extensions config files:</source>
          <target state="translated">&lt;code&gt;cert.pem&lt;/code&gt; 및 &lt;code&gt;server-cert.pem&lt;/code&gt; 을 생성 한 후 다음 두 가지 인증서 서명 요청 및 확장 구성 파일을 안전하게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe57a25fd430d413c30534a60b5766a794ee7fcf" translate="yes" xml:space="preserve">
          <source>After publishing, you can view delegations using a list command:</source>
          <target state="translated">게시 한 후 list 명령을 사용하여 위임을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9aa7de336e23c35b9816adb14a15a6df938a64" translate="yes" xml:space="preserve">
          <source>After revocation, the tag is removed from the list of released tags:</source>
          <target state="translated">해지 후 태그가 해제 된 태그 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="02dde07fb71a5b99305e224c5ebd84a5fba99028" translate="yes" xml:space="preserve">
          <source>After that the plugin &lt;code&gt;&amp;lt;plugin-name&amp;gt;&lt;/code&gt; will show up in &lt;code&gt;docker plugin ls&lt;/code&gt;. Plugins can be pushed to remote registries with &lt;code&gt;docker plugin push &amp;lt;plugin-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;&amp;lt;plugin-name&amp;gt;&lt;/code&gt; &lt;code&gt;docker plugin ls&lt;/code&gt; 이 docker plugin ls 에 표시됩니다 . &lt;code&gt;docker plugin push &amp;lt;plugin-name&amp;gt;&lt;/code&gt; 을 사용 하여 플러그인 을 원격 레지스트리로 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31a15638b28fb4cd7ac276341fc4886021d01232" translate="yes" xml:space="preserve">
          <source>After that, you can see it running, and can change any aspect of the application you choose, or even edit the Compose file itself.</source>
          <target state="translated">그 후에는 실행중인 것을 볼 수 있으며 선택한 응용 프로그램의 모든 측면을 변경하거나 작성 파일 자체를 편집 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ba91485852dd02a2939ae73014029a710c7fe18" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;docker-compose&lt;/code&gt; command completes, list the contents of your project.</source>
          <target state="translated">&lt;code&gt;docker-compose&lt;/code&gt; 명령이 완료된 후 프로젝트 내용을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c9eeafb40b93ca1727d73c1e753470915a246f07" translate="yes" xml:space="preserve">
          <source>After the installation, Brew displays the installation path. Make sure to place the completion script in the path.</source>
          <target state="translated">설치 후 Brew는 설치 경로를 표시합니다. 완료 스크립트를 경로에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="d65ce4f1460ac41cd1cd1e9679619428380b9be4" translate="yes" xml:space="preserve">
          <source>After the plugin is installed, it appears in the list of plugins:</source>
          <target state="translated">플러그인이 설치되면 플러그인 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="125a818848fcf397ed3c34d4eb0697bd9da4f5f2" translate="yes" xml:space="preserve">
          <source>After the pull has completed use the &lt;code&gt;docker images&lt;/code&gt; command to see the images that were pulled. The example below shows all the &lt;code&gt;fedora&lt;/code&gt; images that are present locally:</source>
          <target state="translated">&lt;code&gt;docker images&lt;/code&gt; 완료된 후 docker images 명령을 사용하여 가져온 이미지를보십시오. 아래 예 는 로컬로 존재하는 모든 &lt;code&gt;fedora&lt;/code&gt; 이미지를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9d28570e9a5521548fc6c4674f2ecccfb8d6c05e" translate="yes" xml:space="preserve">
          <source>After the swarm is initialized, use the &lt;code&gt;docker info&lt;/code&gt; command to verify that the port is configured:</source>
          <target state="translated">스웜이 초기화 된 후 &lt;code&gt;docker info&lt;/code&gt; 명령을 사용하여 포트가 구성되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8a27bac855b161210dde436340208ac0902e1ace" translate="yes" xml:space="preserve">
          <source>After you &lt;a href=&quot;../create-swarm/index&quot;&gt;create a swarm&lt;/a&gt;, you can deploy a service to the swarm. For this tutorial, you also &lt;a href=&quot;../add-nodes/index&quot;&gt;added worker nodes&lt;/a&gt;, but that is not a requirement to deploy a service.</source>
          <target state="translated">&lt;a href=&quot;../create-swarm/index&quot;&gt;swarm을 만든&lt;/a&gt; 후에 는 swarm 에 서비스를 배포 할 수 있습니다. 이 학습서에서는 &lt;a href=&quot;../add-nodes/index&quot;&gt;작업자 노드&lt;/a&gt; 도 추가 했지만 서비스를 배치 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="36591e4e2317a8f832ffa34ff99ba3db2afcfea0" translate="yes" xml:space="preserve">
          <source>After you complete the &lt;a href=&quot;../index&quot;&gt;tutorial setup&lt;/a&gt; steps, you&amp;rsquo;re ready to create a swarm. Make sure the Docker Engine daemon is started on the host machines.</source>
          <target state="translated">&lt;a href=&quot;../index&quot;&gt;학습서 설정&lt;/a&gt; 단계 를 완료하면 떼를 만들 준비가 된 것입니다. 호스트 시스템에서 Docker Engine 데몬이 시작되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="885c9e3dd9dafd47ac99e79347596b39e963769f" translate="yes" xml:space="preserve">
          <source>After you create a service, its image is never updated unless you explicitly run &lt;code&gt;docker service update&lt;/code&gt; with the &lt;code&gt;--image&lt;/code&gt; flag as described below. Other update operations such as scaling the service, adding or removing networks or volumes, renaming the service, or any other type of update operation do not update the service&amp;rsquo;s image.</source>
          <target state="translated">서비스를 만든 후에 는 아래 설명 된대로 &lt;code&gt;--image&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;docker service update&lt;/code&gt; 를 명시 적으로 실행하지 않으면 이미지가 업데이트되지 않습니다 . 서비스 확장, 네트워크 또는 볼륨 추가 또는 제거, 서비스 이름 바꾸기 또는 다른 유형의 업데이트 작업과 같은 다른 업데이트 작업은 서비스 이미지를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f0752127d032d8f49fdf2b208c98e43831a7c85" translate="yes" xml:space="preserve">
          <source>After you create an overlay network in swarm mode, all manager nodes have access to the network.</source>
          <target state="translated">스웜 모드에서 오버레이 네트워크를 생성하면 모든 관리자 노드가 네트워크에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b91f84d071eb3e5be82b3de31c1865fee0c4b7b" translate="yes" xml:space="preserve">
          <source>After you create the swarm, you can display or rotate the token using &lt;a href=&quot;../docker/index&quot;&gt;swarm join-token&lt;/a&gt;.</source>
          <target state="translated">스웜을 생성 한 후 &lt;a href=&quot;../docker/index&quot;&gt;swarm join-token을&lt;/a&gt; 사용하여 토큰을 표시하거나 회전 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be68f03df064df5e7baa3d37bc9bc7127187cfac" translate="yes" xml:space="preserve">
          <source>After you have created a plugin using &lt;code&gt;docker plugin create&lt;/code&gt; and the plugin is ready for distribution, use &lt;code&gt;docker plugin push&lt;/code&gt; to share your images to Docker Hub or a self-hosted registry.</source>
          <target state="translated">&lt;code&gt;docker plugin create&lt;/code&gt; 를 사용하여 플러그인을 만들고 플러그인을 배포 할 준비가되면 &lt;code&gt;docker plugin push&lt;/code&gt; 를 사용 하여 이미지를 Docker Hub 또는 자체 호스팅 레지스트리에 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="fe50c823bd5a7315910b683ca1754eb54090c89e" translate="yes" xml:space="preserve">
          <source>After you have created your local copy of the manifest list, you may optionally &lt;code&gt;annotate&lt;/code&gt; it. Annotations allowed are the architecture and operating system (overriding the image&amp;rsquo;s current values), os features, and an architecture variant.</source>
          <target state="translated">매니페스트 목록의 로컬 복사본을 만든 후에는 선택적으로 &lt;code&gt;annotate&lt;/code&gt; 수 있습니다. 허용되는 주석은 아키텍처 및 운영 체제 (이미지의 현재 값을 재정의), OS 기능 및 아키텍처 변형입니다.</target>
        </trans-unit>
        <trans-unit id="8cceec97e84f61a55940336d68ef2d2c07ee059e" translate="yes" xml:space="preserve">
          <source>After you have set up your environment, you are ready to &lt;a href=&quot;create-swarm/index&quot;&gt;create a swarm&lt;/a&gt;.</source>
          <target state="translated">환경을 설정 한 후 &lt;a href=&quot;create-swarm/index&quot;&gt;swarm&lt;/a&gt; 을 작성할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="309ba608aa75f097600873d10b26c70ffd390821" translate="yes" xml:space="preserve">
          <source>Algorithm to use to generate keys stored on the signing service. Valid values are &lt;code&gt;&quot;ecdsa&quot;&lt;/code&gt;, &lt;code&gt;&quot;rsa&quot;&lt;/code&gt;, and &lt;code&gt;&quot;ed25519&quot;&lt;/code&gt;.</source>
          <target state="translated">서명 서비스에 저장된 키를 생성하는 데 사용되는 알고리즘입니다. 유효한 값은 &lt;code&gt;&quot;ecdsa&quot;&lt;/code&gt; , &lt;code&gt;&quot;rsa&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;ed25519&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61a0aa639df35a6785c91dbc68d4304ff14ad9bd" translate="yes" xml:space="preserve">
          <source>Aliases (alternative hostnames) for this service on the network. Other containers on the same network can use either the service name or this alias to connect to one of the service&amp;rsquo;s containers.</source>
          <target state="translated">네트워크에서이 서비스의 별명 (대체 호스트 이름). 동일한 네트워크의 다른 컨테이너는 서비스 이름 또는이 별칭을 사용하여 서비스 컨테이너 중 하나에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b823bb9b42b3672439670b5267fe5328d7524380" translate="yes" xml:space="preserve">
          <source>All keys</source>
          <target state="translated">모든 키</target>
        </trans-unit>
        <trans-unit id="8432cda085ccf4115a62bf19a26621d90691d26a" translate="yes" xml:space="preserve">
          <source>All labels assigned to the container.</source>
          <target state="translated">컨테이너에 할당 된 모든 레이블.</target>
        </trans-unit>
        <trans-unit id="1874ccfc3b2f3176d92ef1eca3c9e68fd35a1f81" translate="yes" xml:space="preserve">
          <source>All labels assigned to the network.</source>
          <target state="translated">네트워크에 할당 된 모든 레이블.</target>
        </trans-unit>
        <trans-unit id="4685b11019bea544cfdb89cd4144cfae479c7943" translate="yes" xml:space="preserve">
          <source>All labels assigned to the secret</source>
          <target state="translated">비밀에 할당 된 모든 라벨</target>
        </trans-unit>
        <trans-unit id="f949b25001a1cd5ab64fb1e3cd3ef4be45a4b484" translate="yes" xml:space="preserve">
          <source>All labels assigned to the volume</source>
          <target state="translated">볼륨에 지정된 모든 레이블</target>
        </trans-unit>
        <trans-unit id="4f17224bf8446441387adc0b6e8cc94e425fa389" translate="yes" xml:space="preserve">
          <source>All markdown files &lt;em&gt;except&lt;/em&gt;&lt;code&gt;README.md&lt;/code&gt; are excluded from the context.</source>
          <target state="translated">&lt;code&gt;README.md&lt;/code&gt; 를 &lt;em&gt;제외한&lt;/em&gt; 모든 마크 다운 파일 은 컨텍스트에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="22c2e3fc9b3e7bf170a6f680cf5c7723222038bb" translate="yes" xml:space="preserve">
          <source>All new files and directories are created with a UID and GID of 0, unless the optional &lt;code&gt;--chown&lt;/code&gt; flag specifies a given username, groupname, or UID/GID combination to request specific ownership of the content added. The format of the &lt;code&gt;--chown&lt;/code&gt; flag allows for either username and groupname strings or direct integer UID and GID in any combination. Providing a username without groupname or a UID without GID will use the same numeric UID as the GID. If a username or groupname is provided, the container&amp;rsquo;s root filesystem &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/group&lt;/code&gt; files will be used to perform the translation from name to integer UID or GID respectively. The following examples show valid definitions for the &lt;code&gt;--chown&lt;/code&gt; flag:</source>
          <target state="translated">선택적 &lt;code&gt;--chown&lt;/code&gt; 플래그가 추가 된 컨텐츠의 특정 소유권을 요청하기 위해 지정된 사용자 이름, 그룹 이름 또는 UID / GID 조합을 지정 하지 않는 한, 모든 새 파일 및 디렉토리는 UID 및 GID가 0으로 작성 됩니다. &lt;code&gt;--chown&lt;/code&gt; 플래그 의 형식은 사용자 이름 및 그룹 이름 문자열 또는 임의의 조합으로 직접 정수 UID 및 GID를 허용합니다. 그룹 이름이없는 사용자 이름 또는 GID가없는 UID를 제공하면 GID와 동일한 숫자 UID가 사용됩니다. 사용자 이름 또는 그룹 이름이 제공되면 컨테이너의 루트 파일 시스템 &lt;code&gt;/etc/passwd&lt;/code&gt; 및 &lt;code&gt;/etc/group&lt;/code&gt; 파일이 각각 이름에서 정수 UID 또는 GID로 변환하는 데 사용됩니다. 다음 예제는 &lt;code&gt;--chown&lt;/code&gt; 플래그에 유효한 정의를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="38c4103ccbc8981b7aad317db58becc1cb352c37" translate="yes" xml:space="preserve">
          <source>All new files and directories are created with a UID and GID of 0, unless the optional &lt;code&gt;--chown&lt;/code&gt; flag specifies a given username, groupname, or UID/GID combination to request specific ownership of the copied content. The format of the &lt;code&gt;--chown&lt;/code&gt; flag allows for either username and groupname strings or direct integer UID and GID in any combination. Providing a username without groupname or a UID without GID will use the same numeric UID as the GID. If a username or groupname is provided, the container&amp;rsquo;s root filesystem &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/group&lt;/code&gt; files will be used to perform the translation from name to integer UID or GID respectively. The following examples show valid definitions for the &lt;code&gt;--chown&lt;/code&gt; flag:</source>
          <target state="translated">선택적 &lt;code&gt;--chown&lt;/code&gt; 플래그가 복사 된 컨텐츠의 특정 소유권을 요청하기 위해 지정된 사용자 이름, 그룹 이름 또는 UID / GID 조합을 지정 하지 않는 한 모든 새 파일 및 디렉토리는 UID 및 GID가 0으로 작성 됩니다. &lt;code&gt;--chown&lt;/code&gt; 플래그 의 형식은 사용자 이름 및 그룹 이름 문자열 또는 임의의 조합으로 직접 정수 UID 및 GID를 허용합니다. 그룹 이름이없는 사용자 이름 또는 GID가없는 UID를 제공하면 GID와 동일한 숫자 UID가 사용됩니다. 사용자 이름 또는 그룹 이름이 제공되면 컨테이너의 루트 파일 시스템 &lt;code&gt;/etc/passwd&lt;/code&gt; 및 &lt;code&gt;/etc/group&lt;/code&gt; 파일이 각각 이름에서 정수 UID 또는 GID로 변환하는 데 사용됩니다. 다음 예제는 &lt;code&gt;--chown&lt;/code&gt; 플래그에 유효한 정의를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a2690a9a4ae6c3ee58a8e10078ccd35ca1d69e46" translate="yes" xml:space="preserve">
          <source>All of the README files are included. The middle line has no effect because &lt;code&gt;!README*.md&lt;/code&gt; matches &lt;code&gt;README-secret.md&lt;/code&gt; and comes last.</source>
          <target state="translated">모든 README 파일이 포함되어 있습니다. &lt;code&gt;!README*.md&lt;/code&gt; 가 &lt;code&gt;README-secret.md&lt;/code&gt; 와 일치 하고 마지막에 오므로 중간 행은 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bc6df11f2f66692594b5aac8e79219817d5ec79a" translate="yes" xml:space="preserve">
          <source>All official Docker library images found on the Docker Hub (docker.io/library/*) are signed by the same Notary root key. This root key&amp;rsquo;s ID has been embedded inside of the Docker Enterprise Engine. Therefore, to enforce that, only official Docker images can be used. Specify:</source>
          <target state="translated">Docker Hub (docker.io/library/*)에있는 모든 공식 Docker 라이브러리 이미지는 동일한 Notary 루트 키로 서명됩니다. 이 루트 키의 ID는 Docker Enterprise Engine 내부에 포함되어 있습니다. 따라서이를 강제하기 위해 공식 Docker 이미지 만 사용할 수 있습니다. 다음을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="af4bb1ba7249b17754143dd4e42cce1777c3480f" translate="yes" xml:space="preserve">
          <source>All other keys are ignored and produce a warning if present. You can review the configuration that will be used to deploy by using the &lt;code&gt;--compatibility&lt;/code&gt; flag with the &lt;code&gt;config&lt;/code&gt; command.</source>
          <target state="translated">다른 모든 키는 무시되고 존재하는 경우 경고를 생성합니다. &lt;code&gt;config&lt;/code&gt; 명령 과 함께 &lt;code&gt;--compatibility&lt;/code&gt; 플래그를 사용하여 배포에 사용될 구성을 검토 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa9acdac1c62b262d4a801f29e33b1243440dfc5" translate="yes" xml:space="preserve">
          <source>All other requests for JSON files include sha256 checksums of the file being requested and are therefore immutable. Requests for JSON files make up the vast majority of all notary requests. Requests for anything other than a GET of a JSON file should not be cached.</source>
          <target state="translated">JSON 파일에 대한 다른 모든 요청에는 요청중인 파일의 sha256 체크섬이 포함되므로 변경할 수 없습니다. JSON 파일 요청은 대부분의 모든 공증인 요청을 구성합니다. JSON 파일의 GET 이외의 요청은 캐시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="66175c863c342db1703cfd1a7f2c8aebddf1bfad" translate="yes" xml:space="preserve">
          <source>All requests are HTTP &lt;code&gt;POST&lt;/code&gt; requests.</source>
          <target state="translated">모든 요청은 HTTP &lt;code&gt;POST&lt;/code&gt; 요청입니다.</target>
        </trans-unit>
        <trans-unit id="4f4c20b7b2272123b43ab72090e5099682128052" translate="yes" xml:space="preserve">
          <source>All tags that have &lt;code&gt;alice&lt;/code&gt;&amp;rsquo;s signature on them are removed from the list of released tags:</source>
          <target state="translated">&lt;code&gt;alice&lt;/code&gt; 의 서명 이있는 모든 태그 는 릴리스 된 태그 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f9ec66aa1f242d33fde5c8a08cb2e498132ca8" translate="yes" xml:space="preserve">
          <source>All the Docker trust keys are stored encrypted using the passphrase you provide on creation. Even so, you should still take care of the location where you back them up. Good practice is to create two encrypted USB keys.</source>
          <target state="translated">모든 Docker 신뢰 키는 생성시 제공 한 암호를 사용하여 암호화되어 저장됩니다. 그럼에도 불구하고 여전히 백업 위치를 관리해야합니다. 암호화 된 USB 키를 두 개 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7620fe42d2e350e5617b071b0f9e0a63a595810e" translate="yes" xml:space="preserve">
          <source>Allocate IPs from a range</source>
          <target state="translated">범위에서 IP 할당</target>
        </trans-unit>
        <trans-unit id="655fdfd4443c64cd03b5c2f752aa7613e8ac159f" translate="yes" xml:space="preserve">
          <source>Allocate a pseudo-TTY</source>
          <target state="translated">의사 TTY 할당</target>
        </trans-unit>
        <trans-unit id="854abd1a8f8647dc0c678383f6f397f0b2744c95" translate="yes" xml:space="preserve">
          <source>Allocate container ip from a sub-range</source>
          <target state="translated">하위 범위에서 컨테이너 IP 할당</target>
        </trans-unit>
        <trans-unit id="3ad0e3698278f45b2af94445396e9865f213f617" translate="yes" xml:space="preserve">
          <source>Allow</source>
          <target state="translated">Allow</target>
        </trans-unit>
        <trans-unit id="87bfea25247f3e5f7a30a80f8aeb7e9a94c1375d" translate="yes" xml:space="preserve">
          <source>Allow MAC configuration or state changes. Implemented for the Smack LSM.</source>
          <target state="translated">MAC 구성 또는 상태 변경을 허용합니다. Smack LSM을 위해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="70140ee707382ccf75e1ecda91ba67b207e69e5f" translate="yes" xml:space="preserve">
          <source>Allow communication with an insecure registry</source>
          <target state="translated">안전하지 않은 레지스트리와의 통신 허용</target>
        </trans-unit>
        <trans-unit id="441a469fcffe3ab57a0d0cb9d9a45e504982b4ce" translate="yes" xml:space="preserve">
          <source>Allow push of nondistributable artifacts</source>
          <target state="translated">배포 할 수없는 아티팩트 푸시 허용</target>
        </trans-unit>
        <trans-unit id="ae163e5ae7b33fd50ea8f726742920dacafd8c32" translate="yes" xml:space="preserve">
          <source>Allow push to an insecure registry</source>
          <target state="translated">안전하지 않은 레지스트리로 푸시 허용</target>
        </trans-unit>
        <trans-unit id="7d93cb54919acb0e622a6d782e8a5c02588ae51c" translate="yes" xml:space="preserve">
          <source>Along the same lines, if you disable &lt;code&gt;userns-remap&lt;/code&gt; you can&amp;rsquo;t access any of the resources created while it was enabled.</source>
          <target state="translated">동일한 행을 따라 &lt;code&gt;userns-remap&lt;/code&gt; 을 비활성화 하면 활성화 된 동안 생성 된 리소스에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2e052bfd9fea2ae0480c2e5dccad58a088a954e" translate="yes" xml:space="preserve">
          <source>Also Windows Container makes use of &lt;code&gt;--exec-opt&lt;/code&gt; for special purpose. Docker user can specify default container isolation technology with this, for example:</source>
          <target state="translated">또한 Windows 컨테이너는 특수 목적 으로 &lt;code&gt;--exec-opt&lt;/code&gt; 를 사용합니다. Docker 사용자는 다음과 같이 기본 컨테이너 격리 기술을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d9119bec38cad5dd0ce2f4b5b6a362defdb573" translate="yes" xml:space="preserve">
          <source>Also, changing a MySQL root passphrase isn&amp;rsquo;t as simple as changing a file on disk. You must use a query or a &lt;code&gt;mysqladmin&lt;/code&gt; command to change the password in MySQL.</source>
          <target state="translated">또한 MySQL 루트 암호 문구를 변경하는 것은 디스크의 파일을 변경하는 것만 큼 간단하지 않습니다. MySQL에서 비밀번호를 변경하려면 query 또는 &lt;code&gt;mysqladmin&lt;/code&gt; 명령을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95b21add4ff4e3477c2d399390bb1d1e4b27b77d" translate="yes" xml:space="preserve">
          <source>Also, check the visualizer at port 8080 on either node&amp;rsquo;s IP address, and notice the &lt;code&gt;redis&lt;/code&gt; service running along with the &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;visualizer&lt;/code&gt; services.</source>
          <target state="translated">또한 노드의 IP 주소 중 하나에서 포트 8080의 비주얼 라이저를 확인하고 &lt;code&gt;web&lt;/code&gt; 및 &lt;code&gt;visualizer&lt;/code&gt; 서비스 와 함께 &lt;code&gt;redis&lt;/code&gt; 서비스가 실행 중인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b898aa36fe3be2ea49442a178e6bd76745135050" translate="yes" xml:space="preserve">
          <source>Also, you can set some of these variables in an &lt;a href=&quot;../../env-file/index&quot;&gt;environment file&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;../../env-file/index&quot;&gt;환경 파일&lt;/a&gt; 에서 이러한 변수 중 일부를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db6cb63555ee5d11ae4f6595ab49eb4d46efc7fd" translate="yes" xml:space="preserve">
          <source>Also, you need to have &lt;code&gt;docker&lt;/code&gt; binary 18.09 or later on the daemon host.</source>
          <target state="translated">또한 데몬 호스트에 &lt;code&gt;docker&lt;/code&gt; binary 18.09 이상 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f63fff3a7ce3738d09b949279240a0c54b37ff06" translate="yes" xml:space="preserve">
          <source>Alternate Dockerfile.</source>
          <target state="translated">대체 Dockerfile.</target>
        </trans-unit>
        <trans-unit id="2833c4ba71616eea188c338d9bc6dad76cc5424d" translate="yes" xml:space="preserve">
          <source>Alternately, root CA rotation can be used to give control of the swarm CA to an external CA, or to take control back from an external CA.</source>
          <target state="translated">또는 루트 CA 회전을 사용하여 웜 CA를 외부 CA에 제어하거나 외부 CA에서 제어를 다시받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f12b0ff726fdec1867c4c52859f0c4cec335baaa" translate="yes" xml:space="preserve">
          <source>Alternative Install Options</source>
          <target state="translated">대체 설치 옵션</target>
        </trans-unit>
        <trans-unit id="ffcfe49466d6d9903231b073c84f4cbfcd3b63a8" translate="yes" xml:space="preserve">
          <source>Alternative install options</source>
          <target state="translated">대체 설치 옵션</target>
        </trans-unit>
        <trans-unit id="cac1d550f8adec5dc858970f911f83395b96f0cb" translate="yes" xml:space="preserve">
          <source>Alternatively you can also get an overview of the swarm health from a manager node with &lt;code&gt;docker node ls&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;docker node ls&lt;/code&gt; 가 있는 관리자 노드에서 swarm 상태에 대한 개요를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc95e53263413219f56f80795c631381507a51d6" translate="yes" xml:space="preserve">
          <source>Alternatively you can trust the certificate globally by adding it to your system&amp;rsquo;s list of root Certificate Authorities.</source>
          <target state="translated">또는 시스템의 루트 인증 기관 목록에 인증서를 추가하여 전 세계적으로 인증서를 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f5831fe2131391bd26b96e2da6e6c3e74785da" translate="yes" xml:space="preserve">
          <source>Alternatively, if you&amp;rsquo;re not worried about keeping them, you can remove them. Compose just creates new ones.</source>
          <target state="translated">또는 보관에 대해 걱정하지 않으면 제거 할 수 있습니다. 작성은 새로운 것을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="8d45ed818cf0f48331423e26ab32b30336d414a3" translate="yes" xml:space="preserve">
          <source>Alternatively, install the latest &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; application on one computer. You can test both single-node and multi-node swarm from this computer, but you need to use Docker Machine to test the multi-node scenarios.</source>
          <target state="translated">또는 한 대의 컴퓨터에 최신 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 용 Docker Desktop&lt;/a&gt; 응용 프로그램을 설치하십시오 . 이 컴퓨터에서 단일 노드 및 다중 노드 떼를 모두 테스트 할 수 있지만 Docker Machine을 사용하여 다중 노드 시나리오를 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c188cf3e8bf28e6a4b7b38d9b12a7a7c237ca35" translate="yes" xml:space="preserve">
          <source>Alternatively, manual port mapping can be specified with the &lt;code&gt;--publish&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; options, just as when using &lt;code&gt;docker run&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;docker run&lt;/code&gt; 사용시 와 같이 &lt;code&gt;--publish&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 옵션을 사용하여 수동 포트 매핑을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa4a332a75013c505a0881b879de0c164ab6f84f" translate="yes" xml:space="preserve">
          <source>Alternatively, once the keys have been imported an image can be pushed with the &lt;code&gt;$ docker push&lt;/code&gt; command, by exporting the DCT environmental variable.</source>
          <target state="translated">또는 키를 가져온 후에 는 DCT 환경 변수를 내보내 &lt;code&gt;$ docker push&lt;/code&gt; 명령으로 이미지를 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c094beea9ff966fac32fc0cdfb289b65227f796c" translate="yes" xml:space="preserve">
          <source>Alternatively, run a shortcut command &lt;code&gt;docker-machine env -u&lt;/code&gt; to show the command you need to run to unset all DOCKER variables:</source>
          <target state="translated">또는 단축 명령 &lt;code&gt;docker-machine env -u&lt;/code&gt; 를 실행하여 모든 DOCKER 변수를 설정 해제하기 위해 실행해야하는 명령을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="33d4977ae6bd614a70ad0512c67ec39f71b3cbc3" translate="yes" xml:space="preserve">
          <source>Alternatively, write your own wrapper script to perform a more application-specific health check. For example, you might want to wait until Postgres is definitely ready to accept commands:</source>
          <target state="translated">또는 더 고유 한 랩퍼 스크립트를 작성하여보다 응용 프로그램 특정 상태 점검을 수행하십시오. 예를 들어 Postgres가 명령을 수락 할 준비가 될 때까지 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2f61de8c425f7ac152816b3e073b1b0a19c911" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;docker stack services&lt;/code&gt;, followed by the name of your stack. The following example command lets you view all services associated with the &lt;code&gt;getstartedlab&lt;/code&gt; stack:</source>
          <target state="translated">또는 &lt;code&gt;docker stack services&lt;/code&gt; 를 실행 한 다음 스택 이름을 실행할 수 있습니다 . 다음 예제 명령을 사용하면 &lt;code&gt;getstartedlab&lt;/code&gt; 스택 과 관련된 모든 서비스를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9edf17ad2ae73b380c1e836527080280a7b7643d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the flags &lt;code&gt;--amazonec2-access-key&lt;/code&gt; and &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; on the command line:</source>
          <target state="translated">또는 명령 행에서 &lt;code&gt;--amazonec2-access-key&lt;/code&gt; 및 &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca20bdcc8304d933da28223a98688aa9e6de7fd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can wrap Docker commands in the form of &lt;code&gt;docker-machine ssh &amp;lt;machine&amp;gt; &quot;&amp;lt;command&amp;gt;&quot;&lt;/code&gt;, which logs directly into the VM but doesn&amp;rsquo;t give you immediate access to files on your local host.</source>
          <target state="translated">또는 Docker &lt;code&gt;docker-machine ssh &amp;lt;machine&amp;gt; &quot;&amp;lt;command&amp;gt;&quot;&lt;/code&gt; 형식으로 Docker 명령을 래핑 할 수 있습니다.이 명령 은 VM에 직접 로그인하지만 로컬 호스트의 파일에 즉시 액세스 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fd578c1e0f72ee7ba96989496b666c3c21b693a" translate="yes" xml:space="preserve">
          <source>Always attempt to pull a newer version of the image</source>
          <target state="translated">항상 최신 버전의 이미지를 가져 오십시오</target>
        </trans-unit>
        <trans-unit id="59627da3d1db48b33ffb3588b56fe63fdd8d3371" translate="yes" xml:space="preserve">
          <source>Always follow symbol link in SRC_PATH</source>
          <target state="translated">항상 SRC_PATH의 심볼 링크를 따르십시오</target>
        </trans-unit>
        <trans-unit id="5fcfbf73a6474b9ba587f57b8fedfbb330414124" translate="yes" xml:space="preserve">
          <source>Always remove intermediate containers</source>
          <target state="translated">중간 용기를 항상 제거하십시오</target>
        </trans-unit>
        <trans-unit id="9840e2d52a5a0683dbbab2fe258f8b4d0fd77b42" translate="yes" xml:space="preserve">
          <source>Always restart the container regardless of the exit status, including on daemon startup, except if the container was put into a stopped state before the Docker daemon was stopped.</source>
          <target state="translated">Docker 데몬이 중지되기 전에 컨테이너가 중지 상태가 된 경우를 제외하고는 데몬 시작시를 포함하여 종료 상태에 관계없이 항상 컨테이너를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b6af1d0559f018d538fcb683cdd17c06a2b62901" translate="yes" xml:space="preserve">
          <source>Always restart the container regardless of the exit status. When you specify always, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.</source>
          <target state="translated">종료 상태에 관계없이 항상 컨테이너를 다시 시작하십시오. 항상 지정하면 Docker 데몬은 컨테이너를 무기한으로 다시 시작하려고 시도합니다. 컨테이너는 컨테이너의 현재 상태에 관계없이 항상 데몬 시작시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5a179c696b06c7eca76e6b146cedd5f9d1f90b00" translate="yes" xml:space="preserve">
          <source>Always run &lt;code&gt;docker swarm init&lt;/code&gt; and &lt;code&gt;docker swarm join&lt;/code&gt; with port 2377 (the swarm management port), or no port at all and let it take the default.</source>
          <target state="translated">항상 &lt;code&gt;docker swarm init&lt;/code&gt; 및 &lt;code&gt;docker swarm join&lt;/code&gt; 을 포트 2377 (웜 관리 포트)과 함께 실행하거나 포트가 전혀없는 상태에서 기본값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="09a8277e99fe2f0557063d244f82555f1d60c387" translate="yes" xml:space="preserve">
          <source>Always set the memory reservation value below the hard limit, otherwise the hard limit takes precedence. A reservation of 0 is the same as setting no reservation. By default (without reservation set), memory reservation is the same as the hard memory limit.</source>
          <target state="translated">메모리 예약 값을 항상 하드 한계 아래로 설정하십시오. 그렇지 않으면 하드 한계가 우선합니다. 예약 0은 예약 없음을 설정하는 것과 같습니다. 기본적으로 (예약 설정없이) 메모리 예약은 하드 메모리 제한과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2a6e8f3d12ed9f36a3930a53eba51361a79521dc" translate="yes" xml:space="preserve">
          <source>Amazon CloudWatch Logs logging driver for Docker. Writes log messages to Amazon CloudWatch Logs</source>
          <target state="translated">Docker 용 Amazon CloudWatch Logs 로깅 드라이버. Amazon CloudWatch Logs에 로그 메시지를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d3e00d24b34937e89bacd34e07ffb19f3bc4a9a5" translate="yes" xml:space="preserve">
          <source>Amazon Web Services</source>
          <target state="translated">아마존 웹 서비스</target>
        </trans-unit>
        <trans-unit id="2fa55c9970d9c86ddc0ebe6970e67464e7684acc" translate="yes" xml:space="preserve">
          <source>Amazon Web Services (AWS)</source>
          <target state="translated">아마존 웹 서비스 (AWS)</target>
        </trans-unit>
        <trans-unit id="37fe46e97ba406f2eccc574243881f6013dab7b9" translate="yes" xml:space="preserve">
          <source>Amazon Web Services (AWS) EC2 example</source>
          <target state="translated">AWS (Amazon Web Services) EC2 예</target>
        </trans-unit>
        <trans-unit id="d56775472c596f4734ecc2325b67790daa17d8ae" translate="yes" xml:space="preserve">
          <source>Ambiguous event fields in API</source>
          <target state="translated">API의 모호한 이벤트 필드</target>
        </trans-unit>
        <trans-unit id="466ba0deac0019df495396edc4725d894716b6f7" translate="yes" xml:space="preserve">
          <source>Amend an existing manifest list</source>
          <target state="translated">기존 목록 목록 수정</target>
        </trans-unit>
        <trans-unit id="472bcc2e02fbf2fd918b9a100c128db7209769c6" translate="yes" xml:space="preserve">
          <source>Amount of disk space to keep for cache</source>
          <target state="translated">캐시를 위해 유지할 디스크 공간</target>
        </trans-unit>
        <trans-unit id="9f2dd78c82736add99358e7f66f613b7e3cebf6c" translate="yes" xml:space="preserve">
          <source>Amount of time to wait after rolling back a task before rolling back the next one. A value of &lt;code&gt;0&lt;/code&gt; means to roll back the second task immediately after the first rolled-back task deploys.</source>
          <target state="translated">작업을 롤백 한 후 다음 작업을 롤백하기 전에 대기하는 시간입니다. 값이 &lt;code&gt;0&lt;/code&gt; 이면 첫 번째 롤백 작업이 배포 된 직후에 두 번째 작업을 롤백한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="5a5ea8cfa87cfd8b567a162e9bbac3a538d1b747" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-manage-availability/&quot;&gt;Availability Set&lt;/a&gt; is created to maximize availability of your machines.</source>
          <target state="translated">시스템의 &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-manage-availability/&quot;&gt;가용성&lt;/a&gt; 을 최대화하기 위해 가용성 세트 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="765abd027fd507b3b4b4f2ee5e4087e1d8a904f5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ARG&lt;/code&gt; declared before a &lt;code&gt;FROM&lt;/code&gt; is outside of a build stage, so it can&amp;rsquo;t be used in any instruction after a &lt;code&gt;FROM&lt;/code&gt;. To use the default value of an &lt;code&gt;ARG&lt;/code&gt; declared before the first &lt;code&gt;FROM&lt;/code&gt; use an &lt;code&gt;ARG&lt;/code&gt; instruction without a value inside of a build stage:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 전에 선언 된 &lt;code&gt;ARG&lt;/code&gt; 는 빌드 단계 외부에 있으므로 &lt;code&gt;FROM&lt;/code&gt; 이후의 명령에서는 사용할 수 없습니다 . 첫 번째 &lt;code&gt;FROM&lt;/code&gt; 이전에 선언 된 &lt;code&gt;ARG&lt;/code&gt; 의 기본값을 사용하려면 빌드 단계 내부에 값이없는 &lt;code&gt;ARG&lt;/code&gt; 명령어를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="79708a1294c575dbb2aa57db0ec53de2e70981b7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ARG&lt;/code&gt; instruction can optionally include a default value:</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 의 명령은 선택적 디폴트 값을 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c627bd42b3d52a5611ce4be9a25bdde96f481711" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ARG&lt;/code&gt; instruction goes out of scope at the end of the build stage where it was defined. To use an arg in multiple stages, each stage must include the &lt;code&gt;ARG&lt;/code&gt; instruction.</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 의 명령이 정의 된 빌드 단계의 끝에서 범위를 벗어나. 여러 단계에서 arg를 사용하려면 각 단계에는 &lt;code&gt;ARG&lt;/code&gt; 명령어 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="919f431f075703897f3b32e63c06078e24d632ca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ARG&lt;/code&gt; variable definition comes into effect from the line on which it is defined in the &lt;code&gt;Dockerfile&lt;/code&gt; not from the argument&amp;rsquo;s use on the command-line or elsewhere. For example, consider this Dockerfile:</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 의 변수 정의는이 정의되어있는 줄에서 발효 &lt;code&gt;Dockerfile&lt;/code&gt; 명령 줄이나 다른 곳에서 인수의 사용으로하지. 예를 들어,이 Dockerfile을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3cead5fe68d5f3d698edd5e9a02538cd0f4701f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ENTRYPOINT&lt;/code&gt; allows you to configure a container that will run as an executable.</source>
          <target state="translated">&lt;code&gt;ENTRYPOINT&lt;/code&gt; 당신이 실행 파일로 실행하는 컨테이너를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd08caa27c6b5ecfe038ef4ae579dedf839aeba5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; manager cluster tolerates the loss of at most &lt;code&gt;(N-1)/2&lt;/code&gt; managers.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 의 관리자 클러스터 최대의 손실 견뎌 &lt;code&gt;(N-1)/2&lt;/code&gt; 매니저.</target>
        </trans-unit>
        <trans-unit id="59877a2ea6c7c2a23085dd4537ff3dff5a4b2ff4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unreachable&lt;/code&gt; health status means that this particular manager node is unreachable from other manager nodes. In this case you need to take action to restore the unreachable manager:</source>
          <target state="translated">&lt;code&gt;unreachable&lt;/code&gt; 건강 상태는이 특정 관리 노드가 다른 관리 노드에서 도달 할 수 있음을 의미합니다. 이 경우 연결할 수없는 관리자를 복원하기위한 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="fae64b8b50705ee0140f4a39137121b902bac85c" translate="yes" xml:space="preserve">
          <source>An AppArmor profile for Docker is installed with the official &lt;em&gt;.deb&lt;/em&gt; packages. For information about this profile and overriding it, see &lt;a href=&quot;apparmor/index&quot;&gt;AppArmor security profiles for Docker&lt;/a&gt;.</source>
          <target state="translated">Docker 용 AppArmor 프로파일은 공식 &lt;em&gt;.deb&lt;/em&gt; 패키지 와 함께 설치 됩니다. 이 프로파일 및 재정의에 대한 정보는 &lt;a href=&quot;apparmor/index&quot;&gt;Docker의 AppArmor 보안 프로파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c352089596b520d2b5b12b7df639ba6fdf535ff" translate="yes" xml:space="preserve">
          <source>An arbitrary string representing either a key or a key-value pair. Expressed as &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;</source>
          <target state="translated">키 또는 키-값 쌍을 나타내는 임의의 문자열입니다. 표현 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="583284eeaf58db85f4cef4424005232dd1758900" translate="yes" xml:space="preserve">
          <source>An attacker can add any malicious content, remove any legitimate content from a collection, and mix up the targets in a collection. They may also add or remove the capabilities of any top level delegation key or role, for example, &lt;code&gt;Delegation1&lt;/code&gt;, &lt;code&gt;Delegation2&lt;/code&gt;, and &lt;code&gt;Delegation3&lt;/code&gt; in the key hierarchy diagram. If they remove the roles entirely, they&amp;rsquo;d break the trust chain to the lower delegation roles, such as &lt;code&gt;Delegation4&lt;/code&gt; or &lt;code&gt;Delegation5&lt;/code&gt;.</source>
          <target state="translated">공격자는 악의적 인 컨텐트를 추가하고 컬렉션에서 합법적 인 컨텐트를 제거하고 컬렉션에서 대상을 혼합 할 수 있습니다. 또한 키 계층 다이어그램에서 최상위 위임 키 또는 역할 (예 : &lt;code&gt;Delegation1&lt;/code&gt; , &lt;code&gt;Delegation2&lt;/code&gt; 및 &lt;code&gt;Delegation3&lt;/code&gt; ) 의 기능을 추가하거나 제거 할 수 있습니다 . 역할을 완전히 제거하면 신뢰 체인을 &lt;code&gt;Delegation4&lt;/code&gt; 또는 &lt;code&gt;Delegation5&lt;/code&gt; 와 같은 하위 위임 역할로 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4dbb3d4e2998881876958cdf84f4f4037548e4" translate="yes" xml:space="preserve">
          <source>An attacker can add any malicious content, remove any legitimate content from a collection, and mix up the targets in a collection. They may also add or remove the capabilities of any top level delegation key or role, such as &lt;code&gt;Delegation1&lt;/code&gt;, &lt;code&gt;Delegation2&lt;/code&gt;, and &lt;code&gt;Delegation3&lt;/code&gt; in the key hierarchy diagram. If they remove the roles entirely, they break the trust chain to the lower delegation roles, such as &lt;code&gt;Delegation4&lt;/code&gt; or &lt;code&gt;Delegation5&lt;/code&gt;.</source>
          <target state="translated">공격자는 악의적 인 컨텐트를 추가하고 컬렉션에서 합법적 인 컨텐트를 제거하고 컬렉션에서 대상을 혼합 할 수 있습니다. 키 계층 다이어그램에서 &lt;code&gt;Delegation1&lt;/code&gt; , &lt;code&gt;Delegation2&lt;/code&gt; 및 &lt;code&gt;Delegation3&lt;/code&gt; 과 같은 최상위 위임 키 또는 역할의 기능을 추가하거나 제거 할 수도 있습니다 . 역할을 완전히 제거하면 신뢰 체인을 &lt;code&gt;Delegation4&lt;/code&gt; 또는 &lt;code&gt;Delegation5&lt;/code&gt; 와 같은 하위 위임 역할로 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="942aa75018f9ddf73e9f30b3f8b38f1861d14e56" translate="yes" xml:space="preserve">
          <source>An attacker can add malicious content, remove legitimate content from a collection, and mix up the targets in a collection, but only within the particular delegation roles that the key can sign for. Depending on the restrictions on that role, they may be restricted in what type of content they can modify. A key may also add or remove the capabilities of other delegation keys below it on the key hierarchy For example, if &lt;code&gt;DelegationKey2&lt;/code&gt; in the above key hierarchy is compromised, it can only modify the capabilities of &lt;code&gt;DelegationKey4&lt;/code&gt; and &lt;code&gt;DelegationKey5&lt;/code&gt;.</source>
          <target state="translated">공격자는 악의적 인 콘텐츠를 추가하고 컬렉션에서 합법적 인 콘텐츠를 제거하며 컬렉션에서 대상을 혼합 할 수 있지만 키가 서명 할 수있는 특정 위임 역할 내에서만 가능합니다. 해당 역할의 제한 사항에 따라 수정할 수있는 콘텐츠 유형이 제한 될 수 있습니다. 키는 키 계층에서 키 아래에 다른 위임 키의 기능을 추가하거나 제거 할 수도 있습니다. 예를 들어, 위 키 계층의 &lt;code&gt;DelegationKey2&lt;/code&gt; 가 손상된 경우 &lt;code&gt;DelegationKey4&lt;/code&gt; 및 &lt;code&gt;DelegationKey5&lt;/code&gt; 의 기능 만 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec4882724412ac67281dd11282fc1e3c65b393be" translate="yes" xml:space="preserve">
          <source>An attacker can add malicious content, remove legitimate content from a collection, and mix up the targets in a collection, but only within the particular delegation roles that the key can sign for. Depending on the restrictions on that role, they may be restricted in what type of content they can modify. They may also add or remove the capabilities of other delegation keys below it on the key hierarchy For example, if &lt;code&gt;DelegationKey2&lt;/code&gt; in the above key hierarchy is compromised, the compromised key could only modify the capabilities of &lt;code&gt;DelegationKey4&lt;/code&gt; and &lt;code&gt;DelegationKey5&lt;/code&gt;.</source>
          <target state="translated">공격자는 악의적 인 콘텐츠를 추가하고 컬렉션에서 합법적 인 콘텐츠를 제거하고 컬렉션에서 대상을 혼합 할 수 있지만 키가 서명 할 수있는 특정 위임 역할 내에서만 가능합니다. 해당 역할의 제한 사항에 따라 수정할 수있는 콘텐츠 유형이 제한 될 수 있습니다. 키 계층에서 그 아래에 다른 위임 키의 기능을 추가하거나 제거 할 수도 있습니다. 예를 들어, 위 키 계층의 &lt;code&gt;DelegationKey2&lt;/code&gt; 가 손상된 경우 손상된 키는 &lt;code&gt;DelegationKey4&lt;/code&gt; 및 &lt;code&gt;DelegationKey5&lt;/code&gt; 의 기능 만 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672c502cfca05e1593b719f92fe05034275459ad" translate="yes" xml:space="preserve">
          <source>An authorization plugin approves or denies requests to the Docker daemon based on both the current authentication context and the command context. The authentication context contains all user details and the authentication method. The command context contains all the relevant request data.</source>
          <target state="translated">인증 플러그인은 현재 인증 컨텍스트와 명령 컨텍스트 모두를 기반으로 Docker 데몬에 대한 요청을 승인하거나 거부합니다. 인증 컨텍스트에는 모든 사용자 세부 사항 및 인증 방법이 포함됩니다. 명령 컨텍스트에는 모든 관련 요청 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f4e384e6910e6d11ca3a834d7fa0f04ab8f973" translate="yes" xml:space="preserve">
          <source>An authorization plugin based on &lt;a href=&quot;https://github.com/casbin/casbin&quot;&gt;Casbin&lt;/a&gt;, which supports access control models like ACL, RBAC, ABAC. The access control model can be customized. The policy can be persisted into file or DB.</source>
          <target state="translated">ACL, RBAC, ABAC와 같은 액세스 제어 모델을 지원 하는 &lt;a href=&quot;https://github.com/casbin/casbin&quot;&gt;Casbin&lt;/a&gt; 기반 인증 플러그인 . 액세스 제어 모델을 사용자 정의 할 수 있습니다. 정책은 파일 또는 DB에 유지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22223fb20ba977f518c0b12e3af184715132a955" translate="yes" xml:space="preserve">
          <source>An authorization plugin that prevents from executing commands with certains parameters.</source>
          <target state="translated">특정 매개 변수로 명령을 실행하지 못하게하는 권한 플러그인</target>
        </trans-unit>
        <trans-unit id="1af59282032be5e611c1f4dcf7f3c5a06b51c4d1" translate="yes" xml:space="preserve">
          <source>An entry under the top-level &lt;code&gt;volumes&lt;/code&gt; key can be empty, in which case it uses the default driver configured by the Engine (in most cases, this is the &lt;code&gt;local&lt;/code&gt; driver). Optionally, you can configure it with the following keys:</source>
          <target state="translated">최상위 &lt;code&gt;volumes&lt;/code&gt; 키 아래의 항목은 비어있을 수 있으며,이 경우 엔진에서 구성한 기본 드라이버를 사용합니다 (대부분의 경우 &lt;code&gt;local&lt;/code&gt; 드라이버 임). 선택적으로 다음 키를 사용하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00db06fb5206797a4c38a65c2c32a7ec5d159a5c" translate="yes" xml:space="preserve">
          <source>An entry with the ip address and hostname is created in &lt;code&gt;/etc/hosts&lt;/code&gt; inside containers for this build, e.g:</source>
          <target state="translated">ip 주소와 호스트 이름을 가진 항목 이이 빌드의 컨테이너 내부에 있는 &lt;code&gt;/etc/hosts&lt;/code&gt; 에 작성됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="49cd6949f4d45cb7bc7f20bf32d60b97c72bfdc5" translate="yes" xml:space="preserve">
          <source>An entry with the ip address and hostname is created in &lt;code&gt;/etc/hosts&lt;/code&gt; inside containers for this service, e.g:</source>
          <target state="translated">IP 주소 및 호스트 이름을 가진 항목 이이 서비스의 컨테이너 내부에 있는 &lt;code&gt;/etc/hosts&lt;/code&gt; 에 작성됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2da4bd4405ab52302ce9bcbc70732673b0b2e90f" translate="yes" xml:space="preserve">
          <source>An ever increasing delay (double the previous delay, starting at 100 milliseconds) is added before each restart to prevent flooding the server. This means the daemon will wait for 100 ms, then 200 ms, 400, 800, 1600, and so on until either the &lt;code&gt;on-failure&lt;/code&gt; limit is hit, or when you &lt;code&gt;docker stop&lt;/code&gt; or &lt;code&gt;docker rm -f&lt;/code&gt; the container.</source>
          <target state="translated">서버 플러딩을 방지하기 위해 다시 시작할 때마다 계속 증가하는 지연 (100 밀리 초부터 시작하여 이전 지연의 두 배)이 추가됩니다. 이는 데몬이 &lt;code&gt;on-failure&lt;/code&gt; 제한에 도달하거나 컨테이너 를 &lt;code&gt;docker stop&lt;/code&gt; 또는 &lt;code&gt;docker rm -f&lt;/code&gt; 할 때 까지 100ms, 200ms, 400, 800, 1600 등을 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="329686eacbcbce4e6f6b3d00065232e0897aa6e6" translate="yes" xml:space="preserve">
          <source>An image can have more than one label. You can specify multiple labels on a single line. Prior to Docker 1.10, this decreased the size of the final image, but this is no longer the case. You may still choose to specify multiple labels in a single instruction, in one of the following two ways:</source>
          <target state="translated">이미지에는 둘 이상의 레이블이있을 수 있습니다. 한 줄에 여러 레이블을 지정할 수 있습니다. Docker 1.10 이전에는 최종 이미지의 크기가 줄어들었지만 더 이상 그렇지 않습니다. 다음 두 가지 방법 중 하나를 사용하여 단일 명령으로 여러 레이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e19642c57620caef2d181970c4b0d9ee154d718" translate="yes" xml:space="preserve">
          <source>An image name is made up of slash-separated name components, optionally prefixed by a registry hostname. The hostname must comply with standard DNS rules, but may not contain underscores. If a hostname is present, it may optionally be followed by a port number in the format &lt;code&gt;:8080&lt;/code&gt;. If not present, the command uses Docker&amp;rsquo;s public registry located at &lt;code&gt;registry-1.docker.io&lt;/code&gt; by default. Name components may contain lowercase letters, digits and separators. A separator is defined as a period, one or two underscores, or one or more dashes. A name component may not start or end with a separator.</source>
          <target state="translated">이미지 이름은 슬래시로 구분 된 이름 구성 요소로 구성되며 선택적으로 레지스트리 호스트 이름이 접두어로 붙습니다. 호스트 이름은 표준 DNS 규칙을 준수해야하지만 밑줄을 포함 할 수 없습니다. 호스트 이름이 있으면 선택적으로 뒤에 &lt;code&gt;:8080&lt;/code&gt; 형식의 포트 번호가 올 수 있습니다. 존재하지 않는 경우, 명령에 위치한 부두 노동자의 공개 레지스트리 사용 &lt;code&gt;registry-1.docker.io&lt;/code&gt; 기본으로합니다. 이름 구성 요소에는 소문자, 숫자 및 구분 기호가 포함될 수 있습니다. 구분 기호는 마침표, 하나 또는 두 개의 밑줄 또는 하나 이상의 대시로 정의됩니다. 이름 구성 요소는 구분 기호로 시작하거나 끝나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86cb1784e576ddc0981174df2c6a486a0e2f3e72" translate="yes" xml:space="preserve">
          <source>An image named &lt;code&gt;test&lt;/code&gt; is built with &lt;code&gt;--squash&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 라는 이미지 는 &lt;code&gt;--squash&lt;/code&gt; 인수로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4db7f98438a8cd84b89363f467ad6f6dbd1fcd91" translate="yes" xml:space="preserve">
          <source>An image pulled by digest has no tag associated with it:</source>
          <target state="translated">다이제스트로 가져온 이미지에는 연관된 태그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f62a639d44438f9633bc404cf47e59f0a3757422" translate="yes" xml:space="preserve">
          <source>An image repository can contain an image with one tag that is signed and another tag that is not. For example, consider &lt;a href=&quot;https://hub.docker.com/r/library/mongo/tags/&quot;&gt;the Mongo image repository&lt;/a&gt;. The &lt;code&gt;latest&lt;/code&gt; tag could be unsigned while the &lt;code&gt;3.1.6&lt;/code&gt; tag could be signed. It is the responsibility of the image publisher to decide if an image tag is signed or not. In this representation, some image tags are signed, others are not:</source>
          <target state="translated">이미지 저장소에는 서명 된 하나의 태그와 그렇지 않은 다른 태그가있는 이미지가 포함될 수 있습니다. 예를 들어 &lt;a href=&quot;https://hub.docker.com/r/library/mongo/tags/&quot;&gt;Mongo 이미지 저장소를&lt;/a&gt; 고려 하십시오 . &lt;code&gt;latest&lt;/code&gt; 그동안 태그는 부호가 될 수 &lt;code&gt;3.1.6&lt;/code&gt; 태그에 서명 할 수있다. 이미지 태그의 서명 여부를 결정하는 것은 이미지 게시자의 책임입니다. 이 표현에서 일부 이미지 태그는 서명되고 다른 이미지 태그는 서명되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="684177704d4f78801a7425a8b68d9a6d0faae260" translate="yes" xml:space="preserve">
          <source>An image version can be expressed in several different ways:</source>
          <target state="translated">이미지 버전은 여러 가지 방식으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c170aee6ea8b174d1e40a13ec6cee6720f6b1c" translate="yes" xml:space="preserve">
          <source>An image will be listed more than once if it has multiple repository names or tags. This single image (identifiable by its matching &lt;code&gt;IMAGE ID&lt;/code&gt;) uses up the &lt;code&gt;SIZE&lt;/code&gt; listed only once.</source>
          <target state="translated">이미지에 여러 저장소 이름 또는 태그가있는 경우 이미지가 두 번 이상 나열됩니다. 이 단일 이미지 (일치하는 &lt;code&gt;IMAGE ID&lt;/code&gt; 로 식별 가능 )는 한 번만 나열된 &lt;code&gt;SIZE&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="90f8e14998e29122565fde0dfa656d297cff03dc" translate="yes" xml:space="preserve">
          <source>An important note about the examples</source>
          <target state="translated">예제에 대한 중요한 참고 사항</target>
        </trans-unit>
        <trans-unit id="487178fd5c3054d7f634b00b52cbf68338c219a4" translate="yes" xml:space="preserve">
          <source>An important part of any Continuous Deployment or Continuous Integration process is the automated test suite. Automated end-to-end testing requires an environment in which to run tests. Compose provides a convenient way to create and destroy isolated testing environments for your test suite. By defining the full environment in a &lt;a href=&quot;compose-file/index&quot;&gt;Compose file&lt;/a&gt;, you can create and destroy these environments in just a few commands:</source>
          <target state="translated">Continuous Deployment 또는 Continuous Integration 프로세스의 중요한 부분은 자동화 된 테스트 스위트입니다. 자동화 된 엔드-투-엔드 테스트에는 테스트를 실행하는 환경이 필요합니다. Compose는 테스트 스위트를위한 격리 된 테스트 환경을 작성하고 파괴 할 수있는 편리한 방법을 제공합니다. &lt;a href=&quot;compose-file/index&quot;&gt;작성 파일&lt;/a&gt; 에서 전체 환경을 정의하면 몇 가지 명령만으로 이러한 환경을 작성하고 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36020ffbf37839a64d482b159286dddb0c47d18c" translate="yes" xml:space="preserve">
          <source>An individual image record has the following identifier:</source>
          <target state="translated">개별 이미지 레코드에는 다음 식별자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fcc8d8eef047749fd368d0e9b8174826a536dc" translate="yes" xml:space="preserve">
          <source>An individual task update is considered to have failed if the task doesn&amp;rsquo;t start up, or if it stops running within the monitoring period specified with the &lt;code&gt;--update-monitor&lt;/code&gt; flag. The default value for &lt;code&gt;--update-monitor&lt;/code&gt; is 30 seconds, which means that a task failing in the first 30 seconds after its started counts towards the service update failure threshold, and a failure after that is not counted.</source>
          <target state="translated">작업이 시작되지 않거나 &lt;code&gt;--update-monitor&lt;/code&gt; 플래그로 지정된 모니터링 기간 내에 실행이 중지되면 개별 작업 업데이트가 실패한 것으로 간주됩니다 . &lt;code&gt;--update-monitor&lt;/code&gt; 의 기본값 은 30 초입니다. 즉, 시작한 후 처음 30 초 동안 실패한 작업은 서비스 업데이트 실패 임계 값으로 계산되고 그 이후의 실패는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3476a79495fa9e52ad5c043ff1631a84d0b70cd6" translate="yes" xml:space="preserve">
          <source>An integer representing the container&amp;rsquo;s exit code. Only useful with &lt;code&gt;--all&lt;/code&gt;.</source>
          <target state="translated">컨테이너의 종료 코드를 나타내는 정수입니다. &lt;code&gt;--all&lt;/code&gt; 에서만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="702c01056699bded0baf009e19e83f6d3296e079" translate="yes" xml:space="preserve">
          <source>An open source network plugin to provide infrastructure and security policies for a multi-tenant micro services deployment, while providing an integration to physical network for non-container workload. Contiv Networking implements the remote driver and IPAM APIs available in Docker 1.9 onwards.</source>
          <target state="translated">멀티 테넌트 마이크로 서비스 배포를위한 인프라 및 보안 정책을 제공하는 동시에 비 컨테이너 워크로드를 위해 물리적 네트워크에 통합을 제공하는 오픈 소스 네트워크 플러그인. Contiv Networking은 Docker 1.9 이상에서 사용 가능한 원격 드라이버 및 IPAM API를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="113f730d1e6ede9b9ddb380e20fbe23dc3525eed" translate="yes" xml:space="preserve">
          <source>An open source volume plugin that allows using an &lt;a href=&quot;https://ipfs.io/&quot;&gt;ipfs&lt;/a&gt; filesystem as a volume.</source>
          <target state="translated">&lt;a href=&quot;https://ipfs.io/&quot;&gt;ipfs&lt;/a&gt; 파일 시스템을 볼륨으로 사용할 수있는 오픈 소스 볼륨 플러그인 .</target>
        </trans-unit>
        <trans-unit id="7376333f76af4272c3b68d221c2cb2750408bb5b" translate="yes" xml:space="preserve">
          <source>An open source volume plugin that provides multi-tenant, persistent, distributed storage with intent based consumption. It has support for Ceph and NFS.</source>
          <target state="translated">인 텐트 기반 소비로 다중 테넌트, 영구 분산 스토리지를 제공하는 오픈 소스 볼륨 플러그인입니다. Ceph 및 NFS를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2c8f0aca1870fe829a557b73c6a88f75242047ac" translate="yes" xml:space="preserve">
          <source>An open source volume plugin to create persistent volumes in a BeeGFS parallel file system.</source>
          <target state="translated">BeeGFS 병렬 파일 시스템에서 영구 볼륨을 생성하는 오픈 소스 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="1140a1b75a04444748561b3ee30b7070db88195f" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-2&quot;&gt;version 2&lt;/a&gt; that introduces new parameters only available with Docker Engine version &lt;strong&gt;1.12.0+&lt;/strong&gt;. Version 2.1 files are supported by &lt;strong&gt;Compose 1.9.0+&lt;/strong&gt;.</source>
          <target state="translated">Docker Engine 버전 &lt;strong&gt;1.12.0+&lt;/strong&gt; 에서만 사용할 수있는 새로운 매개 변수를 도입 한 &lt;a href=&quot;#version-2&quot;&gt;버전 2&lt;/a&gt; 의 업그레이드 . 버전 2.1 파일은 &lt;strong&gt;Compose 1.9.0 이상에서&lt;/strong&gt; 지원됩니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ef5ef8122adc35241f8326e1dab3ac8edd520b" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-21&quot;&gt;version 2.1&lt;/a&gt; that introduces new parameters only available with Docker Engine version &lt;strong&gt;1.13.0+&lt;/strong&gt;. Version 2.2 files are supported by &lt;strong&gt;Compose 1.13.0+&lt;/strong&gt;. This version also allows you to specify default scale numbers inside the service&amp;rsquo;s configuration.</source>
          <target state="translated">Docker Engine 버전 &lt;strong&gt;1.13.0+&lt;/strong&gt; 에서만 사용할 수있는 새 매개 변수를 도입 하는 &lt;a href=&quot;#version-21&quot;&gt;버전 2.1&lt;/a&gt; 의 업그레이드 . 버전 2.2 파일은 &lt;strong&gt;Compose 1.13.0+에서&lt;/strong&gt; 지원됩니다 . 이 버전을 사용하면 서비스 구성 내에서 기본 스케일 번호를 지정할 수도 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f121ceb93dc2ed7779fcc5444f83b399517c15" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-22&quot;&gt;version 2.2&lt;/a&gt; that introduces new parameters only available with Docker Engine version &lt;strong&gt;17.06.0+&lt;/strong&gt;. Version 2.3 files are supported by &lt;strong&gt;Compose 1.16.0+&lt;/strong&gt;.</source>
          <target state="translated">Docker Engine 버전 &lt;strong&gt;17.06.0+&lt;/strong&gt; 에서만 사용할 수있는 새 매개 변수를 도입 하는 &lt;a href=&quot;#version-22&quot;&gt;버전 2.2&lt;/a&gt; 의 업그레이드 . 버전 2.3 파일은 &lt;strong&gt;Compose 1.16.0+에서&lt;/strong&gt; 지원됩니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cdd822bd568c36594d5de5b56df5ccd2e8d2036" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-23&quot;&gt;version 2.3&lt;/a&gt; that introduces new parameters only available with Docker Engine version &lt;strong&gt;17.12.0+&lt;/strong&gt;. Version 2.4 files are supported by &lt;strong&gt;Compose 1.21.0+&lt;/strong&gt;.</source>
          <target state="translated">Docker Engine 버전 &lt;strong&gt;17.12.0+&lt;/strong&gt; 에서만 사용할 수있는 새로운 매개 변수를 도입 하는 &lt;a href=&quot;#version-23&quot;&gt;버전 2.3&lt;/a&gt; 의 업그레이드 . 버전 2.4 파일은 &lt;strong&gt;Compose 1.21.0 이상에서&lt;/strong&gt; 지원됩니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e102d51f50702007b5d6813eeac24c11257bd7b3" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-3&quot;&gt;version 3&lt;/a&gt; that introduces new parameters only available with Docker Engine version &lt;strong&gt;17.06.0+&lt;/strong&gt;, and higher.</source>
          <target state="translated">Docker Engine 버전 &lt;strong&gt;17.06.0&lt;/strong&gt; 이상 에서만 사용할 수있는 새 매개 변수를 도입 한 &lt;a href=&quot;#version-3&quot;&gt;버전 3&lt;/a&gt; 의 업그레이드 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="726db0b05b1e4262ba01c10f4d3add274ad9b543" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-3&quot;&gt;version 3&lt;/a&gt; that introduces new parameters. It is only available with Docker Engine version &lt;strong&gt;17.09.0&lt;/strong&gt; and higher.</source>
          <target state="translated">새로운 매개 변수를 도입 한 &lt;a href=&quot;#version-3&quot;&gt;버전 3&lt;/a&gt; 의 업그레이드 . Docker Engine 버전 &lt;strong&gt;17.09.0&lt;/strong&gt; 이상 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f442492657fa8f681372fe78d02b46f9e66e44d" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-3&quot;&gt;version 3&lt;/a&gt; that introduces new parameters. It is only available with Docker Engine version &lt;strong&gt;17.12.0&lt;/strong&gt; and higher.</source>
          <target state="translated">새로운 매개 변수를 도입 한 &lt;a href=&quot;#version-3&quot;&gt;버전 3&lt;/a&gt; 의 업그레이드 . Docker Engine 버전 &lt;strong&gt;17.12.0&lt;/strong&gt; 이상 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d98042829311ea330d16a2af79eae327b84947bd" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-3&quot;&gt;version 3&lt;/a&gt; that introduces new parameters. It is only available with Docker Engine version &lt;strong&gt;18.02.0&lt;/strong&gt; and higher.</source>
          <target state="translated">새로운 매개 변수를 도입 한 &lt;a href=&quot;#version-3&quot;&gt;버전 3&lt;/a&gt; 의 업그레이드 . Docker Engine 버전 &lt;strong&gt;18.02.0&lt;/strong&gt; 이상 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="366b2640b379ecccea39403467583bd05e9cc493" translate="yes" xml:space="preserve">
          <source>An upgrade of &lt;a href=&quot;#version-3&quot;&gt;version 3&lt;/a&gt; that introduces new parameters. It is only available with Docker Engine version &lt;strong&gt;18.06.0&lt;/strong&gt; and higher.</source>
          <target state="translated">새로운 매개 변수를 도입 한 &lt;a href=&quot;#version-3&quot;&gt;버전 3&lt;/a&gt; 의 업그레이드 . Docker Engine 버전 &lt;strong&gt;18.06.0&lt;/strong&gt; 이상 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7dac9598e3cd591ec6624406212fc665bed26ce1" translate="yes" xml:space="preserve">
          <source>And in this second example, you can see the exit code returned by the &lt;code&gt;bash&lt;/code&gt; process is returned by the &lt;code&gt;docker attach&lt;/code&gt; command to its caller too:</source>
          <target state="translated">그리고이 두 번째 예에서 &lt;code&gt;bash&lt;/code&gt; 프로세스가 반환 한 종료 코드 가 &lt;code&gt;docker attach&lt;/code&gt; 명령으로 호출자에게 반환되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc33e61ab98dbfd15579b049f2e974137916bfd4" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s it, the app is deployed on a swarm cluster!</source>
          <target state="translated">그게 다야, 앱은 웜 클러스터에 배포됩니다!</target>
        </trans-unit>
        <trans-unit id="67779d5577304f1a76f2f14061e9e65aa9115561" translate="yes" xml:space="preserve">
          <source>And the following files:</source>
          <target state="translated">그리고 다음 파일들 :</target>
        </trans-unit>
        <trans-unit id="f353dd45407d9e6dbad3e76252a426ada3818037" translate="yes" xml:space="preserve">
          <source>And we can try it out like so:</source>
          <target state="translated">그리고 우리는 다음과 같이 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e806276841e6086002953aa02f1f68d4152e3287" translate="yes" xml:space="preserve">
          <source>And you can gracefully request &lt;code&gt;top&lt;/code&gt; to shut down using &lt;code&gt;docker stop test&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;docker stop test&lt;/code&gt; 를 사용하여 &lt;code&gt;top&lt;/code&gt; 종료를 정상적으로 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8dffb7e83f20cc40d76bc20938d4245195bb5cd" translate="yes" xml:space="preserve">
          <source>Another common use case is running adhoc or administrative tasks against one or more services in a Compose app. This example demonstrates running a database backup.</source>
          <target state="translated">또 다른 일반적인 사용 사례는 Compose 앱에서 하나 이상의 서비스에 대해 임시 또는 관리 작업을 실행하는 것입니다. 이 예는 데이터베이스 백업 실행을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2abc670d3759b912178f32db28d49a9cbe29fa8b" translate="yes" xml:space="preserve">
          <source>Another example that uses &lt;code&gt;btrfs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;btrfs&lt;/code&gt; 를 사용하는 다른 예 :</target>
        </trans-unit>
        <trans-unit id="6ddecfb2e083c224c0178b099bcea26ce35ccab0" translate="yes" xml:space="preserve">
          <source>Another example that uses &lt;code&gt;nfs&lt;/code&gt; to mount the &lt;code&gt;/path/to/dir&lt;/code&gt; in &lt;code&gt;rw&lt;/code&gt; mode from &lt;code&gt;192.168.1.1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;nfs&lt;/code&gt; 를 사용 하여 &lt;code&gt;192.168.1.1&lt;/code&gt; 에서 &lt;code&gt;rw&lt;/code&gt; 모드 &lt;code&gt;/path/to/dir&lt;/code&gt; 을 마운트하는 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f70d2b7c216e03ee975ebb0ec2cedb3d3cfa1830" translate="yes" xml:space="preserve">
          <source>Another good reference is the Compose file for the voting app sample used in the &lt;a href=&quot;https://github.com/docker/labs/tree/master/beginner/&quot;&gt;Docker for Beginners lab&lt;/a&gt; topic on &lt;a href=&quot;https://github.com/docker/labs/blob/master/beginner/chapters/votingapp/&quot;&gt;Deploying an app to a Swarm&lt;/a&gt;. This is also shown on the accordion at the top of this section.</source>
          <target state="translated">또 다른 좋은 참고 자료는 &lt;a href=&quot;https://github.com/docker/labs/tree/master/beginner/&quot;&gt;Docker for Beginners 랩&lt;/a&gt; 주제에서 &lt;a href=&quot;https://github.com/docker/labs/blob/master/beginner/chapters/votingapp/&quot;&gt;Swarm에 앱 배포&lt;/a&gt; 에 사용 된 투표 앱 샘플의 작성 파일입니다 . 이것은이 섹션 상단의 아코디언에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="10642b483c605f8e087364cbd31be4d2afec1944" translate="yes" xml:space="preserve">
          <source>Another use case for using secrets is to provide a layer of abstraction between the container and a set of credentials. Consider a scenario where you have separate development, test, and production environments for your application. Each of these environments can have different credentials, stored in the development, test, and production swarms with the same secret name. Your containers only need to know the name of the secret to function in all three environments.</source>
          <target state="translated">비밀을 사용하는 또 다른 사용 사례는 컨테이너와 자격 증명 세트 사이에 추상화 계층을 제공하는 것입니다. 응용 프로그램에 대해 별도의 개발, 테스트 및 프로덕션 환경이있는 시나리오를 고려하십시오. 이러한 각 환경은 서로 다른 자격 증명을 가질 수 있으며 동일한 비밀 이름을 가진 개발, 테스트 및 프로덕션 떼에 저장됩니다. 컨테이너는 세 가지 환경 모두에서 작동하기 위해 비밀 이름 만 알면됩니다.</target>
        </trans-unit>
        <trans-unit id="cf83cf1ab9c3d49c804c1a0b73196e7c5006f605" translate="yes" xml:space="preserve">
          <source>Another variant for external configs is when the name of the config in Docker is different from the name that exists within the service. The following example modifies the previous one to use the external config called &lt;code&gt;redis_config&lt;/code&gt;.</source>
          <target state="translated">외부 구성의 또 다른 변형은 Docker의 구성 이름이 서비스 내에 존재하는 이름과 다른 경우입니다. 다음 예제는 &lt;code&gt;redis_config&lt;/code&gt; 라는 외부 구성을 사용하도록 이전 구성을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="2324a104f9255c11258eb35613e563fd25a10a9d" translate="yes" xml:space="preserve">
          <source>Another variant for external secrets is when the name of the secret in Docker is different from the name that exists within the service. The following example modifies the previous one to use the external secret called &lt;code&gt;redis_secret&lt;/code&gt;.</source>
          <target state="translated">외부 비밀의 또 다른 변형은 Docker의 비밀 이름이 서비스 내에 존재하는 이름과 다른 경우입니다. 다음 예제는 &lt;code&gt;redis_secret&lt;/code&gt; 이라는 외부 비밀번호를 사용하도록 이전 비밀번호를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="97dd72f9cd2aec5c14c0a63f9f232e24b10c6d1e" translate="yes" xml:space="preserve">
          <source>Any build instruction can be registered as a trigger.</source>
          <target state="translated">모든 빌드 명령은 트리거로 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce095d81869b8be8fc4acf423cd4ecdbcc44c2c7" translate="yes" xml:space="preserve">
          <source>Any data which is not in a volume is lost.</source>
          <target state="translated">볼륨에없는 데이터는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="903974fe3abb62e15608ed7d6131ab09bde8c6bd" translate="yes" xml:space="preserve">
          <source>Any exposed ports are available on the Docker host&amp;rsquo;s IP address, which you can get using the &lt;code&gt;docker-machine ip&lt;/code&gt; command:</source>
          <target state="translated">노출 된 모든 포트는 Docker 호스트의 IP 주소에서 사용할 수 있으며 &lt;code&gt;docker-machine ip&lt;/code&gt; 명령을 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c83dbbf2be153a0aeba56bfda8b942d644e07149" translate="yes" xml:space="preserve">
          <source>Any of these events result in a &lt;code&gt;137&lt;/code&gt; status:</source>
          <target state="translated">이러한 이벤트는 모두 &lt;code&gt;137&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="85fcde6aeb6e78317f9a173c0794df8fd79168cd" translate="yes" xml:space="preserve">
          <source>Anyone with the appropriate skills can develop an authorization plugin. These skills, at their most basic, are knowledge of Docker, understanding of REST, and sound programming knowledge. This document describes the architecture, state, and methods information available to an authorization plugin developer.</source>
          <target state="translated">적절한 기술을 가진 사람이라면 누구나 인증 플러그인을 개발할 수 있습니다. 기본적으로 이러한 기술은 Docker에 대한 지식, REST에 대한 이해 및 올바른 프로그래밍 지식입니다. 이 문서는 권한 플러그인 개발자가 사용할 수있는 아키텍처, 상태 및 메소드 정보를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3978a0df3f7c86ac2f1135ab7c92035d6073a527" translate="yes" xml:space="preserve">
          <source>AppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats. To use it, a system administrator associates an AppArmor security profile with each program. Docker expects to find an AppArmor policy loaded and enforced.</source>
          <target state="translated">AppArmor (Application Armor)는 운영 체제 및 해당 응용 프로그램을 보안 위협으로부터 보호하는 Linux 보안 모듈입니다. 이를 사용하기 위해 시스템 관리자는 AppArmor 보안 프로파일을 각 프로그램과 연관시킵니다. Docker는로드되고 적용되는 AppArmor 정책을 찾을 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="1c480fec392526646bfda64235d1d9f6c21a4e11" translate="yes" xml:space="preserve">
          <source>AppArmor security profiles for Docker</source>
          <target state="translated">Docker의 AppArmor 보안 프로파일</target>
        </trans-unit>
        <trans-unit id="69c2056b4c8b9f465bbbf2139d68072d8eed369e" translate="yes" xml:space="preserve">
          <source>AppArmor sends quite verbose messaging to &lt;code&gt;dmesg&lt;/code&gt;. Usually an AppArmor line looks like the following:</source>
          <target state="translated">AppArmor는 &lt;code&gt;dmesg&lt;/code&gt; 에 매우 자세한 메시지를 보냅니다 . 일반적으로 AppArmor 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b429cca1f3b3b0e75c5096eebea744d305c588f" translate="yes" xml:space="preserve">
          <source>Apple macOS keychain: https://github.com/docker/docker-credential-helpers/releases</source>
          <target state="translated">Apple macOS 키 체인 : https://github.com/docker/docker-credential-helpers/releases</target>
        </trans-unit>
        <trans-unit id="39d78a97babd08333164f78e32807b19ff896228" translate="yes" xml:space="preserve">
          <source>Apply Dockerfile instruction to the created image</source>
          <target state="translated">생성 된 이미지에 Dockerfile 명령 적용</target>
        </trans-unit>
        <trans-unit id="f5eb99c520d0943ca330734d358d0a371d57b49c" translate="yes" xml:space="preserve">
          <source>Apply executable permissions to the binary:</source>
          <target state="translated">바이너리에 실행 권한을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="20827e3e6573ee2f54330d0711524da55df779fe" translate="yes" xml:space="preserve">
          <source>Apply rolling updates to a service</source>
          <target state="translated">서비스에 롤링 업데이트 적용</target>
        </trans-unit>
        <trans-unit id="5c9546a054d5ecd2da3df5942086862f98ba4302" translate="yes" xml:space="preserve">
          <source>Apt-cacher-ng has some tools that allow you to manage the repository, and they can be used by leveraging the &lt;code&gt;VOLUME&lt;/code&gt; instruction, and the image we built to run the service:</source>
          <target state="translated">Apt-cacher-ng에는 리포지토리를 관리 할 수있는 몇 가지 도구가 있으며 &lt;code&gt;VOLUME&lt;/code&gt; 명령과 서비스를 실행하기 위해 구축 한 이미지 를 활용하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c267323f1b0f309667223d3410dcd2251913f13" translate="yes" xml:space="preserve">
          <source>Architecture and components</source>
          <target state="translated">아키텍처 및 구성 요소</target>
        </trans-unit>
        <trans-unit id="eef440403a36a79bb12736aaf6606b06422efdcb" translate="yes" xml:space="preserve">
          <source>Archive mode (copy all uid/gid information)</source>
          <target state="translated">보관 모드 (모든 UID / GID 정보 복사)</target>
        </trans-unit>
        <trans-unit id="43b600e157f2474943e7f6f27c6030d7b0bd0a94" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;[]string&lt;/code&gt;</source>
          <target state="translated">Args &lt;code&gt;[]string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="8773c013abac8b197048174879924f462b26f150" translate="yes" xml:space="preserve">
          <source>Arguments passed to the service containers.</source>
          <target state="translated">인수가 서비스 컨테이너로 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b908ef412aa11a98ae652aea6a7a55362c6a496" translate="yes" xml:space="preserve">
          <source>As Docker speeds up your work flow, it gets easier to make lots of small changes instead of huge, big bang updates. Smaller changes mean reduced risk and more uptime.</source>
          <target state="translated">Docker가 작업 흐름을 가속화함에 따라 대규모 빅뱅 업데이트 대신 많은 작은 변경을 쉽게 수행 할 수 있습니다. 작은 변화는 위험 감소와 가동 시간 증가를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4591e973b7a22c8fecc3ec0579d0f2b37f303446" translate="yes" xml:space="preserve">
          <source>As a fallback if no thin pool is provided, loopback files are created. Loopback is very slow, but can be used without any pre-configuration of storage. It is strongly recommended that you do not use loopback in production. Ensure your Engine daemon has a &lt;code&gt;--storage-opt dm.thinpooldev&lt;/code&gt; argument provided.</source>
          <target state="translated">씬 풀이 제공되지 않으면 폴백으로 루프백 파일이 작성됩니다. 루프백은 매우 느리지 만 사전에 스토리지를 구성하지 않고 사용할 수 있습니다. 프로덕션에서는 루프백을 사용하지 않는 것이 좋습니다. 엔진 데몬에 &lt;code&gt;--storage-opt dm.thinpooldev&lt;/code&gt; 인수가 제공 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="471fc53fd9eb5fa77ff180bc76b73ac59656c0a0" translate="yes" xml:space="preserve">
          <source>As a point of interest, the virtual machines you create with &lt;a href=&quot;../../reference/create/index&quot;&gt;&lt;code&gt;docker-machine create&lt;/code&gt;&lt;/a&gt; show up in the Hyper-V Manager under &amp;ldquo;Virtual Machines&amp;rdquo;, but you need to manage them with &lt;a href=&quot;../../reference/index&quot;&gt;&lt;code&gt;docker-machine&lt;/code&gt;&lt;/a&gt; commands and not through the Hyper-V Manager.</source>
          <target state="translated">흥미로운 점으로, &lt;a href=&quot;../../reference/create/index&quot;&gt; &lt;code&gt;docker-machine create&lt;/code&gt; 로&lt;/a&gt; 생성 한 가상 시스템 은 Hyper-V Manager의&amp;ldquo;Virtual Machines&amp;rdquo;에 표시되지만 Hyper-V Manager가 아닌 &lt;a href=&quot;../../reference/index&quot;&gt; &lt;code&gt;docker-machine&lt;/code&gt; &lt;/a&gt; 명령 으로 관리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8cf0819763c86a39b67e84447b8581359714ed" translate="yes" xml:space="preserve">
          <source>As above, but wrapped in &lt;code&gt;/bin/sh&lt;/code&gt;. Both forms below are equivalent.</source>
          <target state="translated">위와 같지만 &lt;code&gt;/bin/sh&lt;/code&gt; 에 싸여 있습니다. 아래의 두 가지 형태는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a8b5a3b43658cfa005c7798222097bae511f3a94" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a thin pool as above, Docker can setup a block device for you.</source>
          <target state="translated">위와 같이 씬 ​​풀을 제공하는 대신 Docker는 블록 장치를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9267dc664967b86ac17c82aa20a4bb3c57a6f7cf" translate="yes" xml:space="preserve">
          <source>As an example, the &lt;code&gt;docker-stack.yml&lt;/code&gt; file for the &lt;a href=&quot;https://github.com/docker/labs/blob/master/beginner/chapters/votingapp/&quot;&gt;votingapp sample in Docker Labs&lt;/a&gt; defines a service called &lt;code&gt;db&lt;/code&gt; that runs a &lt;code&gt;postgres&lt;/code&gt; database. It is configured as a named volume to persist the data on the swarm, &lt;em&gt;and&lt;/em&gt; is constrained to run only on &lt;code&gt;manager&lt;/code&gt; nodes. Here is the relevant snip-it from that file:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://github.com/docker/labs/blob/master/beginner/chapters/votingapp/&quot;&gt;Docker Labs&lt;/a&gt; 의 votingapp 샘플에 대한 &lt;code&gt;docker-stack.yml&lt;/code&gt; 파일 은 &lt;code&gt;postgres&lt;/code&gt; 데이터베이스 를 실행하는 &lt;code&gt;db&lt;/code&gt; 라는 서비스를 정의 합니다. 그것은 떼에 데이터를 유지하기 위해 명명 된 볼륨으로 구성되어 &lt;em&gt;및&lt;/em&gt; 에서만 실행하도록 제한되어 &lt;code&gt;manager&lt;/code&gt; 노드. 해당 파일의 관련 내용은 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9eaef7a3c02aaf7160c5546a47a86412e947089f" translate="yes" xml:space="preserve">
          <source>As changes are made to Docker there may be times when existing features need to be removed or replaced with newer features. Before an existing feature is removed it is labeled as &amp;ldquo;deprecated&amp;rdquo; within the documentation and remains in Docker for at least 3 stable releases unless specified explicitly otherwise. After that time it may be removed.</source>
          <target state="translated">Docker가 변경됨에 따라 기존 기능을 제거하거나 최신 기능으로 교체해야 할 수 있습니다. 기존 기능을 제거하기 전에 문서에서 &quot;더 이상 사용되지 않음&quot;으로 표시되며 명시 적으로 다르게 지정하지 않는 한 최소 3 개의 안정 릴리스에 대해 Docker에 남아 있습니다. 그 후에는 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b970beb65da2ad156f8407447c4b4c83043183d" translate="yes" xml:space="preserve">
          <source>As discussed in the &lt;a href=&quot;../../engine/security/certificates/index#understanding-the-configuration&quot;&gt;Docker Engine documentation&lt;/a&gt; place the certificates in &lt;code&gt;/etc/docker/certs.d/hostname/ca.crt&lt;/code&gt; where &lt;code&gt;hostname&lt;/code&gt; is your Registry server&amp;rsquo;s hostname.</source>
          <target state="translated">&lt;a href=&quot;../../engine/security/certificates/index#understanding-the-configuration&quot;&gt;Docker Engine 문서&lt;/a&gt; 에서 설명한대로 인증서는 &lt;code&gt;/etc/docker/certs.d/hostname/ca.crt&lt;/code&gt; 에 배치하십시오. 여기서 &lt;code&gt;hostname&lt;/code&gt; 은 레지스트리 서버의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bd2d2aebe3b4632713790cd5deaa0897060dc3d7" translate="yes" xml:space="preserve">
          <source>As noted in the output of the &lt;code&gt;docker-machine create&lt;/code&gt; command, you need to tell Docker to talk to the new machine. You can do this with the &lt;code&gt;docker-machine env&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;docker-machine create&lt;/code&gt; 명령 의 출력에서 ​​언급했듯이 Docker에게 새 시스템과 통신하도록 지시해야합니다. &lt;code&gt;docker-machine env&lt;/code&gt; 명령으로 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2165d1e97dec311d460a72ebffb4296c8852044f" translate="yes" xml:space="preserve">
          <source>As of Docker 1.10 User Namespaces are supported directly by the docker daemon. This feature allows for the root user in a container to be mapped to a non uid-0 user outside the container, which can help to mitigate the risks of container breakout. This facility is available but not enabled by default.</source>
          <target state="translated">Docker 1.10부터 사용자 네임 스페이스는 docker 데몬에서 직접 지원됩니다. 이 기능을 사용하면 컨테이너의 루트 사용자가 컨테이너 외부의 uid-0이 아닌 사용자에게 매핑 될 수 있으므로 컨테이너 중단의 위험을 줄일 수 있습니다. 이 기능은 사용 가능하지만 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c4184fc29bf222833895c079535d84c176b9cb3" translate="yes" xml:space="preserve">
          <source>As of v1.4.0 container volumes are initialized during the &lt;code&gt;docker create&lt;/code&gt; phase (i.e., &lt;code&gt;docker run&lt;/code&gt; too). For example, this allows you to &lt;code&gt;create&lt;/code&gt; the &lt;code&gt;data&lt;/code&gt; volume container, and then use it from another container:</source>
          <target state="translated">v1.4.0부터 컨테이너 볼륨은 &lt;code&gt;docker create&lt;/code&gt; 단계 동안 초기화됩니다 (즉, &lt;code&gt;docker run&lt;/code&gt; 도). 예를 들어, 당신은 할 수 있습니다 &lt;code&gt;create&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 볼륨 컨테이너를 한 다음 다른 컨테이너에서 사용 :</target>
        </trans-unit>
        <trans-unit id="967308d75eb5c6e5e626167eb0180003a2741c3e" translate="yes" xml:space="preserve">
          <source>As part of rotating delegation keys, you may need to remove a local delegation key from the local Docker trust store. This is done with the Notary CLI, using the &lt;code&gt;$ notary key remove&lt;/code&gt; command.</source>
          <target state="translated">회전 위임 키의 일부로 로컬 Docker 신뢰 저장소에서 로컬 위임 키를 제거해야 할 수도 있습니다. 이것은 &lt;code&gt;$ notary key remove&lt;/code&gt; 명령을 사용하여 Notary CLI로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a09ac2ecfe4741b8e96a18a5ca2aafd9cbe5222" translate="yes" xml:space="preserve">
          <source>As part of rotating keys for a delegation, you may want to remove an individual key but retain the delegation. This can be done with the Notary CLI.</source>
          <target state="translated">위임을위한 회전 키의 일부로 개별 키를 제거하고 위임은 유지해야 할 수 있습니다. 이는 Notary CLI를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e27ba3b50aa3931d51b76d912ef57dbcdf96177" translate="yes" xml:space="preserve">
          <source>As part of the process of creation, Docker Machine installs Docker and configures it with some sensible defaults. For instance, it allows connection from the outside world over TCP with TLS-based encryption and defaults to AUFS as the &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-storage-driver-option&quot;&gt;storage driver&lt;/a&gt; when available.</source>
          <target state="translated">생성 프로세스의 일부로 Docker Machine은 Docker를 설치하고 적절한 기본값으로 구성합니다. 예를 들어, TLS 기반 암호화를 사용하여 TCP를 통해 외부와의 연결을 허용하고 사용 가능한 경우 기본적으로 &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-storage-driver-option&quot;&gt;스토리지 드라이버&lt;/a&gt; 로 AUFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9072ef965ef41813042f4b4eb4d54e90684728a" translate="yes" xml:space="preserve">
          <source>As part of the swarm management lifecycle, you may need to view or update a node as follows:</source>
          <target state="translated">스웜 관리 수명주기의 일부로 다음과 같이 노드를 보거나 업데이트해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669a4a44c1042437a0759921172f3176de6b74ef" translate="yes" xml:space="preserve">
          <source>As the above example demonstrates, both volumes with &lt;code&gt;is-timelord=yes&lt;/code&gt;, and &lt;code&gt;is-timelord=no&lt;/code&gt; are returned.</source>
          <target state="translated">위의 예에서 알 수 있듯이 &lt;code&gt;is-timelord=yes&lt;/code&gt; 및 &lt;code&gt;is-timelord=no&lt;/code&gt; 인 볼륨이 모두 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b64b183468c18f682e7d2ab60a1148513cf598ce" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;docker container create&lt;/code&gt;, options specified in the Dockerfile, such as &lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;EXPOSE&lt;/code&gt;, &lt;code&gt;VOLUME&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt;, are respected by default - you don&amp;rsquo;t need to specify them again in &lt;code&gt;docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">에서와 같이 &lt;code&gt;docker container create&lt;/code&gt; , 같은 Dockerfile에 지정된 옵션 &lt;code&gt;CMD&lt;/code&gt; , &lt;code&gt;EXPOSE&lt;/code&gt; , &lt;code&gt;VOLUME&lt;/code&gt; , &lt;code&gt;ENV&lt;/code&gt; 를 기본적으로 존중 - 당신이하지에 다시 지정해야합니다 &lt;code&gt;docker-compose.yml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6801af4e67a008519e35debafa6b50dd2dc029" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;docker run&lt;/code&gt;, options specified in the Dockerfile, such as &lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;EXPOSE&lt;/code&gt;, &lt;code&gt;VOLUME&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt;, are respected by default - you don&amp;rsquo;t need to specify them again in &lt;code&gt;docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">에서와 같이 &lt;code&gt;docker run&lt;/code&gt; , 옵션과 같은 Dockerfile에 규정 &lt;code&gt;CMD&lt;/code&gt; , &lt;code&gt;EXPOSE&lt;/code&gt; , &lt;code&gt;VOLUME&lt;/code&gt; , &lt;code&gt;ENV&lt;/code&gt; 기본적으로 존중 - 당신이 다시 지정할 필요가 없습니다 &lt;code&gt;docker-compose.yml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82a81fc4e124a11c81e1f87b2b04a7536925aeb0" translate="yes" xml:space="preserve">
          <source>As you can see, the response to &lt;code&gt;docker swarm init&lt;/code&gt; contains a pre-configured &lt;code&gt;docker swarm join&lt;/code&gt; command for you to run on any nodes you want to add. Copy this command, and send it to &lt;code&gt;myvm2&lt;/code&gt; via &lt;code&gt;docker-machine ssh&lt;/code&gt; to have &lt;code&gt;myvm2&lt;/code&gt; join your new swarm as a worker:</source>
          <target state="translated">보시다시피 &lt;code&gt;docker swarm init&lt;/code&gt; 에 대한 응답 에는 추가하려는 모든 노드에서 실행할 수 있도록 사전 구성된 &lt;code&gt;docker swarm join&lt;/code&gt; 명령이 포함되어 있습니다. 이 명령을 복사하고로 보내 &lt;code&gt;myvm2&lt;/code&gt; 를 통해 &lt;code&gt;docker-machine ssh&lt;/code&gt; 가지고 &lt;code&gt;myvm2&lt;/code&gt; 이 노동자로 새 떼에 가입 :</target>
        </trans-unit>
        <trans-unit id="0ee672a4f70eed1b485ffd6b68b250d17caf1b72" translate="yes" xml:space="preserve">
          <source>Ask your network admin for the proxy&amp;rsquo;s CA certificate and append them to &lt;code&gt;/etc/pki/tls/certs/ca-bundle.crt&lt;/code&gt;</source>
          <target state="translated">네트워크 관리자에게 프록시의 CA 인증서를 요청하여 &lt;code&gt;/etc/pki/tls/certs/ca-bundle.crt&lt;/code&gt; 에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fa245c034339a34459af2137bd3491e71b613486" translate="yes" xml:space="preserve">
          <source>Assign a name to the container</source>
          <target state="translated">컨테이너에 이름 지정</target>
        </trans-unit>
        <trans-unit id="cc92403b2199d18ec56578eadf73950347f9fffb" translate="yes" xml:space="preserve">
          <source>Assign name and allocate pseudo-TTY (--name, -it)</source>
          <target state="translated">이름 할당 및 의사 TTY 할당 (--name, -it)</target>
        </trans-unit>
        <trans-unit id="777f7dd72ce602f15c616c8ad4fcee47e9070919" translate="yes" xml:space="preserve">
          <source>Assuming a path separator of &lt;code&gt;/&lt;/code&gt;, a first argument of &lt;code&gt;SRC_PATH&lt;/code&gt; and second argument of &lt;code&gt;DEST_PATH&lt;/code&gt;, the behavior is as follows:</source>
          <target state="translated">경로의 구분 가정 &lt;code&gt;/&lt;/code&gt; 의 첫번째 인수 &lt;code&gt;SRC_PATH&lt;/code&gt; 그리고 두 번째 인수 &lt;code&gt;DEST_PATH&lt;/code&gt; 은 , 동작은 다음과 같은된다 :</target>
        </trans-unit>
        <trans-unit id="670e09db02cc1d3dcf282f0b21dd507653f3c4e4" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;my_web&lt;/code&gt; service from the previous section still exists, use the following command to update it to publish port 80.</source>
          <target state="translated">이전 섹션 의 &lt;code&gt;my_web&lt;/code&gt; 서비스가 여전히 존재 한다고 가정하면 다음 명령을 사용하여 포트 80을 공개하도록 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8e26981e2584c8ef0009b314afb5138bffa9ddcf" translate="yes" xml:space="preserve">
          <source>Assuming the daemon is running in cgroup &lt;code&gt;daemoncgroup&lt;/code&gt;, &lt;code&gt;--cgroup-parent=/foobar&lt;/code&gt; creates a cgroup in &lt;code&gt;/sys/fs/cgroup/memory/foobar&lt;/code&gt;, whereas using &lt;code&gt;--cgroup-parent=foobar&lt;/code&gt; creates the cgroup in &lt;code&gt;/sys/fs/cgroup/memory/daemoncgroup/foobar&lt;/code&gt;</source>
          <target state="translated">데몬 cgroup에에서 실행되는 가정 &lt;code&gt;daemoncgroup&lt;/code&gt; , &lt;code&gt;--cgroup-parent=/foobar&lt;/code&gt; 만드는 어떤 cgroup &lt;code&gt;/sys/fs/cgroup/memory/foobar&lt;/code&gt; 사용한 반면 &lt;code&gt;--cgroup-parent=foobar&lt;/code&gt; 만드는 어떤 cgroup &lt;code&gt;/sys/fs/cgroup/memory/daemoncgroup/foobar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42346eaf82322535f7e95de7fdac2446b8345d07" translate="yes" xml:space="preserve">
          <source>Assuming there is no Docker image that suits your needs on the &lt;a href=&quot;http://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt;, you can create one yourself.</source>
          <target state="translated">&lt;a href=&quot;http://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; 에 필요한 Docker 이미지가 없다고 가정하면 직접 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b9d7db5913be55db5336bac07a6d24f33067c2" translate="yes" xml:space="preserve">
          <source>Assuming you have the postgresql-client installed, you can use the host-mapped port to test as well. You need to use &lt;code&gt;docker ps&lt;/code&gt; to find out what local host port the container is mapped to first:</source>
          <target state="translated">postgresql-client가 설치되어 있다고 가정하면 호스트 매핑 포트를 사용하여 테스트 할 수도 있습니다. 컨테이너가 먼저 어떤 로컬 호스트 포트에 매핑되었는지 확인 하려면 &lt;code&gt;docker ps&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9796ec9f58f5f751eac400059c05c8d59a6ebf2" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;service create&lt;/code&gt; and &lt;code&gt;service update&lt;/code&gt;</source>
          <target state="translated">비동기 &lt;code&gt;service create&lt;/code&gt; 및 &lt;code&gt;service update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25413161fb7ea824e77ae317ac7b180be51e9b2c" translate="yes" xml:space="preserve">
          <source>At some point later, you can remove this swarm if you want to with &lt;code&gt;docker-machine ssh myvm2 &quot;docker swarm leave&quot;&lt;/code&gt; on the worker and &lt;code&gt;docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;&lt;/code&gt; on the manager, but &lt;em&gt;you need this swarm for part 5, so keep it around for now&lt;/em&gt;.</source>
          <target state="translated">나중에 어떤 시점에서, 당신이 원한다면 당신이 떼를 제거 할 수있는 &lt;code&gt;docker-machine ssh myvm2 &quot;docker swarm leave&quot;&lt;/code&gt; 노동자와에 &lt;code&gt;docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;&lt;/code&gt; 관리자에 있지만, &lt;em&gt;당신이 필요합니다 5 부로 떼어 놓으십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c6c2a7909edf639f44eca1646f06d922823611" translate="yes" xml:space="preserve">
          <source>At the command terminal, run &lt;code&gt;docker-machine ls&lt;/code&gt;.</source>
          <target state="translated">명령 터미널에서 &lt;code&gt;docker-machine ls&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc473132bf2c2b90577ab35571c1c11f9d5f137" translate="yes" xml:space="preserve">
          <source>At the end of the build, a list of all triggers is stored in the image manifest, under the key &lt;code&gt;OnBuild&lt;/code&gt;. They can be inspected with the &lt;code&gt;docker inspect&lt;/code&gt; command.</source>
          <target state="translated">빌드가 끝나면 모든 트리거 목록이 이미지 매니페스트의 &lt;code&gt;OnBuild&lt;/code&gt; 키 아래에 저장됩니다 . &lt;code&gt;docker inspect&lt;/code&gt; 명령 으로 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="841cac2ef6794bc0e32e74155cdbfa0468ba9331" translate="yes" xml:space="preserve">
          <source>At this point in the tutorial, you&amp;rsquo;re finished with the &lt;code&gt;helloworld&lt;/code&gt; service. The next step shows how to &lt;a href=&quot;../delete-service/index&quot;&gt;delete the service&lt;/a&gt;.</source>
          <target state="translated">학습서의이 시점에서 &lt;code&gt;helloworld&lt;/code&gt; 서비스를 완료했습니다 . 다음 단계는 &lt;a href=&quot;../delete-service/index&quot;&gt;서비스&lt;/a&gt; 를 삭제하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c88f1760ba20f0e484f1b62369556459c918e0fb" translate="yes" xml:space="preserve">
          <source>At this point, WordPress should be running on port &lt;code&gt;8000&lt;/code&gt; of your Docker Host, and you can complete the &amp;ldquo;famous five-minute installation&amp;rdquo; as a WordPress administrator.</source>
          <target state="translated">이 시점에서 WordPress는 Docker Host의 포트 &lt;code&gt;8000&lt;/code&gt; 에서 실행 중이어야하며 WordPress 관리자로서&amp;ldquo;유명한 5 분 설치&amp;rdquo;를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466bbf4970747de0265e2a1ffb416f6e93a7e0ae" translate="yes" xml:space="preserve">
          <source>At this point, you could actually revoke the &lt;code&gt;mysql&lt;/code&gt; service&amp;rsquo;s access to the &lt;code&gt;mysql_password&lt;/code&gt; and &lt;code&gt;mysql_root_password&lt;/code&gt; secrets because the passwords have been saved in the MySQL system database. Don&amp;rsquo;t do that for now, because we use them later to facilitate rotating the MySQL password.</source>
          <target state="translated">이 시점 에서 비밀번호가 MySQL 시스템 데이터베이스에 저장 &lt;code&gt;mysql_password&lt;/code&gt; 및 &lt;code&gt;mysql_root_password&lt;/code&gt; 시크릿에 대한 &lt;code&gt;mysql&lt;/code&gt; 서비스의 액세스를 실제로 취소 할 수 있습니다. 우리는 나중에 MySQL 암호를 쉽게 회전시키기 위해 사용하기 때문에 지금은 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9da865620473c94dac019e7ff1cc800d65ad6efb" translate="yes" xml:space="preserve">
          <source>At this point, you could actually revoke the WordPress service&amp;rsquo;s access to the &lt;code&gt;mysql_password&lt;/code&gt; secret, because WordPress has copied the secret to its configuration file &lt;code&gt;wp-config.php&lt;/code&gt;. Don&amp;rsquo;t do that for now, because we use it later to facilitate rotating the MySQL password.</source>
          <target state="translated">이 시점에서 WordPress가 해당 구성 파일 &lt;code&gt;wp-config.php&lt;/code&gt; 에 암호를 복사했기 때문에 &lt;code&gt;mysql_password&lt;/code&gt; 암호에 대한 WordPress 서비스의 액세스를 실제로 취소 할 수 있습니다. 우리는 나중에 MySQL 암호를 쉽게 회전시키기 위해 사용하기 때문에 지금은 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="035e235253c8e640051065f496c39f1fcccde223" translate="yes" xml:space="preserve">
          <source>At this point, you have seen the basics of how Compose works.</source>
          <target state="translated">이 시점에서 Compose 작동 방식의 기본 사항을 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="75353334031949f01ec0db32a9628d9adf644143" translate="yes" xml:space="preserve">
          <source>At this point, your Django app should be running at port &lt;code&gt;8000&lt;/code&gt; on your Docker host. On Docker Desktop for Mac and Docker Desktop for Windows, go to &lt;code&gt;http://localhost:8000&lt;/code&gt; on a web browser to see the Django welcome page. If you are using &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;, then &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; returns the Docker host IP address, to which you can append the port (&lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:8000&lt;/code&gt;).</source>
          <target state="translated">이 시점에서 Django 앱은 Docker 호스트의 포트 &lt;code&gt;8000&lt;/code&gt; 에서 실행 중이어야합니다 . Mac 용 Docker Desktop 및 Windows 용 Docker Desktop 의 Django 시작 페이지를 보려면 웹 브라우저에서 &lt;code&gt;http://localhost:8000&lt;/code&gt; 으로 이동 하십시오. 당신이 사용하는 경우 &lt;a href=&quot;../../machine/overview/index&quot;&gt;도커 기계&lt;/a&gt; , 다음 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 는 포트 (추가 할 수있는 할 수있는 부두 노동자 호스트의 IP 주소를 반환 &lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:8000&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f63e504950eb1b1acfc328da5e8554985ca08728" translate="yes" xml:space="preserve">
          <source>At this point, your app is deployed as a swarm on your cloud provider servers, as evidenced by the &lt;code&gt;docker&lt;/code&gt; commands you just ran. But, you still need to open ports on your cloud servers in order to:</source>
          <target state="translated">이 시점에서 방금 실행 한 &lt;code&gt;docker&lt;/code&gt; 명령에 의해 입증 된 것처럼 앱은 클라우드 공급자 서버에 swarm으로 배포됩니다 . 그러나 다음을 수행하려면 클라우드 서버에서 포트를 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="517cbdd4b3611e72e2518b9e359778328b9e7aac" translate="yes" xml:space="preserve">
          <source>Attach STDOUT/STDERR and forward signals</source>
          <target state="translated">STDOUT / STDERR 및 순방향 신호 연결</target>
        </trans-unit>
        <trans-unit id="d538fb609f029c4016fe7b0f4b1fb52c43604fc8" translate="yes" xml:space="preserve">
          <source>Attach a filesystem mount to the container</source>
          <target state="translated">컨테이너에 파일 시스템 마운트 연결</target>
        </trans-unit>
        <trans-unit id="051ebf6999a299b35d88a4465f630883a1716bef" translate="yes" xml:space="preserve">
          <source>Attach a filesystem mount to the service</source>
          <target state="translated">파일 시스템 마운트를 서비스에 연결</target>
        </trans-unit>
        <trans-unit id="79762a0566b2e2895f27470ba073407659d76f39" translate="yes" xml:space="preserve">
          <source>Attach a service to an existing network (--network)</source>
          <target state="translated">기존 네트워크 (-네트워크)에 서비스 연결</target>
        </trans-unit>
        <trans-unit id="1d2c4577dd39ba3e8ed4a224327417083c771e0b" translate="yes" xml:space="preserve">
          <source>Attach container&amp;rsquo;s STDIN</source>
          <target state="translated">컨테이너의 STDIN 부착</target>
        </trans-unit>
        <trans-unit id="8be04814c1a4344c383a67d6bb5d542687865a9d" translate="yes" xml:space="preserve">
          <source>Attach local standard input, output, and error streams to a running container</source>
          <target state="translated">로컬 표준 입력, 출력 및 오류 스트림을 실행중인 컨테이너에 연결</target>
        </trans-unit>
        <trans-unit id="6a8f3e221f161cb4dd6acc2437de9fa3f45bcd51" translate="yes" xml:space="preserve">
          <source>Attach to STDIN, STDOUT or STDERR</source>
          <target state="translated">STDIN, STDOUT 또는 STDERR에 연결</target>
        </trans-unit>
        <trans-unit id="3629b5c56a3f9db5d4419cfa4b05e7db3fdb787a" translate="yes" xml:space="preserve">
          <source>Attach to STDIN/STDOUT/STDERR (-a)</source>
          <target state="translated">STDIN / STDOUT / STDERR에 연결 (-a)</target>
        </trans-unit>
        <trans-unit id="571f95d02b6dfe94d0bcf2c2b6d8e07656829d47" translate="yes" xml:space="preserve">
          <source>Attach to and detach from a running container</source>
          <target state="translated">실행중인 컨테이너에 연결 및 분리</target>
        </trans-unit>
        <trans-unit id="406a01f02866739d886e37cf9d7d204ba82fa9d9" translate="yes" xml:space="preserve">
          <source>Attempt to remove a running node from a swarm</source>
          <target state="translated">떼에서 실행중인 노드를 제거하려고 시도</target>
        </trans-unit>
        <trans-unit id="4e25e9f8e17a3040c6df39499e942e22b20a3ba7" translate="yes" xml:space="preserve">
          <source>Attempts to call a method on a plugin are retried with an exponential backoff for up to 30 seconds. This may help when packaging plugins as containers, since it gives plugin containers a chance to start up before failing any user containers which depend on them.</source>
          <target state="translated">플러그인에서 메소드 호출 시도는 최대 30 초 동안 지수 백 오프와 함께 재 시도됩니다. 이는 플러그인을 컨테이너로 패키징 할 때 도움이 될 수 있습니다. 플러그인 컨테이너는 플러그인 컨테이너에 의존하는 사용자 컨테이너가 실패하기 전에 시작할 수있는 기회를 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b0b14120d408ec23b343ff336cc2d0bcbcee3695" translate="yes" xml:space="preserve">
          <source>AuFS storage driver</source>
          <target state="translated">AuFS 스토리지 드라이버</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">인증 방법</target>
        </trans-unit>
        <trans-unit id="633af5b7d03f43984d458412d4b0687506d0dddf" translate="yes" xml:space="preserve">
          <source>Author (e.g., &amp;ldquo;John Hannibal Smith &lt;a href=&quot;mailto:hannibal@a-team.com&quot;&gt;hannibal@a-team.com&lt;/a&gt;&amp;rdquo;)</source>
          <target state="translated">저자 (예 :&amp;ldquo;John Hannibal Smith &lt;a href=&quot;mailto:hannibal@a-team.com&quot;&gt;hannibal@a-team.com&lt;/a&gt; &amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="f2cbe4142818faebbcc2dd16c2e6cf35fb9bbc0b" translate="yes" xml:space="preserve">
          <source>Authorization message (will be returned to the client in case the access is denied)</source>
          <target state="translated">승인 메시지 (액세스가 거부 된 경우 클라이언트에게 반환 됨)</target>
        </trans-unit>
        <trans-unit id="0c102a7b5a231a4c802e6b86ee3c89aa7fbfd4a3" translate="yes" xml:space="preserve">
          <source>Authorization plugins</source>
          <target state="translated">인증 플러그인</target>
        </trans-unit>
        <trans-unit id="0fa1bb60a605e276c80af2dd90d4ed2ee026364b" translate="yes" xml:space="preserve">
          <source>Authorization plugins must follow the rules described in &lt;a href=&quot;../plugin_api/index&quot;&gt;Docker Plugin API&lt;/a&gt;. Each plugin must reside within directories described under the &lt;a href=&quot;../plugin_api/index#plugin-discovery&quot;&gt;Plugin discovery&lt;/a&gt; section.</source>
          <target state="translated">인증 플러그인은 &lt;a href=&quot;../plugin_api/index&quot;&gt;Docker Plugin API에&lt;/a&gt; 설명 된 규칙을 따라야합니다 . 각 플러그인은 &lt;a href=&quot;../plugin_api/index#plugin-discovery&quot;&gt;플러그인 발견&lt;/a&gt; 섹션에 설명 된 디렉토리 내에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="07b941c99a46df17f413761e33483dcb5ca931b3" translate="yes" xml:space="preserve">
          <source>Automated testing environments</source>
          <target state="translated">자동화 된 테스트 환경</target>
        </trans-unit>
        <trans-unit id="f35592076716a3337f008360b12fdcf3c14ee5c6" translate="yes" xml:space="preserve">
          <source>Automatic platform ARGs in the global scope</source>
          <target state="translated">글로벌 범위의 자동 플랫폼 ARG</target>
        </trans-unit>
        <trans-unit id="31384ec8fb35fb2f0f21fb8a9836c6405d799ef1" translate="yes" xml:space="preserve">
          <source>Automatic scheduling</source>
          <target state="translated">자동 예약</target>
        </trans-unit>
        <trans-unit id="1e7cac1ade7ecadbd570b880e912577106b6af01" translate="yes" xml:space="preserve">
          <source>Automatically get bugfixes without updating the daemon</source>
          <target state="translated">데몬을 업데이트하지 않고 자동으로 버그 수정</target>
        </trans-unit>
        <trans-unit id="491fdacefd1eadf075f0aec5e7fe4d0bd88f4904" translate="yes" xml:space="preserve">
          <source>Automatically remove the container when it exits</source>
          <target state="translated">컨테이너가 나올 때 자동으로 제거</target>
        </trans-unit>
        <trans-unit id="37a469b76a7478f2f3af5669e763a39ddd0c3d11" translate="yes" xml:space="preserve">
          <source>Automatically roll back if an update fails</source>
          <target state="translated">업데이트가 실패하면 자동 롤백</target>
        </trans-unit>
        <trans-unit id="aa0135aa2d34f1a8e7c13db91691e9068d7a1699" translate="yes" xml:space="preserve">
          <source>Automation with content trust</source>
          <target state="translated">컨텐츠 신뢰를 통한 자동화</target>
        </trans-unit>
        <trans-unit id="e3d72b7ef27caf90356cb9d24c4f5d9728c3b04b" translate="yes" xml:space="preserve">
          <source>Auxiliary IPv4 or IPv6 addresses used by Network driver</source>
          <target state="translated">네트워크 드라이버가 사용하는 보조 IPv4 또는 IPv6 주소</target>
        </trans-unit>
        <trans-unit id="2a0b4e4b6e027ed4af79a5bc5f7f4a9f46ce5243" translate="yes" xml:space="preserve">
          <source>Availability of the node (&amp;ldquo;active&amp;rdquo;|&amp;rdquo;pause&amp;rdquo;|&amp;rdquo;drain&amp;rdquo;)</source>
          <target state="translated">노드의 가용성 ( &quot;active&quot;| &quot;pause&quot;| &quot;drain&quot;)</target>
        </trans-unit>
        <trans-unit id="a9084e42ba6095b6ec22da4e7feb2a3bfa3c163c" translate="yes" xml:space="preserve">
          <source>Available completions</source>
          <target state="translated">사용 가능한 완료</target>
        </trans-unit>
        <trans-unit id="86bb35900ca18777ef44ba1a35c7f169fdc900c2" translate="yes" xml:space="preserve">
          <source>Avoid side-effects with rest of the API (intermediate images and containers)</source>
          <target state="translated">나머지 API (중간 이미지 및 컨테이너)의 부작용 방지</target>
        </trans-unit>
        <trans-unit id="07b80f12df066664ffbe0c1e3a2fab017e30a46f" translate="yes" xml:space="preserve">
          <source>Azure File Storage plugin</source>
          <target state="translated">Azure 파일 저장소 플러그인</target>
        </trans-unit>
        <trans-unit id="8d3e4e3a8194d6b24cb90a30e95fd1a14e287c2d" translate="yes" xml:space="preserve">
          <source>Azure driver only has a single required argument to make things easier. Please read the optional flags to configure machine details and placement further.</source>
          <target state="translated">Azure 드라이버에는 일을 더 쉽게하기 위해 하나의 필수 인수 만 있습니다. 기계 세부 사항 및 배치를 추가로 구성하려면 옵션 플래그를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="e3e07f041360817fa65f93f82cefa93102ac7ab6" translate="yes" xml:space="preserve">
          <source>Azure runs fully on the new &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/resource-group-overview/&quot;&gt;Azure Resource Manager (ARM)&lt;/a&gt; stack. Each machine created comes with a few more Azure resources associated with it:</source>
          <target state="translated">Azure는 새로운 &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/resource-group-overview/&quot;&gt;ARM (Azure Resource Manager)&lt;/a&gt; 스택 에서 완전히 실행됩니다 . 생성 된 각 컴퓨터에는 이와 관련된 몇 가지 Azure 리소스가 추가로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8018ddbe65840ddd912362708b0d15bfc714c1e9" translate="yes" xml:space="preserve">
          <source>BLOCK_SUSPEND</source>
          <target state="translated">BLOCK_SUSPEND</target>
        </trans-unit>
        <trans-unit id="0bff4c3c1174dae266e6759ed85f59b47d42938e" translate="yes" xml:space="preserve">
          <source>Back up the entire &lt;code&gt;/var/lib/docker/swarm&lt;/code&gt; directory.</source>
          <target state="translated">전체 &lt;code&gt;/var/lib/docker/swarm&lt;/code&gt; 디렉토리를 백업하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ba776a4fa011285adee0259fa100e8b8e5ff6b8" translate="yes" xml:space="preserve">
          <source>Back up the swarm</source>
          <target state="translated">떼를 백업</target>
        </trans-unit>
        <trans-unit id="0fd9e3c240a05e380707b557ce6fc246889f41cc" translate="yes" xml:space="preserve">
          <source>Back up your keys</source>
          <target state="translated">키 백업</target>
        </trans-unit>
        <trans-unit id="96f9374c6ba59bee4b72a8fa25eb74d5db655efa" translate="yes" xml:space="preserve">
          <source>Backing filesystem without &lt;code&gt;d_type&lt;/code&gt; support for overlay/overlay2</source>
          <target state="translated">오버레이 / 오버레이 2를위한 &lt;code&gt;d_type&lt;/code&gt; 지원 없는 백업 파일 시스템</target>
        </trans-unit>
        <trans-unit id="f620cacbc465c805c4e1c25e20fa57e55c09e33e" translate="yes" xml:space="preserve">
          <source>Bash</source>
          <target state="translated">Bash</target>
        </trans-unit>
        <trans-unit id="1857d34a1feb09a3b06c4dee942314c77cab82ee" translate="yes" xml:space="preserve">
          <source>Basic architecture</source>
          <target state="translated">기본 아키텍처</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="c59bab2761efa2dc78ea4cbc3be5405c02bb44ec" translate="yes" xml:space="preserve">
          <source>Basic principles</source>
          <target state="translated">기본 원리들</target>
        </trans-unit>
        <trans-unit id="5a87caed0816a0626535af710e494dd9f3417692" translate="yes" xml:space="preserve">
          <source>Be aware that the default (&amp;ldquo;local&amp;rdquo;) volume is a locally scoped volume driver. This means that depending on where a task is deployed, either that task gets a &lt;em&gt;new&lt;/em&gt; volume named &amp;ldquo;my-volume&amp;rdquo;, or shares the same &amp;ldquo;my-volume&amp;rdquo; with other tasks of the same service. Multiple containers writing to a single shared volume can cause data corruption if the software running inside the container is not designed to handle concurrent processes writing to the same location. Also take into account that containers can be re-scheduled by the Swarm orchestrator and be deployed on a different node.</source>
          <target state="translated">기본 ( &quot;로컬&quot;) 볼륨은 로컬 범위 볼륨 드라이버입니다. 이는 작업이 배포되는 위치에 따라 해당 작업이 &amp;ldquo;my-volume&amp;rdquo;이라는 &lt;em&gt;새&lt;/em&gt; 볼륨을 받거나 동일한&amp;ldquo;my-volume&amp;rdquo;을 동일한 서비스의 다른 작업과 공유 함을 의미합니다. 컨테이너 내에서 실행중인 소프트웨어가 동일한 위치에 쓰는 동시 프로세스를 처리하도록 설계되지 않은 경우 단일 공유 볼륨에 여러 컨테이너를 쓰면 데이터가 손상 될 수 있습니다. 또한 Swarm 오케 스트레이터가 컨테이너를 다시 예약하고 다른 노드에 배포 할 수 있음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f36881d7163356441158bc55057de96ecb3fc737" translate="yes" xml:space="preserve">
          <source>Be careful setting &lt;code&gt;nproc&lt;/code&gt; with the &lt;code&gt;ulimit&lt;/code&gt; flag as &lt;code&gt;nproc&lt;/code&gt; is designed by Linux to set the maximum number of processes available to a user, not to a container. For details please check the &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; reference.</source>
          <target state="translated">&lt;code&gt;nproc&lt;/code&gt; 은 컨테이너가 아닌 사용자가 사용할 수있는 최대 프로세스 수를 설정하기 위해 Linux에서 설계되었으므로 &lt;code&gt;ulimit&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;nproc&lt;/code&gt; 을 신중하게 설정하십시오 . 자세한 내용은 &lt;a href=&quot;../run/index&quot;&gt;런&lt;/a&gt; 레퍼런스 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="79464c5f3d9887fd51f2eb746309039850d32655" translate="yes" xml:space="preserve">
          <source>Be careful setting &lt;code&gt;nproc&lt;/code&gt; with the &lt;code&gt;ulimit&lt;/code&gt; flag as &lt;code&gt;nproc&lt;/code&gt; is designed by Linux to set the maximum number of processes available to a user, not to a container. For example, start four containers with &lt;code&gt;daemon&lt;/code&gt; user:</source>
          <target state="translated">&lt;code&gt;nproc&lt;/code&gt; 은 컨테이너가 아닌 사용자가 사용할 수있는 최대 프로세스 수를 설정하기 위해 Linux에서 설계되었으므로 &lt;code&gt;ulimit&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;nproc&lt;/code&gt; 을 신중하게 설정하십시오 . 예를 들어, &lt;code&gt;daemon&lt;/code&gt; 사용자로 4 개의 컨테이너를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="78cb01694eb84e59bf48e8663a15da127c157a87" translate="yes" xml:space="preserve">
          <source>Be careful with the join tokens because they are the secrets necessary to join the swarm. In particular, checking a secret into version control is a bad practice because it would allow anyone with access to the application source code to add new nodes to the swarm. Manager tokens are especially sensitive because they allow a new manager node to join and gain control over the whole swarm.</source>
          <target state="translated">결합 토큰은 떼에 참여하는 데 필요한 비밀이므로주의하십시오. 특히 버전 제어에 대한 비밀을 확인하는 것은 응용 프로그램 소스 코드에 액세스 할 수있는 모든 사람이 새 노드를 웜에 추가 할 수있게하므로 나쁜 습관입니다. 관리자 토큰은 새로운 관리자 노드가 참여하여 전체 떼를 제어 할 수 있기 때문에 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="222e2aecb158d6199c5e0bcd6bfae1aab9b3e036" translate="yes" xml:space="preserve">
          <source>Be sure that your subnetworks do not overlap. If they do, the network create fails and Engine returns an error.</source>
          <target state="translated">서브 네트워크가 겹치지 않도록하십시오. 그렇게하면 네트워크 생성이 실패하고 엔진이 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="156747e8988957e8d9ac569a741c5996159f4d13" translate="yes" xml:space="preserve">
          <source>Be sure to protect and back up your &lt;a href=&quot;../trust_key_mng/index&quot;&gt;Notary Canonical Root Key&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../trust_key_mng/index&quot;&gt;공증인 정식 루트 키&lt;/a&gt; 를 보호하고 백업하십시오</target>
        </trans-unit>
        <trans-unit id="4d7fe79d356c9a9feda900cb5a0d461f33e90758" translate="yes" xml:space="preserve">
          <source>Be sure your image works as a deployed container. Run this command, slotting in your info for &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;: &lt;code&gt;docker run -p 4000:80 username/repo:tag&lt;/code&gt;, then visit &lt;code&gt;http://localhost:4000/&lt;/code&gt;.</source>
          <target state="translated">이미지가 배포 된 컨테이너로 작동하는지 확인하십시오. &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;repo&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; : &lt;code&gt;docker run -p 4000:80 username/repo:tag&lt;/code&gt; 에 대한 정보를 슬롯에 넣은 다음 이 명령을 실행 한 다음 &lt;code&gt;http://localhost:4000/&lt;/code&gt; 을 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="93e123ca279979750a2bb0480d457ff8815a0847" translate="yes" xml:space="preserve">
          <source>Be sure your image works as a deployed container. Run this command, slotting in your info for &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;: &lt;code&gt;docker run -p 80:80 username/repo:tag&lt;/code&gt;, then visit &lt;code&gt;http://localhost/&lt;/code&gt;.</source>
          <target state="translated">이미지가 배포 된 컨테이너로 작동하는지 확인하십시오. 이 명령을 실행하여 정보에 &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;repo&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; : &lt;code&gt;docker run -p 80:80 username/repo:tag&lt;/code&gt; 에 넣은 다음 &lt;code&gt;http://localhost/&lt;/code&gt; 를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffa295b40fed04c222db11d5019c93ec3040badf" translate="yes" xml:space="preserve">
          <source>Because Docker container names must be unique, you cannot scale a service beyond 1 container if you have specified a custom name. Attempting to do so results in an error.</source>
          <target state="translated">Docker 컨테이너 이름은 고유해야하므로 사용자 정의 이름을 지정한 경우 1 컨테이너 이상으로 서비스를 확장 할 수 없습니다. 이렇게하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ce225fe69a7943af3544b6633e893c0b7f80bed" translate="yes" xml:space="preserve">
          <source>Because Docker is developed using Go, you can also use any environment variables used by the Go runtime. In particular, you may find these useful:</source>
          <target state="translated">Docker는 Go를 사용하여 개발되었으므로 Go 런타임에서 사용하는 모든 환경 변수를 사용할 수도 있습니다. 특히 다음과 같은 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e3e42e2d33f1b9451f9fa7b48ac0c82df1cf00" translate="yes" xml:space="preserve">
          <source>Because other nodes contact the manager node on its IP address, you should use a fixed IP address.</source>
          <target state="translated">다른 노드는 해당 IP 주소에서 관리자 노드에 접속하므로 고정 IP 주소를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6d518d520d3523b4957048bfc5fb5c61f55cc02" translate="yes" xml:space="preserve">
          <source>Because the application code is now mounted into the container using a volume, you can make changes to its code and see the changes instantly, without having to rebuild the image.</source>
          <target state="translated">이제 응용 프로그램 코드가 볼륨을 사용하여 컨테이너에 마운트되었으므로 이미지를 다시 작성하지 않고도 코드를 변경하고 즉시 변경 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d80ea50c004a24893d67f2649e41a7334c4f96d" translate="yes" xml:space="preserve">
          <source>Because the root CA key should be kept secret, if provided it will not be visible when viewing swarm any information via the CLI or API.</source>
          <target state="translated">루트 CA 키는 비밀로 유지해야하므로 제공된 경우 CLI 또는 API를 통해 정보를 볼 때 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="814153290bb22a4a371d3551c6bb051d2e7e611c" translate="yes" xml:space="preserve">
          <source>Because the scale is set to &lt;code&gt;1&lt;/code&gt;, only a single MySQL task runs. Load-balancing MySQL is left as an exercise to the reader and involves more than just scaling the service.</source>
          <target state="translated">스케일이 &lt;code&gt;1&lt;/code&gt; 로 설정되어 있으므로 단일 MySQL 태스크 만 실행됩니다. 로드 밸런싱 MySQL은 독자에게 연습으로 남겨져 있으며 단순히 서비스를 확장하는 것 이상을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2ec6e2c684acefbb76d32ba2d5b2bc8cf428ac84" translate="yes" xml:space="preserve">
          <source>Because the scale is set to &lt;code&gt;1&lt;/code&gt;, only a single WordPress task runs. Load-balancing WordPress is left as an exercise to the reader, because of limitations with storing WordPress session data on the container filesystem.</source>
          <target state="translated">배율이 &lt;code&gt;1&lt;/code&gt; 로 설정되어 있으므로 단일 WordPress 작업 만 실행됩니다. 컨테이너 파일 시스템에 WordPress 세션 데이터를 저장하는 데 한계가 있기 때문에로드 밸런싱 WordPress는 독자에게 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8c4dd9f2133b33e7dc3430a96db83318a3b0a7" translate="yes" xml:space="preserve">
          <source>Because you are pushing this repository for the first time, Docker creates new root and repository keys and asks you for passphrases with which to encrypt them. If you push again after this, it only asks you for repository passphrase so it can decrypt the key and sign again.</source>
          <target state="translated">이 저장소를 처음으로 푸시하기 때문에 Docker는 새 루트 및 저장소 키를 작성하고이를 암호화 할 비밀번호 문구를 묻습니다. 이 후 다시 푸시하면 저장소 비밀번호 문구 만 요청하므로 키를 해독하고 다시 서명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f60e702a7e0b4c50fd4861be586650c21dda20c" translate="yes" xml:space="preserve">
          <source>BeeGFS Volume Plugin</source>
          <target state="translated">BeeGFS 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="85e2a1868c183b811014b6939c88593bbfbe642a" translate="yes" xml:space="preserve">
          <source>Before Swarm updates all of the tasks, you can see that some are running &lt;code&gt;redis:3.0.6&lt;/code&gt; while others are running &lt;code&gt;redis:3.0.7&lt;/code&gt;. The output above shows the state once the rolling updates are done.</source>
          <target state="translated">Swarm이 모든 작업을 업데이트하기 전에 일부는 &lt;code&gt;redis:3.0.6&lt;/code&gt; 을 실행하고 다른 일부는 &lt;code&gt;redis:3.0.7&lt;/code&gt; 을 실행하고 있음을 알 수 있습니다 . 위의 결과는 롤링 업데이트가 완료된 상태를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f7e86a67ed3ee513dc50e14fc76123ec8b073e12" translate="yes" xml:space="preserve">
          <source>Before adding and signing content to a collection, you must first initialize that collection.</source>
          <target state="translated">컬렉션에 내용을 추가하고 서명하기 전에 먼저 해당 컬렉션을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9019b27688c9db747d028e464b8880117bfaca79" translate="yes" xml:space="preserve">
          <source>Before adding any delegations, you should rotate the snapshot key to the server. This is done by default for new collections created with a Docker Engine 1.11 client. Delegation roles do not require the snapshot key to publish their own targets to the collection, since the server can publish the valid snapshot with the delegation targets:</source>
          <target state="translated">위임을 추가하기 전에 스냅 샷 키를 서버로 회전시켜야합니다. Docker Engine 1.11 클라이언트로 만든 새 컬렉션의 경우 기본적으로 수행됩니다. 서버가 위임 대상으로 유효한 스냅 샷을 게시 할 수 있으므로 위임 역할에는 자체 대상을 컬렉션에 게시하기 위해 스냅 샷 키가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e74692a2472050459c70415985e1818139630b72" translate="yes" xml:space="preserve">
          <source>Before proceeding, save &lt;code&gt;daemon.json&lt;/code&gt; and restart the docker service.</source>
          <target state="translated">계속하기 전에 &lt;code&gt;daemon.json&lt;/code&gt; 을 저장 하고 docker 서비스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="dec757707c02b04634b882a15a1f549100aa9caa" translate="yes" xml:space="preserve">
          <source>Before the Docker daemon runs the instructions in the &lt;code&gt;Dockerfile&lt;/code&gt;, it performs a preliminary validation of the &lt;code&gt;Dockerfile&lt;/code&gt; and returns an error if the syntax is incorrect:</source>
          <target state="translated">도커 데몬의 지시를 실행하기 전에 &lt;code&gt;Dockerfile&lt;/code&gt; 를 , 그것의 예비 유효성 검사를 수행 &lt;code&gt;Dockerfile&lt;/code&gt; 을 하고 구문이 잘못된 경우 오류를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="c3b6146fec5b4809485f5053a8d6998f3414df12" translate="yes" xml:space="preserve">
          <source>Before the docker CLI sends the context to the docker daemon, it looks for a file named &lt;code&gt;.dockerignore&lt;/code&gt; in the root directory of the context. If this file exists, the CLI modifies the context to exclude files and directories that match patterns in it. This helps to avoid unnecessarily sending large or sensitive files and directories to the daemon and potentially adding them to images using &lt;code&gt;ADD&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt;.</source>
          <target state="translated">docker CLI가 컨텍스트를 docker 데몬으로 보내기 전에 컨텍스트 의 루트 디렉토리에서 &lt;code&gt;.dockerignore&lt;/code&gt; 라는 파일을 찾습니다 . 이 파일이 존재하면 CLI는 패턴과 일치하는 파일 및 디렉토리를 제외하도록 컨텍스트를 수정합니다. 이는 크고 민감한 파일과 디렉토리를 불필요하게 데몬에 보내고 &lt;code&gt;ADD&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 이미지에 추가하는 것을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="5001fb71c3dd2aec2b986094dd041a9fac1504dd" translate="yes" xml:space="preserve">
          <source>Before using the amazonec2 driver, ensure that you&amp;rsquo;ve configured credentials.</source>
          <target state="translated">amazonec2 드라이버를 사용하기 전에 자격 증명을 구성했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3deed14d16c3d531a248c96f08919702444bf4d6" translate="yes" xml:space="preserve">
          <source>Before we can use the &lt;code&gt;docker stack deploy&lt;/code&gt; command we first run:</source>
          <target state="translated">&lt;code&gt;docker stack deploy&lt;/code&gt; 명령을 사용하려면 먼저 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c5181436edebb92e4c4b8d74d98fea26ea07ac" translate="yes" xml:space="preserve">
          <source>Before working through this sandbox, you should have read through the &lt;a href=&quot;../content_trust/index&quot;&gt;trust overview&lt;/a&gt;.</source>
          <target state="translated">이 샌드 박스를 통해 작업하기 전에 &lt;a href=&quot;../content_trust/index&quot;&gt;신뢰 개요를&lt;/a&gt; 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3a37c25ac665de849aa25ffb465e93154bd5c960" translate="yes" xml:space="preserve">
          <source>Before you add nodes to a swarm you must install Docker Engine 1.12 or later on the host machine.</source>
          <target state="translated">스웜에 노드를 추가하기 전에 호스트 시스템에 Docker Engine 1.12 이상을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c755942c42dc5f4431be470115098f0ad83f5a" translate="yes" xml:space="preserve">
          <source>Before you can run a &lt;code&gt;docker&lt;/code&gt; command on a machine, you need to configure your command-line to point to that machine. The &lt;code&gt;docker-machine env &amp;lt;machine-name&amp;gt;&lt;/code&gt; subcommand outputs the configuration command you should use.</source>
          <target state="translated">머신에서 &lt;code&gt;docker&lt;/code&gt; 명령을 실행하기 전에 해당 머신을 가리 키도록 명령 행을 구성해야합니다. &lt;code&gt;docker-machine env &amp;lt;machine-name&amp;gt;&lt;/code&gt; 하위 명령 출력을 사용한다 구성 명령.</target>
        </trans-unit>
        <trans-unit id="640a409348d93d5cfecda4f1c15e9e5e18c7e72a" translate="yes" xml:space="preserve">
          <source>Before you forcefully remove a manager node, you must first demote it to the worker role. Make sure that you always have an odd number of manager nodes if you demote or remove a manager.</source>
          <target state="translated">관리자 노드를 강제로 제거하기 전에 먼저 관리자 노드를 작업자 역할로 강등시켜야합니다. 관리자를 강등 시키거나 제거 할 경우 항상 홀수의 관리자 노드가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="37c44b359a731da49b87b3539be92c0c3df6650e" translate="yes" xml:space="preserve">
          <source>Below you can see some examples of Dockerfile syntax. If you&amp;rsquo;re interested in something more realistic, take a look at the list of &lt;a href=&quot;../../examples/index&quot;&gt;Dockerization examples&lt;/a&gt;.</source>
          <target state="translated">아래는 Dockerfile 구문의 몇 가지 예를 보여줍니다. 보다 현실적인 것에 관심이 있다면 &lt;a href=&quot;../../examples/index&quot;&gt;Dockerization 예제&lt;/a&gt; 목록을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="37ecf0235bf307aa647573300d38475e6bb9f56c" translate="yes" xml:space="preserve">
          <source>Between versions 2.x and 3.x, the structure of the Compose file is the same, but several options have been removed:</source>
          <target state="translated">버전 2.x와 3.x 사이에서 작성 파일의 구조는 동일하지만 몇 가지 옵션이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b754e8300524961ad0cf3f4ffe3a393d7c09143" translate="yes" xml:space="preserve">
          <source>Beyond Go&amp;rsquo;s filepath.Match rules, Docker also supports a special wildcard string &lt;code&gt;**&lt;/code&gt; that matches any number of directories (including zero). For example, &lt;code&gt;**/*.go&lt;/code&gt; will exclude all files that end with &lt;code&gt;.go&lt;/code&gt; that are found in all directories, including the root of the build context.</source>
          <target state="translated">Docker는 Go의 filepath.Match 규칙 외에도 여러 디렉토리 (0 포함)와 일치 하는 특수 와일드 카드 문자열 &lt;code&gt;**&lt;/code&gt; 을 지원합니다 . 예를 들어, &lt;code&gt;**/*.go&lt;/code&gt; &lt;code&gt;.go&lt;/code&gt; 는 빌드 컨텍스트의 루트를 포함하여 모든 디렉토리에 있는 .go로 끝나는 모든 파일을 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="81fdf6d22f1a31838d87ca37ed63afe7583834f6" translate="yes" xml:space="preserve">
          <source>Bind Docker to another host/port or a Unix socket</source>
          <target state="translated">Docker를 다른 호스트 / 포트 또는 Unix 소켓에 바인딩</target>
        </trans-unit>
        <trans-unit id="b2e30420df1491aaa6f7e3a565f1af052a0673e5" translate="yes" xml:space="preserve">
          <source>Bind a socket to internet domain privileged ports (port numbers less than 1024).</source>
          <target state="translated">인터넷 도메인의 특권 포트에 소켓을 바인드하십시오 (포트 번호가 1024 미만).</target>
        </trans-unit>
        <trans-unit id="733465e616bdff45480c7770c15b40a1efe97692" translate="yes" xml:space="preserve">
          <source>Bind mount a volume</source>
          <target state="translated">볼륨 바인드 마운트</target>
        </trans-unit>
        <trans-unit id="b9222b0dafcaed74e20e56faf0b7aef2c786ccba" translate="yes" xml:space="preserve">
          <source>Bind mounts</source>
          <target state="translated">바인드 마운트</target>
        </trans-unit>
        <trans-unit id="2dbe7658de4156d1bf7478cc34259863bb592dcf" translate="yes" xml:space="preserve">
          <source>Bind mounts are file system paths from the host where the scheduler deploys the container for the task. Docker mounts the path into the container. The file system path must exist before the swarm initializes the container for the task.</source>
          <target state="translated">바인드 마운트는 스케줄러가 태스크의 컨테이너를 배치하는 호스트의 파일 시스템 경로입니다. Docker는 경로를 컨테이너에 마운트합니다. 웜이 작업의 컨테이너를 초기화하기 전에 파일 시스템 경로가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="6be44b8c85488bc1a7ffb691d71d9fb385efa25e" translate="yes" xml:space="preserve">
          <source>Bind propagation</source>
          <target state="translated">바인드 전파</target>
        </trans-unit>
        <trans-unit id="8dfb242da1591a34f5afa4b66b3db138072a49d4" translate="yes" xml:space="preserve">
          <source>Bind propagation refers to whether or not mounts created within a given bind mount or named volume can be propagated to replicas of that mount. Consider a mount point &lt;code&gt;/mnt&lt;/code&gt;, which is also mounted on &lt;code&gt;/tmp&lt;/code&gt;. The propation settings control whether a mount on &lt;code&gt;/tmp/a&lt;/code&gt; would also be available on &lt;code&gt;/mnt/a&lt;/code&gt;. Each propagation setting has a recursive counterpoint. In the case of recursion, consider that &lt;code&gt;/tmp/a&lt;/code&gt; is also mounted as &lt;code&gt;/foo&lt;/code&gt;. The propagation settings control whether &lt;code&gt;/mnt/a&lt;/code&gt; and/or &lt;code&gt;/tmp/a&lt;/code&gt; would exist.</source>
          <target state="translated">바인드 전파는 지정된 바인드 마운트 또는 이름 지정된 볼륨에서 작성된 마운트를 해당 마운트의 복제본으로 전파 할 수 있는지 여부를 나타냅니다. &lt;code&gt;/tmp&lt;/code&gt; 에 마운트 된 &lt;code&gt;/mnt&lt;/code&gt; 마운트 지점을 고려하십시오 . propations 설정은 &lt;code&gt;/tmp/a&lt;/code&gt; 에서 마운트 를 &lt;code&gt;/mnt/a&lt;/code&gt; 에서 사용할 수 있는지 여부를 제어합니다 . 각 전파 설정에는 재귀 카운터 포인트가 있습니다. 재귀의 경우 &lt;code&gt;/tmp/a&lt;/code&gt; 도 &lt;code&gt;/foo&lt;/code&gt; 로 마운트 된다는 것을 고려하십시오 . 전파 설정은 &lt;code&gt;/mnt/a&lt;/code&gt; 및 / 또는 &lt;code&gt;/tmp/a&lt;/code&gt; 가 존재 하는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="5ea38595ab6e7289b536d5ae4154d3b299dd9d75" translate="yes" xml:space="preserve">
          <source>Binding to different ports on the host</source>
          <target state="translated">호스트의 다른 포트에 바인딩</target>
        </trans-unit>
        <trans-unit id="64408ceb963642882d6810c0793036deb5348328" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored.</source>
          <target state="translated">빈 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="65ef929d8560c40978e81e85004b7a1834b928e1" translate="yes" xml:space="preserve">
          <source>Block IO</source>
          <target state="translated">IO 차단</target>
        </trans-unit>
        <trans-unit id="f5a09f70abed637435b8b0024affa1028a6f38a1" translate="yes" xml:space="preserve">
          <source>Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</source>
          <target state="translated">10에서 1000 사이의 IO 차단 (상대 가중치) 또는 비활성화하려면 0 (기본값 0)</target>
        </trans-unit>
        <trans-unit id="9f7c10250b5fbee2d53395218862c7204dc1c773" translate="yes" xml:space="preserve">
          <source>Block IO bandwidth (Blkio) constraint</source>
          <target state="translated">IO 대역폭 차단 (Blkio) 제약</target>
        </trans-unit>
        <trans-unit id="6d7fa128bd83cb4b5abedb7a9ef964e5c5734537" translate="yes" xml:space="preserve">
          <source>Block IO weight (relative device weight)</source>
          <target state="translated">IO 무게 차단 (상대 장치 무게)</target>
        </trans-unit>
        <trans-unit id="8a10e2a5541fd1bf1e8d16ebe537701dfa1da8ff" translate="yes" xml:space="preserve">
          <source>Block IO weight (relative device weight, format: &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt;)</source>
          <target state="translated">IO 가중치 차단 (상대 장치 무게, 형식 : &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="79e1d0c0d0874da5fa4cab2e6643c71aaf583c6b" translate="yes" xml:space="preserve">
          <source>Block IO weight (relative weight) accepts a weight value between 10 and 1000.</source>
          <target state="translated">블록 IO 가중치 (상대 가중치)는 10에서 1000 사이의 가중치를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d68b1421498a4419ae2acd5715f5a7b4c6d3e54c" translate="yes" xml:space="preserve">
          <source>Block until one or more containers stop, then print their exit codes</source>
          <target state="translated">하나 이상의 컨테이너가 멈출 때까지 차단 한 다음 종료 코드를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="27f5e52caf63e4b4dc5a483f3f867ec5bdf63f8b" translate="yes" xml:space="preserve">
          <source>Blockbridge plugin</source>
          <target state="translated">블록 브리지 플러그인</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="5c973a943534903f2792924248da88a8a26e1441" translate="yes" xml:space="preserve">
          <source>Boolean options take the form &lt;code&gt;-d=false&lt;/code&gt;. The value you see in the help text is the default value which is set if you do &lt;strong&gt;not&lt;/strong&gt; specify that flag. If you specify a Boolean flag without a value, this will set the flag to &lt;code&gt;true&lt;/code&gt;, irrespective of the default value.</source>
          <target state="translated">부울 옵션은 &lt;code&gt;-d=false&lt;/code&gt; 형식 입니다. 도움말 텍스트에 표시되는 값은 해당 플래그를 지정 하지 &lt;strong&gt;않은&lt;/strong&gt; 경우 설정되는 기본값 입니다. 값없이 부울 플래그를 지정 하면 기본값에 관계없이 플래그가 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="86ac3178f11e98ce613e6f67e61f7e91647edf9a" translate="yes" xml:space="preserve">
          <source>Boolean value determining whether to use trust on first use when bootstrapping validation on a collection's root file. This keeps TOFUs on by default.</source>
          <target state="translated">컬렉션의 루트 파일에서 유효성 검사를 부트 스트랩 할 때 처음 사용할 때 신뢰를 사용할지 여부를 결정하는 부울 값입니다. 이렇게하면 기본적으로 TOFU가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="03ca34c6087a14641fe493440e099eeafbe1462e" translate="yes" xml:space="preserve">
          <source>Boolean value indicating whether the request is allowed or denied</source>
          <target state="translated">요청의 허용 여부를 나타내는 부울 값</target>
        </trans-unit>
        <trans-unit id="60e8d7a4e285981a0252b091446a66e30a57ff33" translate="yes" xml:space="preserve">
          <source>Boolean value indicating whether the response is allowed or denied</source>
          <target state="translated">응답의 허용 여부를 나타내는 부울 값</target>
        </trans-unit>
        <trans-unit id="6c431494ad7df0a5f863c75f3f026c51063b84a0" translate="yes" xml:space="preserve">
          <source>Boot2Docker</source>
          <target state="translated">Boot2Docker</target>
        </trans-unit>
        <trans-unit id="932019e70977d30de4a650dc4d7cffb43e523774" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;$VARIABLE&lt;/code&gt; and &lt;code&gt;${VARIABLE}&lt;/code&gt; syntax are supported. Additionally when using the &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;2.1 file format&lt;/a&gt;, it is possible to provide inline default values using typical shell syntax:</source>
          <target state="translated">모두 &lt;code&gt;$VARIABLE&lt;/code&gt; 및 &lt;code&gt;${VARIABLE}&lt;/code&gt; 구문이 지원됩니다. 또한 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;2.1 파일 형식을&lt;/a&gt; 사용하는 경우 일반적인 쉘 구문을 사용하여 인라인 기본값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f7c05150c713e7d20c3803cd4be837e99b1d56" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;$VARIABLE&lt;/code&gt; and &lt;code&gt;${VARIABLE}&lt;/code&gt; syntax are supported. Additionally when using the &lt;a href=&quot;compose-versioning/index#version-21&quot;&gt;2.1 file format&lt;/a&gt;, it is possible to provide inline default values using typical shell syntax:</source>
          <target state="translated">모두 &lt;code&gt;$VARIABLE&lt;/code&gt; 및 &lt;code&gt;${VARIABLE}&lt;/code&gt; 구문이 지원됩니다. 또한 &lt;a href=&quot;compose-versioning/index#version-21&quot;&gt;2.1 파일 형식을&lt;/a&gt; 사용하는 경우 일반적인 쉘 구문을 사용하여 인라인 기본값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0e4faa0e61b2b334d8863392d0acd576833206" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt; instructions define what command gets executed when running a container. There are few rules that describe their co-operation.</source>
          <target state="translated">두 &lt;code&gt;CMD&lt;/code&gt; 및 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 지시는 컨테이너를 실행할 때 명령이 실행됩니다 정의합니다. 그들의 협력을 설명하는 규칙은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4239a8f6e4870edc8d660512129266988a1950b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;docker service inspect redis&lt;/code&gt;, and &lt;code&gt;docker service inspect dmu1ept4cxcf&lt;/code&gt; produce the same result:</source>
          <target state="translated">두 &lt;code&gt;docker service inspect redis&lt;/code&gt; 하고, &lt;code&gt;docker service inspect dmu1ept4cxcf&lt;/code&gt; 와 동일한 결과를 생성 :</target>
        </trans-unit>
        <trans-unit id="b2c916ef64fdda8468c6c452cce1cd97bee5262e" translate="yes" xml:space="preserve">
          <source>Both engine labels and node labels are supported by placement preferences. The example above uses a node label, because the label is referenced with &lt;code&gt;node.labels.datacenter&lt;/code&gt;. To spread over the values of an engine label, use &lt;code&gt;--placement-pref spread=engine.labels.&amp;lt;labelname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">엔진 레이블과 노드 레이블은 모두 배치 환경 설정에서 지원됩니다. 위의 예제는 레이블이 &lt;code&gt;node.labels.datacenter&lt;/code&gt; 로 참조되므로 노드 레이블을 사용합니다 . 엔진 레이블 값을 분산 시키려면 &lt;code&gt;--placement-pref spread=engine.labels.&amp;lt;labelname&amp;gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="05f8f2bddeddb144e88c407c396bbb9384f500de" translate="yes" xml:space="preserve">
          <source>Both flags support the value &lt;code&gt;ALL&lt;/code&gt;, so if the operator wants to have all capabilities but &lt;code&gt;MKNOD&lt;/code&gt; they could use:</source>
          <target state="translated">두 플래그 모두 &lt;code&gt;ALL&lt;/code&gt; 값을 지원 하므로 운영자가 &lt;code&gt;MKNOD&lt;/code&gt; 이외의 모든 기능을 원할 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7f6dcaebd1e8f4dca119957228a419a42fd2a9" translate="yes" xml:space="preserve">
          <source>Both flags take limits in the &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;limit&amp;gt;&lt;/code&gt; format. Both read and write rates must be a positive integer.</source>
          <target state="translated">두 플래그 모두 &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;limit&amp;gt;&lt;/code&gt; 형식으로 제한을 받습니다. 읽기 및 쓰기 속도는 모두 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="eafa400c0b31e17b18c54f70536b75d572bb18c6" translate="yes" xml:space="preserve">
          <source>Both flags take limits in the &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;limit&amp;gt;[unit]&lt;/code&gt; format. Both read and write rates must be a positive integer. You can specify the rate in &lt;code&gt;kb&lt;/code&gt; (kilobytes), &lt;code&gt;mb&lt;/code&gt; (megabytes), or &lt;code&gt;gb&lt;/code&gt; (gigabytes).</source>
          <target state="translated">두 플래그 모두 &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;limit&amp;gt;[unit]&lt;/code&gt; 형식으로 제한을 받습니다. 읽기 및 쓰기 속도는 모두 양의 정수 여야합니다. &lt;code&gt;kb&lt;/code&gt; (킬로바이트), &lt;code&gt;mb&lt;/code&gt; (메가 바이트) 또는 &lt;code&gt;gb&lt;/code&gt; (기가 바이트) 단위로 속도를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c4fd478d35ae9fb239c1f1d393d940f693e6ea7" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;docker-compose&lt;/code&gt; and &lt;code&gt;docker stack&lt;/code&gt; commands support defining secrets in a compose file. See &lt;a href=&quot;../../../compose/compose-file/index#secrets&quot;&gt;the Compose file reference&lt;/a&gt; for details.</source>
          <target state="translated">모두 &lt;code&gt;docker-compose&lt;/code&gt; 및 &lt;code&gt;docker stack&lt;/code&gt; 명령은 파일 작성에 비밀을 정의 지원합니다. 자세한 내용 &lt;a href=&quot;../../../compose/compose-file/index#secrets&quot;&gt;은 파일 작성 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61cf9d32dd987b3bfb9f1079bc0f2a68d113b4ee" translate="yes" xml:space="preserve">
          <source>Both the Notary server and the Notary signer take &lt;a href=&quot;../reference/index&quot;&gt;JSON configuration files&lt;/a&gt;. Pre-built images, such as the &lt;a href=&quot;index#run-a-service-for-testing-or-development&quot;&gt;development images above&lt;/a&gt; provide these configuration files for you with some sane defaults.</source>
          <target state="translated">Notary 서버와 Notary 서명자 모두 &lt;a href=&quot;../reference/index&quot;&gt;JSON 구성 파일을 사용합니다&lt;/a&gt; . &lt;a href=&quot;index#run-a-service-for-testing-or-development&quot;&gt;위&lt;/a&gt; 의 개발 이미지 와 같은 사전 구축 된 이미지 는 이러한 설정 파일을 약간의 기본값으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32aad460b3aa0b7f00bca45a4dd0ee250794162b" translate="yes" xml:space="preserve">
          <source>Both the server and the signer are potential attack vectors against all users of the Notary service. Client keys are also a potential attack vector, but not necessarily against all collections at a time. This section discusses how our architecture is designed to deal with compromises.</source>
          <target state="translated">서버와 서명자 모두 공증인 서비스의 모든 사용자에 대한 잠재적 공격 경로입니다. 클라이언트 키는 잠재적 인 공격 경로이지만 한 번에 모든 컬렉션에 대해 반드시 필요한 것은 아닙니다. 이 섹션에서는 아키텍처가 타협을 처리하도록 설계된 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d1cf4524fbf2ca31f09d77b25fc344dc65b2b7bb" translate="yes" xml:space="preserve">
          <source>Bridge driver options</source>
          <target state="translated">브리지 드라이버 옵션</target>
        </trans-unit>
        <trans-unit id="5dba9e2e9d23b4120629ca7bf6caf4b9830397ed" translate="yes" xml:space="preserve">
          <source>Bridge networks are isolated networks on a single Engine installation. If you want to create a network that spans multiple Docker hosts each running an Engine, you must create an &lt;code&gt;overlay&lt;/code&gt; network. Unlike &lt;code&gt;bridge&lt;/code&gt; networks, overlay networks require some pre-existing conditions before you can create one. These conditions are:</source>
          <target state="translated">브리지 네트워크는 단일 엔진 설치에서 격리 된 네트워크입니다. 각각 엔진을 실행하는 여러 Docker 호스트에 걸쳐있는 네트워크를 작성하려면 &lt;code&gt;overlay&lt;/code&gt; 네트워크를 작성해야합니다 . &lt;code&gt;bridge&lt;/code&gt; 네트워크 와 달리 오버레이 네트워크는 기존의 조건을 만들어야합니다. 이러한 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdcf38d8b648935063d67d09eeb36b8ed0548e61" translate="yes" xml:space="preserve">
          <source>Brief overview of TUF keys and roles</source>
          <target state="translated">TUF 키 및 역할에 대한 간략한 개요</target>
        </trans-unit>
        <trans-unit id="7af6a7b34b7337f1d55b249626f22ab1f9ccf505" translate="yes" xml:space="preserve">
          <source>Bring up WordPress in a web browser</source>
          <target state="translated">웹 브라우저에서 WordPress를 불러옵니다.</target>
        </trans-unit>
        <trans-unit id="87d63ff59943bd44d0515f64bfd5be3c5eabfedf" translate="yes" xml:space="preserve">
          <source>Bringing your own server to Docker Enterprise and setting up Docker Datacenter essentially involves two steps:</source>
          <target state="translated">자체 서버를 Docker Enterprise로 가져오고 Docker Datacenter를 설정하려면 기본적으로 두 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="23ea426693672e77c1775c5bcee149834b6be5a0" translate="yes" xml:space="preserve">
          <source>Browse data on the second database</source>
          <target state="translated">두 번째 데이터베이스에서 데이터 찾아보기</target>
        </trans-unit>
        <trans-unit id="a8b63acbeedc3e7975a7fa7e308d0c998fead062" translate="yes" xml:space="preserve">
          <source>Btrfs options</source>
          <target state="translated">Btrfs 옵션</target>
        </trans-unit>
        <trans-unit id="c828c3fae392cbeddbff706712eafe6ff1aa63ef" translate="yes" xml:space="preserve">
          <source>Build Context Used</source>
          <target state="translated">사용 된 빌드 컨텍스트</target>
        </trans-unit>
        <trans-unit id="cdb24d0da014607af49b18c97430d604ecad6465" translate="yes" xml:space="preserve">
          <source>Build Syntax Suffix</source>
          <target state="translated">구문 구문 접미사 작성</target>
        </trans-unit>
        <trans-unit id="69c645cd06e9c64e45bc9d9baa65f794d3cf456a" translate="yes" xml:space="preserve">
          <source>Build an image and run it as one container</source>
          <target state="translated">이미지를 빌드하고 하나의 컨테이너로 실행</target>
        </trans-unit>
        <trans-unit id="baf8b3e388d58e3efc1b3f442f742b3965625fa8" translate="yes" xml:space="preserve">
          <source>Build an image from a Dockerfile</source>
          <target state="translated">Dockerfile에서 이미지 작성</target>
        </trans-unit>
        <trans-unit id="f2cdd7aaa3f82dbb275fdc7b33ec82dc9c0474bf" translate="yes" xml:space="preserve">
          <source>Build an image from the Dockerfile and assign it a name.</source>
          <target state="translated">Dockerfile에서 이미지를 빌드하고 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee644bb91f709081260d89cc44ead6c5d88b6e13" translate="yes" xml:space="preserve">
          <source>Build an image starting with the Python 3.7 image.</source>
          <target state="translated">Python 3.7 이미지로 시작하는 이미지를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="38a9192a2eb985519a30e46ff5877ee87f9b6b42" translate="yes" xml:space="preserve">
          <source>Build an image with &lt;code&gt;--squash&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;--squash&lt;/code&gt; 인수를 사용 하여 이미지 작성</target>
        </trans-unit>
        <trans-unit id="e39cfecbc32a6cac83f889028a45969f92164684" translate="yes" xml:space="preserve">
          <source>Build and run the Docker image</source>
          <target state="translated">Docker 이미지 빌드 및 실행</target>
        </trans-unit>
        <trans-unit id="42d57a13a95fc363ba6da0349fd7badfb01e83b5" translate="yes" xml:space="preserve">
          <source>Build and start Notary Server with the sample certificates.</source>
          <target state="translated">샘플 인증서로 Notary Server를 빌드하고 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="fd2f5f5e516cd97ff5f3fb398b4b51a490a7fbc3" translate="yes" xml:space="preserve">
          <source>Build cache is only used from images that have a local parent chain. This means that these images were created by previous builds or the whole chain of images was loaded with &lt;code&gt;docker load&lt;/code&gt;. If you wish to use build cache of a specific image you can specify it with &lt;code&gt;--cache-from&lt;/code&gt; option. Images specified with &lt;code&gt;--cache-from&lt;/code&gt; do not need to have a parent chain and may be pulled from other registries.</source>
          <target state="translated">빌드 캐시는 로컬 상위 체인이있는 이미지에서만 사용됩니다. 즉,이 이미지는 이전 빌드에서 생성되었거나 전체 이미지 체인에 &lt;code&gt;docker load&lt;/code&gt; 가로 드되었습니다 . 특정 이미지의 빌드 캐시를 사용하려면 &lt;code&gt;--cache-from&lt;/code&gt; 옵션으로 이미지를 지정할 수 있습니다. &lt;code&gt;--cache-from&lt;/code&gt; 으로 지정된 이미지 에는 상위 체인이 필요하지 않으며 다른 레지스트리에서 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9f0bab1866ca553bf0fed28273ce14692413a5" translate="yes" xml:space="preserve">
          <source>Build support for Docker Secrets into your images</source>
          <target state="translated">이미지에 Docker Secrets 지원 지원</target>
        </trans-unit>
        <trans-unit id="dcf0034475598c7e584936b2280ebf2531c313b0" translate="yes" xml:space="preserve">
          <source>Build the Dockerfile and tag the image as &lt;code&gt;myhtop&lt;/code&gt;:</source>
          <target state="translated">Dockerfile을 빌드하고 이미지를 &lt;code&gt;myhtop&lt;/code&gt; 으로 태그하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fad6fcc785f8581d0bd21750bcf2862182ffc1b" translate="yes" xml:space="preserve">
          <source>Build the app</source>
          <target state="translated">앱 구축</target>
        </trans-unit>
        <trans-unit id="b6e320281378cfe8d9079a62a5db366fae37e518" translate="yes" xml:space="preserve">
          <source>Build the project</source>
          <target state="translated">프로젝트 구축</target>
        </trans-unit>
        <trans-unit id="26846ecc2817af6e251233d933aa789fab1a2bf7" translate="yes" xml:space="preserve">
          <source>Build the sandbox</source>
          <target state="translated">샌드 박스 구축</target>
        </trans-unit>
        <trans-unit id="b676913086eaa112d5c7083b166b47f58cdd07b4" translate="yes" xml:space="preserve">
          <source>Build the specified stage as defined inside the &lt;code&gt;Dockerfile&lt;/code&gt;. See the &lt;a href=&quot;https://docs.docker.com/develop/develop-images&quot;&gt;multi-stage build docs&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 내에 정의 된대로 지정된 스테이지를 빌드하십시오 . 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/develop/develop-images&quot;&gt;다단계 빌드 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df70e525dee30bdb81c057a6cf2a945797a1fb1b" translate="yes" xml:space="preserve">
          <source>Build with -</source>
          <target state="translated">로 빌드-</target>
        </trans-unit>
        <trans-unit id="bf348eb98549bdcb8e6eb616f94e4b26f0c3880f" translate="yes" xml:space="preserve">
          <source>Build with PATH</source>
          <target state="translated">PATH로 빌드</target>
        </trans-unit>
        <trans-unit id="5ca1f6f06d7c33c026e70b0fb9950e3c7df8ca04" translate="yes" xml:space="preserve">
          <source>Build with URL</source>
          <target state="translated">URL로 빌드</target>
        </trans-unit>
        <trans-unit id="6e487a9706ff49a8685e2c9e9052985fa673b1f4" translate="yes" xml:space="preserve">
          <source>Build with content trust</source>
          <target state="translated">컨텐츠 신뢰로 구축</target>
        </trans-unit>
        <trans-unit id="9124c615f7929b18c136c89861cbb0b656fe77ec" translate="yes" xml:space="preserve">
          <source>BuildKit</source>
          <target state="translated">BuildKit</target>
        </trans-unit>
        <trans-unit id="23d1af185b3216443e4a7fbcd3d7a3f788f45d78" translate="yes" xml:space="preserve">
          <source>Building Docker Docker Images for ASP.NET Core</source>
          <target state="translated">ASP.NET Core 용 Docker Docker 이미지 빌드</target>
        </trans-unit>
        <trans-unit id="8ed8e61911a3afbf4d5f6a85059c72be97b094d3" translate="yes" xml:space="preserve">
          <source>Building images</source>
          <target state="translated">건물 이미지</target>
        </trans-unit>
        <trans-unit id="e599b51ed6ef3eaa7e755d740f1b0da73dafcef5" translate="yes" xml:space="preserve">
          <source>Builds, (re)creates, starts, and attaches to containers for a service.</source>
          <target state="translated">서비스를 위해 컨테이너를 빌드, 작성, 시작 및 첨부합니다.</target>
        </trans-unit>
        <trans-unit id="005c691dd96c7caf9e21e233dd6d4328bb4dd943" translate="yes" xml:space="preserve">
          <source>Bundle file format</source>
          <target state="translated">번들 파일 형식</target>
        </trans-unit>
        <trans-unit id="8df453484c5b65dcec2be4b9104ebd8470bf24c3" translate="yes" xml:space="preserve">
          <source>But, if you want to reuse a volume across multiple services, then define a named volume in the &lt;a href=&quot;#volume-configuration-reference&quot;&gt;top-level &lt;code&gt;volumes&lt;/code&gt; key&lt;/a&gt;. Use named volumes with &lt;a href=&quot;#volumes-for-services-swarms-and-stack-files&quot;&gt;services, swarms, and stack files&lt;/a&gt;.</source>
          <target state="translated">그러나 여러 서비스에서 볼륨을 재사용하려면 &lt;a href=&quot;#volume-configuration-reference&quot;&gt;최상위 &lt;code&gt;volumes&lt;/code&gt; 키&lt;/a&gt; 에 이름이 지정된 볼륨을 정의하십시오 . &lt;a href=&quot;#volumes-for-services-swarms-and-stack-files&quot;&gt;서비스, ​​스웜 및 스택 파일과&lt;/a&gt; 함께 명명 된 볼륨을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cd6bb9fda73ba53a16863e2e92f27d4c6c5e7cb" translate="yes" xml:space="preserve">
          <source>By adding the &lt;code&gt;escape&lt;/code&gt; parser directive, the following &lt;code&gt;Dockerfile&lt;/code&gt; succeeds as expected with the use of natural platform semantics for file paths on &lt;code&gt;Windows&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;escape&lt;/code&gt; 파서 지시문 을 추가하면 다음 &lt;code&gt;Dockerfile&lt;/code&gt; 이 &lt;code&gt;Windows&lt;/code&gt; 의 파일 경로에 자연 플랫폼 의미를 사용하여 예상대로 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="fa55cfad7c3a085853bb1c459f1836f51c461649" translate="yes" xml:space="preserve">
          <source>By bind-mounting the docker unix socket and statically linked docker binary (refer to &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#/get-the-linux-binary&quot;&gt;get the linux binary&lt;/a&gt;), you give the container the full access to create and manipulate the host&amp;rsquo;s Docker daemon.</source>
          <target state="translated">docker unix 소켓과 정적으로 링크 된 docker 바이너리 ( &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce#/get-the-linux-binary&quot;&gt;linux binary 가져 오기&lt;/a&gt; 참조)를 바인드 마운트하면 컨테이너에 호스트의 Docker 데몬을 만들고 조작 할 수있는 모든 권한을 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f71581634677a7c9505d86cbd54ac9b78f95f43" translate="yes" xml:space="preserve">
          <source>By contrast, a &lt;strong&gt;virtual machine&lt;/strong&gt; (VM) runs a full-blown &amp;ldquo;guest&amp;rdquo; operating system with &lt;em&gt;virtual&lt;/em&gt; access to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.</source>
          <target state="translated">반대로 &lt;strong&gt;가상 머신&lt;/strong&gt; (VM)은 하이퍼 바이저를 통해 호스트 리소스에 &lt;em&gt;가상으로&lt;/em&gt; 액세스 할 수 있는 완전한 &quot;게스트&quot;운영 체제를 실행합니다 . 일반적으로 VM은 대부분의 응용 프로그램에 필요한 것보다 많은 리소스가있는 환경을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a447d9951a3a2dbbe6ff0093dcc95de641b1bce5" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;docker exec&lt;/code&gt; command runs in the same working directory set when container was created.</source>
          <target state="translated">기본적으로 &lt;code&gt;docker exec&lt;/code&gt; 명령은 컨테이너를 만들 때 설정된 동일한 작업 디렉토리에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f21b045f684657c6e86a0602da01fd56439adb3" translate="yes" xml:space="preserve">
          <source>By default Compose sets up a single &lt;a href=&quot;../../engine/reference/commandline/network_create/index&quot;&gt;network&lt;/a&gt; for your app. Each container for a service joins the default network and is both &lt;em&gt;reachable&lt;/em&gt; by other containers on that network, and &lt;em&gt;discoverable&lt;/em&gt; by them at a hostname identical to the container name.</source>
          <target state="translated">기본적으로 작성은 앱에 단일 &lt;a href=&quot;../../engine/reference/commandline/network_create/index&quot;&gt;네트워크&lt;/a&gt; 를 설정합니다 . 서비스의 각 컨테이너는 기본 네트워크에 참여하며 모두 &lt;em&gt;접근 가능&lt;/em&gt; 해당 네트워크의 다른 컨테이너에서 있고 컨테이너 이름과 동일한 호스트 이름으로 &lt;em&gt;검색&lt;/em&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296b02b005a969977d246b85eed0d5c74c730f7d" translate="yes" xml:space="preserve">
          <source>By default Docker Swarm uses a default address pool &lt;code&gt;10.0.0.0/8&lt;/code&gt; for global scope (overlay) networks. Every network that does not have a subnet specified will have a subnet sequentially allocated from this pool. In some circumstances it may be desirable to use a different default IP address pool for networks.</source>
          <target state="translated">기본적으로 Docker Swarm은 기본 주소 풀을 사용합니다. &lt;code&gt;10.0.0.0/8&lt;/code&gt; 전역 범위 (오버레이) 네트워크에 10.0.0.0/8 을 . 서브넷이 지정되지 않은 모든 네트워크에는이 풀에서 순차적으로 서브넷이 할당됩니다. 경우에 따라 네트워크에 다른 기본 IP 주소 풀을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f441a00c39dd9b688f99277deb92b1bec7187417" translate="yes" xml:space="preserve">
          <source>By default XFS retries infinitely for IO to finish and this can result in unkillable process. To change this behavior one can set xfs_nospace_max_retries to say 0 and XFS will not retry IO after getting ENOSPC and will shutdown filesystem.</source>
          <target state="translated">기본적으로 XFS는 IO가 완료 될 때까지 무한 재 시도하므로 프로세스를 종료 할 수 없습니다. 이 동작을 변경하기 위해 xfs_nospace_max_retries를 0으로 설정하면 ENOSPC를 얻은 후 XFS가 IO를 다시 시도하지 않고 파일 시스템을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="1a8e5f7cbb543d293957a3fc75b0eb5ea50d555f" translate="yes" xml:space="preserve">
          <source>By default a container&amp;rsquo;s file system persists even after the container exits. This makes debugging a lot easier (since you can inspect the final state) and you retain all your data by default. But if you are running short-term &lt;strong&gt;foreground&lt;/strong&gt; processes, these container file systems can really pile up. If instead you&amp;rsquo;d like Docker to &lt;strong&gt;automatically clean up the container and remove the file system when the container exits&lt;/strong&gt;, you can add the &lt;code&gt;--rm&lt;/code&gt; flag:</source>
          <target state="translated">기본적으로 컨테이너의 파일 시스템은 컨테이너가 종료 된 후에도 유지됩니다. 이렇게하면 최종 상태를 검사 할 수 있으므로 디버깅이 훨씬 쉬워지고 기본적으로 모든 데이터가 유지됩니다. 그러나 단기 &lt;strong&gt;포 그라운드&lt;/strong&gt; 프로세스를 실행하는 경우 이러한 컨테이너 파일 시스템이 실제로 쌓일 수 있습니다. Docker가 &lt;strong&gt;컨테이너&lt;/strong&gt; 를 &lt;strong&gt;자동으로 정리하고 컨테이너가 종료 될 때 파일 시스템을 제거하도록&lt;/strong&gt; 하려면 &lt;code&gt;--rm&lt;/code&gt; 플래그를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d668b7926ca52c96f2019bef89381722ec9ad4dd" translate="yes" xml:space="preserve">
          <source>By default manager nodes also act as a worker nodes. This means the scheduler can assign tasks to a manager node. For small and non-critical swarms assigning tasks to managers is relatively low-risk as long as you schedule services using &lt;strong&gt;resource constraints&lt;/strong&gt; for &lt;em&gt;cpu&lt;/em&gt; and &lt;em&gt;memory&lt;/em&gt;.</source>
          <target state="translated">기본적으로 관리자 노드는 작업자 노드 역할도합니다. 이는 스케줄러가 작업을 관리자 노드에 할당 할 수 있음을 의미합니다. 작고 중요하지 않은 떼의 경우 &lt;em&gt;CPU&lt;/em&gt; 및 &lt;em&gt;메모리에&lt;/em&gt; 대한 &lt;strong&gt;자원 제한&lt;/strong&gt; 을 사용하여 서비스를 예약하는 한 관리자에게 작업을 할당하는 것은 상대적으로 위험이 적습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a50f019a6a113bd38e58602121ebe3d7db9879c2" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;docker build&lt;/code&gt; command will look for a &lt;code&gt;Dockerfile&lt;/code&gt; at the root of the build context. The &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;--file&lt;/code&gt;, option lets you specify the path to an alternative file to use instead. This is useful in cases where the same set of files are used for multiple builds. The path must be to a file within the build context. If a relative path is specified then it is interpreted as relative to the root of the context.</source>
          <target state="translated">기본적으로 &lt;code&gt;docker build&lt;/code&gt; 명령은 빌드 컨텍스트의 루트에서 &lt;code&gt;Dockerfile&lt;/code&gt; 을 찾습니다 . &lt;code&gt;-f&lt;/code&gt; 는 , &lt;code&gt;--file&lt;/code&gt; 옵션은 대신 사용하는 다른 파일의 경로를 지정할 수 있습니다. 여러 빌드에 동일한 파일 세트가 사용되는 경우에 유용합니다. 경로는 빌드 컨텍스트 내의 파일에 대한 경로 여야합니다. 상대 경로가 지정되면 컨텍스트의 루트를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c684769c00baded30cf6e28063dfa0d65ded8880" translate="yes" xml:space="preserve">
          <source>By default the Docker daemon will pull three layers of an image at a time. If you are on a low bandwidth connection this may cause timeout issues and you may want to lower this via the &lt;code&gt;--max-concurrent-downloads&lt;/code&gt; daemon option. See the &lt;a href=&quot;../dockerd/index&quot;&gt;daemon documentation&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 Docker 데몬은 한 번에 3 개의 이미지 레이어를 가져옵니다. 저 대역폭 연결 인 경우 시간 초과 문제가 발생할 수 있으며 &lt;code&gt;--max-concurrent-downloads&lt;/code&gt; 데몬 옵션을 통해이 시간을 줄일 수 있습니다. 자세한 내용은 &lt;a href=&quot;../dockerd/index&quot;&gt;데몬 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cdd1ccf49c146fa8726d90dfecc81e151cf7d812" translate="yes" xml:space="preserve">
          <source>By default the Docker daemon will push five layers of an image at a time. If you are on a low bandwidth connection this may cause timeout issues and you may want to lower this via the &lt;code&gt;--max-concurrent-uploads&lt;/code&gt; daemon option. See the &lt;a href=&quot;../dockerd/index&quot;&gt;daemon documentation&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 Docker 데몬은 한 번에 5 개의 이미지 레이어를 푸시합니다. 대역폭이 낮은 연결을 사용하는 경우 시간 초과 문제가 발생할 수 있으며 &lt;code&gt;--max-concurrent-uploads&lt;/code&gt; 데몬 옵션을 통해이 시간을 줄일 수 있습니다. &lt;a href=&quot;../dockerd/index&quot;&gt;데몬 설명서를&lt;/a&gt; 참조하십시오 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27625db74aedc1cf2aff52581897e1f7feca3a00" translate="yes" xml:space="preserve">
          <source>By default the command will just show a summary of the data used:</source>
          <target state="translated">기본적으로이 명령은 사용 된 데이터의 요약 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a36b4c1733cefe6943939a456a5f681007be26d1" translate="yes" xml:space="preserve">
          <source>By default the scheduler updates 1 task at a time. You can pass the &lt;code&gt;--update-parallelism&lt;/code&gt; flag to configure the maximum number of service tasks that the scheduler updates simultaneously.</source>
          <target state="translated">기본적으로 스케줄러는 한 번에 하나의 작업을 업데이트합니다. &lt;code&gt;--update-parallelism&lt;/code&gt; 플래그를 전달 하여 스케줄러가 동시에 업데이트하는 최대 서비스 작업 수를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1484498126e0b62fb567f181a13caf046c3bf4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;EXPOSE&lt;/code&gt; assumes TCP. You can also specify UDP:</source>
          <target state="translated">기본적으로 &lt;code&gt;EXPOSE&lt;/code&gt; 는 TCP를 가정합니다. UDP를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9a27193c87b30f69d2e5a6dda4faa98db248d7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;docker inspect&lt;/code&gt; will render results in a JSON array.</source>
          <target state="translated">기본적으로 &lt;code&gt;docker inspect&lt;/code&gt; 는 결과를 JSON 배열로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="19e4870fba0952423c1248f25d0d36f00c91b505" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;docker pull&lt;/code&gt; pulls a &lt;em&gt;single&lt;/em&gt; image from the registry. A repository can contain multiple images. To pull all images from a repository, provide the &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all-tags&lt;/code&gt;) option when using &lt;code&gt;docker pull&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;docker pull&lt;/code&gt; 은 레지스트리에서 &lt;em&gt;단일&lt;/em&gt; 이미지를 가져옵니다 . 저장소는 여러 이미지를 포함 할 수 있습니다. 저장소에서 모든 이미지를 가져 오려면 &lt;code&gt;docker pull&lt;/code&gt; 을 사용할 때 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--all-tags&lt;/code&gt; 옵션을 제공하십시오. .</target>
        </trans-unit>
        <trans-unit id="2b309be5fdc7befbb50d04cbc42c3d6ef26779d3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;docker pull&lt;/code&gt; pulls images from &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt;. It is also possible to manually specify the path of a registry to pull from. For example, if you have set up a local registry, you can specify its path to pull from it. A registry path is similar to a URL, but does not contain a protocol specifier (&lt;code&gt;https://&lt;/code&gt;).</source>
          <target state="translated">기본적으로 &lt;code&gt;docker pull&lt;/code&gt; 은 &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; 에서 이미지를 가져옵니다 . 가져올 레지스트리 경로를 수동으로 지정할 수도 있습니다. 예를 들어 로컬 레지스트리를 설정 한 경우 해당 경로를 지정하여 가져올 수 있습니다. 레지스트리 경로는 URL과 유사하지만 프로토콜 지정자 ( &lt;code&gt;https://&lt;/code&gt; )를 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64187c85b31e5eefe0a2562826b000123e391b50" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;stop&lt;/code&gt; waits 10 seconds for the container to exit before sending SIGKILL.</source>
          <target state="translated">기본적으로 &lt;code&gt;stop&lt;/code&gt; 은 컨테이너가 종료 될 때까지 10 초 동안 기다렸다가 SIGKILL을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c76437d965beaf3a98bf7f43bbb64e07e6d3449d" translate="yes" xml:space="preserve">
          <source>By default, Compose creates a volume whose name is prefixed with your project name. If you want it to just be called &lt;code&gt;data&lt;/code&gt;, declare it as external:</source>
          <target state="translated">기본적으로 Compose는 이름 앞에 프로젝트 이름이 붙은 볼륨을 만듭니다. &lt;code&gt;data&lt;/code&gt; 라고 부르기를 원한다면 외부로 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="d5d1f08a7950f62738e6141bb1dfa3bc13b4da1a" translate="yes" xml:space="preserve">
          <source>By default, Compose reads two files, a &lt;code&gt;docker-compose.yml&lt;/code&gt; and an optional &lt;code&gt;docker-compose.override.yml&lt;/code&gt; file. By convention, the &lt;code&gt;docker-compose.yml&lt;/code&gt; contains your base configuration. The override file, as its name implies, can contain configuration overrides for existing services or entirely new services.</source>
          <target state="translated">기본적으로 Compose는 두 개의 파일 인 &lt;code&gt;docker-compose.yml&lt;/code&gt; 과 선택적인 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; 파일을 읽습니다 . 일반적으로 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에는 기본 구성이 포함되어 있습니다. 대체 파일은 이름에서 알 수 있듯이 기존 서비스 또는 완전히 새로운 서비스에 대한 구성 대체를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42f892a86e0125721cb57d3e8fe0612075be3154" translate="yes" xml:space="preserve">
          <source>By default, Docker also connects a bridge network to it to provide external connectivity. If you want to create an externally isolated overlay network, you can set this option to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Docker는 기본적으로 브리지 네트워크를 연결하여 외부 연결을 제공합니다. 외부 적으로 고립 된 오버레이 네트워크를 만들려면이 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a50d8001053ab9e6e9eb826955c470341dbc785" translate="yes" xml:space="preserve">
          <source>By default, Docker assumes all, but local (see local registries below), registries are secure. Communicating with an insecure registry is not possible if Docker assumes that registry is secure. In order to communicate with an insecure registry, the Docker daemon requires &lt;code&gt;--insecure-registry&lt;/code&gt; in one of the following two forms:</source>
          <target state="translated">기본적으로 Docker는 모든 것을 가정하지만 로컬 (아래의 로컬 레지스트리 참조) 레지스트리는 안전합니다. Docker가 레지스트리가 안전하다고 가정하면 안전하지 않은 레지스트리와 통신 할 수 없습니다. 안전하지 않은 레지스트리와 통신하려면 Docker 데몬에는 &lt;code&gt;--insecure-registry&lt;/code&gt; 가 필요합니다 다음 두 가지 형식 중 하나로 가 합니다.</target>
        </trans-unit>
        <trans-unit id="770b566d694d41c3a51d0a5cb4c45725f0f15509" translate="yes" xml:space="preserve">
          <source>By default, Docker containers are &amp;ldquo;unprivileged&amp;rdquo; and cannot, for example, run a Docker daemon inside a Docker container. This is because by default a container is not allowed to access any devices, but a &amp;ldquo;privileged&amp;rdquo; container is given access to all devices (see the documentation on &lt;a href=&quot;https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt&quot;&gt;cgroups devices&lt;/a&gt;).</source>
          <target state="translated">Docker 컨테이너는 기본적으로 &quot;권한이 없으며&quot;Docker 컨테이너 내에서 Docker 데몬을 실행할 수 없습니다. 기본적으로 컨테이너는 어떤 장치에도 액세스 할 수 없지만 &quot;권한있는&quot;컨테이너는 모든 장치에 액세스 할 수 있기 때문입니다 ( &lt;a href=&quot;https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt&quot;&gt;cgroups 장치&lt;/a&gt; 의 설명서 참조). ).</target>
        </trans-unit>
        <trans-unit id="5f09ceb2eb6e512758cafe7496faec2a9530220f" translate="yes" xml:space="preserve">
          <source>By default, Docker looks for the native binary on each of the platforms, i.e. &amp;ldquo;osxkeychain&amp;rdquo; on macOS, &amp;ldquo;wincred&amp;rdquo; on windows, and &amp;ldquo;pass&amp;rdquo; on Linux. A special case is that on Linux, Docker will fall back to the &amp;ldquo;secretservice&amp;rdquo; binary if it cannot find the &amp;ldquo;pass&amp;rdquo; binary. If none of these binaries are present, it stores the credentials (i.e. password) in base64 encoding in the config files described above.</source>
          <target state="translated">기본적으로 Docker는 각 플랫폼에서 고유 바이너리를 찾습니다 (예 : macOS의 &quot;osxkeychain&quot;, Windows의 &quot;wincred&quot;및 Linux의 &quot;pass&quot;). 특별한 경우는 Linux에서 Docker가 &quot;통과&quot;바이너리를 찾을 수없는 경우 &quot;secretservice&quot;바이너리로 대체되는 것입니다. 이 바이너리가 없으면 위에서 설명한 구성 파일의 자격 증명 (예 : 비밀번호)을 base64 인코딩으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6a8a0ddfb99d2345ec1a67d36cd61ad762a3b5e6" translate="yes" xml:space="preserve">
          <source>By default, Docker runs through a non-networked UNIX socket. It can also optionally communicate using an HTTP socket.</source>
          <target state="translated">기본적으로 Docker는 네트워크로 연결되지 않은 UNIX 소켓을 통해 실행됩니다. HTTP 소켓을 사용하여 선택적으로 통신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3654fd5e335b324a903259a937c4e5022b2e26fe" translate="yes" xml:space="preserve">
          <source>By default, Docker starts containers with a restricted set of capabilities. What does that mean?</source>
          <target state="translated">기본적으로 Docker는 제한된 기능 세트로 컨테이너를 시작합니다. 그게 무슨 뜻이야?</target>
        </trans-unit>
        <trans-unit id="d401665d8bb2cc7e9c17d85044d3f209a06de259" translate="yes" xml:space="preserve">
          <source>By default, a &lt;code&gt;unix&lt;/code&gt; domain socket (or IPC socket) is created at &lt;code&gt;/var/run/docker.sock&lt;/code&gt;, requiring either &lt;code&gt;root&lt;/code&gt; permission, or &lt;code&gt;docker&lt;/code&gt; group membership.</source>
          <target state="translated">기본적으로 &lt;code&gt;unix&lt;/code&gt; 도메인 소켓 (또는 IPC 소켓)은 &lt;code&gt;/var/run/docker.sock&lt;/code&gt; 에 생성되며 &lt;code&gt;root&lt;/code&gt; 권한 또는도 &lt;code&gt;docker&lt;/code&gt; 필요합니다 그룹 구성원을.</target>
        </trans-unit>
        <trans-unit id="29ccc61f6215893462c2d7171929dac2da11af43" translate="yes" xml:space="preserve">
          <source>By default, a container&amp;rsquo;s kernel can swap out a percentage of anonymous pages. To set this percentage for a container, specify a &lt;code&gt;--memory-swappiness&lt;/code&gt; value between 0 and 100. A value of 0 turns off anonymous page swapping. A value of 100 sets all anonymous pages as swappable. By default, if you are not using &lt;code&gt;--memory-swappiness&lt;/code&gt;, memory swappiness value will be inherited from the parent.</source>
          <target state="translated">기본적으로 컨테이너의 커널은 일정 비율의 익명 페이지를 교체 할 수 있습니다. 컨테이너에 대해이 백분율을 설정하려면 &lt;code&gt;--memory-swappiness&lt;/code&gt; 값을 0에서 100 사이로 지정하십시오 . 값이 0이면 익명 페이지 스와핑이 해제됩니다. 값이 100이면 모든 익명 페이지가 교환 가능한 것으로 설정됩니다. 기본적으로 &lt;code&gt;--memory-swappiness&lt;/code&gt; 를 사용하지 않으면 메모리 스왑 피스 값이 상위에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="38e131bd238144ba1243ad58d5c5b09213ab20e4" translate="yes" xml:space="preserve">
          <source>By default, all containers get the same proportion of CPU cycles. This proportion can be modified by changing the container&amp;rsquo;s CPU share weighting relative to the weighting of all other running containers.</source>
          <target state="translated">기본적으로 모든 컨테이너는 동일한 비율의 CPU주기를 갖습니다. 이 비율은 다른 모든 실행중인 컨테이너의 가중치를 기준으로 컨테이너의 CPU 점유율 가중치를 변경하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82ee0a9ace85926a0813a04cf26b2167967b19f" translate="yes" xml:space="preserve">
          <source>By default, all containers get the same proportion of block IO bandwidth (blkio). This proportion is 500. To modify this proportion, change the container&amp;rsquo;s blkio weight relative to the weighting of all other running containers using the &lt;code&gt;--blkio-weight&lt;/code&gt; flag.</source>
          <target state="translated">기본적으로 모든 컨테이너는 동일한 비율의 블록 IO 대역폭 (blkio)을 갖습니다. 이 비율은 500입니다.이 비율을 수정하려면 &lt;code&gt;--blkio-weight&lt;/code&gt; 플래그를 사용하여 다른 모든 실행중인 컨테이너의 가중치를 기준으로 컨테이너의 blkio 가중치를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="1747619c31997e25a35ae82b733d549833437c80" translate="yes" xml:space="preserve">
          <source>By default, all containers have networking enabled and they can make any outgoing connections. The operator can completely disable networking with &lt;code&gt;docker run --network none&lt;/code&gt; which disables all incoming and outgoing networking. In cases like this, you would perform I/O through files or &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; only.</source>
          <target state="translated">기본적으로 모든 컨테이너에는 네트워킹이 활성화되어 있으며 나가는 연결을 만들 수 있습니다. 운영자는 모든 수신 및 발신 네트워킹을 비활성화하는 &lt;code&gt;docker run --network none&lt;/code&gt; 으로 네트워킹을 완전히 비활성화 할 수 있습니다 . 이와 같은 경우 파일 또는 &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 을 통해 I / O를 수행합니다. 통해서만 합니다.</target>
        </trans-unit>
        <trans-unit id="d521db483da9f3edb5e745ae8f40406dda09f14f" translate="yes" xml:space="preserve">
          <source>By default, all containers have the PID namespace enabled.</source>
          <target state="translated">기본적으로 모든 컨테이너에는 PID 네임 스페이스가 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f9d81709c1204dff9dc155efa99a0eece3c4d0c" translate="yes" xml:space="preserve">
          <source>By default, anonymous volumes attached to containers are not removed. You can override this with &lt;code&gt;-v&lt;/code&gt;. To list all volumes, use &lt;code&gt;docker volume ls&lt;/code&gt;.</source>
          <target state="translated">기본적으로 컨테이너에 연결된 익명 볼륨은 제거되지 않습니다. 이를 &lt;code&gt;-v&lt;/code&gt; 로 대체 할 수 있습니다 . 모든 볼륨을 나열하려면 &lt;code&gt;docker volume ls&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bda1079a215fd51385ab6d7139b4876932cabc33" translate="yes" xml:space="preserve">
          <source>By default, each node in the swarm renews its certificate every three months. You can configure this interval by running the &lt;code&gt;docker swarm update --cert-expiry &amp;lt;TIME PERIOD&amp;gt;&lt;/code&gt; command. The minimum rotation value is 1 hour. Refer to the &lt;a href=&quot;../../../reference/commandline/swarm_update/index&quot;&gt;docker swarm update&lt;/a&gt; CLI reference for details.</source>
          <target state="translated">기본적으로 swarm의 각 노드는 3 개월마다 인증서를 갱신합니다. &lt;code&gt;docker swarm update --cert-expiry &amp;lt;TIME PERIOD&amp;gt;&lt;/code&gt; 명령 을 실행하여이 간격을 구성 할 수 있습니다 . 최소 회전 값은 1 시간입니다. &lt;a href=&quot;../../../reference/commandline/swarm_update/index&quot;&gt;도커 떼 업데이트를&lt;/a&gt; 참조하십시오 CLI 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6eede964e0022963846e5c096d17a1e7ec7c098e" translate="yes" xml:space="preserve">
          <source>By default, every container joins an application-wide default network, and is discoverable at a hostname that&amp;rsquo;s the same as the service name. This means &lt;a href=&quot;../compose-file-v2/index#links&quot;&gt;links&lt;/a&gt; are largely unnecessary. For more details, see &lt;a href=&quot;../compose-file-v2/index#networking/&quot;&gt;Networking in Compose&lt;/a&gt;.</source>
          <target state="translated">기본적으로 모든 컨테이너는 응용 프로그램 전체의 기본 네트워크에 가입하며 서비스 이름과 동일한 호스트 이름에서 검색 할 수 있습니다. 이것은 &lt;a href=&quot;../compose-file-v2/index#links&quot;&gt;링크&lt;/a&gt; 가 크게 불필요하다는 것을 의미 합니다 . 자세한 내용 &lt;a href=&quot;../compose-file-v2/index#networking/&quot;&gt;은 작성 네트워킹을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85ded447c6003b9587e4a0aa4e2260346790beaf" translate="yes" xml:space="preserve">
          <source>By default, experimental mode is disabled. To see the current configuration, use the &lt;code&gt;docker version&lt;/code&gt; command.</source>
          <target state="translated">기본적으로 실험 모드는 비활성화되어 있습니다. 현재 구성을 보려면 &lt;code&gt;docker version&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f32424bb53ddf5050512688e1d1dee656abb0675" translate="yes" xml:space="preserve">
          <source>By default, if you attach an empty volume to a container, and files or directories already existed at the mount-path in the container (</source>
          <target state="translated">기본적으로 컨테이너에 빈 볼륨을 연결하고 컨테이너의 마운트 경로에 파일 또는 디렉토리가 이미 존재하는 경우 (</target>
        </trans-unit>
        <trans-unit id="e687c839fea3eee9c252497f9da75cdc0bfd09aa" translate="yes" xml:space="preserve">
          <source>By default, kernel kills processes in a container if an out-of-memory (OOM) error occurs. To change this behaviour, use the &lt;code&gt;--oom-kill-disable&lt;/code&gt; option. Only disable the OOM killer on containers where you have also set the &lt;code&gt;-m/--memory&lt;/code&gt; option. If the &lt;code&gt;-m&lt;/code&gt; flag is not set, this can result in the host running out of memory and require killing the host&amp;rsquo;s system processes to free memory.</source>
          <target state="translated">기본적으로 커널은 메모리 부족 (OOM) 오류가 발생하면 컨테이너의 프로세스를 종료합니다. 이 동작을 변경하려면 &lt;code&gt;--oom-kill-disable&lt;/code&gt; 옵션을 사용하십시오. &lt;code&gt;-m/--memory&lt;/code&gt; 옵션 도 설정 한 컨테이너에서는 OOM 킬러 만 비활성화하십시오 . 경우 &lt;code&gt;-m&lt;/code&gt; 플래그가 설정되어 있지 않은,이 메모리 부족 호스트 초래하고 무료 메모리 호스트의 시스템 프로세스를 종료 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c0c6de145ff91a0e349b0f013ad866d8fbf6fae" translate="yes" xml:space="preserve">
          <source>By default, submounts are recursively bind-mounted as well. However, this behavior can be confusing when a bind mount is configured with</source>
          <target state="translated">기본적으로 서브 마운트는 재귀 적으로 바인드 마운트됩니다. 그러나 바인드 마운트가 다음과 같이 구성된 경우이 동작이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a0740b2796a107bfa6a2d435c522ab1fb775870" translate="yes" xml:space="preserve">
          <source>By default, tasks scheduled on Windows nodes are run using the default isolation mode configured for this particular node. To force a specific isolation mode, you can use the &lt;code&gt;--isolation&lt;/code&gt; flag:</source>
          <target state="translated">기본적으로 Windows 노드에서 예약 된 작업은이 특정 노드에 대해 구성된 기본 격리 모드를 사용하여 실행됩니다. 특정 격리 모드를 강제 실행하려면 &lt;code&gt;--isolation&lt;/code&gt; 을 사용할 수 있습니다 플래그를 .</target>
        </trans-unit>
        <trans-unit id="583d00edceb99ae24069c52eb36f77ab8b8c28f9" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;$ docker trust&lt;/code&gt; commands expect the notary server URL to be the same as the registry URL specified in the image tag (following a similar logic to &lt;code&gt;$ docker push&lt;/code&gt;). When using Docker Hub or DTR, the notary server URL is the same as the registry URL. However, for self-hosted environments or 3rd party registries, you will need to specify an alternative URL for the notary server. This is done with:</source>
          <target state="translated">기본적으로 &lt;code&gt;$ docker trust&lt;/code&gt; 명령은 공증 서버 URL이 이미지 태그에 지정된 레지스트리 URL과 같을 것으로 예상합니다 ( &lt;code&gt;$ docker push&lt;/code&gt; 와 유사한 논리에 따름 ). Docker Hub 또는 DTR을 사용할 때 공증 서버 URL은 레지스트리 URL과 동일합니다. 그러나 자체 호스팅 환경 또는 타사 레지스트리의 경우 공증 서버의 대체 URL을 지정해야합니다. 이것은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="abb4bdcce29861bdf9624993f0320bb23afabc29" translate="yes" xml:space="preserve">
          <source>By default, the Amazon EC2 driver uses a daily image of &lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt;.</source>
          <target state="translated">기본적으로 Amazon EC2 드라이버는 매일 &lt;code&gt;Ubuntu 16.04 LTS&lt;/code&gt; 이미지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="cd0ecfa751cd4a7a1c76139eba899beb01f5f9f9" translate="yes" xml:space="preserve">
          <source>By default, the Docker command line stores its configuration files in a directory called &lt;code&gt;.docker&lt;/code&gt; within your &lt;code&gt;$HOME&lt;/code&gt; directory. However, you can specify a different location via the &lt;code&gt;DOCKER_CONFIG&lt;/code&gt; environment variable or the &lt;code&gt;--config&lt;/code&gt; command line option. If both are specified, then the &lt;code&gt;--config&lt;/code&gt; option overrides the &lt;code&gt;DOCKER_CONFIG&lt;/code&gt; environment variable. For example:</source>
          <target state="translated">기본적으로 도커 명령 줄라는 디렉토리에 구성 파일을 저장 &lt;code&gt;.docker&lt;/code&gt; 하여 내 &lt;code&gt;$HOME&lt;/code&gt; 디렉토리. 그러나 &lt;code&gt;DOCKER_CONFIG&lt;/code&gt; 환경 변수 또는 &lt;code&gt;--config&lt;/code&gt; 명령 행 옵션을 통해 다른 위치를 지정할 수 있습니다 . 둘 다 지정하면 &lt;code&gt;--config&lt;/code&gt; 옵션이 &lt;code&gt;DOCKER_CONFIG&lt;/code&gt; 를 재정의합니다 . 환경 변수를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2f6e90f88aefe484e230193a0795c76d3c8bffa" translate="yes" xml:space="preserve">
          <source>By default, the Docker daemon automatically starts &lt;code&gt;containerd&lt;/code&gt;. If you want to control &lt;code&gt;containerd&lt;/code&gt; startup, manually start &lt;code&gt;containerd&lt;/code&gt; and pass the path to the &lt;code&gt;containerd&lt;/code&gt; socket using the &lt;code&gt;--containerd&lt;/code&gt; flag. For example:</source>
          <target state="translated">기본적으로 Docker 데몬은 자동으로 &lt;code&gt;containerd&lt;/code&gt; 를 시작합니다 . 제어하려는 경우 &lt;code&gt;containerd&lt;/code&gt; 의 시작을 수동으로 시작 &lt;code&gt;containerd&lt;/code&gt; 을 하고 경로를 통과 &lt;code&gt;containerd&lt;/code&gt; 의 사용하여 소켓 &lt;code&gt;--containerd&lt;/code&gt; 플래그. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="325ba8afcd20daed4ee53487643a6309fe422f50" translate="yes" xml:space="preserve">
          <source>By default, the MAC address is generated using the IP address allocated to the container. You can set the container&amp;rsquo;s MAC address explicitly by providing a MAC address via the &lt;code&gt;--mac-address&lt;/code&gt; parameter (format:&lt;code&gt;12:34:56:78:9a:bc&lt;/code&gt;).Be aware that Docker does not check if manually specified MAC addresses are unique.</source>
          <target state="translated">기본적으로 MAC 주소는 컨테이너에 할당 된 IP 주소를 사용하여 생성됩니다. &lt;code&gt;--mac-address&lt;/code&gt; 매개 변수 를 통해 MAC 주소를 제공하여 컨테이너의 MAC 주소를 명시 적으로 설정할 수 있습니다 (형식 : &lt;code&gt;12:34:56:78:9a:bc&lt;/code&gt; ). Docker는 수동으로 지정된 MAC 주소가 있는지 확인하지 않습니다. 독특한.</target>
        </trans-unit>
        <trans-unit id="bea0a42407ae8876112a1c8d677c3df5b61d5ae5" translate="yes" xml:space="preserve">
          <source>By default, the container being committed and its processes will be paused while the image is committed. This reduces the likelihood of encountering data corruption during the process of creating the commit. If this behavior is undesired, set the &lt;code&gt;--pause&lt;/code&gt; option to false.</source>
          <target state="translated">기본적으로 커밋되는 컨테이너와 프로세스는 이미지가 커밋되는 동안 일시 중지됩니다. 이를 통해 커밋을 만드는 과정에서 데이터가 손상 될 가능성이 줄어 듭니다. 이 동작이 바람직하지 않은 경우 &lt;code&gt;--pause&lt;/code&gt; 옵션을 false로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ade14debca8fb043b4983f4f0629f1e13627e58" translate="yes" xml:space="preserve">
          <source>By default, the container will be able to &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;mknod&lt;/code&gt; these devices. This can be overridden using a third &lt;code&gt;:rwm&lt;/code&gt; set of options to each &lt;code&gt;--device&lt;/code&gt; flag:</source>
          <target state="translated">기본적으로 컨테이너는 할 수있을 것입니다 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;mknod&lt;/code&gt; 에 이러한 장치를. 각 &lt;code&gt;--device&lt;/code&gt; 에 대한 세 번째 &lt;code&gt;:rwm&lt;/code&gt; 옵션 세트를 사용하여이를 재정의 할 수 있습니다 . 플래그에 .</target>
        </trans-unit>
        <trans-unit id="bf326bf0fe822e3103e04ac3c657c3f3491f6f82" translate="yes" xml:space="preserve">
          <source>By default, the container will be able to &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;mknod&lt;/code&gt; these devices. This can be overridden using a third &lt;code&gt;:rwm&lt;/code&gt; set of options to each &lt;code&gt;--device&lt;/code&gt; flag:</source>
          <target state="translated">기본적으로 컨테이너는 할 수있을 것입니다 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , 그리고 &lt;code&gt;mknod&lt;/code&gt; 에 이러한 장치를. 각 &lt;code&gt;--device&lt;/code&gt; 플래그에 대한 세 번째 &lt;code&gt;:rwm&lt;/code&gt; 옵션 세트를 사용하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952bce482ee761e5e849b0e12339e6d217c885a6" translate="yes" xml:space="preserve">
          <source>By default, the docker container process runs with the supplementary groups looked up for the specified user. If one wants to add more to that list of groups, then one can use this flag:</source>
          <target state="translated">기본적으로 docker container 프로세스는 지정된 사용자를 찾는 보충 그룹으로 실행됩니다. 해당 그룹 목록에 더 추가하려는 경우 다음 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec65243b077ed94fe272018d04ac83e8b4724e4" translate="yes" xml:space="preserve">
          <source>By default, the driver creates new instances in region us-east-1 (North Virginia). You can specify a different region by using the &lt;code&gt;--amazonec2-region&lt;/code&gt; flag. For example, create aws-sandbox in us-west-1 (Northern California).</source>
          <target state="translated">기본적으로 드라이버는 지역 us-east-1 (North Virginia)에 새 인스턴스를 만듭니다. &lt;code&gt;--amazonec2-region&lt;/code&gt; 을 사용하여 다른 지역을 지정할 수 있습니다 플래그를 . 예를 들어 us-west-1 (캘리포니아 북부)에 aws-sandbox를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d0bd81e6568314fae945bbfd3f0ae7353cb4d74" translate="yes" xml:space="preserve">
          <source>By default, the notary client is responsible for managing the private keys for root, targets, snapshot roles. All of these keys are generated by default when initializing a new trusted collection. The keys are located in the notary &lt;code&gt;trust_dir&lt;/code&gt; directory. In addition, if delegation roles exist, those roles&amp;rsquo; keys are to also managed by the notary client.</source>
          <target state="translated">기본적으로, 공증인 클라이언트는 루트, 대상, 스냅 샷 역할의 개인 키를 관리합니다. 이러한 모든 키는 기본적으로 신뢰할 수있는 새 컬렉션을 초기화 할 때 생성됩니다. 키는 notary &lt;code&gt;trust_dir&lt;/code&gt; 디렉토리에 있습니다. 또한 위임 역할이 존재하는 경우 해당 역할의 키는 공증인 클라이언트가 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7f1f492f89cad94cf3fc4750226e64216f300c7" translate="yes" xml:space="preserve">
          <source>By default, the only things removed are:</source>
          <target state="translated">기본적으로 제거 된 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73318d9b7dbead96a3e980bc9aa9fb5ba9fa819f" translate="yes" xml:space="preserve">
          <source>By default, these pre-defined variables are excluded from the output of &lt;code&gt;docker history&lt;/code&gt;. Excluding them reduces the risk of accidentally leaking sensitive authentication information in an &lt;code&gt;HTTP_PROXY&lt;/code&gt; variable.</source>
          <target state="translated">기본적으로 이러한 사전 정의 된 변수는 &lt;code&gt;docker history&lt;/code&gt; 출력에서 제외됩니다 . 이를 제외하면 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 변수 에서 민감한 인증 정보가 실수로 유출 될 위험이 줄어 듭니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
