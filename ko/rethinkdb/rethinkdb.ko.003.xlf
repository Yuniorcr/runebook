<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="57d32ed6842f8937bfbfb6135067bdf013914ba5" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name ends with an &amp;ldquo;s&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">성이 &quot;s&quot;로 끝나는 모든 사용자를 검색하려면 다음과 같이 &lt;code&gt;r.match&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5955d5b29355702e414b30489a1bf41c4ff4157d" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name starts with &amp;ldquo;Ma&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">성이 &quot;Ma&quot;로 시작하는 모든 사용자를 검색하려면 &lt;code&gt;r.match&lt;/code&gt; 같이 r.match 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0bc2c2dcf06bfff997e2c4a74f6f884030f7aba" translate="yes" xml:space="preserve">
          <source>If you want to use a prefix notation, you just need to implement all the commands on a module. If you want to use an infix notation, you should implement all the functions on a class &amp;ldquo;term&amp;rdquo; and some prefix commands on the module.</source>
          <target state="translated">접두사 표기법을 사용하려면 모듈에서 모든 명령을 구현하면됩니다. 접두사 표기법을 사용하려면 클래스&amp;ldquo;term&amp;rdquo;의 모든 기능과 모듈의 일부 접두사 명령을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="9be25802011254b9d2a1331968b140867a7a3dff" translate="yes" xml:space="preserve">
          <source>If you wanted to receive &lt;em&gt;all&lt;/em&gt; the changes, including the interim states, you could do so by passing &lt;code&gt;squash: false&lt;/code&gt;. The server will buffer up to 100,000 changes. (This number can be changed with the &lt;code&gt;changefeedQueueSize&lt;/code&gt; optional argument.)</source>
          <target state="translated">임시 상태를 포함하여 &lt;em&gt;모든&lt;/em&gt; 변경 사항 을 수신 하려면 &lt;code&gt;squash: false&lt;/code&gt; 를 전달하면됩니다 . 서버는 최대 100,000 개의 변경 사항을 버퍼링합니다. 이 숫자는 &lt;code&gt;changefeedQueueSize&lt;/code&gt; 선택적 인수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bfcf6ae6bbb104a8f2d9363a057e7ab252bf34a" translate="yes" xml:space="preserve">
          <source>If you wish other locations, change the text in the file appropriately.</source>
          <target state="translated">다른 위치를 원하면 파일의 텍스트를 적절하게 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="683e445d7ef31ffd6276aee46241b7bc6d8c2d1d" translate="yes" xml:space="preserve">
          <source>If you wish to find all points within a certain radius of another point, it&amp;rsquo;s often faster to use &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; with &lt;a href=&quot;../circle/index&quot;&gt;circle&lt;/a&gt;, as long as the approximation of a circle that &lt;code&gt;circle&lt;/code&gt; generates is sufficient.</source>
          <target state="translated">다른 지점의 특정 반경 내에있는 모든 점을 발견 할 경우, 사용하는 빠른 자주의 &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting를&lt;/a&gt; 함께 &lt;a href=&quot;../circle/index&quot;&gt;원&lt;/a&gt; 하는 원의 근사 한, &lt;code&gt;circle&lt;/code&gt; 충분하다 생성한다.</target>
        </trans-unit>
        <trans-unit id="7524784d2e4a2810021fbd5dcbfcfdac73a9720d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re doing ad-hoc analysis and know your table won&amp;rsquo;t have more then 100,000 elements (or you&amp;rsquo;ve changed the setting of the &lt;code&gt;array_limit&lt;/code&gt; option for &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;) you can run &lt;code&gt;orderBy&lt;/code&gt; without an index:</source>
          <target state="translated">임시 분석을 수행하고 있고 테이블에 100,000 개 이상의 요소가없는 경우 (또는 &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; 의 &lt;code&gt;array_limit&lt;/code&gt; 옵션 설정을 변경 한 경우 ) 인덱스없이 &lt;code&gt;orderBy&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ff79c17332249a5d857f8a257aa944f0b925e14" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up a cluster in a secure environment (for instance, the whole cluster is on a local network behind a firewall), you can simply start the servers in the cluster without an admin password, then update the &lt;code&gt;admin&lt;/code&gt; record in the &lt;code&gt;users&lt;/code&gt; table with a new password. However, if you&amp;rsquo;re joining a new server to a cluster that&amp;rsquo;s already password-protected, the best way to do it is to specify the &lt;code&gt;--initial-password auto&lt;/code&gt; option.</source>
          <target state="translated">당신이 안전한 환경에서 클러스터를 설정하는 경우, 당신은 단순히 다음 업데이트, 관리자 암호없이 클러스터의 서버를 시작할 수 있습니다 (예를 들어, 전체 클러스터는 방화벽 뒤의 로컬 네트워크에있는) &lt;code&gt;admin&lt;/code&gt; 의 기록을 새로운 비밀번호를 가진 &lt;code&gt;users&lt;/code&gt; 테이블. 그러나 이미 비밀번호로 보호 된 클러스터에 새 서버를 가입시키는 경우 가장 좋은 방법은 &lt;code&gt;--initial-password auto&lt;/code&gt; 옵션 을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="456807bd4deabd7fb0d4e595a0e89ba5793a3a63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re trying to run the RethinkDB JavaScript driver on an older version of Node.js, you might get an error similar to this one:</source>
          <target state="translated">Node.js의 이전 버전에서 RethinkDB JavaScript 드라이버를 실행하려고하면 다음과 유사한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b39a010075ff223dcb6231c15f5807cd083e75c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, the proxy will de-duplicate changefeed messages sent from other cluster nodes, further reducing traffic.</source>
          <target state="translated">&lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds를&lt;/a&gt; 사용하는 경우 프록시는 다른 클러스터 노드에서 전송 된 changefeed 메시지를 중복 제거하여 트래픽을 더욱 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f62e60bf0cc80777903c60849396bf97f6d61d7f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a command that returns a stream and want to retrieve all of its results at once in an array rather than iterating through them with the cursor object, you can coerce it to an array using the &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; command.</source>
          <target state="translated">스트림을 리턴하는 명령을 사용하고 커서 오브젝트로 반복하지 않고 배열에서 모든 결과를 한 번에 검색하려는 경우 &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; 명령을 사용하여 배열로 강제 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacb25a3674084c03c251e600233179fe60bd947" translate="yes" xml:space="preserve">
          <source>If your Linux system uses &lt;code&gt;systemd&lt;/code&gt;, use &lt;code&gt;journalctl&lt;/code&gt; to view the log:</source>
          <target state="translated">Linux 시스템이 &lt;code&gt;systemd&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;journalctl&lt;/code&gt; 을 사용 하여 로그를보십시오.</target>
        </trans-unit>
        <trans-unit id="da2db0981a7397bff51112a1fc945fe4ca7b2b8f" translate="yes" xml:space="preserve">
          <source>If your cluster has at least three servers, then in most cases RethinkDB will be able to perform automatic failover and maintain table availability.</source>
          <target state="translated">클러스터에 서버가 3 대 이상인 경우 대부분의 경우 RethinkDB는 자동 장애 조치를 수행하고 테이블 가용성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49541bdff3c285637a61fef077a63e1f69a37fc" translate="yes" xml:space="preserve">
          <source>If your driver uses infix notation, you must make sure that the &lt;code&gt;VAR&lt;/code&gt; term implements all the ReQL methods.</source>
          <target state="translated">드라이버가 접두사 표기법을 사용하는 경우 &lt;code&gt;VAR&lt;/code&gt; 용어가 모든 ReQL 메소드를 구현 하는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="350e9574e2ae89a26fa9dc3cc454a0ede0acc59d" translate="yes" xml:space="preserve">
          <source>If your network is open to the internet, you should take additional precautions. See the &lt;a href=&quot;../security/index&quot;&gt;security page&lt;/a&gt; for more details.</source>
          <target state="translated">네트워크가 인터넷에 연결되어 있으면 추가 예방 조치를 취해야합니다. 자세한 내용은 &lt;a href=&quot;../security/index&quot;&gt;보안 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="366849b7e0bac319320d290f73d9827bd3539c9b" translate="yes" xml:space="preserve">
          <source>If your platform isn&amp;rsquo;t listed here, you may still be able to build from source. You should be able to build RethinkDB on most Linux-based systems&amp;mdash;check out the generic &lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;build instructions&lt;/a&gt;. If you get RethinkDB running on your platform, please &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;contribute&lt;/a&gt; a package!</source>
          <target state="translated">귀하의 플랫폼이 여기에 나열되지 않은 경우 여전히 소스에서 빌드 할 수 있습니다. 대부분의 Linux 기반 시스템에서 RethinkDB를 빌드 할 수 있어야합니다 . 일반 &lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;빌드 지침을&lt;/a&gt; 확인하십시오 . 당신이 RethinkDB이 당신의 플랫폼에서 실행 얻을, 제발 &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;기여&lt;/a&gt; 패키지를!</target>
        </trans-unit>
        <trans-unit id="23b1ba702365541b74287007a736458d67c4eaea" translate="yes" xml:space="preserve">
          <source>If your program frequently executes a &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt; followed by a &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt;, that operation can be made more efficient by creating a compound multi index using a mapping function on the field that contains the list.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt; 다음에 &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains를&lt;/a&gt; 자주 실행하는 경우 목록이 포함 된 필드에서 맵핑 기능을 사용하여 복합 다중 색인을 작성하면 해당 조작을보다 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f7491313b584ad1d089f9d22913b45b26e6b14" translate="yes" xml:space="preserve">
          <source>If your timestamps are stored with time zones, this query will work even if you have sales from different offices in different countries (assuming they all work 9-5 local time).</source>
          <target state="translated">타임 스탬프가 표준 시간대와 함께 저장되어있는 경우이 쿼리는 다른 국가의 다른 사무실에서 판매 한 경우에도 작동합니다 (모두 9-5 현지 시간으로 작동한다고 가정).</target>
        </trans-unit>
        <trans-unit id="6768eab9c379c5663aede0e10ef2910ddbacc359" translate="yes" xml:space="preserve">
          <source>Ignored host: (remove everything)</source>
          <target state="translated">무시 된 호스트 : (모두 제거)</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="7830d9e83bdb571cca1e50f542e8516184aeb2bf" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="translated">구현 고려 사항</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="48c76de824c667c812b20e68b2adc022b6cc3927" translate="yes" xml:space="preserve">
          <source>Implementing pagination</source>
          <target state="translated">페이지 매김 구현</target>
        </trans-unit>
        <trans-unit id="4b9473d2b75bfa42436746f65c8c33b98460fd54" translate="yes" xml:space="preserve">
          <source>Import the data into the new version of RethinkDB</source>
          <target state="translated">새로운 버전의 RethinkDB로 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="238711b7dea1818e5597c84c0a73743721ecdeb7" translate="yes" xml:space="preserve">
          <source>Import the driver</source>
          <target state="translated">드라이버 가져 오기</target>
        </trans-unit>
        <trans-unit id="017c247df6b2b83d4d9a69a49f09f95bae03a6a1" translate="yes" xml:space="preserve">
          <source>Importing data</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="e2edf793f8ceb332bdd4099e91b0d561315566da" translate="yes" xml:space="preserve">
          <source>Importing from a directory is only supported for directories created by the &lt;code&gt;rethinkdb export&lt;/code&gt; command.</source>
          <target state="translated">디렉토리에서 가져 오기는 &lt;code&gt;rethinkdb export&lt;/code&gt; 명령으로 작성된 디렉토리에 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f1cdd2fcf75bc422b05e6de9e62859e98a52259" translate="yes" xml:space="preserve">
          <source>Importing your data</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="b2365d482c0ea18f41ce8c42a7403d51a41e4cae" translate="yes" xml:space="preserve">
          <source>Improve this doc</source>
          <target state="translated">이 문서 개선</target>
        </trans-unit>
        <trans-unit id="a2b4972775d63230221d59d42b6e919bd9b4dc33" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;saveFile&lt;/code&gt;, we pass a path to the uploaded file (which may be in a temporary storage directory, even with a temporary name depending on the uploading library we&amp;rsquo;ve used), the name to save the file with, and the id of the user who&amp;rsquo;s uploaded the file. The &lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;binary&lt;/a&gt; ReQL command is used to store the file&amp;rsquo;s contents as a binary object in the &lt;code&gt;file&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;saveFile&lt;/code&gt; 에서는 업로드 한 파일의 경로 (사용한 업로드 라이브러리에 따라 임시 이름이 있더라도 임시 저장 디렉토리에있을 수 있음), 파일을 저장할 이름 및 ID 파일을 업로드 한 사용자 &lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;진&lt;/a&gt; ReQL 명령은의 이진 개체로 파일의 내용을 저장하는 데 사용되는 &lt;code&gt;file&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="ab75b66b21721ea02b5f1190366112cfa1b49ce9" translate="yes" xml:space="preserve">
          <source>In JavaScript you can use the operator &lt;code&gt;()&lt;/code&gt; to get the value of a field. This operator can be chained to retrieve values from nested fields.</source>
          <target state="translated">JavaScript에서는 연산자 &lt;code&gt;()&lt;/code&gt; 를 사용하여 필드 값을 얻을 수 있습니다. 이 연산자는 연결되어 중첩 된 필드에서 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8d71b1ae4e957e1c701dd6a29e28ae62e6fa5a" translate="yes" xml:space="preserve">
          <source>In ReQL, you can chain commands at the end of other commands using the &lt;code&gt;.&lt;/code&gt; operator:</source>
          <target state="translated">ReQL에서는을 사용하여 다른 명령 끝에 명령을 연결할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 운영자:</target>
        </trans-unit>
        <trans-unit id="d7e11373b98a35ae62612e925d7efc50e57e385c" translate="yes" xml:space="preserve">
          <source>In RethinkDB, if there is a network partition, the behavior of the system from any given client&amp;rsquo;s perspective depends on which side of the netsplit that client is on. If the client is on the same side of the netsplit as the majority of voting replicas for the shard the client is trying to reach, it will continue operating without any problems. If the client is on the side of the netsplit with half or fewer of the voting replicas for the shard the client is trying to reach, the client&amp;rsquo;s up-to-date queries and write queries will encounter a failure of availability. For example, if the client is running an up-to-date range query that spans multiple shards, the primaries for all shards must be on the same side of the netsplit as the client, or the client will encounter a failure of availability.</source>
          <target state="translated">RethinkDB에서 네트워크 파티션이있는 경우, 주어진 클라이언트 관점에서 시스템의 동작은 클라이언트가있는 netsplit의 측면에 따라 다릅니다. 클라이언트가 도달하려는 샤드에 대한 대부분의 투표 복제본과 클라이언트가 netsplit의 같은쪽에 있으면 아무런 문제없이 계속 작동합니다. 클라이언트가 도달하려는 샤드에 대한 투표 복제본의 절반 이하로 Netsplit의 측면에있는 경우 클라이언트의 최신 쿼리 및 쓰기 쿼리에 가용성 오류가 발생합니다. 예를 들어, 클라이언트가 여러 샤드에 걸쳐있는 최신 범위 쿼리를 실행중인 경우 모든 샤드의 기본 서버는 클라이언트와 동일한 넷 분할 측에 있어야합니다. 그렇지 않으면 클라이언트에 가용성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53975b0e82ce0d86ca8d9057bdbb663e9bcafe56" translate="yes" xml:space="preserve">
          <source>In RethinkDB, map-reduce queries operate on sequences and are composed of two or three parts:</source>
          <target state="translated">RethinkDB에서 map-reduce 쿼리는 시퀀스에서 작동하며 두 부분 또는 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e547e43d492374793f980136c4cf014cfc49388d" translate="yes" xml:space="preserve">
          <source>In Ruby, you would use a block:</source>
          <target state="translated">루비에서는 다음과 같은 블록을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f616f120c6b02696c4b0366e3aece768d2e56d2" translate="yes" xml:space="preserve">
          <source>In a many to many relation, we can use multiple &lt;code&gt;eq_join&lt;/code&gt; commands to join the data from all three tables:</source>
          <target state="translated">다 대다 관계에서 여러 &lt;code&gt;eq_join&lt;/code&gt; 명령을 사용하여 세 테이블 모두의 데이터를 조인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a1f7a4ae7bafa4f994ca4dcbba5e5033b936cc" translate="yes" xml:space="preserve">
          <source>In a relational database, we&amp;rsquo;d use a &lt;code&gt;JOIN&lt;/code&gt; here; in RethinkDB, we use the &lt;code&gt;eq_join&lt;/code&gt; command. To get all posts along with the author information for William Adama:</source>
          <target state="translated">관계형 데이터베이스에서는 여기 에 &lt;code&gt;JOIN&lt;/code&gt; 을 사용합니다 . RethinkDB에서는 &lt;code&gt;eq_join&lt;/code&gt; 명령 을 사용합니다 . William Adama의 저자 정보와 함께 모든 게시물을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="0017c83cf17c2e2c74f552cbefb9d78035ec322b" translate="yes" xml:space="preserve">
          <source>In addition to commands described here, ReQL supports a number of sophisticated commands that are composable similarly to the commands described here. See the following documentation for more details:</source>
          <target state="translated">여기에 설명 된 명령 외에도 ReQL은 여기에 설명 된 명령과 유사하게 구성 할 수있는 여러 가지 정교한 명령을 지원합니다. 자세한 내용은 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69b56eab4e915ecae6acc17c1b920e1f95e8dda6" translate="yes" xml:space="preserve">
          <source>In addition to the simple &lt;code&gt;on_val&lt;/code&gt; method, you can provide methods that specifically apply to arrays, streams and atoms.</source>
          <target state="translated">간단한 &lt;code&gt;on_val&lt;/code&gt; 메소드 외에도 배열, 스트림 및 원자에 특별히 적용되는 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e832c720b5396283b4982d091435fc8a17a57bae" translate="yes" xml:space="preserve">
          <source>In addition, RethinkDB&amp;rsquo;s cursors and feeds implement an &lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter interface&lt;/a&gt; compatible with Node&amp;rsquo;s. This allows your application to set up listeners to receive data from queries as the data becomes available.</source>
          <target state="translated">또한 RethinkDB의 커서 및 피드 는 노드와 호환 되는 &lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter 인터페이스&lt;/a&gt; 를 구현합니다 . 이를 통해 애플리케이션은 데이터가 사용 가능 해지면 쿼리에서 데이터를 수신하도록 리스너를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac43c6179eddd9e0aa83a1d0f3a033887a74a4d9" translate="yes" xml:space="preserve">
          <source>In addition, like most NoSQL systems, RethinkDB does not support updating multiple documents atomically.</source>
          <target state="translated">또한 대부분의 NoSQL 시스템과 마찬가지로 RethinkDB는 여러 문서를 원자 적으로 업데이트하는 것을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482ca37f4f75fe52405c7f2363070d3ac96941cf" translate="yes" xml:space="preserve">
          <source>In addition, the following two fields are set as circumstances dictate:</source>
          <target state="translated">또한 상황에 따라 다음 두 필드가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dfeb6cb29bcc9b1be788874544634d9e422e0566" translate="yes" xml:space="preserve">
          <source>In addition, there are changefeed-specific methods that may be defined.</source>
          <target state="translated">또한 정의 할 수있는 변경 피드 별 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9c26359d4eb826c3e725e35c3b93e27549d853" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;geometry&lt;/strong&gt; which appears in documentation, to indicate that any of the geometric objects can be used with those commands.</source>
          <target state="translated">또한, &lt;strong&gt;지오메트리&lt;/strong&gt; 라는 &quot;의사 유형&quot;이 있는데,이 명령에는 기하학적 객체를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="98129ae214b9438711e0e318ef2278075825e480" translate="yes" xml:space="preserve">
          <source>In both cases, each documents is a JSON object, bracketed with &lt;code&gt;{}&lt;/code&gt; characters. Only the first format is itself a valid JSON document, but RethinkDB will import documents properly either way.</source>
          <target state="translated">두 경우 모두 각 문서는 &lt;code&gt;{}&lt;/code&gt; 문자 로 묶인 JSON 객체 입니다. 첫 번째 형식 만 유효한 JSON 문서이지만 RethinkDB는 문서를 올바르게 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b0a086d5882f5f0f06698c6203f1af04758586d8" translate="yes" xml:space="preserve">
          <source>In cases where it matters, the system should give administrators fine-tuned control, such as pinning specific primary and secondary replicas to specific servers in the cluster.</source>
          <target state="translated">중요한 경우 시스템은 관리자에게 특정 기본 및 보조 복제본을 클러스터의 특정 서버에 고정하는 등의 미세 조정 된 제어 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b00ccdfaea40371a01b81bb7dc1bad4ad740441" translate="yes" xml:space="preserve">
          <source>In each configuration file, set a different data directory, and include the &lt;code&gt;join&lt;/code&gt; configuration option for each node with the IP address and port of another node in the cluster. If the instances are not running on the same machine, specify &lt;code&gt;bind=all&lt;/code&gt; in the configuration file (or &lt;code&gt;--bind all&lt;/code&gt; on the command line). Take care that each instance on the same machine specifies different values for &lt;code&gt;driver-port&lt;/code&gt;, &lt;code&gt;cluster-port&lt;/code&gt; and &lt;code&gt;http-port&lt;/code&gt;.</source>
          <target state="translated">각 구성 파일에서 다른 데이터 디렉토리를 설정 하고 클러스터에있는 다른 노드의 IP 주소 및 포트를 사용하여 각 노드에 대한 &lt;code&gt;join&lt;/code&gt; 구성 옵션을 포함하십시오 . 인스턴스가 동일한 시스템에서 실행되지 않는 경우 구성 파일에서 &lt;code&gt;bind=all&lt;/code&gt; 을 지정 하십시오 (또는 명령 행에서 &lt;code&gt;--bind all&lt;/code&gt; ). 동일한 시스템의 각 인스턴스가 &lt;code&gt;driver-port&lt;/code&gt; , &lt;code&gt;cluster-port&lt;/code&gt; 및 &lt;code&gt;http-port&lt;/code&gt; 에 다른 값을 지정하도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3aa8875b25a2ffc4aedb33806133ea9bef7d9c" translate="yes" xml:space="preserve">
          <source>In general, operations on grouped streams will be efficiently distributed, and operations on grouped data won&amp;rsquo;t be. You can figure out what you&amp;rsquo;re working with by putting &lt;code&gt;typeOf&lt;/code&gt; on the end of your query. Below are efficient and inefficient examples.</source>
          <target state="translated">일반적으로 그룹화 된 스트림에 대한 작업은 효율적으로 분산되며 그룹화 된 데이터에 대한 작업은 분산되지 않습니다. 쿼리 끝에 &lt;code&gt;typeOf&lt;/code&gt; 를 넣어서 작업 내용을 파악할 수 있습니다. 아래는 효율적이고 비효율적 인 예입니다.</target>
        </trans-unit>
        <trans-unit id="f054beb39982d96498daad23e2a815f6da2c843d" translate="yes" xml:space="preserve">
          <source>In general, you&amp;rsquo;ll have to follow these steps:</source>
          <target state="translated">일반적으로 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="de3c73ba8ae404d459a86a8fedcb02be56388736" translate="yes" xml:space="preserve">
          <source>In its first form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt;, returning a value by applying a combining function to each element in a sequence. The combining function takes two parameters: the previous reduction result (the accumulator) and the current element. However, &lt;code&gt;fold&lt;/code&gt; has the following differences from &lt;code&gt;reduce&lt;/code&gt;:</source>
          <target state="translated">첫 번째 형태에서 &lt;code&gt;fold&lt;/code&gt; 는 &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt; 와 같이 작동 하여 시퀀스의 각 요소에 결합 함수를 적용하여 값을 반환합니다. 결합 기능은 이전 감소 결과 (누산기)와 현재 요소의 두 가지 매개 변수를 사용합니다. 그러나 &lt;code&gt;fold&lt;/code&gt; 에는 축소 와 다음과 같은 차이점이 &lt;code&gt;reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3984a5dbbfd384237df25b964a2fe7964065b882" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;, returning a new sequence rather than a single value. When an &lt;code&gt;emit&lt;/code&gt; function is provided, &lt;code&gt;fold&lt;/code&gt; will:</source>
          <target state="translated">두 번째 형식에서 &lt;code&gt;fold&lt;/code&gt; 는 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; 과 같이 작동 하여 단일 값이 아닌 새로운 시퀀스를 반환합니다. 때 &lt;code&gt;emit&lt;/code&gt; 기능이 제공되고, &lt;code&gt;fold&lt;/code&gt; 의지 :</target>
        </trans-unit>
        <trans-unit id="f1803506720787d5029fd735e7823ff69080cca3" translate="yes" xml:space="preserve">
          <source>In most circumstances, automatic failover can be performed as long as a majority of voting replicas are available. However, one circumstance in which it may not be performed is a non-transitive connectivity failure. Imagine a cluster with three servers: A, B, and C. Under normal network operations, all of the servers can connect to one another. If a network failure occurs such that A can connect to B and B can connect to C, but A cannot connect to C, the network failure is non-transitive. For a more in-depth description, as well as progress on a long-term solution, read &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github issue #4357&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 대부분의 투표 복제본을 사용할 수있는 한 자동 장애 조치를 수행 할 수 있습니다. 그러나 수행되지 않을 수있는 한 가지 상황은 비 일시적 연결 실패입니다. 세 개의 서버 A, B 및 C가있는 클러스터를 상상해보십시오. 정상적인 네트워크 작동 상태에서 모든 서버는 서로 연결할 수 있습니다. A가 B에 연결할 수 있고 B가 C에 연결할 수있는 네트워크 장애가 발생하는 경우 A가 C에 연결할 수없는 경우 네트워크 장애는 전이되지 않습니다. 보다 자세한 설명과 장기 솔루션의 진행 상황에 대해서는 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github Issue # 4357을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd2d7923eb0bc8efca1cb651f85d4797323b30ae" translate="yes" xml:space="preserve">
          <source>In normal operation, &lt;code&gt;single&lt;/code&gt; read mode produces the same results as &lt;code&gt;majority&lt;/code&gt; read mode, but it might return outdated results in the event of a network failure or crash. It&amp;rsquo;s also possible that a read run in &lt;code&gt;single&lt;/code&gt; mode could return results from an incomplete write that is later rolled back.</source>
          <target state="translated">정상 작동에서 &lt;code&gt;single&lt;/code&gt; 읽기 모드는 &lt;code&gt;majority&lt;/code&gt; 읽기 모드 와 동일한 결과를 생성 하지만 네트워크 장애 나 충돌시 오래된 결과를 반환 할 수 있습니다. &lt;code&gt;single&lt;/code&gt; 모드 에서 읽기 실행을 수행 하면 나중에 롤백 된 불완전한 쓰기의 결과가 반환 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae45c6d0609936a00a819d3d51967b8a8050e205" translate="yes" xml:space="preserve">
          <source>In order to model this data we&amp;rsquo;d create three tables&amp;mdash;&lt;code&gt;authors&lt;/code&gt;, &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;authors_posts&lt;/code&gt;, similarly to how we&amp;rsquo;d do it in a relational system. Here is example data for the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">이 데이터를 모델링하기 위해 관계형 시스템에서 수행하는 방식과 유사하게 &lt;code&gt;authors&lt;/code&gt; , &lt;code&gt;posts&lt;/code&gt; 및 &lt;code&gt;authors_posts&lt;/code&gt; 의 세 가지 테이블을 만듭니다 . 다음은 &lt;code&gt;authors&lt;/code&gt; 테이블의 데이터 예입니다 .</target>
        </trans-unit>
        <trans-unit id="97a88b12b94723a393b40b35de02068c1acae898" translate="yes" xml:space="preserve">
          <source>In other words, ReQL queries that involve multiple shards will be processed on those shards whenever possible.</source>
          <target state="translated">즉, 여러 샤드가 포함 된 ReQL 쿼리는 가능할 때마다 해당 샤드에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afd135582e47c109847489d0def7f5b6eefbf292" translate="yes" xml:space="preserve">
          <source>In production, you&amp;rsquo;d likely want to specify options via configuration files rather than command line options; read the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation for details on the format and available options. Also, you&amp;rsquo;d want your RethinkDB instances to come online at system startup. See &lt;a href=&quot;../start-on-startup/index&quot;&gt;Start RethinkDB at system startup&lt;/a&gt; to learn how to set up RethinkDB with &lt;code&gt;init.d&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;.</source>
          <target state="translated">프로덕션 환경에서는 명령 줄 옵션이 아닌 구성 파일을 통해 옵션을 지정하려고합니다. 형식 및 사용 가능한 옵션에 대한 자세한 내용 은 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일&lt;/a&gt; 설명서를 읽으십시오 . 또한 시스템 시작시 RethinkDB 인스턴스가 온라인 상태가되기를 원합니다. &lt;code&gt;init.d&lt;/code&gt; 또는 &lt;code&gt;systemd&lt;/code&gt; 로 RethinkDB를 설정하는 방법을 배우려면 &lt;a href=&quot;../start-on-startup/index&quot;&gt;시스템 시작시 RethinkDB 시작을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0dc7c6b334bc6af46a97821423466554f645dd8" translate="yes" xml:space="preserve">
          <source>In soft durability mode RethinkDB will acknowledge the write immediately after receiving it, but before the write has been committed to disk.</source>
          <target state="translated">소프트 내구성 모드에서 RethinkDB는 쓰기를받은 직후, 쓰기가 디스크에 커밋되기 전에 쓰기를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="5e7d59ad6bb744097a2528372b93cd92bdc3e075" translate="yes" xml:space="preserve">
          <source>In terms of hardware, we used the &lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;OnMetal offerings from Rackspace&lt;/a&gt; to run both RethinkDB server and RethinkDB client nodes. We used different hardware configurations for the server and client nodes as shown below:</source>
          <target state="translated">하드웨어 측면 &lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;에서 Rackspace&lt;/a&gt; 의 OnMetal 제품을 사용하여 RethinkDB 서버와 RethinkDB 클라이언트 노드를 모두 실행했습니다. 아래와 같이 서버 및 클라이언트 노드에 서로 다른 하드웨어 구성을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="cb384544524d3d59795f35c682141659070ffc05" translate="yes" xml:space="preserve">
          <source>In terms of latency, we found that in a 16-node cluster and forbidding stale reads, the 95th percentile for latency is 3ms. When doing a heavy read workload, a large majority of reads fell between 0ms and 1ms which can be seen in the graph below.</source>
          <target state="translated">대기 시간 측면에서, 16 ​​노드 클러스터 및 오래된 읽기 금지에서 대기 시간의 95 번째 백분위 수는 3ms입니다. 많은 양의 읽기 작업을 수행 할 때 대부분의 읽기는 0ms에서 1ms 사이로 떨어졌으며 아래 그래프에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a92dff43ec5bf76e7d231b5b621039bca24c72" translate="yes" xml:space="preserve">
          <source>In that example, when you&amp;rsquo;re trying to get at just one value, the JSON style doesn&amp;rsquo;t offer much advantage. But you can use it to retrieve &lt;em&gt;multiple&lt;/em&gt; values at the same nesting level. For instance, you can get just Bob&amp;rsquo;s work and cell numbers, but not home:</source>
          <target state="translated">이 예에서 단 하나의 값을 얻으려고 할 때 JSON 스타일은 큰 이점을 제공하지 않습니다. 그러나이를 사용 하여 동일한 중첩 수준에서 &lt;em&gt;여러&lt;/em&gt; 값 을 검색 할 수 있습니다 . 예를 들어, Bob의 직장과 휴대 전화 번호 만 얻을 수 있지만 집은 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b85b37e8a9ef902d18f0effb8b8b0a5e0b487" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;asynchronous&amp;rdquo; test, reads use the &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;비동기&quot;테스트에서 읽기는 &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="224e33b3ae99c46077d788fc2cbcfc0ec642f4c2" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;synchronous&amp;rdquo; test, we use the default &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;동기&quot;테스트에서는 기본 &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d0c0068240942eeaad5904125996b7f2b3d6ea1f" translate="yes" xml:space="preserve">
          <source>In the Data Explorer, the following command will output the contents of all the configuration/status tables and the most recent 50 lines of the &lt;code&gt;logs&lt;/code&gt; table:</source>
          <target state="translated">데이터 탐색기에서 다음 명령은 모든 구성 / 상태 테이블의 내용과 &lt;code&gt;logs&lt;/code&gt; 테이블 의 최신 50 행을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="0f2e3061797f8ffc035d338c6ee005215f806609" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation and some error messages, you&amp;rsquo;ll come across terms for &amp;ldquo;data types&amp;rdquo; that are actually &lt;em&gt;classes&lt;/em&gt; of other data types.</source>
          <target state="translated">ReQL API 설명서 및 일부 오류 메시지에는 실제로 다른 데이터 유형의 &lt;em&gt;클래스&lt;/em&gt; 인 &quot;데이터 유형&quot;에 대한 용어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8918357e3571d7f57170387ccdf371596278a850" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation you&amp;rsquo;ll also see a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;Geometry,&lt;/strong&gt; which is a collective for all of the geometry data types. Those commands will work with points, lines and polygons.</source>
          <target state="translated">ReQL API 설명서에는 &lt;strong&gt;Geometry&lt;/strong&gt; 라고하는&amp;ldquo;의사 유형&amp;rdquo;도 있습니다. 이는 모든 기하학 데이터 유형에 대한 집합입니다. 이러한 명령은 점, 선 및 다각형에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50f6c67f7c1dbf2748240f51a04ec169aff9a6b9" translate="yes" xml:space="preserve">
          <source>In the case of nested functions, the &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term is ambiguous, and should not be used. Your driver should either throw an error or let the server return an error.</source>
          <target state="translated">중첩 함수의 경우 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 용어는 모호하므로 사용해서는 안됩니다. 드라이버가 오류를 발생 시키거나 서버가 오류를 반환하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="84e483a5ecf212378a48f1669d098b93f94aaf23" translate="yes" xml:space="preserve">
          <source>In the case of the first source, every database process uses memory to store intermediate results and to maintain internal state. The memory used varies significantly depending on the type of queries run and the size of documents stored in the database. As a rough estimate, expect each query and background process to use 1&amp;ndash;20 MB of memory.</source>
          <target state="translated">첫 번째 소스의 경우 모든 데이터베이스 프로세스는 메모리를 사용하여 중간 결과를 저장하고 내부 상태를 유지합니다. 사용되는 메모리는 실행되는 쿼리 유형과 데이터베이스에 저장된 문서 크기에 따라 크게 다릅니다. 대략적인 추정으로 각 쿼리 및 백그라운드 프로세스는 1-20MB의 메모리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bcb70dff2e48b1f52037256b865f5a9417b2b37" translate="yes" xml:space="preserve">
          <source>In the form above&amp;mdash;with a block that accepts a single argument&amp;mdash;RethinkDB&amp;rsquo;s EventMachine adapter will throw errors back up to your application for you to handle in the same fashion as you would using RethinkDB without EventMachine. If the table &lt;code&gt;test&lt;/code&gt; did not exist in the database above, you would receive the standard &lt;code&gt;ReqlRunTimeError&lt;/code&gt;:</source>
          <target state="translated">RethinkDB의 EventMachine 어댑터는 위의 형식 (단일 인수를 허용하는 블록)으로 EventMachine없이 RethinkDB를 사용하는 것과 같은 방식으로 처리 할 수 ​​있도록 응용 프로그램에 오류를 다시 발생시킵니다. 위의 데이터베이스에 테이블 &lt;code&gt;test&lt;/code&gt; 가 없으면 표준 &lt;code&gt;ReqlRunTimeError&lt;/code&gt; 가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9ec0b06d735bfc391094860e46de01fa59f75cec" translate="yes" xml:space="preserve">
          <source>In the results, we&amp;rsquo;ll see how RethinkDB scales to perform 1.3 million individual reads per second. We will also demonstrate how RethinkDB performs well above 100 thousand operations per second in a mixed 50:50 read/write workload - while at the full level of durability and data integrity guarantees. We performed all benchmarks across a range of cluster sizes, scaling up from one to 16 nodes.</source>
          <target state="translated">결과에서 RethinkDB가 초당 130 만 개인 읽기를 수행하도록 확장되는 방법을 볼 수 있습니다. 또한 50:50 혼합 읽기 / 쓰기 워크로드에서 RethinkDB가 초당 10 만 번 이상의 작업을 수행하는 동시에 전체 수준의 내구성과 데이터 무결성을 보장하는 방법을 보여줍니다. 우리는 1 ~ 16 개의 노드로 확장하여 다양한 클러스터 크기에서 모든 벤치 마크를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="effef7fb5159ccc0efbb8a008e85c758abcdaa0d" translate="yes" xml:space="preserve">
          <source>In the second example, the two replicas in the &lt;code&gt;us&lt;/code&gt; group may be on any of the four servers in the United States.</source>
          <target state="translated">두 번째 예에서 &lt;code&gt;us&lt;/code&gt; 그룹 의 두 복제본 은 미국의 네 서버 중 하나에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd1292a9ca18510e97840764bd37257fdac0d158" translate="yes" xml:space="preserve">
          <source>In the subscribing application we need to create a queue to receive and buffer messages. The queue takes a ReQL filtering function as an argument. This is similar to what you would pass to &lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;filter&lt;/a&gt;. Here we&amp;rsquo;ll subscribe to all messages about superhero fights:</source>
          <target state="translated">구독 애플리케이션에서 메시지를 수신하고 버퍼링 할 큐를 작성해야합니다. 대기열은 ReQL 필터링 기능을 인수로 사용합니다. 이것은 &lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;필터에&lt;/a&gt; 전달할 것과 유사합니다 . 다음은 슈퍼 히어로 싸움에 대한 모든 메시지를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="79b11bb5d26c6627628246b9b4da08bc855ecd84" translate="yes" xml:space="preserve">
          <source>In this case, the predicate &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the field &lt;code&gt;age&lt;/code&gt; is equal to 30. You can write this predicate as an anonymous function instead:</source>
          <target state="translated">이 경우, 술어 &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; 은 필드 &lt;code&gt;age&lt;/code&gt; 가 30 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 대신이 술어를 익명 함수로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d73c774a9ee763c700413c07c0009819356017" translate="yes" xml:space="preserve">
          <source>In this case, we would only receive notifications of fights involving a superhero. Fights between supervillains would be ignored.</source>
          <target state="translated">이 경우, 슈퍼 히어로와의 싸움에 대한 알림 만받습니다. 슈퍼 빌런들 간의 싸움은 무시 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="895f4bd40e5222929c7fb08157cbd280981cabbc" translate="yes" xml:space="preserve">
          <source>In this case, we&amp;rsquo;re using a predicate that returns &lt;code&gt;true&lt;/code&gt; only if the length of the array in the field &lt;code&gt;posts&lt;/code&gt; is greater than two. This predicate contains two commands we haven&amp;rsquo;t seen before:</source>
          <target state="translated">이 경우 필드 &lt;code&gt;posts&lt;/code&gt; 의 배열 길이 가 2보다 큰 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환하는 조건자를 사용합니다 . 이 술어에는 이전에 보지 못한 두 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b372f7d94072c06cbc703d33f6f2f5eb322d59ab" translate="yes" xml:space="preserve">
          <source>In this case, you can do a pivot operation with the &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;coerceTo&lt;/code&gt; commands.</source>
          <target state="translated">이 경우 &lt;code&gt;group&lt;/code&gt; 및 &lt;code&gt;coerceTo&lt;/code&gt; 명령 으로 피벗 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="932455af624242d4d4e2291c9afaaa19c3951b01" translate="yes" xml:space="preserve">
          <source>In this example, we count the number of sentences over the whole data set of 25 million documents based on one of the fields. We use the following exact query which utilizes the map and sum (reduce) functions of ReQL:</source>
          <target state="translated">이 예에서는 필드 중 하나를 기준으로 2,500 만 개의 문서 전체 데이터 세트에 대한 문장 수를 계산합니다. ReQL의 맵 및 합계 (축소) 기능을 활용하는 다음과 같은 정확한 쿼리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5a837ef70a876172728ac7037ebd677f98962f1e" translate="yes" xml:space="preserve">
          <source>In this form, the block will receive &lt;code&gt;nil&lt;/code&gt; as the first argument if there is no error. In the case of an error, the second argument will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 형식에서 오류가 없으면 블록은 첫 번째 인수로 &lt;code&gt;nil&lt;/code&gt; 을 받습니다 . 오류가 발생한 경우 두 번째 인수는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="558ef6c0550627ce8d41470ac5b93bdfb82caa5b" translate="yes" xml:space="preserve">
          <source>In this guide we look at what RethinkDB uses memory for, how we can estimate the amount needed, and how to configure the size of RethinkDB&amp;rsquo;s page cache.</source>
          <target state="translated">이 안내서에서는 RethinkDB가 메모리를 사용하는 용도, 필요한 양을 추정하는 방법 및 RethinkDB의 페이지 캐시 크기를 구성하는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="26ea7c60ff32fa4b3e8fefeb9a9dc71af8af950d" translate="yes" xml:space="preserve">
          <source>In-depth description of the RabbitMQ model</source>
          <target state="translated">RabbitMQ 모델에 대한 자세한 설명</target>
        </trans-unit>
        <trans-unit id="6c1c63beb34300ba0d002edb636ab37ff5010363" translate="yes" xml:space="preserve">
          <source>Includes scripts for building an image for Docker with RethinkDB (and other things).</source>
          <target state="translated">RethinkDB 및 기타 사항을 사용하여 Docker의 이미지를 작성하는 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5714de2ace97726c8558fc98cd998b375aeaa197" translate="yes" xml:space="preserve">
          <source>Including initial values</source>
          <target state="translated">초기 값 포함</target>
        </trans-unit>
        <trans-unit id="0e1b750635a22beeae4a57fea2a9554b63dc760b" translate="yes" xml:space="preserve">
          <source>Including result types</source>
          <target state="translated">결과 유형 포함</target>
        </trans-unit>
        <trans-unit id="a4dfbecd4fe9a9b9f9a34ada5173cbb0a60fca4a" translate="yes" xml:space="preserve">
          <source>Including state changes</source>
          <target state="translated">상태 변경 포함</target>
        </trans-unit>
        <trans-unit id="0777c09113ddc3b67cd50cd499a4890c5b231cf0" translate="yes" xml:space="preserve">
          <source>Including the &lt;code&gt;type&lt;/code&gt; field can simplify code that handles different cases for changefeed results.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 필드를 포함하면 변경 피드 결과에 대한 다양한 사례를 처리하는 코드를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4527e9704b753e001f3be370d293684ea1fc9ebc" translate="yes" xml:space="preserve">
          <source>Increasing the number of shards on an empty table, then using non-UUID primary keys in that table</source>
          <target state="translated">빈 테이블에서 샤드 수 늘리기 및 해당 테이블에서 UUID 이외의 기본 키 사용</target>
        </trans-unit>
        <trans-unit id="ea06f91098e8943020ff7f86773b8606b3f3f7a0" translate="yes" xml:space="preserve">
          <source>Incrementing a field value</source>
          <target state="translated">필드 값 증가</target>
        </trans-unit>
        <trans-unit id="c95a80f91577f1b4f75e07f8b821d9e8943fe898" translate="yes" xml:space="preserve">
          <source>Indexes (both secondary and primary) are guaranteed to be updated by successful write operations. If an &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; operation is successful, the change will be correctly reflected in the index. (Read about RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for write operations.)</source>
          <target state="translated">쓰기 작업이 성공적으로 수행되면 인덱스 (보조 및 주)가 모두 업데이트됩니다. 는 IF &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 작업이 성공, 변경 사항이 제대로 인덱스에 반영됩니다. ( 쓰기 작업 에 대한 RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;일관성 보장&lt;/a&gt; 에 대해 읽으십시오 .)</target>
        </trans-unit>
        <trans-unit id="0391e1ecda549a694d60dcf43663ae1c4ada2850" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;em&gt;arbitrary expressions&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;임의의 표현&lt;/em&gt; 에 기반한 인덱스 .</target>
        </trans-unit>
        <trans-unit id="5758991da81d866c69900c0ad779d0d61274c0f9" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;strong&gt;arbitrary expressions&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;임의의 표현&lt;/strong&gt; 에 기반한 인덱스 .</target>
        </trans-unit>
        <trans-unit id="cfa5fc5368d198722219726949e2bbad91dda010" translate="yes" xml:space="preserve">
          <source>Indexes built with an older version of RethinkDB need to be rebuilt due to changes in the way ReQL handles indexing. See &amp;ldquo;&lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;My secondary index is outdated&lt;/a&gt;&amp;rdquo; for details on how to rebuild indexes.</source>
          <target state="translated">ReQL에서 색인 처리를 처리하는 방식이 변경되어 이전 버전의 RethinkDB로 작성된 색인을 다시 작성해야합니다. &lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;인덱스&lt;/a&gt; 를 다시 작성하는 방법에 대한 자세한 내용 은 &amp;ldquo; 보조 인덱스가 오래되었습니다 &amp;rdquo;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1609b5c345fc2347a59a738ac67f1b56e06b94a" translate="yes" xml:space="preserve">
          <source>Indexes on arbitrary ReQL expressions</source>
          <target state="translated">임의의 ReQL 표현식에 대한 색인</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="043018f3a2dce17d498788f43e79b4e219d2416a" translate="yes" xml:space="preserve">
          <source>Information about the cluster and all operations on the cluster should be programmatically accessible.</source>
          <target state="translated">클러스터 및 클러스터의 모든 작업에 대한 정보는 프로그래밍 방식으로 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5abeab7792567877161cdefc7357d62712b8d656" translate="yes" xml:space="preserve">
          <source>Information about the server:</source>
          <target state="translated">서버에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="f9ec4176c4501a5a0d6dc615f46d39b3af2491e2" translate="yes" xml:space="preserve">
          <source>Initial state (&lt;code&gt;old_val&lt;/code&gt;)</source>
          <target state="translated">초기 상태 ( &lt;code&gt;old_val&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2eea430756a8711c4e7806f52c9877e92ac65847" translate="yes" xml:space="preserve">
          <source>Initial steps</source>
          <target state="translated">초기 단계</target>
        </trans-unit>
        <trans-unit id="80505361d6e27b7e0ae3d35e93853b22f2675393" translate="yes" xml:space="preserve">
          <source>Insert a value in to an array at a given index. Returns the modified array.</source>
          <target state="translated">주어진 인덱스에서 배열에 값을 삽입하십시오. 수정 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8eba2c9cbef2976d5ebdfcd90efdd1990cc6029" translate="yes" xml:space="preserve">
          <source>Insert data</source>
          <target state="translated">데이터 삽입</target>
        </trans-unit>
        <trans-unit id="8a47f8d72661f904ca4e211f6a9e1f8c9c152b3a" translate="yes" xml:space="preserve">
          <source>Insert documents into a table. Accepts a single document or an array of documents.</source>
          <target state="translated">문서를 테이블에 삽입하십시오. 단일 문서 또는 문서 배열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ac0b22d784ef13cc442529b0995c912c4dcd2b31" translate="yes" xml:space="preserve">
          <source>Insert returns an object that contains the following attributes:</source>
          <target state="translated">Insert는 다음 속성이 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65a6ea576f847d46029b82648e01c9ba3de063ca" translate="yes" xml:space="preserve">
          <source>Insert several values in to an array at a given index. Returns the modified array.</source>
          <target state="translated">주어진 인덱스의 배열에 여러 값을 삽입하십시오. 수정 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2d0c213ca368674692f81a4b603c53678e69fc3" translate="yes" xml:space="preserve">
          <source>Inserting documents</source>
          <target state="translated">문서 삽입</target>
        </trans-unit>
        <trans-unit id="29b8d93e8ca73ad1184f047cbc37d36c670720a4" translate="yes" xml:space="preserve">
          <source>Inserting times</source>
          <target state="translated">삽입 시간</target>
        </trans-unit>
        <trans-unit id="ec5593e73134544c0d12300a4f2f2bdea2b1ab11" translate="yes" xml:space="preserve">
          <source>Instagram PubSubHubbub</source>
          <target state="translated">Instagram PubSubHubbub</target>
        </trans-unit>
        <trans-unit id="3cc343c3aa41172c7a302bc5bb30b454ee61655b" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt; 설치</target>
        </trans-unit>
        <trans-unit id="eea9f12452b1397d31321dc6aae0063da202053c" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;amqplib&lt;/a&gt;, a RabbitMQ library for NodeJS</source>
          <target state="translated">&lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;NodeJS&lt;/a&gt; 용 RabbitMQ 라이브러리 amqplib 설치</target>
        </trans-unit>
        <trans-unit id="0e26578d0a3c30b7cc1f3e97e04029b42bb08700" translate="yes" xml:space="preserve">
          <source>Install RethinkDB</source>
          <target state="translated">RethinkDB 설치</target>
        </trans-unit>
        <trans-unit id="32dacb2f0cddc3948aa2de26d4c1fa81e213e4a7" translate="yes" xml:space="preserve">
          <source>Install RethinkDB as a service for your operating system. (This document describes how to do that for both &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;systemd&lt;/code&gt;-based Linux distributions, as well as OS X using &lt;code&gt;launchd&lt;/code&gt;. Depending on how you&amp;rsquo;ve installed RethinkDB, this may already be done for you.)</source>
          <target state="translated">운영 체제에 대한 서비스로 RethinkDB를 설치하십시오. (이 문서는 &lt;code&gt;init.d&lt;/code&gt; 및 &lt;code&gt;systemd&lt;/code&gt; 기반 Linux 배포판과 &lt;code&gt;launchd&lt;/code&gt; 를 사용하여 OS X 모두에서 수행하는 방법을 설명합니다 . RethinkDB 설치 방법에 따라 이미 완료되었을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2df8530df735797a29fd92fab10ddfe7b16aedf6" translate="yes" xml:space="preserve">
          <source>Install client drivers</source>
          <target state="translated">클라이언트 드라이버 설치</target>
        </trans-unit>
        <trans-unit id="01fd635cf310ad64f3e1b1f64648e6ae28c17133" translate="yes" xml:space="preserve">
          <source>Install the server</source>
          <target state="translated">서버 설치</target>
        </trans-unit>
        <trans-unit id="828b11b9132aed05b6b796b08db5481e6d19dd3e" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB</source>
          <target state="translated">RethinkDB 설치</target>
        </trans-unit>
        <trans-unit id="f0813a11b71d8a038d4b80014edfc9b3a6adf95c" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB client drivers</source>
          <target state="translated">RethinkDB 클라이언트 드라이버 설치</target>
        </trans-unit>
        <trans-unit id="25698238529e36c36bbff9a1cf8864afeb7e862b" translate="yes" xml:space="preserve">
          <source>Installing from source</source>
          <target state="translated">소스에서 설치</target>
        </trans-unit>
        <trans-unit id="66166bdf5a5269039901f352cb2db046575a54fa" translate="yes" xml:space="preserve">
          <source>Installing on other platforms</source>
          <target state="translated">다른 플랫폼에 설치</target>
        </trans-unit>
        <trans-unit id="333df51781cc357460f2c635fe316602326864a3" translate="yes" xml:space="preserve">
          <source>Instance administration</source>
          <target state="translated">인스턴스 관리</target>
        </trans-unit>
        <trans-unit id="4319f262417314ad390a0bffe2a7838f08952aea" translate="yes" xml:space="preserve">
          <source>Instead of using the &lt;code&gt;default&lt;/code&gt; optional argument to &lt;code&gt;filter&lt;/code&gt;, we have to use default values on the fields within the &lt;code&gt;or&lt;/code&gt; clause. Why? If the field on the left side of the &lt;code&gt;or&lt;/code&gt; clause is missing from a document&amp;mdash;in this case, if the user doesn&amp;rsquo;t have a &lt;code&gt;role&lt;/code&gt; field&amp;mdash;the predicate will generate an error, and will return &lt;code&gt;false&lt;/code&gt; (or the value the &lt;code&gt;default&lt;/code&gt; argument is set to) without evaluating the right side of the &lt;code&gt;or&lt;/code&gt;. By using &lt;code&gt;.default(false)&lt;/code&gt; on the fields, each side of the &lt;code&gt;or&lt;/code&gt; will evaluate to either the field&amp;rsquo;s value or &lt;code&gt;false&lt;/code&gt; if the field doesn&amp;rsquo;t exist.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 을 위해 &lt;code&gt;default&lt;/code&gt; 선택적 인수를 사용하는 대신 &lt;code&gt;or&lt;/code&gt; 절의 필드에서 기본값을 사용해야합니다 . 왜? &lt;code&gt;or&lt;/code&gt; 절의 왼쪽에있는 필드 가 문서에서 누락 된 경우 (이 경우 사용자에게 &lt;code&gt;role&lt;/code&gt; 필드 가없는 경우) 술어는 오류를 생성하고 &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;default&lt;/code&gt; 인수 값)를 리턴 합니다. &lt;code&gt;or&lt;/code&gt; 의 오른쪽을 평가하지 않고로 설정됩니다 . 필드에서 &lt;code&gt;.default(false)&lt;/code&gt; 를 사용 하면 &lt;code&gt;or&lt;/code&gt; 각면이 필드 값으로 평가되거나 필드가 존재하지 않으면 &lt;code&gt;false&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="edcb8acb99853d0a5ef2bb5e68e942595143f90e" translate="yes" xml:space="preserve">
          <source>Integrating Elasticsearch</source>
          <target state="translated">Elasticsearch 통합</target>
        </trans-unit>
        <trans-unit id="8dbfed65b5b9df99b02a2d3fc9690365cea617b8" translate="yes" xml:space="preserve">
          <source>Integrating RabbitMQ</source>
          <target state="translated">RabbitMQ 통합</target>
        </trans-unit>
        <trans-unit id="081430b73c2092922b1df2dd3a411dc9f24c47e1" translate="yes" xml:space="preserve">
          <source>Integrating RethinkDB with RabbitMQ</source>
          <target state="translated">RabbitMQ와 RethinkDB 통합</target>
        </trans-unit>
        <trans-unit id="a7881cac6e64abca5eafd172df6eb31fe0b84c88" translate="yes" xml:space="preserve">
          <source>Integrations</source>
          <target state="translated">Integrations</target>
        </trans-unit>
        <trans-unit id="796755669082ff5596709d22781a79a1f59e5527" translate="yes" xml:space="preserve">
          <source>Intel Xeon E5-2680 v2 CPU 2.8 GHz (10 cores)</source>
          <target state="translated">Intel Xeon E5-2680 v2 CPU 2.8GHz (10 코어)</target>
        </trans-unit>
        <trans-unit id="873fde3ef086eae1a20c3748b3a65e16d5a254b8" translate="yes" xml:space="preserve">
          <source>Internal metadata</source>
          <target state="translated">내부 메타 데이터</target>
        </trans-unit>
        <trans-unit id="cc2de5d3fe42b60664127c2656b7a7a0b43b73c3" translate="yes" xml:space="preserve">
          <source>Internally this approach is more difficult to implement than the more commonly used consistent hashing, but it has significant advantages because it allows for an efficient implementation of range queries.</source>
          <target state="translated">내부적으로이 방법은 일반적으로 사용되는 일관된 해시보다 구현하기가 어렵지만 범위 쿼리를 효율적으로 구현할 수 있기 때문에 큰 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="110fc7f6ed7d04de80c4765c8e43e4f598bb28eb" translate="yes" xml:space="preserve">
          <source>Internally, compound indexes and simple indexes are the same type of index in RethinkDB; compound indexes are simply a special case of regular index that returns an array rather than a single value.</source>
          <target state="translated">내부적으로 복합 인덱스와 단순 인덱스는 RethinkDB에서 동일한 유형의 인덱스입니다. 복합 인덱스는 단순히 단일 값이 아닌 배열을 반환하는 일반 인덱스의 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="016355aa2cdbc678752876dfc6bd8a8f0e33fcf6" translate="yes" xml:space="preserve">
          <source>Internally, queries are represented as trees. A query of:</source>
          <target state="translated">내부적으로 쿼리는 트리로 표시됩니다. 다음에 대한 쿼리 :</target>
        </trans-unit>
        <trans-unit id="3c0f8a211170bbe9fd74bfe3fb9d32dca2499482" translate="yes" xml:space="preserve">
          <source>Intersect two arrays returning values that occur in both of them as a set (an array with distinct values).</source>
          <target state="translated">두 배열 모두에서 발생하는 값을 집합 (고유 한 값을 가진 배열)으로 반환하는 두 배열을 교차시킵니다.</target>
        </trans-unit>
        <trans-unit id="1df374766527b0942d46def76ff145106af94c20" translate="yes" xml:space="preserve">
          <source>Introduction to Joins</source>
          <target state="translated">조인 소개</target>
        </trans-unit>
        <trans-unit id="886e399859534e91e45eb866e28bb27d1c8ebef9" translate="yes" xml:space="preserve">
          <source>Introduction to ReQL</source>
          <target state="translated">ReQL 소개</target>
        </trans-unit>
        <trans-unit id="c861239c228b921387ace53d3216eff7ae8989a1" translate="yes" xml:space="preserve">
          <source>Introduction to map-reduce</source>
          <target state="translated">지도 축소 소개</target>
        </trans-unit>
        <trans-unit id="abbf10e2c10be16cbb5de69a08a9647bc4b8886f" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tableCreate&lt;/code&gt; without specifying a database using &lt;a href=&quot;../db/index&quot;&gt;db&lt;/a&gt; creates a table in the database specified in &lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;, or &lt;code&gt;test&lt;/code&gt; if no database was specified.</source>
          <target state="translated">호출 &lt;code&gt;tableCreate&lt;/code&gt; 을 사용하여 데이터베이스 지정하지 않고 &lt;a href=&quot;../db/index&quot;&gt;DB하기&lt;/a&gt; 에 지정된 데이터베이스에서 테이블을 만들어 &lt;a href=&quot;../connect/index&quot;&gt;연결&lt;/a&gt; 하거나 &lt;code&gt;test&lt;/code&gt; 에는 데이터베이스가 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="2e984013c5e5d72e6ebe438bef7ce2e2e4fb1ca3" translate="yes" xml:space="preserve">
          <source>Invoking this functionality automatically without the user&amp;rsquo;s request is the next layer in this hierarchy. Currently the user can control the system via the web UI, manually via the command line, or by writing scripts to call the command line tools to perform server automation.</source>
          <target state="translated">사용자의 요청없이이 기능을 자동으로 호출하는 것이이 계층의 다음 계층입니다. 현재 사용자는 웹 UI를 통해, 명령 줄을 통해 수동으로 또는 스크립트를 작성하여 명령 줄 도구를 호출하여 서버 자동화를 수행하여 시스템을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3648c9e586da9da329d881f9456ad5f94947161e" translate="yes" xml:space="preserve">
          <source>Is RethinkDB immediately or eventually consistent?</source>
          <target state="translated">RethinkDB가 즉시 또는 결국 일관성이 있습니까?</target>
        </trans-unit>
        <trans-unit id="4345620dde11a944cdd9bd27934184533e094c4e" translate="yes" xml:space="preserve">
          <source>Is preferable to this query:</source>
          <target state="translated">이 쿼리보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="2425127c8709646f155c07fc3ff2d5c6988816eb" translate="yes" xml:space="preserve">
          <source>Is the crash reproducible, and if so, under what conditions?</source>
          <target state="translated">충돌은 어떤 상황에서 재현 가능합니까?</target>
        </trans-unit>
        <trans-unit id="6e1cb81d9e26a4f9b860dc2a2fd2ba2b29daee20" translate="yes" xml:space="preserve">
          <source>Issue types</source>
          <target state="translated">문제 유형</target>
        </trans-unit>
        <trans-unit id="f03aac29f543ef0de44fcdf77a29c785765deb8a" translate="yes" xml:space="preserve">
          <source>Issues added to the table follow the same structure.</source>
          <target state="translated">표에 추가 된 문제는 동일한 구조를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b48c8924e7f87f4c696bb70c6d06139c134e96ed" translate="yes" xml:space="preserve">
          <source>It also returns results ordered from most relevant to least, not worrying about small differences. Say you want to ask the question: &amp;ldquo;What documents best match the phrase &amp;lsquo;Holy guacamole, Batman&amp;rsquo;?&amp;rdquo; If the hoped-for guacamole reference isn&amp;rsquo;t found, a full-text search should reply with documents containing good matches like &amp;ldquo;Holy smokes, Batman!&amp;rdquo; and &amp;ldquo;Holy armadillo, Batman!&amp;rdquo; In short, you should be using a full-text search database like Elasticsearch if you find yourself writing convoluted regular expressions to grep through big text fields.</source>
          <target state="translated">또한 작은 차이에 대해 걱정하지 않고 가장 관련성이 높은 순서대로 결과를 반환합니다. &quot;어떤 문서가 '신성한 아보카도 몰리, 배트맨'이라는 문구와 가장 잘 어울 립니까?&quot; 원하는 아보카도 소스 참조를 찾을 수없는 경우 전체 텍스트 검색은 &quot;Holy smokes, Batman!&quot;과 같은 일치 항목이 포함 된 문서로 회신해야합니다. 그리고 &quot;거룩한 아르마딜로, 배트맨!&quot; 즉, 큰 텍스트 필드를 통해 grep하기 위해 복잡한 정규식을 작성하는 경우 Elasticsearch와 같은 전체 텍스트 검색 데이터베이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0308bae19734e53e8eeb8fc72417975f82b4d057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common pattern in some query interfaces to &amp;ldquo;build&amp;rdquo; queries programmatically by instantiating a query object, calling it several times in succession to add query commands, then calling the execution command. This lets you dynamically change the query based on conditions at runtime. You might expect to do this in ReQL like so:</source>
          <target state="translated">쿼리 개체를 인스턴스화하고 쿼리 명령을 추가하기 위해 여러 번 호출 한 다음 실행 명령을 호출하여 프로그래밍 방식으로 쿼리를 &quot;빌드&quot;하는 것이 일부 쿼리 인터페이스에서 일반적인 패턴입니다. 이를 통해 런타임시 조건에 따라 쿼리를 동적으로 변경할 수 있습니다. ReQL에서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d263475c984dca5d502747655b9f006256096e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common task for web applications to accept file uploads from users; with RethinkDB you can store these files directly in the database.</source>
          <target state="translated">웹 응용 프로그램이 사용자의 파일 업로드를 허용하는 일반적인 작업입니다. RethinkDB를 사용하면 이러한 파일을 데이터베이스에 직접 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df14c095e2e2a042484762e7fae65618dd20e3e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a natural and convenient way to express queries.</source>
          <target state="translated">자연스럽고 편리한 쿼리 표현 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd366d6aeb93bc8ec97f59c94513521c61f160c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for this error to be caused by a circular reference, where a document inadvertently contains itself:</source>
          <target state="translated">문서에 실수로 포함 된 순환 참조로 인해이 오류가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e119ec402d3bfe01c9d4e90058826653b70f9ef" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use RethinkDB with Ruby on Rails. This guide assumes some familiarity with Rails and ActiveRecord. We&amp;rsquo;ll be using &lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer&lt;/a&gt;&amp;mdash;a RethinkDB ORM, which is an almost drop-in replacement for ActiveRecord.</source>
          <target state="translated">Ruby on Rails와 함께 RethinkDB를 사용하는 것은 쉽습니다. 이 가이드는 Rails와 ActiveRecord에 어느 정도 익숙하다고 가정합니다. 우리는 &lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer를&lt;/a&gt; 사용할 것입니다 &amp;ndash; RethinkDB ORM은 ActiveRecord를 거의 대체하는 대체품입니다.</target>
        </trans-unit>
        <trans-unit id="30747a6d28762ec1343765ae06483c010e675643" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to increment a field value in a document&amp;mdash;for example, a counter&amp;mdash;in one step on the server.</source>
          <target state="translated">서버의 한 단계에서 문서 (예 : 카운터)의 필드 값을 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c38f29865ef6022444784351ea37ca314feb8c" translate="yes" xml:space="preserve">
          <source>JOINS</source>
          <target state="translated">JOINS</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="be4521311d0f547ae040a777490a7694a57f7b10" translate="yes" xml:space="preserve">
          <source>JSON files are preferred to CSV files, as JSON can represent RethinkDB documents fully. If you&amp;rsquo;re importing from a CSV file, you should include a header row with the field names, or use the &lt;code&gt;--no-header&lt;/code&gt; option with the &lt;code&gt;--custom-header&lt;/code&gt; option to specify the names.</source>
          <target state="translated">JSON은 RethinkDB 문서를 완전히 나타낼 수 있으므로 JSON 파일은 CSV 파일보다 선호됩니다. CSV 파일에서 가져 오는 경우 필드 이름과 함께 헤더 행을 포함하거나 &lt;code&gt;--custom-header&lt;/code&gt; 옵션 과 함께 &lt;code&gt;--no-header&lt;/code&gt; -header 옵션을 사용하여 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="2150136b161bb7f3850c20f55af98f5e50de8133" translate="yes" xml:space="preserve">
          <source>JavaScript ORM for RethinkDB.</source>
          <target state="translated">RethinkDB 용 JavaScript ORM</target>
        </trans-unit>
        <trans-unit id="2a15a5b5017d006df320fa6b8ac5c83f39e3e070" translate="yes" xml:space="preserve">
          <source>JavaScript ReQL command reference</source>
          <target state="translated">JavaScript ReQL 명령 참조</target>
        </trans-unit>
        <trans-unit id="12bfad731fd2da7fcf4e3ba16201bc4b30c542f9" translate="yes" xml:space="preserve">
          <source>JavaScript driver with Node.js</source>
          <target state="translated">Node.js가 포함 된 JavaScript 드라이버</target>
        </trans-unit>
        <trans-unit id="c5b67826a8b2b2a28d0ea2896c58630359061683" translate="yes" xml:space="preserve">
          <source>JavaScript has no native iterator, but ReQL implements an &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command similar to &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;&amp;rsquo;s.</source>
          <target state="translated">JavaScript에는 기본 반복자가 없지만 ReQL 은 &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt; 와 유사한 &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;각&lt;/a&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="437736fdb5bb707abdc048483193c86b9a99983e" translate="yes" xml:space="preserve">
          <source>Jobs</source>
          <target state="translated">Jobs</target>
        </trans-unit>
        <trans-unit id="7bb6a0357b0f1772fd50b7f8539ec577ed6f6748" translate="yes" xml:space="preserve">
          <source>Join tables using a field or function on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. &lt;code&gt;eqJoin&lt;/code&gt; is more efficient than other ReQL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field&amp;rsquo;s value exists in the specified index on the right-hand side.</source>
          <target state="translated">오른쪽 테이블의 기본 키 또는 보조 인덱스와 일치하는 왼쪽 시퀀스의 필드 또는 함수를 사용하여 테이블을 조인하십시오. &lt;code&gt;eqJoin&lt;/code&gt; 은 다른 ReQL 조인 유형보다 효율적이며 훨씬 빠르게 작동합니다. 결과 집합의 문서는 왼쪽 및 오른쪽 문서 쌍으로 구성되며, 왼쪽 필드가 존재하고 널이 아니며 해당 필드 값을 가진 항목이 오른쪽의 지정된 색인에 존재할 때 일치합니다. 손 쪽.</target>
        </trans-unit>
        <trans-unit id="442e9473c8c4abf9dfcae036af694232b5434ef9" translate="yes" xml:space="preserve">
          <source>Join these tables using &lt;code&gt;gameId&lt;/code&gt; on the player table and &lt;code&gt;id&lt;/code&gt; on the games table:</source>
          <target state="translated">player 테이블에서 &lt;code&gt;gameId&lt;/code&gt; 를 사용 하고 games 테이블에서 &lt;code&gt;id&lt;/code&gt; 를 사용하여 다음 테이블을 조인 하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2597a987d6f7990bcc2736d74772e6aaab9771" translate="yes" xml:space="preserve">
          <source>Joining multiple changefeeds into one</source>
          <target state="translated">여러 개의 변경 피드를 하나로 결합</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="614248f657c4cd869544f362220155e71e70a6d3" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and browse through dozens of examples of common RethinkDB queries.</source>
          <target state="translated">로 이동 &lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;요리 책&lt;/a&gt; 및 일반 RethinkDB 쿼리의 예를 수십을 찾아.</target>
        </trans-unit>
        <trans-unit id="cadea68a130fb4da345a2bd00c5bc5ec1fdab118" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and see dozens of examples of common RethinkDB queries.</source>
          <target state="translated">로 이동 &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;요리 책&lt;/a&gt; 및 일반 RethinkDB 쿼리의 예를 수십를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="815740848353ae01fefc9bf1699f34710f065f60" translate="yes" xml:space="preserve">
          <source>Just in case you needed another calculator, ReQL can do that too!</source>
          <target state="translated">다른 계산기가 필요한 경우 ReQL도 그렇게 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="df1556914f9d65ff6bb135e1e34b460926c8b594" translate="yes" xml:space="preserve">
          <source>Just like other ReQL indexes, you can create an index using an anonymous function rather than a simple field name, as well as create multi indexes by using the &lt;code&gt;multi&lt;/code&gt; flag with &lt;code&gt;geo&lt;/code&gt;. Read the &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API documentation for more details.</source>
          <target state="translated">다른 ReQL 색인과 마찬가지로 간단한 필드 이름이 아닌 익명 함수를 사용하여 색인을 작성 하고 &lt;code&gt;geo&lt;/code&gt; 와 함께 &lt;code&gt;multi&lt;/code&gt; 플래그를 사용하여 다중 색인을 작성할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2d5bfabcb6bca6d271e3af0b81998719a3d8e256" translate="yes" xml:space="preserve">
          <source>Koa</source>
          <target state="translated">Koa</target>
        </trans-unit>
        <trans-unit id="0cd80e0b1a0d9ca537de8880c046d1db4c5bba77" translate="yes" xml:space="preserve">
          <source>Koa middleware that automatically manages connections via a connection pool.</source>
          <target state="translated">연결 풀을 통해 연결을 자동으로 관리하는 Koa 미들웨어.</target>
        </trans-unit>
        <trans-unit id="26fad106569fcec275e401a5f8f426bcdc4c1a5d" translate="yes" xml:space="preserve">
          <source>Lambda functions in RethinkDB</source>
          <target state="translated">RethinkDB의 Lambda 함수</target>
        </trans-unit>
        <trans-unit id="b3efedc3036d62c6e9695305d32c2033a97f6fed" translate="yes" xml:space="preserve">
          <source>Larger documents of more than 250 bytes are stored in blocks of their own. Documents up to 4 KB use a single block; larger documents are split across multiple blocks as needed.</source>
          <target state="translated">250 바이트가 넘는 큰 문서는 자체 블록에 저장됩니다. 최대 4KB의 문서는 단일 블록을 사용합니다. 더 큰 문서는 필요에 따라 여러 블록으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9c8282669843d174d46b5ef2c7b930b7ff91c0" translate="yes" xml:space="preserve">
          <source>Lastly, we call &lt;code&gt;run(connection, callback)&lt;/code&gt; in order to send the query to the server.</source>
          <target state="translated">마지막으로 서버에 쿼리를 보내기 위해 &lt;code&gt;run(connection, callback)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b593864b68f106789807303bd0cf74356e8e4ff9" translate="yes" xml:space="preserve">
          <source>Latency is also an important metric to measure when testing performance. We found that in a 16-node cluster, the 95th percentile for Workload A query latencies is 26ms.</source>
          <target state="translated">지연 시간은 성능 테스트시 측정 할 중요한 지표입니다. 16 노드 클러스터에서 Workload A 쿼리 대기 시간의 95 번째 백분위 수는 26ms입니다.</target>
        </trans-unit>
        <trans-unit id="ec18da38841bcc22e0215d72fe5f8195fe0cb024" translate="yes" xml:space="preserve">
          <source>Launching an instance</source>
          <target state="translated">인스턴스 시작</target>
        </trans-unit>
        <trans-unit id="cde4c57577148cb7290eeb61254becb94294e003" translate="yes" xml:space="preserve">
          <source>Lazily iterate over a cursor, array, or feed one element at a time. &lt;code&gt;eachAsync&lt;/code&gt; always returns a promise that will be resolved once all rows are returned.</source>
          <target state="translated">한 번에 한 요소 씩 커서, 배열 또는 피드를 느리게 반복합니다. &lt;code&gt;eachAsync&lt;/code&gt; 는 항상 모든 행이 반환되면 해결 될 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7580d3d26925e442143c501474aa5ee2f4ba2239" translate="yes" xml:space="preserve">
          <source>Lazily iterate over the result set one element at a time. The second callback is optional and is called when the iteration stops (when there are no more rows or when the callback returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">한 번에 한 요소 씩 결과 집합을 느리게 반복합니다. 두 번째 콜백은 선택 사항이며 반복이 중지되면 (더 이상 행이 없거나 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때 ) 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="119a27138fe3d276ec8a407746eb7af54a9639ef" translate="yes" xml:space="preserve">
          <source>Leap-seconds aren&amp;rsquo;t well-supported right now: &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; and &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; parse to the same time.</source>
          <target state="translated">윤초는 현재 잘 지원되지 않습니다 : &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; 및 &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; 동시에 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="7352c39338b0f7491547ec046eb62e590d5666fa" translate="yes" xml:space="preserve">
          <source>Learn about changefeeds, RethinkDB's realtime push technology, and how it can be used to build and scale realtime apps.</source>
          <target state="translated">변경 사항, RethinkDB의 실시간 푸시 기술 및 실시간 앱 구축 및 확장에 어떻게 사용될 수 있는지에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="053b8690ab05d3886d2e0a4df01379bf8f5f5878" translate="yes" xml:space="preserve">
          <source>Learn how to deploy RethinkDB on cloud services like Compose.io, AWS, and others.</source>
          <target state="translated">Compose.io, AWS 등의 클라우드 서비스에 RethinkDB를 배포하는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="4008d50d045acf61774875510316c96f31310945" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="e7a12b247f8e4dd853fb7027039428b2379a21df" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../../table-joins/index&quot;&gt;테이블 조인&lt;/a&gt; 을 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="38439358cead9a9ddb8011466b2b2f821423863f" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="9211e3e0cf73e7b17435ad61921079b0ccf56943" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;primary and secondary indexes&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;기본 및 보조 인덱스&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="46618e390b1b640a19b5fe7e820ff17c339e0144" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../table-joins/index&quot;&gt;테이블 조인&lt;/a&gt; 을 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="f065a72b19aac97d11c858d3ee474f834c0ea4e9" translate="yes" xml:space="preserve">
          <source>Learn how to use GeoJSON features to build location-aware apps in RethinkDB.</source>
          <target state="translated">GeoJSON 기능을 사용하여 RethinkDB에서 위치 인식 앱을 구축하는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="7a058f790976caa297b4022af937873c407c3337" translate="yes" xml:space="preserve">
          <source>Learn more about how RethinkDB can efficiently retrieve documents with &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt;.</source>
          <target state="translated">RethinkDB가 &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;보조 인덱스를 사용&lt;/a&gt; 하여 문서를 효율적으로 검색하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="89b463fdfab8c2b3e899da5b283265547e388a16" translate="yes" xml:space="preserve">
          <source>Learning the language is no different from learning any other library.</source>
          <target state="translated">언어를 배우는 것은 다른 도서관을 배우는 것과 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b20a7997c63ce3054fd7d30d35de4678173fe84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the advantages and disadvantages of each approach. We&amp;rsquo;ll use a simple blog database that stores information about authors and their posts to demonstrate them.</source>
          <target state="translated">각 접근 방식의 장단점을 살펴 보겠습니다. 저자 및 게시물에 대한 정보를 저장하는 간단한 블로그 데이터베이스를 사용하여 시연합니다.</target>
        </trans-unit>
        <trans-unit id="0a3374d1d23dd959122583511673592b311245c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s filter based on the nested field &lt;code&gt;email&lt;/code&gt;:</source>
          <target state="translated">중첩 된 필드 &lt;code&gt;email&lt;/code&gt; 기준으로 필터링하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="cb7b4f56da03ec0ec2ef157f49777af0230bdeb9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s find the most influential GitHub users who showed interest in RethinkDB. First, let&amp;rsquo;s grab the list of RethinkDB stargazers:</source>
          <target state="translated">RethinkDB에 관심을 보인 가장 영향력있는 GitHub 사용자를 찾으십시오. 먼저 RethinkDB stargazer 목록을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7c2b1f805ab05c4e6512aa8198d873b9d8e69683" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s follow the processing of a simple query. (This example uses JavaScript, but the commands are virtually identical in other languages.)</source>
          <target state="translated">간단한 쿼리 처리를 따르십시오. (이 예제는 JavaScript를 사용하지만 다른 언어에서는 명령이 거의 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="e6b2a5e6f45fc67a9ecc8d1de778247a2bb0f236" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s insert three new documents into the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 테이블에 세 개의 새 문서를 삽입 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b741c7ad37ec13a7b2f8b15575a0343bd5b1de26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at these concepts in more detail.</source>
          <target state="translated">이러한 개념을보다 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ef26fdd5241f22380a2542ba5b766049445eb40d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have another table &lt;code&gt;authors&lt;/code&gt;, and we&amp;rsquo;d like to get a list of authors whose last names are also in the &lt;code&gt;users&lt;/code&gt; table we&amp;rsquo;ve seen before. We can do it by combining two queries:</source>
          <target state="translated">다른 테이블 &lt;code&gt;authors&lt;/code&gt; 가 있고 이전에 본 &lt;code&gt;users&lt;/code&gt; 테이블 에도 성이있는 저자 목록을 원한다고 가정 하겠습니다. 두 가지 쿼리를 결합하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ff567a62fcc49849955f0084cafdf6e60d5359" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to publish the teaming up between Batman, Superman and the Joker:</source>
          <target state="translated">배트맨, 슈퍼맨, 조커 사이에 팀 구성을 게시한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c97142a03d1740d9845e909927ca5b45579f24c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we can use joins in RethinkDB to query data based on &lt;strong&gt;one to many&lt;/strong&gt;, and &lt;strong&gt;many to many&lt;/strong&gt; relations.</source>
          <target state="translated">RethinkDB에서 조인을 사용 &lt;strong&gt;하여 일대 다&lt;/strong&gt; 및 &lt;strong&gt;다 대다&lt;/strong&gt; 관계 &lt;strong&gt;를&lt;/strong&gt; 기반으로 데이터를 쿼리하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a6c351ade4cff6a3547f0d48de14100d80140b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a simple example. RethinkDB supports server-side JavaScript evaluation using the embedded V8 engine (sandboxed within outside processes, of course):</source>
          <target state="translated">간단한 예부터 시작하겠습니다. RethinkDB는 임베디드 V8 엔진 (물론 외부 프로세스 내에서 샌드 박스 처리)을 사용하여 서버 측 JavaScript 평가를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="49a17718af97d847a464ec714b54c94d0f64ebbe" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s suppose we&amp;rsquo;ve created two tables: &lt;code&gt;employees&lt;/code&gt; and &lt;code&gt;companies&lt;/code&gt;. We&amp;rsquo;ll use these tables to model the notion of people working for organizations (each organization has multiple people working for it, but any given person works at a single organization). Here&amp;rsquo;s an example document in the &lt;code&gt;employees&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;employees&lt;/code&gt; 과 &lt;code&gt;companies&lt;/code&gt; 라는 두 개의 테이블을 만들었다 고 가정 해 봅시다 . 이 표를 사용하여 조직에서 일하는 사람들의 개념을 모델링 할 것입니다 (각 조직에는 여러 사람이 일하고 있지만 주어진 사람은 단일 조직에서 일합니다). &lt;code&gt;employees&lt;/code&gt; 테이블 의 예제 문서는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b79e2ec29148ce71c9f97e43dc0f1bb9de49bd76" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try something very simple &amp;mdash; accessing a website. Type the following command in the Data Explorer and hit &amp;lsquo;Run&amp;rsquo; (alternatively, you can run it from a RethinkDB driver):</source>
          <target state="translated">웹 사이트에 액세스하는 매우 간단한 방법을 시도해 봅시다. 데이터 탐색기에 다음 명령을 입력하고 '실행'을 누르십시오 (또는 RethinkDB 드라이버에서 실행할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="d523c71f4437b42b411bb4d2f3290905dc21ba48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to retrieve the document where the &lt;code&gt;name&lt;/code&gt; attribute is set to &lt;code&gt;William Adama&lt;/code&gt;. We can use a condition to filter the documents by chaining a &lt;code&gt;filter&lt;/code&gt; command to the end of the query:</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 속성이 &lt;code&gt;William Adama&lt;/code&gt; 로 설정된 문서를 검색해 봅시다 . &lt;code&gt;filter&lt;/code&gt; 명령을 쿼리 끝에 연결하여 조건을 사용하여 문서를 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74167a956b2c180d4d5a4db633dfab9b54f1b3ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update all documents in the &lt;code&gt;authors&lt;/code&gt; table and add a &lt;code&gt;type&lt;/code&gt; field to note that every author so far is fictional:</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 테이블의 모든 문서를 업데이트 하고 &lt;code&gt;type&lt;/code&gt; 필드를 추가하여 지금까지의 모든 저자가 허구임을 확인 합시다 .</target>
        </trans-unit>
        <trans-unit id="e46cc597dcd23c00f763aa1f360f40229ca58a86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update our stargazer data with this additional information:</source>
          <target state="translated">이 추가 정보로 stargazer 데이터를 업데이트하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="5cc9d86c4961df923fc41b3ea88b4072aa84010d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use &lt;code&gt;filter&lt;/code&gt; again to retrieve all authors who have more than two posts:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 다시 사용 하여 두 개 이상의 게시물이있는 모든 저자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbb0ddb2e3183cfe93ee6ec919cd561d521a487" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a script that listens for changes in the RethinkDB server and pushes them to RabbitMQ.</source>
          <target state="translated">RethinkDB 서버의 변경 사항을 수신하고 RabbitMQ로 푸시하는 스크립트를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="332e9d887845f15f8edb7f47a27c9feaa5e64473" translate="yes" xml:space="preserve">
          <source>Lets you install RethinkDB using Vagrant.</source>
          <target state="translated">Vagrant를 사용하여 RethinkDB를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa75a36abc1bfd1fe97a7d7bec24659e766b29c" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike 3.0 Unported License에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="e3891b7e1579150dc791a1037b6ef7ffc603c47a" translate="yes" xml:space="preserve">
          <source>Like any ReQL command, &lt;code&gt;changes&lt;/code&gt; integrates with the rest of the query language. You can call &lt;code&gt;changes&lt;/code&gt; after most commands that transform or select data:</source>
          <target state="translated">다른 ReQL 명령과 마찬가지로 &lt;code&gt;changes&lt;/code&gt; 은 나머지 쿼리 언어와 통합됩니다. 데이터를 변환하거나 선택하는 대부분의 명령 후에 &lt;code&gt;changes&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50c623d37beca2feae774d169fbe6b85ee0be7e7" translate="yes" xml:space="preserve">
          <source>Like many traditional database systems, RethinkDB supports &lt;code&gt;JOIN&lt;/code&gt; commands to combine data from multiple tables. In RethinkDB joins are automatically distributed&amp;mdash;a join command is automatically sent to the appropriate nodes across the cluster, the relevant data is combined, and the final result is presented to the user.</source>
          <target state="translated">많은 기존 데이터베이스 시스템과 마찬가지로 RethinkDB는 &lt;code&gt;JOIN&lt;/code&gt; 명령을 지원 하여 여러 테이블의 데이터를 결합합니다. RethinkDB 조인은 자동으로 배포됩니다. 조인 명령이 클러스터의 해당 노드로 자동 전송되고 관련 데이터가 결합되어 최종 결과가 사용자에게 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b81e349422612226eccc114d5f889ba875ee59c6" translate="yes" xml:space="preserve">
          <source>Like most database systems, ReQL supports primary and secondary indexes to allow efficient data access. You can also create compound indexes and indexes based on arbitrary ReQL expressions to speed up complex queries.</source>
          <target state="translated">대부분의 데이터베이스 시스템과 마찬가지로 ReQL은 기본 및 보조 인덱스를 지원하여 효율적인 데이터 액세스를 허용합니다. 임의의 ReQL 표현식을 기반으로 복합 인덱스 및 인덱스를 작성하여 복잡한 쿼리 속도를 높일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcbaaf781c0838f0b358c0dddcca12bc10e4339" translate="yes" xml:space="preserve">
          <source>Limitations of automatic failover</source>
          <target state="translated">자동 장애 조치의 한계</target>
        </trans-unit>
        <trans-unit id="8f13609bf219f6ca237069b790c4c9a2ad381552" translate="yes" xml:space="preserve">
          <source>Limiting the number of returned documents</source>
          <target state="translated">반품 된 문서 수 제한</target>
        </trans-unit>
        <trans-unit id="46453bf012aa531ac54613a0f5623dcf3c269fca" translate="yes" xml:space="preserve">
          <source>Linearizability and atomicity guarantees</source>
          <target state="translated">선형성 및 원 자성 보장</target>
        </trans-unit>
        <trans-unit id="8079cd01630a2b6f154b2abd4aca58bf065d2bf7" translate="yes" xml:space="preserve">
          <source>Lines and distances</source>
          <target state="translated">선과 거리</target>
        </trans-unit>
        <trans-unit id="f8a8b40332141131251cba0338928c84cbc899bd" translate="yes" xml:space="preserve">
          <source>Lines and polygons can be specified using either point objects or sequences of two-number arrays:</source>
          <target state="translated">점 개체 또는 두 개의 숫자 배열 시퀀스를 사용하여 선과 다각형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e17174307bd30c9651cd5cd7f2b98cd08f8a35" translate="yes" xml:space="preserve">
          <source>Linking documents in multiple tables</source>
          <target state="translated">여러 테이블에서 문서 연결</target>
        </trans-unit>
        <trans-unit id="6ed36fa1183214845ee195f26eeda3f8866b655a" translate="yes" xml:space="preserve">
          <source>Linux Mint</source>
          <target state="translated">리눅스 민트</target>
        </trans-unit>
        <trans-unit id="d51bed5d4234a9759d6a8aab8a001767fd630b60" translate="yes" xml:space="preserve">
          <source>Linux and OS X</source>
          <target state="translated">리눅스와 OS X</target>
        </trans-unit>
        <trans-unit id="a6b55add3271bf52f9229b1f55c71bf39192ee0c" translate="yes" xml:space="preserve">
          <source>List all database names in the system. The result is a list of strings.</source>
          <target state="translated">시스템의 모든 데이터베이스 이름을 나열하십시오. 결과는 문자열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="993b1d68164e0a0c046c84b9ca43c4e5830eec98" translate="yes" xml:space="preserve">
          <source>List all table names in a database. The result is a list of strings.</source>
          <target state="translated">데이터베이스의 모든 테이블 이름을 나열하십시오. 결과는 문자열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3bb65a3a68d5a8ad114346be2ad7ccd0b325bc12" translate="yes" xml:space="preserve">
          <source>List all the secondary indexes of this table.</source>
          <target state="translated">이 테이블의 모든 보조 인덱스를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="cca8cd4e2bc2f275251b8f0b5ed8434b92cf0173" translate="yes" xml:space="preserve">
          <source>Listen for changes in a RethinkDB table over RabbitMQ.</source>
          <target state="translated">RabbitMQ를 통해 RethinkDB 테이블의 변경 사항을 청취하십시오.</target>
        </trans-unit>
        <trans-unit id="eb6fc719e4222cb0e021bed23a373eb005d0e88d" translate="yes" xml:space="preserve">
          <source>Listening to RabbitMQ messages</source>
          <target state="translated">RabbitMQ 메시지 듣기</target>
        </trans-unit>
        <trans-unit id="5ec7392e4c45dc057d7ab6c781c38d95f4d3346a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;python&lt;/code&gt; (or &lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt;) and set up a connection to your database:</source>
          <target state="translated">&lt;code&gt;python&lt;/code&gt; (또는 &lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt; )을 로드 하고 데이터베이스에 대한 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="37819416fc67fd2f5cd366c850cf56b4ff2d213c" translate="yes" xml:space="preserve">
          <source>Log in using the username &lt;code&gt;rethinkdb&lt;/code&gt; and the password you chose in step 7.</source>
          <target state="translated">&lt;code&gt;rethinkdb&lt;/code&gt; 사용자 이름 과 7 단계에서 선택한 비밀번호를 사용하여 로그인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2e3210b91ade80c488bbcfd4ac6f12798b16237" translate="yes" xml:space="preserve">
          <source>Log options</source>
          <target state="translated">로그 옵션</target>
        </trans-unit>
        <trans-unit id="aa42cc5f49c6d291cfc5d71f7d47803ff3f9de31" translate="yes" xml:space="preserve">
          <source>Log write issues</source>
          <target state="translated">로그 쓰기 문제</target>
        </trans-unit>
        <trans-unit id="00d45cf43ab6900d309ef4eaaa39f6e115347863" translate="yes" xml:space="preserve">
          <source>Logging tools</source>
          <target state="translated">로깅 도구</target>
        </trans-unit>
        <trans-unit id="77579f2f6e9a0b7bf5302dfdb7b5e31eec34bd09" translate="yes" xml:space="preserve">
          <source>Longitude (&amp;minus;180 to 180) and latitude (&amp;minus;90 to 90) of vertices are plotted on a perfect sphere. See &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system.</source>
          <target state="translated">정점의 경도 (-180-180) 및 위도 (-90-90)는 완벽한 구에 표시됩니다. ReQL 좌표계에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7f41960132584f9d7bd0c067c3f4dfa28d057b2" translate="yes" xml:space="preserve">
          <source>Look at how many arguments the function takes (&lt;code&gt;num_args&lt;/code&gt;)</source>
          <target state="translated">함수가 몇 개의 인수를 받는지보십시오 ( &lt;code&gt;num_args&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c92246116a0060ce1970018249864b4c7a3348ef" translate="yes" xml:space="preserve">
          <source>Loop over a sequence, evaluating the given write query for each element.</source>
          <target state="translated">시퀀스를 반복하여 각 요소에 대해 주어진 쓰기 쿼리를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c6ceab055f64bcd972209f1ed242740ed0fe108b" translate="yes" xml:space="preserve">
          <source>Lowercases a string.</source>
          <target state="translated">문자열을 소문자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="853db5db5e9449857a125fdaf64c49523fbe605b" translate="yes" xml:space="preserve">
          <source>Make also sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;installed the JavaScript driver&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;JavaScript 드라이버를 설치&lt;/a&gt; 했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae4a8e3bb1c5ba5084979d58dccde30ec4b6619e" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;installed RethinkDB&lt;/a&gt;&amp;mdash;it should only take a minute!</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;RethinkDB를 설치&lt;/a&gt; 했는지 확인하십시오. 단 1 분 밖에 걸리지 않습니다!</target>
        </trans-unit>
        <trans-unit id="ec8db219e768dbf927afc537cce0ed0ac5d426cf" translate="yes" xml:space="preserve">
          <source>Manipulating Databases</source>
          <target state="translated">데이터베이스 조작</target>
        </trans-unit>
        <trans-unit id="cd5274de84779cf7e26c8aeb43ee293a6d239ace" translate="yes" xml:space="preserve">
          <source>Manipulating Tables</source>
          <target state="translated">테이블 조작</target>
        </trans-unit>
        <trans-unit id="0315f3bc6857038096e10b57a0d97ca1a21082ee" translate="yes" xml:space="preserve">
          <source>Manipulating databases</source>
          <target state="translated">데이터베이스 조작</target>
        </trans-unit>
        <trans-unit id="85cd44aae68cc1b84cb48c7c2fe761b7d6e991c5" translate="yes" xml:space="preserve">
          <source>Manipulating documents</source>
          <target state="translated">문서 조작</target>
        </trans-unit>
        <trans-unit id="379776eeb89cc816e18680ac4dff7a7359381323" translate="yes" xml:space="preserve">
          <source>Manipulating indexes with the web UI</source>
          <target state="translated">웹 UI를 사용하여 인덱스 조작</target>
        </trans-unit>
        <trans-unit id="ae4c8c8c4f2c5ea1dc21a8c397caa583dd053f78" translate="yes" xml:space="preserve">
          <source>Manipulating indexes: &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</source>
          <target state="translated">인덱스 조작 : &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt; 및 &lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e391b105e9585f961562e7064cb0aa9414e73a72" translate="yes" xml:space="preserve">
          <source>Manipulating tables</source>
          <target state="translated">테이블 조작</target>
        </trans-unit>
        <trans-unit id="f17e3cdc08f968d3b1b8c2ec9eb1ceefef64f7ee" translate="yes" xml:space="preserve">
          <source>Manually merge the left and right fields</source>
          <target state="translated">왼쪽 및 오른쪽 필드를 수동으로 병합</target>
        </trans-unit>
        <trans-unit id="b9a082aaaec9d03b12fca89934928f413350caae" translate="yes" xml:space="preserve">
          <source>Many people have been reporting that they get back a connection object when they run a query, the object being:</source>
          <target state="translated">많은 사람들이 쿼리를 실행할 때 연결 개체를 다시 얻는다고보고했습니다. 개체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4d9a2e9aca1ebab3357daa2f4482b382a28a79" translate="yes" xml:space="preserve">
          <source>Many to many relations</source>
          <target state="translated">다 대다 관계</target>
        </trans-unit>
        <trans-unit id="d103bd0ce354a22ec2d971d2a818261309039c72" translate="yes" xml:space="preserve">
          <source>Map-reduce in RethinkDB</source>
          <target state="translated">RethinkDB의 맵 축소</target>
        </trans-unit>
        <trans-unit id="ec8bb2749b0912c81ba2d5e51014afb3a3980c0f" translate="yes" xml:space="preserve">
          <source>Matches against a regular expression. If there is a match, returns an object with the fields:</source>
          <target state="translated">정규식과 일치합니다. 일치하는 항목이 있으면 필드가있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aded3de93027fd725e41f6ca4105d385535009bf" translate="yes" xml:space="preserve">
          <source>Math and Logic</source>
          <target state="translated">수학과 논리</target>
        </trans-unit>
        <trans-unit id="e76587c25d66762a167abd2d402654b3cc867d80" translate="yes" xml:space="preserve">
          <source>Math and logic</source>
          <target state="translated">수학과 논리</target>
        </trans-unit>
        <trans-unit id="6888270cc5b2dfaf0916f2237e02a11e56088cf7" translate="yes" xml:space="preserve">
          <source>Memory availability issues</source>
          <target state="translated">메모리 가용성 문제</target>
        </trans-unit>
        <trans-unit id="110c6707f36ae400d4ca884b4a45ac2166550586" translate="yes" xml:space="preserve">
          <source>Memory requirements</source>
          <target state="translated">메모리 요구 사항</target>
        </trans-unit>
        <trans-unit id="5dd7c30db3f640d34b64d0e2719a800c2ccfb0d5" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">둘 이상의 객체를 병합하여 모든 속성을 가진 새 객체를 구성합니다. 필드 이름간에 충돌이 발생하면 인수 목록에서 가장 오른쪽에있는 개체의 필드가 기본 설정으로 제공됩니다. 또한 &lt;code&gt;merge&lt;/code&gt; 는 객체를 반환하는 하위 쿼리 함수를 허용하며,이 함수 는 &lt;a href=&quot;../map/index&quot;&gt;맵&lt;/a&gt; 함수 와 유사하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="04d73701de8502ed6708d400a96b65af03f13dbb" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">둘 이상의 객체를 병합하여 모든 속성을 가진 새 객체를 구성합니다. 필드 이름간에 충돌이 발생하면 인수 목록에서 가장 오른쪽에있는 개체의 필드가 기본 설정으로 제공됩니다. 또한 &lt;code&gt;merge&lt;/code&gt; 는 객체를 반환하는 하위 쿼리 함수를 허용하며,이 함수 는 &lt;a href=&quot;map/index&quot;&gt;맵&lt;/a&gt; 함수 와 유사하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="98f6cf8510e0439f12bcf7a86ba1ceba63386fc2" translate="yes" xml:space="preserve">
          <source>Merge two or more sequences.</source>
          <target state="translated">둘 이상의 시퀀스를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="1f0a513d0abdd16d2f84502191d76b98a52fb8f7" translate="yes" xml:space="preserve">
          <source>Migrating data from previous versions of RethinkDB</source>
          <target state="translated">이전 버전의 RethinkDB에서 데이터 마이그레이션</target>
        </trans-unit>
        <trans-unit id="aa6d9b542df934b1fb7cababc57d99f0c762b82c" translate="yes" xml:space="preserve">
          <source>Migrating old data</source>
          <target state="translated">이전 데이터 마이그레이션</target>
        </trans-unit>
        <trans-unit id="ce5743bd4325e12d91947a3f4a1b808fb776fbbb" translate="yes" xml:space="preserve">
          <source>Migration consists of three simple steps:</source>
          <target state="translated">마이그레이션은 세 가지 간단한 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe0b02845ac7e31f8355515cfa9358814ea98d9" translate="yes" xml:space="preserve">
          <source>Mimics the behavior of Python&amp;rsquo;s &lt;code&gt;string.split&lt;/code&gt; in edge cases, except for splitting on the empty string, which instead produces an array of single-character strings.</source>
          <target state="translated">빈 문자열을 분할하는 대신 (단일 문자 문자열 배열을 생성하는 경우를 제외하고) 가장자리의 경우 Python의 &lt;code&gt;string.split&lt;/code&gt; 동작을 모방합니다 .</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="1a0e2290409950c22eeaa9cec60aef1b7a34fe19" translate="yes" xml:space="preserve">
          <source>Mixed sequences of data sort in the following order:</source>
          <target state="translated">혼합 순서의 데이터는 다음 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="050aa84d9f3547048f944db27736fa71c21601f8" translate="yes" xml:space="preserve">
          <source>Modeling relationships</source>
          <target state="translated">모델링 관계</target>
        </trans-unit>
        <trans-unit id="4d7ad1ad621c826e63ea432ff5d8acd0e7e9dbc1" translate="yes" xml:space="preserve">
          <source>Models in depth</source>
          <target state="translated">깊이있는 모델</target>
        </trans-unit>
        <trans-unit id="0e0c2052c8a28cb53004104670a5f3189e0ff126" translate="yes" xml:space="preserve">
          <source>Modifying times</source>
          <target state="translated">시간 수정</target>
        </trans-unit>
        <trans-unit id="38ed8d7a13fc2d35939d911335ecac667570c279" translate="yes" xml:space="preserve">
          <source>Molly.js</source>
          <target state="translated">Molly.js</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="41775da315d57d76ff81ed9611116e4ea3dfd26d" translate="yes" xml:space="preserve">
          <source>More complex predicates</source>
          <target state="translated">더 복잡한 술어</target>
        </trans-unit>
        <trans-unit id="7180389997e0b1e0af0e7dc001fd021b621caff0" translate="yes" xml:space="preserve">
          <source>Most APIs support some form of authentication and rate limiting. The &lt;code&gt;r.http&lt;/code&gt; command supports common forms of authentication (see the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;reference&lt;/a&gt; for more details). For example, here is how you can use GitHub tokens with basic auth:</source>
          <target state="translated">대부분의 API는 특정 형식의 인증 및 속도 제한을 지원합니다. &lt;code&gt;r.http&lt;/code&gt; 의 명령은 인증의 일반적인 형태 (투시 지원 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;참조&lt;/a&gt; 자세한 내용 참조). 예를 들어 기본 인증과 함께 GitHub 토큰을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa60d0629e116eb043cbf63a410f5ce6c0b76c72" translate="yes" xml:space="preserve">
          <source>Most date operations are only defined on years in the range &lt;code&gt;[1400, 10000]&lt;/code&gt; (but note that times in the year &lt;code&gt;10000&lt;/code&gt; cannot be printed as ISO 8601 dates).</source>
          <target state="translated">대부분의 날짜 작업은 &lt;code&gt;[1400, 10000]&lt;/code&gt; 범위의 연도에만 정의됩니다 (그러나 &lt;code&gt;10000&lt;/code&gt; 연도의 시간은 ISO 8601 날짜로 인쇄 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="0641f9094acfde9b6cf6cc3b9d52a297e0e65bd8" translate="yes" xml:space="preserve">
          <source>Multi indexes</source>
          <target state="translated">다중 인덱스</target>
        </trans-unit>
        <trans-unit id="98a7e7d6cc4d0854490ddbd7601741fd83b90023" translate="yes" xml:space="preserve">
          <source>Multi-datacenter setup</source>
          <target state="translated">다중 데이터 센터 설정</target>
        </trans-unit>
        <trans-unit id="86753c0740ef8a696a347475bf1ea038b52b180e" translate="yes" xml:space="preserve">
          <source>Multipart responses</source>
          <target state="translated">멀티 파트 응답</target>
        </trans-unit>
        <trans-unit id="021a631169c4a417b486aab49a973289a6614f87" translate="yes" xml:space="preserve">
          <source>Multiple RethinkDB instances on a single machine</source>
          <target state="translated">단일 시스템에서 여러 RethinkDB 인스턴스</target>
        </trans-unit>
        <trans-unit id="09ad7baebfde68a2882bc6128e8473c249838c72" translate="yes" xml:space="preserve">
          <source>Multiple instances</source>
          <target state="translated">여러 인스턴스</target>
        </trans-unit>
        <trans-unit id="cc1d53d7c78cd147a3d1ec6d9077c46bc8013328" translate="yes" xml:space="preserve">
          <source>Multiple servers, databases, or tables in the same database have been assigned the same name. The &lt;code&gt;name&lt;/code&gt; field shows the conflicting name; &lt;code&gt;ids&lt;/code&gt; are the UUIDs of the entities that have that name. In the case of &lt;code&gt;table_name_collision&lt;/code&gt;, &lt;code&gt;db&lt;/code&gt; will be the database that the tables are in. Rename the conflicting entities.</source>
          <target state="translated">동일한 데이터베이스의 여러 서버, 데이터베이스 또는 테이블에 동일한 이름이 지정되었습니다. &lt;code&gt;name&lt;/code&gt; 필드는 충돌 이름을 보여줍니다; &lt;code&gt;ids&lt;/code&gt; 는 해당 이름을 가진 엔티티의 UUID입니다. 의 경우 &lt;code&gt;table_name_collision&lt;/code&gt; , &lt;code&gt;db&lt;/code&gt; 테이블이있는 것을 데이터베이스 될 것입니다. 충돌하는 엔티티의 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8ee266f49fc4bb636b4d04389645377477ea4f26" translate="yes" xml:space="preserve">
          <source>Multiply two numbers, or make a periodic array.</source>
          <target state="translated">두 숫자를 곱하거나 주기적으로 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="1f211804aeeccd93ce4380676a5c34cd70670249" translate="yes" xml:space="preserve">
          <source>My insert queries are slow. How can I speed them up?</source>
          <target state="translated">삽입 쿼리 속도가 느립니다. 속도를 높이려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4d572e4dbba9de4ec7b823d0ec15cdc5e5e700f7" translate="yes" xml:space="preserve">
          <source>My secondary index is outdated</source>
          <target state="translated">보조 인덱스가 오래되었습니다</target>
        </trans-unit>
        <trans-unit id="e7942af5c84b130986b851206ecc6f9a347c6d81" translate="yes" xml:space="preserve">
          <source>Name collision issues</source>
          <target state="translated">이름 충돌 문제</target>
        </trans-unit>
        <trans-unit id="57d2c00ce45ae19ada8881fa5212e7afd2ff2b8c" translate="yes" xml:space="preserve">
          <source>Native ReQL commands like &lt;code&gt;reconfigure&lt;/code&gt; also control sharding and replication, and if you&amp;rsquo;re not using server tags you can change sharding/replication settings in the web UI. Read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;reconfigure&lt;/code&gt; 과 같은 기본 ReQL 명령은 샤딩 및 복제도 제어하며 서버 태그를 사용하지 않는 경우 웹 UI에서 샤딩 / 복제 설정을 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b732272c643f080018849521bf6a04412a4035e5" translate="yes" xml:space="preserve">
          <source>Native language&amp;rsquo;s operations that have side effects or control blocks cannot be used within a &lt;code&gt;lambda&lt;/code&gt;. Learn more about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this design is implemented&lt;/a&gt; for details.</source>
          <target state="translated">부작용 또는 제어 블록이있는 모국어 작업은 &lt;code&gt;lambda&lt;/code&gt; 내에서 사용할 수 없습니다 . 세부 사항을 &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;위해이 디자인이 구현&lt;/a&gt; 되는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="87c96561f54572b1d2129d04e9b42119a72d9901" translate="yes" xml:space="preserve">
          <source>Near to the release of this performance report, we are excited to release RethinkDB 2.3 with plenty of new features. Rigorous performance testing, and properly publishing results is a very time-consuming process, but one we will conduct for future releases on an ongoing basis. We plan to publish our next set of metrics during the lifetime of the RethinkDB 2.3 release. We also would like to test RethinkDB performance when scaled to beyond a 16 node cluster during our next testing cycle. Going forward, we will include a summary of previous reports at the end of each report for comparison.</source>
          <target state="translated">이 성능 보고서의 출시가 가까워지면서 많은 새로운 기능을 갖춘 RethinkDB 2.3을 출시하게되어 기쁩니다. 엄격한 성능 테스트 및 결과 게시는 매우 시간이 걸리는 프로세스이지만 향후 릴리스를 위해 지속적으로 수행 할 것입니다. RethinkDB 2.3 릴리스 기간 동안 다음 측정 항목을 게시 할 계획입니다. 또한 다음 테스트주기 동안 16 노드 클러스터 이상으로 확장 될 때 RethinkDB 성능을 테스트하려고합니다. 앞으로는 각 보고서 끝에 이전 보고서 요약을 포함시켜 비교할 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f6fba18324193c1ccc35dd945f1c291c471bf6d" translate="yes" xml:space="preserve">
          <source>Negative &lt;code&gt;startOffset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; values are allowed with arrays; in that case, the returned range counts back from the array&amp;rsquo;s end. That is, the range &lt;code&gt;(-2)&lt;/code&gt; returns the last two elements, and the range of &lt;code&gt;(2,-1)&lt;/code&gt; returns the second element through the next-to-last element of the range. An error will be raised on a negative &lt;code&gt;startOffset&lt;/code&gt; or &lt;code&gt;endOffset&lt;/code&gt; with non-arrays. (An &lt;code&gt;endOffset&lt;/code&gt; of &amp;minus;1 &lt;em&gt;is&lt;/em&gt; allowed with a stream if &lt;code&gt;rightBound&lt;/code&gt; is closed; this behaves as if no &lt;code&gt;endOffset&lt;/code&gt; was specified.)</source>
          <target state="translated">음수 &lt;code&gt;startOffset&lt;/code&gt; 및 &lt;code&gt;endOffset&lt;/code&gt; 값은 배열에 허용됩니다. 이 경우 반환 된 범위는 배열의 끝부터 계산됩니다. 즉, 범위 &lt;code&gt;(-2)&lt;/code&gt; 는 마지막 두 요소를 반환하고 &lt;code&gt;(2,-1)&lt;/code&gt; 의 범위는 범위의 다음에서 마지막 요소까지 두 번째 요소를 반환합니다. 음수 가 아닌 &lt;code&gt;startOffset&lt;/code&gt; 또는 &lt;code&gt;endOffset&lt;/code&gt; 에서 배열이 아닌 경우 오류가 발생 합니다. &lt;code&gt;rightBound&lt;/code&gt; 가 닫히면 스트림 에 -1 의 &lt;code&gt;endOffset&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 허용되며 &lt;code&gt;endOffset&lt;/code&gt; 이 지정 되지 않은 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="55d06d5784fa220b321b58feb4840aab256fc83a" translate="yes" xml:space="preserve">
          <source>Nested resources in views</source>
          <target state="translated">뷰에서 중첩 된 리소스</target>
        </trans-unit>
        <trans-unit id="6ddf66c9236295cf80e623178cd3a86d93d90f71" translate="yes" xml:space="preserve">
          <source>Network options</source>
          <target state="translated">네트워크 옵션</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="24f947aa7d57d693ce1d98cdba36427bb9ce7386" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll connect to the RabbitMQ server using amqplib:</source>
          <target state="translated">다음으로 amqplib를 사용하여 RabbitMQ 서버에 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="16acb6d551b744fda3354c17a22ed53ee3c2a38e" translate="yes" xml:space="preserve">
          <source>No proxy for: (remove everything)</source>
          <target state="translated">프록시 없음 : (모든 항목 제거)</target>
        </trans-unit>
        <trans-unit id="d4388553ac2433a2d8de402d1a33e87d261b34cb" translate="yes" xml:space="preserve">
          <source>No special procedures or commands are necessary to execute RethinkDB queries asynchronously in JavaScript. Read about using callbacks and promises with RethinkDB in the documentation for the &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; command.</source>
          <target state="translated">JavaScript에서 RethinkDB 쿼리를 비동기식으로 실행하는 데 특별한 절차 나 명령이 필요하지 않습니다. &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; 명령 설명서에서 RethinkDB와의 콜백 및 약속 사용에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7695d8b90da619c62d4210a919c12878e58d47a6" translate="yes" xml:space="preserve">
          <source>No. However, you can export to GeoJSON and process that with other tools.</source>
          <target state="translated">그러나 GeoJSON으로 내보내고 다른 도구를 사용하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc6dfab40c56076b4529c151dc339fe0e28415a" translate="yes" xml:space="preserve">
          <source>NoBrainer adds a light wrapper around ReQL queries. Here are some examples:</source>
          <target state="translated">NoBrainer는 ReQL 쿼리 주위에 가벼운 래퍼를 추가합니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="2334597b85868c5bda45705d9c6dadcdc53b3feb" translate="yes" xml:space="preserve">
          <source>NoBrainer runs the validations only when saving, but not when retrieving a document. This means you can always retrieve your data, but an invalid model won&amp;rsquo;t be saved to the database.</source>
          <target state="translated">NoBrainer는 저장할 때만 유효성 검사를 실행하지만 문서를 검색 할 때는 유효성 검사를 실행하지 않습니다. 즉, 항상 데이터를 검색 할 수 있지만 잘못된 모델은 데이터베이스에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff74a5e83610f74cfb3d040f4dd2a594d12dd9d2" translate="yes" xml:space="preserve">
          <source>Node and Socket.io</source>
          <target state="translated">노드와 Socket.io</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="aa72935495ba47f9868598eb0972bab220cb0b79" translate="yes" xml:space="preserve">
          <source>Node.js Todo list</source>
          <target state="translated">Node.js 할 일 목록</target>
        </trans-unit>
        <trans-unit id="4839715bc122d856e205f2a6e684ab4b4c9e9787" translate="yes" xml:space="preserve">
          <source>Node.js libraries</source>
          <target state="translated">Node.js 라이브러리</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="60e056d9960d2aa21ce42b1232734ba6d3cb45ff" translate="yes" xml:space="preserve">
          <source>Not passing the &lt;code&gt;group_format&lt;/code&gt; flag would return:</source>
          <target state="translated">&lt;code&gt;group_format&lt;/code&gt; 플래그를 전달하지 않으면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a33a695a3e0e45a968fb7f12f79cb0174916eeb2" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; will ignore the &lt;code&gt;read_mode&lt;/code&gt; flag, and will always behave as if it is set to &lt;code&gt;single&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds이&lt;/a&gt; 무시됩니다 &lt;code&gt;read_mode&lt;/code&gt; 의 플래그를하고로 설정되어있는 것처럼 항상 작동합니다 &lt;code&gt;single&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23aa91cdc70b0f0c42f4dc080acc2e18f209da6b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;branch&lt;/code&gt;, the ReQL conditional command, must be used instead of &lt;code&gt;if&lt;/code&gt;. See the &lt;code&gt;branch&lt;/code&gt;&lt;a href=&quot;../branch/index&quot;&gt;documentation&lt;/a&gt; for more.</source>
          <target state="translated">그 주 &lt;code&gt;branch&lt;/code&gt; 는 ReQL 조건 명령이 대신 사용되어야 &lt;code&gt;if&lt;/code&gt; . 자세한 내용은 &lt;code&gt;branch&lt;/code&gt; &lt;a href=&quot;../branch/index&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="046b36ef7075cbe7dba601071ec0d34de7ee628d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;getAll&lt;/code&gt; and similar operations do &lt;em&gt;not&lt;/em&gt; execute in an atomic fashion with &lt;code&gt;update&lt;/code&gt;. Read &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for more details. Also, see the example for conditional updates below for a solution using &lt;code&gt;branch&lt;/code&gt; in an &lt;code&gt;update&lt;/code&gt; clause.</source>
          <target state="translated">참고 &lt;code&gt;filter&lt;/code&gt; , &lt;code&gt;getAll&lt;/code&gt; 메 와 유사한 작업을 할 &lt;em&gt;수 없습니다&lt;/em&gt; 와 원자 방식으로 실행 &lt;code&gt;update&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;일관성 보증&lt;/a&gt; 을 읽으십시오 . 또한 &lt;code&gt;update&lt;/code&gt; 절 에서 &lt;code&gt;branch&lt;/code&gt; 를 사용하는 솔루션에 대해서는 아래 조건부 업데이트 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3cce3c5063c9b4680ce2db7489bc86d18a9613e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;innerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; or &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;innerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">참고 것을 &lt;code&gt;innerJoin&lt;/code&gt; 가 느린 사용하는 것보다 훨씬 효율적이다 &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; 또는 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap을&lt;/a&gt; 함께 &lt;a href=&quot;../get_all/index&quot;&gt;를 getAll&lt;/a&gt; . 가능하면 명령에 &lt;code&gt;innerJoin&lt;/code&gt; 을 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="fb9c353d911b32d303fae6ec6ffcae4f1a653918" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;map&lt;/code&gt; can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the &lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt; command.</source>
          <target state="translated">참고 것을 &lt;code&gt;map&lt;/code&gt; 에만 시퀀스가 아닌 단일 값에 적용 할 수 있습니다. 단일 값 / 선택 (배열 포함)에 함수를 적용하려면 &lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="52edb1931a7678b06f40d0f67216ea63d608c768" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;outerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;outerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">참고 것을 &lt;code&gt;outerJoin&lt;/code&gt; 느린 사용하는 것보다 훨씬 효율적이다 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap을&lt;/a&gt; 함께 &lt;a href=&quot;../get_all/index&quot;&gt;를 getAll&lt;/a&gt; . 가능하면 명령에 &lt;code&gt;outerJoin&lt;/code&gt; 을 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="bd4b1c6ffc31ec1f99a87680dc2b303487664897" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;row&lt;/code&gt; does not work within subqueries to access nested documents; you should use anonymous functions to access those documents instead. (See the last example.)</source>
          <target state="translated">참고 &lt;code&gt;row&lt;/code&gt; 액세스 중첩 된 문서에 서브 쿼리 내에서 작동하지 않는다; 대신 익명 함수를 사용하여 해당 문서에 액세스해야합니다. (마지막 예 참조)</target>
        </trans-unit>
        <trans-unit id="d752e9b9c354ac26c00d43811dff01c2a8679e7b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;true&lt;/code&gt; in the example above is testing for the existence of &lt;code&gt;championships&lt;/code&gt; as a field, not testing to see if the value of the &lt;code&gt;championships&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt;. There&amp;rsquo;s a more convenient shorthand form available. (See &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; for more details on this.)</source>
          <target state="translated">참고 &lt;code&gt;true&lt;/code&gt; 위의 예는 존재에 대해 테스트하는 &lt;code&gt;championships&lt;/code&gt; 아닌 값 있는지 테스트 필드로 &lt;code&gt;championships&lt;/code&gt; 필드로 설정 &lt;code&gt;true&lt;/code&gt; . 보다 편리한 속기 형식이 있습니다. (자세한 내용은 &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="b95d53711950543d65d38ace0235593f05e863af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;write_acks&lt;/code&gt; and &lt;code&gt;durability&lt;/code&gt; don&amp;rsquo;t actually affect how the write is performed; they only affect when the acknowledgement is sent back to the client.</source>
          <target state="translated">하는 것으로 &lt;code&gt;write_acks&lt;/code&gt; 및 &lt;code&gt;durability&lt;/code&gt; 실제로 쓰기가 수행되는 방식에 영향을주지 않습니다; 승인이 클라이언트로 다시 전송 될 때만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="7020586ba6fb68f8b3332682998d8be66b7d38f3" translate="yes" xml:space="preserve">
          <source>Note that a line between the north pole and south pole (from latitude &amp;minus;90 to latitude 90) cannot be calculated, as &lt;em&gt;all&lt;/em&gt; possible paths between them are the &amp;ldquo;shortest&amp;rdquo;; this may trigger an error in ReQL or it may choose an arbitrary (but technically correct) path.</source>
          <target state="translated">북극과 남극 (위도 -90에서 위도 90) 사이의 선은 계산할 수 없습니다. 이들 사이의 &lt;em&gt;모든&lt;/em&gt; 가능한 경로는 &quot;가장 짧습니다&quot;. 이로 인해 ReQL에서 오류가 발생하거나 임의의 (기술적으로 올바른) 경로를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869310050eda36904b9b1684e375eea8a27df6a7" translate="yes" xml:space="preserve">
          <source>Note that an index may not be immediately available after creation. If your application needs to use indexes immediately after creation, use the &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; command to ensure the indexes are ready before use.</source>
          <target state="translated">작성 후 색인을 즉시 사용하지 못할 수 있습니다. 응용 프로그램에서 생성 직후 인덱스를 사용해야하는 경우 &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; 명령을 사용하여 인덱스를 사용하기 전에 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="cc7bb93e73f8b5f0f5aac10c43c2d4956feb9dc0" translate="yes" xml:space="preserve">
          <source>Note that by default, RethinkDB only opens connections bound to &lt;code&gt;localhost&lt;/code&gt; in order to prevent unauthorized clients on the network from connecting to the server. The &lt;code&gt;--bind all&lt;/code&gt; option allows connections from anywhere on the network. It works well if the network is protected.</source>
          <target state="translated">기본적으로 RethinkDB 는 네트워크의 인증되지 않은 클라이언트가 서버에 연결하지 못하도록 &lt;code&gt;localhost&lt;/code&gt; 에 바인딩 된 연결 만 엽니 다 . 는 &lt;code&gt;--bind all&lt;/code&gt; 옵션은 네트워크의 어느 곳에서나 연결을 할 수 있습니다. 네트워크가 보호되어 있으면 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="07fbecac98fcf0f3caf272d28683d05c9f00b5fe" translate="yes" xml:space="preserve">
          <source>Note that if you call &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;table&lt;/a&gt; with &lt;code&gt;identifier_format&lt;/code&gt; set to &lt;code&gt;uuid&lt;/code&gt;, then references to servers, tables and databases in the &lt;code&gt;info&lt;/code&gt; subdocument will be UUIDs rather than names.</source>
          <target state="translated">전화 할 경우주의 &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;테이블을&lt;/a&gt; 함께 &lt;code&gt;identifier_format&lt;/code&gt; 의 로 설정 &lt;code&gt;uuid&lt;/code&gt; , 다음의 서버, 테이블 및 데이터베이스에 대한 참조 &lt;code&gt;info&lt;/code&gt; 하위 문서가 UUID를 이름이 아닌 것이다.</target>
        </trans-unit>
        <trans-unit id="6ae89b9920878619801ec2ca89056fee59578b79" translate="yes" xml:space="preserve">
          <source>Note that if you didn&amp;rsquo;t call &lt;code&gt;ungroup&lt;/code&gt;, you would instead select one random game from each player:</source>
          <target state="translated">&lt;code&gt;ungroup&lt;/code&gt; 으로 전화하지 않았다면 대신 각 플레이어에서 하나의 무작위 게임을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="794a796e7f7b74c249460ac6df405541e4ffc7df" translate="yes" xml:space="preserve">
          <source>Note that in the last case, you&amp;rsquo;re required to provide a CA certificate as well. This is a certificate used to sign other certificates. In this case, we&amp;rsquo;re using the same certificate for both, but we could sign our &lt;code&gt;cert.pem&lt;/code&gt; with a different CA certificate and specify both of them. Servers can only connect to the cluster if the certificates specified by their &lt;code&gt;cluster-tls-cert&lt;/code&gt; value are signed by the CA certificate specified by &lt;code&gt;cluster-tls-ca&lt;/code&gt;.</source>
          <target state="translated">마지막 경우에는 CA 인증서도 제공해야합니다. 다른 인증서에 서명하는 데 사용되는 인증서입니다. 이 경우 두 인증서에 모두 동일한 인증서를 사용하지만 다른 CA 인증서로 &lt;code&gt;cert.pem&lt;/code&gt; 에 서명하고 두 인증서를 모두 지정할 수 있습니다. &lt;code&gt;cluster-tls-cert&lt;/code&gt; 값으로 지정된 인증서가 &lt;code&gt;cluster-tls-ca&lt;/code&gt; 로 지정된 CA 인증서로 서명 된 경우에만 서버가 클러스터에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a530ba90750d307c78bffe12c73f7bc690c170" translate="yes" xml:space="preserve">
          <source>Note that in this case, &lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt; may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:</source>
          <target state="translated">이 경우 함수 매개 변수가받는 것과 동일한 값을 반환하므로 &lt;a href=&quot;../row/index&quot;&gt;행&lt;/a&gt; 은 익명 함수를 작성하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d62e0a372be981e1086845747762fa68efdd64" translate="yes" xml:space="preserve">
          <source>Note that looping over a cursor must be done with &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;fetch_next&lt;/code&gt;, rather than using a &lt;code&gt;for x in cursor&lt;/code&gt; loop.</source>
          <target state="translated">&lt;code&gt;for x in cursor&lt;/code&gt; 루프 에서 for x를 사용하는 대신 &lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;fetch_next&lt;/code&gt; 로 커서를 반복해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9631e710ce7fec5bb59199fdbb7bd3ffaa2b587" translate="yes" xml:space="preserve">
          <source>Note that passwords will be sent in plaintext unless you are using TLS encryption. Instead of (or in addition to) TLS, you can bind the driver port and use SSH tunneling, as described below.</source>
          <target state="translated">TLS 암호화를 사용하지 않는 한 비밀번호는 일반 텍스트로 전송됩니다. TLS 대신 (또는 그에 추가하여) 아래 설명 된대로 드라이버 포트를 바인딩하고 SSH 터널링을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caab8be7c7ee8a44aad19ce23e3ceec991876422" translate="yes" xml:space="preserve">
          <source>Note that queries with &lt;code&gt;getAll&lt;/code&gt; or &lt;code&gt;between&lt;/code&gt; may return the same document multiple times unless you use the &lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;getAll&lt;/code&gt; 을 사용 하거나 &lt;code&gt;between&lt;/code&gt; 있는 쿼리 는 &lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt; 명령 을 사용하지 않으면 동일한 문서를 여러 번 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7c21b67930f527774bfd43705840df0f2b95c65" translate="yes" xml:space="preserve">
          <source>Note that rebuilding indexes is &lt;em&gt;not&lt;/em&gt; required if you&amp;rsquo;re upgrading between minor releases (i.e., 2.2.0 to 2.2.1).</source>
          <target state="translated">부 릴리스 (예 : 2.2.0에서 2.2.1)로 업그레이드하는 경우 인덱스를 다시 작성할 필요 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6f72e66b293b77e8428e776de4027ca58fa284cb" translate="yes" xml:space="preserve">
          <source>Note that server tags cannot be configured through RethinkDB&amp;rsquo;s web administration dashboard. They may be created and assigned through ReQL commands and scripts.</source>
          <target state="translated">서버 태그는 RethinkDB의 웹 관리 대시 보드를 통해 구성 할 수 없습니다. 그것들은 ReQL 명령과 스크립트를 통해 생성되고 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82182344e60cfb2c08352c68670095dcbc4419cc" translate="yes" xml:space="preserve">
          <source>Note that tables are configured on creation and when the &lt;code&gt;reconfigure&lt;/code&gt; command is called, but the configurations are &lt;em&gt;not&lt;/em&gt; stored by the server otherwise. To reconfigure tables consistently&amp;mdash;especially if your configuration uses server tags&amp;mdash;you should save the configuration in a script. Read more about this in &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">테이블은 작성시와 &lt;code&gt;reconfigure&lt;/code&gt; 명령이 호출 될 때 구성되지만 구성은 서버에 의해 저장 &lt;em&gt;되지 않습니다&lt;/em&gt; . 특히 구성에서 서버 태그를 사용하는 경우 테이블을 일관되게 재구성하려면 구성을 스크립트에 저장해야합니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../administration-tools/index&quot;&gt;관리 도구를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5a0befe8f4a2d2c04f639c1bc0ee0b7b9f3d58" translate="yes" xml:space="preserve">
          <source>Note that the left bound (including the implied left bound of 0 in the 0- and 1-argument form) is always closed and the right bound is always open: the start value will always be included in the returned range and the end value will &lt;em&gt;not&lt;/em&gt; be included in the returned range.</source>
          <target state="translated">왼쪽 경계 (0 및 1 인수 형식의 암시 적 왼쪽 경계 0 포함)는 항상 닫히고 오른쪽 경계는 항상 열려 있습니다. 시작 값은 항상 반환 된 범위에 포함되며 끝 값은 반환 된 범위에 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8c2fd8bb823ff27914611ee376d7f11e792c0216" translate="yes" xml:space="preserve">
          <source>Note that the sequence being merged&amp;mdash;in this example, the comments&amp;mdash;must be coerced from a selection to an array. Without &lt;code&gt;coerceTo&lt;/code&gt; the operation will throw an error (&amp;ldquo;Expected type DATUM but found SELECTION&amp;rdquo;).</source>
          <target state="translated">이 예에서 주석과 병합되는 시퀀스는 선택에서 배열로 강제 변환되어야합니다. &lt;code&gt;coerceTo&lt;/code&gt; 가 없으면 작업에 오류가 발생합니다 ( &quot;예상 유형 DATUM이지만 발견됨&quot;).</target>
        </trans-unit>
        <trans-unit id="e98abad9a62e2bab40d6be837e719bce034e43c6" translate="yes" xml:space="preserve">
          <source>Note that the values for &lt;code&gt;author_id&lt;/code&gt; correspond to the &lt;code&gt;id&lt;/code&gt; field of the author, which allows us to link the documents.</source>
          <target state="translated">&lt;code&gt;author_id&lt;/code&gt; 의 값 은 저자 의 &lt;code&gt;id&lt;/code&gt; 필드에 해당하므로 문서를 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ca43a4f1a4253668972ac4f388573e961d6210" translate="yes" xml:space="preserve">
          <source>Note that we first selected every author in the table, and then chained the &lt;code&gt;update&lt;/code&gt; command to the end of the query. We could also update a subset of documents by filtering the table first. Let&amp;rsquo;s update William Adama&amp;rsquo;s record to note that he has the rank of Admiral:</source>
          <target state="translated">먼저 테이블의 모든 작성자를 선택한 다음 &lt;code&gt;update&lt;/code&gt; 명령을 쿼리 끝에 연결했습니다 . 먼저 테이블을 필터링하여 문서의 하위 집합을 업데이트 할 수도 있습니다. 윌리엄 아다마 (William Adama)의 기록을 업데이트하여 제독 (Admiral) 계급을 보유하고 있음을 알아 봅시다.</target>
        </trans-unit>
        <trans-unit id="92ed5dd039e24ac49d654376ac966bb44a6b7f52" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;r.do()&lt;/code&gt; takes the function as its &lt;em&gt;last&lt;/em&gt; argument, &lt;code&gt;FUNCALL&lt;/code&gt; serializes the function as its &lt;em&gt;first&lt;/em&gt; argument.</source>
          <target state="translated">반면 참고 &lt;code&gt;r.do()&lt;/code&gt; 의 함수로서 얻어 &lt;em&gt;마지막&lt;/em&gt; 인자를 &lt;code&gt;FUNCALL&lt;/code&gt; 은 그와 같은 기능 직렬화 &lt;em&gt;제&lt;/em&gt; 인자.</target>
        </trans-unit>
        <trans-unit id="961048dc5c12584ceafa08e33e5c7ca4211def59" translate="yes" xml:space="preserve">
          <source>Note that you can omit the &lt;code&gt;db&lt;/code&gt; command if you&amp;rsquo;re creating a table in the default database on your connection (set to &lt;code&gt;test&lt;/code&gt; unless specified in &lt;code&gt;connect&lt;/code&gt;).</source>
          <target state="translated">연결시 기본 데이터베이스에 테이블을 작성하는 경우 ( &lt;code&gt;connect&lt;/code&gt; 에 지정되지 않은 경우 &lt;code&gt;test&lt;/code&gt; 하도록 설정) &lt;code&gt;db&lt;/code&gt; 명령을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02badbdd66f3ecc05d33efbafafd420cfaa47135" translate="yes" xml:space="preserve">
          <source>Note that you will not be able to read the &lt;code&gt;iterations&lt;/code&gt; value for an account; as it&amp;rsquo;s stored in the password field, it remains read-only.</source>
          <target state="translated">계정 의 &lt;code&gt;iterations&lt;/code&gt; 값 을 읽을 수는 없습니다 . 비밀번호 필드에 저장되므로 읽기 전용으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb089f10f83d1ccdecb1a60a861bab8d0ee2602" translate="yes" xml:space="preserve">
          <source>Note the command line parameters we used to start the second node:</source>
          <target state="translated">두 번째 노드를 시작하는 데 사용한 명령 줄 매개 변수에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="44da02227d007949366a19f44ea67a15d04cf1dc" translate="yes" xml:space="preserve">
          <source>Note the id of the security group. It will start with &lt;code&gt;sg-&lt;/code&gt;.</source>
          <target state="translated">보안 그룹의 ID를 기록하십시오. &lt;code&gt;sg-&lt;/code&gt; 로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="4be3a7d8983105ceac2d9d6226a9207c4e4a7f87" translate="yes" xml:space="preserve">
          <source>Note the port numbers you can use to access RethinkDB:</source>
          <target state="translated">RethinkDB에 액세스하는 데 사용할 수있는 포트 번호를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="520bd0b12df7f31816c20ea08f041b38cd1efc9c" translate="yes" xml:space="preserve">
          <source>Note: Only alphanumeric characters and underscores are valid for the database name.</source>
          <target state="translated">참고 : 데이터베이스 이름에는 영숫자와 밑줄 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e4f1dfb495411f7c79397bcc72d7fc74a5c0836b" translate="yes" xml:space="preserve">
          <source>Note: The last argument given will always be the &amp;lsquo;open&amp;rsquo; side of the range, but when generating a floating-point number, the &amp;lsquo;open&amp;rsquo; side may be less than the &amp;lsquo;closed&amp;rsquo; side.</source>
          <target state="translated">참고 : 마지막으로 주어진 인수는 항상 범위의 '개방형'측이지만 부동 소수점 숫자를 생성 할 때 '개방형'측은 '폐쇄'측보다 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="ceb637042a0d9428c0df8add2990697098a05c47" translate="yes" xml:space="preserve">
          <source>Notes on connections</source>
          <target state="translated">연결에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="b4d5a0b9e73af6cd9b264bcafa717aeda3b8bd40" translate="yes" xml:space="preserve">
          <source>Now consider a larger example:</source>
          <target state="translated">이제 더 큰 예를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="3a1aea1028da8d2cfbf3ca018738fc4dca263dc7" translate="yes" xml:space="preserve">
          <source>Now create an SSH tunnel on the server that needs to access the remote RethinkDB driver port:</source>
          <target state="translated">이제 원격 RethinkDB 드라이버 포트에 액세스해야하는 SSH 터널을 서버에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="36c86a37d15270331c5ca41f45f937ef93547855" translate="yes" xml:space="preserve">
          <source>Now for something more complicated: calculating the total and average quantities sold per item. For this, we&amp;rsquo;ll use the &lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt; function, which combines mapping and concatenation together. In this case, we want to produce a sequence of all the items sold throughout all the orders with their item IDs and quantities. We&amp;rsquo;ll also add a &amp;ldquo;count&amp;rdquo; field set to &lt;code&gt;1&lt;/code&gt;; we&amp;rsquo;ll use this the same way we used the mapping of each post in the blog example.</source>
          <target state="translated">이제 더 복잡한 것은 아이템 당 판매 된 총 수량과 평균 수량을 계산하는 것입니다. 이를 위해 매핑과 연결을 결합한 &lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt; 함수를 사용합니다 . 이 경우 모든 주문에서 판매 된 모든 품목을 품목 ID와 수량으로 순서대로 생성하려고합니다. 또한 &quot;count&quot;필드를 &lt;code&gt;1&lt;/code&gt; 로 설정합니다 . 블로그 예제에서 각 게시물의 매핑을 사용하는 것과 같은 방식으로이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83b7df19c7a7fab5f6f86d5d49556fd86a1c4ed9" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s access a real JSON API. In this example we&amp;rsquo;re going to use GitHub &amp;mdash; a collaborative development platform that hosts thousands of open-source projects. Users on GitHub can indicate interest by starring projects and following other users. GitHub calls users who starred other projects &amp;ldquo;stargazers&amp;rdquo;.</source>
          <target state="translated">이제 실제 JSON API에 액세스하십시오. 이 예에서는 수천 개의 오픈 소스 프로젝트를 호스팅하는 공동 개발 플랫폼 인 GitHub를 사용합니다. GitHub의 사용자는 프로젝트에 별표를 표시하고 다른 사용자를 팔로우하여 관심을 나타낼 수 있습니다. GitHub는 다른 프로젝트에 별표를 표시 한 사용자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7e792f8e7d51655e21b3f588eca27d6ee4ec76c2" translate="yes" xml:space="preserve">
          <source>Now start the second RethinkDB instance on the same machine:</source>
          <target state="translated">이제 동일한 머신에서 두 번째 RethinkDB 인스턴스를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c29ee53738e56f268012e978255da2e21fb2123f" translate="yes" xml:space="preserve">
          <source>Now switch back to your first terminal. We&amp;rsquo;ll be updating and deleting some documents in the next two sections. As we run these commands, the feed will push notifications to your program. The code above will print the following messages in the second terminal:</source>
          <target state="translated">이제 첫 번째 터미널로 다시 전환하십시오. 다음 두 섹션에서 일부 문서를 업데이트하고 삭제합니다. 이 명령을 실행하면 피드가 프로그램에 알림을 푸시합니다. 위의 코드는 두 번째 터미널에 다음 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a233b26c262807902c4cc9fc0e713ee2a3c939fb" translate="yes" xml:space="preserve">
          <source>Now that we inserted some data, let&amp;rsquo;s see how we can query the database!</source>
          <target state="translated">이제 몇 가지 데이터를 삽입 했으므로 데이터베이스를 쿼리하는 방법을 알아 보겠습니다!</target>
        </trans-unit>
        <trans-unit id="8efdd3a96ed18374cd2b44f39375f891439bba62" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve installed the plugin, the next step is to actually configure it to connect to our RethinkDB instance. We can do that by talking to Elasticsearch&amp;rsquo;s REST API. There are three concepts we need to deal with in the API: indexes, types, and documents. A document is the actual data being stored itself and is just JSON. A type contains documents and is similar to a table in RethinkDB. An index contains types and is similar to a database in RethinkDB.</source>
          <target state="translated">이제 플러그인을 설치 했으므로 다음 단계는 실제로 RethinkDB 인스턴스에 연결하도록 플러그인을 구성하는 것입니다. Elasticsearch의 REST API와 대화하면 가능합니다. API에서 다루어야 할 개념은 인덱스, 유형 및 문서의 세 가지입니다. 문서는 실제로 저장되는 실제 데이터이며 JSON입니다. 유형은 문서를 포함하며 RethinkDB의 테이블과 유사합니다. 색인은 유형을 포함하며 RethinkDB의 데이터베이스와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e816e64d8ebb842e4b0118841e17ba4aab267ea3" translate="yes" xml:space="preserve">
          <source>Now the coroutine will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">이제 코 루틴이 백그라운드에서 실행되어 변경 사항을 인쇄합니다. 테이블을 변경하면 변경 사항이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="88579e11bba37adb2b24fcaf9dceaf04746ffa0d" translate="yes" xml:space="preserve">
          <source>Now the task will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">이제 작업이 백그라운드에서 실행되어 변경 사항이 인쇄됩니다. 테이블을 변경하면 변경 사항이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="96aaeca03bd2a83f83cdc2012364ba4295826827" translate="yes" xml:space="preserve">
          <source>Now we can plug our changes directly into Rabbit:</source>
          <target state="translated">이제 변경 사항을 Rabbit에 직접 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cca3688c70abd6d885cd1f6703f8f921526df1a" translate="yes" xml:space="preserve">
          <source>Now we can publish any arbitrary JSON document to the topic:</source>
          <target state="translated">이제 임의의 JSON 문서를 주제에 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2399a2288ab147cdf7e8afafb71d676fc702e4fb" translate="yes" xml:space="preserve">
          <source>Now we need to &amp;ldquo;bind&amp;rdquo; the queue to the topics we&amp;rsquo;re interested in. Other listeners can subscribe to the same topic, and Rabbit will copy the message for every queue. Here, we&amp;rsquo;ll just keep it simple and bind to all events from &amp;ldquo;mytable&amp;rdquo;:</source>
          <target state="translated">이제 관심있는 주제에 대기열을&amp;ldquo;바인드&amp;rdquo;해야합니다. 다른 리스너는 동일한 주제에 가입 할 수 있으며 Rabbit은 모든 대기열에 대해 메시지를 복사합니다. 여기서는 간단하게 유지하고&amp;ldquo;mytable&amp;rdquo;의 모든 이벤트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="0c8880d6597c3169973e8e1627a2c6d6907027cb" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;d like to sort RethinkDB stargazers by influence. When you request stargazers from GitHub, the GitHub API doesn&amp;rsquo;t include the number of followers for each stargazer, but it does include a field &lt;code&gt;url&lt;/code&gt; specific to each stargazer. If you follow this URL, the GitHub API will return additional information for the user, including the number of their followers.</source>
          <target state="translated">이제 RethinkDB stargazer를 영향별로 정렬하려고합니다. GitHub에서 stargazer를 요청하면 GitHub API에는 각 stargazer의 팔로어 수가 포함되지 않지만 각 stargazer에 고유 한 필드 &lt;code&gt;url&lt;/code&gt; 은 포함됩니다 . 이 URL을 따르면 GitHub API는 팔로어 수를 포함하여 사용자에 대한 추가 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ceb299c25786316a08bb16460c9243fa1eec175" translate="yes" xml:space="preserve">
          <source>Now with a &amp;ldquo;clean&amp;rdquo; data set we can run simple reports right in the Data Explorer. (You might want to switch to Table View for some of these, and you can also add &lt;code&gt;.without('id')&lt;/code&gt; in the command chain to &amp;ldquo;prettify&amp;rdquo; the table display if you wish.)</source>
          <target state="translated">이제 &quot;깨끗한&quot;데이터 세트를 사용하여 데이터 탐색기에서 간단한 보고서를 바로 실행할 수 있습니다. (일부 테이블 뷰로 전환하고 싶을 때 명령 체인에 &lt;code&gt;.without('id')&lt;/code&gt; 를 추가하여 원하는 경우 테이블 디스플레이를 &quot;예비&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9caa73cdf116b57684d6c1c8b8b9f44f4d600fcd" translate="yes" xml:space="preserve">
          <source>Now, consider a larger example.</source>
          <target state="translated">이제 더 큰 예를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="afea3b1aecf0d259448b1b35c58dad9976a271d3" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s get those back:</source>
          <target state="translated">이제 다시 돌려 드리겠습니다 :</target>
        </trans-unit>
        <trans-unit id="e6ed379404867578a5a6db513257215a7d553130" translate="yes" xml:space="preserve">
          <source>Now, use one of the following two methods to enable secure access.</source>
          <target state="translated">이제 다음 두 가지 방법 중 하나를 사용하여 보안 액세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fba0bbb4e77831e38e81b55c86757fe6c887f2ef" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll &lt;code&gt;group&lt;/code&gt; by the &lt;code&gt;item_id&lt;/code&gt; field and use a custom &lt;code&gt;reduce&lt;/code&gt; function to sum the quantities and counts.</source>
          <target state="translated">이제, 우리는거야 &lt;code&gt;group&lt;/code&gt; 에 의해 &lt;code&gt;item_id&lt;/code&gt; 필드와 사용자 정의를 사용 &lt;code&gt;reduce&lt;/code&gt; 수량과 횟수를 요약하는 기능.</target>
        </trans-unit>
        <trans-unit id="c4dffe1e129e38cabba8445af4a117e656e614bc" translate="yes" xml:space="preserve">
          <source>Now, when any heroes are added, modified or deleted from either table, a change notification will be sent out.</source>
          <target state="translated">이제 영웅이 테이블에서 추가, 수정 또는 삭제되면 변경 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2c148f3b7dd44ba4e2ab9591ded50bd106dde2f1" translate="yes" xml:space="preserve">
          <source>Now, you can use ReQL commands to query system tables and perform reconfiguration commands. To return the server status, you can query the &lt;code&gt;server_status&lt;/code&gt; system table in the special &lt;code&gt;rethinkdb&lt;/code&gt; database.</source>
          <target state="translated">이제 ReQL 명령을 사용하여 시스템 테이블을 쿼리하고 재구성 명령을 수행 할 수 있습니다. 서버 상태를 리턴하기 위해 특수 &lt;code&gt;rethinkdb&lt;/code&gt; 데이터베이스 에서 &lt;code&gt;server_status&lt;/code&gt; 시스템 테이블을 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85120bce76a23e361fb938c44bc73facc906afcd" translate="yes" xml:space="preserve">
          <source>ORMs</source>
          <target state="translated">ORMs</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="3868dbba6ab95babefa387180cf6de66e170f8ea" translate="yes" xml:space="preserve">
          <source>Official RethinkDB client drivers for Python, JavaScript, Java, and Ruby</source>
          <target state="translated">Python, JavaScript, Java 및 Ruby 용 공식 RethinkDB 클라이언트 드라이버</target>
        </trans-unit>
        <trans-unit id="74cdd5cbbd592f9b99c0f8d5979f1463f350d5ff" translate="yes" xml:space="preserve">
          <source>Official drivers</source>
          <target state="translated">공식 드라이버</target>
        </trans-unit>
        <trans-unit id="ebd6ec34f67b785d250d426fa00edef1acad05a5" translate="yes" xml:space="preserve">
          <source>Official packages</source>
          <target state="translated">공식 패키지</target>
        </trans-unit>
        <trans-unit id="831937a5ef9ec548ca483436b44fdfe4b969dfca" translate="yes" xml:space="preserve">
          <source>Older versions</source>
          <target state="translated">이전 버전</target>
        </trans-unit>
        <trans-unit id="d65b6345aa5b8fc44215a53289fccbbb539c6d88" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code as above.</source>
          <target state="translated">에 &lt;code&gt;false&lt;/code&gt; , 서버는 위와 같이 오류 및 오류 코드를 보내드립니다.</target>
        </trans-unit>
        <trans-unit id="c1cebe4c7f1c61569d9257cc40cc35bbf81ae6de" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code.</source>
          <target state="translated">에 &lt;code&gt;false&lt;/code&gt; , 서버는 오류 및 오류 코드를 보내드립니다.</target>
        </trans-unit>
        <trans-unit id="4412954aef37a85b9b6c203be268bc8e49fc7bc0" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;failure,&lt;/strong&gt; the server sends a null-terminated error string (&lt;em&gt;not&lt;/em&gt; JSON).</source>
          <target state="translated">에 &lt;strong&gt;실패,&lt;/strong&gt; 서버는 널 종료 오류 문자열 (전송 &lt;em&gt;하지&lt;/em&gt; JSON을).</target>
        </trans-unit>
        <trans-unit id="f51347c7500404083d9d35f76646a95435173ff5" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;success,&lt;/strong&gt; the server sends a null-terminated JSON response, indicating success, minimum and maximum protocol versions, and the server version.</source>
          <target state="translated">에 &lt;strong&gt;성공,&lt;/strong&gt; 서버는 성공, 최소 및 최대 프로토콜 버전 및 서버 버전을 나타내는 널 종료 JSON 응답을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bb940d279b36ee1325e1f1b7715aa2df3888293b" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB marketplace page&lt;/a&gt;, click the &lt;strong&gt;Continue&lt;/strong&gt; button.</source>
          <target state="translated">온 &lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB 시장 페이지&lt;/a&gt; 의 클릭 &lt;strong&gt;계속&lt;/strong&gt; 버튼을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="b81c1cb3f1e6975a3ac220d8d48062c1f8158f69" translate="yes" xml:space="preserve">
          <source>Once RethinkDB is running, you can connect to it at &lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;, assuming you&amp;rsquo;ve kept the default port (8080) and it&amp;rsquo;s running on your local machine.</source>
          <target state="translated">RethinkDB가 실행되면 기본 포트 (8080)를 유지하고 로컬 컴퓨터에서 실행 중이라고 가정 하고 &lt;a href=&quot;http://localhost:8080&quot;&gt;http : // localhost : 8080&lt;/a&gt; 에서 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee24599fbbe748a6207ac5abb75b2f0ce146744" translate="yes" xml:space="preserve">
          <source>Once a server has been given a tag, the tags may be used to assign table replicas to servers with the same tags using the &lt;code&gt;reconfigure&lt;/code&gt; command. Read the section of this document on &lt;a href=&quot;#server-tags&quot;&gt;Server tags&lt;/a&gt; for more details.</source>
          <target state="translated">서버에 태그가 제공되면 태그를 사용하여 &lt;code&gt;reconfigure&lt;/code&gt; 명령을 사용하여 동일한 태그를 가진 서버에 테이블 복제본을 할당 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;#server-tags&quot;&gt;서버 태그&lt;/a&gt; 에서이 문서의 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e5540408974abb67910a41cc619a4fa95a13d057" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;run&lt;/a&gt; command is processed, the serialized query needs to be wrapped in the message sent to the server. The complete message takes the form:</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;실행&lt;/a&gt; 명령이 처리 되면 서버로 전송 된 메시지에서 직렬화 된 쿼리를 랩핑해야합니다. 완전한 메시지는 다음과 같은 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="53bf8635a8710aec13732e6e69e7bc521527324f" translate="yes" xml:space="preserve">
          <source>Once the query is sent, you can read the response object back from the server. The response object takes the following form:</source>
          <target state="translated">조회가 전송되면 서버에서 응답 오브젝트를 다시 읽을 수 있습니다. 응답 오브젝트는 다음 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="3581112a511227ecab2edb84928b539f7af5864d" translate="yes" xml:space="preserve">
          <source>Once you block the web interface port in the step above, the easiest way to access it is to use ssh to set up a SOCKS proxy. Run the following command on your local server (not the one running RethinkDB):</source>
          <target state="translated">위 단계에서 웹 인터페이스 포트를 차단하면 가장 쉬운 액세스 방법은 ssh를 사용하여 SOCKS 프록시를 설정하는 것입니다. 로컬 서버에서 다음 명령을 실행하십시오 (RethinkDB를 실행하는 명령 아님).</target>
        </trans-unit>
        <trans-unit id="d54a699f360387d75f05e3a07ed4952abe9ff92f" translate="yes" xml:space="preserve">
          <source>Once you have several machines in a RethinkDB cluster, you can improve your cluster&amp;rsquo;s efficiency by running a &lt;em&gt;proxy node&lt;/em&gt; on each application server and having the client application connect to the proxy on &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 클러스터에 여러 머신이 있으면 각 애플리케이션 서버에서 &lt;em&gt;프록시 노드&lt;/em&gt; 를 실행 하고 클라이언트 애플리케이션을 &lt;code&gt;localhost&lt;/code&gt; 의 프록시에 연결 하여 클러스터의 효율성을 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dbb1fe10358fc30c28cd5763913addfac15ea73" translate="yes" xml:space="preserve">
          <source>Once you start using the &lt;code&gt;EventEmitter&lt;/code&gt; interface, the other RethinkDB cursor commands like &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;toArray&lt;/code&gt;, and &lt;code&gt;each&lt;/code&gt; will not be available anymore.</source>
          <target state="translated">당신이 사용하기 시작하면 &lt;code&gt;EventEmitter&lt;/code&gt; 의 인터페이스를 다른 RethinkDB 커서 명령 좋아 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;toArray&lt;/code&gt; 를 , 그리고 &lt;code&gt;each&lt;/code&gt; 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e0cf5a9798cd7d0b4bee1fb0bc70175a34b8763" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve got the data in your Elasticsearch server, you&amp;rsquo;re ready to go. Here&amp;rsquo;s an example of a simple query using the Elasticsearch REST API:</source>
          <target state="translated">Elasticsearch 서버에 데이터가 있으면 준비가 된 것입니다. 다음은 Elasticsearch REST API를 사용하는 간단한 쿼리의 예입니다.</target>
        </trans-unit>
        <trans-unit id="91405022f24ea795a6deb7e4bd6123de31f00a95" translate="yes" xml:space="preserve">
          <source>One document exists in &lt;code&gt;db_config&lt;/code&gt; for each database in the cluster, with only two fields in the document.</source>
          <target state="translated">클러스터의 각 데이터베이스에 대해 하나의 문서가 &lt;code&gt;db_config&lt;/code&gt; 에 있으며 문서에는 두 개의 필드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aefbe1f3a3edcbf196b9064f46c2b010b75a91e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a coroutine set to consume a changefeed indefinitely, and the connection closes, the coroutine will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">특히 하나의 오류가 눈에.니다. 변경 피드를 무기한 소비하도록 설정된 코 루틴이 있고 연결이 닫히면 코 루틴에 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f970864af19d41ebb8dfcca5915e187b5747d24e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a task that consumes a changefeed indefinitely, and the connection closes, the task will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">특히 하나의 오류가 눈에.니다. 변경 피드를 무기한 소비하는 작업이 있고 연결이 닫히면 작업에 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="16aa2d8ea363974f203646459194020c667345ca" translate="yes" xml:space="preserve">
          <source>One more way to write the previous query is to set the age to be &lt;code&gt;-1&lt;/code&gt; when the field is missing.</source>
          <target state="translated">이전 쿼리를 작성하는 또 다른 방법 은 필드가 없을 때 &lt;code&gt;-1&lt;/code&gt; 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e019a9ff633c6020fe2ace6839ac83a61316c9" translate="yes" xml:space="preserve">
          <source>One to many relations</source>
          <target state="translated">일대 다 관계</target>
        </trans-unit>
        <trans-unit id="2e0254c28e2b06c621fe3e5af23ceeb7e03e64e7" translate="yes" xml:space="preserve">
          <source>Ongoing</source>
          <target state="translated">Ongoing</target>
        </trans-unit>
        <trans-unit id="066193625de0ad53074bd617e05acb13fb7e193d" translate="yes" xml:space="preserve">
          <source>Only a limited subset of ReQL commands may be chained after &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 후에는 제한된 ReQL 명령의 하위 집합 만 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bddea468cb2adb77cc258c3b88f6e01f0752c0bc" translate="yes" xml:space="preserve">
          <source>Only longitude/latitude coordinates are supported. GeoJSON objects that use Cartesian coordinates, specify an altitude, or specify their own coordinate reference system will be rejected.</source>
          <target state="translated">경도 / 위도 좌표 만 지원됩니다. 직교 좌표를 사용하거나 고도를 지정하거나 자체 좌표 참조 시스템을 지정하는 GeoJSON 객체는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="262b6559e88c687d15b623deba02fac703403295" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to the server on the driver port. The default port is &lt;code&gt;28015&lt;/code&gt;.</source>
          <target state="translated">드라이버 포트에서 서버에 대한 TCP 연결을 엽니 다. 기본 포트는 &lt;code&gt;28015&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1c232e4ef552d94c7bc322934608dfd9c1f3678b" translate="yes" xml:space="preserve">
          <source>Open a connection</source>
          <target state="translated">연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="65160f68c4c399c8650355e13e625aa1a85b20f6" translate="yes" xml:space="preserve">
          <source>Open the &lt;strong&gt;Security Groups&lt;/strong&gt; section of the administration console.</source>
          <target state="translated">관리 콘솔 의 &lt;strong&gt;보안 그룹&lt;/strong&gt; 섹션을여십시오.</target>
        </trans-unit>
        <trans-unit id="3098205123cfb916f292fb3965082298a4ab6621" translate="yes" xml:space="preserve">
          <source>Open the RethinkDB Data Explorer in the web UI and execute the following command:</source>
          <target state="translated">웹 UI에서 RethinkDB Data Explorer를 열고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="26e94e9d577c801c827b900c0b793db4e3600d97" translate="yes" xml:space="preserve">
          <source>OpenSSL will ask you to enter information for the certificate. While some of these questions can be left at their default, the &amp;ldquo;Common Name&amp;rdquo; must match the domain name of your server. For local testing purposes you can use &lt;code&gt;localhost&lt;/code&gt;, but not in production.</source>
          <target state="translated">OpenSSL은 인증서 정보를 입력하도록 요청합니다. 이러한 질문 중 일부는 기본값으로 남겨 둘 수 있지만 &quot;공통 이름&quot;은 서버의 도메인 이름과 일치해야합니다. 로컬 테스트 목적으로 &lt;code&gt;localhost&lt;/code&gt; 를 사용할 수 있지만 프로덕션에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="005f473987f60d5de30a1511d957a61d11d7b074" translate="yes" xml:space="preserve">
          <source>Opera 1.62 or higher</source>
          <target state="translated">오페라 1.62 이상</target>
        </trans-unit>
        <trans-unit id="800944565827543e19a120253438c1772df26425" translate="yes" xml:space="preserve">
          <source>Operations on authors and posts don&amp;rsquo;t require loading the data for every post for a given author into memory.</source>
          <target state="translated">작성자 및 게시물에 대한 작업은 지정된 작성자의 모든 게시물에 대한 데이터를 메모리에로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67910125278b444143eb3baa7f7a144f98b62c28" translate="yes" xml:space="preserve">
          <source>Optimizing query performance</source>
          <target state="translated">쿼리 성능 최적화</target>
        </trans-unit>
        <trans-unit id="3c7b449b88c10330229439fe19c9db3e4b06af90" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;circle&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;circle&lt;/code&gt; 과 함께 사용할 수있는 선택적 인수 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e91d767910b702fe59c28c74e7779fc7e01b53ac" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;distance&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;distance&lt;/code&gt; 와 함께 사용할 수있는 선택적 인수 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="655dae8fdf9f43c66dc061c5ade6f0a366837031" translate="yes" xml:space="preserve">
          <source>Options for imports include:</source>
          <target state="translated">가져 오기 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52b7d82bd544399dc5fb544375b8f490d76aeee0" translate="yes" xml:space="preserve">
          <source>Options to &lt;code&gt;dump&lt;/code&gt; let you specify cluster information and limit the archive to specific databases or tables.</source>
          <target state="translated">&lt;code&gt;dump&lt;/code&gt; 옵션을 사용하면 클러스터 정보를 지정하고 아카이브를 특정 데이터베이스 또는 테이블로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82e2b89585dcea4afe8d1cf12f407a6d9a9afae" translate="yes" xml:space="preserve">
          <source>Or create a secondary index on them:</source>
          <target state="translated">또는 보조 인덱스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="76ee0a831a4163c3b30755e038356362dcf59b70" translate="yes" xml:space="preserve">
          <source>Or, Bob&amp;rsquo;s work phone and Skype handle:</source>
          <target state="translated">또는 Bob의 업무용 전화 및 Skype는 다음을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dea3c588ab8bfc482b4550169db7672275347564" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s pluck out usernames and IDs, and sort the array in ascending order by user IDs:</source>
          <target state="translated">또는 사용자 이름과 ID를 뽑아 배열을 오름차순으로 사용자 ID별로 정렬 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8617c20d3ebc00ea8af63ceb4ece5ae885ba2bb" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s try to delete a single user:</source>
          <target state="translated">또는 단일 사용자를 삭제 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="517d47ffe448c40f8d65907d0e9bbb885347087a" translate="yes" xml:space="preserve">
          <source>Oracle Java 1.8.0 on the client nodes</source>
          <target state="translated">클라이언트 노드의 Oracle Java 1.8.0</target>
        </trans-unit>
        <trans-unit id="a67de582176ad1685ed737600c40cb806a9dc02a" translate="yes" xml:space="preserve">
          <source>Order by date and title.</source>
          <target state="translated">날짜와 제목으로 주문하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3437a75ca6256f37c2450c0c776fb565f1c788" translate="yes" xml:space="preserve">
          <source>Ordering without an index requires the server to load the whole sequence in an array, which is limited by default to 100,000 documents. You can use the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; to temporarily raise this limit. However, a more efficient option is to use an index. See the documentation for &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; for more information.</source>
          <target state="translated">색인없이 주문하려면 서버가 전체 시퀀스를 배열로로드해야하며, 기본적으로 100,000 개의 문서로 제한됩니다. &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 사용 하여이 한계를 일시적으로 높이기 위해 &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;실행할&lt;/a&gt; 수 있습니다 . 그러나보다 효율적인 옵션은 인덱스를 사용하는 것입니다. 자세한 내용은 &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0635fe7d51a8df49e7a657f79a8f6473abb466ab" translate="yes" xml:space="preserve">
          <source>Organizing by value with &lt;strong&gt;multi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;멀티&lt;/strong&gt; 를 이용한 가치 구성&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02920c862ccbff6d9ea90f0249e6739c73f53be8" translate="yes" xml:space="preserve">
          <source>Other architectures</source>
          <target state="translated">다른 아키텍처</target>
        </trans-unit>
        <trans-unit id="bc1c9b417f89fe542bb1934f83a9192b283b0bb0" translate="yes" xml:space="preserve">
          <source>Other tables</source>
          <target state="translated">다른 테이블</target>
        </trans-unit>
        <trans-unit id="2650dbe4bcd4f307dc4c1b316b876d711322bfab" translate="yes" xml:space="preserve">
          <source>Other things that might be helpful to us, if you have them:</source>
          <target state="translated">도움이 될만한 다른 것들이 있다면 :</target>
        </trans-unit>
        <trans-unit id="866131f1f2375ca571ce12c268e0c656ecbc12e4" translate="yes" xml:space="preserve">
          <source>Other unusual configuration details</source>
          <target state="translated">다른 특이한 구성 세부 사항</target>
        </trans-unit>
        <trans-unit id="3f6f6d94cdfb57598370b4d3559b5ea5baf371fc" translate="yes" xml:space="preserve">
          <source>Otherwise, a document was updated from &lt;code&gt;new_val&lt;/code&gt; to &lt;code&gt;old_val&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면, 문서에서 업데이트 된 &lt;code&gt;new_val&lt;/code&gt; 에 &lt;code&gt;old_val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635983c30fa94cc702bf5a3063575de06b27f6c0" translate="yes" xml:space="preserve">
          <source>Our first workload from YCSB is workload A. It performs an equal number of get and update operations.</source>
          <target state="translated">YCSB의 첫 번째 워크로드는 워크로드 A입니다. 동일한 수의 가져 오기 및 업데이트 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c3102dfdc420ea7f4b95502211100be74c8d001e" translate="yes" xml:space="preserve">
          <source>Our long-term goal is to port RethinkDB to every widely-used platform. &lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;Get involved&lt;/a&gt; in the development effort and help port RethinkDB to more platforms.</source>
          <target state="translated">우리의 장기적인 목표는 RethinkDB를 널리 사용되는 모든 플랫폼으로 이식하는 것입니다. 개발 노력에 &lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;참여&lt;/a&gt; 하고 RethinkDB를 더 많은 플랫폼으로 이식하십시오.</target>
        </trans-unit>
        <trans-unit id="9d27e01bc1f16af9ab5b684bbca08e77d04c7441" translate="yes" xml:space="preserve">
          <source>Outdated index issues</source>
          <target state="translated">오래된 인덱스 문제</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1ad9f67d0f855f646efb3775c7a4778a3cc5a138" translate="yes" xml:space="preserve">
          <source>Parallelism</source>
          <target state="translated">Parallelism</target>
        </trans-unit>
        <trans-unit id="a3f2f9b464ffd6a075b16b138e68eee36eb4fad2" translate="yes" xml:space="preserve">
          <source>Parse a JSON string on the server.</source>
          <target state="translated">서버에서 JSON 문자열을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="a02cd3149b8489d7554699018bd6802639a0fb15" translate="yes" xml:space="preserve">
          <source>Parsing RethinkDB&amp;rsquo;s response to a write query</source>
          <target state="translated">쓰기 쿼리에 대한 RethinkDB의 응답 구문 분석</target>
        </trans-unit>
        <trans-unit id="d5ed1ca0e30841762087801ad0ea2356bf068bd4" translate="yes" xml:space="preserve">
          <source>Passport</source>
          <target state="translated">Passport</target>
        </trans-unit>
        <trans-unit id="a6ef67119795d1dec2733382dde8851959466fd2" translate="yes" xml:space="preserve">
          <source>Password hashing iterations</source>
          <target state="translated">비밀번호 해시 반복</target>
        </trans-unit>
        <trans-unit id="602f708ddfd2f5c04ef6214f07b92793c6440c57" translate="yes" xml:space="preserve">
          <source>Pastie app</source>
          <target state="translated">페이스트리 앱</target>
        </trans-unit>
        <trans-unit id="9ee3e3fb749ad0b1c61fd33d63af73925ef460d8" translate="yes" xml:space="preserve">
          <source>Perform a branching conditional equivalent to &lt;code&gt;if-then-else&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if-then-else&lt;/code&gt; 와 동등한 분기 조건을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb5dcdc44fc2c6fa0229180b4ba0e6617436df4" translate="yes" xml:space="preserve">
          <source>Perform a handshake</source>
          <target state="translated">악수를 수행</target>
        </trans-unit>
        <trans-unit id="31d145708b03b1271ba67061462d8bf7d2aa9ca6" translate="yes" xml:space="preserve">
          <source>Performance Details</source>
          <target state="translated">성능 세부 사항</target>
        </trans-unit>
        <trans-unit id="d8de1447c9bf3acce93c7e508a1c29a20555687a" translate="yes" xml:space="preserve">
          <source>Performance report</source>
          <target state="translated">성과 보고서</target>
        </trans-unit>
        <trans-unit id="1a7039a0fe11cfbcaf911a9186d34c5c3a09eeb8" translate="yes" xml:space="preserve">
          <source>Performing a conditional insert or replace</source>
          <target state="translated">조건부 삽입 또는 교체 수행</target>
        </trans-unit>
        <trans-unit id="933b62ca112baccc2befe203fa03de8a89c72068" translate="yes" xml:space="preserve">
          <source>Performing a pivot operation</source>
          <target state="translated">피벗 작업 수행</target>
        </trans-unit>
        <trans-unit id="a9d4d7d7d35c4a76ac97d509252cf3e581c5e1dc" translate="yes" xml:space="preserve">
          <source>Performing an unpivot operation</source>
          <target state="translated">피벗 해제 작업 수행</target>
        </trans-unit>
        <trans-unit id="c0bc0b17b999bff2f1cc8b8c30efeb6034e0c0a9" translate="yes" xml:space="preserve">
          <source>Performing multiple aggregations simultaneously</source>
          <target state="translated">여러 집계를 동시에 수행</target>
        </trans-unit>
        <trans-unit id="a03eb97735ec7717f1d64f293267ac389abb2754" translate="yes" xml:space="preserve">
          <source>Performs 200 million operations in total</source>
          <target state="translated">총 2 억 건의 작업 수행</target>
        </trans-unit>
        <trans-unit id="1f85efe74af8d3b3506a24e9543f0465c2109af2" translate="yes" xml:space="preserve">
          <source>Performs 50 million operations in total</source>
          <target state="translated">총 5 천만 건의 작업 수행</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="627aed65a0d9d2626caf51bb839dcee691e75d17" translate="yes" xml:space="preserve">
          <source>Permissions and user accounts</source>
          <target state="translated">권한 및 사용자 계정</target>
        </trans-unit>
        <trans-unit id="0ac88ea84587ef82d96b641061e89b7e0e66ff2c" translate="yes" xml:space="preserve">
          <source>Permissions are stored in the &lt;code&gt;permissions&lt;/code&gt; system table. While you can change permissions by modifying documents within that table, it&amp;rsquo;s far more convenient to use the &lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt; command; see below.</source>
          <target state="translated">권한은 &lt;code&gt;permissions&lt;/code&gt; 시스템 테이블에 저장됩니다 . 해당 테이블 내에서 문서를 수정하여 권한을 변경할 수 있지만 &lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt; 명령 을 사용하는 것이 훨씬 편리합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf871a8778973cc849027508cdc967888db0dc66" translate="yes" xml:space="preserve">
          <source>Permissions may be granted on a global scope, or granted for a specific table or database. The scope is defined by calling &lt;code&gt;grant&lt;/code&gt; on its own (e.g., &lt;code&gt;r.grant()&lt;/code&gt;, on a table (&lt;code&gt;r.table().grant()&lt;/code&gt;), or on a database (&lt;code&gt;r.db().grant()&lt;/code&gt;).</source>
          <target state="translated">전역 범위에서 권한을 부여하거나 특정 테이블 또는 데이터베이스에 대해 권한을 부여 할 수 있습니다. 범위는 그 자체로 &lt;code&gt;grant&lt;/code&gt; (예 : &lt;code&gt;r.grant()&lt;/code&gt; , 테이블 ( &lt;code&gt;r.table().grant()&lt;/code&gt; ) 또는 데이터베이스 ( &lt;code&gt;r.db().grant()&lt;/code&gt; ) )를 호출 하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb767066d9789af7d92101acfb56fb7687bff20c" translate="yes" xml:space="preserve">
          <source>Permissions specified at a lower level will override permissions set at a higher level: a user could be granted read and write access to the &lt;code&gt;field_notes&lt;/code&gt; database, but denied the ability to write to the &lt;code&gt;calendar&lt;/code&gt; table and to either read or write to the &lt;code&gt;supervisor_only&lt;/code&gt; table.</source>
          <target state="translated">하위 수준에서 지정된 권한은 상위 수준에서 설정된 권한보다 우선합니다. 사용자에게는 &lt;code&gt;field_notes&lt;/code&gt; 데이터베이스에 대한 읽기 및 쓰기 권한이 부여 될 수 있지만 &lt;code&gt;calendar&lt;/code&gt; 테이블에 쓰고 &lt;code&gt;supervisor_only&lt;/code&gt; 테이블 에 대한 쓰기 또는 쓰기 기능은 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="d15069fb8e15cad486a5d82a9690982408a75b0e" translate="yes" xml:space="preserve">
          <source>Permissions that are not defined on a local scope will be inherited from the next largest scope. For example, a write operation on a table will first check if &lt;code&gt;write&lt;/code&gt; permissions are explicitly set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; for that table and account combination; if they are not, the &lt;code&gt;write&lt;/code&gt; permissions for the database will be used if those are explicitly set; and if neither table nor database permissions are set for that account, the global &lt;code&gt;write&lt;/code&gt; permissions for that account will be used.</source>
          <target state="translated">로컬 범위에 정의되지 않은 권한은 다음으로 큰 범위에서 상속됩니다. 예를 들어, 테이블에 대한 쓰기 작업은 먼저 해당 테이블과 계정 조합에 대해 &lt;code&gt;write&lt;/code&gt; 권한이 명시 적으로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있는지 확인합니다 . 그렇지 않은 경우 데이터베이스에 대한 &lt;code&gt;write&lt;/code&gt; 권한이 명시 적으로 설정된 경우 사용됩니다. 해당 계정에 대해 테이블 ​​및 데이터베이스 권한이 설정되지 않은 경우 해당 계정에 대한 전역 &lt;code&gt;write&lt;/code&gt; 권한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b2206d37e61c7b1012ffbefa3c983e86a032077" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">지정된 필드가없는 시퀀스의 객체를 필터링하여 일련의 객체에서 하나 이상의 속성을 가져옵니다. 기능적으로, 이는 동일 &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields는&lt;/a&gt; 다음 &lt;a href=&quot;../pluck/index&quot;&gt;뽑는다&lt;/a&gt; 시퀀스에.</target>
        </trans-unit>
        <trans-unit id="a7461725c3e122f101426f35a2e66d9ba3287681" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">지정된 필드가없는 시퀀스의 객체를 필터링하여 일련의 객체에서 하나 이상의 속성을 가져옵니다. 기능적으로, 이는 동일 &lt;a href=&quot;has_fields/index&quot;&gt;hasFields는&lt;/a&gt; 다음 &lt;a href=&quot;pluck/index&quot;&gt;뽑는다&lt;/a&gt; 시퀀스에.</target>
        </trans-unit>
        <trans-unit id="4550e37a008aa8641c291ddb18c860428af08805" translate="yes" xml:space="preserve">
          <source>Plucks out one or more attributes from either an object or a sequence of objects (projection).</source>
          <target state="translated">객체 또는 일련의 객체 (투영)에서 하나 이상의 속성을 뽑습니다.</target>
        </trans-unit>
        <trans-unit id="59a24e502e21080856136622628d2c36a365ff13" translate="yes" xml:space="preserve">
          <source>Point (single document) changefeeds</source>
          <target state="translated">포인트 (단일 문서) 변경 피드</target>
        </trans-unit>
        <trans-unit id="d82fa8e3ba9ed2db42802966c34a79c79ec35e10" translate="yes" xml:space="preserve">
          <source>Point your browser to &lt;code&gt;localhost:8080&lt;/code&gt;. You&amp;rsquo;ll see an administrative UI where you can control the cluster (which so far consists of one server), and play with the query language.</source>
          <target state="translated">브라우저를 &lt;code&gt;localhost:8080&lt;/code&gt; 으로 지정하십시오 . 서버를 구성하는 클러스터를 제어하고 쿼리 언어로 재생할 수있는 관리 UI가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6fedcfcdb0a32752d9ea03a839178f433515d36" translate="yes" xml:space="preserve">
          <source>Point your browser to the HTTP connections port (&lt;code&gt;8080&lt;/code&gt; by default) to access the web interface.</source>
          <target state="translated">웹 인터페이스에 액세스하려면 브라우저를 HTTP 연결 포트 ( 기본적으로 &lt;code&gt;8080&lt;/code&gt; )로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a871ea0a8e57174881c9b4bf86e9bb052c9f69" translate="yes" xml:space="preserve">
          <source>Polygons can also have holes in them, created when a polygon entirely enclosed by another one is &amp;ldquo;punched out&amp;rdquo; of the larger one using the &lt;code&gt;polygonSub&lt;/code&gt; command. (This is the only way to create a polygon with a hole in it.)</source>
          <target state="translated">또한 다각형에는 다른 다각형으로 완전히 둘러싸인 다각형이 &lt;code&gt;polygonSub&lt;/code&gt; 명령을 사용하여 더 큰 다각형에서 &quot;펀칭&quot;될 때 생성되는 구멍이있을 수 있습니다 . 구멍이있는 다각형을 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="606d1d5e59fa1b7b6ee0fae6e5cdc98754db92b8" translate="yes" xml:space="preserve">
          <source>Port 22 is for SSH. The server uses public key authentication.</source>
          <target state="translated">포트 22는 SSH 용입니다. 서버는 공개 키 인증을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="167dacf7578e199e55dd6313fc9876a5b1867b79" translate="yes" xml:space="preserve">
          <source>Port 28015 is for client driver access. The only form of authentication is a key that is sent in plain text over the network.</source>
          <target state="translated">포트 28015는 클라이언트 드라이버 액세스를위한 것입니다. 인증의 유일한 형식은 네트워크를 통해 일반 텍스트로 전송되는 키입니다.</target>
        </trans-unit>
        <trans-unit id="6122f7270d7d535ad95a3aec4e825c2e02f9c751" translate="yes" xml:space="preserve">
          <source>Port 443 is for HTTPS. An Nginx server sits between RethinkDB and the world and provides basic HTTP authentication and secure HTTPS connections for the web UI.</source>
          <target state="translated">포트 443은 HTTPS 용입니다. Nginx 서버는 RethinkDB와 전세계에 위치하며 웹 UI를위한 기본 HTTP 인증 및 보안 HTTPS 연결을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f5c666906c3424aaf3e0422d4c7fc73f92951d6e" translate="yes" xml:space="preserve">
          <source>Port 80 is for HTTP. It is used during the setup process but otherwise redirects to HTTPS.</source>
          <target state="translated">포트 80은 HTTP 용입니다. 설정 과정에서 사용되지만 HTTPS로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="687986e409c97687863566c17cb109678af9b482" translate="yes" xml:space="preserve">
          <source>Port: &lt;code&gt;3000&lt;/code&gt;</source>
          <target state="translated">포트 : &lt;code&gt;3000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5333d3c84dc8377268cd686f0cc959419711b637" translate="yes" xml:space="preserve">
          <source>Predicates to &lt;code&gt;filter&lt;/code&gt; are evaluated on the server, and must use ReQL expressions. You cannot use standard JavaScript comparison operators such as &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;/&lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;/&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 할 술어 는 서버에서 평가되며 ReQL 표현식을 사용해야합니다. &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 표준 JavaScript 비교 연산자를 사용할 수 없습니다 / &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d574e84514abeecdd6ac66fa898f6addb4221b4" translate="yes" xml:space="preserve">
          <source>Prepend a value to an array.</source>
          <target state="translated">배열 앞에 값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7f22ba753489d7e920e259cf09c81b2c3d9c5597" translate="yes" xml:space="preserve">
          <source>Produce a single value from a sequence through repeated application of a reduction function.</source>
          <target state="translated">축소 함수를 반복적으로 적용하여 시퀀스에서 단일 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d9f525bfecb73d82d2f90a76e5e52925c8bfb8b8" translate="yes" xml:space="preserve">
          <source>Produces a non-existence error when called on an empty sequence. You can handle this case with &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">빈 시퀀스에서 호출 될 때 존재하지 않는 오류를 생성합니다. 이 경우는 &lt;code&gt;default&lt;/code&gt; 로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="9015371a0d33ee422afb2ea58ff543ac4c16f19b" translate="yes" xml:space="preserve">
          <source>Provide a default value in case of non-existence errors. The &lt;code&gt;default&lt;/code&gt; command evaluates its first argument (the value it&amp;rsquo;s chained to). If that argument returns &lt;code&gt;null&lt;/code&gt; or a non-existence error is thrown in evaluation, then &lt;code&gt;default&lt;/code&gt; returns its second argument. The second argument is usually a default value, but it can be a function that returns a value.</source>
          <target state="translated">존재하지 않는 오류의 경우 기본값을 제공하십시오. &lt;code&gt;default&lt;/code&gt; 명령은 첫 번째 인수 (이 묶여있어 값)을 평가한다. 해당 인수가 &lt;code&gt;null&lt;/code&gt; 하거나 존재하지 않는 오류가 평가에서 발생하면 &lt;code&gt;default&lt;/code&gt; 으로 두 번째 인수를 리턴합니다. 두 번째 인수는 일반적으로 기본값이지만 값을 반환하는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2793cd5e2cebdd699874e60337368ad4c7f0e4" translate="yes" xml:space="preserve">
          <source>Proxy nodes</source>
          <target state="translated">프록시 노드</target>
        </trans-unit>
        <trans-unit id="35cd7f9cdee7e3c5423c4f68b7a5a738e7ee908a" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe</source>
          <target state="translated">Publish-Subscribe</target>
        </trans-unit>
        <trans-unit id="d74d06bbc20ee3a59b09c01526b467c887af9167" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe with RethinkDB</source>
          <target state="translated">RethinkDB를 사용한 게시-구독</target>
        </trans-unit>
        <trans-unit id="08ab1df032a5bfbbddcde416cd9683a3da9a8034" translate="yes" xml:space="preserve">
          <source>Publish-subscribe</source>
          <target state="translated">Publish-subscribe</target>
        </trans-unit>
        <trans-unit id="9c416ee884bbd4d8e89a95d4c023e9b2eff57f5f" translate="yes" xml:space="preserve">
          <source>Pushing changes to RabbitMQ</source>
          <target state="translated">RabbitMQ로 변경 사항 푸시</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">함께 모아서</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="49cfc0fae0169e4b63343a3e789527ea52375294" translate="yes" xml:space="preserve">
          <source>Python driver</source>
          <target state="translated">파이썬 드라이버</target>
        </trans-unit>
        <trans-unit id="d82cabe971317809828edbfbe4a5e9612ec586ff" translate="yes" xml:space="preserve">
          <source>Python libraries</source>
          <target state="translated">파이썬 라이브러리</target>
        </trans-unit>
        <trans-unit id="c56ac30b14c8764fec5b5b70036659f9b693a5b5" translate="yes" xml:space="preserve">
          <source>Python with Tornado or Twisted</source>
          <target state="translated">토네이도 또는 꼬인 파이썬</target>
        </trans-unit>
        <trans-unit id="bacc89e7a944a342361ad407e50c1bdc4adbb60e" translate="yes" xml:space="preserve">
          <source>Queries for accessing authors and posts tend to be simpler.</source>
          <target state="translated">저자와 게시물에 액세스하는 쿼리는 더 간단한 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a23e1f2ab29b58922510028cdd1e93bcff6daa1" translate="yes" xml:space="preserve">
          <source>Queries in detail</source>
          <target state="translated">상세하게 쿼리</target>
        </trans-unit>
        <trans-unit id="6ed8d030024e173cbdfaacb35d2c5b9fe1de254d" translate="yes" xml:space="preserve">
          <source>Query (read and/or update) the configurations for individual tables or databases.</source>
          <target state="translated">개별 테이블 또는 데이터베이스의 구성을 쿼리 (읽기 및 / 또는 업데이트)합니다.</target>
        </trans-unit>
        <trans-unit id="2dd43bff670fb4443641b638e91c3a1e2666b727" translate="yes" xml:space="preserve">
          <source>Query Runtime (seconds)</source>
          <target state="translated">쿼리 런타임 (초)</target>
        </trans-unit>
        <trans-unit id="90479d900b8bfaebff69bef7c1e6f5e4acf525cc" translate="yes" xml:space="preserve">
          <source>Query execution</source>
          <target state="translated">쿼리 실행</target>
        </trans-unit>
        <trans-unit id="89912ace151473384dc0a610242cf6f97eff4e6b" translate="yes" xml:space="preserve">
          <source>Query optimization</source>
          <target state="translated">쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="c40c0a7ff9b0eb9e3f2b0a13a19b9c280e41d151" translate="yes" xml:space="preserve">
          <source>Query types: 50% single-document read ops, 50% single-document update ops</source>
          <target state="translated">쿼리 유형 : 단일 문서 읽기 작업 50 %, 단일 문서 업데이트 작업 50 %</target>
        </trans-unit>
        <trans-unit id="aaa9e9974cdedcdc0d68a460b12895753d966e0f" translate="yes" xml:space="preserve">
          <source>Query types: Count the total number of sentences over a single field: table.map(r.row(&amp;ldquo;field0&amp;rdquo;).split(&amp;ldquo;.&amp;rdquo;).count()).sum()</source>
          <target state="translated">쿼리 유형 : 단일 필드의 총 문장 수를 계산합니다. table.map (r.row (&amp;ldquo;field0&amp;rdquo;). split (&amp;ldquo;.&amp;rdquo;). count ()). sum ()</target>
        </trans-unit>
        <trans-unit id="30a91f4f78c1ba3a4e0863c44ed3e1c0761b3e1b" translate="yes" xml:space="preserve">
          <source>Query types: Single-document gets</source>
          <target state="translated">쿼리 유형 : 단일 문서 가져 오기</target>
        </trans-unit>
        <trans-unit id="cc6835ce045ca407e1aa42cf034a40b2dc968c7d" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="translated">Querying</target>
        </trans-unit>
        <trans-unit id="2311ef772fd9667ad480d784efeb91fd87562cee" translate="yes" xml:space="preserve">
          <source>Querying the jobs table</source>
          <target state="translated">작업 테이블 쿼리</target>
        </trans-unit>
        <trans-unit id="cfd1d967b9233f2a022120ac5fc5e2af2bff64b0" translate="yes" xml:space="preserve">
          <source>Querying the stats table</source>
          <target state="translated">통계 테이블 쿼리</target>
        </trans-unit>
        <trans-unit id="b4e9d799b4c484b951d3a7526f99384d51e97175" translate="yes" xml:space="preserve">
          <source>Querying this table with no filters produces a list of all current issues within the cluster.</source>
          <target state="translated">필터없이이 테이블을 쿼리하면 클러스터 내의 모든 현재 문제 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24cc2440fd1b49aaf1c5a8958c6de61e1529c18a" translate="yes" xml:space="preserve">
          <source>Quick setup</source>
          <target state="translated">빠른 설치</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="bfc29699c72375bf47c9436811bc275479e815df" translate="yes" xml:space="preserve">
          <source>RECV</source>
          <target state="translated">RECV</target>
        </trans-unit>
        <trans-unit id="9e7d6316420463a965783442095454fff2759c0a" translate="yes" xml:space="preserve">
          <source>RabbitMQ is a natural choice for distributing notifications of change events. It&amp;rsquo;s designed to efficiently route messages to many listeners, and there are client libraries for most popular languages. In this tutorial we take advantage of RabbitMQ&amp;rsquo;s &lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;topic exchanges&lt;/a&gt;. Topic exchanges allow clients to subscribe to the messages they&amp;rsquo;re interested in, and ignore the rest.</source>
          <target state="translated">RabbitMQ는 변경 이벤트 알림을 배포하기위한 자연스러운 선택입니다. 메시지를 여러 리스너로 효율적으로 라우팅하도록 설계되었으며 가장 널리 사용되는 언어를위한 클라이언트 라이브러리가 있습니다. 이 학습서에서는 RabbitMQ의 &lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;주제 교환을 활용&lt;/a&gt; 합니다. 토픽 교환을 통해 클라이언트는 관심있는 메시지를 구독하고 나머지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5dd8e5ee1c3e6446669db2bc1a5feb0e30e90272" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal Compute</source>
          <target state="translated">Rackspace OnMetal 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="26231667af7cc1c479da94498b920bd20cc4204e" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal I/O</source>
          <target state="translated">Rackspace OnMetal I / O</target>
        </trans-unit>
        <trans-unit id="56f04e78d5af9bc3df5498e192f568246521ebe8" translate="yes" xml:space="preserve">
          <source>Raspbian</source>
          <target state="translated">Raspbian</target>
        </trans-unit>
        <trans-unit id="cc2546f8cc7b851025e82d9ad64be8681c1defc8" translate="yes" xml:space="preserve">
          <source>ReQL</source>
          <target state="translated">ReQL</target>
        </trans-unit>
        <trans-unit id="4ac00efdbe1ef213d5db65a44a2317ffb880734f" translate="yes" xml:space="preserve">
          <source>ReQL administration commands</source>
          <target state="translated">ReQL 관리 명령</target>
        </trans-unit>
        <trans-unit id="ed867a0a1051c1e47be81b1dc6bcf49d2a9a6a50" translate="yes" xml:space="preserve">
          <source>ReQL command: () (bracket)</source>
          <target state="translated">ReQL 명령 : () (브래킷)</target>
        </trans-unit>
        <trans-unit id="9c77279ce7eb456fb9242d6b0d4944fc101cd9ac" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (connection)</source>
          <target state="translated">ReQL 명령 : EventEmitter (연결)</target>
        </trans-unit>
        <trans-unit id="33ff2c1a1ec8fbe986458a9f2936ae04f4bdfb80" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (cursor)</source>
          <target state="translated">ReQL 명령 : EventEmitter (커서)</target>
        </trans-unit>
        <trans-unit id="ecfe4f46eb5536b7c3b6865e0253407db4987f76" translate="yes" xml:space="preserve">
          <source>ReQL command: ISO8601</source>
          <target state="translated">ReQL 명령 : ISO8601</target>
        </trans-unit>
        <trans-unit id="d77f4ff715692913a39d0f155d76e544abc4994a" translate="yes" xml:space="preserve">
          <source>ReQL command: add</source>
          <target state="translated">ReQL 명령 : 추가</target>
        </trans-unit>
        <trans-unit id="bd75b6bf5a43cdc3fbcc301becfc8a5b38968d20" translate="yes" xml:space="preserve">
          <source>ReQL command: and</source>
          <target state="translated">ReQL 명령 : 및</target>
        </trans-unit>
        <trans-unit id="f2605569a04a0afde3a9470a0eff3c6a2b21a661" translate="yes" xml:space="preserve">
          <source>ReQL command: append</source>
          <target state="translated">ReQL 명령 : 추가</target>
        </trans-unit>
        <trans-unit id="c2634cf1d36dacdd152e506ed1c1009b68f6146a" translate="yes" xml:space="preserve">
          <source>ReQL command: args</source>
          <target state="translated">ReQL 명령 : 인수</target>
        </trans-unit>
        <trans-unit id="06786aca8c46cb6acbf99bb208c4f2ecc10b5911" translate="yes" xml:space="preserve">
          <source>ReQL command: avg</source>
          <target state="translated">ReQL 명령 : 평균</target>
        </trans-unit>
        <trans-unit id="11520f025e9654a1117903ab39195c25867c3da1" translate="yes" xml:space="preserve">
          <source>ReQL command: between</source>
          <target state="translated">ReQL 명령 : 사이</target>
        </trans-unit>
        <trans-unit id="3655b193f6608706a983a08861b50d6b5e185a06" translate="yes" xml:space="preserve">
          <source>ReQL command: binary</source>
          <target state="translated">ReQL 명령 : 이진</target>
        </trans-unit>
        <trans-unit id="cc7b8e77c49a6f5233051f7e6eb87cbaa04267df" translate="yes" xml:space="preserve">
          <source>ReQL command: branch</source>
          <target state="translated">ReQL 명령 : 지점</target>
        </trans-unit>
        <trans-unit id="a542671e41bd856caf41efc6940bae16c1a4696d" translate="yes" xml:space="preserve">
          <source>ReQL command: ceil</source>
          <target state="translated">ReQL 명령 : ceil</target>
        </trans-unit>
        <trans-unit id="527929389823a7da454b535fc44ab98c9b397b0d" translate="yes" xml:space="preserve">
          <source>ReQL command: changeAt</source>
          <target state="translated">ReQL 명령 : changeAt</target>
        </trans-unit>
        <trans-unit id="25d7b0a2ca00d4a73406eff48faa4fefee9b927e" translate="yes" xml:space="preserve">
          <source>ReQL command: changes</source>
          <target state="translated">ReQL 명령 : 변경</target>
        </trans-unit>
        <trans-unit id="b439af789b774f651c0736c700338a2616f990b1" translate="yes" xml:space="preserve">
          <source>ReQL command: circle</source>
          <target state="translated">ReQL 명령 : 서클</target>
        </trans-unit>
        <trans-unit id="6b2fd8a84da14971568a45b72ab9313d35cade87" translate="yes" xml:space="preserve">
          <source>ReQL command: close</source>
          <target state="translated">ReQL 명령 : 닫기</target>
        </trans-unit>
        <trans-unit id="417eab2fa9f97567083539e8c74527f21ccacd8c" translate="yes" xml:space="preserve">
          <source>ReQL command: coerceTo</source>
          <target state="translated">ReQL 명령 : coerceTo</target>
        </trans-unit>
        <trans-unit id="4184adbeb4e69b759b643238c0d1b15d72ffc48e" translate="yes" xml:space="preserve">
          <source>ReQL command: concatMap</source>
          <target state="translated">ReQL 명령 : concatMap</target>
        </trans-unit>
        <trans-unit id="2cba949c803d2634ab6f639cf3a79f395d198c8e" translate="yes" xml:space="preserve">
          <source>ReQL command: config</source>
          <target state="translated">ReQL 명령 : config</target>
        </trans-unit>
        <trans-unit id="44e902bd9764f683711d0c83dd116fd1ae54a328" translate="yes" xml:space="preserve">
          <source>ReQL command: connect</source>
          <target state="translated">ReQL 명령 : connect</target>
        </trans-unit>
        <trans-unit id="79ec01842c910c009d437f0b1ec418b2cd2e55ff" translate="yes" xml:space="preserve">
          <source>ReQL command: contains</source>
          <target state="translated">ReQL 명령 : 포함</target>
        </trans-unit>
        <trans-unit id="63144a966ab3eea31f6d0e990c630286409bb445" translate="yes" xml:space="preserve">
          <source>ReQL command: count</source>
          <target state="translated">ReQL 명령 : 개수</target>
        </trans-unit>
        <trans-unit id="ed85af4ffe2d7e416e7f09211f7fde5e62c12bd2" translate="yes" xml:space="preserve">
          <source>ReQL command: date</source>
          <target state="translated">ReQL 명령 : 날짜</target>
        </trans-unit>
        <trans-unit id="fe45f01059e3f5e250f4fe61f283fa0b3e071514" translate="yes" xml:space="preserve">
          <source>ReQL command: day</source>
          <target state="translated">ReQL 명령 : 일</target>
        </trans-unit>
        <trans-unit id="1bf352324c27548c918fa1efea8de5b8bd8c7ab1" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfWeek</source>
          <target state="translated">ReQL 명령 : dayOfWeek</target>
        </trans-unit>
        <trans-unit id="059e7de04bc86952404125b943c999aa79d78ed3" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfYear</source>
          <target state="translated">ReQL 명령 : dayOfYear</target>
        </trans-unit>
        <trans-unit id="8b5d959614c2e1eff9a4980760f966439d124e61" translate="yes" xml:space="preserve">
          <source>ReQL command: db</source>
          <target state="translated">ReQL 명령 : db</target>
        </trans-unit>
        <trans-unit id="d76075daac756324d6d0ec0a0928aa961d586a1d" translate="yes" xml:space="preserve">
          <source>ReQL command: dbCreate</source>
          <target state="translated">ReQL 명령 : dbCreate</target>
        </trans-unit>
        <trans-unit id="8e87a1bc1f3bf2ec8d32b7c2cc40f36556358729" translate="yes" xml:space="preserve">
          <source>ReQL command: dbDrop</source>
          <target state="translated">ReQL 명령 : dbDrop</target>
        </trans-unit>
        <trans-unit id="f2a8b36dca132fdcc0c2871c7a5fbe6092c9db74" translate="yes" xml:space="preserve">
          <source>ReQL command: dbList</source>
          <target state="translated">ReQL 명령 : dbList</target>
        </trans-unit>
        <trans-unit id="5f2d6e5cf850ea9208748619684b22798f566d95" translate="yes" xml:space="preserve">
          <source>ReQL command: default</source>
          <target state="translated">ReQL 명령 : 기본값</target>
        </trans-unit>
        <trans-unit id="152ab9d0af0267e9629d3302fda86cb29bd1679c" translate="yes" xml:space="preserve">
          <source>ReQL command: delete</source>
          <target state="translated">ReQL 명령 : 삭제</target>
        </trans-unit>
        <trans-unit id="5793c7294123817b3c67b2446d9ed0fc24099e64" translate="yes" xml:space="preserve">
          <source>ReQL command: deleteAt</source>
          <target state="translated">ReQL 명령 : deleteAt</target>
        </trans-unit>
        <trans-unit id="ea37eedb2d752c766abd0663d17fa8283bafc07a" translate="yes" xml:space="preserve">
          <source>ReQL command: difference</source>
          <target state="translated">ReQL 명령 : 차이점</target>
        </trans-unit>
        <trans-unit id="4a5e04f27c1cb25c8d2eae66f69a116238196fdf" translate="yes" xml:space="preserve">
          <source>ReQL command: distance</source>
          <target state="translated">ReQL 명령 : 거리</target>
        </trans-unit>
        <trans-unit id="f3ba8164cc670369a39c3cd89a607b234d43f1c0" translate="yes" xml:space="preserve">
          <source>ReQL command: distinct</source>
          <target state="translated">ReQL 명령 : 구별</target>
        </trans-unit>
        <trans-unit id="5476b8fa7162e4450c92f418aa9aa3e48fd06aef" translate="yes" xml:space="preserve">
          <source>ReQL command: div</source>
          <target state="translated">ReQL 명령 : div</target>
        </trans-unit>
        <trans-unit id="561b5fa4e590d6f2ad1196573954cfb43c646dd8" translate="yes" xml:space="preserve">
          <source>ReQL command: do</source>
          <target state="translated">ReQL 명령 : do</target>
        </trans-unit>
        <trans-unit id="9aec0c0d4c81051146d47accc16dda35f7a5a0b3" translate="yes" xml:space="preserve">
          <source>ReQL command: downcase</source>
          <target state="translated">ReQL 명령 : 소문자</target>
        </trans-unit>
        <trans-unit id="f28b2c93a01839f916ec02c4cfcc9a13721eb722" translate="yes" xml:space="preserve">
          <source>ReQL command: during</source>
          <target state="translated">ReQL 명령 : 중</target>
        </trans-unit>
        <trans-unit id="3d326b5fb9ed975ecff66601d036627598003399" translate="yes" xml:space="preserve">
          <source>ReQL command: each</source>
          <target state="translated">ReQL 명령 : 각각</target>
        </trans-unit>
        <trans-unit id="aabe73e97a51d3c59d01989d6242a260e6d74509" translate="yes" xml:space="preserve">
          <source>ReQL command: eachAsync</source>
          <target state="translated">ReQL 명령 : eachAsync</target>
        </trans-unit>
        <trans-unit id="425ea449a1d70e01c64dbe6b5b29d2b23e87a858" translate="yes" xml:space="preserve">
          <source>ReQL command: epochTime</source>
          <target state="translated">ReQL 명령 : epochTime</target>
        </trans-unit>
        <trans-unit id="98c30486e513c1a061f79323971a52b0a723618f" translate="yes" xml:space="preserve">
          <source>ReQL command: eq</source>
          <target state="translated">ReQL 명령 : eq</target>
        </trans-unit>
        <trans-unit id="3e7a5fb0e8e29eec05542a30ba6b8c444ee3105a" translate="yes" xml:space="preserve">
          <source>ReQL command: eqJoin</source>
          <target state="translated">ReQL 명령 : eqJoin</target>
        </trans-unit>
        <trans-unit id="6b42cae3456f66df523de497a56b8436bdc4f933" translate="yes" xml:space="preserve">
          <source>ReQL command: error</source>
          <target state="translated">ReQL 명령 : 오류</target>
        </trans-unit>
        <trans-unit id="804a86083314037dd13602582c6f8bbc82d8f39b" translate="yes" xml:space="preserve">
          <source>ReQL command: expr</source>
          <target state="translated">ReQL 명령 : expr</target>
        </trans-unit>
        <trans-unit id="611e77c0661fdb3292aea37d8df3679b35c7df12" translate="yes" xml:space="preserve">
          <source>ReQL command: fill</source>
          <target state="translated">ReQL 명령 : 채우기</target>
        </trans-unit>
        <trans-unit id="9dccb4ccbba48c519594c5157e513ba0d5701de8" translate="yes" xml:space="preserve">
          <source>ReQL command: filter</source>
          <target state="translated">ReQL 명령 : 필터</target>
        </trans-unit>
        <trans-unit id="9cffb149505c56762d298753a09eb0d2d8a6560b" translate="yes" xml:space="preserve">
          <source>ReQL command: floor</source>
          <target state="translated">ReQL 명령 : 바닥</target>
        </trans-unit>
        <trans-unit id="94cbd2adf0a235aac8c2088b4ca0140be21b53f8" translate="yes" xml:space="preserve">
          <source>ReQL command: fold</source>
          <target state="translated">ReQL 명령 : 접기</target>
        </trans-unit>
        <trans-unit id="897d9459594bc60b50cde84578f8afb019abc97e" translate="yes" xml:space="preserve">
          <source>ReQL command: forEach</source>
          <target state="translated">ReQL 명령 : forEach</target>
        </trans-unit>
        <trans-unit id="bab464954d3bc8833ad8340a54c35662a312b11d" translate="yes" xml:space="preserve">
          <source>ReQL command: ge</source>
          <target state="translated">ReQL 명령 : ge</target>
        </trans-unit>
        <trans-unit id="d741c68ddfa631d21e6871f1b46d42614e18a83a" translate="yes" xml:space="preserve">
          <source>ReQL command: geojson</source>
          <target state="translated">ReQL 명령 : geojson</target>
        </trans-unit>
        <trans-unit id="82ed05550360dd83aa891c363cbc524b4a2f8f7a" translate="yes" xml:space="preserve">
          <source>ReQL command: get</source>
          <target state="translated">ReQL 명령 : get</target>
        </trans-unit>
        <trans-unit id="a1f385f0efe0b25f9afac8babc9ac59aefa669e0" translate="yes" xml:space="preserve">
          <source>ReQL command: getAll</source>
          <target state="translated">ReQL 명령 : getAll</target>
        </trans-unit>
        <trans-unit id="d0a8e46aaab6c31944afe326cfc398bb973a4686" translate="yes" xml:space="preserve">
          <source>ReQL command: getField</source>
          <target state="translated">ReQL 명령 : getField</target>
        </trans-unit>
        <trans-unit id="db529b687aac749a71e749e57613644679a50870" translate="yes" xml:space="preserve">
          <source>ReQL command: getIntersecting</source>
          <target state="translated">ReQL 명령 : getIntersecting</target>
        </trans-unit>
        <trans-unit id="2496d8ab318dd96eb24cd47e28fe55900147c8db" translate="yes" xml:space="preserve">
          <source>ReQL command: getNearest</source>
          <target state="translated">ReQL 명령 : getNearest</target>
        </trans-unit>
        <trans-unit id="aabf73eab95fa6104bd97b42749ee58b48fd0292" translate="yes" xml:space="preserve">
          <source>ReQL command: grant</source>
          <target state="translated">ReQL 명령 : 부여</target>
        </trans-unit>
        <trans-unit id="7b03dc68f7aad27c5aaa10cd5ee0aad622ce5f31" translate="yes" xml:space="preserve">
          <source>ReQL command: group</source>
          <target state="translated">ReQL 명령 : 그룹</target>
        </trans-unit>
        <trans-unit id="e86480de71bd273e6658917ba3f61bc7e6824443" translate="yes" xml:space="preserve">
          <source>ReQL command: gt</source>
          <target state="translated">ReQL 명령 : gt</target>
        </trans-unit>
        <trans-unit id="c24bee4561071d0d871cdd0200719bc29b97ebc8" translate="yes" xml:space="preserve">
          <source>ReQL command: hasFields</source>
          <target state="translated">ReQL 명령 : hasFields</target>
        </trans-unit>
        <trans-unit id="7bd359800f881c05722a02a6b5695da760181882" translate="yes" xml:space="preserve">
          <source>ReQL command: hours</source>
          <target state="translated">ReQL 명령 : 시간</target>
        </trans-unit>
        <trans-unit id="bcc9bf4de764097e98526fcd54cc961135eb7962" translate="yes" xml:space="preserve">
          <source>ReQL command: http</source>
          <target state="translated">ReQL 명령 : http</target>
        </trans-unit>
        <trans-unit id="7431d9aa2cada8de64c18a070081d24a5b9fbb09" translate="yes" xml:space="preserve">
          <source>ReQL command: inTimezone</source>
          <target state="translated">ReQL 명령 : inTimezone</target>
        </trans-unit>
        <trans-unit id="cd1c77e55dc7e874dfb9a9c9be6aaccb645f6b7d" translate="yes" xml:space="preserve">
          <source>ReQL command: includes</source>
          <target state="translated">ReQL 명령 : 포함</target>
        </trans-unit>
        <trans-unit id="d6711e810c115ceff2ece5c128308dbb42b5a2cf" translate="yes" xml:space="preserve">
          <source>ReQL command: indexCreate</source>
          <target state="translated">ReQL 명령 : indexCreate</target>
        </trans-unit>
        <trans-unit id="bfd351f65f12fb8a7fe92627deee9214f561ab3e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexDrop</source>
          <target state="translated">ReQL 명령 : indexDrop</target>
        </trans-unit>
        <trans-unit id="3652ad2442800cc05c6e2985c0264e2e0382ca27" translate="yes" xml:space="preserve">
          <source>ReQL command: indexList</source>
          <target state="translated">ReQL 명령 : indexList</target>
        </trans-unit>
        <trans-unit id="f1e54de063dd1435fd13b88690dd9922aa7eeb29" translate="yes" xml:space="preserve">
          <source>ReQL command: indexRename</source>
          <target state="translated">ReQL 명령 : indexRename</target>
        </trans-unit>
        <trans-unit id="8b48bce424975b58f5a6277f94555aa3e884e76e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexStatus</source>
          <target state="translated">ReQL 명령 : indexStatus</target>
        </trans-unit>
        <trans-unit id="f625bf613db8f884e43c623097656ac6805cb4d5" translate="yes" xml:space="preserve">
          <source>ReQL command: indexWait</source>
          <target state="translated">ReQL 명령 : indexWait</target>
        </trans-unit>
        <trans-unit id="daf81e983eb792f0c3e3c85e87f063644fd228a7" translate="yes" xml:space="preserve">
          <source>ReQL command: info</source>
          <target state="translated">ReQL 명령 : 정보</target>
        </trans-unit>
        <trans-unit id="f2865b2fe07ec14465b473e3e2191c86471ebc88" translate="yes" xml:space="preserve">
          <source>ReQL command: innerJoin</source>
          <target state="translated">ReQL 명령 : innerJoin</target>
        </trans-unit>
        <trans-unit id="42c5914444ddf911b418ac8a07bbdfe87434a490" translate="yes" xml:space="preserve">
          <source>ReQL command: insert</source>
          <target state="translated">ReQL 명령 : 삽입</target>
        </trans-unit>
        <trans-unit id="5e67c8f25f616daa8641527206d66dbca593343b" translate="yes" xml:space="preserve">
          <source>ReQL command: insertAt</source>
          <target state="translated">ReQL 명령 : insertAt</target>
        </trans-unit>
        <trans-unit id="e7827d7ac574cac26fe38a431bf6d13d20d79386" translate="yes" xml:space="preserve">
          <source>ReQL command: intersects</source>
          <target state="translated">ReQL 명령 : 교차</target>
        </trans-unit>
        <trans-unit id="2fc4b91b71a6f3ca54688e50d5dfb5007f51a3a6" translate="yes" xml:space="preserve">
          <source>ReQL command: isEmpty</source>
          <target state="translated">ReQL 명령 : isEmpty</target>
        </trans-unit>
        <trans-unit id="cc63c3831bbe8fcf8cc6bb4a0bf3937a70c83637" translate="yes" xml:space="preserve">
          <source>ReQL command: js</source>
          <target state="translated">ReQL 명령 : js</target>
        </trans-unit>
        <trans-unit id="704734e522301a470558a5131f2c6e3b6ef85eb1" translate="yes" xml:space="preserve">
          <source>ReQL command: json</source>
          <target state="translated">ReQL 명령 : json</target>
        </trans-unit>
        <trans-unit id="ee963dc4f4a09e977f54e79c552d271a5efe1ab5" translate="yes" xml:space="preserve">
          <source>ReQL command: keys</source>
          <target state="translated">ReQL 명령 : 키</target>
        </trans-unit>
        <trans-unit id="464e94774d901f92cc30536abe6dc20f1abb20d5" translate="yes" xml:space="preserve">
          <source>ReQL command: le</source>
          <target state="translated">ReQL 명령 : le</target>
        </trans-unit>
        <trans-unit id="04153a56a203e790ab924f8607428b4b8d9eb847" translate="yes" xml:space="preserve">
          <source>ReQL command: limit</source>
          <target state="translated">ReQL 명령 : 한계</target>
        </trans-unit>
        <trans-unit id="9f2597983292d8bf2c21e31bbb1694b0f4e60b71" translate="yes" xml:space="preserve">
          <source>ReQL command: line</source>
          <target state="translated">ReQL 명령 : 라인</target>
        </trans-unit>
        <trans-unit id="04e551b6caa8c5819ee49593aa863ab30753852a" translate="yes" xml:space="preserve">
          <source>ReQL command: literal</source>
          <target state="translated">ReQL 명령 : 리터럴</target>
        </trans-unit>
        <trans-unit id="dd52f5f092b7e6f28627bef15e94ecf8131e3ef6" translate="yes" xml:space="preserve">
          <source>ReQL command: lt</source>
          <target state="translated">ReQL 명령 : lt</target>
        </trans-unit>
        <trans-unit id="8cd6432c7520ab24d1a185bc4ab261febc0ac9f9" translate="yes" xml:space="preserve">
          <source>ReQL command: map</source>
          <target state="translated">ReQL 명령 : 맵</target>
        </trans-unit>
        <trans-unit id="f29d7e822149fb3bdb52bb327684c64fed039865" translate="yes" xml:space="preserve">
          <source>ReQL command: match</source>
          <target state="translated">ReQL 명령 : 일치</target>
        </trans-unit>
        <trans-unit id="c75671801e688e758173dd6841f05e272b833433" translate="yes" xml:space="preserve">
          <source>ReQL command: max</source>
          <target state="translated">ReQL 명령 : 최대</target>
        </trans-unit>
        <trans-unit id="99b4fb1fe845d533e11f41a152cc7193a70f0a3c" translate="yes" xml:space="preserve">
          <source>ReQL command: merge</source>
          <target state="translated">ReQL 명령 : 병합</target>
        </trans-unit>
        <trans-unit id="f32d131081cad08c01e30eada59cfa338cb1b409" translate="yes" xml:space="preserve">
          <source>ReQL command: min</source>
          <target state="translated">ReQL 명령 : min</target>
        </trans-unit>
        <trans-unit id="8c3b86a9d0f6ac29f03bfbb3265cd75620f9d3e0" translate="yes" xml:space="preserve">
          <source>ReQL command: minutes</source>
          <target state="translated">ReQL 명령 : 분</target>
        </trans-unit>
        <trans-unit id="5cb8dacfbfe621b76bb3f63fdb19e0e6e6dd08d6" translate="yes" xml:space="preserve">
          <source>ReQL command: mod</source>
          <target state="translated">ReQL 명령 : mod</target>
        </trans-unit>
        <trans-unit id="759964af86c65918dbeb70bab369aed0f281b7ac" translate="yes" xml:space="preserve">
          <source>ReQL command: month</source>
          <target state="translated">ReQL 명령 : 월</target>
        </trans-unit>
        <trans-unit id="f88a626fbd64a50878cbe7d76d55f2a5c63f80ce" translate="yes" xml:space="preserve">
          <source>ReQL command: mul</source>
          <target state="translated">ReQL 명령 : mul</target>
        </trans-unit>
        <trans-unit id="de874b4d0dc4ed2dbc0d6880b5cb21a27c76bc32" translate="yes" xml:space="preserve">
          <source>ReQL command: ne</source>
          <target state="translated">ReQL 명령 : ne</target>
        </trans-unit>
        <trans-unit id="6c6619dceafd328a67bddca06d99d66fe8e0c745" translate="yes" xml:space="preserve">
          <source>ReQL command: next</source>
          <target state="translated">ReQL 명령 : 다음</target>
        </trans-unit>
        <trans-unit id="2fe619f0be2dfaac8395f90e027e18f66dfb5cde" translate="yes" xml:space="preserve">
          <source>ReQL command: noreplyWait</source>
          <target state="translated">ReQL 명령 : noreplyWait</target>
        </trans-unit>
        <trans-unit id="b786c5ec3389b7fffd91940e9df8dcfc1bed6413" translate="yes" xml:space="preserve">
          <source>ReQL command: not</source>
          <target state="translated">ReQL 명령 : 아닙니다</target>
        </trans-unit>
        <trans-unit id="51bf93483726e0ed581b769efc939be0c439b3f0" translate="yes" xml:space="preserve">
          <source>ReQL command: now</source>
          <target state="translated">ReQL 명령 : 지금</target>
        </trans-unit>
        <trans-unit id="142c81f0e7aad4d403a5e9717af093c3fa309da0" translate="yes" xml:space="preserve">
          <source>ReQL command: nth</source>
          <target state="translated">ReQL 명령 : nth</target>
        </trans-unit>
        <trans-unit id="7a52ef447aef8fb68ab5bf4ab1b1be3cb0a8e6fa" translate="yes" xml:space="preserve">
          <source>ReQL command: object</source>
          <target state="translated">ReQL 명령 : 객체</target>
        </trans-unit>
        <trans-unit id="0285d42b6439c5758658f23558fb2a316aa232a9" translate="yes" xml:space="preserve">
          <source>ReQL command: offsetsOf</source>
          <target state="translated">ReQL 명령 : offsetsOf</target>
        </trans-unit>
        <trans-unit id="37141a239a711e7b56007bb0ff0bef4bc3a55f32" translate="yes" xml:space="preserve">
          <source>ReQL command: or</source>
          <target state="translated">ReQL 명령 : 또는</target>
        </trans-unit>
        <trans-unit id="469eeab7689f5192386b409764992410551e27f1" translate="yes" xml:space="preserve">
          <source>ReQL command: orderBy</source>
          <target state="translated">ReQL 명령 : orderBy</target>
        </trans-unit>
        <trans-unit id="c49f00d76ad001bdc3166004292a3c0a27e75d43" translate="yes" xml:space="preserve">
          <source>ReQL command: outerJoin</source>
          <target state="translated">ReQL 명령 : outerJoin</target>
        </trans-unit>
        <trans-unit id="cd3e4940e21cee61fccac24d189f22bbfab1ba9f" translate="yes" xml:space="preserve">
          <source>ReQL command: pluck</source>
          <target state="translated">ReQL 명령 : pluck</target>
        </trans-unit>
        <trans-unit id="0914f786606ccc5c9796e887a77cd485af776083" translate="yes" xml:space="preserve">
          <source>ReQL command: point</source>
          <target state="translated">ReQL 명령 : 포인트</target>
        </trans-unit>
        <trans-unit id="dce548026c69300e92a29bc23af287b80ded5dd0" translate="yes" xml:space="preserve">
          <source>ReQL command: polygon</source>
          <target state="translated">ReQL 명령 : 다각형</target>
        </trans-unit>
        <trans-unit id="ec7f5406bd2ba258cc0960fe19f501b84159cbf3" translate="yes" xml:space="preserve">
          <source>ReQL command: polygonSub</source>
          <target state="translated">ReQL 명령 : polygonSub</target>
        </trans-unit>
        <trans-unit id="25d262b79633d6a23b112ff0642a2bbd27b058de" translate="yes" xml:space="preserve">
          <source>ReQL command: prepend</source>
          <target state="translated">ReQL 명령 : prepend</target>
        </trans-unit>
        <trans-unit id="32df6b377a42b81280feba4abd45d6fb776b7c5b" translate="yes" xml:space="preserve">
          <source>ReQL command: r</source>
          <target state="translated">ReQL 명령 : r</target>
        </trans-unit>
        <trans-unit id="163b8f2d543ca883e5f457526db714e8507bc273" translate="yes" xml:space="preserve">
          <source>ReQL command: random</source>
          <target state="translated">ReQL 명령 : 랜덤</target>
        </trans-unit>
        <trans-unit id="abd0f1d41d793cf5d1fd1be44dad48ed9f52dcb0" translate="yes" xml:space="preserve">
          <source>ReQL command: range</source>
          <target state="translated">ReQL 명령 : 범위</target>
        </trans-unit>
        <trans-unit id="abcfac2a068eb352bf7b1585227c21dd99a9dad2" translate="yes" xml:space="preserve">
          <source>ReQL command: rebalance</source>
          <target state="translated">ReQL 명령 : 재조정</target>
        </trans-unit>
        <trans-unit id="ed78391e00455b6f7508ebf957eb0c3519b8cda6" translate="yes" xml:space="preserve">
          <source>ReQL command: reconfigure</source>
          <target state="translated">ReQL 명령 : 재구성</target>
        </trans-unit>
        <trans-unit id="bb603637d01d111818e3e54d87f6fbe2f0948e04" translate="yes" xml:space="preserve">
          <source>ReQL command: reconnect</source>
          <target state="translated">ReQL 명령 : 다시 연결</target>
        </trans-unit>
        <trans-unit id="ca15dd0e4b3cb78958bbc04ff2ebdfc6237c1480" translate="yes" xml:space="preserve">
          <source>ReQL command: reduce</source>
          <target state="translated">ReQL 명령 : 감소</target>
        </trans-unit>
        <trans-unit id="1b669d035898f8b7832c9d6b122df85452bb3621" translate="yes" xml:space="preserve">
          <source>ReQL command: replace</source>
          <target state="translated">ReQL 명령 : 바꾸기</target>
        </trans-unit>
        <trans-unit id="462aad92203d25425961d17c822cf9c057229d02" translate="yes" xml:space="preserve">
          <source>ReQL command: round</source>
          <target state="translated">ReQL 명령 : 라운드</target>
        </trans-unit>
        <trans-unit id="021b12c6ad75724f11b7b4db3ef364873869fc62" translate="yes" xml:space="preserve">
          <source>ReQL command: row</source>
          <target state="translated">ReQL 명령 : 행</target>
        </trans-unit>
        <trans-unit id="30f7a7cfdc10d2f8f0979e09db335392564ee022" translate="yes" xml:space="preserve">
          <source>ReQL command: run</source>
          <target state="translated">ReQL 명령 : 실행</target>
        </trans-unit>
        <trans-unit id="35baf0bd20ef826e0e6f2d92d0b5ececfd90953e" translate="yes" xml:space="preserve">
          <source>ReQL command: sample</source>
          <target state="translated">ReQL 명령 : 샘플</target>
        </trans-unit>
        <trans-unit id="0be3d60445795016ac04b5c046a0a131b0ae6079" translate="yes" xml:space="preserve">
          <source>ReQL command: seconds</source>
          <target state="translated">ReQL 명령 : 초</target>
        </trans-unit>
        <trans-unit id="f1bb2be8ae02baa7d054dd238fb17ff6adc0e5fc" translate="yes" xml:space="preserve">
          <source>ReQL command: server</source>
          <target state="translated">ReQL 명령 : 서버</target>
        </trans-unit>
        <trans-unit id="bd21c33c7d7e4a661ae24315ff5adaf657b0d101" translate="yes" xml:space="preserve">
          <source>ReQL command: setDifference</source>
          <target state="translated">ReQL 명령 : setDifference</target>
        </trans-unit>
        <trans-unit id="ee8b9454ec4e6e9f1927b8de9dc70609dcdeafae" translate="yes" xml:space="preserve">
          <source>ReQL command: setInsert</source>
          <target state="translated">ReQL 명령 : setInsert</target>
        </trans-unit>
        <trans-unit id="c9a0eb231439f96cafbfefb58f50b26a3a819a2d" translate="yes" xml:space="preserve">
          <source>ReQL command: setIntersection</source>
          <target state="translated">ReQL 명령 : setIntersection</target>
        </trans-unit>
        <trans-unit id="04f4bae437d2c848c78c8d28f84714b52d7f6c3f" translate="yes" xml:space="preserve">
          <source>ReQL command: setUnion</source>
          <target state="translated">ReQL 명령 : setUnion</target>
        </trans-unit>
        <trans-unit id="19311ff5522c6db5f5f3d20e812d39f1a5fc5892" translate="yes" xml:space="preserve">
          <source>ReQL command: skip</source>
          <target state="translated">ReQL 명령 : 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="76501a2b3ef6222fd67dd4c4fd5d7848613ac2b2" translate="yes" xml:space="preserve">
          <source>ReQL command: slice</source>
          <target state="translated">ReQL 명령 : 슬라이스</target>
        </trans-unit>
        <trans-unit id="5dfe709e1e34e3632317f2600c09e5128cb9ae93" translate="yes" xml:space="preserve">
          <source>ReQL command: spliceAt</source>
          <target state="translated">ReQL 명령 : spliceAt</target>
        </trans-unit>
        <trans-unit id="c8464e0de44dd2800e23b2097a3059deee41b021" translate="yes" xml:space="preserve">
          <source>ReQL command: split</source>
          <target state="translated">ReQL 명령 : 분할</target>
        </trans-unit>
        <trans-unit id="570b17954ae1d507f16d974d184fbad67acf5855" translate="yes" xml:space="preserve">
          <source>ReQL command: status</source>
          <target state="translated">ReQL 명령 : 상태</target>
        </trans-unit>
        <trans-unit id="13e59b90332b50ab084f0e4a384ba3686605cd3f" translate="yes" xml:space="preserve">
          <source>ReQL command: sub</source>
          <target state="translated">ReQL 명령 : sub</target>
        </trans-unit>
        <trans-unit id="10e1b3442af15fbd32119e6a98b64febea339584" translate="yes" xml:space="preserve">
          <source>ReQL command: sum</source>
          <target state="translated">ReQL 명령 : 합계</target>
        </trans-unit>
        <trans-unit id="da0339a917c31dc275e5131893031fc7f6acce4c" translate="yes" xml:space="preserve">
          <source>ReQL command: sync</source>
          <target state="translated">ReQL 명령 : sync</target>
        </trans-unit>
        <trans-unit id="8d21f3686cbc79062796b79f01a307a2daa74707" translate="yes" xml:space="preserve">
          <source>ReQL command: table</source>
          <target state="translated">ReQL 명령 : 테이블</target>
        </trans-unit>
        <trans-unit id="5a75ff2420141b13ad812407726590d8e11bf491" translate="yes" xml:space="preserve">
          <source>ReQL command: tableCreate</source>
          <target state="translated">ReQL 명령 : tableCreate</target>
        </trans-unit>
        <trans-unit id="6edc96e8bb975009898532d7c3ac0d5c9c3e1171" translate="yes" xml:space="preserve">
          <source>ReQL command: tableDrop</source>
          <target state="translated">ReQL 명령 : tableDrop</target>
        </trans-unit>
        <trans-unit id="321385e05615dc1e097447354a11170214318796" translate="yes" xml:space="preserve">
          <source>ReQL command: tableList</source>
          <target state="translated">ReQL 명령 : tableList</target>
        </trans-unit>
        <trans-unit id="0659bee81d319deb7e130473db0dc2263f4622f3" translate="yes" xml:space="preserve">
          <source>ReQL command: time</source>
          <target state="translated">ReQL 명령 : 시간</target>
        </trans-unit>
        <trans-unit id="37216ac18e28d2fe512c09beeb963db758364a4b" translate="yes" xml:space="preserve">
          <source>ReQL command: timeOfDay</source>
          <target state="translated">ReQL 명령 : timeOfDay</target>
        </trans-unit>
        <trans-unit id="1de03f1799a9257b1e0cb0c6a0e68b6a2125ca72" translate="yes" xml:space="preserve">
          <source>ReQL command: timezone</source>
          <target state="translated">ReQL 명령 : 시간대</target>
        </trans-unit>
        <trans-unit id="2af08e633e375c04686b6dd4e002092239a1eed9" translate="yes" xml:space="preserve">
          <source>ReQL command: toArray</source>
          <target state="translated">ReQL 명령 : toArray</target>
        </trans-unit>
        <trans-unit id="513f46f55a4b510e789657e077cfdb94101a2398" translate="yes" xml:space="preserve">
          <source>ReQL command: toEpochTime</source>
          <target state="translated">ReQL 명령 : toEpochTime</target>
        </trans-unit>
        <trans-unit id="627570fef15c7acc0c2663e684f59cb33b2b1459" translate="yes" xml:space="preserve">
          <source>ReQL command: toGeojson</source>
          <target state="translated">ReQL 명령 : toGeojson</target>
        </trans-unit>
        <trans-unit id="56852d9c1a1873fd61c17972ef99801ac2c87ecf" translate="yes" xml:space="preserve">
          <source>ReQL command: toISO8601</source>
          <target state="translated">ReQL 명령 : toISO8601</target>
        </trans-unit>
        <trans-unit id="f6f174b5765bf64194d9ca622d10e16cd8a46617" translate="yes" xml:space="preserve">
          <source>ReQL command: toJsonString, toJSON</source>
          <target state="translated">ReQL 명령 : toJsonString, toJSON</target>
        </trans-unit>
        <trans-unit id="19cdf1a2a2fefcc0935b25802524c2a58527dbbb" translate="yes" xml:space="preserve">
          <source>ReQL command: typeOf</source>
          <target state="translated">ReQL 명령 : typeOf</target>
        </trans-unit>
        <trans-unit id="8022749a3da3c400ea76655d26b31790850a20bf" translate="yes" xml:space="preserve">
          <source>ReQL command: ungroup</source>
          <target state="translated">ReQL 명령 : 그룹 해제</target>
        </trans-unit>
        <trans-unit id="fe481736ff3cb3a807c23188aaf45a55b2d99dc4" translate="yes" xml:space="preserve">
          <source>ReQL command: union</source>
          <target state="translated">ReQL 명령 : 공용체</target>
        </trans-unit>
        <trans-unit id="6dbff263f97562be4ce701c91fec033e04feaf07" translate="yes" xml:space="preserve">
          <source>ReQL command: upcase</source>
          <target state="translated">ReQL 명령 : 대문자</target>
        </trans-unit>
        <trans-unit id="455ab20ffc94cace160b696dfbeaa15326dd0cf2" translate="yes" xml:space="preserve">
          <source>ReQL command: update</source>
          <target state="translated">ReQL 명령 : 업데이트</target>
        </trans-unit>
        <trans-unit id="e0651ec1f9bbf8339e03befeb514c75a1ab27c73" translate="yes" xml:space="preserve">
          <source>ReQL command: use</source>
          <target state="translated">ReQL 명령 : 사용</target>
        </trans-unit>
        <trans-unit id="4e9d4a579dc4455f2e6db7cb499db7af40804ded" translate="yes" xml:space="preserve">
          <source>ReQL command: uuid</source>
          <target state="translated">ReQL 명령 : uuid</target>
        </trans-unit>
        <trans-unit id="325ff960145ced96b81cf4fd70fa7b1153d74132" translate="yes" xml:space="preserve">
          <source>ReQL command: values</source>
          <target state="translated">ReQL 명령 : 값</target>
        </trans-unit>
        <trans-unit id="997a6bf76bb87f3bcdf7d12f2d88b575cc41fefa" translate="yes" xml:space="preserve">
          <source>ReQL command: wait</source>
          <target state="translated">ReQL 명령 : 대기</target>
        </trans-unit>
        <trans-unit id="85a62250b115e6cd99762def1db4a11a411a71e6" translate="yes" xml:space="preserve">
          <source>ReQL command: withFields</source>
          <target state="translated">ReQL 명령 : withFields</target>
        </trans-unit>
        <trans-unit id="369250ffd90be27fd1fa8cfe5c8ea1f06e5ca8ed" translate="yes" xml:space="preserve">
          <source>ReQL command: without</source>
          <target state="translated">ReQL 명령 : 미포함</target>
        </trans-unit>
        <trans-unit id="274b2016fa95fda2a3b60df052ec709fc131c8b3" translate="yes" xml:space="preserve">
          <source>ReQL command: year</source>
          <target state="translated">ReQL 명령 : 연도</target>
        </trans-unit>
        <trans-unit id="395a7dc9265d0f496258ee4292950abf3e16e123" translate="yes" xml:space="preserve">
          <source>ReQL command: zip</source>
          <target state="translated">ReQL 명령 : zip</target>
        </trans-unit>
        <trans-unit id="0745f2086f93ccd2a331d7072137817d3cb55afa" translate="yes" xml:space="preserve">
          <source>ReQL commands</source>
          <target state="translated">ReQL 명령</target>
        </trans-unit>
        <trans-unit id="59807be887cb81af9dbfaac16f14ad42e6245fa9" translate="yes" xml:space="preserve">
          <source>ReQL commands are represented as a list of two or three elements.</source>
          <target state="translated">ReQL 명령은 2 ~ 3 개의 요소 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94f7952690489bb7dd3edb6940dbc296908f9252" translate="yes" xml:space="preserve">
          <source>ReQL data</source>
          <target state="translated">ReQL 데이터</target>
        </trans-unit>
        <trans-unit id="09010231d56a5d2fda3a74b70c661c1e81cadefe" translate="yes" xml:space="preserve">
          <source>ReQL data types</source>
          <target state="translated">ReQL 데이터 유형</target>
        </trans-unit>
        <trans-unit id="191a7a574620481e86f08d38eca70528f9f36e03" translate="yes" xml:space="preserve">
          <source>ReQL embeds into your programming language</source>
          <target state="translated">프로그래밍 언어에 ReQL 내장</target>
        </trans-unit>
        <trans-unit id="125f3b5c55d48af1835dac4b751c29ca63213adc" translate="yes" xml:space="preserve">
          <source>ReQL error types</source>
          <target state="translated">ReQL 오류 유형</target>
        </trans-unit>
        <trans-unit id="cece285d53709eacd625cbfa5e27ed559a1d29d6" translate="yes" xml:space="preserve">
          <source>ReQL geometry objects are not &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; objects, but you can convert back and forth between them with the &lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt; commands.</source>
          <target state="translated">ReQL 지오메트리 객체는 &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 객체가 아니지만 &lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt; 및 &lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt; 명령을 사용하여 객체 간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35a42830df2a6efe0b040fe441dccc75dde4e460" translate="yes" xml:space="preserve">
          <source>ReQL has commands for extracting parts of &lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;dates and times&lt;/a&gt;, including &lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;year&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;month&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;day&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt; and more. You can use these with &lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;group&lt;/a&gt; to group by various intervals. Suppose you had a table of invoices and wanted to retrieve them in groups ordered by year and month:</source>
          <target state="translated">ReQL에는 &lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;year&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;month&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;day&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt; 등을 포함하여 &lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;날짜 및 시간의&lt;/a&gt; 일부를 추출하는 명령이 있습니다. 다양한 간격 으로 &lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;그룹화&lt;/a&gt; 하기 위해 그룹 과 함께 사용할 수 있습니다 . 송장 테이블이 있고 연도 및 월별로 순서대로 그룹으로 검색하려고한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da86166d7e392999c718f777993e73c609f2fbc7" translate="yes" xml:space="preserve">
          <source>ReQL is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;domain specific language&lt;/a&gt; expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</source>
          <target state="translated">ReQL은 호스트 언어 &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;로&lt;/a&gt; 표현 된 도메인 별 언어입니다. 세 가지 공식 드라이버는 매우 유사한 구문을 따릅니다. 선택한 언어가 허용하는 한 그 모델을 고수해야합니다. 일반적으로 접두사 또는 접두사 표기법을 자유롭게 사용하거나 두 가지를 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b7a017a84f9b3da4de0039647a3013516208eb" translate="yes" xml:space="preserve">
          <source>ReQL is different from other NoSQL query languages. It&amp;rsquo;s built on three key principles:</source>
          <target state="translated">ReQL은 다른 NoSQL 쿼리 언어와 다릅니다. 세 가지 주요 원칙을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="dab0c7b28a7500cbaccffec7e5e887241992d2da" translate="yes" xml:space="preserve">
          <source>ReQL is efficient</source>
          <target state="translated">ReQL은 효율적입니다</target>
        </trans-unit>
        <trans-unit id="6c8ae750e37a742a762efbb4d4a707a2f88e21d9" translate="yes" xml:space="preserve">
          <source>ReQL is the RethinkDB query language. It offers a very powerful and convenient way to manipulate JSON documents. This document is a gentle introduction to ReQL concepts. You don&amp;rsquo;t have to read it to be productive with RethinkDB, but it helps to understand some basics.</source>
          <target state="translated">ReQL은 RethinkDB 쿼리 언어입니다. JSON 문서를 조작하는 매우 강력하고 편리한 방법을 제공합니다. 이 문서는 ReQL 개념에 대한 간단한 소개입니다. RethinkDB로 생산성을 높이기 위해 읽을 필요는 없지만 몇 가지 기본 사항을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="62b7b785aa09ec970184f5e88cf1e8539b883367" translate="yes" xml:space="preserve">
          <source>ReQL pseudo types</source>
          <target state="translated">ReQL 의사 유형</target>
        </trans-unit>
        <trans-unit id="8b783f5ac5ce21c42bde10cc36b31b26d3e95f39" translate="yes" xml:space="preserve">
          <source>ReQL queries are composable</source>
          <target state="translated">ReQL 쿼리는 작성 가능</target>
        </trans-unit>
        <trans-unit id="0d649019dd97255601cf647335065eb587632177" translate="yes" xml:space="preserve">
          <source>ReQL queries are executed lazily:</source>
          <target state="translated">ReQL 쿼리는 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="46cc7a8d6eff2c8a22f5442d9d90d27387cddcaa" translate="yes" xml:space="preserve">
          <source>ReQL queries are functional</source>
          <target state="translated">ReQL 쿼리는 작동합니다</target>
        </trans-unit>
        <trans-unit id="baf0a6b4a49af458581fecb524a2b910b9bc313c" translate="yes" xml:space="preserve">
          <source>ReQL types and commands are defined in the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt; file.</source>
          <target state="translated">ReQL 유형 및 명령은 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2093e96b1a65a9a688a5cc8dffba6429e5a47515" translate="yes" xml:space="preserve">
          <source>ReQL&amp;rsquo;s nesting depth is limited to 20 levels. This can be changed with the undocumented &lt;code&gt;nestingDepth&lt;/code&gt; (or &lt;code&gt;nesting_depth&lt;/code&gt;) option to &lt;code&gt;r.expr()&lt;/code&gt;, but before using that, consider whether the document can be reorganized to avoid the error.</source>
          <target state="translated">ReQL의 중첩 깊이는 20 레벨로 제한됩니다. 이것은 문서화되지 않은 &lt;code&gt;nestingDepth&lt;/code&gt; (또는 &lt;code&gt;nesting_depth&lt;/code&gt; ) 옵션을 사용하여 &lt;code&gt;r.expr()&lt;/code&gt; 로 변경할 수 있지만, 사용하기 전에 오류를 피하기 위해 문서를 재구성 할 수 있는지 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="48fa53a29856312c157be48d24a169a0a913953d" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for a complete discussion of the subject, including advanced topics.</source>
          <target state="translated">고급 주제를 포함하여 주제에 대한 전체 토론을 보려면 &lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b4eef36f30bb0fd18c9978dad0fad8450b46a35e" translate="yes" xml:space="preserve">
          <source>Read Compose&amp;rsquo;s &lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;overview&lt;/a&gt; of RethinkDB support and their &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;Connecting to RethinkDB&lt;/a&gt; documentation for more information.</source>
          <target state="translated">자세한 내용은 Compose의 RethinkDB 지원 &lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;개요&lt;/a&gt; 및 RethinkDB에 &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;연결&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="646061e2f38829c59bbd2bebc1acc8f7f33e1c4e" translate="yes" xml:space="preserve">
          <source>Read More</source>
          <target state="translated">더 읽어보기</target>
        </trans-unit>
        <trans-unit id="26899b3ad08bf6f09ed1824ded31e41b43aadfd5" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;creating secondary indexes in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;RethinkDB에서 보조 인덱스 작성&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b6445979be97a3e933b6bb240cff09a6407b2918" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;validation in NoBrainer&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;은 NoBrainer의 유효성 검사에&lt;/a&gt; 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f88dbb0d2a98507a39fce321163277b3a73a9734" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this technology is implemented&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;은이 기술이 어떻게 구현되는지&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="ad086cf55b834c375e209972840f1342401d8c41" translate="yes" xml:space="preserve">
          <source>Read more</source>
          <target state="translated">더 읽어보기</target>
        </trans-unit>
        <trans-unit id="a2453263034e6e359ea2f543b4881317b239da0a" translate="yes" xml:space="preserve">
          <source>Read more about this command &amp;rarr;</source>
          <target state="translated">이 명령에 대해 자세히 알아보십시오 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="02f254122240b0223890c627f9fb1fededf11d25" translate="yes" xml:space="preserve">
          <source>Read more details about RethinkDB&amp;rsquo;s binary object support: &lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;Storing binary objects&lt;/a&gt;.</source>
          <target state="translated">RethinkDB의 이진 객체 지원에 대한 자세한 내용을 읽어보십시오 : &lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;이진 객체 저장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90468c1697f8bededde1b19c579430c9cba85e5a" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;introduction to RQL&lt;/a&gt; to learn about the ReQL concepts in more depth.</source>
          <target state="translated">ReQL 개념에 대해 자세히 알아 보려면 &lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;RQL 소개를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b7305dc3ce2b74ab8470a10b76b25826ab716813" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../quickstart/index&quot;&gt;서른 초 빠른 시작&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="bd50ab4e04e65b18c59e790e54937f033d4e636d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../quickstart/index&quot;&gt;서른 초 빠른 시작을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b3f7216d53c7652972070c1613c1e9033b24a010" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../guide/javascript/index&quot;&gt;ten-minute guide&lt;/a&gt; to get started with using RethinkDB.</source>
          <target state="translated">RethinkDB 사용을 시작 하려면 &lt;a href=&quot;../guide/javascript/index&quot;&gt;10 분 가이드&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2d09665db0a53946b8e9d31dc64ad079edc1aaff" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../quickstart/index&quot;&gt;서른 초 빠른 시작&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="a87c2bcd4362cf6fb041820c08ec2389cdff1f01" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;source code for existing drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;기존 드라이버&lt;/a&gt; 의 소스 코드를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ecd34094f7e876256eb1edd303a58f87ed2f40f7" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL data types&lt;/a&gt; for a more detailed discussion. Note that some possible return values from &lt;code&gt;typeOf&lt;/code&gt; are internal values, such as &lt;code&gt;MAXVAL&lt;/code&gt;, and unlikely to be returned from queries in standard practice.</source>
          <target state="translated">더 자세한 논의는 &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL 데이터 유형&lt;/a&gt; 에 관한 기사를 읽으십시오 . 일부 가능한 반환 값 있습니다 &lt;code&gt;typeOf&lt;/code&gt; 내부와 같은 값이다 &lt;code&gt;MAXVAL&lt;/code&gt; 및 가능성은 표준 실제로 쿼리에서 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69a94a798fe63c51a0462527c27fb6ae3d9aa98a" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../writing-drivers/index&quot;&gt;writing RethinkDB drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../writing-drivers/index&quot;&gt;RethinkDB 드라이버 작성에&lt;/a&gt; 관한 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae455b050e5bf042c051a0264064730a12241af" translate="yes" xml:space="preserve">
          <source>Reads and writes are performed by eight client servers, with 128 concurrent connections per database server. This means we have 128 connections with just a single RethinkDB server, and 2048 concurrent connections with a 16-node cluster. We used a replication factor of two per table, meaning each document was replicated to two separate servers.</source>
          <target state="translated">데이터베이스 서버 당 128 개의 동시 연결로 8 개의 클라이언트 서버가 읽기 및 쓰기를 수행합니다. 즉, 단일 RethinkDB 서버로 128 개의 연결이 있고 16 노드 클러스터와 2048 개의 동시 연결이 있습니다. 테이블 당 2의 복제 팩터를 사용했습니다. 즉, 각 문서가 두 개의 별도 서버로 복제되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee4d904478e46dd47f209480eb0a07339d3b0d44" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode will return outdated data even during normal operation, but the data will typically be less than a second out of date. In the event of a network or server failure, the data may be much more out of date. The advantage of running reads in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode is that the latency and throughput are often better than in &lt;code&gt;&quot;single&quot;&lt;/code&gt; mode, in addition to the availability differences described in the previous section.</source>
          <target state="translated">&lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 모드 에서 실행 하면 정상 작동 중에도 오래된 데이터가 반환되지만 데이터는 일반적으로 1 초 미만입니다. 네트워크 또는 서버 장애가 발생하면 데이터가 훨씬 오래되었을 수 있습니다. &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 모드 에서 읽기를 실행 하면 이전 섹션에서 설명한 가용성 차이 외에도 대기 시간 및 처리량이 &lt;code&gt;&quot;single&quot;&lt;/code&gt; 모드 보다 우수하다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4e1fdf56fccb0716e779b51b4fd1b78316b38b" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;single&lt;/code&gt; mode may succeed even if the table is not available, but this is not guaranteed. Reads run in &lt;code&gt;outdated&lt;/code&gt; mode will succeed as long as at least one replica for each of the relevant shards is available.</source>
          <target state="translated">테이블을 사용할 수없는 경우에도 &lt;code&gt;single&lt;/code&gt; 모드 에서 읽기 실행 이 성공할 수 있지만 이것이 보장되지는 않습니다. 각 관련 샤드에 대해 하나 이상의 복제본을 사용할 수 있는 한 &lt;code&gt;outdated&lt;/code&gt; 모드 에서 읽기 가 성공합니다.</target>
        </trans-unit>
        <trans-unit id="1d0349ac58ea3d38ff5f50980a915c92316eb132" translate="yes" xml:space="preserve">
          <source>Realtime feeds</source>
          <target state="translated">실시간 피드</target>
        </trans-unit>
        <trans-unit id="6858c6a7228cbd560d4cfe81ead5db5f9e52f0b8" translate="yes" xml:space="preserve">
          <source>Rebalances the shards of a table. When called on a database, all the tables in that database will be rebalanced.</source>
          <target state="translated">테이블의 샤드를 재조정합니다. 데이터베이스에서 호출되면 해당 데이터베이스의 모든 테이블이 재조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0fe299ad13ae6716e4c9dd8be790a6a70d91b0f3" translate="yes" xml:space="preserve">
          <source>Rebuild indexes</source>
          <target state="translated">인덱스 재 구축</target>
        </trans-unit>
        <trans-unit id="36141d622dd1843fafbde3ba5b63d5704d3eaca5" translate="yes" xml:space="preserve">
          <source>Receive responses</source>
          <target state="translated">응답 받기</target>
        </trans-unit>
        <trans-unit id="f40f931807d3e751f75ae8f61f51b88d3c55f63e" translate="yes" xml:space="preserve">
          <source>Recently, the team behind BigchainDB &amp;ndash; a scalable blockchain database built on top of RethinkDB &amp;ndash; has benchmarked RethinkDB on a 32-server cluster running on Amazon&amp;rsquo;s EC2. They measured throughput of more than a million writes per second. Their conclusion: &amp;ldquo;There is linear scaling in write performance with the number of nodes.&amp;rdquo; The full report is available at &lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt;</source>
          <target state="translated">최근에 RethinkDB 위에 구축 된 확장 가능한 블록 체인 데이터베이스 인 BigchainDB 팀은 Amazon EC2에서 실행되는 32 서버 클러스터에서 RethinkDB를 벤치마킹했습니다. 그들은 초당 백만 번 이상의 쓰기 처리량을 측정했습니다. 그들의 결론 :&amp;ldquo;노드 수에 따라 쓰기 성능에 선형 스케일링이 있습니다.&amp;rdquo; 전체 보고서는 &lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt; 에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed843dc519783f62617c1358f81fae926ee0818" translate="yes" xml:space="preserve">
          <source>Reconfigure a table&amp;rsquo;s sharding and replication.</source>
          <target state="translated">테이블의 샤딩 및 복제를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce1c56b1ad89cc7c3d7f1c846b92e4404ee94e6" translate="yes" xml:space="preserve">
          <source>Reconfiguring a table (changing the number of shards, rebalancing, etc.) causes brief losses of availability at various points during the reconfiguration.</source>
          <target state="translated">테이블 재구성 (샤드 수 변경, 재조정 등)은 재구성 중에 다양한 지점에서 일시적으로 가용성이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="d883c0d0e6af1f4f5d9bae45cb31865272b7621e" translate="yes" xml:space="preserve">
          <source>Reference a database.</source>
          <target state="translated">데이터베이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f97b0faeb0aa223b01f7944075457b4fdb5c0b17" translate="yes" xml:space="preserve">
          <source>Related commands</source>
          <target state="translated">관련 명령</target>
        </trans-unit>
        <trans-unit id="6fd9fce94e1798f55b5904f5f4b1afc9b73462f0" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;../delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">주어진 인덱스의 배열에서 하나 이상의 요소를 제거합니다. 수정 된 배열을 반환합니다. (참고 : &lt;code&gt;deleteAt&lt;/code&gt; 는 문서가 아닌 배열에서 작동합니다. 문서를 삭제 &lt;a href=&quot;../delete/index&quot;&gt;하려면 delete&lt;/a&gt; 명령을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="28b83b24b89e420600d6b0c7028a8d2290ddf0d9" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">주어진 인덱스의 배열에서 하나 이상의 요소를 제거합니다. 수정 된 배열을 반환합니다. (참고 : &lt;code&gt;deleteAt&lt;/code&gt; 는 문서가 아닌 배열에서 작동합니다. 문서를 삭제 &lt;a href=&quot;delete/index&quot;&gt;하려면 delete&lt;/a&gt; 명령을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a87b37bc5f692c148c02fe605a7458c77b15a50d" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another and return them as a set (an array with distinct values).</source>
          <target state="translated">한 배열의 요소를 다른 배열에서 제거하고 세트 (고유 한 값을 가진 배열)로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="afa632a95dc9c80b866a354f23735d7bcd1157a2" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another array.</source>
          <target state="translated">한 배열의 요소를 다른 배열에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0697a27ec337b72d0e4d72523605d451a59444a0" translate="yes" xml:space="preserve">
          <source>Removes duplicates from elements in a sequence.</source>
          <target state="translated">순서대로 요소에서 중복을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="79a53851e290035c55b906df35b29aaa6f920cf9" translate="yes" xml:space="preserve">
          <source>Removing a field from a document</source>
          <target state="translated">문서에서 필드 제거</target>
        </trans-unit>
        <trans-unit id="67e44982c2b6ecb129404da6bb7b5c7d570feae7" translate="yes" xml:space="preserve">
          <source>Removing duplicate documents</source>
          <target state="translated">중복 문서 제거</target>
        </trans-unit>
        <trans-unit id="fd82550f7bdd5147fa9b38ad056203473cb75426" translate="yes" xml:space="preserve">
          <source>Removing the conflicting fields</source>
          <target state="translated">충돌하는 필드 제거</target>
        </trans-unit>
        <trans-unit id="b5140bff21a36c4d10e5e19f157b727b262facdd" translate="yes" xml:space="preserve">
          <source>Rename an existing secondary index on a table. If the optional argument &lt;code&gt;overwrite&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;, a previously existing index with the new name will be deleted and the index will be renamed. If &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) an error will be raised if the new index name already exists.</source>
          <target state="translated">테이블에서 기존 보조 인덱스의 이름을 바꿉니다. 선택적 인수 &lt;code&gt;overwrite&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 지정 되면 새 이름을 가진 기존 색인이 삭제되고 색인 이름이 변경됩니다. 경우 &lt;code&gt;overwrite&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 새 인덱스 이름이 이미 존재하는 경우 (기본값) 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b77fd7d07db52ea2672fd8ede11ae8823105710" translate="yes" xml:space="preserve">
          <source>Rename the new index to the old index&amp;rsquo;s name with &lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt; 을 사용하여 새 인덱스의 이름을 이전 인덱스의 이름으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="40c174bdf445078528f8a2f96d1df5c325ca2288" translate="yes" xml:space="preserve">
          <source>Renaming a database</source>
          <target state="translated">데이터베이스 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="284f910642e6a0defb4586578a3c2a7bd1161d13" translate="yes" xml:space="preserve">
          <source>Renaming a field when retrieving documents</source>
          <target state="translated">문서를 검색 할 때 필드 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c85b059a75da0fd1dc38ae1c0c348e9320390608" translate="yes" xml:space="preserve">
          <source>Renaming the fields</source>
          <target state="translated">필드 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="6aca56afb789aecc38fe4230dec10a4632e60865" translate="yes" xml:space="preserve">
          <source>Replace an object in a field instead of merging it with an existing object in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation. Using &lt;code&gt;literal&lt;/code&gt; with no arguments in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation will remove the corresponding field.</source>
          <target state="translated">필드를 &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt; 작업 에서 기존 개체와 병합하는 대신 필드의 개체를 바꾸십시오 . &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt; 작업 에서 인수없이 &lt;code&gt;literal&lt;/code&gt; 을 사용 하면 해당 필드가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab64c46bc6706994c25c2b0a6ee60d324ab8b2d" translate="yes" xml:space="preserve">
          <source>Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces the original document with the new one. The new document must have the same primary key as the original document.</source>
          <target state="translated">테이블에서 문서를 교체하십시오. JSON 문서 또는 ReQL 표현식을 승인하고 원본 문서를 새 문서로 바꿉니다. 새 문서에는 원본 문서와 동일한 기본 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6a9ea19f10bfe83981d4540dee88a3df008ec57" translate="yes" xml:space="preserve">
          <source>Replace returns an object that contains the following attributes:</source>
          <target state="translated">바꾸기는 다음 속성이 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c5d061d62323778048566a495b1df0b38ea2db7" translate="yes" xml:space="preserve">
          <source>Replaces cursors with streams.</source>
          <target state="translated">커서를 스트림으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="722a8bb542ea393f48ca936e084109b805daa87a" translate="yes" xml:space="preserve">
          <source>Replication</source>
          <target state="translated">Replication</target>
        </trans-unit>
        <trans-unit id="8c34185af915f1e0949bfddb344b5dea859540d4" translate="yes" xml:space="preserve">
          <source>Repubsub implements a simple abstraction on top of RethinkDB to enable publish-subscribe. It uses ReQL as the filtering mechanism, so the full power of the language is at your disposal. This gives a lot more flexibility than traditional message queues.</source>
          <target state="translated">Repubsub는 RethinkDB 위에 간단한 추상화를 구현하여 publish-subscribe를 활성화합니다. 필터링 메커니즘으로 ReQL을 사용하므로 언어의 모든 기능을 사용할 수 있습니다. 이는 기존 메시지 대기열보다 훨씬 많은 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="552a6a287997255111938f1213d6239a6eb625b9" translate="yes" xml:space="preserve">
          <source>Request Options</source>
          <target state="translated">요청 옵션</target>
        </trans-unit>
        <trans-unit id="cf028cb289e92d72ecac0c14797660b76e05fb6f" translate="yes" xml:space="preserve">
          <source>Resolving field name conflicts</source>
          <target state="translated">필드 이름 충돌 해결</target>
        </trans-unit>
        <trans-unit id="5488d03c527f32b4acc287af95407883ab8f73b2" translate="yes" xml:space="preserve">
          <source>Response notes</source>
          <target state="translated">응답 메모</target>
        </trans-unit>
        <trans-unit id="edbff191035089d6d00fc87982482ed99855f37e" translate="yes" xml:space="preserve">
          <source>Response types</source>
          <target state="translated">응답 유형</target>
        </trans-unit>
        <trans-unit id="ab860e83a8bba4577ed1f5d169b6ff9b4a71a996" translate="yes" xml:space="preserve">
          <source>Responses from the server take the following form:</source>
          <target state="translated">서버의 응답은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3cbe6d6b9a8d1596bb5bca12e14d81c9e108a1a3" translate="yes" xml:space="preserve">
          <source>Restore</source>
          <target state="translated">Restore</target>
        </trans-unit>
        <trans-unit id="fa8c448a3304c7e3bba81325d21434fc4e1ab989" translate="yes" xml:space="preserve">
          <source>Restore &lt;code&gt;backup.tar.gz&lt;/code&gt; to the cluster running on &lt;code&gt;fortress&lt;/code&gt; at port &lt;code&gt;39500&lt;/code&gt;.</source>
          <target state="translated">포트 &lt;code&gt;39500&lt;/code&gt; 의 &lt;code&gt;fortress&lt;/code&gt; 에서 실행중인 클러스터로 &lt;code&gt;backup.tar.gz&lt;/code&gt; 를 복원 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c5aff5b034a17ad5b0aa80d1b5867fcaeafd472" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster (&lt;code&gt;localhost:28015&lt;/code&gt;).</source>
          <target state="translated">기본 클러스터 ( &lt;code&gt;localhost:28015&lt;/code&gt; )로 복원하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfb3d23e010f68e0af656c3a161f08787d49d8df" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster, only importing the table &lt;code&gt;users&lt;/code&gt; to the database &lt;code&gt;league&lt;/code&gt; from the archive &lt;code&gt;backup.tar.gz&lt;/code&gt;. Read the &lt;code&gt;admin&lt;/code&gt; user password from the file &lt;code&gt;pw.txt&lt;/code&gt;. (This should be a plain text file with the password on the first and only line.)</source>
          <target state="translated">아카이브 &lt;code&gt;backup.tar.gz&lt;/code&gt; 에서 테이블 &lt;code&gt;users&lt;/code&gt; 를 데이터베이스 &lt;code&gt;league&lt;/code&gt; 로 가져 오기만 기본 클러스터로 복원하십시오 . &lt;code&gt;pw.txt&lt;/code&gt; 파일에서 &lt;code&gt;admin&lt;/code&gt; 비밀번호를 읽으십시오 . (첫 번째 및 유일한 행에 비밀번호가있는 일반 텍스트 파일이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="735933ae21af969b090b07b609e7695fc978b7ac" translate="yes" xml:space="preserve">
          <source>RethinkDB 2.1.5 performance &amp;amp; scaling report</source>
          <target state="translated">RethinkDB 2.1.5 성능 및 스케일링 보고서</target>
        </trans-unit>
        <trans-unit id="cb467484ded44adadf6f26ec92b1553d399b7b13" translate="yes" xml:space="preserve">
          <source>RethinkDB Documentation</source>
          <target state="translated">RethinkDB 문서</target>
        </trans-unit>
        <trans-unit id="e4d8c0ff3051c40b7a7d2280bdd1fcf8d66cf738" translate="yes" xml:space="preserve">
          <source>RethinkDB achieves a throughput of 14.6K QPS with two servers, and scales near-linearly as servers are added to the cluster.</source>
          <target state="translated">RethinkDB는 2 대의 서버로 14.6K QPS의 처리량을 달성하며 서버가 클러스터에 추가 될 때 거의 선형으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e345c3b07e0fd9d1adeaa8ca81dd01baad355475" translate="yes" xml:space="preserve">
          <source>RethinkDB allows you to shard and replicate your cluster on a per-table basis. Settings can be controlled easily from the web administration console. In addition, ReQL commands for table configuration allow both scripting capability and more fine-grained control over replication, distributing replicas for individual tables across user-defined groups of servers using server tags.</source>
          <target state="translated">RethinkDB를 사용하면 테이블별로 클러스터를 분할하고 복제 할 수 있습니다. 웹 관리 콘솔에서 설정을 쉽게 제어 할 수 있습니다. 또한 테이블 구성을위한 ReQL 명령을 사용하면 스크립팅 기능과 복제를보다 세밀하게 제어 할 수 있으므로 서버 태그를 사용하여 사용자 정의 서버 그룹에 개별 테이블의 복제본을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda9071dab24f5356340e451144a72dcc92d3fce" translate="yes" xml:space="preserve">
          <source>RethinkDB and Rails</source>
          <target state="translated">DB 및 레일 재검토</target>
        </trans-unit>
        <trans-unit id="26e492bb4ea400bd0d23919baddf67941c58a444" translate="yes" xml:space="preserve">
          <source>RethinkDB automatically rebalances tables when the number of shards are increased, and as long as your documents have evenly distributed primary keys&amp;mdash;such as the default UUIDs&amp;mdash;it is rarely necessary to call &lt;code&gt;rebalance&lt;/code&gt; manually. Cases where &lt;code&gt;rebalance&lt;/code&gt; may need to be called include:</source>
          <target state="translated">샤드 수가 증가하고 문서에 기본 UUID와 같은 기본 키가 균등하게 분산되어있는 한 RethinkDB는 자동으로 테이블의 &lt;code&gt;rebalance&lt;/code&gt; 합니다. 케이스 &lt;code&gt;rebalance&lt;/code&gt; 호출 할 필요가 있습니다은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="ad70484f409d6361985bb8c8f93c7743544624d3" translate="yes" xml:space="preserve">
          <source>RethinkDB binary installed by the official package in &lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt; 의 공식 패키지로 설치된 RethinkDB 바이너리</target>
        </trans-unit>
        <trans-unit id="b9fdbdd31616d7b419cfafad99fc5ceb4c45dd50" translate="yes" xml:space="preserve">
          <source>RethinkDB cache size set to 64,000 MB per server, otherwise default parameters</source>
          <target state="translated">서버 당 64,000MB로 설정된 RethinkDB 캐시 크기, 그렇지 않으면 기본 매개 변수</target>
        </trans-unit>
        <trans-unit id="6492843a1285914ee9da37e99939a00ce233450b" translate="yes" xml:space="preserve">
          <source>RethinkDB can be easily deployed on &lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt; and &lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 &lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt; 및 &lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt; 에 쉽게 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="779613e061fcbb3ecdf1b3f674a77401d73451f7" translate="yes" xml:space="preserve">
          <source>RethinkDB can handle databases much larger than the amount of main memory available on a server. However, some internal metadata is always kept in memory to guarantee fast access times. Every table has an overhead of 8 MB per server.</source>
          <target state="translated">RethinkDB는 서버에서 사용 가능한 주 메모리 용량보다 훨씬 큰 데이터베이스를 처리 할 수 ​​있습니다. 그러나 일부 내부 메타 데이터는 빠른 액세스 시간을 보장하기 위해 항상 메모리에 보관됩니다. 모든 테이블의 오버 헤드는 서버 당 8MB입니다.</target>
        </trans-unit>
        <trans-unit id="a7a4715c972f6634315cdf77dceadee9d8dd2408" translate="yes" xml:space="preserve">
          <source>RethinkDB changefeeds</source>
          <target state="translated">DB 변경 피드 재검토</target>
        </trans-unit>
        <trans-unit id="1982a12bd3c3cd7086173906e98b7aa6c17ed25d" translate="yes" xml:space="preserve">
          <source>RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses from the server and returning them to the calling application. This process takes the following steps:</source>
          <target state="translated">RethinkDB 클라이언트 드라이버는 쿼리를 직렬화하고, ReQL 유선 프로토콜을 사용하여 서버로 쿼리를 보내고, 서버에서 응답을 수신하여 호출 애플리케이션으로 리턴합니다. 이 프로세스는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="29742e53bf514545423e131a5089ae63314110fd" translate="yes" xml:space="preserve">
          <source>RethinkDB clustering with CoreOS, etcd2 and Docker, by &lt;a href=&quot;https://github.com/pires&quot;&gt;@pires&lt;/a&gt;.</source>
          <target state="translated">@pires에 의해 &lt;a href=&quot;https://github.com/pires&quot;&gt;CoreOS&lt;/a&gt; , etcd2 및 Docker를 사용한 DB 클러스터링을 다시 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="546b0d2304c21245d3bc9748794a02297ae69be4" translate="yes" xml:space="preserve">
          <source>RethinkDB command line options</source>
          <target state="translated">RethinkDB 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="757b43f479974355f39e37a9afd966d958b550a0" translate="yes" xml:space="preserve">
          <source>RethinkDB controls access to clusters through a system based around &lt;strong&gt;users, permissions,&lt;/strong&gt; and &lt;strong&gt;scopes.&lt;/strong&gt; Together, these allow you to specify fine grained control for reading, writing and administrative access down to a per-table level.</source>
          <target state="translated">RethinkDB는 &lt;strong&gt;사용자, 권한&lt;/strong&gt; 및 &lt;strong&gt;범위를&lt;/strong&gt; 기반으로하는 시스템을 통해 클러스터에 대한 액세스를 제어합니다 &lt;strong&gt;. &lt;/strong&gt;이 둘을 함께 사용하면 테이블 수준까지 읽기, 쓰기 및 관리 액세스를위한 세밀한 제어를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5823fa08eb48445af67a4037ecc0701a77215e5" translate="yes" xml:space="preserve">
          <source>RethinkDB data directory will be &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt;</source>
          <target state="translated">RethinkDB 데이터 디렉토리는 &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="612315f0d5f8087ec3f0b4e7fce019c06049b1a8" translate="yes" xml:space="preserve">
          <source>RethinkDB demonstrates extremely high scalability in this configuration, reaching throughputs of well over a million queries per second. The slightly sub-linear scalability when going from 12 to 16 database servers is caused by the client servers&amp;rsquo; CPUs getting saturated at these throughputs.</source>
          <target state="translated">RethinkDB는이 구성에서 매우 높은 확장 성을 보여 초당 백만 건 이상의 쿼리 처리량에 도달합니다. 12 개에서 16 개의 데이터베이스 서버로 이동할 때 약간의 하위 선형 확장 성은 클라이언트 서버의 CPU가 이러한 처리량에서 포화 상태로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8672db1bf1765198165013defafd20d8db24f975" translate="yes" xml:space="preserve">
          <source>RethinkDB does not currently have an optimizer. As an example, the following query will not automatically use an index:</source>
          <target state="translated">RethinkDB에는 현재 최적화 프로그램이 없습니다. 예를 들어 다음 쿼리는 인덱스를 자동으로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="672811adc0003c264d287d9d90dddfe5392790ce" translate="yes" xml:space="preserve">
          <source>RethinkDB does not have fully automatic failover (yet), but if a server in a cluster crashes it can be manually removed from the cluster. In most cases, RethinkDB will recover from such a situation automatically. For information on this process, read &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt;.</source>
          <target state="translated">RethinkDB에는 완전 자동 장애 조치 (아직)가 없지만 클러스터의 서버가 충돌하는 경우 클러스터에서 수동으로 제거 할 수 있습니다. 대부분의 경우 RethinkDB는 이러한 상황에서 자동으로 복구됩니다. 이 프로세스에 대한 자세한 내용은 &lt;a href=&quot;../failover/index&quot;&gt;장애 조치를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29225a505de5e9d97ccc052ef35e3e9e191310f6" translate="yes" xml:space="preserve">
          <source>RethinkDB does not support unique secondary indexes even for non-sharded tables.</source>
          <target state="translated">RethinkDB는 샤딩되지 않은 테이블에서도 고유 한 보조 인덱스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a1e6552e69e48ce4c7f868763ae1040ab304a06" translate="yes" xml:space="preserve">
          <source>RethinkDB does take exclusive block-level locks in case multiple writes are performed on documents that are close together in the B-Tree. If the contested block is cached in memory, these locks are extremely short-lived. If the blocks need to be loaded from disk, these locks take longer. Typically this does not present performance problems because the top levels of the B-Tree are all cached along with the frequently used blocks, so in most cases writes can be performed essentially lock-free.</source>
          <target state="translated">RethinkDB는 B-Tree에서 서로 가까운 문서에서 여러 번 쓰기가 수행되는 경우 독점적 인 블록 수준 잠금을 수행합니다. 컨테스트 된 블록이 메모리에 캐시 된 경우 이러한 잠금은 수명이 매우 짧습니다. 디스크에서 블록을로드해야하는 경우 이러한 잠금이 더 오래 걸립니다. 일반적으로 B-Tree의 최상위 레벨이 자주 사용되는 블록과 함께 캐시되므로 대부분의 경우 쓰기가 기본적으로 잠금없이 수행 될 수 있으므로 성능 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f0f98da3c17608b70462f0c36e09dd4a185e21" translate="yes" xml:space="preserve">
          <source>RethinkDB has access to the query structure, which allows for optimization techniques similar to those available in SQL. This feature will be added to RethinkDB in the future.</source>
          <target state="translated">RethinkDB는 쿼리 구조에 액세스 할 수있어 SQL에서 사용 가능한 것과 유사한 최적화 기법을 사용할 수 있습니다. 이 기능은 향후 RethinkDB에 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="cf29f8f9f21bf8fba6ea63ced9d6fae553e0b5eb" translate="yes" xml:space="preserve">
          <source>RethinkDB has failed to write to its log file (or to &lt;code&gt;stdout/stderr&lt;/code&gt;). The &lt;code&gt;message&lt;/code&gt; string will be the error that RethinkDB received from the operating system on the failed write; &lt;code&gt;servers&lt;/code&gt; will be a list of servers affected.</source>
          <target state="translated">RethinkDB가 로그 파일 (또는 &lt;code&gt;stdout/stderr&lt;/code&gt; ) 에 쓰지 못했습니다 . &lt;code&gt;message&lt;/code&gt; 문자열 RethinkDB 실패한 쓰기에 운영 체제에서 수신 한 오류가 될 것입니다; &lt;code&gt;servers&lt;/code&gt; 는 영향을받는 서버 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc2af13435e602b512f4af7f70dee3bcd170db5" translate="yes" xml:space="preserve">
          <source>RethinkDB has native support for millisecond-precision times with time zones. Some highlights:</source>
          <target state="translated">RethinkDB는 표준 시간대로 밀리 초 단위의 정확한 시간을 지원합니다. 일부 주요 특징 :</target>
        </trans-unit>
        <trans-unit id="0fae139b6eb1367767e96d5c430169b70f3ebb30" translate="yes" xml:space="preserve">
          <source>RethinkDB has powerful Hadoop-style map-reduce tools, that integrate cleanly into the query language. Learn how they work, and play with a few examples.</source>
          <target state="translated">RethinkDB에는 강력한 Hadoop 스타일 맵 감소 도구가있어 쿼리 언어에 깔끔하게 통합됩니다. 그들이 어떻게 작동하는지 배우고 몇 가지 예를 들어보십시오.</target>
        </trans-unit>
        <trans-unit id="7bba8fb71c9832349f00a9f837897d44f12388f1" translate="yes" xml:space="preserve">
          <source>RethinkDB has shortcuts for five common aggregation operations: &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. In practice, you&amp;rsquo;ll often be able to use these with &lt;code&gt;group&lt;/code&gt; these rather than writing your own &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions.</source>
          <target state="translated">RethinkDB에는 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 의 5 가지 일반적인 집계 작업에 대한 바로 가기가 있습니다. 실제로, 당신은 종종 자신의 &lt;code&gt;map&lt;/code&gt; 작성 하고 기능을 &lt;code&gt;reduce&lt;/code&gt; 대신 이들을 &lt;code&gt;group&lt;/code&gt; 과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a07a2f1e204ccef9ce95abeb8228ca595f3024c2" translate="yes" xml:space="preserve">
          <source>RethinkDB has three classes of errors: driver (&lt;code&gt;ReqlDriverError&lt;/code&gt;), query compilation (&lt;code&gt;ReqlCompileError&lt;/code&gt;) and runtime (errors subclassed from &lt;code&gt;ReqlRuntimeError&lt;/code&gt;).</source>
          <target state="translated">RethinkDB에는 드라이버 ( &lt;code&gt;ReqlDriverError&lt;/code&gt; ), 쿼리 컴파일 ( &lt;code&gt;ReqlCompileError&lt;/code&gt; ) 및 런타임 ( &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 에서 서브 클래 싱 된 오류) 의 세 가지 오류 클래스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7024546f8577c97b82e4aeda6e9841941adc8703" translate="yes" xml:space="preserve">
          <source>RethinkDB in two minutes</source>
          <target state="translated">2 분 만에 DB 재검토</target>
        </trans-unit>
        <trans-unit id="4eeea1cb9e84ccba67aa59483a4f622f2c06144f" translate="yes" xml:space="preserve">
          <source>RethinkDB inverts the traditional database architecture by exposing an exciting new access model &amp;ndash; instead of polling for changes, the developer can tell RethinkDB to continuously push updated query results to applications in realtime.</source>
          <target state="translated">RethinkDB는 변경에 대한 폴링 대신 흥미로운 새로운 액세스 모델을 제공함으로써 기존 데이터베이스 아키텍처를 뒤집습니다. 개발자는 RethinkDB에 업데이트 된 쿼리 결과를 실시간으로 애플리케이션에 지속적으로 푸시하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15b38cf885439fce391405265382c8fb3a5eddc" translate="yes" xml:space="preserve">
          <source>RethinkDB is running out of memory</source>
          <target state="translated">RethinkDB에 메모리가 부족합니다</target>
        </trans-unit>
        <trans-unit id="025c104640a27fcf19c9484f3ab6cf659bfa56be" translate="yes" xml:space="preserve">
          <source>RethinkDB keeps an internal directory tracking the current state of the cluster: how many servers are accessible, what data is currently stored on each server, etc. The data structures that keep track of the directory are automatically updated when the cluster changes. For example, if a server dies due to power failure, the directory is updated to represent this change.</source>
          <target state="translated">RethinkDB는 클러스터의 현재 상태를 추적하는 내부 디렉토리를 유지합니다. 액세스 가능한 서버 수, 각 서버에 현재 저장되어있는 데이터 등. 디렉토리를 추적하는 데이터 구조는 클러스터가 변경 될 때 자동으로 업데이트됩니다. 예를 들어, 정전으로 인해 서버가 사망하면이 변경 사항을 나타내도록 디렉토리가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9d083edb8c21c54d52f3036376df035b56b907" translate="yes" xml:space="preserve">
          <source>RethinkDB log will be &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt;</source>
          <target state="translated">RethinkDB 로그는 &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12e7e6962d9b0bc38ee3bb81801ab1841743fac0" translate="yes" xml:space="preserve">
          <source>RethinkDB maintains availability if the user increases or decreases the number of replicas in the cluster. In most cases, the replication process should not have a strong performance impact on the real-time system.</source>
          <target state="translated">사용자가 클러스터의 복제본 수를 늘리거나 줄이면 RethinkDB는 가용성을 유지합니다. 대부분의 경우 복제 프로세스가 실시간 시스템에 큰 성능 영향을 미치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="623536e8efae22fe8dbe6bff869831b8cb6a7ba8" translate="yes" xml:space="preserve">
          <source>RethinkDB makes building and scaling realtime apps dramatically easier. Get started by installing the server, and jump into our getting started guide to start building your first app in minutes.</source>
          <target state="translated">RethinkDB를 사용하면 실시간 앱을 쉽게 구축하고 확장 할 수 있습니다. 서버를 설치하여 시작하고 시작 안내서로 이동하여 몇 분 안에 첫 번째 앱 구축을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2e85a94c44575620e7b9601eb22bb2499c37e1fb" translate="yes" xml:space="preserve">
          <source>RethinkDB may or may not maintain availability if the user modifies the number of shards. In many cases availability will be maintained, but currently it cannot be guaranteed. We&amp;rsquo;re exploring different solutions to remove this limitation.</source>
          <target state="translated">사용자가 샤드 수를 수정하면 RethinkDB가 가용성을 유지하거나 유지하지 않을 수 있습니다. 대부분의 경우 가용성은 유지되지만 현재 보장 할 수는 없습니다. 우리는이 한계를 없애기 위해 다양한 솔루션을 모색하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d55b0820382b90b873c36c3282a6665c40558fe" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon. MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB는 ReQL에 해당하는 GeoJSON 객체 (Point, LineString 및 Polygon) 만 변환 할 수 있습니다. MultiPoint, MultiLineString 및 MultiPolygon은 지원되지 않습니다. 그러나 여러 점, 선 및 다각형을 배열에 저장하고 지리 공간 다중 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05eba76c1e3bf668992e43cbb82de3b220dab3cc" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon; MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB는 ReQL에 해당하는 GeoJSON 객체 (Point, LineString 및 Polygon) 만 변환 할 수 있습니다. MultiPoint, MultiLineString 및 MultiPolygon은 지원되지 않습니다. 그러나 여러 점, 선 및 다각형을 배열에 저장하고 지리 공간 다중 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8f4e6bd74894f0a648d341946431e0292b55f6" translate="yes" xml:space="preserve">
          <source>RethinkDB operates at peak performance when the batch size is around two hundred documents.</source>
          <target state="translated">배치 크기가 약 200 개의 문서 인 경우 RethinkDB는 최고의 성능으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="08ab91ee1258986387b10e654d9e4c5d42985b98" translate="yes" xml:space="preserve">
          <source>RethinkDB operations are never atomic across multiple keys. For this reason, RethinkDB cannot be considered an ACID database.</source>
          <target state="translated">RethinkDB 작업은 여러 키에 걸쳐 원자 적이 지 않습니다. 이러한 이유로 RethinkDB는 ACID 데이터베이스로 간주 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8741a43490c434407d3eb5b4660dc5f8849570f6" translate="yes" xml:space="preserve">
          <source>RethinkDB organizes data into blocks. Blocks in RethinkDB are sized in steps of 512 bytes up to a maximum of 4 KB. While the content of a block itself can be cleared from main memory to free space, metadata of approximately 10&amp;ndash;26 bytes per block is always kept in memory. Thus, this memory overhead is directly proportional to the number of blocks that a given data set requires. (This is in addition to the 8 MB overhead mentioned above.)</source>
          <target state="translated">RethinkDB는 데이터를 블록으로 구성합니다. RethinkDB의 블록 크기는 512 바이트 단위로 최대 4KB까지입니다. 블록 자체의 내용은 기본 메모리에서 여유 공간으로 지울 수 있지만 블록 당 약 10-26 바이트의 메타 데이터는 항상 메모리에 유지됩니다. 따라서이 메모리 오버 헤드는 주어진 데이터 세트에 필요한 블록 수에 정비례합니다. (이는 위에서 언급 한 8MB 오버 헤드에 추가됩니다.)</target>
        </trans-unit>
        <trans-unit id="b9269f54553fd9442463297c700ee2b8e73e7de2" translate="yes" xml:space="preserve">
          <source>RethinkDB packages automatically install an init script at &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; and add default run-level entries. For RethinkDB to automatically run on system startup, you&amp;rsquo;ll need to add a config file to &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 패키지는 &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; 에 init 스크립트를 자동으로 설치하고 기본 실행 레벨 항목을 추가합니다. 시스템 시작시 RethinkDB를 자동으로 실행하려면 &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt; 에 구성 파일을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7f008700c05c1865d12295437922484ecae3c18" translate="yes" xml:space="preserve">
          <source>RethinkDB provides a web interface which lets you manage your entire server cluster, from controlling sharding and replication to running ReQL queries (in JavaScript), with editing and history support. In addition, you can perform administration tasks using scriptable ReQL commands.</source>
          <target state="translated">RethinkDB는 편집 및 히스토리 지원을 통해 샤딩 및 복제 제어에서 JavaScript로 실행중인 ReQL 쿼리에 이르기까지 전체 서버 클러스터를 관리 할 수있는 웹 인터페이스를 제공합니다. 또한 스크립트 가능한 ReQL 명령을 사용하여 관리 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f7f159d2a79c214cc2f935797ab4190a4a3c1ee" translate="yes" xml:space="preserve">
          <source>RethinkDB provides an &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command for accessing external APIs directly from the database. Since many APIs accept and return JSON, RethinkDB is a convenient platform for manipulating and analyzing API data, both interactively and in running applications.</source>
          <target state="translated">RethinkDB는 데이터베이스에서 직접 외부 API에 액세스하기 위한 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; 명령을 제공 합니다. 많은 API가 JSON을 수락하고 반환하므로 RethinkDB는 대화식으로 또는 실행중인 응용 프로그램에서 API 데이터를 조작하고 분석하는 편리한 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="7f522c8137b2011dbb2715593ecd36021f7cbfe7" translate="yes" xml:space="preserve">
          <source>RethinkDB server</source>
          <target state="translated">RethinkDB 서버</target>
        </trans-unit>
        <trans-unit id="b74edfe769c267c7428c9983eb180ae400916f47" translate="yes" xml:space="preserve">
          <source>RethinkDB ships with simple tools to perform a hot backup of a running cluster. See the &lt;a href=&quot;../backup/index&quot;&gt;backup instructions&lt;/a&gt; for more details.</source>
          <target state="translated">RethinkDB는 실행중인 클러스터의 핫 백업을 수행하는 간단한 도구와 함께 제공됩니다. 자세한 내용은 &lt;a href=&quot;../backup/index&quot;&gt;백업 지침&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="84dcf0975c77e90cf88fc77f75f9af0d1107ebf5" translate="yes" xml:space="preserve">
          <source>RethinkDB supports &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, which allow you to subscribe to changes on a table. The database pushes these changes to you as they happen.</source>
          <target state="translated">RethinkDB 지원 &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; 당신이 테이블에 변화를 구독 할 수 있습니다. 데이터베이스는 이러한 변경 사항이 발생할 때이를 사용자에게 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="f539d29ec109400beb33e87944c1bc419991ee37" translate="yes" xml:space="preserve">
          <source>RethinkDB supports a native binary object type, letting you use ReQL to store binary objects directly in the database. The ReQL driver will transparently translate between the ReQL type and Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 기본 이진 객체 유형을 지원하므로 ReQL을 사용하여 이진 객체를 데이터베이스에 직접 저장할 수 있습니다. ReQL 드라이버는 ReQL 유형과 Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;버퍼&lt;/a&gt; 사이를 투명하게 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b79de0235d3d7e49d6270396cae554871735eba3" translate="yes" xml:space="preserve">
          <source>RethinkDB supports automatic failover when more than half of the voting replicas for each shard of a table are still available (see the &lt;a href=&quot;../../../docs/failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details). However, if half or more of the voting replicas for a shard are lost, failover will not happen automatically, leaving two options:</source>
          <target state="translated">RethinkDB는 테이블의 각 샤드에 대해 투표 복제본의 절반 이상을 계속 사용할 수있는 경우 자동 장애 조치를 지원합니다 (자세한 내용은 &lt;a href=&quot;../../../docs/failover/index&quot;&gt;장애 조치&lt;/a&gt; 설명서 참조). 그러나 샤드에 대한 투표 복제본 중 절반 이상이 손실되면 장애 조치가 자동으로 수행되지 않으므로 다음 두 가지 옵션이 남습니다.</target>
        </trans-unit>
        <trans-unit id="bc0a64248d0d6d9b7730531fe524793090fdf2c0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both secondary and compound indexes, as well as indexes that compute arbitrary expressions. You can see examples of how to use the secondary index API &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 2 차 및 복합 색인뿐만 아니라 임의의 표현식을 계산하는 색인을 모두 지원합니다. 보조 인덱스 API를 사용하는 방법의 예는 &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;여기&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71d8b68931056a0d66d312a06ccb2e2e6cb5d9a2" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both up-to-date and out-of-date reads. By default, all read queries are executed up-to-date, which means that every read operation for a given shard is routed to the primary replica for that shard and executed in order with other operations on the shard. In this default mode, the client always sees the latest, consistent, artifact-free view of the data.</source>
          <target state="translated">RethinkDB는 최신 및 최신 읽기를 모두 지원합니다. 기본적으로 모든 읽기 쿼리는 최신 상태로 실행되므로 지정된 샤드의 모든 읽기 작업이 해당 샤드의 기본 복제본으로 라우팅되고 샤드의 다른 작업과 순서대로 실행됩니다. 이 기본 모드에서 클라이언트는 항상 최신의 일관된 아티팩트없는 데이터보기를 봅니다.</target>
        </trans-unit>
        <trans-unit id="f11243238b91ef1b89680e4c273314a374928ae0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports different types of secondary indexes:</source>
          <target state="translated">RethinkDB는 다양한 유형의 보조 인덱스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="56794295c6dd1026fd6f7ec8b02775e58186eb63" translate="yes" xml:space="preserve">
          <source>RethinkDB supports most commonly used file systems. It optionally supports direct disk I/O for greater efficiency, but this is not enabled by default.</source>
          <target state="translated">RethinkDB는 가장 일반적으로 사용되는 파일 시스템을 지원합니다. 효율성을 높이기 위해 직접 디스크 I / O를 선택적으로 지원하지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="10e2f3eb29f4d8af581f7118e24c03dfdcd9a5d9" translate="yes" xml:space="preserve">
          <source>RethinkDB supports replication of data: every table in a database can be replicated as many times as you have servers in a cluster. Setting up replication is a simple operation with the web interface or the command line tool. For details, read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 데이터 복제를 지원합니다. 데이터베이스에있는 모든 테이블은 클러스터에 서버가있는 횟수만큼 복제 할 수 있습니다. 웹 인터페이스 또는 명령 줄 도구를 사용하여 복제를 간단하게 설정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cb54ac86a86c52460e890916d58c1288376ab8b" translate="yes" xml:space="preserve">
          <source>RethinkDB supports spatial and geographic queries through geometry object support.</source>
          <target state="translated">RethinkDB는 지오메트리 객체 지원을 통해 공간 및 지리적 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d32fa6ee6031165bb84247418c80028e7ab18532" translate="yes" xml:space="preserve">
          <source>RethinkDB supports the WGS84 World Geodetic System&amp;rsquo;s reference ellipsoid and geographic coordinate system (GCS). It does not directly support any projected coordinate system (PCS), but there are many tools available for performing such projections.</source>
          <target state="translated">RethinkDB는 WGS84 World Geodetic System의 참조 타원체 및 지리 좌표계 (GCS)를 지원합니다. PCS (Projected Coordinate System)를 직접 지원하지는 않지만 이러한 투영을 수행하는 데 사용할 수있는 많은 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c7488acfc62299ace979066c1e3f08638dfc5c" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a range sharding algorithm parameterized on the table&amp;rsquo;s primary key to partition the data. When the user states they want a given table to use a certain number of shards, the system examines the statistics for the table and finds the optimal set of split points to break up the table evenly. All sharding is currently done based on the table&amp;rsquo;s primary key, and cannot be done based on any other attribute (in RethinkDB the primary key and the shard key are effectively the same thing).</source>
          <target state="translated">RethinkDB는 테이블의 기본 키에 매개 변수화 된 범위 샤딩 알고리즘을 사용하여 데이터를 분할합니다. 사용자가 특정 테이블에서 특정 개수의 샤드를 사용하도록하려면 시스템이 테이블에 대한 통계를 검사하고 테이블을 균등하게 분할 할 최적의 분할 지점을 찾습니다. 모든 샤딩은 현재 테이블의 기본 키를 기반으로 수행되며 다른 속성을 기반으로 수행 할 수 없습니다 (RethinkDB에서는 기본 키와 샤드 키가 사실상 동일 함).</target>
        </trans-unit>
        <trans-unit id="5f2b0afa489f326033447882c4ce512558bc7c6f" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a safe default configuration for write acknowledgement. Each write is committed to disk before the server acknowledges it to the client. If you&amp;rsquo;re running a single thread that inserts documents into RethinkDB in a loop, each insert must wait for the server acknowledgement before proceeding to the next one. This can significantly slow down the overall throughput.</source>
          <target state="translated">RethinkDB는 쓰기 승인을 위해 안전한 기본 구성을 사용합니다. 서버가 클라이언트에 승인하기 전에 각 쓰기는 디스크에 커밋됩니다. 루프에서 RethinkDB에 문서를 삽입하는 단일 스레드를 실행하는 경우 각 삽입은 다음 승인을 진행하기 전에 서버 승인을 기다려야합니다. 이로 인해 전체 처리량이 크게 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d7ed56e064cdc2be5c3c306b0a024e244f7da3" translate="yes" xml:space="preserve">
          <source>RethinkDB uses byte-wise ordering for &lt;code&gt;between&lt;/code&gt; and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;between&lt;/code&gt; 바이트 단위 순서를 사용하며 유니 코드 데이터 정렬을 지원하지 않습니다. 비 ASCII 문자는 UTF-8 코드 포인트로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b7492bd98ab8c96ed190967271aac8f2b9a308" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft algorithm&lt;/a&gt; to store and propagate cluster configuration in most cases, although there are some situations it uses semilattices, versioned with internal timestamps. This architecture turns out to have sufficient mathematical properties to address all the issues mentioned above (this result has been known in distributed systems research for quite a while).</source>
          <target state="translated">RethinkDB는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft 알고리즘&lt;/a&gt; 을 사용하여 대부분의 경우 클러스터 구성을 저장 및 전파하지만 내부 타임 스탬프 버전의 반격 자를 사용하는 경우도 있습니다. 이 아키텍처는 위에서 언급 한 모든 문제를 해결하기에 충분한 수학적 특성을 갖는 것으로 판명되었습니다 (이 결과는 분산 시스템 연구에서 꽤 오랫동안 알려졌습니다).</target>
        </trans-unit>
        <trans-unit id="ad9e86f0c36323e6c20f0c976359840d640f76c9" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the same protocol for communication within a datacenter as it does across datacenters. Because the architecture is immediately consistent and does not require quorums on individual document reads and writes, the latency issues commonly associated with cross-datacenter quorums on Dynamo-style systems do not arise in RethinkDB.</source>
          <target state="translated">RethinkDB는 데이터 센터 내에서와 동일한 데이터 프로토콜 내 통신에 동일한 프로토콜을 사용합니다. 아키텍처는 즉시 일관성이 있으며 개별 문서 읽기 및 쓰기에서 쿼럼이 필요하지 않기 때문에 RethinkDB에서는 Dynamo 스타일 시스템의 교차 데이터 센터 쿼럼과 일반적으로 관련된 대기 시간 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e113a38cea5f70d16b5f974ca8331179248d2d4" translate="yes" xml:space="preserve">
          <source>RethinkDB uses three ports to operate&amp;mdash;the HTTP web UI port, the client drivers port, and the intracluster traffic port. You can connect the browser to the web UI port to administer the cluster right from your browser, and connect the client drivers to the client driver port to run queries from your application. If you&amp;rsquo;re running a cluster, different RethinkDB nodes communicate with each other via the intracluster traffic port.</source>
          <target state="translated">RethinkDB는 HTTP 웹 UI 포트, 클라이언트 드라이버 포트 및 클러스터 내 트래픽 포트의 세 가지 포트를 사용하여 작동합니다. 브라우저를 웹 UI 포트에 연결하여 브라우저에서 바로 클러스터를 관리하고 클라이언트 드라이버를 클라이언트 드라이버 포트에 연결하여 응용 프로그램에서 쿼리를 실행할 수 있습니다. 클러스터를 실행중인 경우 다른 RethinkDB 노드는 클러스터 내 트래픽 포트를 통해 서로 통신합니다.</target>
        </trans-unit>
        <trans-unit id="82c73af11c06078443ac96c46a3ff491a24f303f" translate="yes" xml:space="preserve">
          <source>RethinkDB version 2.1.5</source>
          <target state="translated">RethinkDB 버전 2.1.5</target>
        </trans-unit>
        <trans-unit id="64be170039b96e0579e9278dd905f8db6230488d" translate="yes" xml:space="preserve">
          <source>RethinkDB will accept two formats for JSON files:</source>
          <target state="translated">RethinkDB는 JSON 파일에 대해 두 가지 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1b3f223b9bb1750bce96d8634333989e0ebc07d7" translate="yes" xml:space="preserve">
          <source>RethinkDB will automatically load on startup. To disable this behavior, change the &lt;code&gt;RunAtLoad&lt;/code&gt; key to &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; in the &lt;code&gt;plist&lt;/code&gt; file.</source>
          <target state="translated">RethinkDB는 시작시 자동으로로드됩니다. 이 동작을 비활성화하려면 &lt;code&gt;plist&lt;/code&gt; 파일 에서 &lt;code&gt;RunAtLoad&lt;/code&gt; 키를 &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; 로 변경 하십시오.</target>
        </trans-unit>
        <trans-unit id="188b67359aa222e3ea9d29fed4e862f6d351f160" translate="yes" xml:space="preserve">
          <source>RethinkDB will generate a primary key and return it in &lt;code&gt;generated_keys&lt;/code&gt;.</source>
          <target state="translated">RethinkDB는 기본 키를 생성하고 그것에서 돌아 &lt;code&gt;generated_keys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7af94097e441aba69be3324247352a59b9643a" translate="yes" xml:space="preserve">
          <source>RethinkDB will notify your program of all changes in the &lt;code&gt;authors&lt;/code&gt; table and will include the old value and the new value of each modified document. See the &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; documentation entry for more details on how to use realtime feeds in RethinkDB.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;authors&lt;/code&gt; 테이블 의 모든 변경 사항을 프로그램에 알리고 수정 된 각 문서의 이전 값과 새 값을 포함합니다. &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;RethinkDB&lt;/a&gt; 에서 실시간 피드를 사용하는 방법에 대한 자세한 내용 은 changefeeds 문서 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f968cad894d6556a053a28efbaa35e8a48e757e7" translate="yes" xml:space="preserve">
          <source>RethinkDB will process this query with the following steps:</source>
          <target state="translated">RethinkDB는 다음 단계로이 쿼리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="64b9b5257d87ef3a851f521694a7f625e0295a7e" translate="yes" xml:space="preserve">
          <source>RethinkDB will seamlessly evaluate the &lt;code&gt;js&lt;/code&gt; command by calling into the V8 engine during the evaluation of the &lt;code&gt;filter&lt;/code&gt; query. You can combine most queries this way into progressively more complex ones.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;filter&lt;/code&gt; 쿼리를 평가하는 동안 V8 엔진을 호출 하여 &lt;code&gt;js&lt;/code&gt; 명령을 원활하게 평가합니다 . 이 방법으로 대부분의 쿼리를 점진적으로 더 복잡한 쿼리로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa0bfa56109a4dcf6840553fb0b62be795519d3" translate="yes" xml:space="preserve">
          <source>RethinkDB write operations will only throw exceptions if errors occur before any writes. Other errors will be listed in &lt;code&gt;first_error&lt;/code&gt;, and &lt;code&gt;errors&lt;/code&gt; will be set to a non-zero count. To properly handle errors with this term, code must both handle exceptions and check the &lt;code&gt;errors&lt;/code&gt; return value!</source>
          <target state="translated">RethinkDB 쓰기 작업은 쓰기 전에 오류가 발생한 경우에만 예외를 발생시킵니다. 다른 오류는 &lt;code&gt;first_error&lt;/code&gt; 에 나열 되고 &lt;code&gt;errors&lt;/code&gt; 는 0이 아닌 수로 설정됩니다. 이 용어로 오류를 올바르게 처리하려면 코드에서 예외를 처리하고 &lt;code&gt;errors&lt;/code&gt; 반환 값을 확인해야합니다 !</target>
        </trans-unit>
        <trans-unit id="34e087373ce7adace20d25fd88b9372fbefa4968" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s GMR queries are distributed and parallelized across shards and CPU cores whenever possible. While this allows them to execute efficiently, it&amp;rsquo;s important to keep in mind that the &lt;code&gt;reduce&lt;/code&gt; function is &lt;em&gt;not&lt;/em&gt; called on the elements of its input stream from left to right. It&amp;rsquo;s called on either the elements of the stream &lt;em&gt;in any order&lt;/em&gt; or on the output of previous calls to the function.</source>
          <target state="translated">RethinkDB의 GMR 쿼리는 가능할 때마다 샤드 및 CPU 코어에 분산되고 병렬화됩니다. 이렇게하면 효율적으로 실행할 수 있지만 입력 스트림의 요소에서 왼쪽에서 오른쪽으로 &lt;code&gt;reduce&lt;/code&gt; 기능이 호출 &lt;em&gt;되지 않는다는&lt;/em&gt; 점을 명심해야합니다 . 스트림의 요소 &lt;em&gt;에서 순서에 관계없이&lt;/em&gt; 호출되거나 함수에 대한 이전 호출의 출력에서 ​​호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b133a4402124e33904942b046a7e475fcf7c87c8" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s UUIDs are standards-compliant. Without the optional argument, a version 4 random UUID will be generated; with that argument, a version 5 UUID will be generated, using a fixed namespace UUID of &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt;. For more information, read &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia&amp;rsquo;s UUID article&lt;/a&gt;.</source>
          <target state="translated">RethinkDB의 UUID는 표준을 준수합니다. 선택적 인수가 없으면 버전 4 임의 UUID가 생성됩니다. 이 인수를 사용하면 고정 네임 스페이스 UUID &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt; 을 사용하여 버전 5 UUID가 생성됩니다 . 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia의 UUID 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0da7bfd7ba58030ff21673f3096c2d4399c90c10" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s automatic failover has limitations in cases of non-transitive connectivity failure, i.e., server A can contact B and B can contact C, but A cannot contact C. Read the &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details.</source>
          <target state="translated">RethinkDB의 자동 장애 조치 (failover)에는 전이가 아닌 연결 실패의 경우 제한이 있습니다. 즉, 서버 A는 B에 연결할 수 있고 B는 C에 연결할 수 있지만 A는 C에 연결할 수 없습니다 . 자세한 내용 은 &lt;a href=&quot;../failover/index&quot;&gt;장애 조치&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1fe8ed60518c4cc231f66de64be6b6b14e157f1" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s basic data types include numbers, strings, boolean values, objects, arrays, and the &lt;code&gt;null&lt;/code&gt; value. In addition, it stores RethinkDB-specific data types including tables, streams, selections, binary objects, time objects, geometry data types, and grouped data.</source>
          <target state="translated">RethinkDB의 기본 데이터 유형에는 숫자, 문자열, 부울 값, 객체, 배열 및 &lt;code&gt;null&lt;/code&gt; 값이 포함됩니다. 또한 테이블, 스트림, 선택, 이진 객체, 시간 객체, 지오메트리 데이터 유형 및 그룹화 된 데이터를 포함한 RethinkDB 관련 데이터 유형을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0ca7a8d234327a4022cad363f1285f21bac0f144" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s default settings prioritize safety over performance, except in one case: &lt;code&gt;read_mode&lt;/code&gt; defaults to &lt;code&gt;single&lt;/code&gt; rather than &lt;code&gt;majority&lt;/code&gt;. The &lt;code&gt;majority&lt;/code&gt; read mode requires sending a query to all of the replicas and waiting for a majority to reply, which significantly degrades performance.</source>
          <target state="translated">RethinkDB의 기본 설정은 한 가지 경우를 제외하고 성능보다 안전을 우선시합니다. &lt;code&gt;read_mode&lt;/code&gt; 의 기본값 은 &lt;code&gt;majority&lt;/code&gt; 아닌 &lt;code&gt;single&lt;/code&gt; 입니다. &lt;code&gt;majority&lt;/code&gt; 읽기 모드는 모든 복제본에 쿼리를 전송하고 대부분의 성능이 크게 저하하는 회신을 기다리고 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb2f37e7edacabf1482154290f8348ef4776073d" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s defaults tend to prioritize safety over performance. One of those defaults is that queries will be sent to the primary replicas for shards, which will always have current data (although that data may be returned to a query before it&amp;rsquo;s been committed to disk).</source>
          <target state="translated">RethinkDB의 기본값은 성능보다 안전을 우선시하는 경향이 있습니다. 이러한 기본값 중 하나는 쿼리가 샤드의 기본 복제본으로 전송되며 항상 최신 데이터를 갖습니다 (데이터는 디스크에 커밋되기 전에 쿼리로 반환 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="db4c9426f43aa7a8535f8d64ebcc1ea7e3791bc5" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s page cache keeps recently used data in memory to minimize disk access. By default, RethinkDB automatically configures the cache size limit according to the formula &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt;. &lt;code&gt;available_mem&lt;/code&gt; is the amount of available memory at the time RethinkDB starts, including memory that can be freed up by the operating system if needed (such as the operating system&amp;rsquo;s disk cache). If there is less than 1224 MB of memory available on the system, a minimum cache size limit of 100 MB is used. You can find the actual size limit used by an instance of RethinkDB in its log.</source>
          <target state="translated">RethinkDB의 페이지 캐시는 최근에 사용한 데이터를 메모리에 보관하여 디스크 액세스를 최소화합니다. 기본적으로 RethinkDB는 공식 &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt; 에 따라 캐시 크기 제한을 자동으로 구성합니다 . &lt;code&gt;available_mem&lt;/code&gt; 은 필요한 경우 운영 체제의 디스크 캐시와 같이 운영 체제에서 사용 가능한 메모리를 포함하여 RethinkDB가 시작될 때 사용 가능한 메모리의 양입니다. 시스템에 사용 가능한 1224MB 미만의 메모리가 있으면 최소 캐시 크기 제한 100MB가 사용됩니다. 로그에서 RethinkDB 인스턴스가 사용하는 실제 크기 제한을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653b9779dde232052144d040476ebeef4a8dcaaa" translate="yes" xml:space="preserve">
          <source>RethinkDB-specific data types</source>
          <target state="translated">DB 별 데이터 유형 재검토</target>
        </trans-unit>
        <trans-unit id="57354ca1c1a9aab463d86135427b774bc928dbcc" translate="yes" xml:space="preserve">
          <source>Retrieve all results and pass them as an array to the given callback.</source>
          <target state="translated">모든 결과를 검색하여 주어진 콜백에 배열로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a0800d22e7dc2655702fc5c45eb8eba5b2a4d42c" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), and who do not have a middle name.</source>
          <target state="translated">이름이 &quot;William Adama&quot;(이름은 &quot;William&quot;, 성은 &quot;Adama&quot;)이고 중간 이름이없는 모든 사용자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="cec1adbb3f9ef3982a4b34f750d9645287ab990d" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), with any middle name.</source>
          <target state="translated">이름이&amp;ldquo;William Adama&amp;rdquo;(이름은&amp;ldquo;William&amp;rdquo;, 성은&amp;ldquo;Adama&amp;rdquo;) 인 모든 사용자를 중간 이름으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="237e5c73e5953045fa795163933e9ed9332088b6" translate="yes" xml:space="preserve">
          <source>Retrieve all users whose field &lt;code&gt;placesVisited&lt;/code&gt; contains &lt;code&gt;France&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;placesVisited&lt;/code&gt; 에 &lt;code&gt;France&lt;/code&gt; 가 포함 된 모든 사용자를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d4b04dce1b7df968174efc9d7f0fa1e97e4f76c" translate="yes" xml:space="preserve">
          <source>Retrieve all users whose name is &amp;ldquo;William&amp;rdquo; (case insensitive).</source>
          <target state="translated">이름이 &quot;William&quot;(대소 문자를 구분하지 않음) 인 모든 사용자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="144e062a80d5bfa018aedb28a373c2819db9d43b" translate="yes" xml:space="preserve">
          <source>Retrieve data from the specified URL over HTTP. The return type depends on the &lt;code&gt;resultFormat&lt;/code&gt; option, which checks the &lt;code&gt;Content-Type&lt;/code&gt; of the response by default.</source>
          <target state="translated">HTTP를 통해 지정된 URL에서 데이터를 검색하십시오. 리턴 유형은 기본적으로 응답 의 &lt;code&gt;Content-Type&lt;/code&gt; 을 확인 하는 &lt;code&gt;resultFormat&lt;/code&gt; 옵션 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="211aca45f30753de118f273f7b269e7e4499fd62" translate="yes" xml:space="preserve">
          <source>Retrieve documents</source>
          <target state="translated">문서 검색</target>
        </trans-unit>
        <trans-unit id="3b22bfa4b5202554454b9ce9093ae3ce1ea8220d" translate="yes" xml:space="preserve">
          <source>Retrieve documents by primary key</source>
          <target state="translated">기본 키로 문서 검색</target>
        </trans-unit>
        <trans-unit id="7544efd784c58b3cc6b94510160698abf4204cdf" translate="yes" xml:space="preserve">
          <source>Retrieve the document you just inserted with:</source>
          <target state="translated">방금 삽입 한 문서를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7383fa3693e7f98d7e2271113002f8270dbf24" translate="yes" xml:space="preserve">
          <source>Retrieving all the objects in a stream (cursor) as an array</source>
          <target state="translated">스트림 (커서)의 모든 객체를 배열로 검색</target>
        </trans-unit>
        <trans-unit id="d3381e3b339f22ad2879bc207700fcde0bfd99cc" translate="yes" xml:space="preserve">
          <source>Retrieving documents</source>
          <target state="translated">문서 검색</target>
        </trans-unit>
        <trans-unit id="96da5941680a83531c9d9d6e650a067fcf591587" translate="yes" xml:space="preserve">
          <source>Retrieving portions of times</source>
          <target state="translated">시간의 일부를 검색</target>
        </trans-unit>
        <trans-unit id="095d7a5343b62a81ee9712b14cf269156fe7c534" translate="yes" xml:space="preserve">
          <source>Retrieving times</source>
          <target state="translated">시간 검색</target>
        </trans-unit>
        <trans-unit id="1ac0fc4ed2e5cad9e59397ea987188f54b8218a4" translate="yes" xml:space="preserve">
          <source>Return a UUID (universally unique identifier), a string that can be used as a unique ID. If a string is passed to &lt;code&gt;uuid&lt;/code&gt; as an argument, the UUID will be deterministic, derived from the string&amp;rsquo;s SHA-1 hash.</source>
          <target state="translated">고유 한 ID로 사용할 수있는 문자열 인 UUID (일반적으로 고유 한 식별자)를 반환합니다. 문자열이 인수 로 &lt;code&gt;uuid&lt;/code&gt; 에 전달 되면 UUID는 문자열의 SHA-1 해시에서 파생 된 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="ffd17e2071ddb0546ffd90d50675a3881fba96ef" translate="yes" xml:space="preserve">
          <source>Return a list of documents closest to a specified point based on a geospatial index, sorted in order of increasing distance.</source>
          <target state="translated">거리가 증가하는 순서로 정렬 된 지리 공간 인덱스를 기반으로 지정된 지점에 가장 가까운 문서 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f63b091983357380f1a69b1dfe84c2c468192c7" translate="yes" xml:space="preserve">
          <source>Return a new time object only based on the day, month and year (ie. the same day at 00:00).</source>
          <target state="translated">일, 월 및 연도를 기준으로 만 새 시간 개체를 반환합니다 (예 : 같은 날 00:00).</target>
        </trans-unit>
        <trans-unit id="015c5dd378cc34e946f70fe5920eef6871ab879c" translate="yes" xml:space="preserve">
          <source>Return a new time object with a different timezone. While the time stays the same, the results returned by methods such as hours() will change since they take the timezone into account. The timezone argument has to be of the ISO 8601 format.</source>
          <target state="translated">시간대가 다른 새 시간 객체를 반환합니다. 시간은 동일하게 유지되지만 hours ()와 같은 메소드가 리턴 한 결과는 시간대를 고려하므로 변경됩니다. 시간대 인수는 ISO 8601 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c41bbd84134669b7c1a4ef8c089acb5a464d383" translate="yes" xml:space="preserve">
          <source>Return a time object representing the current time in UTC. The command now() is computed once when the server receives the query, so multiple instances of r.now() will always return the same time inside a query.</source>
          <target state="translated">현재 시간을 나타내는 시간 객체를 UTC로 반환합니다. now () 명령은 서버가 쿼리를받을 때 한 번 계산되므로 r.now ()의 여러 인스턴스는 항상 쿼리 내에서 같은 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bf7e4e063eddc8455a8c8c1c7dcbd9e564f26eb" translate="yes" xml:space="preserve">
          <source>Return all documents in a table. Other commands may be chained after &lt;code&gt;table&lt;/code&gt; to return a subset of documents (such as &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;) or perform further processing.</source>
          <target state="translated">테이블에있는 모든 문서를 반환하십시오. 다른 명령은 &lt;code&gt;table&lt;/code&gt; 뒤에 연결 되어 문서의 서브 세트 (예 : &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; 및 &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt; ) 를 리턴 하거나 추가 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb807193ee6de63e427d7ed0d8324b9c3c3b591" translate="yes" xml:space="preserve">
          <source>Return all documents in a table. Other commands may be chained after &lt;code&gt;table&lt;/code&gt; to return a subset of documents (such as &lt;a href=&quot;get/index&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;) or perform further processing.</source>
          <target state="translated">테이블에있는 모든 문서를 반환하십시오. 다른 명령은 &lt;code&gt;table&lt;/code&gt; 뒤에 연결 되어 문서의 서브 세트 (예 : &lt;a href=&quot;get/index&quot;&gt;get&lt;/a&gt; 및 &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt; ) 를 리턴 하거나 추가 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478ae85b5976cf44bf341f6ea047a3fc9cec6987" translate="yes" xml:space="preserve">
          <source>Return all the elements in a sequence for which the given predicate is true. The return value of &lt;code&gt;filter&lt;/code&gt; will be the same as the input (sequence, stream, or array). Documents can be filtered in a variety of ways&amp;mdash;ranges, nested values, boolean conditions, and the results of anonymous functions.</source>
          <target state="translated">주어진 술어가 참인 순서로 모든 요소를 ​​리턴합니다. &lt;code&gt;filter&lt;/code&gt; 의 반환 값은 입력 (시퀀스, 스트림 또는 배열)과 같습니다. 범위, 중첩 값, 부울 조건 및 익명 함수의 결과와 같은 다양한 방법으로 문서를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f61e9b869f88502f4aea0e59d05d2b3e56538f" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s keys. Note that the keys will be sorted as described in &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt; (for strings, lexicographically).</source>
          <target state="translated">객체의 모든 키를 포함하는 배열을 반환합니다. 키는 &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; (문자열의 경우 사전 식)에 설명 된대로 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="e70c431aef04b9c7b45e841c2755e0962bdd3716" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s keys. Note that the keys will be sorted as described in &lt;a href=&quot;../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt; (for strings, lexicographically).</source>
          <target state="translated">객체의 모든 키를 포함하는 배열을 반환합니다. 키는 &lt;a href=&quot;../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; (문자열의 경우 사전 식)에 설명 된대로 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3730aaaa8f1bbcef6b27cf753e5ef734ef1890e" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s values. &lt;code&gt;values()&lt;/code&gt; guarantees the values will come out in the same order as &lt;a href=&quot;../keys/index&quot;&gt;keys&lt;/a&gt;.</source>
          <target state="translated">객체의 모든 값을 포함하는 배열을 반환합니다. &lt;code&gt;values()&lt;/code&gt; 는 값이 &lt;a href=&quot;../keys/index&quot;&gt;keys&lt;/a&gt; 와 동일한 순서로 나오도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="971118c553d2907361131e3449a1a6ec52645842" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s values. &lt;code&gt;values()&lt;/code&gt; guarantees the values will come out in the same order as &lt;a href=&quot;keys/index&quot;&gt;keys&lt;/a&gt;.</source>
          <target state="translated">객체의 모든 값을 포함하는 배열을 반환합니다. &lt;code&gt;values()&lt;/code&gt; 는 값이 &lt;a href=&quot;keys/index&quot;&gt;keys&lt;/a&gt; 와 동일한 순서로 나오도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="56bffb13073f7f91d3bc50303093a5720e9d1b1e" translate="yes" xml:space="preserve">
          <source>Return information about the server being used by a connection.</source>
          <target state="translated">연결에 사용중인 서버에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1b11d0437587617248352faf5ad14320b9e0e72" translate="yes" xml:space="preserve">
          <source>Return players who have the &amp;ldquo;championships&amp;rdquo; field.</source>
          <target state="translated">&quot;챔피언 쉽&quot;필드를 가진 플레이어를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="9572f90ef4a18b691f067965a76e794f55e11c57" translate="yes" xml:space="preserve">
          <source>Return the day of a time object as a number between 1 and 31.</source>
          <target state="translated">시간 개체의 요일을 1에서 31 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="439ddcb82ceaaca4c171019c2f4cb98b13d31d24" translate="yes" xml:space="preserve">
          <source>Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).</source>
          <target state="translated">시간 개체의 일을 1과 366 사이의 숫자로 반환합니다 (ISO 8601 표준에 따름).</target>
        </trans-unit>
        <trans-unit id="519ae8ae909a6a02ab7b4e9a29c2f7526e688760" translate="yes" xml:space="preserve">
          <source>Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard). For your convenience, the terms r.monday, r.tuesday etc. are defined and map to the appropriate integer.</source>
          <target state="translated">시간 객체의 요일을 1과 7 사이의 숫자로 반환합니다 (ISO 8601 표준에 따름). 편의상 r.monday, r.tuesday 등의 용어가 정의되어 적절한 정수로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d4ed5fd76817542a76355cd4b4f991608b7c9797" translate="yes" xml:space="preserve">
          <source>Return the elements of a sequence within the specified range.</source>
          <target state="translated">지정된 범위 내에서 시퀀스의 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2d16cca3af2640562e11239c5e1cb70f24e2040" translate="yes" xml:space="preserve">
          <source>Return the hour in a time object as a number between 0 and 23.</source>
          <target state="translated">시간 개체의 시간을 0과 23 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a27edb7435efd0748ac618d8f95b6d80fc2510a" translate="yes" xml:space="preserve">
          <source>Return the maximum number comments per post.</source>
          <target state="translated">게시물 당 최대 댓글 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f0c62205fb575cc337651b85a3c80c4c42e9b98" translate="yes" xml:space="preserve">
          <source>Return the minute in a time object as a number between 0 and 59.</source>
          <target state="translated">시간 개체의 분을 0과 59 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b204d98d48eba1077a862d07b71af3333275043c" translate="yes" xml:space="preserve">
          <source>Return the month of a time object as a number between 1 and 12. For your convenience, the terms r.january, r.february etc. are defined and map to the appropriate integer.</source>
          <target state="translated">시간 개체의 월을 1과 12 사이의 숫자로 반환합니다. 편의상 r.january, r.february 등의 용어가 정의되어 적절한 정수로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="7c290219ba6cddea6fd8ee62f62fd68fb04cbe8e" translate="yes" xml:space="preserve">
          <source>Return the number of comments for all posts.</source>
          <target state="translated">모든 게시물에 대한 댓글 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e316ab849a4c0fd165af196f49cfa9c7888f04b2" translate="yes" xml:space="preserve">
          <source>Return the number of seconds elapsed since the beginning of the day stored in the time object.</source>
          <target state="translated">시간 객체에 저장된 하루의 시작 이후 경과 된 시간 (초)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c308fc928c3ca38906101a5971935fa2b23267d8" translate="yes" xml:space="preserve">
          <source>Return the seconds in a time object as a number between 0 and 59.999 (double precision).</source>
          <target state="translated">시간 개체의 초를 0과 59.999 (배정 밀도) 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ca2261d31fada3154fe610f41e3f36f34f50104" translate="yes" xml:space="preserve">
          <source>Return the status of a table.</source>
          <target state="translated">테이블의 상태를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="ee8f6ace073116dd4cee2823f8ec775a63ec6e3c" translate="yes" xml:space="preserve">
          <source>Return the timezone of the time object.</source>
          <target state="translated">시간 객체의 시간대를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a16f2cc87a2424696c4c7c72d81f1b8443ca04e0" translate="yes" xml:space="preserve">
          <source>Return the year of a time object.</source>
          <target state="translated">시간 객체의 연도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7251e5ca9210a35e0349f287619f236690248620" translate="yes" xml:space="preserve">
          <source>Return whether a time is between two other times.</source>
          <target state="translated">시간이 다른 두 시간 사이인지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7df890bcefe8759cfa2f24768eb854401e46e8ce" translate="yes" xml:space="preserve">
          <source>Returning a ReQL query as a string</source>
          <target state="translated">ReQL 쿼리를 문자열로 반환</target>
        </trans-unit>
        <trans-unit id="6549cc77b11e26ba920d62def1da169519c38689" translate="yes" xml:space="preserve">
          <source>Returning specific fields of a document</source>
          <target state="translated">문서의 특정 필드 반환</target>
        </trans-unit>
        <trans-unit id="97c5eeaf29f67ee72247c15972aaba739a353910" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;&quot;SELECTION&amp;lt;OBJECT&amp;gt;&quot;&lt;/code&gt;. (Yes, the type of the &lt;code&gt;typeOf&lt;/code&gt; command is &lt;code&gt;&quot;STRING&quot;&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;&quot;SELECTION&amp;lt;OBJECT&amp;gt;&quot;&lt;/code&gt; 리턴합니다 . (예, &lt;code&gt;typeOf&lt;/code&gt; 명령 의 유형 은 &lt;code&gt;&quot;STRING&quot;&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="14fe7627b67a0185a8f04483dd7d16235707fb12" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;'domain.com'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'domain.com'&lt;/code&gt; 을 반환합니다</target>
        </trans-unit>
        <trans-unit id="643e18161845e0ecb05d553ae30ebf927d10f3ce" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;0&lt;/code&gt; when called on an empty sequence.</source>
          <target state="translated">빈 시퀀스에서 호출되면 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c46d32827e2a7131ff1d77a2f7291e55fe3cc2c1" translate="yes" xml:space="preserve">
          <source>Returns a left outer join of two sequences. The returned sequence represents a union of the left-hand sequence and the right-hand sequence: all documents in the left-hand sequence will be returned, each matched with a document in the right-hand sequence if one satisfies the predicate condition. In most cases, you will want to follow the join with &lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt; to combine the left and right results.</source>
          <target state="translated">두 시퀀스의 왼쪽 외부 조인을 반환합니다. 리턴 된 순서는 왼쪽 순서와 오른쪽 순서의 결합을 나타냅니다. 왼쪽 순서의 모든 문서가 리턴되며, 조건 조건을 만족하는 경우 각각 오른쪽 순서의 문서와 일치합니다. 대부분의 경우 왼쪽 및 오른쪽 결과를 결합하기 위해 &lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt; 으로 조인을 따르고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ab1565069e4a0e57be6a5a52da760fcbbfc29ef0" translate="yes" xml:space="preserve">
          <source>Returns a left outer join of two sequences. The returned sequence represents a union of the left-hand sequence and the right-hand sequence: all documents in the left-hand sequence will be returned, each matched with a document in the right-hand sequence if one satisfies the predicate condition. In most cases, you will want to follow the join with &lt;a href=&quot;zip/index&quot;&gt;zip&lt;/a&gt; to combine the left and right results.</source>
          <target state="translated">두 시퀀스의 왼쪽 외부 조인을 반환합니다. 리턴 된 순서는 왼쪽 순서와 오른쪽 순서의 결합을 나타냅니다. 왼쪽 순서의 모든 문서가 리턴되며, 조건 조건을 만족하는 경우 각각 오른쪽 순서의 문서와 일치합니다. 대부분의 경우 왼쪽 및 오른쪽 결과를 결합하기 위해 &lt;a href=&quot;zip/index&quot;&gt;zip&lt;/a&gt; 으로 조인을 따르고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="71e616c4f0779291525e7a3daecba278fcf11b08" translate="yes" xml:space="preserve">
          <source>Returns an inner join of two sequences.</source>
          <target state="translated">두 시퀀스의 내부 조인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c830f78dec23684142dbe486cecbd1eb26631348" translate="yes" xml:space="preserve">
          <source>Returns the currently visited document.</source>
          <target state="translated">현재 방문한 문서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63c93a91670215210d58774851527a985d56583c" translate="yes" xml:space="preserve">
          <source>Returns the following result:</source>
          <target state="translated">다음 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3243ea249cfe8eb0c3119088a6a8fe5d63da9ba4" translate="yes" xml:space="preserve">
          <source>Rich command-set</source>
          <target state="translated">풍부한 명령 세트</target>
        </trans-unit>
        <trans-unit id="57223975ae6497ffb734052c257297523d6a53df" translate="yes" xml:space="preserve">
          <source>Rounds the given value down, returning the largest integer value less than or equal to the given value (the value&amp;rsquo;s floor).</source>
          <target state="translated">주어진 값을 내림하고 주어진 값 (값의 바닥)보다 작거나 같은 가장 큰 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1055a67da6f244655ae05b937e997675ab32f267" translate="yes" xml:space="preserve">
          <source>Rounds the given value to the nearest whole integer.</source>
          <target state="translated">주어진 값을 가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="42e7a006f535f03176759ec87c52257b285ebc2f" translate="yes" xml:space="preserve">
          <source>Rounds the given value up, returning the smallest integer value greater than or equal to the given value (the value&amp;rsquo;s ceiling).</source>
          <target state="translated">주어진 값을 반올림하여 주어진 값보다 크거나 같은 가장 작은 정수 값 (값의 상한)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b217e98c3bf70f3cf4633a5447d6587eea974ba1" translate="yes" xml:space="preserve">
          <source>Ruby</source>
          <target state="translated">Ruby</target>
        </trans-unit>
        <trans-unit id="91667aa4fbc722508d6b30787e8e791fb64f62f5" translate="yes" xml:space="preserve">
          <source>Ruby driver</source>
          <target state="translated">루비 드라이버</target>
        </trans-unit>
        <trans-unit id="b853e9265c2ef8705439ae2bf2b5eaf811a08fef" translate="yes" xml:space="preserve">
          <source>Ruby libraries</source>
          <target state="translated">루비 라이브러리</target>
        </trans-unit>
        <trans-unit id="73569b1cb680b4a4ed18b11d5df9a172d7172552" translate="yes" xml:space="preserve">
          <source>Ruby with EventMachine</source>
          <target state="translated">EventMachine을 사용한 루비</target>
        </trans-unit>
        <trans-unit id="079aca0608b19eda84bb36e7a085f9aa4e9ee427" translate="yes" xml:space="preserve">
          <source>Run a query on a connection. The callback will get either an error, a single JSON result, or a cursor, depending on the query.</source>
          <target state="translated">연결에서 쿼리를 실행하십시오. 콜백은 쿼리에 따라 오류, 단일 JSON 결과 또는 커서를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c8219c1f62102cbb2bc5e0e9dd3b930cf610805d" translate="yes" xml:space="preserve">
          <source>Run some queries</source>
          <target state="translated">몇 가지 쿼리를 실행</target>
        </trans-unit>
        <trans-unit id="d44ebe98717661727e47dcc676b5bed62a1bcda9" translate="yes" xml:space="preserve">
          <source>Run the publisher and corresponding subscribers in different terminal windows, so the output doesn&amp;rsquo;t run together. For example, to run the publisher for the regex demo:</source>
          <target state="translated">다른 터미널 창에서 게시자와 해당 구독자를 실행하면 출력이 함께 실행되지 않습니다. 예를 들어 정규식 데모를 위해 게시자를 실행하려면</target>
        </trans-unit>
        <trans-unit id="ce872fe41a13ab76827629aca0160e3532cba67b" translate="yes" xml:space="preserve">
          <source>Running a proxy node</source>
          <target state="translated">프록시 노드 실행</target>
        </trans-unit>
        <trans-unit id="e0d0a896f47bbfa4aa812a58dd924904235834c4" translate="yes" xml:space="preserve">
          <source>Running multiple instances of RethinkDB on the same server may be desirable for isolating databases for separate applications running on the same server, or for testing purposes. (There is no performance gain from running multiple nodes of the same cluster on the same physical machine.)</source>
          <target state="translated">동일한 서버에서 여러 RethinkDB 인스턴스를 실행하는 것은 동일한 서버에서 실행되는 별도의 응용 프로그램이나 테스트 목적으로 데이터베이스를 격리하는 데 바람직 할 수 있습니다. 동일한 물리적 시스템에서 동일한 클러스터의 여러 노드를 실행해도 성능이 향상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="a2469c47824560f8054ab9e6c0cc7613158a31d8" translate="yes" xml:space="preserve">
          <source>SEND</source>
          <target state="translated">SEND</target>
        </trans-unit>
        <trans-unit id="2064cb643caa8d9e1de12eea7f3e143ca9f8680d" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="translated">SQL</target>
        </trans-unit>
        <trans-unit id="94dbfc935bc4110b42a7479845ebaaf6831417c0" translate="yes" xml:space="preserve">
          <source>SQL and RethinkDB share very similar terminology. Below is a table of terms and concepts in the two systems.</source>
          <target state="translated">SQL과 RethinkDB는 매우 유사한 용어를 공유합니다. 아래는 두 시스템의 용어 및 개념 표입니다.</target>
        </trans-unit>
        <trans-unit id="2d9ba3ea6a8f0fa4cc2e912557eb633510807715" translate="yes" xml:space="preserve">
          <source>SQL to ReQL cheat sheet</source>
          <target state="translated">SQL에서 ReQL 치트 시트로</target>
        </trans-unit>
        <trans-unit id="93660706dc5c1a232c7b857cae33b1f219f3ce07" translate="yes" xml:space="preserve">
          <source>SSH access</source>
          <target state="translated">SSH 액세스</target>
        </trans-unit>
        <trans-unit id="2913b792a0b75101deedbaa4f460c87e0b282d9f" translate="yes" xml:space="preserve">
          <source>SSH tunneling lets you connect directly to the virtual private network of your RethinkDB cluster. This is more complicated to set up, but lets you work with the hosted RethinkDB instance the same way you&amp;rsquo;d work with a local installation, and it can work with any community RethinkDB driver. After your RethinkDB deployment is created, the admin console will give you the host and port information that you need to use to set up the SSH tunnel.</source>
          <target state="translated">SSH 터널링을 사용하면 RethinkDB 클러스터의 가상 사설 네트워크에 직접 연결할 수 있습니다. 이것은 설정하기가 더 복잡하지만 로컬 설치 작업과 동일한 방식으로 호스팅 된 RethinkDB 인스턴스를 사용할 수 있으며 모든 커뮤니티 RethinkDB 드라이버와 작업 할 수 있습니다. RethinkDB 배치가 작성된 후 관리 콘솔은 SSH 터널을 설정하는 데 필요한 호스트 및 포트 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c37f79b7f9adfb0fadf4cb243f264c3d81acde8" translate="yes" xml:space="preserve">
          <source>Safari 6.02 or higher</source>
          <target state="translated">사파리 6.02 이상</target>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="f1af3da47cd6f0772dc9bc865e617198fa0a2bb1" translate="yes" xml:space="preserve">
          <source>Scaling considerations</source>
          <target state="translated">스케일링 고려 사항</target>
        </trans-unit>
        <trans-unit id="56711ed4f6ac142f89dade8ba9b9c93a04023164" translate="yes" xml:space="preserve">
          <source>Scaling, sharding and replication</source>
          <target state="translated">스케일링, 샤딩 및 복제</target>
        </trans-unit>
        <trans-unit id="c23540e5fb551edff0ac95649a1d551f9736d55e" translate="yes" xml:space="preserve">
          <source>Scopes</source>
          <target state="translated">Scopes</target>
        </trans-unit>
        <trans-unit id="c3647743e6f9e273cffde9b95098045e446733a9" translate="yes" xml:space="preserve">
          <source>Scripting ReQL</source>
          <target state="translated">스크립팅 ReQL</target>
        </trans-unit>
        <trans-unit id="5ea96a2371f2e2dcc3e4681dca2cd5e276968843" translate="yes" xml:space="preserve">
          <source>Scripting is also the only way to access some advanced features such as server tags, which let you group servers together for replication purposes (such as associating them with physical data centers). For more information, read the &amp;ldquo;Advanced configuration&amp;rdquo; section of &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">스크립팅은 서버 태그와 같은 일부 고급 기능에 액세스 할 수있는 유일한 방법이기도합니다.이를 통해 복제 목적으로 서버를 그룹화 할 수 있습니다 (예 : 물리적 데이터 센터와 서버 연결). 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 의&amp;ldquo;고급 구성&amp;rdquo;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0672c0c8416fc438be3b303ceef330bdab976b4" translate="yes" xml:space="preserve">
          <source>Seagate Nytro WarpDrive BLP4-1600 storage</source>
          <target state="translated">Seagate Nytro WarpDrive BLP4-1600 스토리지</target>
        </trans-unit>
        <trans-unit id="d0fdab3c7cf84c4001e23486595c30f75a5024ad" translate="yes" xml:space="preserve">
          <source>Secondary indexes are data structures that improve the speed of many read queries at the slight cost of increased storage space and decreased write performance.</source>
          <target state="translated">보조 인덱스는 약간의 스토리지 공간과 쓰기 성능 저하로 약간의 비용으로 많은 읽기 쿼리의 속도를 향상시키는 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="8c7224c2e5fff28a7f3c317eb4d8793a788ef45a" translate="yes" xml:space="preserve">
          <source>Secondary indexes can be used in extremely powerful ways with &lt;code&gt;between&lt;/code&gt; and other commands; read the full article on &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt; for examples using boolean operations, &lt;code&gt;contains&lt;/code&gt; and more.</source>
          <target state="translated">보조 인덱스는 다른 명령과 다른 명령 &lt;code&gt;between&lt;/code&gt; 에서 매우 강력한 방식으로 사용될 수 있습니다 . 부울 연산, &lt;code&gt;contains&lt;/code&gt; 등을 사용하는 예제 는 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;보조 인덱스에&lt;/a&gt; 대한 전체 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4eba5ab82d78a89eda9fb209fef681f5287e83f5" translate="yes" xml:space="preserve">
          <source>Secondary indexes can be used in extremely powerful ways with &lt;code&gt;getAll&lt;/code&gt; and other commands; read the full article on &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt; for examples using boolean operations, &lt;code&gt;contains&lt;/code&gt; and more.</source>
          <target state="translated">보조 인덱스는 &lt;code&gt;getAll&lt;/code&gt; 및 기타 명령과 함께 매우 강력한 방식으로 사용될 수 있습니다 . 부울 연산, &lt;code&gt;contains&lt;/code&gt; 등을 사용하는 예제 는 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;보조 인덱스에&lt;/a&gt; 대한 전체 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7982e9ee250aad3eb15a6e1fa6db7cfdc26cb2f8" translate="yes" xml:space="preserve">
          <source>Secondary indexes will not store &lt;code&gt;null&lt;/code&gt; values or objects. Thus, the results of a command such as:</source>
          <target state="translated">보조 인덱스는 &lt;code&gt;null&lt;/code&gt; 값이나 개체를 저장하지 않습니다 . 따라서 다음과 같은 명령의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8244783aa1946897f99cef0c73eb2f5a4dfb4197" translate="yes" xml:space="preserve">
          <source>Secure your cluster</source>
          <target state="translated">클러스터 보안</target>
        </trans-unit>
        <trans-unit id="b8c1351559faf4d2f8b669b12ea7d407f5666309" translate="yes" xml:space="preserve">
          <source>Securing the driver port</source>
          <target state="translated">드라이버 포트 보안</target>
        </trans-unit>
        <trans-unit id="a1d993407c8376c1672bf0c5a4284232354399e2" translate="yes" xml:space="preserve">
          <source>Securing your cluster</source>
          <target state="translated">클러스터 보안</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="69a94e079c6f72dd821a2916438daf4debbe798b" translate="yes" xml:space="preserve">
          <source>Security options</source>
          <target state="translated">보안 옵션</target>
        </trans-unit>
        <trans-unit id="6b8e42cb98e4e465a60e20b63d2bd2161876bca6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../../docs/external-api-access/index&quot;&gt;the tutorial&lt;/a&gt; on &lt;code&gt;r.http&lt;/code&gt; for more examples on how to use this command.</source>
          <target state="translated">이 명령을 사용하는 방법에 대한 자세한 예 는 &lt;code&gt;r.http&lt;/code&gt; &lt;a href=&quot;../../../docs/external-api-access/index&quot;&gt;의 자습서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b99ffebc80bfe3b34e15d2ac5f938bedd9c52f7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../install-drivers/index&quot;&gt;driver install instructions&lt;/a&gt; for your language.</source>
          <target state="translated">해당 언어의 &lt;a href=&quot;../install-drivers/index&quot;&gt;드라이버 설치 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e659a7b1fb270abb215eabd50ddcef317a46e407" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;server install instructions&lt;/a&gt; for your platform.</source>
          <target state="translated">플랫폼에 대한 &lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;서버 설치 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fdf7b2ad01bc194f00eacfd1ee38e4d3b63dcb2" translate="yes" xml:space="preserve">
          <source>See cat pictures shared on Instagram in real time.</source>
          <target state="translated">Instagram에서 공유 한 고양이 사진을 실시간으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c2ba2a4f667941be3cc9b497e222e28d10a7c74" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../../data-types/index&quot;&gt;data type documentation&lt;/a&gt; for more detail about streams.</source>
          <target state="translated">스트림에 대한 자세한 내용은 &lt;a href=&quot;../../data-types/index&quot;&gt;데이터 형식 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c48c84da1b5e5392c19334e8b0bbaa319e703a8" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt; documentation for a description of the field values.</source>
          <target state="translated">필드 값에 대한 설명은 &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bde140c936811da044b952e743be8767f0ecb2cc" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../status/index&quot;&gt;status&lt;/a&gt; command for an explanation of the objects returned in the &lt;code&gt;old_val&lt;/code&gt; and &lt;code&gt;new_val&lt;/code&gt; fields.</source>
          <target state="translated">&lt;code&gt;old_val&lt;/code&gt; 및 &lt;code&gt;new_val&lt;/code&gt; 필드에 리턴 된 오브젝트에 대한 설명은 &lt;a href=&quot;../status/index&quot;&gt;status&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="629e4746d16af85c9b3fd8d43b27fa95f2889be7" translate="yes" xml:space="preserve">
          <source>See the code &amp;raquo;</source>
          <target state="translated">코드보기&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="dcd7ebe20b693b22889b95a15eca49030584ea07" translate="yes" xml:space="preserve">
          <source>See the source &amp;raquo;</source>
          <target state="translated">소스보기&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="ab287e3400037660977c93949d06c8794701e08d" translate="yes" xml:space="preserve">
          <source>Select &amp;ldquo;RethinkDB.&amp;rdquo;</source>
          <target state="translated">&quot;RethinkDB&quot;를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="49ff71acb246cc6a63a1ed20135722e307015e4a" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;Custom TCP rule&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;사용자 정의 TCP 규칙을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ed0e41cf00adc048443a4c59a481c886d9dcf2" translate="yes" xml:space="preserve">
          <source>Select a given number of elements from a sequence with uniform random distribution. Selection is done without replacement.</source>
          <target state="translated">균일 한 랜덤 분포를 갖는 시퀀스에서 주어진 수의 요소를 선택하십시오. 교체하지 않고 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cdf1371e4dd147b3db77a3f68e9797466ae68a9a" translate="yes" xml:space="preserve">
          <source>Select the &lt;strong&gt;1-Click Launch&lt;/strong&gt; tab, select the size of the instance you wish to configure, and click on the &lt;strong&gt;Launch with 1-Click&lt;/strong&gt; button on the right.</source>
          <target state="translated">선택 &lt;strong&gt;1 - 클릭 실행&lt;/strong&gt; , 탭을 구성하려는 인스턴스의 크기를 선택하고 클릭 &lt;strong&gt;1 클릭으로 실행&lt;/strong&gt; 오른쪽 버튼을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="24ef151114580dc0d68467e5ab448d8c09efd89c" translate="yes" xml:space="preserve">
          <source>Select the security group that your instances belong to and open the &lt;strong&gt;Inbound&lt;/strong&gt; tab in the bottom half of the page.</source>
          <target state="translated">인스턴스가 속한 보안 그룹을 선택하고 페이지 하단에서 &lt;strong&gt;인바운드&lt;/strong&gt; 탭을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="af912eddd3068889909f441f05cc66e7d588440d" translate="yes" xml:space="preserve">
          <source>Selecting Data</source>
          <target state="translated">데이터 선택</target>
        </trans-unit>
        <trans-unit id="cfe3f3de9a7d6d7478e815f2c854155e18ec593b" translate="yes" xml:space="preserve">
          <source>Selecting data</source>
          <target state="translated">데이터 선택</target>
        </trans-unit>
        <trans-unit id="01e78f2f17937f1b67c1972da29be60ea26dacdb" translate="yes" xml:space="preserve">
          <source>Selecting workloads and hardware</source>
          <target state="translated">워크로드 및 하드웨어 선택</target>
        </trans-unit>
        <trans-unit id="0e06550e71b1bb97d074f86a8f3eff781b17db2b" translate="yes" xml:space="preserve">
          <source>Selections: &lt;code&gt;between&lt;/code&gt;, &lt;code&gt;get_all&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;</source>
          <target state="translated">선택 사항 : &lt;code&gt;between&lt;/code&gt; , &lt;code&gt;get_all&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c274dc21c7abbd576e80808d73c6a883b8fc67d" translate="yes" xml:space="preserve">
          <source>Semantic command</source>
          <target state="translated">시맨틱 명령</target>
        </trans-unit>
        <trans-unit id="5340a0e3ba910c6ba58f50f0b02149f97571010b" translate="yes" xml:space="preserve">
          <source>Send the authorization key as an ASCII string. &lt;em&gt;If there is no authorization key, skip this step.&lt;/em&gt;</source>
          <target state="translated">인증 키를 ASCII 문자열로 보냅니다. &lt;em&gt;인증 키가 없으면이 단계를 건너 뜁니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="740b49c8e2030bbb3b6d6adfaf0a7f11772bbe3d" translate="yes" xml:space="preserve">
          <source>Send the following data to the server:</source>
          <target state="translated">다음 데이터를 서버로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="efa93b393c3d5d51c8ab31aa67430179ff81d156" translate="yes" xml:space="preserve">
          <source>Send the length of the authorization key, as a 32-bit little-endian integer (4 bytes). Send &lt;code&gt;0&lt;/code&gt; if there is no authorization key.</source>
          <target state="translated">인증 키의 길이를 32 비트 리틀 엔디안 정수 (4 바이트)로 보내십시오. 인증 키가 없으면 &lt;code&gt;0&lt;/code&gt; 을 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="05226713ff51e987c345dc09ac55543399794d44" translate="yes" xml:space="preserve">
          <source>Send the message</source>
          <target state="translated">메시지 보내기</target>
        </trans-unit>
        <trans-unit id="4da6808722e9c55a13e5d55b1b3fcad59e4b38ad" translate="yes" xml:space="preserve">
          <source>Send the protocol type, as a 32-bit little-endian integer (4 bytes). Protocol types are defined in the &lt;code&gt;Protocol&lt;/code&gt; enum in &lt;code&gt;ql2.proto&lt;/code&gt;. New drivers should use JSON, &lt;code&gt;0x7e6970c7&lt;/code&gt;.</source>
          <target state="translated">프로토콜 유형을 32 비트 리틀 엔디안 정수 (4 바이트)로 전송하십시오. 프로토콜 유형은 &lt;code&gt;ql2.proto&lt;/code&gt; 의 &lt;code&gt;Protocol&lt;/code&gt; 열거에 정의되어 있습니다. 새 드라이버는 JSON &lt;code&gt;0x7e6970c7&lt;/code&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d87012444da097dfb39f95359e77788d4b8c6f34" translate="yes" xml:space="preserve">
          <source>Send the protocol version, as a 32-bit little-endian integer (4 bytes). &lt;em&gt;Note:&lt;/em&gt; All instructions below assume a protocol of &lt;code&gt;V0_3&lt;/code&gt; or higher. The current protocol as of RethinkDB 2.0 is &lt;code&gt;V0_4&lt;/code&gt;.</source>
          <target state="translated">프로토콜 버전을 32 비트 리틀 엔디안 정수 (4 바이트)로 보냅니다. &lt;em&gt;참고 :&lt;/em&gt; 아래의 모든 지침은 &lt;code&gt;V0_3&lt;/code&gt; 이상의 프로토콜을 가정합니다 . RethinkDB 2.0 현재의 현재 프로토콜은 &lt;code&gt;V0_4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0edc082b63c1cd873d382eccbdf135d9f6ac595b" translate="yes" xml:space="preserve">
          <source>Sending a query to the server takes the following steps:</source>
          <target state="translated">서버로 쿼리를 보내려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d443e709debab14709d7be0d682a089ecefe0676" translate="yes" xml:space="preserve">
          <source>Sending queries</source>
          <target state="translated">쿼리 보내기</target>
        </trans-unit>
        <trans-unit id="e46be1417c76343bc1c3aa2b1e53190674bcf776" translate="yes" xml:space="preserve">
          <source>Serialize the query</source>
          <target state="translated">쿼리를 직렬화</target>
        </trans-unit>
        <trans-unit id="2a0b4e570611bbb4fac2919e233436966085b203" translate="yes" xml:space="preserve">
          <source>Serialize the query as UTF8-encoded JSON</source>
          <target state="translated">쿼리를 UTF8로 인코딩 된 JSON으로 직렬화</target>
        </trans-unit>
        <trans-unit id="22560a188183eb4938827af6f2ba7b1b011ef57a" translate="yes" xml:space="preserve">
          <source>Serialize the result as the function body</source>
          <target state="translated">함수 본문으로 결과를 직렬화</target>
        </trans-unit>
        <trans-unit id="e801f1e48565ad9f05ad5d47ade5d22a1e958713" translate="yes" xml:space="preserve">
          <source>Serializing BINARY</source>
          <target state="translated">이진 직렬화</target>
        </trans-unit>
        <trans-unit id="dd029cb1a0d313fcf58a06341f2e7bdf14cdb24d" translate="yes" xml:space="preserve">
          <source>Serializing FUNCALL (r.do)</source>
          <target state="translated">FUNCALL 직렬화 (r.do)</target>
        </trans-unit>
        <trans-unit id="6f6ea3f30e1c4a9dd85cfbac7843347f0e57f7af" translate="yes" xml:space="preserve">
          <source>Serializing IMPLICIT_VAR (r.row)</source>
          <target state="translated">IMPLICIT_VAR 직렬화 (r.row)</target>
        </trans-unit>
        <trans-unit id="9362048d7a1ed20573c1df7d6139cfc0122f7c7f" translate="yes" xml:space="preserve">
          <source>Serializing functions depends heavily on your driver&amp;rsquo;s language. The JavaScript driver does it this way:</source>
          <target state="translated">직렬화 기능은 드라이버 언어에 따라 크게 다릅니다. JavaScript 드라이버는 다음과 같이합니다 :</target>
        </trans-unit>
        <trans-unit id="097cf93c17b852922e8cd146b12ffe5341e6bbc2" translate="yes" xml:space="preserve">
          <source>Serializing queries</source>
          <target state="translated">쿼리 직렬화</target>
        </trans-unit>
        <trans-unit id="b4269c5c84242504fd47a52d752db994a859d003" translate="yes" xml:space="preserve">
          <source>Server name options</source>
          <target state="translated">서버 이름 옵션</target>
        </trans-unit>
        <trans-unit id="71dcf72bf9cc6e1c264c8103df146d0cb981e165" translate="yes" xml:space="preserve">
          <source>Server tags</source>
          <target state="translated">서버 태그</target>
        </trans-unit>
        <trans-unit id="92d0a01058b90937ea648c34a5eafe7e961cb37e" translate="yes" xml:space="preserve">
          <source>Server-side execution</source>
          <target state="translated">서버 측 실행</target>
        </trans-unit>
        <trans-unit id="052415886e7845a7d8c9677f78a612cf9388c2e4" translate="yes" xml:space="preserve">
          <source>Service options</source>
          <target state="translated">서비스 옵션</target>
        </trans-unit>
        <trans-unit id="787ea64c257fea9081ea48830032783bdd035b44" translate="yes" xml:space="preserve">
          <source>Set User/Group options</source>
          <target state="translated">사용자 / 그룹 옵션 설정</target>
        </trans-unit>
        <trans-unit id="11b1bdd58898b94a3331dd7009df636000e030ca" translate="yes" xml:space="preserve">
          <source>Set a user account and password for your application</source>
          <target state="translated">응용 프로그램의 사용자 계정 및 비밀번호 설정</target>
        </trans-unit>
        <trans-unit id="3720b938334b35818a908635b19bf42e1dc3cfc4" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;Label&lt;/code&gt; key value to the name of the file (e.g., &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Label&lt;/code&gt; 키 값을 파일 이름으로 설정 하십시오 (예 : &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf4ec08a934fec647917f8442a9eb64a83b5273a" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;ProgramArguments&lt;/code&gt; key to a new configuration file (e.g., &lt;code&gt;/etc/rethinkdb2.conf&lt;/code&gt;).</source>
          <target state="translated">설정 &lt;code&gt;ProgramArguments&lt;/code&gt; 의 새 구성 파일 (예를 들어, 핵심 &lt;code&gt;/etc/rethinkdb2.conf&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="8f3c03334a02bba0274f2e4013da9aefe549f42d" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;StandardOutPath&lt;/code&gt; and &lt;code&gt;StandardErrorPath&lt;/code&gt; keys to a new log file.</source>
          <target state="translated">설정 &lt;code&gt;StandardOutPath&lt;/code&gt; 및 &lt;code&gt;StandardErrorPath&lt;/code&gt; 새 로그 파일에 키를.</target>
        </trans-unit>
        <trans-unit id="049d191886309580e64950b88aef06ddc12854ad" translate="yes" xml:space="preserve">
          <source>Set the number of shards and replicas you would like.</source>
          <target state="translated">원하는 샤드 및 복제본 수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="259bb4847964abaa06f8a09e3bf87cfbfe2f039f" translate="yes" xml:space="preserve">
          <source>Set this file to be owned by the &lt;code&gt;root&lt;/code&gt; user:</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 사용자 가이 파일을 소유하도록 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="484f40f1ca8f5abf97858ccdf6eaece611f3121b" translate="yes" xml:space="preserve">
          <source>Setting up VPC security groups</source>
          <target state="translated">VPC 보안 그룹 설정</target>
        </trans-unit>
        <trans-unit id="72717ced9f39074f0e308322cf67ec080b85f4cd" translate="yes" xml:space="preserve">
          <source>Setting up high availability</source>
          <target state="translated">고 가용성 설정</target>
        </trans-unit>
        <trans-unit id="c7f73bb54d928922c3838bb789ee9fb8a5b1eb37" translate="yes" xml:space="preserve">
          <source>Settings</source>
          <target state="translated">Settings</target>
        </trans-unit>
        <trans-unit id="b40f8c6b312aa78981283ac7bcf07d39753f5f58" translate="yes" xml:space="preserve">
          <source>Sharding</source>
          <target state="translated">Sharding</target>
        </trans-unit>
        <trans-unit id="8b825f365b5f5094480702aedaba3f3404b88156" translate="yes" xml:space="preserve">
          <source>Sharding and replication</source>
          <target state="translated">샤딩 및 복제</target>
        </trans-unit>
        <trans-unit id="9675bc0d332a6ee2cdd0a92eee926c14735851f9" translate="yes" xml:space="preserve">
          <source>Sharding and replication can be controlled through the &lt;code&gt;table_config&lt;/code&gt; table, along with the more advanced settings of write acknowledgements and durability. Tables can also be renamed by modifying their rows. A typical row in the &lt;code&gt;table_config&lt;/code&gt; table will look like this:</source>
          <target state="translated">샤딩 및 복제는 보다 고급의 쓰기 승인 및 내구성 설정과 함께 &lt;code&gt;table_config&lt;/code&gt; 테이블을 통해 제어 할 수 있습니다 . 행을 수정하여 테이블 이름을 바꿀 수도 있습니다. &lt;code&gt;table_config&lt;/code&gt; 테이블 의 일반적인 행 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65fdb932a6e83c2148674a2aebcd5a18d8e5feee" translate="yes" xml:space="preserve">
          <source>Sharding and replication is configured through &lt;em&gt;table configurations,&lt;/em&gt; which let you simply specify the number of shards and replicas per table or for all tables within a database. Users do not need to manually associate servers with tables. RethinkDB uses a set of heuristics to attempt to satisfy table configurations in an optimal way. It will copy data for new replicas from an available server, evenly distribute replicas of the data across the cluster, try to distribute the load evenly, and so on.</source>
          <target state="translated">샤딩 및 복제는 &lt;em&gt;테이블&lt;/em&gt; 구성을 통해 &lt;em&gt;구성&lt;/em&gt; 되므로 테이블 또는 데이터베이스 내의 모든 테이블에 대한 샤드 및 복제본의 수를 간단히 지정할 수 있습니다. 사용자는 서버를 테이블과 수동으로 연결할 필요가 없습니다. RethinkDB는 일련의 휴리스틱을 사용하여 최적의 방식으로 테이블 구성을 충족 시키려고 시도합니다. 사용 가능한 서버에서 새 복제본에 대한 데이터를 복사하고 클러스터에 데이터 복제본을 균등하게 분배하고로드를 균등하게 분배하는 등의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ca374faf5075c1fff58817a8737a9b8341f7b444" translate="yes" xml:space="preserve">
          <source>Sharding and replication via ReQL</source>
          <target state="translated">ReQL을 통한 샤딩 및 복제</target>
        </trans-unit>
        <trans-unit id="4675658ba485e5ab233faf96f4b4bd60bdbc1d69" translate="yes" xml:space="preserve">
          <source>Sharding and replication via the web console</source>
          <target state="translated">웹 콘솔을 통한 샤딩 및 복제</target>
        </trans-unit>
        <trans-unit id="0f61896f7a3a3b22c994b7290ce915514b2ffb18" translate="yes" xml:space="preserve">
          <source>Similarly, you can use the &lt;code&gt;r.or&lt;/code&gt; command to filter based on one of many conditions.</source>
          <target state="translated">마찬가지로 &lt;code&gt;r.or&lt;/code&gt; 명령을 사용하여 여러 조건 중 하나를 기준으로 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ead99c11dfb522b4ed24272cb8935d1b0c95297" translate="yes" xml:space="preserve">
          <source>Simple creation and insertion</source>
          <target state="translated">간단한 생성 및 삽입</target>
        </trans-unit>
        <trans-unit id="b49b76d7f46024bae079a561e12707a34bb17cda" translate="yes" xml:space="preserve">
          <source>Simple indexes</source>
          <target state="translated">간단한 인덱스</target>
        </trans-unit>
        <trans-unit id="b9b59b87ad4c0b4b1b2c1e4f4e9e461f32d5aa30" translate="yes" xml:space="preserve">
          <source>Simple queries on a superheroes dataset.</source>
          <target state="translated">슈퍼 히어로 데이터 세트에 대한 간단한 쿼리.</target>
        </trans-unit>
        <trans-unit id="f9e72abc4ccbeabab6d891f4fb04960cf410c43e" translate="yes" xml:space="preserve">
          <source>Simple usage</source>
          <target state="translated">간단한 사용법</target>
        </trans-unit>
        <trans-unit id="8ba0e1b4f1c2ba72682c0924cd3042f72176d882" translate="yes" xml:space="preserve">
          <source>Simply specify the field using the &lt;code&gt;row&lt;/code&gt; command instead of a string.</source>
          <target state="translated">단순히 문자열 대신 &lt;code&gt;row&lt;/code&gt; 명령을 사용하여 필드를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e78ef142771d107595b0bc8cf20eb66722ed8ac8" translate="yes" xml:space="preserve">
          <source>Simulates a mixed read/write workload with equally many writes as reads</source>
          <target state="translated">읽기와 동일한 쓰기로 혼합 된 읽기 / 쓰기 워크로드를 시뮬레이션</target>
        </trans-unit>
        <trans-unit id="1fdb1c708a30ef631fc8da75683628bb2d960c6a" translate="yes" xml:space="preserve">
          <source>Simulates a read-only workload</source>
          <target state="translated">읽기 전용 워크로드 시뮬레이션</target>
        </trans-unit>
        <trans-unit id="3f5ef2e223d333ea61560c000796e68942bc4eab" translate="yes" xml:space="preserve">
          <source>Sinatra</source>
          <target state="translated">Sinatra</target>
        </trans-unit>
        <trans-unit id="b19b761fc2db7f1d9136da17083f2446b67beb3a" translate="yes" xml:space="preserve">
          <source>Since NoBrainer&amp;rsquo;s &lt;code&gt;has_many&lt;/code&gt; associations are read-only, handling nested resources changes a little bit. For example, if &lt;code&gt;Comments&lt;/code&gt; are nested in &lt;code&gt;Articles&lt;/code&gt;, the comment form in the Article view would look like this:</source>
          <target state="translated">NoBrainer의 &lt;code&gt;has_many&lt;/code&gt; 연관은 읽기 전용이므로 중첩 된 자원을 처리하면 약간 변경됩니다. 예를 들어, &lt;code&gt;Comments&lt;/code&gt; 이 &lt;code&gt;Articles&lt;/code&gt; 에 중첩 된 경우 기사 보기의 주석 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dea68530ec6917cefc65a58fb3ef6ae8d193b4ea" translate="yes" xml:space="preserve">
          <source>Since automatic failover requires a majority of servers for a table to be available, it requires a minimum of three servers to be involved. In a two-machine cluster, automatic failover will never occur, and tables will lose availability for writes if either machine loses connectivity. In this case, if the machine cannot be reconnected, you must fix the problem manually using the emergency repair option of &lt;code&gt;reconfigure&lt;/code&gt;.</source>
          <target state="translated">자동 장애 조치 (failover)에는 테이블을 사용할 수있는 대부분의 서버가 필요하므로 최소 3 대의 서버가 필요합니다. 두 시스템 클러스터에서는 자동 장애 조치가 발생하지 않으며 두 시스템 중 하나의 연결이 끊어지면 테이블의 쓰기 가용성이 손실됩니다. 이 경우 머신을 다시 연결할 수 없으면 응급 복구 옵션 인 &lt;code&gt;reconfigure&lt;/code&gt; 를 사용하여 수동으로 문제점을 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c04f4c8a74a44e7cb0a881e32ee9d07a7e1b6956" translate="yes" xml:space="preserve">
          <source>Since changefeeds are unidirectional with no acknowledgement returned from clients, they cannot guarantee delivery. If you need real-time updating with delivery guarantees, consider using a model that distributes to the clients through a message broker such as &lt;a href=&quot;../../rabbitmq/javascript/index&quot;&gt;RabbitMQ&lt;/a&gt;.</source>
          <target state="translated">변경 피드는 클라이언트로부터 수신 확인을 보내지 않고 단방향이므로 배달을 보장 할 수 없습니다. 배달 보증으로 실시간 업데이트가 필요한 경우 &lt;a href=&quot;../../rabbitmq/javascript/index&quot;&gt;RabbitMQ&lt;/a&gt; 와 같은 메시지 브로커를 통해 클라이언트에 배포하는 모델을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfa008fce6f7f4612e2eead0a4d7c799cf0ca174" translate="yes" xml:space="preserve">
          <source>Since it&amp;rsquo;s available online, you can import our sample data set just by creating a table and importing it with &lt;a href=&quot;../http/index&quot;&gt;http&lt;/a&gt;. Just execute these commands directly in the Data Explorer.</source>
          <target state="translated">온라인에서 사용할 수 있으므로 테이블을 작성하고 &lt;a href=&quot;../http/index&quot;&gt;http로&lt;/a&gt; 가져 오기만하면 샘플 데이터 세트를 가져올 수 있습니다 . 데이터 탐색기에서 이러한 명령을 직접 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="28e09663b14b74fc50bbdf52af54ef70c8ff5d0a" translate="yes" xml:space="preserve">
          <source>Since primary keys are unique, the &lt;code&gt;get&lt;/code&gt; command returns a single document. This way we can retrieve the document directly without converting a cursor to an array.</source>
          <target state="translated">기본 키는 고유하기 때문에 &lt;code&gt;get&lt;/code&gt; 명령은 단일 문서를 반환합니다. 이런 식으로 커서를 배열로 변환하지 않고 문서를 직접 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eded6ab1c8bba9391d0bc0efe3fde1c3a7029bd5" translate="yes" xml:space="preserve">
          <source>Since the backup process uses client drivers, it takes advantage of RethinkDB&amp;rsquo;s concurrency. While it will use some cluster resources, it won&amp;rsquo;t lock out any clients, and it can be safely run on a live cluster.</source>
          <target state="translated">백업 프로세스는 클라이언트 드라이버를 사용하므로 RethinkDB의 동시성을 활용합니다. 일부 클러스터 리소스를 사용하지만 클라이언트를 잠그지 않으며 라이브 클러스터에서 안전하게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646f2ddb07a63e77664dbfdf8026cf82e89c96af" translate="yes" xml:space="preserve">
          <source>Since the table might contain a large number of documents, the database returns a cursor object. As you iterate through the cursor, the server will send documents to the client in batches as they are requested. We only have three documents in our example, so we can safely retrieve all the documents at once. The &lt;code&gt;toArray&lt;/code&gt; function automatically iterates through the cursor and puts the documents into a JavaScript array.</source>
          <target state="translated">테이블에 많은 수의 문서가 포함될 수 있으므로 데이터베이스는 커서 객체를 반환합니다. 커서를 반복 할 때 서버는 요청에 따라 문서를 클라이언트에 일괄 적으로 보냅니다. 이 예제에는 3 개의 문서 만 있으므로 모든 문서를 한 번에 안전하게 검색 할 수 있습니다. &lt;code&gt;toArray&lt;/code&gt; 의 기능이 자동으로 자바 스크립트 배열에 커서를두고 문서를 반복.</target>
        </trans-unit>
        <trans-unit id="461e45707281cf6856842c50c790ea612c5a6862" translate="yes" xml:space="preserve">
          <source>Since this query is pure ReQL, the entire query will be distributed efficiently over the cluster without any computation being done on the client.</source>
          <target state="translated">이 쿼리는 순수한 ReQL이므로 전체 쿼리는 클라이언트에서 계산을 수행하지 않고도 클러스터에 효율적으로 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="d08c9e61a015681b5d3f9c65c2e3d1116acb06fd" translate="yes" xml:space="preserve">
          <source>Since we changed three documents, the result should look like this:</source>
          <target state="translated">세 개의 문서를 변경 했으므로 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de5b0b24c773e307562dc43accdfc9204b771ec8" translate="yes" xml:space="preserve">
          <source>Since we have two authors with less than two posts, the result is:</source>
          <target state="translated">게시물이 2 개 미만인 저자가 2 명이므로 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8922e181eb91cb6fa5246f74862ea665af4e7901" translate="yes" xml:space="preserve">
          <source>Since we only updated one document, we get back this object:</source>
          <target state="translated">하나의 문서 만 업데이트했기 때문에이 객체를 다시 얻습니다.</target>
        </trans-unit>
        <trans-unit id="eeaf9297d721b8e99b43d24aa5fc70dd66377540" translate="yes" xml:space="preserve">
          <source>Since you&amp;rsquo;ll be doing more manipulation on the data, you might want to store the results of an API call in the database. Let&amp;rsquo;s create a table &lt;code&gt;stargazers&lt;/code&gt; and insert the RethinkDB stargazers into this table:</source>
          <target state="translated">데이터에 대한 추가 조작을 수행하므로 API 호출 결과를 데이터베이스에 저장하려고 할 수 있습니다. 테이블 &lt;code&gt;stargazers&lt;/code&gt; 를 만들고이 테이블에 RethinkDB stargazer를 삽입 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b9140d15368b4c6388b91b301bb59e02a57255f2" translate="yes" xml:space="preserve">
          <source>Skip a number of elements from the head of the sequence.</source>
          <target state="translated">시퀀스 헤드에서 여러 요소를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="11669c94403e009f8888a5f31c24059deacb9444" translate="yes" xml:space="preserve">
          <source>Small documents of no more than 250 bytes (including encoding overhead) are stored &amp;ldquo;in line&amp;rdquo; in the primary index tree. Many such documents can share a single 4 KB block.</source>
          <target state="translated">250 바이트 이하의 작은 문서 (인코딩 오버 헤드 포함)는 기본 인덱스 트리에 &quot;인라인&quot;으로 저장됩니다. 이러한 많은 문서는 단일 4KB 블록을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66e287db281bba04ed3fbc4687e72ca03b461a59" translate="yes" xml:space="preserve">
          <source>Smaller result sets can be turned into an array directly, with native language constructs in Python and Ruby (&lt;code&gt;list(players)&lt;/code&gt; and &lt;code&gt;players.to_a&lt;/code&gt; respectively) or ReQL commands in JavaScript and Java (&lt;code&gt;players.toArray()&lt;/code&gt; and &lt;code&gt;players.toList()&lt;/code&gt; respectively; see &lt;a href=&quot;../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; and &lt;a href=&quot;https://rethinkdb.com/api/java/to_array/&quot;&gt;toList&lt;/a&gt; documentation).</source>
          <target state="translated">작은 결과 세트는 기본 언어 파이썬과 루비 구조 (과 직접 배열로 설정할 수 있습니다 &lt;code&gt;list(players)&lt;/code&gt; 와 &lt;code&gt;players.to_a&lt;/code&gt; 자바 스크립트와 자바 (각각) 또는 ReQL 명령 &lt;code&gt;players.toArray()&lt;/code&gt; 와 &lt;code&gt;players.toList()&lt;/code&gt; 각각 &lt;a href=&quot;../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; 및 &lt;a href=&quot;https://rethinkdb.com/api/java/to_array/&quot;&gt;toList&lt;/a&gt; 설명서를 참조하십시오 ).</target>
        </trans-unit>
        <trans-unit id="0d0c98658c204f1e54e4cbe7f13aa85d03ebbf38" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve seen only simple queries without conditions. ReQL supports a familiar syntax for building more advanced queries:</source>
          <target state="translated">지금까지 조건이없는 간단한 쿼리 만 보았습니다. ReQL은 고급 쿼리를 작성하기 위해 익숙한 구문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="679b56c74eaec9a82e1ba0243df0e7b84b448cc7" translate="yes" xml:space="preserve">
          <source>So we can see IMDb&amp;rsquo;s number one movie with &lt;code&gt;filter({rank: 1})&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;filter({rank: 1})&lt;/code&gt; IMDb의 최고의 영화를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2233aa4b211f8f385bb078bd9f37203992d460f" translate="yes" xml:space="preserve">
          <source>So, for example, if we wanted to send a notification that Batman and the Joker had a fight, we might publish with the tags &lt;code&gt;#superhero&lt;/code&gt;, &lt;code&gt;#fight&lt;/code&gt;, and &lt;code&gt;#supervillain&lt;/code&gt;:</source>
          <target state="translated">예를 들어 배트맨과 조커가 싸웠다는 알림을 보내려면 태그 &lt;code&gt;#superhero&lt;/code&gt; , &lt;code&gt;#fight&lt;/code&gt; 및 &lt;code&gt;#supervillain&lt;/code&gt; 을 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eba8326cc93ad5c924b37021c049a63bed74a15f" translate="yes" xml:space="preserve">
          <source>So, our initial example query of:</source>
          <target state="translated">따라서 우리의 초기 예제 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c2be06fa2bad03ab6e4aac214b80b94243e8bb0" translate="yes" xml:space="preserve">
          <source>So, the data we send to the server is as follows:</source>
          <target state="translated">따라서 서버로 보내는 데이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="925f0ecb819a75da4d24fd9a6b368e3d9d210d0c" translate="yes" xml:space="preserve">
          <source>Socks host: &lt;code&gt;localhost&lt;/code&gt;</source>
          <target state="translated">양말 호스트 : &lt;code&gt;localhost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3d2add8cfb71350f0a21731bae9a1fcd1c6f911" translate="yes" xml:space="preserve">
          <source>Some commands (&lt;code&gt;orderBy&lt;/code&gt; and &lt;code&gt;between&lt;/code&gt;) return a data type similar to a selection called a &lt;strong&gt;table_slice&lt;/strong&gt;. In most cases a table_slice behaves identically to a selection, but &lt;code&gt;between&lt;/code&gt; can only be called on a table or a table_slice, not any other kind of selection.</source>
          <target state="translated">일부 명령 ( &lt;code&gt;orderBy&lt;/code&gt; 및 &lt;code&gt;between&lt;/code&gt; )은 &lt;strong&gt;table_slice&lt;/strong&gt; 라는 선택과 유사한 데이터 유형을 반환합니다 . 대부분의 경우 table_slice는 선택 항목과 동일하게 동작하지만 그 &lt;code&gt;between&lt;/code&gt; 는 다른 종류의 선택 항목이 아닌 테이블 또는 table_slice에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="920b523b3dbbdb44d9018758c80fc8718d1fcd73" translate="yes" xml:space="preserve">
          <source>Some native ReQL data types have no direct JSON representations. These are implemented as &lt;em&gt;pseudo types,&lt;/em&gt; JSON objects with the special key &lt;code&gt;$reql_type$&lt;/code&gt;. The three official ReQL drivers convert date and binary types to pseudo types.</source>
          <target state="translated">일부 기본 ReQL 데이터 유형에는 직접적인 JSON 표현이 없습니다. 이들은 특수 키가 &lt;code&gt;$reql_type$&lt;/code&gt; &lt;em&gt;의사 유형의&lt;/em&gt; JSON 객체로 구현됩니다 . 세 가지 공식 ReQL 드라이버는 날짜 및 이진 유형을 의사 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="45727d8558702b8e8e6821036bedae3a955e8e75" translate="yes" xml:space="preserve">
          <source>Some other map-reduce implementations, like Hadoop&amp;rsquo;s, use the mapping step to perform grouping as well; RethinkDB&amp;rsquo;s implementation explicitly separates them. This is sometimes referred to as &amp;ldquo;group-map-reduce,&amp;rdquo; or GMR. RethinkDB distributes GMR queries over tables and shards efficiently. You write GMR queries with the &lt;a href=&quot;https://rethinkdb.com/api/python/group/&quot;&gt;group&lt;/a&gt;, &lt;a href=&quot;https://rethinkdb.com/api/python/map/&quot;&gt;map&lt;/a&gt; and &lt;a href=&quot;https://rethinkdb.com/api/python/reduce/&quot;&gt;reduce&lt;/a&gt; commands, although as we&amp;rsquo;ll see in our examples, many ReQL commands compile to GMR queries behind the scenes&amp;mdash;many common map-reduce cases can be accomplished in one or two lines of ReQL.</source>
          <target state="translated">Hadoop과 같은 일부 다른 맵 축소 구현에서는 매핑 단계를 사용하여 그룹화도 수행합니다. RethinkDB의 구현은 명시 적으로 분리합니다. 이를 &quot;그룹 맵 감소&quot;또는 GMR이라고도합니다. RethinkDB는 GMR 쿼리를 테이블과 샤드에 효율적으로 배포합니다. 예제에서 볼 수 있듯이 &lt;a href=&quot;https://rethinkdb.com/api/python/group/&quot;&gt;그룹&lt;/a&gt; 과 함께 GMR 쿼리를 작성 하고 &lt;a href=&quot;https://rethinkdb.com/api/python/map/&quot;&gt;map&lt;/a&gt; 및 &lt;a href=&quot;https://rethinkdb.com/api/python/reduce/&quot;&gt;reduce&lt;/a&gt; 명령을 사용 합니다. 많은 ReQL 명령이 장면 뒤에서 GMR 쿼리로 컴파일됩니다. 많은 일반적인 map-reduce 사례는 ReQL의 한두 줄로 이루어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38976f19ca7ba6bdfba5c08f5a088ab5d7765537" translate="yes" xml:space="preserve">
          <source>Some system tables are read-only. System tables which allow writing require specific document schema, described below.</source>
          <target state="translated">일부 시스템 테이블은 읽기 전용입니다. 쓰기가 가능한 시스템 테이블에는 아래에 설명 된 특정 문서 스키마가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="297bafdbd8b010b58a31c04b9e3f52472f0b3473" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to write a ReQL document with a dynamic key&amp;mdash;the field name is stored in a variable. You can do this with the &lt;code&gt;object&lt;/code&gt; command, which takes a list of keys and values (&lt;code&gt;(key, value, key, value ...)&lt;/code&gt;) and returns an object from them.</source>
          <target state="translated">때로는 동적 키를 사용하여 ReQL 문서를 작성하려고 할 수 있습니다. 필드 이름은 변수에 저장됩니다. 당신은이 작업을 수행 할 수 &lt;code&gt;object&lt;/code&gt; 키와 값 (목록 소요 명령 &lt;code&gt;(key, value, key, value ...)&lt;/code&gt; ) 반환 그들에서 개체를.</target>
        </trans-unit>
        <trans-unit id="377d3d6f2c79ecc7905a44e35d7263f6d55bd8b0" translate="yes" xml:space="preserve">
          <source>Sort the sequence by document values of the given key(s). To specify the ordering, wrap the attribute with either &lt;code&gt;r.asc&lt;/code&gt; or &lt;code&gt;r.desc&lt;/code&gt; (defaults to ascending).</source>
          <target state="translated">주어진 키의 문서 값에 따라 순서를 정렬하십시오. 순서를 지정하려면 &lt;code&gt;r.asc&lt;/code&gt; 또는 &lt;code&gt;r.desc&lt;/code&gt; (기본값은 오름차순)로 속성을 래핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="7901d66f07cf332523d69e3f926ea835572d11fb" translate="yes" xml:space="preserve">
          <source>Sorting functions passed to &lt;code&gt;orderBy&lt;/code&gt; must be deterministic. You cannot, for instance, order rows using the &lt;a href=&quot;../random/index&quot;&gt;random&lt;/a&gt; command. Using a non-deterministic function with &lt;code&gt;orderBy&lt;/code&gt; will raise a &lt;code&gt;ReqlQueryLogicError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;orderBy&lt;/code&gt; 에 전달 된 정렬 함수는 결정적이어야합니다. 예를 들어 &lt;a href=&quot;../random/index&quot;&gt;random&lt;/a&gt; 명령을 사용하여 행을 주문할 수 없습니다 . 와 비 결정적 함수를 사용 &lt;code&gt;orderBy&lt;/code&gt; 인상됩니다 &lt;code&gt;ReqlQueryLogicError&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ea8a4b203c7a70438b72d257427b2cfcb7f268ca" translate="yes" xml:space="preserve">
          <source>Sorting order</source>
          <target state="translated">정렬 순서</target>
        </trans-unit>
        <trans-unit id="dab5e101e385b9bc90149afad6561250f3d14abf" translate="yes" xml:space="preserve">
          <source>Sorting without an index requires the server to hold the sequence in memory, and is limited to 100,000 documents (or the setting of the &lt;code&gt;arrayLimit&lt;/code&gt; option for &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;). Sorting with an index can be done on arbitrarily large tables, or after a &lt;a href=&quot;../between/index&quot;&gt;between&lt;/a&gt; command using the same index. This applies to both secondary indexes and the primary key (e.g., &lt;code&gt;{index:'id'}&lt;/code&gt;).</source>
          <target state="translated">인덱스없이 정렬하려면 서버가 메모리에 시퀀스를 보유해야하며 100,000 개의 문서 (또는 &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; 의 &lt;code&gt;arrayLimit&lt;/code&gt; 옵션 설정)로 제한됩니다 . 인덱스를 사용한 정렬은 임의로 큰 테이블에서 또는 동일한 인덱스를 사용 하는 &lt;a href=&quot;../between/index&quot;&gt;사이&lt;/a&gt; 명령 후 수행 할 수 있습니다 . 이는 보조 인덱스와 기본 키 (예 &lt;code&gt;{index:'id'}&lt;/code&gt; ) 에 모두 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb6ec6ac44dc07a6b156451cfaf45f72f2ae2b6e" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;emergencyRepair&lt;/code&gt; with one of two string options:</source>
          <target state="translated">다음 두 문자열 옵션 중 하나를 사용하여 &lt;code&gt;emergencyRepair&lt;/code&gt; 를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e2ea144bfd6964140019a1eb9ee087345b4db18" translate="yes" xml:space="preserve">
          <source>Split points will not automatically be changed after table creation, which means that if the primary keys are unevenly distributed, shards may become unbalanced. However, the user can manually rebalance shards when necessary, as well as reconfigure tables with new sharding and replication settings. Users cannot set split points for shards manually.</source>
          <target state="translated">테이블 생성 후 분리 점은 자동으로 변경되지 않으므로 기본 키가 고르지 않게 분산되면 샤드의 균형이 맞지 않을 수 있습니다. 그러나 사용자는 필요할 때 샤드를 수동으로 재조정하고 새로운 샤딩 및 복제 설정으로 테이블을 재구성 할 수 있습니다. 사용자는 샤드의 분할 점을 수동으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b1c84e3e4d99951fca9f0d1fa4ec08eae18ef655" translate="yes" xml:space="preserve">
          <source>Splits a string into substrings. Splits on whitespace when called with no arguments. When called with a separator, splits on that separator. When called with a separator and a maximum number of splits, splits on that separator at most &lt;code&gt;max_splits&lt;/code&gt; times. (Can be called with &lt;code&gt;null&lt;/code&gt; as the separator if you want to split on whitespace while still specifying &lt;code&gt;max_splits&lt;/code&gt;.)</source>
          <target state="translated">문자열을 하위 문자열로 분할합니다. 인수없이 호출되면 공백으로 분할됩니다. 구분 기호로 호출하면 해당 구분 기호로 분할됩니다. 구분 기호와 최대 분할 수를 사용하여 호출하면 해당 구분 기호를 최대 &lt;code&gt;max_splits&lt;/code&gt; 번 까지 분할합니다 . &lt;code&gt;max_splits&lt;/code&gt; 를 지정하면서 공백으로 분할하려는 경우 구분 기호 로 &lt;code&gt;null&lt;/code&gt; 을 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aad90813842550742d376854c4564d0e0ee6d4e7" translate="yes" xml:space="preserve">
          <source>Start RethinkDB at system startup</source>
          <target state="translated">시스템 시작시 RethinkDB 시작</target>
        </trans-unit>
        <trans-unit id="f9f2f9177a8d7e05be7d153da2578fcbfbc850a7" translate="yes" xml:space="preserve">
          <source>Start a RethinkDB server</source>
          <target state="translated">RethinkDB 서버 시작</target>
        </trans-unit>
        <trans-unit id="95486e29d0190c040fcd314d3f50c1dbcf3ab1a4" translate="yes" xml:space="preserve">
          <source>Start monitoring the changefeed in one client:</source>
          <target state="translated">한 클라이언트에서 변경 피드 모니터링을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d43ccd49e58bb91b7b4cdd2c2060dd0955232eae" translate="yes" xml:space="preserve">
          <source>Start on system startup</source>
          <target state="translated">시스템 시작시 시작</target>
        </trans-unit>
        <trans-unit id="2fbe3f947d63c8589e6302b2e97c70001429bf28" translate="yes" xml:space="preserve">
          <source>Start the server</source>
          <target state="translated">서버를 시작</target>
        </trans-unit>
        <trans-unit id="9f8bb9939a14cfff47edd8071834d58be0a0cbf9" translate="yes" xml:space="preserve">
          <source>Start the server from a terminal window.</source>
          <target state="translated">터미널 창에서 서버를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="78a3bbf31dc69529206cdcb865e33f6e461a23d6" translate="yes" xml:space="preserve">
          <source>Start the server from the Windows command prompt.</source>
          <target state="translated">Windows 명령 프롬프트에서 서버를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2d4af8c2a3172fa7ad4ba56655af4716e0c909b4" translate="yes" xml:space="preserve">
          <source>Starting RethinkDB instances</source>
          <target state="translated">RethinkDB 인스턴스 시작</target>
        </trans-unit>
        <trans-unit id="c3c304eb5e15271a98ffd09a1430e6b519336201" translate="yes" xml:space="preserve">
          <source>Starting RethinkDB with the &lt;code&gt;proxy&lt;/code&gt; command turns a server into a &lt;em&gt;proxy node,&lt;/em&gt; which acts as a query router. This increases cluster performance by reducing intracluster traffic and, if you&amp;rsquo;re using changefeeds, de-duplicating feed messages.</source>
          <target state="translated">&lt;code&gt;proxy&lt;/code&gt; 명령으로 RethinkDB를 시작 하면 서버가 &lt;em&gt;프록시 노드&lt;/em&gt; 로 바뀌어 쿼리 라우터 역할을합니다. 이렇게하면 클러스터 내 트래픽이 줄어들고 변경 피드를 사용하는 경우 피드 메시지 중복 제거를 통해 클러스터 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="11477333db87f433e59f65e30ba16cd581824f79" translate="yes" xml:space="preserve">
          <source>Starting a cluster on multiple machines or VMs is even easier than starting it on a single machine, because you don&amp;rsquo;t have to worry about port and directory conflicts.</source>
          <target state="translated">포트 및 디렉토리 충돌에 대해 걱정할 필요가 없기 때문에 여러 머신 또는 VM에서 클러스터를 시작하는 것이 단일 머신에서 시작하는 것보다 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="317d49bb0215c341c0bb18c9da4c9a7908ce3acf" translate="yes" xml:space="preserve">
          <source>Starting the server</source>
          <target state="translated">서버 시작</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
