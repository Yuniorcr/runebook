<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angularjs">
    <body>
      <group id="angularjs">
        <trans-unit id="6df6e689423958b8b13ffb0a6a5742c72252b129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; refers to the current scope</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 는 현재 범위를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="6570b17255a636d66f9fa82bb833e5c0f7586e6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt;: (optional) override the scope.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; : (선택 사항) 범위를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="3ae667447104aaa6f9f5e76dfcf12ece25e6e761" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt;: The result of this expression will be bound to the model of the parent &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element. If not specified, &lt;code&gt;select&lt;/code&gt; expression will default to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; :이 표현식의 결과는 부모 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소 의 모델에 바인딩됩니다 . 지정하지 않으면 &lt;code&gt;select&lt;/code&gt; expression의 기본값은 &lt;code&gt;value&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78e458052a16c01b3670ea39bf0e5b65aeae45ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;label&lt;/code&gt;&lt;strong&gt;&lt;code&gt;disable when&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;disable&lt;/code&gt;&lt;strong&gt;&lt;code&gt;for&lt;/code&gt; &lt;code&gt;(&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;key&lt;/code&gt;&lt;strong&gt;&lt;code&gt;,&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;strong&gt;&lt;code&gt;) in&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;label&lt;/code&gt; &lt;strong&gt; &lt;code&gt;disable when&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;disable&lt;/code&gt; &lt;strong&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;key&lt;/code&gt; &lt;strong&gt; &lt;code&gt;,&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;strong&gt; &lt;code&gt;) in&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e0b61ae68ccf6a0fefe789619ae7c985ee70b82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;label&lt;/code&gt;&lt;strong&gt;&lt;code&gt;for (&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;key&lt;/code&gt;&lt;strong&gt;&lt;code&gt;,&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;strong&gt;&lt;code&gt;) in&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;label&lt;/code&gt; &lt;strong&gt; &lt;code&gt;for (&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;key&lt;/code&gt; &lt;strong&gt; &lt;code&gt;,&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;strong&gt; &lt;code&gt;) in&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca66b2e6ac07e7ca29ddae160544b3bc7b0ebca7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;label&lt;/code&gt;&lt;strong&gt;&lt;code&gt;for&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;label&lt;/code&gt;&lt;strong&gt;&lt;code&gt;for&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68502af231efc1bd12a7d337f6cf5a0798c290b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;label&lt;/code&gt;&lt;strong&gt;&lt;code&gt;group by&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;group&lt;/code&gt;&lt;strong&gt;&lt;code&gt;for&lt;/code&gt; &lt;code&gt;(&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;key&lt;/code&gt;&lt;strong&gt;&lt;code&gt;,&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;strong&gt;&lt;code&gt;) in&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;label&lt;/code&gt; &lt;strong&gt; &lt;code&gt;group by&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;group&lt;/code&gt; &lt;strong&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;key&lt;/code&gt; &lt;strong&gt; &lt;code&gt;,&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;strong&gt; &lt;code&gt;) in&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85b6c9eeacbfb84c2c4b45f9b1ff493799d0771f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slotName&lt;/code&gt;: (optional) the name of the slot to transclude. If falsy (e.g. &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;''&lt;/code&gt;) then the default transclusion is provided. The &lt;code&gt;$transclude&lt;/code&gt; function also has a method on it, &lt;code&gt;$transclude.isSlotFilled(slotName)&lt;/code&gt;, which returns &lt;code&gt;true&lt;/code&gt; if the specified slot contains content (i.e. one or more DOM nodes).</source>
          <target state="translated">&lt;code&gt;slotName&lt;/code&gt; : (선택 사항) 변환 할 슬롯의 이름입니다. 거짓 인 경우 (예 : &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;''&lt;/code&gt; ) 기본 변환이 제공됩니다. &lt;code&gt;$transclude&lt;/code&gt; 기능은 그것의 방법이 &lt;code&gt;$transclude.isSlotFilled(slotName)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 지정된 슬롯 콘텐츠 (이상 DOM 노드 즉, 하나)가 포함되어있는 경우.</target>
        </trans-unit>
        <trans-unit id="2d38932d58ae4db4450e491cc28b4e0e8782b480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stagger&lt;/code&gt; - A numeric time value representing the delay between successively animated elements (&lt;a href=&quot;../../nganimate#css-staggering-animations.html&quot;&gt;Click here to learn how CSS-based staggering works in ngAnimate.&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;stagger&lt;/code&gt; - 연속적으로 애니메이션 요소 사이의 지연 시간을 나타내는 숫자 시간 값 ( &lt;a href=&quot;../../nganimate#css-staggering-animations.html&quot;&gt;ngAnimate의 작품을 비틀 CSS 기반 방법을 알아 보려면 여기를 클릭하십시오.&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e831bf85661d4350f937ca1ee30582dab7b941fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staggerIndex&lt;/code&gt; - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a &lt;code&gt;stagger&lt;/code&gt; option value of &lt;code&gt;0.1&lt;/code&gt; is used then there will be a stagger delay of &lt;code&gt;600ms&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;staggerIndex&lt;/code&gt; -스 태거 항목을 나타내는 숫자 인덱스 (예 : 값 5는 스 태거의 여섯 번째 항목과 동일하므로 스 &lt;code&gt;stagger&lt;/code&gt; 옵션 값 &lt;code&gt;0.1&lt;/code&gt; 을 사용하는 경우 스 태거 지연이 &lt;code&gt;600ms&lt;/code&gt; 임)</target>
        </trans-unit>
        <trans-unit id="4b45e4978dcf7ce6b7b883c7dd98db8f0f80ca71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; - The method to start the animation. This will return a &lt;code&gt;Promise&lt;/code&gt; when called.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; - 애니메이션을 시작하는 방법입니다. 호출 하면 &lt;code&gt;Promise&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3cb9ccde0ec19acd597bd9145a2a92a9b69d53db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is called on either &lt;code&gt;mousedown&lt;/code&gt;, &lt;code&gt;touchstart&lt;/code&gt; or &lt;code&gt;pointerdown&lt;/code&gt;. After this event, &lt;code&gt;$swipe&lt;/code&gt; is watching for &lt;code&gt;touchmove&lt;/code&gt;, &lt;code&gt;mousemove&lt;/code&gt; or &lt;code&gt;pointermove&lt;/code&gt; events. These events are ignored until the total distance moved in either dimension exceeds a small threshold.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 는 &lt;code&gt;mousedown&lt;/code&gt; , &lt;code&gt;touchstart&lt;/code&gt; 또는 &lt;code&gt;pointerdown&lt;/code&gt; 에서 호출 됩니다. 이 이벤트 후 &lt;code&gt;$swipe&lt;/code&gt; 는 &lt;code&gt;touchmove&lt;/code&gt; , &lt;code&gt;mousemove&lt;/code&gt; 또는 &lt;code&gt;pointermove&lt;/code&gt; 이벤트를 감시 합니다. 이러한 이벤트는 한 차원에서 이동 한 총 거리가 작은 임계 값을 초과 할 때까지 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4470450130ac3b5e4842fb970bfa6aa99c71833c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stopPropagation&lt;/code&gt; - &lt;code&gt;{function=}&lt;/code&gt;: calling &lt;code&gt;stopPropagation&lt;/code&gt; function will cancel further event propagation (available only for events that were &lt;code&gt;$emit&lt;/code&gt;-ed).</source>
          <target state="translated">&lt;code&gt;stopPropagation&lt;/code&gt; - &lt;code&gt;{function=}&lt;/code&gt; : 호출 &lt;code&gt;stopPropagation&lt;/code&gt; 기능을하는 (만했다 이벤트를 더 이상 사용할 수있는 이벤트 전파를 취소합니다 &lt;code&gt;$emit&lt;/code&gt; -ed를).</target>
        </trans-unit>
        <trans-unit id="562f32dbb4ed76736045cbd8fdf38a6b2f9b9379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictDi&lt;/code&gt; - disable automatic function annotation for the application. This is meant to assist in finding bugs which break minified code. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strictDi&lt;/code&gt; - 응용 프로그램에 대한 자동 함수 주석을 비활성화합니다. 이는 축소 된 코드를 손상시키는 버그를 찾는 데 도움을주기위한 것입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7276b814226305e007944b2417ca4a18386b0d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;: An AngularJS expression. This expression will be evaluated against each item and the result will be used for sorting. For example, use &lt;code&gt;'label'&lt;/code&gt; to sort by a property called &lt;code&gt;label&lt;/code&gt; or &lt;code&gt;'label.substring(0, 3)'&lt;/code&gt; to sort by the first 3 characters of the &lt;code&gt;label&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : AngularJS 표현식. 이 표현식은 각 항목에 대해 평가되며 결과는 정렬에 사용됩니다. 예를 들어, 사용 &lt;code&gt;'label'&lt;/code&gt; 속성이라는 기준으로 정렬 할 &lt;code&gt;label&lt;/code&gt; 또는 &lt;code&gt;'label.substring(0, 3)'&lt;/code&gt; 의 첫 번째 3 자 정렬 기준으로 &lt;code&gt;label&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="87065c1b0a8c3b424a3bf885c83aec838ee244e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;: Evaluated as &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : &lt;a href=&quot;../../../guide/expression&quot;&gt;표현식으로&lt;/a&gt; 평가</target>
        </trans-unit>
        <trans-unit id="1f120efe592339b69657624de23eb491c8d1b860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;: The string is used for matching against the contents of the &lt;code&gt;array&lt;/code&gt;. All strings or objects with string properties in &lt;code&gt;array&lt;/code&gt; that match this string will be returned. This also applies to nested object properties. The predicate can be negated by prefixing the string with &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : 문자열은 &lt;code&gt;array&lt;/code&gt; 의 내용과 일치하는 데 사용 됩니다 . 이 문자열과 일치 하는 &lt;code&gt;array&lt;/code&gt; 문자열 속성이있는 모든 문자열 또는 객체 가 반환됩니다. 중첩 된 개체 속성에도 적용됩니다. 문자열 앞에 &lt;code&gt;!&lt;/code&gt; 를 붙여서 술어를 무시할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="0fac8b9ae85918a1b9bc8ddbaeca59ac4b4bdd0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;: execute using the rules as defined in &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : &lt;a href=&quot;../../../guide/expression&quot;&gt;expression에&lt;/a&gt; 정의 된 규칙을 사용하여 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="96c6e2cb8a41f3ff6df278ab114004a459396f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;: the controller instance</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : 컨트롤러 인스턴스</target>
        </trans-unit>
        <trans-unit id="94b44bd8ed432ec208416beb4e35097bab5affc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;DOMElement&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;DOMElement&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="910d44622a6107a3b19072bdef477ba5ae9f8f6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Number&lt;/code&gt;&lt;code&gt;Array.&amp;lt;string&amp;gt;&lt;/code&gt;&lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Number&lt;/code&gt;&lt;code&gt;Array.&amp;lt;string&amp;gt;&lt;/code&gt;&lt;code&gt;boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b0b56a1549a08913f8940eb735e9bc52b22b15a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object.&amp;lt;string&amp;gt;&lt;/code&gt;&lt;code&gt;Object.&amp;lt;Array.&amp;lt;string&amp;gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object.&amp;lt;string&amp;gt;&lt;/code&gt;&lt;code&gt;Object.&amp;lt;Array.&amp;lt;string&amp;gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52a43af812236606133b2286a90533aa1da9dce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0617274d3eb14a8dc52328b1796f76e5008bdb89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="333110296a642e5efb3711dbb16416e1cab4cf22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5c9c81312a04d037526e6aaf5a2317937e86260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b79898c77a9158ed9a3b37da256dd059ffe3c81c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;code&gt;function(string)=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9eaac284d7e4378b9085c54e3296234cdfaab404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;TrustedObject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;TrustedObject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c392a5b127563010af8428bead8b621d39ab9f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;TrustedResourceUrl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;TrustedResourceUrl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0841c37de01d8a9cca515bc654a12239afab25d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76df6b50f223f89d90393b827dfbded897257a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2797717466ee7c0a14d61e2cca32c8deba9e887a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function()&lt;/code&gt;&lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="895ee3aad440c5ee332da06917bd8f67a4bda274" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function(scope)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;function(scope)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6eae39d5eadf0ab32025ed06721ddcabd1fe903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;number&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f4b43f7a2cf03aecf02ecdf8aaa8da5e8670ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="746d33f90849146f5b6d6cb98d0e6d0c1d1bfd53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd29f8ef866a70b2bfb061ce2616ab1e279f7e87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;&lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt;&lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="158ce96b5b8e7c15256896a4b3412574b9b96c2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;structural&lt;/code&gt; - Indicates that the &lt;code&gt;ng-&lt;/code&gt; prefix will be added to the event class. Setting to &lt;code&gt;false&lt;/code&gt; or omitting will turn &lt;code&gt;ng-EVENT&lt;/code&gt; and &lt;code&gt;ng-EVENT-active&lt;/code&gt; in &lt;code&gt;EVENT&lt;/code&gt; and &lt;code&gt;EVENT-active&lt;/code&gt;. Unused if &lt;code&gt;event&lt;/code&gt; is omitted.</source>
          <target state="translated">&lt;code&gt;structural&lt;/code&gt; - &lt;code&gt;ng-&lt;/code&gt; 접두사가 이벤트 클래스에 추가됨을 나타냅니다 . 로 설정 &lt;code&gt;false&lt;/code&gt; 또는 켜집니다 생략 &lt;code&gt;ng-EVENT&lt;/code&gt; 하고 &lt;code&gt;ng-EVENT-active&lt;/code&gt; 의 &lt;code&gt;EVENT&lt;/code&gt; 및 &lt;code&gt;EVENT-active&lt;/code&gt; . &lt;code&gt;event&lt;/code&gt; 가 생략 되면 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8544943dc901d069323d20e2530a0add4888fae8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svg&lt;/code&gt; - The root nodes in the template are SVG elements (excluding &lt;code&gt;&amp;lt;math&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;svg&lt;/code&gt; - 템플릿의 루트 노드는 SVG 요소 ( &lt;code&gt;&amp;lt;math&amp;gt;&lt;/code&gt; 제외 )입니다.</target>
        </trans-unit>
        <trans-unit id="786046ffc4529a4e093a1303dfa9a1ee93ec701f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svgElements&lt;/code&gt;: This is similar to &lt;code&gt;htmlElements&lt;/code&gt;, but for SVG elements. This list is only taken into account if SVG is &lt;a href=&quot;%24sanitizeprovider#enableSvg.html&quot;&gt;enabled&lt;/a&gt; for &lt;code&gt;$sanitize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;svgElements&lt;/code&gt; : 이것은 &lt;code&gt;htmlElements&lt;/code&gt; 와 유사 하지만 SVG 요소의 경우입니다. 이 목록은 SVG가 &lt;code&gt;$sanitize&lt;/code&gt; 대해 &lt;a href=&quot;%24sanitizeprovider#enableSvg.html&quot;&gt;활성화 된&lt;/a&gt; 경우에만 고려됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9515e5426c7450b18d455b87febbca653c16d06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tAttrs&lt;/code&gt; - template attributes - Normalized list of attributes declared on this element shared between all directive compile functions.</source>
          <target state="translated">&lt;code&gt;tAttrs&lt;/code&gt; - 템플리트 속성-이 지시문에 선언 된 정규화 된 속성 목록은 모든 지시문 컴파일 기능간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="640b5f8f1c6fb750f1bcf0be926a6f7cccf24306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tElement&lt;/code&gt; - template element - The element where the directive has been declared. It is safe to do template transformation on the element and child elements only.</source>
          <target state="translated">&lt;code&gt;tElement&lt;/code&gt; - 템플릿 요소-지시문이 선언 된 요소입니다. 요소 및 하위 요소에 대해서만 템플리트 변환을 수행하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="72d0667731893a2127528a59238286dff75d5787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;targetScope&lt;/code&gt; - &lt;code&gt;{Scope}&lt;/code&gt;: the scope on which the event was &lt;code&gt;$emit&lt;/code&gt;-ed or &lt;code&gt;$broadcast&lt;/code&gt;-ed.</source>
          <target state="translated">&lt;code&gt;targetScope&lt;/code&gt; 는 - &lt;code&gt;{Scope}&lt;/code&gt; : 범위가되는 사건이었다 &lt;code&gt;$emit&lt;/code&gt; -ed 또는 &lt;code&gt;$broadcast&lt;/code&gt; -ed.</target>
        </trans-unit>
        <trans-unit id="d9d78aa42995096a3743024a59381d174315f3db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; &amp;ndash; &lt;code&gt;{(string|Function)=}&lt;/code&gt; &amp;ndash; html template as a string or a function that returns an html template as a string which should be used by &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; or &lt;a href=&quot;../../ng/directive/nginclude&quot;&gt;ngInclude&lt;/a&gt; directives. This property takes precedence over &lt;code&gt;templateUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; &amp;ndash; &lt;code&gt;{(string|Function)=}&lt;/code&gt; &amp;ndash; html 템플릿 문자열 또는 &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; 또는 &lt;a href=&quot;../../ng/directive/nginclude&quot;&gt;ngInclude&lt;/a&gt; 지시문에서 사용해야하는 문자열로 html 템플릿을 반환하는 함수입니다 . 이 속성은 &lt;code&gt;templateUrl&lt;/code&gt; 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="b847eeb83e71a1ccc9378c6a72a5b750311dd281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; &amp;ndash; &lt;code&gt;{string=|function()=}&lt;/code&gt; &amp;ndash; html template as a string or a function that returns an html template as a string which should be used as the contents of this component. Empty string by default.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; &amp;ndash; &lt;code&gt;{string=|function()=}&lt;/code&gt; &amp;ndash; 문자열로 HTML 템플릿 또는이 구성 요소의 내용으로 사용해야하는 문자열로 HTML 템플릿을 반환하는 함수. 기본적으로 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0429ae61ad47c1536dc730ee0afecadf00bc6957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;templateUrl&lt;/code&gt; &amp;ndash; &lt;code&gt;{(string|Function)=}&lt;/code&gt; &amp;ndash; path or function that returns a path to an html template that should be used by &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; &amp;ndash; &lt;code&gt;{(string|Function)=}&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../directive/ngview&quot;&gt;ngView에서&lt;/a&gt; 사용해야하는 html 템플릿의 경로를 반환하는 경로 또는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="1f165003a7442135289074eae552a6c8ec021d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;templateUrl&lt;/code&gt; &amp;ndash; &lt;code&gt;{string=|function()=}&lt;/code&gt; &amp;ndash; path or function that returns a path to an html template that should be used as the contents of this component.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; &amp;ndash; &lt;code&gt;{string=|function()=}&lt;/code&gt; &amp;ndash;이 구성 요소의 내용으로 사용해야하는 html 템플릿의 경로를 반환하는 경로 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ee42cbd3774e590fa40f0b97c140df868c1c1461" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;templateUrl&lt;/code&gt; can also be a function which returns the URL of an HTML template to be loaded and used for the directive. AngularJS will call the &lt;code&gt;templateUrl&lt;/code&gt; function with two parameters: the element that the directive was called on, and an &lt;code&gt;attr&lt;/code&gt; object associated with that element.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; 은 또한 지시문에로드되어 사용될 HTML 템플릿의 URL을 반환하는 함수일 수도 있습니다. AngularJS는 지시문이 호출 된 요소와 해당 요소와 관련된 &lt;code&gt;attr&lt;/code&gt; 객체의 두 매개 변수를 사용 하여 &lt;code&gt;templateUrl&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ea870e647b9ea89f6e12722c036f7bb3d691164f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;then(successCallback, [errorCallback], [notifyCallback])&lt;/code&gt; &amp;ndash; regardless of when the promise was or will be resolved or rejected, &lt;code&gt;then&lt;/code&gt; calls one of the success or error callbacks asynchronously as soon as the result is available. The callbacks are called with a single argument: the result or rejection reason. Additionally, the notify callback may be called zero or more times to provide a progress indication, before the promise is resolved or rejected.</source>
          <target state="translated">&lt;code&gt;then(successCallback, [errorCallback], [notifyCallback])&lt;/code&gt; -에 관계없이 약속이었다 또는 해결되거나 거부 될 때의, &lt;code&gt;then&lt;/code&gt; 비동기 적으로 즉시 결과를 사용할 수있게되면 성공 또는 오류 콜백 중 하나를 호출합니다. 콜백은 결과 또는 거부 사유라는 단일 인수로 호출됩니다. 또한, 통지가 해결되거나 거부되기 전에, 통지 콜백이 진행 표시를 제공하기 위해 0 회 이상 호출 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d443cc9d4071a44cd6714aa6913e16543351cdf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; for chaining</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 연결을 위해 이것을</target>
        </trans-unit>
        <trans-unit id="d2d6fd71723f49cd4579527a989629fb9d4d03d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeSecondsFormat&lt;/code&gt;: Defines if the &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;datetime-local&lt;/code&gt; types should show seconds and milliseconds. The option follows the format string of &lt;a href=&quot;../filter/date&quot;&gt;date filter&lt;/a&gt;. By default, the options is &lt;code&gt;undefined&lt;/code&gt; which is equal to &lt;code&gt;'ss.sss'&lt;/code&gt; (seconds and milliseconds). The other options are &lt;code&gt;'ss'&lt;/code&gt; (strips milliseconds), and &lt;code&gt;''&lt;/code&gt; (empty string), which strips both seconds and milliseconds. Note that browsers that support &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;datetime-local&lt;/code&gt; require the hour and minutes part of the time string, and may show the value differently in the user interface. &lt;a href=&quot;ngmodeloptions#formatting-the-value-of-time-and-datetime-local-.html&quot;&gt;See the example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;timeSecondsFormat&lt;/code&gt; : &lt;code&gt;time&lt;/code&gt; 및 &lt;code&gt;datetime-local&lt;/code&gt; 유형이 초와 밀리 초를 표시 해야하는지 여부를 정의합니다 . 옵션은 &lt;a href=&quot;../filter/date&quot;&gt;날짜 필터&lt;/a&gt; 의 형식 문자열을 따릅니다 . 기본적 으로 &lt;code&gt;'ss.sss'&lt;/code&gt; (초 및 밀리 초)와 같은 옵션은 &lt;code&gt;undefined&lt;/code&gt; 되어 있지 않습니다 . 다른 옵션은 &lt;code&gt;'ss'&lt;/code&gt; (스트립 밀리 초) 및 &lt;code&gt;''&lt;/code&gt; (빈 문자열)이며 초와 밀리 초를 모두 제거합니다. &lt;code&gt;time&lt;/code&gt; 및 &lt;code&gt;datetime-local&lt;/code&gt; 을 지원하는 브라우저 는 시간 문자열의 시간 및 분 부분을 필요로하며 사용자 인터페이스에서 값을 다르게 표시 할 수 있습니다. &lt;a href=&quot;ngmodeloptions#formatting-the-value-of-time-and-datetime-local-.html&quot;&gt;예를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="228f9fa9bef945471bcee9dc6f546084669857e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeStripZeroSeconds&lt;/code&gt;: Defines if the &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;datetime-local&lt;/code&gt; types should strip the seconds and milliseconds from the formatted value if they are zero. This option is applied after &lt;code&gt;timeSecondsFormat&lt;/code&gt;. This option can be used to make the formatting consistent over different browsers, as some browsers with support for &lt;code&gt;time&lt;/code&gt; will natively hide the milliseconds and seconds if they are zero, but others won't, and browsers that don't implement these input types will always show the full string. &lt;a href=&quot;ngmodeloptions#formatting-the-value-of-time-and-datetime-local-.html&quot;&gt;See the example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;timeStripZeroSeconds&lt;/code&gt; : &lt;code&gt;time&lt;/code&gt; 및 &lt;code&gt;datetime-local&lt;/code&gt; 유형이 0 인 경우 형식화 된 값에서 초와 밀리 초를 제거 해야하는지 여부를 정의합니다 . 이 옵션은 &lt;code&gt;timeSecondsFormat&lt;/code&gt; 후에 적용됩니다 . &lt;code&gt;time&lt;/code&gt; 을 지원하는 일부 브라우저 는 기본적으로 밀리 초와 초를 0으로 숨기지 만 다른 브라우저는 그렇지 않으며 이러한 입력 유형을 구현하지 않는 브라우저는 기본적으로 항상 전체 문자열을 표시하십시오. &lt;a href=&quot;ngmodeloptions#formatting-the-value-of-time-and-datetime-local-.html&quot;&gt;예를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8cf0b2913a0db255f8c2c6df6d233dc95a24ffc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timezone&lt;/code&gt;: Defines the timezone to be used to read/write the &lt;code&gt;Date&lt;/code&gt; instance in the model for &lt;code&gt;&amp;lt;input type=&quot;date&quot; /&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input type=&quot;time&quot; /&amp;gt;&lt;/code&gt;, ... . It understands UTC/GMT and the continental US time zone abbreviations, but for general use, use a time zone offset, for example, &lt;code&gt;'+0430'&lt;/code&gt; (4 hours, 30 minutes east of the Greenwich meridian) If not specified, the timezone of the browser will be used. Note that changing the timezone will have no effect on the current date, and is only applied after the next input / model change.</source>
          <target state="translated">&lt;code&gt;timezone&lt;/code&gt; : &lt;code&gt;&amp;lt;input type=&quot;date&quot; /&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;input type=&quot;time&quot; /&amp;gt;&lt;/code&gt; , ... 의 모델에서 &lt;code&gt;Date&lt;/code&gt; 인스턴스 를 읽고 쓰는 데 사용할 시간대를 정의합니다 . UTC / GMT와 미국 대륙 시간대 약어를 이해하지만 일반적으로 사용하는 경우 시간대 오프셋을 사용하십시오 (예 : &lt;code&gt;'+0430'&lt;/code&gt; (그리니치 자오선에서 동쪽으로 4 시간 30 분)) 브라우저가 사용됩니다. 시간대를 변경해도 현재 날짜에는 영향을 미치지 않으며 다음 입력 / 모델 변경 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1387f6c816d68d8c1111f49ddff0725feea9741e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to&lt;/code&gt; - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.</source>
          <target state="translated">&lt;code&gt;to&lt;/code&gt; -CSS 전환을 통해 애니메이션에 적용되는 끝 CSS 스타일 (키 / 값 객체)입니다.</target>
        </trans-unit>
        <trans-unit id="3d33e6e6f66d624736af3942dc236de0a529ac2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toJSON&lt;/code&gt;: It returns a simple object without any of the extra properties added as part of the Resource API. This object can be serialized through &lt;a href=&quot;../../ng/function/angular.tojson&quot;&gt;&lt;code&gt;angular.toJson&lt;/code&gt;&lt;/a&gt; safely without attaching AngularJS-specific fields. Notice that &lt;code&gt;JSON.stringify&lt;/code&gt; (and &lt;code&gt;angular.toJson&lt;/code&gt;) automatically use this method when serializing a Resource instance (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON%28%29_behavior&quot;&gt;MDN&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;toJSON&lt;/code&gt; : Resource API의 일부로 추가 속성이 추가되지 않은 간단한 객체를 반환합니다. 이 객체는 AngularJS 관련 필드를 첨부하지 않고도 &lt;a href=&quot;../../ng/function/angular.tojson&quot;&gt; &lt;code&gt;angular.toJson&lt;/code&gt; 을&lt;/a&gt; 통해 안전하게 직렬화 할 수 있습니다 . 것을 알 수 &lt;code&gt;JSON.stringify&lt;/code&gt; (그리고 &lt;code&gt;angular.toJson&lt;/code&gt; 는 자원 인스턴스 (참조 직렬화시) 자동으로이 방법을 사용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON%28%29_behavior&quot;&gt;MDN을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b268b94b454ee57eb30bc251dc84638c344e172e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trackexpr&lt;/code&gt;: Used when working with an array of objects. The result of this expression will be used to identify the objects in the array. The &lt;code&gt;trackexpr&lt;/code&gt; will most likely refer to the &lt;code&gt;value&lt;/code&gt; variable (e.g. &lt;code&gt;value.propertyName&lt;/code&gt;). With this the selection is preserved even when the options are recreated (e.g. reloaded from the server).</source>
          <target state="translated">&lt;code&gt;trackexpr&lt;/code&gt; : 객체 배열로 작업 할 때 사용됩니다. 이 표현식의 결과는 배열의 객체를 식별하는 데 사용됩니다. &lt;code&gt;trackexpr&lt;/code&gt; 는 거의 확실하게 참조 할 &lt;code&gt;value&lt;/code&gt; 변수 (예 : &lt;code&gt;value.propertyName&lt;/code&gt; ). 이 옵션을 사용하면 옵션을 다시 작성하더라도 (예 : 서버에서 다시로드) 선택 사항이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3f094ebe4b7290c61e9499ebb0b6c3b80541f847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transclude&lt;/code&gt; &amp;ndash; &lt;code&gt;{boolean=}&lt;/code&gt; &amp;ndash; whether &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;content transclusion&lt;/a&gt; is enabled. Disabled by default.</source>
          <target state="translated">&lt;code&gt;transclude&lt;/code&gt; &amp;ndash; &lt;code&gt;{boolean=}&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;컨텐츠 변환&lt;/a&gt; 사용 여부 입니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="847676ced2371e533c2148870bad52b1da205f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transclude&lt;/code&gt; - [&lt;em&gt;DEPRECATED&lt;/em&gt;!] A transclude linking function: &lt;code&gt;function(scope, cloneLinkingFn)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;transclude&lt;/code&gt; [- &lt;em&gt;불량한&lt;/em&gt; !]는 transclude 링크 함수 : &lt;code&gt;function(scope, cloneLinkingFn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65712ae8d4a77115277acd1f52e30f6601b939d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transcludeControllers&lt;/code&gt; - an object hash with keys that map controller names to a hash with the key &lt;code&gt;instance&lt;/code&gt;, which maps to the controller instance; if given, it will make the controllers available to directives on the compileNode:</source>
          <target state="translated">&lt;code&gt;transcludeControllers&lt;/code&gt; - 컨트롤러 인스턴스에 매핑되는 키 &lt;code&gt;instance&lt;/code&gt; 를 사용하여 컨트롤러 이름을 컨트롤러에 매핑하는 키가있는 객체 해시 . 주어진 경우, compileNode에서 지시문에 제어기를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="37d92d08b7ef416b01c5f305b2c61d07d365d9cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transcludeFn&lt;/code&gt; - A transclude linking function pre-bound to the correct transclusion scope. This is the same as the &lt;code&gt;$transclude&lt;/code&gt; parameter of directive controllers, see &lt;a href=&quot;%24compile#-controller-.html&quot;&gt;the controller section for details&lt;/a&gt;. &lt;code&gt;function([scope], cloneLinkingFn, futureParentElement)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;transcludeFn&lt;/code&gt; - 올바른 transclusion 범위에 사전 바인딩 된 transclude 연결 기능. 이것은 지시문 제어기 의 &lt;code&gt;$transclude&lt;/code&gt; 매개 변수 와 동일합니다 . &lt;a href=&quot;%24compile#-controller-.html&quot;&gt;세부 사항은 제어기 섹션을 참조하십시오&lt;/a&gt; . &lt;code&gt;function([scope], cloneLinkingFn, futureParentElement)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d16ff7ca5be8284ed85e6eb4694c10ec231342f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transcludeFn&lt;/code&gt; is a transclude linking function pre-bound to the correct transclusion scope.</source>
          <target state="translated">&lt;code&gt;transcludeFn&lt;/code&gt; 은 올바른 transclusion 범위에 미리 바인딩 된 transclude 연결 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ffb35396e95b58bb7c8f48a2fbe498f67c401065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transitionStyle&lt;/code&gt; - The raw CSS transition style that will be used (e.g. &lt;code&gt;1s linear all&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;transitionStyle&lt;/code&gt; - 사용될 원시 CSS 전환 스타일 (예 : &lt;code&gt;1s linear all&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="acb77224c6ceb61fd094da2474b6ea580eb395e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - the template will replace the directive's element.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 템플릿이 지시문 요소를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d1f524d3ded436a245165aaa4f109e71bf8b5f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - transclude the content (i.e. the child nodes) of the directive's element.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 지시어의 요소의 내용 (즉, 자식 노드) transclude.</target>
        </trans-unit>
        <trans-unit id="7564f800bc370a2796451ba70257f53a5325b839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if injector has given service.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인젝터가 서비스를 제공 한 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="0d4ccfa8d3922c854b6dd6344e7f34130ef1d616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;{enabled: true}&lt;/code&gt; - see &lt;a href=&quot;%24location#html5-mode.html&quot;&gt;HTML5 mode&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;{enabled: true}&lt;/code&gt; &lt;a href=&quot;%24location#html5-mode.html&quot;&gt;-HTML5 모드&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="af162df4dc94fd9daba3aafea0161c62a70863fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;: A shorthand for &lt;code&gt;function(actual, expected) { return angular.equals(actual, expected)}&lt;/code&gt;. This is essentially strict comparison of expected and actual.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; : &lt;code&gt;function(actual, expected) { return angular.equals(actual, expected)}&lt;/code&gt; 의 약자입니다 . 이것은 본질적으로 예상과 실제의 엄격한 비교입니다.</target>
        </trans-unit>
        <trans-unit id="fbe4c50fd0a9abce8570e4e958c2d4e2146509ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; are converted to &lt;code&gt;''&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 은 &lt;code&gt;''&lt;/code&gt; 로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c98b8e988d02e1ba1e97b4721ab935dd4f217c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateOn&lt;/code&gt;: string specifying which event should the input be bound to. You can set several events using an space delimited list. There is a special event called &lt;code&gt;default&lt;/code&gt; that matches the default events belonging to the control. These are the events that are bound to the control, and when fired, update the &lt;code&gt;$viewValue&lt;/code&gt; via &lt;code&gt;$setViewValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updateOn&lt;/code&gt; : 입력 할 이벤트를 지정하는 문자열입니다. 공백으로 구분 된 목록을 사용하여 여러 이벤트를 설정할 수 있습니다. 특별한 이벤트라고이 &lt;code&gt;default&lt;/code&gt; 컨트롤에 속하는 기본 이벤트를 일치합니다. 이는 컨트롤에 바인딩 된 이벤트이며 시작되면 &lt;code&gt;$viewValue&lt;/code&gt; 를 통해 &lt;code&gt;$setViewValue&lt;/code&gt; 를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="29d95699dd6c95d5464de3151d2264f965e177b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;urlErrorParamsEnabled&lt;/code&gt;&lt;strong&gt;{Boolean}&lt;/strong&gt; - Specifies wether the generated error url will contain the parameters of the thrown error. Disabling the parameters can be useful if the generated error url is very long.</source>
          <target state="translated">&lt;code&gt;urlErrorParamsEnabled&lt;/code&gt; &lt;strong&gt;{Boolean}&lt;/strong&gt; -생성 된 오류 URL에 발생 된 오류의 매개 변수가 포함 될지 여부를 지정합니다. 생성 된 오류 URL이 매우 긴 경우 매개 변수를 비활성화하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb74c0fa899bba332ead017a3a8b0909948754f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;: local variable which will refer to each item in the &lt;code&gt;array&lt;/code&gt; or each property value of &lt;code&gt;object&lt;/code&gt; during iteration.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; : &lt;code&gt;array&lt;/code&gt; 각 항목 또는 반복하는 동안 &lt;code&gt;object&lt;/code&gt; 각 속성 값을 참조하는 로컬 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="94509a804195595227a5cfe6a6953e645a82587d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variable in expression as alias_expression&lt;/code&gt; &amp;ndash; You can also provide an optional alias expression which will then store the intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message when a filter is active on the repeater, but the filtered result set is empty.</source>
          <target state="translated">&lt;code&gt;variable in expression as alias_expression&lt;/code&gt; &amp;ndash; 필터를 적용한 후 repeater의 중간 결과를 저장할 선택적 별명 표현식을 제공 할 수도 있습니다. 일반적으로 리피터에서 필터가 활성화되어 있지만 필터링 된 결과 세트가 비어있는 경우 특수 메시지를 렌더링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da0e272e8acc0a6195e3bcaf512b0a10321a73a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variable in expression track by tracking_expression&lt;/code&gt; &amp;ndash; You can also provide an optional tracking expression which can be used to associate the objects in the collection with the DOM elements. If no tracking expression is specified, ng-repeat associates elements by identity. It is an error to have more than one tracking expression value resolve to the same key. (This would mean that two distinct objects are mapped to the same DOM element, which is not possible.)</source>
          <target state="translated">&lt;code&gt;variable in expression track by tracking_expression&lt;/code&gt; &amp;ndash; 컬렉션의 객체를 DOM 요소와 연결하는 데 사용할 수있는 선택적 추적 표현식을 제공 할 수도 있습니다. 추적 표현식이 지정되지 않으면 ng-repeat는 요소를 ID로 연관시킵니다. 둘 이상의 추적 표현식 값이 동일한 키로 해석되는 것은 오류입니다. (이것은 두 개의 별개의 객체가 동일한 DOM 요소에 매핑되어 불가능하다는 것을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="92f234e3ec0cb367320a3a220f4b20ef2167912e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variable in expression&lt;/code&gt; &amp;ndash; where variable is the user defined loop variable and &lt;code&gt;expression&lt;/code&gt; is a scope expression giving the collection to enumerate.</source>
          <target state="translated">&lt;code&gt;variable in expression&lt;/code&gt; &amp;ndash; 여기서 variable은 사용자 정의 루프 변수이고 &lt;code&gt;expression&lt;/code&gt; 은 콜렉션에 열거 할 범위 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="334ac9044b19555f1050ecb68b25a14f4bb8c986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;which&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/KeyboardEvent/which&quot;&gt;which&lt;/a&gt; for keyboard events (keydown, keypress, and keyup).</source>
          <target state="translated">&lt;code&gt;which&lt;/code&gt; : &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/KeyboardEvent/which&quot;&gt;어떤&lt;/a&gt; 키보드 이벤트 (를 keyDown, 키 누름과의 keyup)합니다.</target>
        </trans-unit>
        <trans-unit id="1ac658084647c61610cc182b520bbea0c2f421a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt;: x-coordinates for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : X 좌표에 대한 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;된 MouseEvent&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e77c7788c746962515a474a5d749e1a79e210076" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt;: y-coordinates for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; : &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/TouchEvent&quot;&gt;TouchEvent의&lt;/a&gt; y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="c7e687c0043c071c6aece0047f6ecce75d19741c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yOffset&lt;/code&gt; can be specified in various ways:</source>
          <target state="translated">&lt;code&gt;yOffset&lt;/code&gt; 은 다양한 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a617d5ce788306d35a28f1b23deafa05516a552c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{'foo': 'bar'}&lt;/code&gt; results in &lt;code&gt;foo=bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{'foo': 'bar'}&lt;/code&gt; results in &lt;code&gt;foo=bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40f5e12482264d458011441d8acd229f0c146c27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{'foo': Date.now()}&lt;/code&gt; results in &lt;code&gt;foo=2015-04-01T09%3A50%3A49.262Z&lt;/code&gt; (&lt;code&gt;toISOString()&lt;/code&gt; and encoded representation of a Date object)</source>
          <target state="translated">&lt;code&gt;{'foo': Date.now()}&lt;/code&gt; results in &lt;code&gt;foo=2015-04-01T09%3A50%3A49.262Z&lt;/code&gt; (&lt;code&gt;toISOString()&lt;/code&gt; and encoded representation of a Date object)</target>
        </trans-unit>
        <trans-unit id="57485b09d81aab721ab707b73b044a684f8e5060" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{'foo': ['bar', 'baz']}&lt;/code&gt; results in &lt;code&gt;foo=bar&amp;amp;foo=baz&lt;/code&gt; (repeated key for each array element)</source>
          <target state="translated">&lt;code&gt;{'foo': ['bar', 'baz']}&lt;/code&gt; results in &lt;code&gt;foo=bar&amp;amp;foo=baz&lt;/code&gt; (repeated key for each array element)</target>
        </trans-unit>
        <trans-unit id="d3da24ed0f0d4b7cfaff7dad39818886793dbdd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{'foo': {'bar':'baz'}}&lt;/code&gt; results in &lt;code&gt;foo=%7B%22bar%22%3A%22baz%22%7D&lt;/code&gt; (stringified and encoded representation of an object)</source>
          <target state="translated">&lt;code&gt;{'foo': {'bar':'baz'}}&lt;/code&gt; results in &lt;code&gt;foo=%7B%22bar%22%3A%22baz%22%7D&lt;/code&gt; (stringified and encoded representation of an object)</target>
        </trans-unit>
        <trans-unit id="911108b4676c74e69e2c8a5425b9290805810576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{..., requireBase: true/false}&lt;/code&gt; (only affects HTML5 mode) - see &lt;a href=&quot;%24location#relative-links.html&quot;&gt;Relative links&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;{..., requireBase: true/false}&lt;/code&gt; (only affects HTML5 mode) - see &lt;a href=&quot;%24location#relative-links.html&quot;&gt;Relative links&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b318179a9e271f3e2ae88a0a62abd131b8304a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{..., rewriteLinks: true/false/'string'}&lt;/code&gt; (only affects HTML5 mode) - see &lt;a href=&quot;%24location#html-link-rewriting.html&quot;&gt;HTML link rewriting&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;{..., rewriteLinks: true/false/'string'}&lt;/code&gt; (only affects HTML5 mode) - see &lt;a href=&quot;%24location#html-link-rewriting.html&quot;&gt;HTML link rewriting&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54f251c1df022ee72aa09d55c18a4cad4642a15c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Array.&amp;lt;Object&amp;gt;}&lt;/code&gt; - route parameters extracted from the current &lt;code&gt;$location.path()&lt;/code&gt; by applying the current route</source>
          <target state="translated">&lt;code&gt;{Array.&amp;lt;Object&amp;gt;}&lt;/code&gt; - route parameters extracted from the current &lt;code&gt;$location.path()&lt;/code&gt; by applying the current route</target>
        </trans-unit>
        <trans-unit id="d55397a3691fb7f16c2b68ceccf09396cffff1e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Object.&amp;lt;string&amp;gt;}&lt;/code&gt; - route parameters extracted from the current &lt;code&gt;$location.path()&lt;/code&gt; by applying the current route templateUrl.</source>
          <target state="translated">&lt;code&gt;{Object.&amp;lt;string&amp;gt;}&lt;/code&gt; - route parameters extracted from the current &lt;code&gt;$location.path()&lt;/code&gt; by applying the current route templateUrl.</target>
        </trans-unit>
        <trans-unit id="5dd320208f2f8b6bd9bf61c72c4ecba3a9f5f0df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Object}&lt;/code&gt; - current &lt;code&gt;$location.search()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{Object}&lt;/code&gt; - current &lt;code&gt;$location.search()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2149ad1bd6c42b49cd543b148dfb2f6388d925cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{number=}&lt;/code&gt;&lt;code&gt;capacity&lt;/code&gt; &amp;mdash; turns the cache into LRU cache.</source>
          <target state="translated">&lt;code&gt;{number=}&lt;/code&gt;&lt;code&gt;capacity&lt;/code&gt; &amp;mdash; turns the cache into LRU cache.</target>
        </trans-unit>
        <trans-unit id="da407c21ae2fa7bb980f78d9a8da4ee25cc9f350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{object}&lt;/code&gt;&lt;code&gt;info()&lt;/code&gt; &amp;mdash; Returns id, size, and options of cache.</source>
          <target state="translated">&lt;code&gt;{object}&lt;/code&gt;&lt;code&gt;info()&lt;/code&gt; &amp;mdash; Returns id, size, and options of cache.</target>
        </trans-unit>
        <trans-unit id="3e3ad3b4a976be784d9931118a3ade95ac665494" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{string}&lt;/code&gt; - current &lt;code&gt;$location.path()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{string}&lt;/code&gt; - current &lt;code&gt;$location.path()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c522d995b45e3440f20bd443030478095e596984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;destroy()&lt;/code&gt; &amp;mdash; Removes references to this cache from $cacheFactory.</source>
          <target state="translated">&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;destroy()&lt;/code&gt; &amp;mdash; Removes references to this cache from $cacheFactory.</target>
        </trans-unit>
        <trans-unit id="e4a6fd63772f52f96e9f426f81d54c33fb4eb1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;remove({string} key)&lt;/code&gt; &amp;mdash; Removes a key-value pair from the cache.</source>
          <target state="translated">&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;remove({string} key)&lt;/code&gt; &amp;mdash; Removes a key-value pair from the cache.</target>
        </trans-unit>
        <trans-unit id="18479675af1aa11b86509fba5caaf0f831d9057b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;removeAll()&lt;/code&gt; &amp;mdash; Removes all cached values.</source>
          <target state="translated">&lt;code&gt;{void}&lt;/code&gt;&lt;code&gt;removeAll()&lt;/code&gt; &amp;mdash; Removes all cached values.</target>
        </trans-unit>
        <trans-unit id="1d36ed26057d8216f3c08e045608a09b11e71945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{{*}}&lt;/code&gt;&lt;code&gt;get({string} key)&lt;/code&gt; &amp;mdash; Returns cached value for &lt;code&gt;key&lt;/code&gt; or undefined for cache miss.</source>
          <target state="translated">&lt;code&gt;{{*}}&lt;/code&gt;&lt;code&gt;get({string} key)&lt;/code&gt; &amp;mdash; Returns cached value for &lt;code&gt;key&lt;/code&gt; or undefined for cache miss.</target>
        </trans-unit>
        <trans-unit id="a7970ce53d560ba63cd690ee2c2257e390612fa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{{*}}&lt;/code&gt;&lt;code&gt;put({string} key, {*} value)&lt;/code&gt; &amp;mdash; Puts a new key-value pair into the cache and returns it.</source>
          <target state="translated">&lt;code&gt;{{*}}&lt;/code&gt;&lt;code&gt;put({string} key, {*} value)&lt;/code&gt; &amp;mdash; Puts a new key-value pair into the cache and returns it.</target>
        </trans-unit>
        <trans-unit id="c158b45018b20241b7d64f0e6fb6c158205d5d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{{user.name}}&lt;/code&gt; matches the &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;interpolation directive&lt;/a&gt; and &lt;code&gt;ng-repeat&lt;/code&gt; matches the &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{{user.name}}&lt;/code&gt; matches the &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;interpolation directive&lt;/a&gt; and &lt;code&gt;ng-repeat&lt;/code&gt; matches the &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt; directive&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e726282d380a1534e9fad60131be5ac0b29e3297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;$index&lt;/em&gt;: This special property tracks the collection items by their index, and re-uses the DOM elements that match that index, e.g. &lt;code&gt;item in items track by $index&lt;/code&gt;. This can be used for a performance improvement if no unique identfier is available and the identity of the collection items cannot be easily computed. It also allows duplicates.</source>
          <target state="translated">&lt;em&gt;$index&lt;/em&gt;: This special property tracks the collection items by their index, and re-uses the DOM elements that match that index, e.g. &lt;code&gt;item in items track by $index&lt;/code&gt;. This can be used for a performance improvement if no unique identfier is available and the identity of the collection items cannot be easily computed. It also allows duplicates.</target>
        </trans-unit>
        <trans-unit id="a044b72eb8a0781c9343b5af12f792aab95c9bcb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(default: 0)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(default: 0)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e751ce11ad956dd90cd36a0afb9b0b1dcbe4b08c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(default: 2)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(default: 2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a816a476b72a253b7763dfcfe1c04c484bed8eaa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(default: false)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(default: false)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5362d88f02d84c0f6072e31087130279fa90f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(default: this)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(default: this)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98d2aadf95d2d40783636f5c4b85be8f3d958303" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(default: true)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(default: true)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cbb24e41dd32901d004d12d257493c3c5c0bda11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(optional)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(optional)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="754ecad7a95e3b7f4e5db644ceb0b025a5bf0881" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Accessing normalized attribute names:&lt;/em&gt; Directives like 'ngBind' can be expressed in many ways: 'ng:bind', &lt;code&gt;data-ng-bind&lt;/code&gt;, or 'x-ng-bind'. The attributes object allows for normalized access to the attributes.</source>
          <target state="translated">&lt;em&gt;정규화 된 속성 이름 액세스 :&lt;/em&gt; 'ngBind'와 같은 지시문은 'ng : bind', &lt;code&gt;data-ng-bind&lt;/code&gt; 또는 'x-ng-bind' 와 같은 여러 가지 방법으로 표현할 수 있습니다 . 속성 오브젝트는 속성에 대한 정규화 된 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e111c27e75a56741f56869876541081c8dedd0a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caveat&lt;/em&gt;: While regular expressions are powerful and offer great flexibility, their syntax (and all the inevitable escaping) makes them &lt;em&gt;harder to maintain&lt;/em&gt;. It's easy to accidentally introduce a bug when one updates a complex expression (imho, all regexes should have good test coverage). For instance, the use of &lt;code&gt;.&lt;/code&gt; in the regex is correct only in a small number of cases. A &lt;code&gt;.&lt;/code&gt; character in the regex used when matching the scheme or a subdomain could be matched against a &lt;code&gt;:&lt;/code&gt; or literal &lt;code&gt;.&lt;/code&gt; that was likely not intended. It is highly recommended to use the string patterns and only fall back to regular expressions as a last resort.</source>
          <target state="translated">&lt;em&gt;주의 사항&lt;/em&gt; : 정규식은 강력하고 유연성이 뛰어나지 만 구문 (및 모든 피할 수없는 이스케이프)을 사용하면 &lt;em&gt;유지 관리가 더 어렵습니다&lt;/em&gt; . 복잡한 표현을 업데이트 할 때 실수로 버그가 발생하기 쉽습니다 (임시, 모든 정규 표현식은 테스트 범위가 양호해야 함). 예를 들어 &lt;code&gt;.&lt;/code&gt; 정규 표현식의 경우 소수의 경우에만 정확합니다. &lt;code&gt;.&lt;/code&gt; 구성표 또는 하위 도메인과 일치 할 때 사용되는 정규식의 문자는 &lt;code&gt;:&lt;/code&gt; 또는 리터럴 과 일치 될 수 있습니다 &lt;code&gt;.&lt;/code&gt; 의도하지 않은 것 같습니다. 문자열 패턴을 사용하고 최후의 수단으로 정규식으로 만 넘어가는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e30982b90f66fca844979a6a9a4f7586be2a1a77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom Expression&lt;/em&gt;: It is possible to use any AngularJS expression to compute the tracking id, for example with a function, or using a property on the collection items. &lt;code&gt;item in items track by item.id&lt;/code&gt; is a typical pattern when the items have a unique identifier, e.g. database id. In this case the object identity does not matter. Two objects are considered equivalent as long as their &lt;code&gt;id&lt;/code&gt; property is same. Tracking by unique identifier is the most performant way and should be used whenever possible.</source>
          <target state="translated">&lt;em&gt;사용자 정의 표현식&lt;/em&gt; : AngularJS 표현식을 사용하여 추적 ID (예 : 함수 또는 콜렉션 항목의 특성 사용)를 계산할 수 있습니다. &lt;code&gt;item in items track by item.id&lt;/code&gt; 로 추적되는 항목의 항목은 항목 에 고유 식별자 (예 : 데이터베이스 ID)가있는 경우 일반적인 패턴입니다. 이 경우 객체 아이덴티티는 중요하지 않습니다. &lt;code&gt;id&lt;/code&gt; 속성이 동일한 한 두 객체는 ​​동등한 것으로 간주됩니다 . 고유 식별자로 추적하는 것이 가장 효과적인 방법이며 가능할 때마다 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb6033f7c259e56bf4d1d68342cdc278b40229d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Default tracking: $id()&lt;/em&gt;: &lt;code&gt;item in items&lt;/code&gt; is equivalent to &lt;code&gt;item in items track by $id(item)&lt;/code&gt;. This implies that the DOM elements will be associated by item identity in the collection.</source>
          <target state="translated">&lt;em&gt;기본 추적 : $ id ()&lt;/em&gt; : &lt;code&gt;item in items&lt;/code&gt; 은 &lt;code&gt;item in items track by $id(item)&lt;/code&gt; 과 같습니다 . 이는 DOM 요소가 컬렉션의 항목 ID로 연결됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b852f0315e4ce34566ab5c876166ae5f304785c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Directive inter-communication:&lt;/em&gt; All directives share the same instance of the attributes object which allows the directives to use the attributes object as inter directive communication.</source>
          <target state="translated">&lt;em&gt;지시문 상호 통신 :&lt;/em&gt; 모든 지시문은 지시문이 속성 오브젝트를 상호 지시문 통신으로 사용할 수 있도록하는 동일한 속성 오브젝트 인스턴스를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="dacb1691370dfd3920557255152348a22cf3b5d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This function is also published on window for easy access.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; :이 기능은 쉽게 액세스 할 수 있도록 창에도 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="b596967063bc267febec1b76dc2c374401a146b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This function is declared ONLY WHEN running tests with jasmine or mocha</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; :이 기능은 jasmine 또는 mocha로 테스트를 실행할 때만 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d3c19141a200045b21b9fcad67eb34dedcb2de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This is not an injectable instance, just a globally available function.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 이것은 주사 가능한 인스턴스가 아니라 전 세계적으로 사용 가능한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e8fbdfd4557770e7bbafe78d8a96bbbde024637b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: this is not an injectable instance, just a globally available mock class of &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 이것은 주사 가능한 인스턴스가 아니며 전 세계적으로 사용 가능한 모의 클래스 &lt;code&gt;Date&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ea949e8b6b51b83ce83927bd1d2ab8eed8069172" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Child links, buttons or other interactive controls must also be removed from the tab order.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 하위 링크, 버튼 또는 기타 대화식 컨트롤도 탭 순서에서 제거해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca1bdf6fca422a6f0c552750122a3a2b40e96654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This directive is only available in the &lt;code&gt;ng-csp&lt;/code&gt; and &lt;code&gt;data-ng-csp&lt;/code&gt; attribute form.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 지시문은 &lt;code&gt;ng-csp&lt;/code&gt; 및 &lt;code&gt;data-ng-csp&lt;/code&gt; 속성 형식으로 만 사용할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77a2682333273242b4c5e6bda8deff61d9bd60c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Observing interpolated attributes:&lt;/em&gt; Use &lt;code&gt;$observe&lt;/code&gt; to observe the value changes of attributes that contain interpolation (e.g. &lt;code&gt;src=&quot;{{bar}}&quot;&lt;/code&gt;). Not only is this very efficient but it's also the only way to easily get the actual value because during the linking phase the interpolation hasn't been evaluated yet and so the value is at this time set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;보간 된 속성 관찰 : &lt;/em&gt; &lt;code&gt;$observe&lt;/code&gt; 를 사용 하여 보간을 포함하는 속성의 값 변경을 관찰하십시오 (예 : &lt;code&gt;src=&quot;{{bar}}&quot;&lt;/code&gt; ). 이 단계는 매우 효율적일뿐만 아니라 연결 단계에서 보간이 아직 평가되지 않아 현재 값이 &lt;code&gt;undefined&lt;/code&gt; 로 설정되어 있기 때문에 실제 값을 쉽게 얻을 수있는 유일한 방법이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="5aae482cd8880389624b85fc425ae110f5121a77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Please note&lt;/em&gt;: The browser's &lt;a href=&quot;https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest&quot;&gt;Same Origin Policy&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt; policy apply in addition to this and may further restrict whether the template is successfully loaded. This means that without the right CORS policy, loading templates from a different domain won't work on all browsers. Also, loading templates from &lt;code&gt;file://&lt;/code&gt; URL does not work on some browsers.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 브라우저의 &lt;a href=&quot;https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest&quot;&gt;동일한 원본 정책&lt;/a&gt; 및 &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS (Cross-Origin Resource Sharing)&lt;/a&gt; 정책이 여기에 적용되며 템플릿이 성공적으로로드되는지 여부를 추가로 제한 할 수 있습니다. 즉, 올바른 CORS 정책이 없으면 다른 도메인에서 템플릿을로드하는 것이 모든 브라우저에서 작동하지는 않습니다. 또한 일부 브라우저에서는 &lt;code&gt;file://&lt;/code&gt; URL 에서 템플릿을로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8db5bad99fcd4bad5c64bc6f0cd52fe53c5671ef" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Supports interpolation:&lt;/em&gt; Interpolation attributes are assigned to the attribute object allowing other directives to read the interpolated value.</source>
          <target state="translated">&lt;em&gt;보간 지원 :&lt;/em&gt; 보간 속성이 속성 개체에 할당되어 다른 지시문이 보간 된 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d36f936e1ce70c281c0f3b29312665e6e0fa9952" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is fairly rare but could be the case if a third party library is injecting the markup.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이것은 매우 드물지만 타사 라이브러리가 마크 업을 주입하는 경우에 해당 될 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="366e250bee7007fcaea094681e23e7a415c9b803" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This method is essentially an alias of &lt;a href=&quot;%24flushpendingtasks&quot;&gt;&lt;code&gt;$flushPendingTasks&lt;/code&gt;&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 메소드는 기본적으로 &lt;a href=&quot;%24flushpendingtasks&quot;&gt; &lt;code&gt;$flushPendingTasks&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f0f567975629635167fbde2583ef0602afeaa7c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This method is essentially an alias of &lt;a href=&quot;%24verifynopendingtasks&quot;&gt;&lt;code&gt;$verifyNoPendingTasks&lt;/code&gt;&lt;/a&gt; (called with no arguments).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 메소드는 본질적으로 &lt;a href=&quot;%24verifynopendingtasks&quot;&gt; &lt;code&gt;$verifyNoPendingTasks&lt;/code&gt; &lt;/a&gt; 의 별명입니다 (인수없이 호출 됨).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3520b15297383cde81b70725936914a0e5c00b82" translate="yes" xml:space="preserve">
          <source>&lt;small id=&quot;drtvArray&quot;&gt;1. Multiple directives may be registered to the same selector/name&lt;/small&gt;</source>
          <target state="translated">&lt;small id=&quot;drtvArray&quot;&gt;1. 동일한 지시자 / 이름에 여러 지시문을 등록 할 수 있습니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="68b9d92a12caafebe3855b5e3346edcc26067843" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;ngclick&quot;&gt;ngClick&lt;/span&gt; and &lt;span id=&quot;ngdblclick&quot;&gt;ngDblclick&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;ngclick&quot;&gt;ngClick&lt;/span&gt; 및 &lt;span id=&quot;ngdblclick&quot;&gt;ngDblclick&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1f8e28fe31dc034c9871f375e6dfe2b703d202d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;'self'&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;'self'&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="015a1117f6703ba8bef821a627eaa71af0db5e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;...&lt;/strong&gt;: any additional properties from the options object when creating the cache.</source>
          <target state="translated">&lt;strong&gt;...&lt;/strong&gt;: any additional properties from the options object when creating the cache.</target>
        </trans-unit>
        <trans-unit id="a544b3a64559b2b7cd3fa3fe814e5954fe808a68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;action&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {string} &amp;ndash; The name of action. This name becomes the name of the method on your resource object.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;action&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {string} &amp;ndash; 조치 이름. 이 이름은 자원 객체의 메소드 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="f808f87280400577500827dc90a1f628ac1389e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean|Cache}&lt;/code&gt; &amp;ndash; A boolean value or object created with &lt;a href=&quot;../../ng/service/%24cachefactory&quot;&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;&lt;/a&gt; to enable or disable caching of the HTTP response. See &lt;a href=&quot;../../ng/service/%24http#caching.html&quot;&gt;$http Caching&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;cache&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean|Cache}&lt;/code&gt; &amp;ndash;HTTP 응답의 캐싱을 활성화 또는 비활성화하기 위해&lt;a href=&quot;../../ng/service/%24cachefactory&quot;&gt; &lt;code&gt;$cacheFactory&lt;/code&gt; &lt;/a&gt; 로만든 부울 값 또는 객체입니다. 자세한 정보는&lt;a href=&quot;../../ng/service/%24http#caching.html&quot;&gt; $ http 캐싱&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb11994b5e6616708f025693d6148ee298b90fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;cancellable&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; If true, the request made by a &quot;non-instance&quot; call will be cancelled (if not already completed) by calling &lt;code&gt;$cancelRequest()&lt;/code&gt; on the call's return value. Calling &lt;code&gt;$cancelRequest()&lt;/code&gt; for a non-cancellable or an already completed/cancelled request will have no effect.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;cancellable&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; true 인 경우 &quot;비 인스턴스&quot;호출에 의한 요청은 호출의 반환 값에서 &lt;code&gt;$cancelRequest()&lt;/code&gt; 를호출하여 취소됩니다 (아직 완료되지 않은 경우 ) . 취소 할 수 없거나 이미 완료 / 취소 된 요청에 대해 &lt;code&gt;$cancelRequest()&lt;/code&gt; 를호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d26a33190f844946474d7e0488694940a6da6635" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;cancellable&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {boolean} &amp;ndash; If true, the request made by a &quot;non-instance&quot; call will be cancelled (if not already completed) by calling &lt;code&gt;$cancelRequest()&lt;/code&gt; on the call's return value. This can be overwritten per action. (Defaults to false.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;cancellable&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {boolean} &amp;ndash; true 인 경우 &quot;비 인스턴스&quot;호출에 의한 요청은 호출의 반환 값에서 &lt;code&gt;$cancelRequest()&lt;/code&gt; 를호출하여 취소됩니다 (아직 완료되지 않은 경우 ) . 작업별로 덮어 쓸 수 있습니다. (기본값은 false입니다.)</target>
        </trans-unit>
        <trans-unit id="2aa9849f2fa96ee47a768e94764889dff2b45b78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.cache&lt;/code&gt;&lt;/strong&gt; - {boolean|Object} - A boolean value or object created with &lt;a href=&quot;../service/%24cachefactory&quot;&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;&lt;/a&gt; to enable or disable caching of HTTP responses by default. See &lt;a href=&quot;../service/%24http#caching.html&quot;&gt;$http Caching&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.cache&lt;/code&gt; -&lt;/strong&gt; {boolean | Object}-기본적으로 HTTP 응답 캐싱을 사용 또는 사용하지 않도록&lt;a href=&quot;../service/%24cachefactory&quot;&gt; &lt;code&gt;$cacheFactory&lt;/code&gt; &lt;/a&gt; 로작성된 부울 값 또는 객체입니다. 자세한 정보는&lt;a href=&quot;../service/%24http#caching.html&quot;&gt; $ http 캐싱&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26448d453ee4f5fa77860aaf5e8d2a0a8c02f8a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.headers.common&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;defaults.headers.common&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a19d9dca2d591347552c0f80f4943484d1fc595" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.headers.patch&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;defaults.headers.patch&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01250ad1bd780612d6896e760534ed4963daca0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.headers.post&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;defaults.headers.post&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3572907c9434da9a2cbd4aa1d71c3bcb51cc0c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.headers.put&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;defaults.headers.put&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cecf31eef476a01c594653984af1546d95027cac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.headers&lt;/code&gt;&lt;/strong&gt; - {Object} - Default headers for all $http requests. Refer to &lt;a href=&quot;../service/%24http#setting-http-headers.html&quot;&gt;$http&lt;/a&gt; for documentation on setting default headers.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.headers&lt;/code&gt; -&lt;/strong&gt; {Object}-모든 $ http 요청의 기본 헤더. 기본 헤더 설정에 대한 설명서는&lt;a href=&quot;../service/%24http#setting-http-headers.html&quot;&gt; $ http&lt;/a&gt; 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc36634214d9ac2415c40c2549f7de1cb60e3feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.jsonpCallbackParam&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - the name of the query parameter that passes the name of the callback in a JSONP request. The value of this parameter will be replaced with the expression generated by the &lt;a href=&quot;../service/%24jsonpcallbacks&quot;&gt;&lt;code&gt;$jsonpCallbacks&lt;/code&gt;&lt;/a&gt; service. Defaults to &lt;code&gt;'callback'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.jsonpCallbackParam&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - JSONP 요청에 콜백의 이름을 전달하는 쿼리 매개 변수의 이름입니다. 이 매개 변수의 값은&lt;a href=&quot;../service/%24jsonpcallbacks&quot;&gt; &lt;code&gt;$jsonpCallbacks&lt;/code&gt; &lt;/a&gt; 서비스에서 생성 된 표현식으로 대체됩니다. 기본값은 &lt;code&gt;'callback'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a58794246bb5fa501c3b1836a60304b9cf9bb59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.paramSerializer&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;{string|function(Object&amp;lt;string,string&amp;gt;):string}&lt;/code&gt; - A function used to the prepare string representation of request parameters (specified as an object). If specified as string, it is interpreted as a function registered with the &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;. Defaults to &lt;a href=&quot;../service/%24httpparamserializer&quot;&gt;$httpParamSerializer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.paramSerializer&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;{string|function(Object&amp;lt;string,string&amp;gt;):string}&lt;/code&gt; - (객체로 지정) 요청 파라미터의 제조 문자열 표현으로 사용하는 기능. 문자열로 지정하면&lt;a href=&quot;../../auto/service/%24injector&quot;&gt; $ injector에&lt;/a&gt; 등록 된 함수로 해석됩니다. 기본값은&lt;a href=&quot;../service/%24httpparamserializer&quot;&gt; $ httpParamSerializer&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="042a55b56f1a54d0925ee17b60cfc038408dcdb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.transformRequest&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;function(data, headersGetter)&amp;gt;|function(data, headersGetter)}&lt;/code&gt; - An array of functions (or a single function) which are applied to the request data. By default, this is an array with one request transformation function:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.transformRequest&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;function(data, headersGetter)&amp;gt;|function(data, headersGetter)}&lt;/code&gt; - 상기 요청 된 데이터에 적용되는 기능 (또는 단일 기능)의 배열. 기본적으로 이것은 하나의 요청 변환 함수가있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="be710c6b3bfc678c19bcab77b8a8b2eef9e9b20a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.transformResponse&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;function(data, headersGetter, status)&amp;gt;|function(data, headersGetter, status)}&lt;/code&gt; - An array of functions (or a single function) which are applied to the response data. By default, this is an array which applies one response transformation function that does two things:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.transformResponse&lt;/code&gt; &lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;function(data, headersGetter, status)&amp;gt;|function(data, headersGetter, status)}&lt;/code&gt; - 응답 데이터에 적용 함수의 어레이 (또는 단일 작용). 기본적으로 이것은 두 가지 작업을 수행하는 하나의 응답 변환 함수를 적용하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="4261b76b3fa76174bbb5b55b8872a690a00997de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.xsrfCookieName&lt;/code&gt;&lt;/strong&gt; - {string} - Name of cookie containing the XSRF token. Defaults value is &lt;code&gt;'XSRF-TOKEN'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.xsrfCookieName&lt;/code&gt; -&lt;/strong&gt; {string}-XSRF 토큰을 포함하는 쿠키의 이름입니다. 기본값은 &lt;code&gt;'XSRF-TOKEN'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8167ea5cadbe074374e2a50533eb74dc4f94fc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;defaults.xsrfHeaderName&lt;/code&gt;&lt;/strong&gt; - {string} - Name of HTTP header to populate with the XSRF token. Defaults value is &lt;code&gt;'X-XSRF-TOKEN'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;defaults.xsrfHeaderName&lt;/code&gt; -&lt;/strong&gt; {string}-XSRF 토큰으로 채울 HTTP 헤더의 이름입니다. 기본값은 &lt;code&gt;'X-XSRF-TOKEN'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b93d026301ec002f48aa1ac86163db37461abe45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;false&lt;/code&gt; (default):&lt;/strong&gt; No scope will be created for the directive. The directive will use its parent's scope.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;false&lt;/code&gt; (기본값) :&lt;/strong&gt; 지시문에 대한 범위가 만들어지지 않습니다. 지시문은 부모의 범위를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e9b13e113acd277b44549b14aae31153cec5b74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;hasBody&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; If true, then the request will have a body. If not specified, then only POST, PUT and PATCH requests will have a body. *</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;hasBody&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; true이면 요청에 본문이 있습니다. 지정하지 않으면 POST, PUT 및 PATCH 요청에만 본문이 있습니다. *</target>
        </trans-unit>
        <trans-unit id="d734241778e6e421ce70dbb15f7c7edc8059d04e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;interceptor&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object=}&lt;/code&gt; &amp;ndash; The interceptor object has four optional methods - &lt;code&gt;request&lt;/code&gt;, &lt;code&gt;requestError&lt;/code&gt;, &lt;code&gt;response&lt;/code&gt;, and &lt;code&gt;responseError&lt;/code&gt;. See &lt;a href=&quot;../../ng/service/%24http#interceptors.html&quot;&gt;$http interceptors&lt;/a&gt; for details. Note that &lt;code&gt;request&lt;/code&gt;/&lt;code&gt;requestError&lt;/code&gt; interceptors are applied before calling &lt;code&gt;$http&lt;/code&gt;, thus before any global &lt;code&gt;$http&lt;/code&gt; interceptors. Also, rejecting or throwing an error inside the &lt;code&gt;request&lt;/code&gt; interceptor will result in calling the &lt;code&gt;responseError&lt;/code&gt; interceptor. The resource instance or collection is available on the &lt;code&gt;resource&lt;/code&gt; property of the &lt;code&gt;http response&lt;/code&gt; object passed to &lt;code&gt;response&lt;/code&gt;/&lt;code&gt;responseError&lt;/code&gt; interceptors. Keep in mind that the associated promise will be resolved with the value returned by the response interceptors. Make sure you return an appropriate value and not the &lt;code&gt;response&lt;/code&gt; object passed as input. For reference, the default &lt;code&gt;response&lt;/code&gt; interceptor (which gets applied if you don't specify a custom one) returns &lt;code&gt;response.resource&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;interceptor&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object=}&lt;/code&gt; &amp;ndash; interceptor 오브젝트에는 &lt;code&gt;request&lt;/code&gt; , &lt;code&gt;requestError&lt;/code&gt; , &lt;code&gt;response&lt;/code&gt; 및 &lt;code&gt;responseError&lt;/code&gt; 의 네 가지 선택적 메소드가있습니다. 자세한 내용은&lt;a href=&quot;../../ng/service/%24http#interceptors.html&quot;&gt; $ http 인터셉터&lt;/a&gt; 를 참조하십시오. 주의 &lt;code&gt;request&lt;/code&gt; / &lt;code&gt;requestError&lt;/code&gt; 의 인터셉터를 호출하기 전에 적용 &lt;code&gt;$http&lt;/code&gt; 따라서 전역하기 전에, &lt;code&gt;$http&lt;/code&gt; 인터셉터. 또한 &lt;code&gt;request&lt;/code&gt; 인터셉터내에서 오류를 거부하거나 처리하면 &lt;code&gt;responseError&lt;/code&gt; 인터셉터가 호출됩니다. 자원 인스턴스 또는 수집은 볼 수 있습니다 &lt;code&gt;resource&lt;/code&gt; 의 특성 &lt;code&gt;http response&lt;/code&gt; 오브젝트가 &lt;code&gt;response&lt;/code&gt; / &lt;code&gt;responseError&lt;/code&gt; 인터셉터에 전달되었습니다 . 연관된 약속은 응답 인터셉터가 리턴 한 값으로 해결됩니다. 입력으로 전달 된 &lt;code&gt;response&lt;/code&gt; 오브젝트가 아닌 적절한 값을 리턴하십시오 . 참고로 기본 &lt;code&gt;response&lt;/code&gt; 인터셉터 (사용자 정의 인터셉터를 지정하지 않은 경우 적용됨)는 &lt;code&gt;response.resource&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e08864f200d427bae3213d382a4ee126b33b73be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isArray&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {boolean=} &amp;ndash; If true then the returned object for this action is an array, see &lt;code&gt;returns&lt;/code&gt; section.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;isArray&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {boolean =} &amp;ndash; true 인 경우이 조치에 대해 리턴 된 오브젝트는 배열입니다. &lt;code&gt;returns&lt;/code&gt; 섹션을참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c72d3596d9a1d4896c0d5cb60a5cd09bf5574ee5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;method&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {string} &amp;ndash; Case insensitive HTTP method (e.g. &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;JSONP&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;method&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {string} &amp;ndash; 대소 문자를 구분하지 않는 HTTP 메소드 (예 : &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;JSONP&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="aae376e10a8f77b6721b4bc1bf0c98819c82c0b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;params&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {Object=} &amp;ndash; Optional set of pre-bound parameters for this action. If any of the parameter value is a function, it will be called every time when a param value needs to be obtained for a request (unless the param was overridden). The function will be passed the current data value as an argument.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;params&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {Object =} &amp;ndash;이 조치에 대한 선택적 사전 바인딩 매개 변수 세트입니다. 매개 변수 값 중 하나가 함수 인 경우 요청에 대해 매개 변수 값을 가져와야 할 때마다 (매개 변수가 대체되지 않는 한) 호출됩니다. 함수는 현재 데이터 값을 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e667830ad1b6b97bb07009b7b43101e62855c36c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;responseType&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType&quot;&gt;XMLHttpRequest.responseType&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;responseType&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType&quot;&gt; XMLHttpRequest.responseType을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6f8bfd7bb40362c4448b97ea0540c59bda61b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;stripTrailingSlashes&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {boolean} &amp;ndash; If true then the trailing slashes from any calculated URL will be stripped. (Defaults to true.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;stripTrailingSlashes&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {boolean} &amp;ndash; true이면 계산 된 URL의 후행 슬래시가 제거됩니다. (기본값은 true입니다.)</target>
        </trans-unit>
        <trans-unit id="ee12f09df154c39b895e5f3233f8d96b41eb95d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{number}&lt;/code&gt; &amp;ndash; Timeout in milliseconds.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{number}&lt;/code&gt; &amp;ndash; 밀리 초 단위의 시간 초과.</target>
        </trans-unit>
        <trans-unit id="8860939df6552cef90fec239ad04c99010175f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;transformRequest&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter)|Array.&amp;lt;function(data, headersGetter)&amp;gt;}&lt;/code&gt; &amp;ndash; Transform function or an array of such functions. The transform function takes the http request body and headers and returns its transformed (typically serialized) version. By default, transformRequest will contain one function that checks if the request data is an object and serializes it using &lt;code&gt;angular.toJson&lt;/code&gt;. To prevent this behavior, set &lt;code&gt;transformRequest&lt;/code&gt; to an empty array: &lt;code&gt;transformRequest: []&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;transformRequest&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter)|Array.&amp;lt;function(data, headersGetter)&amp;gt;}&lt;/code&gt; &amp;ndash; 변환 함수 또는 이러한 함수의 배열. transform 함수는 http 요청 본문과 헤더를 가져와 변환 된 (일반적으로 직렬화 된) 버전을 반환합니다. 기본적으로 transformRequest에는 요청 데이터가 객체인지 확인하고 &lt;code&gt;angular.toJson&lt;/code&gt; 을 사용하여 직렬화하는 하나의 함수가 포함됩니다. 이 동작을 방지하려면 &lt;code&gt;transformRequest&lt;/code&gt; 를 빈 배열로 설정하십시오. &lt;code&gt;transformRequest: []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4b07be3a2acec82f0b9a59f65ad187c54cc4a40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;transformResponse&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter, status)|Array.&amp;lt;function(data, headersGetter, status)&amp;gt;}&lt;/code&gt; &amp;ndash; Transform function or an array of such functions. The transform function takes the HTTP response body, headers and status and returns its transformed (typically deserialized) version. By default, transformResponse will contain one function that checks if the response looks like a JSON string and deserializes it using &lt;code&gt;angular.fromJson&lt;/code&gt;. To prevent this behavior, set &lt;code&gt;transformResponse&lt;/code&gt; to an empty array: &lt;code&gt;transformResponse: []&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;transformResponse&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter, status)|Array.&amp;lt;function(data, headersGetter, status)&amp;gt;}&lt;/code&gt; &amp;ndash; 변환 함수 또는 이러한 함수의 배열. 변환 함수는 HTTP 응답 본문, 헤더 및 상태를 가져와 변환 된 (일반적으로 역 직렬화 된) 버전을 반환합니다. 기본적으로 transformResponse에는 응답이 JSON 문자열인지 확인하고 &lt;code&gt;angular.fromJson&lt;/code&gt; 을 사용하여 deserialize하는 함수가 하나 있습니다. 이 동작을 방지하려면 &lt;code&gt;transformResponse&lt;/code&gt; 를 빈 배열로 설정하십시오. &lt;code&gt;transformResponse: []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a0fb5bc58db9aba768f380cd413475c058f2676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;true&lt;/code&gt;:&lt;/strong&gt; A new child scope that prototypically inherits from its parent will be created for the directive's element. If multiple directives on the same element request a new scope, only one new scope is created.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;true&lt;/code&gt; :&lt;/strong&gt; 지시어 요소에 대해 부모에서 프로토 타입으로 상속되는 새로운 하위 범위가 작성됩니다. 동일한 요소에 여러 지시문이 새 범위를 요청하면 하나의 새 범위 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f954c335fa1c88b9e6f54185f3e45307c2692170" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;url&lt;/code&gt;&lt;/strong&gt; &amp;ndash; {string} &amp;ndash; Action specific &lt;code&gt;url&lt;/code&gt; override. The url templating is supported just like for the resource-level urls.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;url&lt;/code&gt; &lt;/strong&gt; &amp;ndash; {string} &amp;ndash; 작업 별 &lt;code&gt;url&lt;/code&gt; 재정의. URL 템플릿은 리소스 수준 URL과 마찬가지로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8282452aa2df4d7986a97ad42ae713ded09cdf66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Whether to set the &lt;code&gt;withCredentials&lt;/code&gt; flag on the XHR object. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;XMLHttpRequest.withCredentials&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash;XHR 객체에 &lt;code&gt;withCredentials&lt;/code&gt; 플래그를 설정할지 여부입니다. 자세한정보는&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; XMLHttpRequest.withCredentials&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5534420a1f0d70bfdf49536229b84023ea80de7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;{...}&lt;/code&gt; (an object hash):&lt;/strong&gt; - map elements of the content onto transclusion &quot;slots&quot; in the template.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;{...}&lt;/code&gt; (an object hash):&lt;/strong&gt; - map elements of the content onto transclusion &quot;slots&quot; in the template.</target>
        </trans-unit>
        <trans-unit id="71dd11f48572c56893f6273d285f51870813fbcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;{...}&lt;/code&gt; (an object hash):&lt;/strong&gt; A new &quot;isolate&quot; scope is created for the directive's template. The 'isolate' scope differs from normal scope in that it does not prototypically inherit from its parent scope. This is useful when creating reusable components, which should not accidentally read or modify data in the parent scope. Note that an isolate scope directive without a &lt;code&gt;template&lt;/code&gt; or &lt;code&gt;templateUrl&lt;/code&gt; will not apply the isolate scope to its children elements.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;{...}&lt;/code&gt; (an object hash):&lt;/strong&gt; A new &quot;isolate&quot; scope is created for the directive's template. The 'isolate' scope differs from normal scope in that it does not prototypically inherit from its parent scope. This is useful when creating reusable components, which should not accidentally read or modify data in the parent scope. Note that an isolate scope directive without a &lt;code&gt;template&lt;/code&gt; or &lt;code&gt;templateUrl&lt;/code&gt; will not apply the isolate scope to its children elements.</target>
        </trans-unit>
        <trans-unit id="55716f0cf97f955d54001576e8203120c29a8dd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Accessibility:&lt;/strong&gt;&lt;a href=&quot;guide/accessibility&quot;&gt;ngAria&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Accessibility:&lt;/strong&gt;&lt;a href=&quot;guide/accessibility&quot;&gt;ngAria&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32d5678c93da3911d14629087f800c16a9214e81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advanced Routing:&lt;/strong&gt;&lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;UI-Router&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;고급 라우팅 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;UI- 라우터&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ec468f4ccb9634ebf835fc9cc003046af4d82e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An application is a tree of components:&lt;/strong&gt; Ideally, the whole application should be a tree of components that implement clearly defined inputs and outputs, and minimize two-way data binding. That way, it's easier to predict when data changes and what the state of a component is.</source>
          <target state="translated">&lt;strong&gt;응용 프로그램은 구성 요소 트리입니다.&lt;/strong&gt; 이상적으로 전체 응용 프로그램은 명확하게 정의 된 입력 및 출력을 구현하고 양방향 데이터 바인딩을 최소화하는 구성 요소 트리 여야합니다. 이렇게하면 데이터가 변경되는 시점과 구성 요소의 상태를 예측하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="fc3cbfeb9923528544cefb117bda81db350ba626" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Analytics and Logging:&lt;/strong&gt;&lt;a href=&quot;http://ngmodules.org/modules/angularytics&quot;&gt;Angularytics (Google Analytics)&lt;/a&gt;, &lt;a href=&quot;https://github.com/luisfarzati/angulartics&quot;&gt;Angulartics (Analytics)&lt;/a&gt;, &lt;a href=&quot;http://www.bennadel.com/blog/2542-Logging-Client-Side-Errors-With-AngularJS-And-Stacktrace-js.htm&quot;&gt;Logging Client-Side Errors&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;분석 및 로깅 : &lt;/strong&gt;&lt;a href=&quot;http://ngmodules.org/modules/angularytics&quot;&gt;Angularytics (Google Analytics)&lt;/a&gt; , &lt;a href=&quot;https://github.com/luisfarzati/angulartics&quot;&gt;Angulartics (Analytics)&lt;/a&gt; , &lt;a href=&quot;http://www.bennadel.com/blog/2542-Logging-Client-Side-Errors-With-AngularJS-And-Stacktrace-js.htm&quot;&gt;클라이언트 측 오류 로깅&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4f6be7f6dde452ce0886e715bc87ec6823e4a1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animation:&lt;/strong&gt;&lt;a href=&quot;guide/animations&quot;&gt;Core concepts&lt;/a&gt;, &lt;a href=&quot;api/nganimate&quot;&gt;ngAnimate API&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;애니메이션 : &lt;/strong&gt;&lt;a href=&quot;guide/animations&quot;&gt;핵심 개념&lt;/a&gt; , &lt;a href=&quot;api/nganimate&quot;&gt;ngAnimate API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="278a6aea40fd074492b2bd66393c9b7aa694664a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Announcing changes&lt;/strong&gt;: When filtering or other UI messaging happens away from the user's focus, notify with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions&quot;&gt;ARIA Live Regions&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;변경 사항 발표&lt;/strong&gt; : 필터링 또는 기타 UI 메시징이 사용자의 초점에서 벗어난 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions&quot;&gt;ARIA Live Regions에&lt;/a&gt; 알리십시오 .</target>
        </trans-unit>
        <trans-unit id="4f18c14e214158a783463e0a863bdd40977505c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;App wiring:&lt;/strong&gt;&lt;a href=&quot;guide/di&quot;&gt;Dependency injection&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;앱 배선 : &lt;/strong&gt;&lt;a href=&quot;guide/di&quot;&gt;의존성 주입&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fb419a1909e8e3b534b459c7f7480b57df90a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attackers with local access can retrieve sensitive data from this cache even when users are not authenticated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;로컬 액세스 권한이있는 공격자는 사용자가 인증되지 않은 경우에도이 캐시에서 중요한 데이터를 검색 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0404b26fa72f75ae0a463aa6f030e67901db44fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Authentication/Login: &lt;/strong&gt;&lt;a href=&quot;https://developers.google.com/+/photohunt/python&quot;&gt;Google example&lt;/a&gt;, &lt;a href=&quot;https://github.com/pc035860/angular-easyfb&quot;&gt;AngularJS Facebook library&lt;/a&gt;, &lt;a href=&quot;http://blog.brunoscopelliti.com/facebook-authentication-in-your-angularjs-web-app&quot;&gt;Facebook example&lt;/a&gt;, &lt;a href=&quot;http://blog.brunoscopelliti.com/deal-with-users-authentication-in-an-angularjs-web-app&quot;&gt;authentication strategy&lt;/a&gt;, &lt;a href=&quot;http://frederiknakstad.com/authentication-in-single-page-applications-with-angular-js/&quot;&gt;unix-style authorization&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;인증 / 로그인 : &lt;/strong&gt;&lt;a href=&quot;https://developers.google.com/+/photohunt/python&quot;&gt;Google 예제&lt;/a&gt; , &lt;a href=&quot;https://github.com/pc035860/angular-easyfb&quot;&gt;AngularJS Facebook 라이브러리&lt;/a&gt; , &lt;a href=&quot;http://blog.brunoscopelliti.com/facebook-authentication-in-your-angularjs-web-app&quot;&gt;Facebook 예제&lt;/a&gt; , &lt;a href=&quot;http://blog.brunoscopelliti.com/deal-with-users-authentication-in-an-angularjs-web-app&quot;&gt;인증 전략&lt;/a&gt; , &lt;a href=&quot;http://frederiknakstad.com/authentication-in-single-page-applications-with-angular-js/&quot;&gt;유닉스 스타일 인증&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb41941bf9973471001e39b14773894e1600d9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Authentication:&lt;/strong&gt;&lt;a href=&quot;https://github.com/witoldsz/angular-http-auth&quot;&gt;Http Auth Interceptor&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;인증 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/witoldsz/angular-http-auth&quot;&gt;HTTP 인증 인터셉터&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3613cfafa439088ac45f401ceea5a3a7878004c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be aware that marking untrusted data as safe via calls to &lt;a href=&quot;../api/ng/service/%24sce#trustAsHtml.html&quot;&gt;&lt;code&gt;$sce.trustAsHtml&lt;/code&gt;&lt;/a&gt;, etc is dangerous and will lead to Cross Site Scripting exploits.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;../api/ng/service/%24sce#trustAsHtml.html&quot;&gt; &lt;code&gt;$sce.trustAsHtml&lt;/code&gt; &lt;/a&gt; 등에 대한 호출을 통해 신뢰할 수없는 데이터를 안전한 것으로 표시하는 것은 위험하며 크로스 사이트 스크립팅 악용으로 이어질 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d1565baa0d8c0800213288fd11e963f8abddc9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Any operation which can be shared among the instance of directives should be moved to the compile function for performance reasons.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 지시문 인스턴스간에 공유 할 수있는 모든 작업은 성능상의 이유로 컴파일 기능으로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="154a0af44d6ebb41a4e868d63cdb4d863d1d5ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Comment directives were commonly used in places where the DOM API limits the ability to create directives that spanned multiple elements (e.g. inside &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; elements). AngularJS 1.2 introduces &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ng-repeat-start&lt;/code&gt; and &lt;code&gt;ng-repeat-end&lt;/code&gt;&lt;/a&gt; as a better solution to this problem. Developers are encouraged to use this over custom comment directives when possible.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 주석 지시문은 일반적으로 DOM API가 여러 요소 (예 : &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소 내부)에 걸친 지시문 작성 기능을 제한하는 위치에서 사용되었습니다 . AngularJS 1.2는 이 문제에 대한 더 나은 솔루션으로 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ng-repeat-start&lt;/code&gt; 및 &lt;code&gt;ng-repeat-end&lt;/code&gt; &lt;/a&gt; 를 도입했습니다. 개발자는 가능할 때 사용자 정의 주석 지시문을 통해 이것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eec82de673765c49099d465321288990084a66d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Directives should clean up after themselves. You can use &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt; or &lt;code&gt;scope.$on('$destroy', ...)&lt;/code&gt; to run a clean-up function when the directive is removed.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 지시문 자체를 정리해야합니다. 당신은 사용할 수 있습니다 &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt; 나 &lt;code&gt;scope.$on('$destroy', ...)&lt;/code&gt; 이 지침이 제거 될 때 청소 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e208258b909cdfe75b3c3165f6e087ea396480bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; If you are working with objects that have a unique identifier property, you should track by this identifier instead of the object instance, e.g. &lt;code&gt;item in items track by item.id&lt;/code&gt;. Should you reload your data later, &lt;code&gt;ngRepeat&lt;/code&gt; will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 고유 식별자 속성이있는 객체를 사용하는 경우 &lt;code&gt;item in items track by item.id&lt;/code&gt; 과 같이 객체 인스턴스 대신이 식별자로 추적해야합니다 . 나중에 데이터를 다시로드 하면 컬렉션의 JavaScript 객체가 새로운 객체로 대체 된 경우에도 &lt;code&gt;ngRepeat&lt;/code&gt; 는 이미 렌더링 된 아이템에 대한 DOM 요소를 다시 빌드하지 않아도됩니다. 대규모 컬렉션의 경우 렌더링 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="b23c4bfb3b2b379e51d133233ee4beb35c63fb4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; If your app will be used only in one locale, it is fine to rely on the default currency symbol. If you anticipate that viewers in other locales might use your app, you should explicitly provide a currency symbol.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 앱이 한 로케일에서만 사용되는 경우 기본 통화 기호를 사용하는 것이 좋습니다. 다른 로케일의 뷰어가 앱을 사용할 것으로 예상되는 경우 명시 적으로 통화 기호를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="eaa374cd5f757d0f8bdee6a83204e711ef11c463" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; In order to avoid collisions with some future standard, it's best to prefix your own directive names. For instance, if you created a &lt;code&gt;&amp;lt;carousel&amp;gt;&lt;/code&gt; directive, it would be problematic if HTML7 introduced the same element. A two or three letter prefix (e.g. &lt;code&gt;btfCarousel&lt;/code&gt;) works well. Similarly, do not prefix your own directives with &lt;code&gt;ng&lt;/code&gt; or they might conflict with directives included in a future version of AngularJS.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 미래의 표준과의 충돌을 피하려면 고유 한 지시문 이름을 접두어로 사용하는 것이 가장 좋습니다. 예를 들어 &lt;code&gt;&amp;lt;carousel&amp;gt;&lt;/code&gt; 지시문 을 만든 경우 HTML7에서 동일한 요소를 도입하면 문제가됩니다. 두세 글자 접두사 (예 : &lt;code&gt;btfCarousel&lt;/code&gt; )가 잘 작동합니다. 마찬가지로, 고유 지시문 앞에 &lt;code&gt;ng&lt;/code&gt; 를 붙이지 마십시오 . 이후 버전의 AngularJS에 포함 된 지시문과 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91a547aa7a90f5913cc0361874deea48265913c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; It's best to keep getters fast because AngularJS is likely to call them more frequently than other parts of your code.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; AngularJS가 코드의 다른 부분보다 더 자주 호출하기 때문에 게터를 빠르게 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="562ae68aa5a7c95fda85899cccdcbaf4ca298e2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; It's recommended to use the &quot;directive definition object&quot; form.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; &quot;직접 정의 개체&quot;양식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7a47336f4b17a025f5af5052c3624880d8987c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Keep the filtering function as lean as possible, because it will be called for each DOM action (e.g. insertion, removal, class change) performed by &quot;animation-aware&quot; directives. See &lt;a href=&quot;../../../guide/animations#which-directives-support-animations-.html&quot;&gt;here&lt;/a&gt; for a list of built-in directives that support animations. Performing computationally expensive or time-consuming operations on each call of the filtering function can make your animations sluggish.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 필터링 기능은 &quot;애니메이션 인식&quot;지시문에 의해 수행되는 각 DOM 작업 (예 : 삽입, 제거, 클래스 변경)에 대해 호출되므로 최대한 간결하게 유지하십시오. 애니메이션을 지원하는 내장 지시문 목록은 &lt;a href=&quot;../../../guide/animations#which-directives-support-animations-.html&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . 필터링 함수를 호출 할 때마다 계산 비용이 많이 들거나 시간이 많이 걸리는 작업을 수행하면 애니메이션이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b89654abdc85c287788fb956a5415b67b03df9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Keep the filtering function as lean as possible, because it will be called for each DOM action (e.g. insertion, removal, class change) performed by &quot;animation-aware&quot; directives. See &lt;a href=&quot;animations#which-directives-support-animations-.html&quot;&gt;here&lt;/a&gt; for a list of built-in directives that support animations. Performing computationally expensive or time-consuming operations on each call of the filtering function can make your animations sluggish.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 필터링 기능은 &quot;애니메이션 인식&quot;지시문에 의해 수행되는 각 DOM 작업 (예 : 삽입, 제거, 클래스 변경)에 대해 호출되므로 최대한 간결하게 유지하십시오. 애니메이션을 지원하는 내장 지시문 목록은 &lt;a href=&quot;animations#which-directives-support-animations-.html&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . 필터링 함수를 호출 할 때마다 계산 비용이 많이 들거나 시간이 많이 걸리는 작업을 수행하면 애니메이션이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b204a0bc6447763a2a9eed14261cd6cb3e7bbf3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Prefer using directives via tag name and attributes over comment and class names. Doing so generally makes it easier to determine what directives a given element matches.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 주석 및 클래스 이름보다 태그 이름 및 속성을 통해 지시문을 사용하는 것이 좋습니다. 그렇게하면 일반적으로 주어진 요소가 어떤 지시문과 일치하는지 쉽게 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea37a8ba38693a6357c550cc3e8fed26616432d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Prefer using the dash-delimited format (e.g. &lt;code&gt;ng-bind&lt;/code&gt; for &lt;code&gt;ngBind&lt;/code&gt;). If you want to use an HTML validating tool, you can instead use the &lt;code&gt;data&lt;/code&gt;-prefixed version (e.g. &lt;code&gt;data-ng-bind&lt;/code&gt; for &lt;code&gt;ngBind&lt;/code&gt;). The other forms shown above are accepted for legacy reasons but we advise you to avoid them.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 대시로 구분 된 형식 (예 : &lt;code&gt;ngBind&lt;/code&gt; 의 경우 &lt;code&gt;ng-bind&lt;/code&gt; ) 을 사용하는 것이 좋습니다 . HTML 유효성 검사 도구를 사용하려면 대신 &lt;code&gt;data&lt;/code&gt; 접두사 버전 (예 : &lt;code&gt;ngBind&lt;/code&gt; 의 경우 &lt;code&gt;data-ng-bind&lt;/code&gt; ) 을 사용할 수 있습니다. 위에 표시된 다른 양식은 레거시 이유로 허용되지만 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1082802fce10851c5a44b53099be49c1bff97de3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Unless your template is very small, it's typically better to break it apart into its own HTML file and load it with the &lt;code&gt;templateUrl&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 템플릿이 매우 작은 경우가 아니면 일반적으로 템플릿을 자체 HTML 파일로 분리하여 &lt;code&gt;templateUrl&lt;/code&gt; 옵션 과 함께로드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a61c999a12dbbaaf9b15f01f05db8b33b1207d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; Use the &lt;code&gt;scope&lt;/code&gt; option to create isolate scopes when making components that you want to reuse throughout your app.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 사용 &lt;code&gt;scope&lt;/code&gt; 앱을 통해 다시 사용하려는 구성 요소를 만들 때 옵션을 분리 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf3ab3a718158f6dc5f57a13fa63897bb4d9a05c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; name the factory functions as &lt;code&gt;&amp;lt;serviceId&amp;gt;Factory&lt;/code&gt; (e.g., apiTokenFactory). While this naming convention is not required, it helps when navigating the codebase or looking at stack traces in the debugger.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 팩토리 기능의 이름을 &lt;code&gt;&amp;lt;serviceId&amp;gt;Factory&lt;/code&gt; (예 : apiTokenFactory)로 지정하십시오. 이 명명 규칙은 필요하지 않지만 디버거에서 코드베이스를 탐색하거나 스택 추적을 볼 때 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd01d844b7cc208ec811e4a8e61f854e64737953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; only use &lt;code&gt;transclude: true&lt;/code&gt; when you want to create a directive that wraps arbitrary content.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 임의의 내용을 래핑하는 지시문을 만들려면 &lt;code&gt;transclude: true&lt;/code&gt; 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dedb89ac35c7defeb1581c33c4fe4fc5e767eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; use &lt;code&gt;&amp;amp;attr&lt;/code&gt; in the &lt;code&gt;scope&lt;/code&gt; option when you want your directive to expose an API for binding to behaviors.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; 지시문이 동작에 바인딩하기 위해 API를 노출하도록 하려면 &lt;code&gt;scope&lt;/code&gt; 옵션 에서 &lt;code&gt;&amp;amp;attr&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="494ca317afa0a1c099d1ccb6267751ae377ac8af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice:&lt;/strong&gt; use &lt;code&gt;controller&lt;/code&gt; when you want to expose an API to other directives. Otherwise use &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;모범 사례 :&lt;/strong&gt; API를 다른 지시문에 노출하려는 경우 &lt;code&gt;controller&lt;/code&gt; 사용하십시오 . 그렇지 않으면 &lt;code&gt;link&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="afc296414277849789c9310271d222c899f7860a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice&lt;/strong&gt;: Always provide a &lt;code&gt;cloneFn&lt;/code&gt; (clone attach function) when you call a transclude function since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.</source>
          <target state="translated">&lt;strong&gt;모범 사례&lt;/strong&gt; : &lt;code&gt;cloneFn&lt;/code&gt; 함수를 호출 할 때 항상 원본 DOM의 새로운 복제본을 가져오고 새로운 transclusion 범위에 액세스 할 수 있으므로 항상 cloneFn (복제 연결 함수)을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="539e490e5b11ba68c8d7a1e07354c117dea53cef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Practice&lt;/strong&gt;: if you intend to add and remove transcluded content manually in your directive (by calling the transclude function to get the DOM and calling &lt;code&gt;element.remove()&lt;/code&gt; to remove it), then you are also responsible for calling &lt;code&gt;$destroy&lt;/code&gt; on the transclusion scope.</source>
          <target state="translated">&lt;strong&gt;모범 사례&lt;/strong&gt; : 지시문에서 변환 된 컨텐츠를 수동으로 추가 및 제거하려는 경우 (DOM을 가져 오기 위해 transclude 함수를 호출 하고이를 제거하기 위해 &lt;code&gt;element.remove()&lt;/code&gt; 를 호출 하여), 또한 transclusion에서 &lt;code&gt;$destroy&lt;/code&gt; 를 호출해야합니다. 범위.</target>
        </trans-unit>
        <trans-unit id="bb5ccbde708321e45669e8a636a6ff900cf5b928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bootstrap:&lt;/strong&gt;&lt;a href=&quot;guide/bootstrap&quot;&gt;Bootstrapping an app&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;부트 스트랩 : &lt;/strong&gt;&lt;a href=&quot;guide/bootstrap&quot;&gt;앱 부트 스트랩&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab44cfa01ef866a58f7f9728eb8d0893aec0fc94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Careful:&lt;/strong&gt; If you plan to &lt;a href=&quot;http://en.wikipedia.org/wiki/Minification_(programming)&quot;&gt;minify&lt;/a&gt; your code, your service names will get renamed and break your app.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 코드 를 &lt;a href=&quot;http://en.wikipedia.org/wiki/Minification_(programming)&quot;&gt;축소&lt;/a&gt; 하려는 경우 서비스 이름이 바뀌고 앱이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="56179cbf2aff90b5b65d0a399af34f3432b2cd0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Color contrast and scale&lt;/strong&gt;: Make sure content is legible and interactive controls are usable at all screen sizes. Consider configurable UI themes for people with color blindness, low vision or other visual impairments.</source>
          <target state="translated">&lt;strong&gt;색상 대비 및 배율&lt;/strong&gt; : 모든 화면 크기에서 내용을 읽을 수 있고 대화 형 컨트롤을 사용할 수 있는지 확인하십시오. 색맹, 시력 저하 또는 기타 시각 장애가있는 사용자를 위해 구성 가능한 UI 테마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ac547823d94131b4d29fe5107223764e7946bf5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Communicating with servers:&lt;/strong&gt;&lt;a href=&quot;api/ng/service/%24http&quot;&gt;$http&lt;/a&gt;, &lt;a href=&quot;api/ngresource/service/%24resource&quot;&gt;$resource&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;서버와의 통신 : &lt;/strong&gt;&lt;a href=&quot;api/ng/service/%24http&quot;&gt;$ http&lt;/a&gt; , &lt;a href=&quot;api/ngresource/service/%24resource&quot;&gt;$ resource&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33029029bed4b443c712a3a281f8467c8da8dfc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compile:&lt;/strong&gt; traverse the DOM and collect all of the directives. The result is a linking function.</source>
          <target state="translated">&lt;strong&gt;컴파일 :&lt;/strong&gt; DOM을 순회하고 모든 지시문을 수집하십시오. 결과는 연결 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0c95db3b1f38a8001b8fcd9ace33e6cdea0243f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components have a well-defined lifecycle:&lt;/strong&gt; Each component can implement &quot;lifecycle hooks&quot;. These are methods that will be called at certain points in the life of the component. The following hook methods can be implemented:</source>
          <target state="translated">&lt;strong&gt;구성 요소에는 수명주기가 잘 정의되어&lt;/strong&gt; 있습니다 &lt;strong&gt;.&lt;/strong&gt; 각 구성 요소는 &quot;수명주기 후크&quot;를 구현할 수 있습니다. 이것들은 구성 요소 수명의 특정 시점에서 호출되는 메소드입니다. 다음과 같은 후크 메소드를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc33ce1740fb347751434152e84b19712b1a8f47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components have a well-defined public API - Inputs and Outputs:&lt;/strong&gt; However, scope isolation only goes so far, because AngularJS uses two-way binding. So if you pass an object to a component like this - &lt;code&gt;bindings: {item: '='}&lt;/code&gt;, and modify one of its properties, the change will be reflected in the parent component. For components however, only the component that owns the data should modify it, to make it easy to reason about what data is changed, and when. For that reason, components should follow a few simple conventions:</source>
          <target state="translated">&lt;strong&gt;컴포넌트에는 잘 정의 된 퍼블릭 API-입력 및 출력이 있습니다.&lt;/strong&gt; 그러나 AngularJS는 양방향 바인딩을 사용하므로 스코프 격리는 지금까지만 진행됩니다. 따라서 &lt;code&gt;bindings: {item: '='}&lt;/code&gt; 과 같은 구성 요소에 객체를 전달하고 해당 속성 중 하나를 수정하면 변경 사항이 상위 구성 요소에 반영됩니다. 그러나 구성 요소의 경우 데이터를 변경 한 구성 요소와시기를 쉽게 추론 할 수 있도록 데이터를 소유 한 구성 요소 만 수정해야합니다. 따라서 구성 요소는 몇 가지 간단한 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="fdbc3c0b82f0fdd2e38b13e622456e7527414d41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components only control their own View and Data:&lt;/strong&gt; Components should never modify any data or DOM that is out of their own scope. Normally, in AngularJS it is possible to modify data anywhere in the application through scope inheritance and watches. This is practical, but can also lead to problems when it is not clear which part of the application is responsible for modifying the data. That is why component directives use an isolate scope, so a whole class of scope manipulation is not possible.</source>
          <target state="translated">&lt;strong&gt;구성 요소는 자신의보기 및 데이터 만 제어합니다.&lt;/strong&gt; 구성 요소는 자체 범위를 벗어난 데이터 또는 DOM을 수정해서는 안됩니다. 일반적으로 AngularJS에서는 범위 상속 및 시계를 통해 응용 프로그램의 모든 위치에서 데이터를 수정할 수 있습니다. 이는 실용적이지만 응용 프로그램에서 데이터 수정을 담당하는 부분이 확실하지 않은 경우 문제가 발생할 수 있습니다. 따라서 구성 요소 지시문이 분리 범위를 사용하므로 전체 범위 조작이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ea5024441518186f1d8d19e15ff04550168838b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Context:&lt;/strong&gt; JavaScript expressions are evaluated against the global &lt;code&gt;window&lt;/code&gt;. In AngularJS, expressions are evaluated against a &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;strong&gt;컨텍스트 :&lt;/strong&gt; JavaScript 표현식은 전역 &lt;code&gt;window&lt;/code&gt; 에 대해 평가 됩니다. AngularJS에서 표현식은 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 객체 에 대해 평가 됩니다.</target>
        </trans-unit>
        <trans-unit id="25b9d3e57b4590062259c3449266ebe5e34703c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller Definition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨트롤러 정의 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4eb25f46c9ed2a0a0131f2096bc9e0ff89ef620" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Controller Test:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컨트롤러 테스트 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d21e7e084fc25e99d1555970d47ff8a6c8ffc4a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Creation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15196e2bb706cf7a298552f36e5aa63a4fa9578" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom directives to access the DOM&lt;/strong&gt;: In AngularJS, the only place where an application should access the DOM is within directives. This is important because artifacts that access the DOM are hard to test. If you need to access the DOM directly you should write a custom directive for this. The &lt;a href=&quot;directive&quot;&gt;directives guide&lt;/a&gt; explains how to do this.</source>
          <target state="translated">&lt;strong&gt;DOM에 액세스하기위한 사용자 지정 지시문&lt;/strong&gt; : AngularJS에서 응용 프로그램이 DOM에 액세스해야하는 유일한 위치는 지시문 내에 있습니다. 이는 DOM에 액세스하는 아티팩트를 테스트하기 어렵 기 때문에 중요합니다. DOM에 직접 액세스해야하는 경우이를위한 사용자 지정 지시문을 작성해야합니다. &lt;a href=&quot;directive&quot;&gt;지침 가이드는&lt;/a&gt; 이 작업을 수행하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="05f7e5084b082e3e86f79e93392adf8dab0cd628" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data Handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터 처리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cdcaa96f16edae165b34c183a8af244b806db88b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Debugging:&lt;/strong&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en&quot;&gt;Batarang&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Debugging:&lt;/strong&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en&quot;&gt;Batarang&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcc6d0189a9829bde92474bed45b16ba9f9f0224" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Deprecated:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3b88a22e2271f42fe87df0e187227576e5a9612" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt;(since 1.6.5)</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; (1.6.5부터)</target>
        </trans-unit>
        <trans-unit id="b336024f1362b00347db2024e13812fdfef548d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt;(since 1.7.0)</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 1.7.0부터</target>
        </trans-unit>
        <trans-unit id="9115d2a2f5f4763c5242dee073391a13ca26deff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt;(since 1.7.3)</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 1.7.3부터</target>
        </trans-unit>
        <trans-unit id="9962f993ae5f02cb5239548a1e42a4a3f263c7c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Django:&lt;/strong&gt;&lt;a href=&quot;http://blog.mourafiq.com/post/55034504632/end-to-end-web-app-with-django-rest-framework&quot;&gt;Tutorial&lt;/a&gt;, &lt;a href=&quot;http://django-angular.readthedocs.org/en/latest/integration.html&quot;&gt;Integrating AngularJS with Django&lt;/a&gt;, &lt;a href=&quot;http://blog.kevinastone.com/getting-started-with-django-rest-framework-and-angularjs.html&quot;&gt;Getting Started with Django Rest Framework and AngularJS&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Django : &lt;/strong&gt;&lt;a href=&quot;http://blog.mourafiq.com/post/55034504632/end-to-end-web-app-with-django-rest-framework&quot;&gt;튜토리얼&lt;/a&gt; , &lt;a href=&quot;http://django-angular.readthedocs.org/en/latest/integration.html&quot;&gt;AngularJS와 Django 통합&lt;/a&gt; , &lt;a href=&quot;http://blog.kevinastone.com/getting-started-with-django-rest-framework-and-angularjs.html&quot;&gt;Django Rest Framework 및 AngularJS 시작하기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ea0aaeacdcb99323968249d0f4da6d418a46a63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this property to attempt to modify the modules after the application has been bootstrapped.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;응용 프로그램이 부트 스트랩 된 후이 특성을 사용하여 모듈을 수정하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35c64fc4414905e1dac355fee722a3b4f7563854" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editor support:&lt;/strong&gt;&lt;a href=&quot;http://plugins.jetbrains.com/plugin/6971&quot;&gt;Webstorm&lt;/a&gt; (and &lt;a href=&quot;http://www.youtube.com/watch?v=LJOyrSh1kDU&quot;&gt;video&lt;/a&gt;), &lt;a href=&quot;https://github.com/angular-ui/AngularJS-sublime-package&quot;&gt;Sublime Text&lt;/a&gt;, &lt;a href=&quot;http://madskristensen.net/post/angularjs-intellisense-in-visual-studio-2012&quot;&gt;Visual Studio&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular-ui/AngularJS-Atom&quot;&gt;Atom&lt;/a&gt;, &lt;a href=&quot;https://github.com/burnettk/vim-angular&quot;&gt;Vim&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;에디터 지원 : &lt;/strong&gt;&lt;a href=&quot;http://plugins.jetbrains.com/plugin/6971&quot;&gt;Webstorm&lt;/a&gt; (및 &lt;a href=&quot;http://www.youtube.com/watch?v=LJOyrSh1kDU&quot;&gt;비디오&lt;/a&gt; ), &lt;a href=&quot;https://github.com/angular-ui/AngularJS-sublime-package&quot;&gt;Sublime Text&lt;/a&gt; , &lt;a href=&quot;http://madskristensen.net/post/angularjs-intellisense-in-visual-studio-2012&quot;&gt;Visual Studio&lt;/a&gt; , &lt;a href=&quot;https://github.com/angular-ui/AngularJS-Atom&quot;&gt;Atom&lt;/a&gt; , &lt;a href=&quot;https://github.com/burnettk/vim-angular&quot;&gt;Vim&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c918741e4ebe8c6f874a77e7b6b027496a491b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;End-to-End Testing:&lt;/strong&gt;&lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt;, &lt;a href=&quot;guide/e2e-testing&quot;&gt;e2e testing guide&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;엔드 투 엔드 테스트 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;각도기&lt;/a&gt; , &lt;a href=&quot;guide/e2e-testing&quot;&gt;e2e 테스트 안내서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eb90a61d13dbb1be010d1d795ccea91ff166125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;: Consider the following case.</source>
          <target state="translated">&lt;strong&gt;예&lt;/strong&gt; : 다음과 같은 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e6ff57a661932efb3d4a52d964964919eb790b57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exposing model to templates:&lt;/strong&gt;&lt;a href=&quot;guide/scope&quot;&gt;Scopes&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;모델을 템플릿에 노출 : &lt;/strong&gt;&lt;a href=&quot;guide/scope&quot;&gt;범위&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29419687192edcb313a9e8cb642fbcf74067c9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fileupload:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Fileupload:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="728ae224a4f3f6513bbafc04078c292e46e0bd3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Filters:&lt;/strong&gt; You can use &lt;a href=&quot;filter&quot;&gt;filters&lt;/a&gt; within expressions to format data before displaying it.</source>
          <target state="translated">&lt;strong&gt;필터 :&lt;/strong&gt; 표현식 내에서 &lt;a href=&quot;filter&quot;&gt;필터&lt;/a&gt; 를 사용 하여 데이터를 표시하기 전에 형식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7c1fa4b2eaf7626d1792029e5b26b13d72fcf3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FireBase:&lt;/strong&gt;&lt;a href=&quot;http://angularfire.com/&quot;&gt;AngularFire&lt;/a&gt;, &lt;a href=&quot;http://www.youtube.com/watch?v=C7ZI7z7qnHU&quot;&gt;Realtime Apps with AngularJS and FireBase (video)&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;FireBase : &lt;/strong&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=C7ZI7z7qnHU&quot;&gt;AngularJS 및 FireBase가 포함 된 &lt;/a&gt;&lt;a href=&quot;http://angularfire.com/&quot;&gt;AngularFire&lt;/a&gt; , 실시간 앱 (비디오)</target>
        </trans-unit>
        <trans-unit id="cf84010d7a6b61f41ee63c802ccd44de864e5dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Focus management&lt;/strong&gt;: Guide the user around the app as views are appended/removed. Focus should &lt;em&gt;never&lt;/em&gt; be lost, as this causes unexpected behavior and much confusion (referred to as &quot;freak-out mode&quot;).</source>
          <target state="translated">&lt;strong&gt;포커스 관리&lt;/strong&gt; : 뷰가 추가 / 제거 될 때 앱을 안내합니다. 초점한다 &lt;em&gt;결코&lt;/em&gt; 이 ( &quot;괴물 아웃 모드&quot;이라한다) 예상치 못한 행동과 많은 혼란을 야기으로, 손실되지.</target>
        </trans-unit>
        <trans-unit id="2af7f91debc00c4d66b54ff27066486fa7fb3a61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For security purposes, it is strongly encouraged that web servers escape user-supplied data, replacing angle brackets (&amp;lt;, &amp;gt;) with &amp;amp;lt; and &amp;amp;gt; respectively, and replacing all interpolation start/end markers with their escaped counterparts.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;보안상의 이유로 웹 서버는 꺾쇠 괄호 (&amp;lt;,&amp;gt;)를 &amp;amp; lt; &amp;amp; gt; 모든 보간 시작 / 종료 마커를 이스케이프 처리 된 상대로 대체합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b581a24703a37b7af937ecbc3944d0890b25a5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forgiving:&lt;/strong&gt; In JavaScript, trying to evaluate undefined properties generates &lt;code&gt;ReferenceError&lt;/code&gt; or &lt;code&gt;TypeError&lt;/code&gt;. In AngularJS, expression evaluation is forgiving to &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;용서 :&lt;/strong&gt; JavaScript에서 정의되지 않은 속성을 평가하려고하면 &lt;code&gt;ReferenceError&lt;/code&gt; 또는 &lt;code&gt;TypeError&lt;/code&gt; 가 생성됩니다 . AngularJS에서 표현식 평가는 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 을 용서합니다 .</target>
        </trans-unit>
        <trans-unit id="118ae1efbf212c1af6f2ec7a52d16996705f9a9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Free online:&lt;/strong&gt;&lt;a href=&quot;http://thinkster.io&quot;&gt;thinkster.io&lt;/a&gt;, &lt;a href=&quot;http://www.codecademy.com/courses/javascript-advanced-en-2hJ3J/0/1&quot;&gt;CodeAcademy&lt;/a&gt;, &lt;a href=&quot;https://www.codeschool.com/courses/shaping-up-with-angular-js&quot;&gt;CodeSchool&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;무료 온라인 : &lt;/strong&gt;&lt;a href=&quot;http://thinkster.io&quot;&gt;thinkster.io&lt;/a&gt; , &lt;a href=&quot;http://www.codecademy.com/courses/javascript-advanced-en-2hJ3J/0/1&quot;&gt;CodeAcademy&lt;/a&gt; , &lt;a href=&quot;https://www.codeschool.com/courses/shaping-up-with-angular-js&quot;&gt;CodeSchool&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e321247d81350096c762f426ea37a7f7f65c46b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General UI Libraries:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일반 UI 라이브러리 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c62cc2644917c0c78a5ad290cc5c9b4a3cbc9f21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General options&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;일반 옵션&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="83069315cc099dddfa6736b90e27c48bdf031e5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generating AngularJS templates on the server containing user-provided content&lt;/strong&gt;. This is the most common pitfall where you are generating HTML via some server-side engine such as PHP, Java or ASP.NET.</source>
          <target state="translated">&lt;strong&gt;사용자가 제공 한 콘텐츠를 포함하는 서버에 AngularJS와 템플릿을 생성&lt;/strong&gt; . 이것은 PHP, Java 또는 ASP.NET과 같은 일부 서버 측 엔진을 통해 HTML을 생성하는 가장 일반적인 함정입니다.</target>
        </trans-unit>
        <trans-unit id="b7704441aa8773f48d301f0f5b37cfd7c03c0699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting Started:&lt;/strong&gt;&lt;a href=&quot;http://www.dancancro.com/comparison-of-angularjs-application-starters/&quot;&gt;Comparison of the options for starting a new project&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;시작하기 : &lt;/strong&gt;&lt;a href=&quot;http://www.dancancro.com/comparison-of-angularjs-application-starters/&quot;&gt;새 프로젝트를 시작하기위한 옵션 비교&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d6b4902ff6c42ae4bb55caf32e3267d18fa47e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google Cloud Platform:&lt;/strong&gt;&lt;a href=&quot;https://github.com/GoogleCloudPlatform/appengine-angular-gotodos&quot;&gt;with Go&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Google 클라우드 플랫폼 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/GoogleCloudPlatform/appengine-angular-gotodos&quot;&gt;Go&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc400a339550b52ce6b0be7cd10a7b9a81323f48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML Semantics&lt;/strong&gt;: If you're creating custom element directives, Web Components or HTML in general, use native elements wherever possible to utilize built-in events and properties. Alternatively, use ARIA to communicate semantic meaning. See &lt;a href=&quot;http://www.w3.org/TR/aria-in-html/#notes-on-aria-use-in-html&quot;&gt;notes on ARIA use&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;HTML 의미&lt;/strong&gt; : 일반적으로 사용자 지정 요소 지시문, 웹 구성 요소 또는 HTML을 만드는 경우 기본 제공 이벤트 및 속성을 활용할 수있는 기본 요소를 사용하십시오. 또는 ARIA를 사용하여 의미 적 의미를 전달하십시오. &lt;a href=&quot;http://www.w3.org/TR/aria-in-html/#notes-on-aria-use-in-html&quot;&gt;ARIA 사용에 대한&lt;/a&gt; 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="772e80ba0b22ef620ca409833085ad693b23ee9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hood.ie:&lt;/strong&gt;&lt;a href=&quot;http://www.roberthorvick.com/2013/06/30/todomvc-angularjs-hood-ie-60-minutes-to-awesome/&quot;&gt;60 Minutes to Awesome&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Hood.ie : &lt;/strong&gt;&lt;a href=&quot;http://www.roberthorvick.com/2013/06/30/todomvc-angularjs-hood-ie-60-minutes-to-awesome/&quot;&gt;멋진 60 분&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19085e0a2c5cd050d84b7d76363211819ff976a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If an attacker has access to control AngularJS templates or expressions, they can exploit an AngularJS application via an XSS attack, regardless of the version.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공격자가 AngularJS 템플릿 또는 표현식을 제어 할 수있는 권한이 있으면 버전에 관계없이 XSS 공격을 통해 AngularJS 응용 프로그램을 악용 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deaff8edd96bc66f4727a4f3ab4978724f45f6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you must continue to allow user-provided content in an AngularJS template then the safest option is to ensure that it is only present in the part of the template that is made inert via the &lt;a href=&quot;../api/ng/directive/ngnonbindable&quot;&gt;&lt;code&gt;ngNonBindable&lt;/code&gt;&lt;/a&gt; directive.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS 템플릿에서 사용자 제공 콘텐츠를 계속 허용해야하는 경우 가장 안전한 옵션은 &lt;a href=&quot;../api/ng/directive/ngnonbindable&quot;&gt; &lt;code&gt;ngNonBindable&lt;/code&gt; &lt;/a&gt; 지시문을 통해 비활성으로 만들어진 템플릿 부분에만 해당 콘텐츠가 존재하도록하는 것입니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b01ec1aed4e21712373f6ba89f7d3b02564dd612" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input-type specific options&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;입력 유형별 옵션&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f943ecf537936d45c56dbe1a62ccb2ab16e8ccfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internationalization and Localization:&lt;/strong&gt;&lt;a href=&quot;guide/i18n&quot;&gt;AngularJS Guide to i18n and l10n&lt;/a&gt;, &lt;a href=&quot;api/ng/filter/date&quot;&gt;date filter&lt;/a&gt;, &lt;a href=&quot;api/ng/filter/currency&quot;&gt;currency filter&lt;/a&gt;, &lt;a href=&quot;https://blog.novanet.no/creating-multilingual-support-using-angularjs/&quot;&gt;Creating multilingual support&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;국제화 및 현지화 : &lt;/strong&gt;&lt;a href=&quot;guide/i18n&quot;&gt;AngularJS i18n 및 l10n 안내서&lt;/a&gt; , &lt;a href=&quot;api/ng/filter/date&quot;&gt;날짜 필터&lt;/a&gt; , &lt;a href=&quot;api/ng/filter/currency&quot;&gt;통화 필터&lt;/a&gt; , &lt;a href=&quot;https://blog.novanet.no/creating-multilingual-support-using-angularjs/&quot;&gt;다국어 지원 작성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13d22bd673d3e8b5f004e45768f0644ef8cf6802" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internationalization and Localization:&lt;/strong&gt;&lt;a href=&quot;http://www.novanet.no/blog/hallstein-brotan/dates/2013/10/creating-multilingual-support-using-angularjs/&quot;&gt;Creating multilingual support&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;국제화 및 현지화 : &lt;/strong&gt;&lt;a href=&quot;http://www.novanet.no/blog/hallstein-brotan/dates/2013/10/creating-multilingual-support-using-angularjs/&quot;&gt;다국어 지원 작성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e5f409cb2ee335a9867f4c6a6b23ca8aa2e621" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internationalization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Internationalization:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ea751c15b641e55b67020dc80776c68a6993488" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's best to design your application in such a way that users cannot change client-side templates.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용자가 클라이언트 측 템플릿을 변경할 수 없도록 애플리케이션을 설계하는 것이 가장 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bd2654d1202485a2e442179165da1e7c418c60d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Javascript minification: &lt;/strong&gt;&lt;a href=&quot;http://thegreenpizza.github.io/2013/05/25/building-minification-safe-angular.js-applications/&quot;&gt;Background&lt;/a&gt;, &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate automation tool&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;자바 스크립트 축소 : &lt;/strong&gt;&lt;a href=&quot;http://thegreenpizza.github.io/2013/05/25/building-minification-safe-angular.js-applications/&quot;&gt;백그라운드&lt;/a&gt; , &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;주석 주석 자동화 도구&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="091f846e69bd67ba0e23902bb84fa8e87a680de4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Life cycle: Pseudo-Code of &lt;code&gt;$apply()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;라이프 사이클 : &lt;code&gt;$apply()&lt;/code&gt; 의 의사 코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="487183e5f206a39ee969219ee284ebe8a02babcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Link:&lt;/strong&gt; combine the directives with a scope and produce a live view. Any changes in the scope model are reflected in the view, and any user interactions with the view are reflected in the scope model. This makes the scope model the single source of truth.</source>
          <target state="translated">&lt;strong&gt;링크 :&lt;/strong&gt; 지시문을 범위와 결합하고 라이브 뷰를 생성합니다. 범위 모델의 모든 변경 사항이 뷰에 반영되고 뷰와의 사용자 상호 작용이 범위 모델에 반영됩니다. 이것은 스코프 모델을 단일 진실 소스로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="96b3884d0059c68bd05c7315cffd0cf62ea0f114" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MEAN Stack: &lt;/strong&gt;&lt;a href=&quot;http://blog.mongodb.org/post/49262866911/the-mean-stack-mongodb-expressjs-angularjs-and&quot;&gt;Blog post&lt;/a&gt;, &lt;a href=&quot;http://thecodebarbarian.wordpress.com/2013/07/22/introduction-to-the-mean-stack-part-one-setting-up-your-tools/&quot;&gt;Setup&lt;/a&gt;, &lt;a href=&quot;https://developers.google.com/live/shows/913996610&quot;&gt;GDL Video&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;MEAN Stack : &lt;/strong&gt;&lt;a href=&quot;http://blog.mongodb.org/post/49262866911/the-mean-stack-mongodb-expressjs-angularjs-and&quot;&gt;블로그 게시물&lt;/a&gt; , &lt;a href=&quot;http://thecodebarbarian.wordpress.com/2013/07/22/introduction-to-the-mean-stack-part-one-setting-up-your-tools/&quot;&gt;설정&lt;/a&gt; , &lt;a href=&quot;https://developers.google.com/live/shows/913996610&quot;&gt;GDL 비디오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2911fd9d126848f8eb1eed1ab9acba880de28cac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Manipulating HTML DOM programmatically:&lt;/strong&gt; Manipulating HTML DOM is a cornerstone of AJAX applications, but it's cumbersome and error-prone. By declaratively describing how the UI should change as your application state changes, you are freed from low-level DOM manipulation tasks. Most applications written with AngularJS never have to programmatically manipulate the DOM, although you can if you want to.</source>
          <target state="translated">&lt;strong&gt;프로그래밍 방식으로 HTML DOM 조작 :&lt;/strong&gt; HTML DOM 조작은 AJAX 애플리케이션의 초석이지만 번거롭고 오류가 발생하기 쉽습니다. 애플리케이션 상태가 변경됨에 따라 UI가 어떻게 변경되어야하는지 선언적으로 설명함으로써 하위 수준의 DOM 조작 작업에서 벗어날 수 있습니다. AngularJS로 작성된 대부분의 응용 프로그램은 원하는 경우 DOM을 프로그래밍 방식으로 조작 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae65de1008d93ac10e5147e1a16fe4001e84f1a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Marshaling data to and from the UI:&lt;/strong&gt; CRUD operations make up the majority of AJAX applications' tasks. The flow of marshaling data from the server to an internal object to an HTML form, allowing users to modify the form, validating the form, displaying validation errors, returning to an internal model, and then back to the server, creates a lot of boilerplate code. AngularJS eliminates almost all of this boilerplate, leaving code that describes the overall flow of the application rather than all of the implementation details.</source>
          <target state="translated">&lt;strong&gt;UI와의 데이터 마샬링 :&lt;/strong&gt; CRUD 작업은 대부분의 AJAX 응용 프로그램 작업을 구성합니다. 서버에서 내부 객체로 HTML 객체로 데이터를 마샬링하여 사용자가 양식을 수정하고, 양식을 검증하고, 유효성 검증 오류를 표시하며, 내부 모델로 돌아온 후 서버로 다시 돌아가서 많은 상용구를 작성합니다. 암호. AngularJS는이 상용구를 거의 모두 제거하여 모든 구현 세부 사항이 아니라 애플리케이션의 전체 흐름을 설명하는 코드를 남깁니다.</target>
        </trans-unit>
        <trans-unit id="2a275a422f10bed3a56df7995304ed16eed43489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meteor: &lt;/strong&gt;&lt;a href=&quot;https://github.com/Urigo/angular-meteor&quot;&gt;angular-meteor package&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;유성 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/Urigo/angular-meteor&quot;&gt;각 유성 패키지&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db0671b387ecea8787251da7e07fd8e9fdaf4483" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Methods&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d8a78379558acab3af04cd587819d30c75521e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Model mutation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모델 돌연변이&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7086e1ce6f42d5fad9cba2e1f5646b1b825187cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mult-slot transclusion&lt;/strong&gt; is declared by providing an object for the &lt;code&gt;transclude&lt;/code&gt; property.</source>
          <target state="translated">&lt;strong&gt;다중 슬롯 변환&lt;/strong&gt; 은 &lt;code&gt;transclude&lt;/code&gt; 특성에 대한 오브젝트를 제공하여 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="6659bd2912ce42ac1bdd194ad91b297788435e7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mutation observation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;돌연변이 관찰&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b23529e246744b68c2bd6ef0af4dd7ff9830bcef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; Developers should take care in how and why they are modifying the &lt;code&gt;$delegate&lt;/code&gt; for the service. Not only should expectations for the consumer be kept, but some functionality (such as directive registration) does not take place after decoration, but during creation/registration of the original service. This means, for example, that an action such as pushing a directive object to a directive &lt;code&gt;$delegate&lt;/code&gt; will likely result in unexpected behavior. Furthermore, great care should be taken when decorating core services, directives, or filters as this may unexpectedly or adversely affect the functionality of the framework.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 개발자는 서비스 의 &lt;code&gt;$delegate&lt;/code&gt; 를 수정하는 방법과 이유에주의해야 합니다. 소비자에 대한 기대를 유지해야 할뿐만 아니라 일부 기능 (예 : 지시어 등록)은 장식 후가 아니라 원래 서비스의 생성 / 등록 중에 발생합니다. 예를 들어, 지시문 객체를 지시문 &lt;code&gt;$delegate&lt;/code&gt; 로 푸시하는 것과 같은 동작은 예기치 않은 동작을 초래할 수 있음을 의미합니다. 또한, 핵심 서비스, 지시문 또는 필터를 장식 할 때는 프레임 워크의 기능에 예기치 않게 또는 부정적인 영향을 줄 수 있으므로 각별히주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="68ff0628f16e24ea841c9bf624378b977ece4f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This guide is targeted towards developers who are already familiar with AngularJS basics. If you're just getting started, we recommend the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;tutorial&lt;/a&gt; first.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 안내서는 AngularJS 기본 사항에 이미 익숙한 개발자를 대상으로합니다. 방금 시작한 경우 먼저 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;자습서를&lt;/a&gt; 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="fdb079ff35eeaa09176e6b1ab92674e118487a5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: animations take effect only if the &lt;strong&gt;ngAnimate&lt;/strong&gt; module is loaded.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 애니메이션은 &lt;strong&gt;ngAnimate&lt;/strong&gt; 모듈이로드 된 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="29bce9ed0569284644bd5abffe0b6b3ff5ca463c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No Bitwise, Comma, And Void Operators:&lt;/strong&gt; You cannot use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&quot;&gt;Bitwise&lt;/a&gt;, &lt;code&gt;,&lt;/code&gt; or &lt;code&gt;void&lt;/code&gt; operators in an AngularJS expression.</source>
          <target state="translated">&lt;strong&gt;없음 비트 단위, 쉼표, 그리고 무효 연산자 :&lt;/strong&gt; 당신은 사용할 수 없습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&quot;&gt;비트 단위&lt;/a&gt; , &lt;code&gt;,&lt;/code&gt; 또는 &lt;code&gt;void&lt;/code&gt; AngularJS와 식에서 연산자.</target>
        </trans-unit>
        <trans-unit id="ac0995069bdfdc8439b558ebbcd92d17a5af46db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No Control Flow Statements:&lt;/strong&gt; You cannot use the following in an AngularJS expression: conditionals, loops, or exceptions.</source>
          <target state="translated">&lt;strong&gt;제어 흐름 문 없음 :&lt;/strong&gt; AngularJS 표현식에서 조건부, 루프 또는 예외를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f763c2d5219a3a509a21ff61c916fa107b127c3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No Function Declarations:&lt;/strong&gt; You cannot declare functions in an AngularJS expression, even inside &lt;code&gt;ng-init&lt;/code&gt; directive.</source>
          <target state="translated">&lt;strong&gt;함수 선언 없음 : &lt;/strong&gt; &lt;code&gt;ng-init&lt;/code&gt; 지시문 내에서도 AngularJS 표현식에서 함수를 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3111894aec8cae77ef6914c2f135257f6ecd663c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No Object Creation With New Operator:&lt;/strong&gt; You cannot use &lt;code&gt;new&lt;/code&gt; operator in an AngularJS expression.</source>
          <target state="translated">&lt;strong&gt;새 연산자로 객체 생성 안 함 :&lt;/strong&gt; AngularJS 표현식에서 &lt;code&gt;new&lt;/code&gt; 연산자를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4884a66d9e6f11c9d9f4d185ac827f2e5cf991df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No RegExp Creation With Literal Notation:&lt;/strong&gt; You cannot create regular expressions in an AngularJS expression. An exception to this rule is &lt;a href=&quot;../api/ng/directive/ngpattern&quot;&gt;&lt;code&gt;ng-pattern&lt;/code&gt;&lt;/a&gt; which accepts valid RegExp.</source>
          <target state="translated">&lt;strong&gt;리터럴 표기법을 사용한 RegExp 작성 없음 :&lt;/strong&gt; AngularJS 표현식에서 정규식을 작성할 수 없습니다. 이 규칙의 예외 는 유효한 RegExp를 허용하는 &lt;a href=&quot;../api/ng/directive/ngpattern&quot;&gt; &lt;code&gt;ng-pattern&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="754b4f64006bb56947e7f8ed014b7227d3ff1a01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; All element references in AngularJS are always wrapped with jQuery or jqLite (such as the element argument in a directive's compile / link function). They are never raw DOM references.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; AngularJS의 모든 요소 참조는 항상 jQuery 또는 jqLite (예 : 지시문의 컴파일 / 링크 함수의 요소 인수)로 래핑됩니다. 절대 원시 DOM 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bccc0e1ef7219cdcae1c7eee6b50dfe79beaa7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An &quot;origin&quot; consists of the &lt;a href=&quot;https://en.wikipedia.org/wiki/URI_scheme&quot;&gt;URI scheme&lt;/a&gt;, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hostname&quot;&gt;hostname&lt;/a&gt; and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Port_(computer_networking&quot;&gt;port number&lt;/a&gt;. For &lt;code&gt;http:&lt;/code&gt; and &lt;code&gt;https:&lt;/code&gt;, the port number can be omitted if using th default ports (80 and 443 respectively). Examples: &lt;code&gt;http://example.com&lt;/code&gt;, &lt;code&gt;https://api.example.com:9876&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; &quot;origin&quot;은 &lt;a href=&quot;https://en.wikipedia.org/wiki/URI_scheme&quot;&gt;URI 체계&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Hostname&quot;&gt;호스트 이름&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Port_(computer_networking&quot;&gt;포트 번호로 구성&lt;/a&gt; 됩니다. 대한 &lt;code&gt;http:&lt;/code&gt; 및 &lt;code&gt;https:&lt;/code&gt; 포트 번호를 생략 할 수있는 일 기본 포트를 사용하는 경우 (80 및 443 각각). 예 : &lt;code&gt;http://example.com&lt;/code&gt; , &lt;code&gt;https://api.example.com:9876&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07d16e1f6d934f26fde4c4dbf393c311b322112b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; AngularJS directive attributes take either expressions &lt;em&gt;or&lt;/em&gt; interpolation markup with embedded expressions. It is considered &lt;strong&gt;bad practice&lt;/strong&gt; to embed interpolation markup inside an expression:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; AngularJS 지시문 속성은 표현식 &lt;em&gt;또는&lt;/em&gt; 포함 된 표현식으로 보간 마크 업을 사용합니다. 표현식 내에 보간 마크 업을 포함시키는 &lt;strong&gt;것은 나쁜 습관&lt;/strong&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f30dc881f403b4408bffc55af0c839141d80f1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; AngularJS does not make a copy of the &lt;code&gt;data&lt;/code&gt; parameter before it is passed into the &lt;code&gt;transformRequest&lt;/code&gt; pipeline. That means changes to the properties of &lt;code&gt;data&lt;/code&gt; are not local to the transform function (since Javascript passes objects by reference). For example, when calling &lt;code&gt;$http.get(url, $scope.myObject)&lt;/code&gt;, modifications to the object's properties in a transformRequest function will be reflected on the scope and in any templates where the object is data-bound. To prevent this, transform functions should have no side-effects. If you need to modify properties, it is recommended to make a copy of the data, or create new object to return.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; AngularJS는 &lt;code&gt;data&lt;/code&gt; 매개 변수가 &lt;code&gt;transformRequest&lt;/code&gt; 파이프 라인 으로 전달되기 전에 사본을 작성하지 않습니다 . 즉, Javascript가 객체를 참조로 전달하기 때문에 &lt;code&gt;data&lt;/code&gt; 속성 변경 이 변환 함수에 국한되지 않습니다. 예를 들어 &lt;code&gt;$http.get(url, $scope.myObject)&lt;/code&gt; 호출 하면 transformRequest 함수에서 객체 속성에 대한 수정 사항이 객체와 데이터 바인딩 된 템플릿 및 범위에 반영됩니다. 이를 방지하기 위해 변환 함수에는 부작용이 없어야합니다. 속성을 수정해야하는 경우 데이터 복사본을 만들거나 반환 할 새 개체를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62e8d769efbb38bebbae56179db43581fb022339" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; AngularJS uses &lt;a href=&quot;http://misko.hevery.com/2009/02/19/constructor-injection-vs-setter-injection/&quot;&gt;&lt;strong&gt;constructor injection&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; AngularJS는 &lt;a href=&quot;http://misko.hevery.com/2009/02/19/constructor-injection-vs-setter-injection/&quot;&gt;&lt;strong&gt;생성자 주입을&lt;/strong&gt;&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ea8f867f10d41b8ea0eac218ad0e389751b74337" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Any unspecified options will use the default value. You can see the default values below.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 지정되지 않은 옵션은 기본값을 사용합니다. 아래의 기본값을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be1272e4ff520c7319bf0af92eafbe034baf447" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Avoid using the &lt;code&gt;g&lt;/code&gt; flag on the RegExp, as it will cause each successive search to start at the index of the last search's match, thus not taking the whole input value into account.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; RegExp 에서 &lt;code&gt;g&lt;/code&gt; 플래그를 사용하지 마십시오 . 마지막 검색과 일치하는 색인에서 각 연속 검색이 시작되므로 전체 입력 값을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9646681f60adbf1cab980b4c3672b602175ba12b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Do not bootstrap the app on an element with a directive that uses &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;transclusion&lt;/a&gt;, such as &lt;a href=&quot;../directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../directive/nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt;&lt;code&gt;ngView&lt;/code&gt;&lt;/a&gt;. Doing this misplaces the app &lt;a href=&quot;../service/%24rootelement&quot;&gt;&lt;code&gt;$rootElement&lt;/code&gt;&lt;/a&gt; and the app's &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;injector&lt;/a&gt;, causing animations to stop working and making the injector inaccessible from outside the app.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 음주 사용하는 지시문 요소에 응용 프로그램을 부트 스트랩하지 &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;트랜스 클루 전을&lt;/a&gt; 같은, &lt;a href=&quot;../directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../directive/nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt; &lt;code&gt;ngView&lt;/code&gt; &lt;/a&gt; . 이렇게하면 앱 &lt;a href=&quot;../service/%24rootelement&quot;&gt; &lt;code&gt;$rootElement&lt;/code&gt; &lt;/a&gt; 와 앱의 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;인젝터가&lt;/a&gt; 잘못 배치되어 애니메이션이 작동을 멈추고 인젝터가 앱 외부에서 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7d1df2da097b762e8500ab2bc8acc5c59dd5dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Filter names must be valid AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt;&lt;code&gt;Expressions&lt;/code&gt;&lt;/a&gt; identifiers, such as &lt;code&gt;uppercase&lt;/code&gt; or &lt;code&gt;orderBy&lt;/code&gt;. Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace your filters, then you can use capitalization (&lt;code&gt;myappSubsectionFilterx&lt;/code&gt;) or underscores (&lt;code&gt;myapp_subsection_filterx&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 필터 이름은 &lt;code&gt;uppercase&lt;/code&gt; 또는 &lt;code&gt;orderBy&lt;/code&gt; 와 같은 유효한 AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt; &lt;code&gt;Expressions&lt;/code&gt; &lt;/a&gt; 식별자 여야합니다 . 하이픈 및 점과 같은 특수 문자가있는 이름은 사용할 수 없습니다. 필터 네임 스페이스를 사용하려면 대문자 ( &lt;code&gt;myappSubsectionFilterx&lt;/code&gt; ) 또는 밑줄 ( &lt;code&gt;myapp_subsection_filterx&lt;/code&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6db5293b8274f7a74ad2c0a15707b9a31946b87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Filter names must be valid AngularJS &lt;a href=&quot;expression&quot;&gt;&lt;code&gt;Expressions&lt;/code&gt;&lt;/a&gt; identifiers, such as &lt;code&gt;uppercase&lt;/code&gt; or &lt;code&gt;orderBy&lt;/code&gt;. Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace your filters, then you can use capitalization (&lt;code&gt;myappSubsectionFilterx&lt;/code&gt;) or underscores (&lt;code&gt;myapp_subsection_filterx&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 필터 이름은 &lt;code&gt;uppercase&lt;/code&gt; 또는 &lt;code&gt;orderBy&lt;/code&gt; 와 같은 유효한 AngularJS &lt;a href=&quot;expression&quot;&gt; &lt;code&gt;Expressions&lt;/code&gt; &lt;/a&gt; 식별자 여야합니다 . 하이픈 및 점과 같은 특수 문자가있는 이름은 사용할 수 없습니다. 필터 네임 스페이스를 사용하려면 대문자 ( &lt;code&gt;myappSubsectionFilterx&lt;/code&gt; ) 또는 밑줄 ( &lt;code&gt;myapp_subsection_filterx&lt;/code&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09b3de40dff5562853d96db36635c9e72bd0fad2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If present, &lt;code&gt;classNameFilter&lt;/code&gt; will be checked after &lt;a href=&quot;%24animateprovider#customFilter.html&quot;&gt;customFilter&lt;/a&gt;. If &lt;code&gt;customFilter&lt;/code&gt; is present and returns false, &lt;code&gt;classNameFilter&lt;/code&gt; will not be checked.</source>
          <target state="translated">&lt;strong&gt;참고 :있는&lt;/strong&gt; 경우 &lt;a href=&quot;%24animateprovider#customFilter.html&quot;&gt;customFilter&lt;/a&gt; 다음에 &lt;code&gt;classNameFilter&lt;/code&gt; 가 검사됩니다 . 경우 &lt;code&gt;customFilter&lt;/code&gt; 존재하고 false를 반환 &lt;code&gt;classNameFilter&lt;/code&gt; 는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29f87520727c565590339f924ac7cca7cfc0196b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If present, &lt;code&gt;customFilter&lt;/code&gt; will be checked before &lt;a href=&quot;%24animateprovider#classNameFilter.html&quot;&gt;classNameFilter&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :있는&lt;/strong&gt; 경우 &lt;code&gt;customFilter&lt;/code&gt; 가 &lt;a href=&quot;%24animateprovider#classNameFilter.html&quot;&gt;classNameFilter&lt;/a&gt; 보다 먼저 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="8336bca83b29dfc525f1cedfe875ac2325965bd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the predicate is missing or empty then it defaults to &lt;code&gt;'+'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 술어가 누락되었거나 비어 있으면 기본값은 &lt;code&gt;'+'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb48c215391d9e21f60d1b4f3e5128f35325a987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you notice numbers not being sorted as expected, make sure they are actually being saved as numbers and not strings. &lt;strong&gt;Note:&lt;/strong&gt; For the purpose of sorting, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are considered &quot;greater than&quot; any other value (with undefined &quot;greater than&quot; null). This effectively means that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values end up at the end of a list sorted in ascending order. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;null&lt;/code&gt; values use &lt;code&gt;'null'&lt;/code&gt; as their type to be able to distinguish them from objects.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 숫자가 예상대로 정렬되지 않은 경우 실제로 숫자가 아닌 문자열로 저장되는지 확인하십시오. &lt;strong&gt;참고 :&lt;/strong&gt; 정렬을 위해 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 다른 값으로 &quot;보다 큼&quot;(정의되지 않은 &quot;보다 큼&quot;)으로 간주됩니다. 이는 효과적으로 &lt;code&gt;null&lt;/code&gt; 값 과 &lt;code&gt;undefined&lt;/code&gt; 값이 오름차순으로 정렬 된 목록의 끝에서 끝나는 것을 의미합니다 . &lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;null&lt;/code&gt; 값은 &lt;code&gt;'null'&lt;/code&gt; 을 유형으로 사용하여 객체와 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcfa7bc4217aa09ca0ac15abc5df872e42c3cb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If your scope already contains a property with this name, it will be hidden or overwritten. Make sure, you specify an appropriate name for this property, that does not collide with other properties on the scope.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 범위에이 이름의 속성이 이미 포함되어 있으면 숨겨 지거나 덮어 씁니다. 범위의 다른 속성과 충돌하지 않는이 속성에 적절한 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de6d75d2a08de0ddaf214e94f5c491a4f41f785" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In contrast to &lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$http.config&lt;/a&gt;, &lt;a href=&quot;../../ng/service/%24q&quot;&gt;promises&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; supported in &lt;code&gt;$resource&lt;/code&gt;, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the &lt;code&gt;cancellable&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$ http.config&lt;/a&gt; 와 달리 &lt;code&gt;$resource&lt;/code&gt; 에서는 &lt;a href=&quot;../../ng/service/%24q&quot;&gt;약속&lt;/a&gt; 이 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 여러 값에 동일한 값이 사용되기 때문입니다. 요청을 취소 할 수있는 방법을 찾고 있다면 &lt;code&gt;cancellable&lt;/code&gt; 옵션을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2a9960a1716b955d15c8ef82b1ff61b1bfaa4a68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Keep in mind that &lt;code&gt;angular.extend&lt;/code&gt; does not support recursive merge (deep copy). Use &lt;a href=&quot;angular.merge&quot;&gt;&lt;code&gt;angular.merge&lt;/code&gt;&lt;/a&gt; for this.</source>
          <target state="translated">&lt;strong&gt;주 :&lt;/strong&gt; 있음을 명심 &lt;code&gt;angular.extend&lt;/code&gt; 은 재귀 병합 (전체 복사)를 지원하지 않습니다. &lt;a href=&quot;angular.merge&quot;&gt; &lt;code&gt;angular.merge&lt;/code&gt; &lt;/a&gt; 위해 angular.merge 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a737670eed793e3a7f5e79a30adcd1dd5cf06a3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Keep in mind that this function will not find elements by tag name / CSS selector. For lookups by tag name, try instead &lt;code&gt;angular.element(document).find(...)&lt;/code&gt; or &lt;code&gt;$document.find()&lt;/code&gt;, or use the standard DOM APIs, e.g. &lt;code&gt;document.querySelectorAll()&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 태그 이름 / CSS 선택기로 요소를 찾지 않습니다. 태그 이름으로 검색하려면 &lt;code&gt;angular.element(document).find(...)&lt;/code&gt; 또는 &lt;code&gt;$document.find()&lt;/code&gt; 대신 표준 DOM API (예 : &lt;code&gt;document.querySelectorAll()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25007ddb7e4598a0075b438ca00a30fc96476806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Like other core AngularJS identifiers, built-in services always start with &lt;code&gt;$&lt;/code&gt; (e.g. &lt;code&gt;$http&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다른 핵심 AngularJS 식별자와 마찬가지로 내장 서비스는 항상 &lt;code&gt;$&lt;/code&gt; 로 시작합니다 (예 : &lt;code&gt;$http&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4932f6167e601a77c161e5c189cbfa99ccc31644" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Normally, a scope prototypically inherits from its parent. An isolated scope does not. See the &lt;a href=&quot;../api/ng/service/%24compile#directive-definition-object.html&quot;&gt;&quot;Directive Definition Object - scope&quot;&lt;/a&gt; section for more information about isolate scopes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 일반적으로 스코프는 프로토 타입으로 부모로부터 상속됩니다. 격리 된 범위는 그렇지 않습니다. 참고 항목 &lt;a href=&quot;../api/ng/service/%24compile#directive-definition-object.html&quot;&gt;- &quot;범위 지침 정의 개체&quot;&lt;/a&gt; 분리 범위에 대한 자세한 내용은 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1da042f7bf95ae6c4e993f7e979d273468251963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not every feature offered is available for all input types. Specifically, data binding and event handling via &lt;code&gt;ng-model&lt;/code&gt; is unsupported for &lt;code&gt;input[file]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 제공되는 모든 기능을 모든 입력 유형에 사용할 수있는 것은 아닙니다. 특히 &lt;code&gt;ng-model&lt;/code&gt; 을 통한 데이터 바인딩 및 이벤트 처리 는 &lt;code&gt;input[file]&lt;/code&gt; 대해 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="43c9bbd85138c973366badefbee28f8a58515f29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Passing a &lt;code&gt;transclude&lt;/code&gt; function to the $compile function is deprecated, as it e.g. will not use the right outer scope. Please pass the transclude function as a &lt;code&gt;parentBoundTranscludeFn&lt;/code&gt; to the link function instead.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; $ compile 함수에 &lt;code&gt;transclude&lt;/code&gt; 함수를 전달하는 것은 더 이상 사용되지 않습니다. 예를 들어 올바른 외부 범위를 사용하지 않기 때문입니다. 대신 &lt;code&gt;parentBoundTranscludeFn&lt;/code&gt; 함수를 parentBoundTranscludeFn 으로 링크 함수에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c375e47ef7907278cde581e097943b5b5c842c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Protractor based end-to-end tests cannot use this function to bootstrap manually. They must use &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 각도기 기반 엔드 투 엔드 테스트는이 기능을 사용하여 수동으로 부트 스트랩 할 수 없습니다. &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8cf1ad8dcecbe51df5c09b1d4e999791e1bdb417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Re-using DOM elements can have unforeseen effects. Read the &lt;a href=&quot;ngrepeat#tracking-and-duplicates.html&quot;&gt;section on tracking and duplicates&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; DOM 요소를 재사용하면 예기치 않은 결과가 발생할 수 있습니다. 자세한 &lt;a href=&quot;ngrepeat#tracking-and-duplicates.html&quot;&gt;내용은 추적 및 복제 섹션을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="64d9e466303a2306994cdaf48132f8a30be292b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;transclude&lt;/code&gt; function that is passed to the compile function is deprecated, as it e.g. does not know about the right outer scope. Please use the transclude function that is passed to the link function instead.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 컴파일 함수에 전달 된 &lt;code&gt;transclude&lt;/code&gt; 함수는 사용되지 않습니다. 예를 들어 오른쪽 외부 범위에 대해 알지 못하기 때문입니다. 대신 링크 기능으로 전달 된 변환 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d372d7dabca924b84525cbea0b2c53815c203cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The compile function cannot handle directives that recursively use themselves in their own templates or compile functions. Compiling these directives results in an infinite loop and stack overflow errors. This can be avoided by manually using $compile in the postLink function to imperatively compile a directive's template instead of relying on automatic template compilation via &lt;code&gt;template&lt;/code&gt; or &lt;code&gt;templateUrl&lt;/code&gt; declaration or manual compilation inside the compile function.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 컴파일 함수는 자체 템플릿 또는 컴파일 함수에서 자신을 재귀 적으로 사용하는 지시문을 처리 할 수 ​​없습니다. 이러한 지시문을 컴파일하면 무한 루프 및 스택 오버플로 오류가 발생합니다. postLink 함수에서 $ compile을 수동으로 사용하여 &lt;code&gt;template&lt;/code&gt; 또는 &lt;code&gt;templateUrl&lt;/code&gt; 선언을 통한 자동 템플릿 컴파일 또는 컴파일 함수 내부의 수동 컴파일 에 의존하는 대신 지시문 템플릿을 명령 적으로 컴파일하면 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1a7cf77f06230eb77dc4be6a59d85af8ef8f296" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The template instance and the link instance may be different objects if the template has been cloned. For this reason it is &lt;strong&gt;not&lt;/strong&gt; safe to do anything other than DOM transformations that apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration should be done in a linking function rather than in a compile function.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 템플릿이 복제 된 경우 템플릿 인스턴스와 링크 인스턴스는 다른 개체 일 수 있습니다. 이러한 이유로 컴파일 함수 내에서 복제 된 모든 DOM 노드에 적용되는 DOM 변환 이외의 작업 은 안전하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 특히 DOM 리스너 등록은 컴파일 기능이 아닌 연결 기능에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c1bb05a6bbf37a35eb2ec554716d99aa62c0f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These &lt;code&gt;=attr&lt;/code&gt; attributes in the &lt;code&gt;scope&lt;/code&gt; option of directives are normalized just like directive names. To bind to the attribute in &lt;code&gt;&amp;lt;div bind-to-this=&quot;thing&quot;&amp;gt;&lt;/code&gt;, you'd specify a binding of &lt;code&gt;=bindToThis&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 지시문 의 &lt;code&gt;scope&lt;/code&gt; 옵션 에서 이러한 &lt;code&gt;=attr&lt;/code&gt; 속성은 지시문 이름과 같이 정규화됩니다. &lt;code&gt;&amp;lt;div bind-to-this=&quot;thing&quot;&amp;gt;&lt;/code&gt; 의 속성에 바인딩하려면 &lt;code&gt;=bindToThis&lt;/code&gt; 바인딩을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="26330f0aa2b3354d455a060a2a0ed9b50f0e0816" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This directive is also added when the plain &lt;code&gt;maxlength&lt;/code&gt; attribute is used, with two differences:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 지시문은 일반 &lt;code&gt;maxlength&lt;/code&gt; 속성을 사용할 때도 추가 되며 두 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="238371dbb97a0e21fd538ddd42aa26554743d3ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This directive is also added when the plain &lt;code&gt;minlength&lt;/code&gt; attribute is used, with two differences:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 지시문은 일반 &lt;code&gt;minlength&lt;/code&gt; 속성을 사용할 때도 추가 되며 두 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="054250c4eff180ddca708b0e13aaa9156bc4280e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This directive is also added when the plain &lt;code&gt;pattern&lt;/code&gt; attribute is used, with two differences:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 지시문은 일반 &lt;code&gt;pattern&lt;/code&gt; 속성을 사용할 때도 추가 되며 두 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3171a730d4dfd4d4e95771c02006e09d50cdce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This document is an in-depth reference of all directive options. For a gentle introduction to directives with examples of common use cases, see the &lt;a href=&quot;../../../guide/directive&quot;&gt;directive guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 문서는 모든 지시문 옵션에 대한 심층적 인 참조입니다. 일반적인 사용 사례가 포함 된 지시문에 대한 간단한 소개는 &lt;a href=&quot;../../../guide/directive&quot;&gt;지시문 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dd59fef3a0d3dd52af38640e43c530d57bae301" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This option has no effect if &lt;code&gt;reloadOnUrl&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;reloadOnUrl&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면이 옵션이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="66f44d93a693e4c8d18278d6f5c209ad5bac8242" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When testing an element transclude directive you must not place the directive at the root of the DOM fragment that is being compiled. See &lt;a href=&quot;../../../guide/unit-testing#testing-transclusion-directives.html&quot;&gt;Testing Transclusion Directives&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 요소 transclude 지시문을 테스트 할 때 지시문을 컴파일중인 DOM 단편의 루트에 배치해서는 안됩니다. &lt;a href=&quot;../../../guide/unit-testing#testing-transclusion-directives.html&quot;&gt;Transclusion 지시문 테스트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b58b0c8530e6790b470560e7f408cab50785f3ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When using onload on SVG elements in IE11, the browser will try to call a function with the name on the window element, which will usually throw a &quot;function is undefined&quot; error. To fix this, you can instead use &lt;code&gt;data-onload&lt;/code&gt; or a different form that &lt;a href=&quot;../../../guide/directive#normalization.html&quot;&gt;matches&lt;/a&gt;&lt;code&gt;onload&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; IE11의 SVG 요소에서 onload를 사용할 때 브라우저는 일반적으로 &quot;function is undefined&quot;오류를 발생시키는 window 요소에서 이름을 가진 함수를 호출하려고 시도합니다. 이 문제를 해결하기 위해 &lt;code&gt;data-onload&lt;/code&gt; 또는 &lt;code&gt;onload&lt;/code&gt; &lt;a href=&quot;../../../guide/directive#normalization.html&quot;&gt;와 일치&lt;/a&gt; 하는 다른 양식을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43f275432395642736507de1fe9a315f4610ac22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When you create a directive, it is restricted to attribute and elements only by default. In order to create directives that are triggered by class name, you need to use the &lt;code&gt;restrict&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 지시문을 작성하면 기본적으로 속성 및 요소로만 제한됩니다. 클래스 이름으로 트리거되는 지시문을 작성하려면 &lt;code&gt;restrict&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="32cd8109a72d8948eb03c5cd4ec38de5ffe9496c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You do not currently have the ability to access scope variables from the &lt;code&gt;templateUrl&lt;/code&gt; function, since the template is requested before the scope is initialized.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 당신은 현재의 액세스 범위 변수에 능력이없는 &lt;code&gt;templateUrl&lt;/code&gt; 의 범위가 초기화되기 전에 템플릿이 요구되기 때문에, 기능.</target>
        </trans-unit>
        <trans-unit id="c3bc51797a8a7ef94a8e3d3ab8bec2861e246ac8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You should not use the ng-app directive when manually bootstrapping your app.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 앱을 수동으로 부트 스트랩 할 때는 ng-app 지시문을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e718d160fc8fa7b57d62c3c0b94a711ce06db0b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if this function is called outside of a &lt;code&gt;$digest&lt;/code&gt; cycle, a new &lt;code&gt;$digest&lt;/code&gt; cycle will be scheduled. However, it is encouraged to always call code that changes the model from within an &lt;code&gt;$apply&lt;/code&gt; call. That includes code evaluated via &lt;code&gt;$evalAsync&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능을 &lt;code&gt;$digest&lt;/code&gt; 주기 외부에서 호출 하면 새로운 &lt;code&gt;$digest&lt;/code&gt; 주기가 예약됩니다. 그러나 &lt;code&gt;$apply&lt;/code&gt; 호출 내에서 모델을 변경하는 코드를 항상 호출하는 것이 좋습니다 . 여기에는 &lt;code&gt;$evalAsync&lt;/code&gt; 를 통해 평가 된 코드가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bfcfeb91f4c7f896d2812380dae3170c526be42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; it is not possible to override the &lt;code&gt;getterSetter&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;getterSetter&lt;/code&gt; 옵션 을 대체 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="54b44c51ce581455eb6d9bebb63519e9ccd54302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;script&lt;/code&gt; tag containing the template does not need to be included in the &lt;code&gt;head&lt;/code&gt; of the document, but it must be a descendent of the &lt;a href=&quot;%24rootelement&quot;&gt;$rootElement&lt;/a&gt; (e.g. element with &lt;a href=&quot;../directive/ngapp&quot;&gt;&lt;code&gt;ngApp&lt;/code&gt;&lt;/a&gt; attribute), otherwise the template will be ignored.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 템플릿을 포함 하는 &lt;code&gt;script&lt;/code&gt; 태그 는 문서 의 &lt;code&gt;head&lt;/code&gt; 에 포함시킬 필요는 없지만 &lt;a href=&quot;%24rootelement&quot;&gt;$ rootElement&lt;/a&gt; 의 하위 항목이어야합니다 (예 : &lt;a href=&quot;../directive/ngapp&quot;&gt; &lt;code&gt;ngApp&lt;/code&gt; &lt;/a&gt; 속성이있는 요소 ). 그렇지 않으면 템플릿이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="937ca5efe376d5fad14e43dc0eebc369b4c45d8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;track by&lt;/code&gt; expression must come last - after any filters, and the alias expression: &lt;code&gt;item in items | filter:searchText as results  track by item.id&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;track by&lt;/code&gt; 표현이 마지막으로 와야 - 어떤 필터 후 별칭 표현 : &lt;code&gt;item in items | filter:searchText as results track by item.id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c758091459e087cd64a7d9d853e92c0229d1b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the default whitelist of 'self' is not recommended if your app shares its origin with other apps! It is a good idea to limit it to only your application's directory.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 앱이 다른 앱과 오리진을 공유하는 경우 기본 'self'화이트리스트는 권장되지 않습니다! 응용 프로그램의 디렉토리로만 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="580217ca4b9a925610a894a2a8a3fbeec3d61913" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this function only affects the options set on the &lt;code&gt;ngModelController&lt;/code&gt;, and not the options on the &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; directive from which they might have been obtained initially.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 &lt;code&gt;ngModelController&lt;/code&gt; 에 설정된 옵션에만 영향을 미치며 처음에 얻을 수있는 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; &lt;/a&gt; 지시문 의 옵션에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d7a9b2da896eca14042d2367f2756e8843535ce0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this guide is targeted towards developers who are already familiar with AngularJS basics. If you're just getting started, we recommend the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;tutorial&lt;/a&gt; first. If you just want to create custom directives, we recommend the &lt;a href=&quot;directive&quot;&gt;directives guide&lt;/a&gt;. If you want a deeper look into AngularJS's compilation process, you're in the right place.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 안내서는 AngularJS 기본 사항에 이미 익숙한 개발자를 대상으로합니다. 방금 시작한 경우 먼저 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;자습서를&lt;/a&gt; 권장합니다 . 사용자 지정 지시문 만 만들려면 &lt;a href=&quot;directive&quot;&gt;지시문 안내서를&lt;/a&gt; 권장합니다 . AngularJS의 컴파일 프로세스를 자세히 살펴 보려면 올바른 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f01bce739b9a30fca8b2e435855aebf0d4be03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this guide is targeted towards developers who are already familiar with AngularJS basics. If you're just getting started, we recommend the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;tutorial&lt;/a&gt; first. If you're looking for the &lt;strong&gt;directives API&lt;/strong&gt;, you can find it in the &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;&lt;code&gt;$compile&lt;/code&gt; API docs&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 안내서는 AngularJS 기본 사항에 이미 익숙한 개발자를 대상으로합니다. 방금 시작한 경우 먼저 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;자습서를&lt;/a&gt; 권장합니다 . &lt;strong&gt;지시문 API를&lt;/strong&gt; 찾고 있다면 &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; API docs&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43578b6de6d5a04f8a47794d2395d123f9352a38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;ngSelected&lt;/code&gt; does not interact with the &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;ngModel&lt;/code&gt; directives, it only sets the &lt;code&gt;selected&lt;/code&gt; attribute on the element. If you are using &lt;code&gt;ngModel&lt;/code&gt; on the select, you should not use &lt;code&gt;ngSelected&lt;/code&gt; on the options, as &lt;code&gt;ngModel&lt;/code&gt; will set the select value and selected options.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;ngSelected&lt;/code&gt; 는 &lt;code&gt;select&lt;/code&gt; 및 &lt;code&gt;ngModel&lt;/code&gt; 지시문 과 상호 작용하지 않으며 &lt;code&gt;selected&lt;/code&gt; 속성 만 요소에 설정합니다 . 당신이 사용하는 경우 &lt;code&gt;ngModel&lt;/code&gt; 을 선택에, 당신은 사용하지 말아야 &lt;code&gt;ngSelected&lt;/code&gt; 을 같이 옵션에 &lt;code&gt;ngModel&lt;/code&gt; 이 선택 값과 선택 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9674dd656cd0bb33b36917505723e467176e6355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;null&lt;/code&gt; values use &lt;code&gt;'null'&lt;/code&gt; as their type.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;null&lt;/code&gt; 값 은 유형으로 &lt;code&gt;'null'&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7ce3871382cfc81e140c332a7381c6d7ded995c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;replace&lt;/code&gt; is deprecated in AngularJS and has been removed in the new Angular (v2+).</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;replace&lt;/code&gt; 는 AngularJS에서 더 이상 사용되지 않으며 새로운 Angular (v2 +)에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="094902b4f074c52d206de76a0d6c62c38c4f99cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;em&gt;Link&lt;/em&gt; means setting up listeners on the DOM and setting up &lt;code&gt;$watch&lt;/code&gt; on the Scope to keep the two in sync.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;em&gt;링크&lt;/em&gt; 는 DOM에서 리스너를 설정 하고 스코프에서 &lt;code&gt;$watch&lt;/code&gt; 를 설정하여 동기화를 유지하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="abd92687b99044b4eddf773d671c4667439b4622" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="4e7e869df02e986a8bd9dd779b5592b5c9faf996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;%24compile#-replace-.html&quot;&gt;&lt;code&gt;replace: true&lt;/code&gt;&lt;/a&gt; is deprecated and not recommended to use, mainly due to the issues listed here. It has been completely removed in the new Angular.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;%24compile#-replace-.html&quot;&gt; &lt;code&gt;replace: true&lt;/code&gt; &lt;/a&gt; 는 더 이상 사용되지 않으며 주로 여기에 나열된 문제로 인해 사용하지 않는 것이 좋습니다. 새로운 Angular에서는 완전히 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4451c5f79942d8017493f279d2afc73973a025d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;ngForm&lt;/code&gt; cannot be used as a replacement for &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, because it lacks its &lt;a href=&quot;https://html.spec.whatwg.org/#the-form-element&quot;&gt;built-in HTML functionality&lt;/a&gt;. Specifically, you cannot submit &lt;code&gt;ngForm&lt;/code&gt; like a &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag. That means, you cannot send data to the server with &lt;code&gt;ngForm&lt;/code&gt;, or integrate it with &lt;a href=&quot;ngsubmit&quot;&gt;&lt;code&gt;ngSubmit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;ngForm&lt;/code&gt; 은 &lt;a href=&quot;https://html.spec.whatwg.org/#the-form-element&quot;&gt;HTML 기능&lt;/a&gt; 이 내장 되어 있지 않으므로 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 을 대신 할 수 없습니다 . 특히 &lt;code&gt;ngForm&lt;/code&gt; 을 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 처럼 제출할 수 없습니다 . 그 말은, 당신과 함께 서버에 데이터를 보낼 수 없습니다 &lt;code&gt;ngForm&lt;/code&gt; , 또는와 통합 &lt;a href=&quot;ngsubmit&quot;&gt; &lt;code&gt;ngSubmit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d01ba8914ae532b4b38f3b54193bdb550f9cf269" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For fake HTTP backend implementation suitable for end-to-end testing or backend-less development please see &lt;a href=&quot;../../ngmocke2e/service/%24httpbackend&quot;&gt;e2e $httpBackend mock&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 엔드 투 엔드 테스트 또는 백엔드리스 개발에 적합한 가짜 HTTP 백엔드 구현은 &lt;a href=&quot;../../ngmocke2e/service/%24httpbackend&quot;&gt;e2e $ httpBackend mock을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02c202d12207861a5f5725222e593ed8c38b35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For fake http backend implementation suitable for unit testing please see &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;unit-testing $httpBackend mock&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 단위 테스트에 적합한 가짜 http 백엔드 구현의 경우 단위 &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;테스트 $ httpBackend mock을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c97b6b23eb89dc034c80ac1fd70c6ded60d55024" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Generally, the events that are fired correspond 1:1 to &lt;code&gt;$animate&lt;/code&gt; method names, e.g. &lt;a href=&quot;%24animate#addClass.html&quot;&gt;addClass()&lt;/a&gt; will fire &lt;code&gt;addClass&lt;/code&gt;, and &lt;a href=&quot;../directive/ngclass&quot;&gt;&lt;code&gt;ngClass&lt;/code&gt;&lt;/a&gt; will fire &lt;code&gt;addClass&lt;/code&gt; if classes are added, and &lt;code&gt;removeClass&lt;/code&gt; if classes are removed. However, there are two exceptions:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 일반적으로 대응 한 해고 된 이벤트 : 1을 &lt;code&gt;$animate&lt;/code&gt; 메소드 이름, 예를 들어, &lt;a href=&quot;%24animate#addClass.html&quot;&gt;addClass ()가&lt;/a&gt; 실행됩니다 &lt;code&gt;addClass&lt;/code&gt; 를 하고 &lt;a href=&quot;../directive/ngclass&quot;&gt; &lt;code&gt;ngClass&lt;/code&gt; 가&lt;/a&gt; 실행됩니다 &lt;code&gt;addClass&lt;/code&gt; 를 클래스를 추가하는 경우와 &lt;code&gt;removeClass&lt;/code&gt; 클래스가 제거되면. 그러나 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cacd31a04d29b782a40c79d6c3ab3a6d3435a24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If the array contains objects that reference themselves, filtering is not possible.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 배열에 자신을 참조하는 객체가 포함되어 있으면 필터링 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac4a26705c378eb8deb6df0e71f71d7c21815409" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you have assignment in &lt;code&gt;ngInit&lt;/code&gt; along with a &lt;a href=&quot;../service/%24filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, make sure you have parentheses to ensure correct operator precedence:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;../service/%24filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;ngInit&lt;/code&gt; 에 할당 된 경우 올바른 연산자 우선 순위를 보장하기 위해 괄호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="458f3e8132df2dd3d5450a74a9df936fbcdd5440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Intervals created by this service must be explicitly destroyed when you are finished with them. In particular they are not automatically destroyed when a controller's scope or a directive's element are destroyed. You should take this into consideration and make sure to always cancel the interval at the appropriate moment. See the example below for more details on how and when to do this.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 서비스에서 생성 된 간격은 완료되면 명시 적으로 삭제해야합니다. 특히 컨트롤러의 범위 나 지시어 요소가 파괴 될 때 자동으로 파괴되지 않습니다. 이를 고려하여 적절한 순간에 항상 간격을 취소해야합니다. 이 작업을 수행하는 방법과시기에 대한 자세한 내용은 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba6f1fdd102bb501811f6bf2972b3d2642460a55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The element will be taken into account only as long as its &lt;code&gt;position&lt;/code&gt; is set to &lt;code&gt;fixed&lt;/code&gt;. This option is useful, when dealing with responsive navbars/headers that adjust their height and/or positioning according to the viewport's size.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 요소의 &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;fixed&lt;/code&gt; 으로 설정된 경우에만 요소가 고려됩니다 . 이 옵션은 뷰포트의 크기에 따라 높이 및 / 또는 위치를 조정하는 반응 형 탐색 막대 / 헤더를 처리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="137a110690fcaf3ac66664419099f281ac00252c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The new attributes will not be treated as URI attributes, which means their values will not be sanitized as URIs using &lt;code&gt;$compileProvider&lt;/code&gt;'s &lt;a href=&quot;../../ng/provider/%24compileprovider#aHrefSanitizationWhitelist.html&quot;&gt;aHrefSanitizationWhitelist&lt;/a&gt; and &lt;a href=&quot;../../ng/provider/%24compileprovider#imgSrcSanitizationWhitelist.html&quot;&gt;imgSrcSanitizationWhitelist&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; : 새 속성은 URI 속성으로 처리되지 않으므로 &lt;code&gt;$compileProvider&lt;/code&gt; 의 &lt;a href=&quot;../../ng/provider/%24compileprovider#aHrefSanitizationWhitelist.html&quot;&gt;aHrefSanitizationWhitelist&lt;/a&gt; 및 &lt;a href=&quot;../../ng/provider/%24compileprovider#imgSrcSanitizationWhitelist.html&quot;&gt;imgSrcSanitizationWhitelist를&lt;/a&gt; 사용하여 해당 값이 URI로 삭제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="55917c01e65338e57270513362a867e1b4c0feee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Typically directives are registered with &lt;code&gt;module.directive&lt;/code&gt;. The example below is to illustrate how &lt;code&gt;$compile&lt;/code&gt; works.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 일반적으로 지시문은 &lt;code&gt;module.directive&lt;/code&gt; 에 등록됩니다 . 아래 예제는 &lt;code&gt;$compile&lt;/code&gt; 작동 방식을 설명하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b0494f4ee055225c681e0e403b86a484ffd8980e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP: &lt;/strong&gt;&lt;a href=&quot;http://blog.brunoscopelliti.com/building-a-restful-web-service-with-angularjs-and-php-more-power-with-resource&quot;&gt;Building a RESTful web service&lt;/a&gt;, &lt;a href=&quot;http://www.youtube.com/watch?v=hqAyiqUs93c&quot;&gt;End to End with Laravel 4 (video)&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PHP는 : &lt;/strong&gt;&lt;a href=&quot;http://blog.brunoscopelliti.com/building-a-restful-web-service-with-angularjs-and-php-more-power-with-resource&quot;&gt;편안한 웹 서비스를 구축&lt;/a&gt; , &lt;a href=&quot;http://www.youtube.com/watch?v=hqAyiqUs93c&quot;&gt;끝 Laravel 4 (비디오)로 종료하기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b054fa14b9f8995a1c15e748a733fb1cf28c399a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paid online:&lt;/strong&gt;&lt;a href=&quot;https://www.pluralsight.com/search?q=angularjs&quot;&gt;Pluralsight&lt;/a&gt;, &lt;a href=&quot;https://tutsplus.com/course/easier-js-apps-with-angular/&quot;&gt;Tuts+&lt;/a&gt;, &lt;a href=&quot;http://www.lynda.com/AngularJS-tutorials/Up-Running-AngularJS/133318-2.html&quot;&gt;lynda.com&lt;/a&gt;, &lt;a href=&quot;http://www.wintellectnow.com/Course/Detail/mastering-angularjs&quot;&gt;WintellectNOW (4 lessons)&lt;/a&gt;, &lt;a href=&quot;https://www.packtpub.com/web-development/angularjs-maintaining-web-applications&quot;&gt;Packt&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;온라인 지불 : &lt;/strong&gt;&lt;a href=&quot;https://www.pluralsight.com/search?q=angularjs&quot;&gt;Pluralsight&lt;/a&gt; , &lt;a href=&quot;https://tutsplus.com/course/easier-js-apps-with-angular/&quot;&gt;Tuts +&lt;/a&gt; , &lt;a href=&quot;http://www.lynda.com/AngularJS-tutorials/Up-Running-AngularJS/133318-2.html&quot;&gt;lynda.com&lt;/a&gt; , &lt;a href=&quot;http://www.wintellectnow.com/Course/Detail/mastering-angularjs&quot;&gt;WintellectNOW (4 수업)&lt;/a&gt; , &lt;a href=&quot;https://www.packtpub.com/web-development/angularjs-maintaining-web-applications&quot;&gt;Packt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ed46aedfd7b0fd6c026a8e38d2a8ce283872b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paid onsite:&lt;/strong&gt;&lt;a href=&quot;http://angularbootcamp.com/&quot;&gt;angularbootcamp.com&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;유료 현장 : &lt;/strong&gt;&lt;a href=&quot;http://angularbootcamp.com/&quot;&gt;angularbootcamp.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef361f872ee0abe6437ca670508f1edf68b6175d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing an expression generated from user provided content as a predicate to &lt;code&gt;orderBy&lt;/code&gt; pipe&lt;/strong&gt;: &lt;code&gt;{{ value | orderBy : userContent }}&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;사용자가 제공 한 컨텐츠에서 생성 된 표현식을 &lt;code&gt;orderBy&lt;/code&gt; pipe에 술어로 전달&lt;/strong&gt; : &lt;code&gt;{{ value | orderBy : userContent }}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a49a97f0edbf657da69f757aee03a753983b32c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing an expression generated from user-provided content in calls to services that parse expressions&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;호출에서 사용자 제공 컨텐츠에서 생성 된 표현식을 표현식을 구문 분석하는 서비스에 전달&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="ba373bfdf6ea17c370636f865ce98036d187cbe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passing an expression generated from user-provided content in calls to the following methods on a &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;사용자가 제공 한 컨텐츠에서 생성 된 표현식을 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 의 다음 메소드에 대한 호출로 전달합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7b6c34e4e6dfb6bb513c537e719eef4875800a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Progressive enhancement&lt;/strong&gt;: Some users do not browse with JavaScript enabled or do not have the latest browser. An accessible message about site requirements can inform users and improve the experience.</source>
          <target state="translated">&lt;strong&gt;점진적 향상&lt;/strong&gt; : 일부 사용자는 JavaScript가 활성화 된 상태로 탐색하지 않거나 최신 브라우저가 없습니다. 사이트 요구 사항에 대한 액세스 가능한 메시지는 사용자에게 알리고 환경을 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5dbbea29c67d64aa80bbcb732589e138e7f1c3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Properties&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b2caabe019481b97276f492b585ec123276f9ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESTful services:&lt;/strong&gt;&lt;a href=&quot;https://github.com/mgonto/restangular&quot;&gt;Restangular&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;RESTful 서비스 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/mgonto/restangular&quot;&gt;Restangular&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fc726fc1694d2026c213ec7c238c454994e3951" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rails: &lt;/strong&gt;&lt;a href=&quot;http://coderberry.me/blog/2013/04/22/angularjs-on-rails-4-part-1/&quot;&gt;Tutorial&lt;/a&gt;, &lt;a href=&quot;https://shellycloud.com/blog/2013/10/how-to-integrate-angularjs-with-rails-4&quot;&gt;AngularJS with Rails4&lt;/a&gt;, &lt;a href=&quot;https://github.com/hiravgandhi/angularjs-rails&quot;&gt;angularjs-rails&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;레일즈 : &lt;/strong&gt;&lt;a href=&quot;http://coderberry.me/blog/2013/04/22/angularjs-on-rails-4-part-1/&quot;&gt;튜토리얼&lt;/a&gt; , &lt;a href=&quot;https://shellycloud.com/blog/2013/10/how-to-integrate-angularjs-with-rails-4&quot;&gt;AngularJS with Rails4&lt;/a&gt; , &lt;a href=&quot;https://github.com/hiravgandhi/angularjs-rails&quot;&gt;angularjs-rails&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35f61f48a504bab275e88d2b627834431d260550" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Realtime Communication: &lt;/strong&gt;&lt;a href=&quot;http://www.creativebloq.com/javascript/angularjs-collaboration-board-socketio-2132885&quot;&gt;Socket.io&lt;/a&gt;, &lt;a href=&quot;https://github.com/jeffbcross/omnibinder&quot;&gt;OmniBinder&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;실시간 커뮤니케이션 : &lt;/strong&gt;&lt;a href=&quot;http://www.creativebloq.com/javascript/angularjs-collaboration-board-socketio-2132885&quot;&gt;Socket.io&lt;/a&gt; , &lt;a href=&quot;https://github.com/jeffbcross/omnibinder&quot;&gt;OmniBinder&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c4b1881e3ea790d1b4cb8dcf56958e79b072995" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RegExp&lt;/strong&gt; (&lt;em&gt;see caveat below&lt;/em&gt;)</source>
          <target state="translated">&lt;strong&gt;RegExp&lt;/strong&gt; ( &lt;em&gt;아래의 경고 참조&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="2f424009ac2309fbb979e7f9569fcfa54550fbb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Registering callbacks:&lt;/strong&gt; Registering callbacks clutters your code, making it hard to see the forest for the trees. Removing common boilerplate code such as callbacks is a good thing. It vastly reduces the amount of JavaScript coding &lt;em&gt;you&lt;/em&gt; have to do, and it makes it easier to see what your application does.</source>
          <target state="translated">&lt;strong&gt;콜백 등록 : 콜백을&lt;/strong&gt; 등록하면 코드가 복잡 해져서 트리의 포리스트를보기가 어렵습니다. 콜백과 같은 일반적인 상용구 코드를 제거하는 것이 좋습니다. 그것은 크게 코딩 자바 스크립트의 양을 감소 &lt;em&gt;당신이&lt;/em&gt; 해야 할, 그리고 그것이 쉽게 응용 프로그램이 무엇을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bda6b80bdaa77386bd7e68ba0999abefbe67c29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SEO:&lt;/strong&gt;&lt;a href=&quot;http://www.yearofmoo.com/2012/11/angularjs-and-seo.html&quot;&gt;By hand&lt;/a&gt;, &lt;a href=&quot;http://prerender.io/&quot;&gt;prerender.io&lt;/a&gt;, &lt;a href=&quot;http://www.brombone.com/&quot;&gt;Brombone&lt;/a&gt;, &lt;a href=&quot;http://getseojs.com/&quot;&gt;SEO.js&lt;/a&gt;, &lt;a href=&quot;http://www.seo4ajax.com/&quot;&gt;SEO4Ajax&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;SEO : &lt;/strong&gt;&lt;a href=&quot;http://www.yearofmoo.com/2012/11/angularjs-and-seo.html&quot;&gt;손으로&lt;/a&gt; , &lt;a href=&quot;http://prerender.io/&quot;&gt;prerender.io&lt;/a&gt; , &lt;a href=&quot;http://www.brombone.com/&quot;&gt;Brombone&lt;/a&gt; , &lt;a href=&quot;http://getseojs.com/&quot;&gt;SEO.js&lt;/a&gt; , &lt;a href=&quot;http://www.seo4ajax.com/&quot;&gt;SEO4Ajax&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b7329df37cbcee74f573d40974e8bfc0d92b934" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SQL and NoSQL backends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQL 및 NoSQL 백엔드 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="acf1014f44dc0693085e4a0ab0bf149931716756" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scope destruction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;범위 파괴&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="076280b82e27232af3c9aa1b34ea31f26250c8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security:&lt;/strong&gt;&lt;a href=&quot;guide/security&quot;&gt;Security Docs&lt;/a&gt;, &lt;a href=&quot;api/ng/service/%24sce&quot;&gt;Strict Contextual Escaping&lt;/a&gt;, &lt;a href=&quot;api/ng/directive/ngcsp&quot;&gt;Content Security Policy&lt;/a&gt;, &lt;a href=&quot;api/ngsanitize/service/%24sanitize&quot;&gt;$sanitize&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=18ifoT-Id54&quot;&gt;video&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;보안 : &lt;/strong&gt;&lt;a href=&quot;guide/security&quot;&gt;보안 문서&lt;/a&gt; , &lt;a href=&quot;api/ng/service/%24sce&quot;&gt;엄격한 문맥 이탈&lt;/a&gt; , &lt;a href=&quot;api/ng/directive/ngcsp&quot;&gt;콘텐츠 보안 정책&lt;/a&gt; , &lt;a href=&quot;api/ngsanitize/service/%24sanitize&quot;&gt;$ sanitize&lt;/a&gt; , &lt;a href=&quot;https://www.youtube.com/watch?v=18ifoT-Id54&quot;&gt;비디오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3818895c2eaf69923be55c09ae40035c7a33fc1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security:&lt;/strong&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=18ifoT-Id54&quot;&gt;video&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Security:&lt;/strong&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=18ifoT-Id54&quot;&gt;video&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="731d5463075faa14e1925cfee5778a98b6fb8b60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Specific UI Elements:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;특정 UI 요소 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9d146aba5991ca9690d0ebf1b69c1d2ad2110eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String&lt;/strong&gt; (except the special value &lt;code&gt;'self'&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;문자열&lt;/strong&gt; (특수 값 &lt;code&gt;'self'&lt;/code&gt; 제외 )</target>
        </trans-unit>
        <trans-unit id="45fd1f66005840cbb6e08d3413cddd2bf1c094d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Text alternatives&lt;/strong&gt;: Add alternate text content to make visual information accessible using &lt;a href=&quot;http://www.w3.org/TR/html-alt-techniques/&quot;&gt;these W3C guidelines&lt;/a&gt;. The appropriate technique depends on the specific markup but can be accomplished using offscreen spans, &lt;code&gt;aria-label&lt;/code&gt; or label elements, image &lt;code&gt;alt&lt;/code&gt; attributes, &lt;code&gt;figure&lt;/code&gt;/&lt;code&gt;figcaption&lt;/code&gt; elements and more.</source>
          <target state="translated">&lt;strong&gt;대체 텍스트&lt;/strong&gt; : 사용하여 시각 정보에 액세스 할 수 있도록 대체 텍스트의 내용을 추가합니다 &lt;a href=&quot;http://www.w3.org/TR/html-alt-techniques/&quot;&gt;다음 W3C 지침을&lt;/a&gt; . 적절한 기술은 특정 태그에 의존하지만, 오프 스크린 아우르 사용하여 달성 될 수 &lt;code&gt;aria-label&lt;/code&gt; 또는 라벨 요소 화상 &lt;code&gt;alt&lt;/code&gt; 특성 &lt;code&gt;figure&lt;/code&gt; / &lt;code&gt;figcaption&lt;/code&gt; 의 요소를 더.</target>
        </trans-unit>
        <trans-unit id="fba8d19cd4f7dea6aaa365182952d5236f7ad9d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The $location service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;$ location 서비스 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b7007892454ee4088595e9c377a077a8c78c5c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is a dangerous API, which you use at your own risk!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것은 위험한 API이며, 귀하는 자신의 책임하에 사용해야합니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="101f5499ee7b85073fb5b7d462d7ebab58281432" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Touch events:&lt;/strong&gt;&lt;a href=&quot;api/ngtouch&quot;&gt;Touch events&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;터치 이벤트 : &lt;/strong&gt;&lt;a href=&quot;api/ngtouch&quot;&gt;터치 이벤트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca46b9f8a99de723a70b66185c89b9dce9c64fbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Underscore notation&lt;/strong&gt;: The use of the underscore notation (e.g.: &lt;code&gt;_$rootScope_&lt;/code&gt;) is a convention wide spread in AngularJS community to keep the variable names clean in your tests. That's why the &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt;&lt;code&gt;$injector&lt;/code&gt;&lt;/a&gt; strips out the leading and the trailing underscores when matching the parameters. The underscore rule applies &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; if the name starts &lt;strong&gt;and&lt;/strong&gt; ends with exactly one underscore, otherwise no replacing happens.</source>
          <target state="translated">&lt;strong&gt;밑줄 표기법&lt;/strong&gt; : 밑줄 표기법 (예 : &lt;code&gt;_$rootScope_&lt;/code&gt; )을 사용하면 변수 이름을 테스트에서 깨끗하게 유지하기 위해 AngularJS 커뮤니티에서 널리 사용됩니다. 이것이 바로 &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt; &lt;code&gt;$injector&lt;/code&gt; &lt;/a&gt; 가 매개 변수와 일치 할 때 선행 및 후행 밑줄을 제거하는 이유 입니다. 밑줄 규칙 은 이름이 정확히 하나의 밑줄로 시작 &lt;strong&gt;하고&lt;/strong&gt; 끝나는 경우 &lt;strong&gt;&lt;em&gt;에만&lt;/em&gt;&lt;/strong&gt; 적용 &lt;strong&gt;&lt;em&gt;되며&lt;/em&gt;&lt;/strong&gt; , 그렇지 않으면 대체가 발생하지 않습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c9695aa3f0771d41376db49cc30e5d66abe41a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unit testing:&lt;/strong&gt;&lt;a href=&quot;http://karma-runner.github.io&quot;&gt;Karma&lt;/a&gt;, &lt;a href=&quot;guide/unit-testing&quot;&gt;Unit testing&lt;/a&gt;, &lt;a href=&quot;guide/services#unit-testing.html&quot;&gt;Testing services&lt;/a&gt;,</source>
          <target state="translated">&lt;strong&gt;단위 테스트 : &lt;/strong&gt;&lt;a href=&quot;http://karma-runner.github.io&quot;&gt;Karma&lt;/a&gt; , &lt;a href=&quot;guide/unit-testing&quot;&gt;단위 테스트&lt;/a&gt; , &lt;a href=&quot;guide/services#unit-testing.html&quot;&gt;테스트 서비스&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="eeca4842d131502c4e4d20da777344377746dd2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unit testing:&lt;/strong&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=YG5DEzaQBIc&quot;&gt;Using Karma (video)&lt;/a&gt;, &lt;a href=&quot;http://blog.jetbrains.com/webstorm/2013/10/running-javascript-tests-with-karma-in-webstorm-7/&quot;&gt;Karma in Webstorm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;단위 테스트 : &lt;/strong&gt;&lt;a href=&quot;http://blog.jetbrains.com/webstorm/2013/10/running-javascript-tests-with-karma-in-webstorm-7/&quot;&gt;Webstorm에서 &lt;/a&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=YG5DEzaQBIc&quot;&gt;Karma (비디오)&lt;/a&gt; , Karma 사용</target>
        </trans-unit>
        <trans-unit id="c1824507e8d65146ba51fd2f682f8bce763fbcb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Visualization:&lt;/strong&gt;&lt;a href=&quot;http://gaslight.co/blog/angular-backed-svgs&quot;&gt;SVG&lt;/a&gt;, &lt;a href=&quot;http://www.ng-newsletter.com/posts/d3-on-angular.html&quot;&gt;D3.js&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;시각화 : &lt;/strong&gt;&lt;a href=&quot;http://gaslight.co/blog/angular-backed-svgs&quot;&gt;SVG&lt;/a&gt; , &lt;a href=&quot;http://www.ng-newsletter.com/posts/d3-on-angular.html&quot;&gt;D3.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43b420f64ccef0d7a45849c939b529e0440f143d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Be careful not to cause &quot;double-submission&quot; by using both the &lt;code&gt;ngClick&lt;/code&gt; and &lt;code&gt;ngSubmit&lt;/code&gt; handlers together. See the &lt;a href=&quot;form#submitting-a-form-and-preventing-the-default-action.html&quot;&gt;&lt;code&gt;form&lt;/code&gt; directive documentation&lt;/a&gt; for a detailed discussion of when &lt;code&gt;ngSubmit&lt;/code&gt; may be triggered.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;code&gt;ngClick&lt;/code&gt; 및 &lt;code&gt;ngSubmit&lt;/code&gt; 핸들러를 함께 사용하여 &quot;이중 제출&quot;이 발생하지 않도록주의하십시오 . &lt;code&gt;ngSubmit&lt;/code&gt; 이 언제 트리거 될 수 있는지에 대한 자세한 설명은 &lt;a href=&quot;form#submitting-a-form-and-preventing-the-default-action.html&quot;&gt; &lt;code&gt;form&lt;/code&gt; 지시문 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2756abf1eaa19230be9bb95e04f5d2e16307d6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5217522448e77af8b97a21a877276a4ab365b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Watcher registration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;감시자 등록&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28bd0a25092a659fd8466d8287ab8ba78d234c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does it mean to &quot;compile&quot; an HTML template?&lt;/strong&gt; For AngularJS, &quot;compilation&quot; means attaching directives to the HTML to make it interactive. The reason we use the term &quot;compile&quot; is that the recursive process of attaching directives mirrors the process of compiling source code in &lt;a href=&quot;http://en.wikipedia.org/wiki/Compiled_languages&quot;&gt;compiled programming languages&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;HTML 템플릿을 &quot;컴파일&quot;한다는 것은 무엇을 의미합니까? &lt;/strong&gt;AngularJS의 경우 &quot;컴파일&quot;은 대화식으로 만들기 위해 지시문을 HTML에 첨부하는 것을 의미합니다. &quot;컴파일&quot;이라는 용어를 사용하는 이유는 지시문을 첨부하는 재귀 프로세스가 &lt;a href=&quot;http://en.wikipedia.org/wiki/Compiled_languages&quot;&gt;컴파일 된 프로그래밍 언어로&lt;/a&gt; 소스 코드를 컴파일 하는 프로세스를 반영하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="664e7640cdaa2696eb7827afab80580a8f9cf489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use an attribute versus an element?&lt;/strong&gt; Use an element when you are creating a component that is in control of the template. The common case for this is when you are creating a Domain-Specific Language for parts of your template. Use an attribute when you are decorating an existing element with new functionality.</source>
          <target state="translated">&lt;strong&gt;속성과 요소를 언제 사용해야합니까? &lt;/strong&gt;템플리트를 제어하는 ​​구성 요소를 작성할 때 요소를 사용하십시오. 일반적인 경우는 템플릿의 일부에 대해 도메인 별 언어를 만들 때입니다. 새로운 기능으로 기존 요소를 장식 할 때 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2feab5c0d7b5da0795b0fa56ef78488f3d7f1a9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Workflow:&lt;/strong&gt;&lt;a href=&quot;https://github.com/yeoman/generator-angular&quot;&gt;Yeoman.io&lt;/a&gt; and &lt;a href=&quot;http://www.sitepoint.com/kickstart-your-angularjs-development-with-yeoman-grunt-and-bower/&quot;&gt;AngularJS Yeoman Tutorial&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;워크 플로우 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/yeoman/generator-angular&quot;&gt;Yeoman.io&lt;/a&gt; 및 &lt;a href=&quot;http://www.sitepoint.com/kickstart-your-angularjs-development-with-yeoman-grunt-and-bower/&quot;&gt;AngularJS Yeoman 튜토리얼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f3f6ab59fb7d12e56b5eff068180765cef04fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Writing tons of initialization code just to get started:&lt;/strong&gt; Typically you need to write a lot of plumbing just to get a basic &quot;Hello World&quot; AJAX app working. With AngularJS you can bootstrap your app easily using services, which are auto-injected into your application in a &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt;-like dependency-injection style. This allows you to get started developing features quickly. As a bonus, you get full control over the initialization process in automated tests.</source>
          <target state="translated">&lt;strong&gt;시작하기 위해 수많은 초기화 코드 작성 :&lt;/strong&gt; 일반적으로 기본 &quot;Hello World&quot;AJAX 앱이 작동하도록하려면 많은 수의 배관을 작성해야합니다. AngularJS를 사용하면 &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt; 와 같은 의존성 주입 스타일로 애플리케이션에 자동 주입되는 서비스를 사용하여 앱을 쉽게 부트 스트랩 할 수 있습니다 . 이를 통해 기능 개발을 빠르게 시작할 수 있습니다. 또한 자동화 된 테스트에서 초기화 프로세스를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="837a994c27693c0ffafa5e8b6bbd93b59ef4b61a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can use suitably sanitized server-side templating to dynamically generate CSS, URLs, etc, but not for generating templates that are bootstrapped/compiled by AngularJS.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;적절하게 위생 처리 된 서버 측 템플릿을 사용하여 CSS, URL 등을 동적으로 생성 할 수 있지만 AngularJS에서 부트 스트랩 / 컴파일 한 템플릿은 생성 할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f42b5ce071116456c1fc4e1cc56cd6b04c6d1be1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a library&lt;/strong&gt; - a collection of functions which are useful when writing web apps. Your code is in charge and it calls into the library when it sees fit. E.g., &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;라이브러리&lt;/strong&gt; -웹 앱을 작성할 때 유용한 함수 모음입니다. 귀하의 코드는 담당하고 있으며 적합 할 때 라이브러리를 호출합니다. 예, &lt;code&gt;jQuery&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="98932b647226b8e2849198caedd642fb90dab6d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;actions&lt;/strong&gt; - &lt;code&gt;{Object.&amp;lt;Object&amp;gt;}&lt;/code&gt; - A hash with default actions declarations. Actions are high-level methods corresponding to RESTful actions/methods on resources. An action may specify what HTTP method to use, what URL to hit, if the return value will be a single object or a collection (array) of objects etc. For more details, see &lt;a href=&quot;../service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt;. The actions can also be enhanced or overwritten per resource class.</source>
          <target state="translated">&lt;strong&gt;행동&lt;/strong&gt; - &lt;code&gt;{Object.&amp;lt;Object&amp;gt;}&lt;/code&gt; - 기본 동작 선언있는 해시. 작업은 리소스에 대한 RESTful 작업 / 방법에 해당하는 고급 방법입니다. 리턴 값이 단일 오브젝트 또는 오브젝트 콜렉션 (배열) 인 경우 조치는 사용할 HTTP 메소드, 적중 URL을 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 자원 클래스별로 조치를 향상 시키거나 겹쳐 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2d2c0ce8d29d9f4e2bfa9fb62c6f4ed866864e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;addClass&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - space-separated CSS classes to add to element</source>
          <target state="translated">&lt;strong&gt;addClass&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 요소에 추가 할 공백으로 구분 된 CSS 클래스</target>
        </trans-unit>
        <trans-unit id="3b880e37bc32e5066151f7c349b650275f496d8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaChecked&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-checked tags</source>
          <target state="translated">&lt;strong&gt;ariaChecked&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-checked 태그를 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b4566b629259ed3938a66f9e2c09e41cca0eff67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaDisabled&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-disabled tags</source>
          <target state="translated">&lt;strong&gt;ariaDisabled&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-disabled 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="ec84a05dd50e86c6d693d672c9a56938940d4df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaHidden&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-hidden tags</source>
          <target state="translated">&lt;strong&gt;ariaHidden&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-hidden 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="f5b6a851da6c7f1da90b7c258c89ea999da5724f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaInvalid&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-invalid tags</source>
          <target state="translated">&lt;strong&gt;ariaInvalid&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-invalid 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="30e1dd087a2dff3e1ba2b39d2a8f8f28db460895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaReadonly&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-readonly tags</source>
          <target state="translated">&lt;strong&gt;ariaReadonly&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-readonly 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="74982eb7100114452e4662b17862a0c7316b3e8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaRequired&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-required tags</source>
          <target state="translated">&lt;strong&gt;ariaRequired&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria 필수 태그를 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3de219a7746396ec7fc8c7048e94be789af81626" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ariaValue&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags</source>
          <target state="translated">&lt;strong&gt;ariaValue&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; aria-valuemin, aria-valuemax 및 aria-valuenow 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="a93636a21222157a7d39caeced98d0d0220354e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bindKeydown&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables keyboard event binding on non-interactive elements (such as &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;li&lt;/code&gt;) using ng-click, making them more accessible to users of assistive technologies</source>
          <target state="translated">&lt;strong&gt;bindKeydown&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; ng-click을 사용하여 비대화 형 요소 (예 : &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;li&lt;/code&gt; ) 에서 키보드 이벤트 바인딩을 활성화 / 비활성화 하여 보조 기술 사용자가보다 쉽게 ​​액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="1f938a576e462e2e78209117c19b46118b383162" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bindRoleForClick&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Adds role=button to non-interactive elements (such as &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;li&lt;/code&gt;) using ng-click, making them more accessible to users of assistive technologies</source>
          <target state="translated">&lt;strong&gt;bindRoleForClick&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; ng-click을 사용하여 비 대화식 요소 (예 : &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;li&lt;/code&gt; )에 role = button을 추가 하여 보조 기술 사용자가보다 쉽게 ​​액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="1ebc19fcbae29f07eb55d62df4481b4901b11803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cache&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean|Object}&lt;/code&gt; &amp;ndash; A boolean value or object created with &lt;a href=&quot;%24cachefactory&quot;&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;&lt;/a&gt; to enable or disable caching of the HTTP response. See &lt;a href=&quot;%24http#caching.html&quot;&gt;$http Caching&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;cache&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean|Object}&lt;/code&gt; &amp;ndash; HTTP 응답의 캐싱을 활성화 또는 비활성화하기 위해 &lt;a href=&quot;%24cachefactory&quot;&gt; &lt;code&gt;$cacheFactory&lt;/code&gt; &lt;/a&gt; 로 생성 된 부울 값 또는 객체입니다 . 자세한 정보는 &lt;a href=&quot;%24http#caching.html&quot;&gt;$ http 캐싱&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d19728a0bfc86797b2d9cc70edb8c8754da2aec7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cancellable&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; If true, the request made by a &quot;non-instance&quot; call will be cancelled (if not already completed) by calling &lt;code&gt;$cancelRequest()&lt;/code&gt; on the call's return value. For more details, see &lt;a href=&quot;../service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt;. This can be overwritten per resource class or action.</source>
          <target state="translated">&lt;strong&gt;cancellable&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; true 인 경우 &quot;인스턴스가 아닌&quot;호출 에 의한 요청은 호출의 반환 값에서 &lt;code&gt;$cancelRequest()&lt;/code&gt; 를 호출하여 취소됩니다 (아직 완료되지 않은 경우 ) . 자세한 내용은 &lt;a href=&quot;../service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 자원 클래스 또는 조치별로 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54ba2b4f61e1d9303b95bacf774efcb814bbe9c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;child scope&lt;/strong&gt; + &lt;strong&gt;child scope&lt;/strong&gt; =&amp;gt; Both directives will share one single child scope</source>
          <target state="translated">&lt;strong&gt;자식 범위&lt;/strong&gt; + &lt;strong&gt;자식 범위&lt;/strong&gt; =&amp;gt; 두 지시어 모두 하나의 자식 범위를 공유합니다</target>
        </trans-unit>
        <trans-unit id="8e9bcb2c30cc37bc699c2bf46b1e5cd7b8752bd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;child scope&lt;/strong&gt; + &lt;strong&gt;no scope&lt;/strong&gt; =&amp;gt; Both directives will share one single child scope</source>
          <target state="translated">&lt;strong&gt;자식 범위&lt;/strong&gt; + &lt;strong&gt;범위 &lt;/strong&gt;&lt;strong&gt;없음&lt;/strong&gt; =&amp;gt; 두 지시어 모두 하나의 자식 범위를 공유합니다</target>
        </trans-unit>
        <trans-unit id="8502152cb2a6790191684eea0be8b0e6958819b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;config&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object}&lt;/code&gt; &amp;ndash; The configuration object that was used to generate the request.</source>
          <target state="translated">&lt;strong&gt;config&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object}&lt;/code&gt; &amp;ndash; 요청을 생성하는 데 사용 된 구성 개체입니다.</target>
        </trans-unit>
        <trans-unit id="662140cf1387a85b485f928c62a84c04f36e2aa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|Object}&lt;/code&gt; &amp;ndash; Data to be sent as the request message data.</source>
          <target state="translated">&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|Object}&lt;/code&gt; &amp;ndash; 요청 메시지 데이터로 전송 될 데이터.</target>
        </trans-unit>
        <trans-unit id="5f1af385a1cc7a95bfbe95753d773f2d47e066fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|Object}&lt;/code&gt; &amp;ndash; The response body transformed with the transform functions.</source>
          <target state="translated">&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|Object}&lt;/code&gt; &amp;ndash; 변환 함수로 변환 된 응답 본문.</target>
        </trans-unit>
        <trans-unit id="b80e157d8b23723a50936794e8e443415bc93df4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;domain&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - The cookie will be available only for this domain and its sub-domains. For security reasons the user agent will not accept the cookie if the current domain is not a sub-domain of this domain or equal to it.</source>
          <target state="translated">&lt;strong&gt;도메인&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 쿠키는이 도메인 및 하위 도메인에 대해 사용할 수 있습니다. 보안상의 이유로 사용자 에이전트는 현재 도메인이이 도메인의 하위 도메인이 아니거나 같은 경우 쿠키를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="128553ab9ab0e05c4ab4a84338d7a953631a3185" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;enabled&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; (default: false) If true, will rely on &lt;code&gt;history.pushState&lt;/code&gt; to change urls where supported. Will fall back to hash-prefixed paths in browsers that do not support &lt;code&gt;pushState&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;enabled&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; (기본값 : false) true 인 경우 지원되는 경우 URL을 변경하기 위해 &lt;code&gt;history.pushState&lt;/code&gt; 를 사용합니다. &lt;code&gt;pushState&lt;/code&gt; 를 지원하지 않는 브라우저에서 해시 접두사 경로로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="d727d563ac38884edda5ae3de43341e5d7ae4a4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;event&lt;/strong&gt;&lt;code&gt;{String}&lt;/code&gt; - The name of the animation event (e.g. &lt;code&gt;enter&lt;/code&gt;, &lt;code&gt;leave&lt;/code&gt;, &lt;code&gt;addClass&lt;/code&gt; etc).</source>
          <target state="translated">&lt;strong&gt;event &lt;/strong&gt; &lt;code&gt;{String}&lt;/code&gt; -애니메이션 이벤트의 이름입니다 (예 : &lt;code&gt;enter&lt;/code&gt; , &lt;code&gt;leave&lt;/code&gt; , &lt;code&gt;addClass&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="63abc4452ff2982408c11e34a986d4b004794707" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eventHandlers&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - Event listeners to be bound to the XMLHttpRequest object. To bind events to the XMLHttpRequest upload object, use &lt;code&gt;uploadEventHandlers&lt;/code&gt;. The handler will be called in the context of a &lt;code&gt;$apply&lt;/code&gt; block.</source>
          <target state="translated">&lt;strong&gt;eventHandlers&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - 이벤트 리스너는 XMLHttpRequest의 개체에 바인딩합니다. 이벤트를 XMLHttpRequest 업로드 객체에 바인딩하려면 &lt;code&gt;uploadEventHandlers&lt;/code&gt; 를 사용 하십시오 . 핸들러는 &lt;code&gt;$apply&lt;/code&gt; 블록 의 컨텍스트에서 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcfcdc7c176b0da776cad529dafbf2335547158e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;expires&lt;/strong&gt; - &lt;code&gt;{string|Date}&lt;/code&gt; - String of the form &quot;Wdy, DD Mon YYYY HH:MM:SS GMT&quot; or a Date object indicating the exact date/time this cookie will expire.</source>
          <target state="translated">&lt;strong&gt;만료&lt;/strong&gt; - &lt;code&gt;{string|Date}&lt;/code&gt; - 문자열 형태 &quot;Wdy, DD 월 YYYY HH : MM : SS GMT&quot;또는이 쿠키가 만료되는 정확한 날짜 / 시간을 나타내는 Date 객체.</target>
        </trans-unit>
        <trans-unit id="2656cc29c637fb21f8e27327beb17e5e36dfd9e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;frameworks&lt;/strong&gt; - a particular implementation of a web application, where your code fills in the details. The framework is in charge and it calls into your code when it needs something app specific. E.g., &lt;code&gt;durandal&lt;/code&gt;, &lt;code&gt;ember&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;strong&gt;프레임 워크&lt;/strong&gt; -코드가 세부 사항을 채우는 웹 애플리케이션의 특정 구현입니다. 프레임 워크는 책임이 있으며 앱 고유의 것이 필요할 때 코드를 호출합니다. 예 : &lt;code&gt;durandal&lt;/code&gt; , &lt;code&gt;ember&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="5670e234f5705492daf7befb2ad1d2ae5caf2766" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;from&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - CSS properties &amp;amp; values at the beginning of animation. Must have matching &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;에서&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - 애니메이션의 시작 부분에 CSS 속성 및 값. 에 일치해야 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b091f4e3a87ebd01ba917c0b3435cc77e175a24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;function&lt;/strong&gt;: A getter function called everytime &lt;code&gt;$anchorScroll()&lt;/code&gt; is executed. Must return a number representing the offset (in pixels).</source>
          <target state="translated">&lt;strong&gt;function&lt;/strong&gt; : &lt;code&gt;$anchorScroll()&lt;/code&gt; 이 실행될 때마다 호출되는 getter 함수 . 오프셋을 나타내는 숫자를 픽셀 단위로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="92e857dff4997c9bc1ff36c7b2cf176c608091e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;hashPrefix(prefix)&lt;/strong&gt;: &lt;code&gt;{string}&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;hashPrefix (접두사)&lt;/strong&gt; : &lt;code&gt;{string}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="582f879f3edebaeff4ee118aaf6df855b64a7075" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;headers&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object}&lt;/code&gt; &amp;ndash; Map of strings or functions which return strings representing HTTP headers to send to the server. If the return value of a function is null, the header will not be sent. Functions accept a config object as an argument.</source>
          <target state="translated">&lt;strong&gt;headers&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object}&lt;/code&gt; &amp;ndash; 서버로 보낼 HTTP 헤더를 나타내는 문자열을 반환하는 문자열 또는 함수의 맵입니다. 함수의 반환 값이 null이면 헤더가 전송되지 않습니다. 함수는 설정 객체를 인수로 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="e9daa8346bf248ada6861d23bf92e78d2db4888b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;headers&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function([headerName])}&lt;/code&gt; &amp;ndash; Header getter function.</source>
          <target state="translated">&lt;strong&gt;헤더&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function([headerName])}&lt;/code&gt; &amp;ndash; 헤더 게터 함수.</target>
        </trans-unit>
        <trans-unit id="feb861ab325127f385f259aec3c6d753d18eb488" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;html5Mode(mode)&lt;/strong&gt;: &lt;code&gt;{boolean|Object}&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;html5Mode (mode)&lt;/strong&gt; : &lt;code&gt;{boolean|Object}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a792522659c8bad0c4f41a9fed876f069c7f3001" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;htmlElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - A list of elements to extend the current list of HTML elements.</source>
          <target state="translated">&lt;strong&gt;htmlElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - 요소의 목록은 HTML 요소의 현재 목록을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="0a42c76c3fb4084b470b98106340ac1b01895367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;htmlVoidElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - A list of elements to extend the current list of void HTML elements; i.e. elements that do not have an end tag.</source>
          <target state="translated">&lt;strong&gt;htmlVoidElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - 보이드 HTML 요소의 현재 목록을 확장 요소의 목록; 즉, 종료 태그가없는 요소.</target>
        </trans-unit>
        <trans-unit id="e3fba7c55daba09f699627d6ddf5c7f98aebf5dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;id&lt;/strong&gt;: the id of the cache instance</source>
          <target state="translated">&lt;strong&gt;id&lt;/strong&gt; : 캐시 인스턴스의 ID</target>
        </trans-unit>
        <trans-unit id="f8de2446f97561038f35cfbca3fe049fc42c4852" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isolated scope&lt;/strong&gt; + &lt;strong&gt;child scope&lt;/strong&gt; =&amp;gt; &lt;strong&gt;Won't work!&lt;/strong&gt; Only one scope can be related to one element. Therefore these directives cannot be applied to the same element.</source>
          <target state="translated">&lt;strong&gt;격리 된 범위&lt;/strong&gt; + &lt;strong&gt;자식 범위&lt;/strong&gt; =&amp;gt; &lt;strong&gt;작동하지 않습니다! &lt;/strong&gt;하나의 범위는 하나의 요소와 관련 될 수 있습니다. 따라서 이러한 지시문은 동일한 요소에 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="124d7d31ddab47d2d156da6e7c9218c9f4e303b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isolated scope&lt;/strong&gt; + &lt;strong&gt;isolated scope&lt;/strong&gt; =&amp;gt; &lt;strong&gt;Won't work!&lt;/strong&gt; Only one scope can be related to one element. Therefore these directives cannot be applied to the same element.</source>
          <target state="translated">&lt;strong&gt;격리 된 범위&lt;/strong&gt; + &lt;strong&gt;격리 된 범위&lt;/strong&gt; =&amp;gt; &lt;strong&gt;작동하지 않습니다! &lt;/strong&gt;하나의 범위는 하나의 요소와 관련 될 수 있습니다. 따라서 이러한 지시문은 동일한 요소에 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6d1f2d0baa4d824cae5e0344ad362c468b1df71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isolated scope&lt;/strong&gt; + &lt;strong&gt;no scope&lt;/strong&gt; =&amp;gt; The isolated directive will use it's own created isolated scope. The other directive will use its parent's scope</source>
          <target state="translated">&lt;strong&gt;분리 된 범위&lt;/strong&gt; + &lt;strong&gt;범위 &lt;/strong&gt;&lt;strong&gt;없음&lt;/strong&gt; =&amp;gt; 분리 된 지시문은 자체 작성된 분리 된 범위를 사용합니다. 다른 지시어는 부모의 범위를 사용합니다</target>
        </trans-unit>
        <trans-unit id="c4773c7c7695330d0fb94c9c57adbbb2bf149700" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jqLite&lt;/strong&gt;: A jqLite/jQuery element to be used for specifying the offset. The distance from the top of the page to the element's bottom will be used as offset.</source>
          <target state="translated">&lt;strong&gt;jqLite&lt;/strong&gt; : 오프셋을 지정하는 데 사용되는 jqLite / jQuery 요소. 페이지 상단에서 요소 하단까지의 거리가 오프셋으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27a1edc20316d5c41ba1140a1cc228f9cdb92f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;method&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; HTTP method (e.g. 'GET', 'POST', etc)</source>
          <target state="translated">&lt;strong&gt;method&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; HTTP 메소드 (예 : 'GET', 'POST'등)</target>
        </trans-unit>
        <trans-unit id="b8c8b20a9898829cf0f68deb23102862860694a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;no scope&lt;/strong&gt; + &lt;strong&gt;no scope&lt;/strong&gt; =&amp;gt; Two directives which don't require their own scope will use their parent's scope</source>
          <target state="translated">&lt;strong&gt;범위 없음&lt;/strong&gt; + &lt;strong&gt;범위 &lt;/strong&gt;&lt;strong&gt;없음&lt;/strong&gt; =&amp;gt; 자체 범위가 필요하지 않은 두 개의 지시문은 부모 범위를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0e93dba1c9076df304aac7edb503b800b45a7c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;node&lt;/strong&gt;&lt;code&gt;{DOMElement}&lt;/code&gt; - The DOM element to be animated.</source>
          <target state="translated">&lt;strong&gt;node &lt;/strong&gt; &lt;code&gt;{DOMElement}&lt;/code&gt; -애니메이션 될 DOM 요소.</target>
        </trans-unit>
        <trans-unit id="72addb38a35523e85f22360331c35045c03519b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;number&lt;/strong&gt;: A fixed number of pixels to be used as offset.</source>
          <target state="translated">&lt;strong&gt;number&lt;/strong&gt; : 오프셋으로 사용될 고정 된 수의 픽셀.</target>
        </trans-unit>
        <trans-unit id="6bfe42c01803398822405d49a5823f112f8c8264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;objectMaxDepth&lt;/strong&gt;: The maximum depth to which objects are traversed when stringified for error messages.</source>
          <target state="translated">&lt;strong&gt;objectMaxDepth&lt;/strong&gt; : 오류 메시지로 문자열 화 될 때 객체가 통과하는 최대 깊이입니다.</target>
        </trans-unit>
        <trans-unit id="59d0f8dde98a32b496242d2a29226f215bf7c086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt;&lt;code&gt;{Object}&lt;/code&gt; - A collection of options/styles used for the animation.</source>
          <target state="translated">&lt;strong&gt;options &lt;/strong&gt; &lt;code&gt;{Object}&lt;/code&gt; -애니메이션에 사용되는 옵션 / 스타일 모음입니다.</target>
        </trans-unit>
        <trans-unit id="d651a44f16d7b9f660fb78f4848f8fe899718c1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paramSerializer&lt;/strong&gt; - &lt;code&gt;{string|function(Object&amp;lt;string,string&amp;gt;):string}&lt;/code&gt; - A function used to prepare the string representation of request parameters (specified as an object). If specified as string, it is interpreted as function registered with the &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;, which means you can create your own serializer by registering it as a &lt;a href=&quot;../../auto/service/%24provide#service.html&quot;&gt;service&lt;/a&gt;. The default serializer is the &lt;a href=&quot;%24httpparamserializer&quot;&gt;$httpParamSerializer&lt;/a&gt;; alternatively, you can use the &lt;a href=&quot;%24httpparamserializerjqlike&quot;&gt;$httpParamSerializerJQLike&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;paramSerializer&lt;/strong&gt; - &lt;code&gt;{string|function(Object&amp;lt;string,string&amp;gt;):string}&lt;/code&gt; - (객체로 지정) 요청 파라미터의 스트링 표현을 제조하는 데 사용되는 함수. 문자열로 지정하면 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector에&lt;/a&gt; 등록 된 함수로 해석되므로 &lt;a href=&quot;../../auto/service/%24provide#service.html&quot;&gt;서비스&lt;/a&gt; 로 등록하여 고유 한 직렬 변환기를 작성할 수 있습니다 . 기본 시리얼 라이저는 &lt;a href=&quot;%24httpparamserializer&quot;&gt;$ httpParamSerializer입니다&lt;/a&gt; . 또는 &lt;a href=&quot;%24httpparamserializerjqlike&quot;&gt;$ httpParamSerializerJQLike를&lt;/a&gt; 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="eb412c19087d047d702d4bb44d9b2be7ab1a675c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;params&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object.&amp;lt;string|Object&amp;gt;}&lt;/code&gt; &amp;ndash; Map of strings or objects which will be serialized with the &lt;code&gt;paramSerializer&lt;/code&gt; and appended as GET parameters.</source>
          <target state="translated">&lt;strong&gt;params&lt;/strong&gt; &amp;ndash; &lt;code&gt;{Object.&amp;lt;string|Object&amp;gt;}&lt;/code&gt; &amp;ndash; &lt;code&gt;paramSerializer&lt;/code&gt; 로 직렬화 되고 GET 매개 변수로 추가 될 문자열 또는 객체의 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="060adaafb51ecc8f11beb5c933aa7af0d463cd31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - The cookie will be available only for this path and its sub-paths. By default, this is the URL that appears in your &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;strong&gt;경로&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 쿠키는이 경로와 그 하위 경로에 대해 사용할 수 있습니다. 기본적으로이 URL은 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 태그에 나타나는 URL입니다 .</target>
        </trans-unit>
        <trans-unit id="5f3eaf2d48263b11c832c76ce400f5db9b03ae2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;placeholder&lt;/strong&gt; in &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; in Internet Explorer 10/11 (see &lt;a href=&quot;https://github.com/angular/angular.js/issues/5025&quot;&gt;issue 5025&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;자리&lt;/strong&gt; 에서 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 인터넷 익스플로러 10/11 선택 ( &lt;a href=&quot;https://github.com/angular/angular.js/issues/5025&quot;&gt;5025 문제&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4958679eaea1cd6781d8263b662a8d5fd1a73530" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;removeClass&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - space-separated CSS classes to remove from element</source>
          <target state="translated">&lt;strong&gt;removeClass&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 요소에서 제거 할 공백으로 구분 된 CSS 클래스</target>
        </trans-unit>
        <trans-unit id="98c7a336bebc4478053dfdd092b76fa1a2505115" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireBase&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - (default: &lt;code&gt;true&lt;/code&gt;) When html5Mode is enabled, specifies whether or not a  tag is required to be present. If &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;requireBase&lt;/code&gt; are true, and a base tag is not present, an error will be thrown when &lt;code&gt;$location&lt;/code&gt; is injected. See the &lt;a href=&quot;../../../guide/%24location&quot;&gt;$location guide for more information&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;requireBase&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - (기본 : &lt;code&gt;true&lt;/code&gt; ) html5Mode을 사용하면 태그가 필요할지 여부를 지정 존재합니다. 경우 &lt;code&gt;enabled&lt;/code&gt; 및 &lt;code&gt;requireBase&lt;/code&gt; 는 해당하고, 기본 태그 때 오류가 발생합니다, 존재하지 않는 &lt;code&gt;$location&lt;/code&gt; 주입된다. 자세한 내용은 &lt;a href=&quot;../../../guide/%24location&quot;&gt;$ location 안내서를 참조하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ff98c63e2f8647761676a30d4ba3fbaef42096f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;responseType&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#xmlhttprequest-responsetype&quot;&gt;XMLHttpRequest.responseType&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;responseType&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 볼 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#xmlhttprequest-responsetype&quot;&gt;XMLHttpRequest.responseType을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83429cc05bf49200558ea7c8b13a952af6c8c748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rewriteLinks&lt;/strong&gt; - &lt;code&gt;{boolean|string}&lt;/code&gt; - (default: &lt;code&gt;true&lt;/code&gt;) When html5Mode is enabled, enables/disables URL rewriting for relative links. If set to a string, URL rewriting will only happen on links with an attribute that matches the given string. For example, if set to &lt;code&gt;'internal-link'&lt;/code&gt;, then the URL will only be rewritten for &lt;code&gt;&amp;lt;a internal-link&amp;gt;&lt;/code&gt; links. Note that &lt;a href=&quot;../../../guide/directive#normalization.html&quot;&gt;attribute name normalization&lt;/a&gt; does not apply here, so &lt;code&gt;'internalLink'&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;'internal-link'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;rewriteLinks&lt;/strong&gt; - &lt;code&gt;{boolean|string}&lt;/code&gt; - (기본 : &lt;code&gt;true&lt;/code&gt; )을 사용 html5Mode / 비활성화 URL 상대 링크를 재 작성 할 수 있습니다. 문자열로 설정하면 지정된 문자열과 일치하는 속성을 가진 링크에서만 URL 재 작성이 발생합니다. 예를 들어,로 설정하면 &lt;code&gt;'internal-link'&lt;/code&gt; , 다음 URL은 용으로 다시 작성됩니다 &lt;code&gt;&amp;lt;a internal-link&amp;gt;&lt;/code&gt; 링크. 참고 것을 &lt;a href=&quot;../../../guide/directive#normalization.html&quot;&gt;속성 이름 정상화가&lt;/a&gt; 여기에 적용되지 않기 때문에 &lt;code&gt;'internalLink'&lt;/code&gt; 는 것입니다 &lt;strong&gt;하지&lt;/strong&gt; 일치 &lt;code&gt;'internal-link'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f51a95c24827c45784afc6a3873a40fbc1bd7fef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;samesite&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - prevents the browser from sending the cookie along with cross-site requests. Accepts the values &lt;code&gt;lax&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt;. See the &lt;a href=&quot;https://www.owasp.org/index.php/SameSite&quot;&gt;OWASP Wiki&lt;/a&gt; for more info. Note that as of May 2018, not all browsers support &lt;code&gt;SameSite&lt;/code&gt;, so it cannot be used as a single measure against Cross-Site-Request-Forgery (CSRF) attacks.</source>
          <target state="translated">&lt;strong&gt;samesite는&lt;/strong&gt; - &lt;code&gt;{string}&lt;/code&gt; - 크로스 사이트 요청과 함께 쿠키를 보낼 브라우저를 방지 할 수 있습니다. &lt;code&gt;lax&lt;/code&gt; 및 &lt;code&gt;strict&lt;/code&gt; 값을 승인합니다 . 자세한 내용은 &lt;a href=&quot;https://www.owasp.org/index.php/SameSite&quot;&gt;OWASP Wiki&lt;/a&gt; 를 참조하십시오. 2018 년 5 월 현재 모든 브라우저가 &lt;code&gt;SameSite&lt;/code&gt; 를 지원하는 것은 아니므로 CSRF (Cross-Site-Request-Forgery) 공격에 대한 단일 수단으로 사용될 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d7da530df946f3545fca78880b34ff024bfaaa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;secure&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - If &lt;code&gt;true&lt;/code&gt;, then the cookie will only be available through a secured connection.</source>
          <target state="translated">&lt;strong&gt;보안&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - 경우 &lt;code&gt;true&lt;/code&gt; , 그 쿠키는 보안 연결을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2a25b2159af2f5d84818851dec8d42f417bf2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;size&lt;/strong&gt; in &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; elements (see &lt;a href=&quot;https://github.com/angular/angular.js/issues/1619&quot;&gt;issue 1619&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;크기&lt;/strong&gt; 에서 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소 (참고 &lt;a href=&quot;https://github.com/angular/angular.js/issues/1619&quot;&gt;1,619 문제&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9f4ef8b00882dfdcc97c71765bf22fb7abfccf47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;size&lt;/strong&gt;: the number of entries kept in the cache instance</source>
          <target state="translated">&lt;strong&gt;size&lt;/strong&gt; : 캐시 인스턴스에 보관 된 항목 수</target>
        </trans-unit>
        <trans-unit id="df2a02b6376cc0ebb01f5e18aa2d102288edb907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;status&lt;/strong&gt; &amp;ndash; &lt;code&gt;{number}&lt;/code&gt; &amp;ndash; HTTP status code of the response.</source>
          <target state="translated">&lt;strong&gt;status&lt;/strong&gt; &amp;ndash; &lt;code&gt;{number}&lt;/code&gt; &amp;ndash; 응답의 HTTP 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="35ce03bf58d6ec7f55ac8f04a8ebccad62becdbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;statusText&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; HTTP status text of the response.</source>
          <target state="translated">&lt;strong&gt;statusText&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; 응답의 HTTP 상태 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="0345fb2cc138ca84d0cde834fd433d751d6414af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stripTrailingSlashes&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; If true, then the trailing slashes from any calculated URL will be stripped.</source>
          <target state="translated">&lt;strong&gt;stripTrailingSlashes&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; true이면 계산 된 URL의 후행 슬래시가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ea7e3d61cd6b089004feefdef3261d48887930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;svgElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - A list of elements to extend the current list of SVG elements. The list of SVG elements is only taken into account if SVG is &lt;a href=&quot;%24sanitizeprovider#enableSvg.html&quot;&gt;enabled&lt;/a&gt; for &lt;code&gt;$sanitize&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;svgElements&lt;/strong&gt; - &lt;code&gt;{Array&amp;lt;String&amp;gt;}&lt;/code&gt; - 요소의리스트는 SVG 요소의 현재리스트를 확장한다. SVG 요소의 목록은 SVG가 &lt;code&gt;$sanitize&lt;/code&gt; 대해 &lt;a href=&quot;%24sanitizeprovider#enableSvg.html&quot;&gt;활성화 된&lt;/a&gt; 경우에만 고려됩니다 .</target>
        </trans-unit>
        <trans-unit id="50e376066f3f2ada02d92730374d9ebd58e1e323" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tabindex&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; Enables/disables tabindex tags</source>
          <target state="translated">&lt;strong&gt;tabindex&lt;/strong&gt; &amp;ndash; &lt;code&gt;{boolean}&lt;/code&gt; &amp;ndash; tabindex 태그를 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="70e324de17d76b0a9ec0d32b1e7654a6240d0e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;timeout&lt;/strong&gt; &amp;ndash; &lt;code&gt;{number|Promise}&lt;/code&gt; &amp;ndash; timeout in milliseconds, or &lt;a href=&quot;%24q&quot;&gt;promise&lt;/a&gt; that should abort the request when resolved.</source>
          <target state="translated">&lt;strong&gt;timeout&lt;/strong&gt; &amp;ndash; &lt;code&gt;{number|Promise}&lt;/code&gt; &amp;ndash; 밀리 초 단위의 시간 초과 또는 해결시 요청을 중단해야하는 &lt;a href=&quot;%24q&quot;&gt;약속&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e679bd6dc14d74c998593892b9b48ccec9f3a8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;to&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - CSS properties &amp;amp; values at end of animation. Must have matching &lt;code&gt;from&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;에&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - 애니메이션의 끝에서 CSS 속성 및 값. &lt;code&gt;from&lt;/code&gt; 일치해야합니다</target>
        </trans-unit>
        <trans-unit id="3d33b5c0716f7f5b554828e3c86a6d260fde2f1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;transformRequest&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter)|Array.&amp;lt;function(data, headersGetter)&amp;gt;}&lt;/code&gt; &amp;ndash; transform function or an array of such functions. The transform function takes the http request body and headers and returns its transformed (typically serialized) version. See &lt;a href=&quot;%24http#overriding-the-default-transformations-per-request.html&quot;&gt;Overriding the Default Transformations&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;transformRequest&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter)|Array.&amp;lt;function(data, headersGetter)&amp;gt;}&lt;/code&gt; &amp;ndash; 변환 함수 또는 이러한 함수의 배열. transform 함수는 http 요청 본문과 헤더를 가져와 변환 된 (일반적으로 직렬화 된) 버전을 반환합니다. &lt;a href=&quot;%24http#overriding-the-default-transformations-per-request.html&quot;&gt;기본 변환 재정의를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="87f825777fa4ed7bb1205871ba42d32b29aacd6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;transformResponse&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter, status)|Array.&amp;lt;function(data, headersGetter, status)&amp;gt;}&lt;/code&gt; &amp;ndash; transform function or an array of such functions. The transform function takes the http response body, headers and status and returns its transformed (typically deserialized) version. See &lt;a href=&quot;%24http#overriding-the-default-transformations-per-request.html&quot;&gt;Overriding the Default Transformations&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;transformResponse&lt;/strong&gt; &amp;ndash; &lt;code&gt;{function(data, headersGetter, status)|Array.&amp;lt;function(data, headersGetter, status)&amp;gt;}&lt;/code&gt; &amp;ndash; 변환 함수 또는 이러한 함수의 배열. 변환 함수는 http 응답 본문, 헤더 및 상태를 가져와 변환 된 (일반적으로 역 직렬화 된) 버전을 반환합니다. &lt;a href=&quot;%24http#overriding-the-default-transformations-per-request.html&quot;&gt;기본 변환 재정의를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d039bff6529a3e51b665953058a2578bf03ae530" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;type&lt;/strong&gt; in &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; in Internet Explorer 11 (see &lt;a href=&quot;https://github.com/angular/angular.js/issues/5025&quot;&gt;issue 14117&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;Internet Explorer 11 에서 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 을 &lt;strong&gt;입력&lt;/strong&gt; 하십시오 ( &lt;a href=&quot;https://github.com/angular/angular.js/issues/5025&quot;&gt;문제 14117&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9043907a2669b340d01a39ec2d66417c24b13029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;uploadEventHandlers&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - Event listeners to be bound to the XMLHttpRequest upload object. To bind events to the XMLHttpRequest object, use &lt;code&gt;eventHandlers&lt;/code&gt;. The handler will be called in the context of a &lt;code&gt;$apply&lt;/code&gt; block.</source>
          <target state="translated">&lt;strong&gt;uploadEventHandlers&lt;/strong&gt; - &lt;code&gt;{Object}&lt;/code&gt; - 이벤트 리스너는 XMLHttpRequest를 업로드 개체에 바인딩합니다. 이벤트를 XMLHttpRequest 객체에 바인딩하려면 &lt;code&gt;eventHandlers&lt;/code&gt; 를 사용 하십시오 . 핸들러는 &lt;code&gt;$apply&lt;/code&gt; 블록 의 컨텍스트에서 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bca94c5d01d86c53e05d7e629d478ec3750e7c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|TrustedObject}&lt;/code&gt; &amp;ndash; Absolute or relative URL of the resource that is being requested; or an object created by a call to &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;url&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string|TrustedObject}&lt;/code&gt; &amp;ndash; 요청중인 자원의 절대 또는 상대 URL. 또는 &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt; 호출로 생성 된 객체 .</target>
        </trans-unit>
        <trans-unit id="0a760b7dddba992bcb6c8a6db574124bfeae2eb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value&lt;/strong&gt; in &lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt; in Internet Explorer = 11 (see &lt;a href=&quot;https://github.com/angular/angular.js/issues/7218&quot;&gt;issue 7218&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;값&lt;/strong&gt; 의 &lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt; 인터넷 익스플로러에서 = 11 (참조 : &lt;a href=&quot;https://github.com/angular/angular.js/issues/7218&quot;&gt;7218 문제&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d9d9e23f794cf05d52a0d2a6fe3ab544fb89b0e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;withCredentials&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - whether to set the &lt;code&gt;withCredentials&lt;/code&gt; flag on the XHR object. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials&quot;&gt;requests with credentials&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;withCredentials&lt;/strong&gt; - &lt;code&gt;{boolean}&lt;/code&gt; - 세트에 있는지 &lt;code&gt;withCredentials&lt;/code&gt; 의 XHR 객체에 플래그. 자세한 정보 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials&quot;&gt;는 신임&lt;/a&gt; 정보가있는 요청 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b9f84e97e3ba1d5fd7cc6a758d16b678b9e932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;xhrStatus&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; Status of the XMLHttpRequest (&lt;code&gt;complete&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;xhrStatus&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; XMLHttpRequest의 상태 ( &lt;code&gt;complete&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; 또는 &lt;code&gt;abort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d2bbd1de159541f1410dcb870ff574d3ec923734" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;xsrfCookieName&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; Name of cookie containing the XSRF token.</source>
          <target state="translated">&lt;strong&gt;xsrfCookieName&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; XSRF 토큰을 포함하는 쿠키의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="82ebc64de30022400b91cd2832387f47ce545a88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;xsrfHeaderName&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; Name of HTTP header to populate with the XSRF token.</source>
          <target state="translated">&lt;strong&gt;xsrfHeaderName&lt;/strong&gt; &amp;ndash; &lt;code&gt;{string}&lt;/code&gt; &amp;ndash; XSRF 토큰으로 채울 HTTP 헤더의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b2697460deb5f5b660f6f33232f0bbe0994052e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;%24q&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; that will be resolved (request success) or rejected (request failure) with a response object.</source>
          <target state="translated">&lt;a href=&quot;%24q&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 응답 객체 (요청 성공) 또는 거부 (요청 실패) 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f670bf823c39c6ce15ca2cee63a5bda25c59bf4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;module&lt;/a&gt; is a collection of providers, services, directives etc., and optionally config and run blocks which get applied to the application during the bootstrap process.</source>
          <target state="translated">&lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;모듈은&lt;/a&gt; 지침 등을 제공, 서비스의 모음입니다, 그리고 선택적으로 부트 스트랩 과정에서 응용 프로그램에 적용받을 블록을 config (설정) 및 실행합니다.</target>
        </trans-unit>
        <trans-unit id="99f98a62c49c1d357ce0e0c6e22da8b20e044b38" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../function/angular.element&quot;&gt;jQuery or jqLite&lt;/a&gt; wrapper for the browser's &lt;code&gt;window.document&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;../function/angular.element&quot;&gt;jQuery를 또는 jqLite의&lt;/a&gt; 브라우저의 래퍼 &lt;code&gt;window.document&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1b2e7a0bbc83c26ed075072213b62d4c6f673112" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;function/angular.element&quot;&gt;jQuery or jqLite&lt;/a&gt; wrapper for the browser's &lt;code&gt;window.document&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;function/angular.element&quot;&gt;jQuery를 또는 jqLite의&lt;/a&gt; 브라우저의 래퍼 &lt;code&gt;window.document&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7839c71de200f27fd2e542514415551d06c81302" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx&quot;&gt;JSON vulnerability&lt;/a&gt; allows third party website to turn your JSON resource URL into &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; request under some conditions. To counter this your server can prefix all JSON requests with following string &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt;. AngularJS will automatically strip the prefix before processing it as JSON.</source>
          <target state="translated">&lt;a href=&quot;http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx&quot;&gt;JSON 취약점이&lt;/a&gt; 타사 웹 사이트로 JSON 자원 URL을 켤 수 있습니다 &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP의&lt;/a&gt; 일부 조건에서 요청. 이를 방지하기 위해 서버는 모든 JSON 요청 앞에 다음 문자열 &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt; 붙일 수 있습니다 . AngularJS는 접두사를 JSON으로 처리하기 전에 자동으로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2fa15ce24236637c6517ab3482040ede6e84b058" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/blur&quot;&gt;blur event&lt;/a&gt; fires when an element has lost focus.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/blur&quot;&gt;흐림 이벤트&lt;/a&gt; 화재 요소가 손실 포커스가있을 때.</target>
        </trans-unit>
        <trans-unit id="40add3cdd16405c074177fc8110bb43b5ac7fb2b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; with two buttons and a simple message</source>
          <target state="translated">두 개의 버튼과 간단한 메시지가 있는 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="050f37f110fc9fa63e63cd7117b1384816703419" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ComponentInstruction&lt;/code&gt; represents the route state for a single component. An &lt;code&gt;Instruction&lt;/code&gt; is composed of a tree of these &lt;code&gt;ComponentInstruction&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;ComponentInstruction&lt;/code&gt; 는 단일 요소에 대한 경로 상태를 나타낸다. &lt;code&gt;Instruction&lt;/code&gt; 이들의 나무로 구성되어 &lt;code&gt;ComponentInstruction&lt;/code&gt; 의 의.</target>
        </trans-unit>
        <trans-unit id="f8f1e492c2e32412cc2e9ab7f4b7de5a17b72edc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Router&lt;/code&gt; is responsible for mapping URLs to components.</source>
          <target state="translated">&lt;code&gt;Router&lt;/code&gt; 구성 요소에 URL을 매핑 할 책임이있다.</target>
        </trans-unit>
        <trans-unit id="afe91777794606fc3697cc65d25283b9e3db37d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;username&lt;/code&gt; directive that asynchronously checks if a user-entered value is already taken. We mock the server request with a &lt;code&gt;$q&lt;/code&gt; deferred.</source>
          <target state="translated">사용자가 입력 한 값이 이미 사용 중인지 비동기 적으로 확인 하는 &lt;code&gt;username&lt;/code&gt; 지시문입니다. &lt;code&gt;$q&lt;/code&gt; 지연된 서버 요청을 조롱합니다 .</target>
        </trans-unit>
        <trans-unit id="a7878972a098fc3249b245269b4fd298ddb5e251" translate="yes" xml:space="preserve">
          <source>A Controller with two functions that set the value of &lt;code&gt;spice&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spice&lt;/code&gt; 의 가치를 설정하는 두 가지 기능을 가진 컨트롤러</target>
        </trans-unit>
        <trans-unit id="099221b87692bd857151be9e3c242bd9da492b16" translate="yes" xml:space="preserve">
          <source>A Promise that will be resolved or rejected with a response object. See &lt;a href=&quot;%24http#%24http-returns.html&quot;&gt;&lt;code&gt;$http()&lt;/code&gt; return value&lt;/a&gt;.</source>
          <target state="translated">응답 오브젝트로 해결되거나 거부 될 약속. &lt;a href=&quot;%24http#%24http-returns.html&quot;&gt; &lt;code&gt;$http()&lt;/code&gt; 반환 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08542be42901cd2d3503e21ba713f703abed31db" translate="yes" xml:space="preserve">
          <source>A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a curtain-like effect. The ngAnimate module (versions &amp;gt;=1.2) supports staggering animations and the stagger effect can be performed by creating a &lt;strong&gt;ng-EVENT-stagger&lt;/strong&gt; CSS class and attaching that class to the base CSS class used for the animation. The style property expected within the stagger class can either be a &lt;strong&gt;transition-delay&lt;/strong&gt; or an &lt;strong&gt;animation-delay&lt;/strong&gt; property (or both if your animation contains both transitions and keyframe animations).</source>
          <target state="translated">스 태거 애니메이션은 각 연속 작업 사이에 약간의 지연이 발생하여 커튼과 같은 효과를내는 애니메이션 모음입니다. ngAnimate 모듈 (버전&amp;gt; = 1.2)은 스 태거 애니메이션을 지원하며 &lt;strong&gt;ng-EVENT- 스 태거&lt;/strong&gt; CSS 클래스를 만들고 해당 클래스를 애니메이션에 사용되는 기본 CSS 클래스에 연결 하여 스 태거 효과를 수행 할 수 있습니다 . 스 태거 클래스 내에서 예상되는 스타일 속성은 &lt;strong&gt;전환 지연&lt;/strong&gt; 또는 &lt;strong&gt;애니메이션 지연&lt;/strong&gt; 속성 일 수 있습니다 (또는 애니메이션에 전환 및 키 프레임 애니메이션이 모두 포함 된 경우 둘 다).</target>
        </trans-unit>
        <trans-unit id="8b1041ce62379a6088fbb9d282654cc4b528feba" translate="yes" xml:space="preserve">
          <source>A boolean property indicating if routes defined using this provider should be matched using a case insensitive algorithm. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 공급자를 사용하여 정의 된 경로가 대소 문자를 구분하지 않는 알고리즘을 사용하여 일치해야하는지 여부를 나타내는 부울 속성입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fca8caeaa11957e504e1245c3676b49630f2625d" translate="yes" xml:space="preserve">
          <source>A cache object used to store and retrieve data, primarily used by &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$templateRequest&lt;/a&gt; and the &lt;a href=&quot;../directive/script&quot;&gt;script&lt;/a&gt; directive to cache templates and other data.</source>
          <target state="translated">데이터를 저장하고 검색하는 데 사용되는 캐시 객체. 주로 &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$ templateRequest&lt;/a&gt; 및 &lt;a href=&quot;../directive/script&quot;&gt;스크립트&lt;/a&gt; 지시문에서 템플릿 및 기타 데이터를 캐시 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7741c0b5eadb3178c8fd1b6d3cbe41c65898491f" translate="yes" xml:space="preserve">
          <source>A cache object used to store and retrieve data, primarily used by &lt;a href=&quot;service/%24templaterequest&quot;&gt;$templateRequest&lt;/a&gt; and the &lt;a href=&quot;directive/script&quot;&gt;script&lt;/a&gt; directive to cache templates and other data.</source>
          <target state="translated">데이터를 저장하고 검색하는 데 사용되는 캐시 객체. 주로 &lt;a href=&quot;service/%24templaterequest&quot;&gt;$ templateRequest&lt;/a&gt; 및 &lt;a href=&quot;directive/script&quot;&gt;스크립트&lt;/a&gt; 지시문에서 템플릿 및 기타 데이터를 캐시 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ef2ed6994f65370ddeaf83f5b2e47c35d4d5e29" translate="yes" xml:space="preserve">
          <source>A cache-control header on the response does not affect if or how responses are cached.</source>
          <target state="translated">응답의 캐시 제어 헤더는 응답의 캐시 여부에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bfa439ad785ad69c4e2d9f497dacaf475106385" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;$resume()&lt;/code&gt; on a non-suspended scope is a no-op.</source>
          <target state="translated">일시 중단되지 않은 범위에서 &lt;code&gt;$resume()&lt;/code&gt; 을 호출 하면 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9133b855702802c397e165028750356edd7047a4" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;$suspend()&lt;/code&gt; on an already suspended scope is a no-op.</source>
          <target state="translated">이미 일시 중단 된 범위에서 &lt;code&gt;$suspend()&lt;/code&gt; 를 호출 하면 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ea4006eb2cb656edf669af2a4fe53b47d3e21e0" translate="yes" xml:space="preserve">
          <source>A collection of validations that are expected to perform an asynchronous validation (e.g. a HTTP request). The validation function that is provided is expected to return a promise when it is run during the model validation process. Once the promise is delivered then the validation status will be set to true when fulfilled and false when rejected. When the asynchronous validators are triggered, each of the validators will run in parallel and the model value will only be updated once all validators have been fulfilled. As long as an asynchronous validator is unfulfilled, its key will be added to the controllers &lt;code&gt;$pending&lt;/code&gt; property. Also, all asynchronous validators will only run once all synchronous validators have passed.</source>
          <target state="translated">비동기 유효성 검사 (예 : HTTP 요청)를 수행 할 것으로 예상되는 유효성 검사 모음입니다. 제공되는 유효성 검증 기능은 모델 유효성 검증 프로세스 중에 실행될 때 약속을 리턴 할 것으로 예상됩니다. 약속이 전달되면 유효성 검사 상태는 이행되면 true로 설정되고 거부되면 false로 설정됩니다. 비동기 유효성 검증 기가 트리거되면 각 유효성 검증 기가 병렬로 실행되며 모든 유효성 검증 기가 완료된 후에 만 ​​모델 값이 업데이트됩니다. 비동기 유효성 검사기가 수행되지 않으면 해당 키가 컨트롤러의 &lt;code&gt;$pending&lt;/code&gt; 속성에 추가됩니다 . 또한 모든 비동기 유효성 검사기는 모든 동기 유효성 검사기가 통과 한 후에 만 ​​실행됩니다.</target>
        </trans-unit>
        <trans-unit id="229fac7603e8188798542bcb67ff90d46994a3c3" translate="yes" xml:space="preserve">
          <source>A collection of validators that are applied whenever the model value changes. The key value within the object refers to the name of the validator while the function refers to the validation operation. The validation operation is provided with the model value as an argument and must return a true or false value depending on the response of that validation.</source>
          <target state="translated">모델 값이 변경 될 때마다 적용되는 유효성 검사기 모음입니다. 객체 내의 키 값은 유효성 검사기의 이름을 나타내며 함수는 유효성 검사 작업을 나타냅니다. 유효성 검사 작업에는 모델 값이 인수로 제공되며 해당 유효성 검사의 응답에 따라 true 또는 false 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="be0235f4b74d82983b712495add7b645995775dd" translate="yes" xml:space="preserve">
          <source>A compile function can have a return value which can be either a function or an object.</source>
          <target state="translated">컴파일 함수는 함수 또는 객체 일 수있는 반환 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e05e2a218277dd6b00da94dc6067e64b2045df3e" translate="yes" xml:space="preserve">
          <source>A complete client-side solution</source>
          <target state="translated">완벽한 클라이언트 측 솔루션</target>
        </trans-unit>
        <trans-unit id="e60157b6585baedc59c4d7575ad7dc9ea71f80e6" translate="yes" xml:space="preserve">
          <source>A constructor function that will be instantiated.</source>
          <target state="translated">인스턴스화 할 생성자 함수입니다.</target>
        </trans-unit>
        <trans-unit id="73f2b01348f1ce5048a10e6122982c908f8be945" translate="yes" xml:space="preserve">
          <source>A container for the options set by the &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">&lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; &lt;/a&gt; 지시문으로 설정 한 옵션의 컨테이너</target>
        </trans-unit>
        <trans-unit id="1704347efadba97c8861b4da7846bbc0b00699ef" translate="yes" xml:space="preserve">
          <source>A container for the options set by the &lt;a href=&quot;directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">&lt;a href=&quot;directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; &lt;/a&gt; 지시문으로 설정 한 옵션의 컨테이너</target>
        </trans-unit>
        <trans-unit id="39f7ee12cd4358531c59cddc0da19e827ffc1dee" translate="yes" xml:space="preserve">
          <source>A decorator for &lt;a href=&quot;../../ng/service/%24controller&quot;&gt;&lt;code&gt;$controller&lt;/code&gt;&lt;/a&gt; with additional &lt;code&gt;bindings&lt;/code&gt; parameter, useful when testing controllers of directives that use &lt;a href=&quot;../../ng/service/%24compile#-bindtocontroller-.html&quot;&gt;&lt;code&gt;bindToController&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24compile#-bindtocontroller-.html&quot;&gt; &lt;code&gt;bindToController&lt;/code&gt; &lt;/a&gt; 를 사용하는 지시문의 컨트롤러를 테스트 할 때 유용한 추가 &lt;code&gt;bindings&lt;/code&gt; 매개 변수가있는 &lt;a href=&quot;../../ng/service/%24controller&quot;&gt; &lt;code&gt;$controller&lt;/code&gt; &lt;/a&gt; 데코레이터 .</target>
        </trans-unit>
        <trans-unit id="4d65491f42f9e447fd2de27ab73792203123c4e5" translate="yes" xml:space="preserve">
          <source>A decorator for &lt;a href=&quot;../ng/service/%24controller&quot;&gt;&lt;code&gt;$controller&lt;/code&gt;&lt;/a&gt; with additional &lt;code&gt;bindings&lt;/code&gt; parameter, useful when testing controllers of directives that use &lt;a href=&quot;../ng/service/%24compile#-bindtocontroller-.html&quot;&gt;&lt;code&gt;bindToController&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../ng/service/%24compile#-bindtocontroller-.html&quot;&gt; &lt;code&gt;bindToController&lt;/code&gt; &lt;/a&gt; 를 사용하는 지시문의 컨트롤러를 테스트 할 때 유용한 추가 &lt;code&gt;bindings&lt;/code&gt; 매개 변수가있는 &lt;a href=&quot;../ng/service/%24controller&quot;&gt; &lt;code&gt;$controller&lt;/code&gt; &lt;/a&gt; 데코레이터 .</target>
        </trans-unit>
        <trans-unit id="a6ddae07840c68a872552d4cb70b579cf8c24aef" translate="yes" xml:space="preserve">
          <source>A decorator for &lt;a href=&quot;ng/service/%24controller&quot;&gt;&lt;code&gt;$controller&lt;/code&gt;&lt;/a&gt; with additional &lt;code&gt;bindings&lt;/code&gt; parameter, useful when testing controllers of directives that use &lt;a href=&quot;ng/service/%24compile#-bindtocontroller-.html&quot;&gt;&lt;code&gt;bindToController&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ng/service/%24compile#-bindtocontroller-.html&quot;&gt; &lt;code&gt;bindToController&lt;/code&gt; &lt;/a&gt; 를 사용하는 지시문의 컨트롤러를 테스트 할 때 유용한 추가 &lt;code&gt;bindings&lt;/code&gt; 매개 변수가있는 &lt;a href=&quot;ng/service/%24controller&quot;&gt; &lt;code&gt;$controller&lt;/code&gt; &lt;/a&gt; 데코레이터 .</target>
        </trans-unit>
        <trans-unit id="ce088c4e794e32fe14c0927041d2cdf88cfae0c8" translate="yes" xml:space="preserve">
          <source>A default message can also be displayed when no &lt;code&gt;ngMessage&lt;/code&gt; directive is inserted, using the &lt;a href=&quot;ngmessagedefault&quot;&gt;&lt;code&gt;ngMessageDefault&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;code&gt;ngMessage&lt;/code&gt; Default 지시문을 사용하여 &lt;a href=&quot;ngmessagedefault&quot;&gt; &lt;code&gt;ngMessageDefault&lt;/code&gt; &lt;/a&gt; 지시문을 삽입 하지 않으면 기본 메시지를 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36be02f1c6d94ec102591f40a3981d2fe909e18c" translate="yes" xml:space="preserve">
          <source>A different issue with objects or collections is that ngModel won't detect if an object property or a collection item changes. For that reason, &lt;code&gt;ngOptions&lt;/code&gt; additionally watches the model using &lt;code&gt;$watchCollection&lt;/code&gt;, when the expression contains a &lt;code&gt;track by&lt;/code&gt; clause or the the select has the &lt;code&gt;multiple&lt;/code&gt; attribute. This allows ngOptions to trigger a re-rendering of the options even if the actual object/collection has not changed identity, but only a property on the object or an item in the collection changes.</source>
          <target state="translated">객체 또는 컬렉션의 다른 문제는 ngModel이 객체 속성 또는 컬렉션 항목이 변경되는지 감지하지 못한다는 것입니다. 이러한 이유로, &lt;code&gt;ngOptions&lt;/code&gt; 은 추가로 사용하여 모델 시계 &lt;code&gt;$watchCollection&lt;/code&gt; 표현이 포함되어있는 경우, &lt;code&gt;track by&lt;/code&gt; 절 또는 선택이가 &lt;code&gt;multiple&lt;/code&gt; 속성을. 이를 통해 실제 객체 / 컬렉션이 ID를 변경하지 않았지만 객체의 속성 또는 컬렉션의 항목 만 변경 되더라도 ngOptions가 옵션을 다시 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3708b5167f652cc7a6cae8807f541525f153a1c0" translate="yes" xml:space="preserve">
          <source>A directive can specify which of the 4 matching types it supports in the &lt;a href=&quot;../api/ng/service/%24compile#-restrict-.html&quot;&gt;&lt;code&gt;restrict&lt;/code&gt;&lt;/a&gt; property of the directive definition object. The default is &lt;code&gt;EA&lt;/code&gt;.</source>
          <target state="translated">지시문은 지시문 정의 개체 의 &lt;a href=&quot;../api/ng/service/%24compile#-restrict-.html&quot;&gt; &lt;code&gt;restrict&lt;/code&gt; &lt;/a&gt; 속성 에서 지원하는 4 가지 일치 유형을 지정할 수 있습니다 . 기본값은 &lt;code&gt;EA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06d7072e7c82651d679b053abc62ab52bfe11d8d" translate="yes" xml:space="preserve">
          <source>A directive is a behavior which should be triggered when specific HTML constructs are encountered during the compilation process. The directives can be placed in element names, attributes, class names, as well as comments. Here are some equivalent examples of invoking the &lt;a href=&quot;../api/ng/directive/ngbind&quot;&gt;&lt;code&gt;ng-bind&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">지시문은 컴파일 프로세스 중에 특정 HTML 구문이 발견 될 때 트리거되어야하는 동작입니다. 지시문은 요소 이름, 속성, 클래스 이름 및 주석에 배치 할 수 있습니다. 다음은 &lt;a href=&quot;../api/ng/directive/ngbind&quot;&gt; &lt;code&gt;ng-bind&lt;/code&gt; &lt;/a&gt; 지시문 을 호출하는 것과 동등한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="327c78294c94992b0cd933d4b87c5e9699e89329" translate="yes" xml:space="preserve">
          <source>A directive is just a function which executes when the compiler encounters it in the DOM. See &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directive API&lt;/a&gt; for in-depth documentation on how to write directives.</source>
          <target state="translated">지시문은 컴파일러가 DOM에서 지시자를 만나면 실행되는 함수일뿐입니다. &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 작성 방법에 대한 자세한 문서는 지시문 API 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00783a21194e4ab3c93280470d34ea3574675381" translate="yes" xml:space="preserve">
          <source>A factory which creates a resource object that lets you interact with &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;RESTful&lt;/a&gt; server-side data sources.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;RESTful&lt;/a&gt; 서버 측 데이터 소스 와 상호 작용할 수있는 자원 오브젝트를 작성하는 팩토리입니다 .</target>
        </trans-unit>
        <trans-unit id="75674063b61a643301023ae7950ffed53283453a" translate="yes" xml:space="preserve">
          <source>A first example: Data binding</source>
          <target state="translated">첫 번째 예 : 데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="e0ea85d6b6af2158aa8c6e9605380b608e4a22b9" translate="yes" xml:space="preserve">
          <source>A form is an instance of &lt;a href=&quot;../api/ng/type/form.formcontroller&quot;&gt;FormController&lt;/a&gt;. The form instance can optionally be published into the scope using the &lt;code&gt;name&lt;/code&gt; attribute.</source>
          <target state="translated">폼은 &lt;a href=&quot;../api/ng/type/form.formcontroller&quot;&gt;FormController&lt;/a&gt; 의 인스턴스입니다 . &lt;code&gt;name&lt;/code&gt; 인스턴스를 사용하여 양식 인스턴스를 선택적으로 범위에 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09b0457141fd71126f4f5b1856e175c7bdc679f5" translate="yes" xml:space="preserve">
          <source>A function that performs no operations. This function can be useful when writing code in the functional style.</source>
          <target state="translated">작업을 수행하지 않는 기능입니다. 이 기능은 기능적 스타일로 코드를 작성할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="927c2853c79260f99382637d60b1f31d09e600d8" translate="yes" xml:space="preserve">
          <source>A function that returns its first argument. This function is useful when writing code in the functional style.</source>
          <target state="translated">첫 번째 인수를 반환하는 함수입니다. 이 기능은 기능적 스타일로 코드를 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3bf96ebee31efd450a90bce44c461047308f3f00" translate="yes" xml:space="preserve">
          <source>A function that should be called repeatedly.</source>
          <target state="translated">반복적으로 호출해야하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d5fe795730c98a599df718415511d721ffaffbbc" translate="yes" xml:space="preserve">
          <source>A function that should be called repeatedly. If no additional arguments are passed (see below), the function is called with the current iteration count.</source>
          <target state="translated">반복적으로 호출해야하는 함수입니다. 추가 인수가 전달되지 않으면 (아래 참조) 함수는 현재 반복 횟수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f48966c4d92539555740018c51cafcd2b987c9f4" translate="yes" xml:space="preserve">
          <source>A function which represents the compiled expression:</source>
          <target state="translated">컴파일 된 표현식을 나타내는 함수 :</target>
        </trans-unit>
        <trans-unit id="03e8ddc04c009e88be1986ce9071a6ff42d38f7e" translate="yes" xml:space="preserve">
          <source>A function which takes two arguments &lt;code&gt;tElement&lt;/code&gt; and &lt;code&gt;tAttrs&lt;/code&gt; (described in the &lt;code&gt;compile&lt;/code&gt; function api below) and returns a string value.</source>
          <target state="translated">&lt;code&gt;tElement&lt;/code&gt; 및 &lt;code&gt;tAttrs&lt;/code&gt; 인수 ( 아래 &lt;code&gt;compile&lt;/code&gt; 함수 api에 설명 됨)를 사용하여 문자열 값을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="02dbdfe8aec371363fd2d4f9088e6efc174fd5a2" translate="yes" xml:space="preserve">
          <source>A function, whose execution should be delayed.</source>
          <target state="translated">실행이 지연되어야하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="56056728c573b2a14e4a6b4609fd75c358098fed" translate="yes" xml:space="preserve">
          <source>A handful of common AngularJS directives support and trigger animation hooks whenever any major event occurs during their life cycle. The table below explains in detail which animation events are triggered:</source>
          <target state="translated">일반적인 AngularJS 지시문 중 소수는 수명주기 동안 주요 이벤트가 발생할 때마다 애니메이션 후크를 지원하고 트리거합니다. 아래 표는 어떤 애니메이션 이벤트가 트리거되는지 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e4ed6112409252387811e119060f0e3fb404c17f" translate="yes" xml:space="preserve">
          <source>A hash containing all the modules that have been loaded into the $injector.</source>
          <target state="translated">$ injector에로드 된 모든 모듈을 포함하는 해시.</target>
        </trans-unit>
        <trans-unit id="6280bbd23fbf02ccab69cad3ae2df8798d0ede5f" translate="yes" xml:space="preserve">
          <source>A list of module functions or their aliases. See &lt;a href=&quot;angular.module&quot;&gt;&lt;code&gt;angular.module&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;ng&lt;/code&gt; module must be explicitly added.</source>
          <target state="translated">모듈 기능 또는 별명 목록. &lt;a href=&quot;angular.module&quot;&gt; &lt;code&gt;angular.module&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . &lt;code&gt;ng&lt;/code&gt; 모듈은 명시 적으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="94127fa72f5be9627d12463f3a9a89dc6e85f8d2" translate="yes" xml:space="preserve">
          <source>A list of valid HTML elements or an object with one or more of the following properties:</source>
          <target state="translated">유효한 HTML 요소 또는 다음 속성 중 하나 이상을 가진 개체의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="05e8a415e27bf82becfd6d37ac93442a77ca6c5f" translate="yes" xml:space="preserve">
          <source>A list of valid attributes.</source>
          <target state="translated">유효한 속성 목록</target>
        </trans-unit>
        <trans-unit id="a2cff4a5b3056231e50fc5df06de40e59768b479" translate="yes" xml:space="preserve">
          <source>A locale is a specific geographical, political, or cultural region. The most commonly used locale ID consists of two parts: language code and country code. For example, &lt;code&gt;en-US&lt;/code&gt;, &lt;code&gt;en-AU&lt;/code&gt;, and &lt;code&gt;zh-CN&lt;/code&gt; are all valid locale IDs that have both language codes and country codes. Because specifying a country code in locale ID is optional, locale IDs such as &lt;code&gt;en&lt;/code&gt;, &lt;code&gt;zh&lt;/code&gt;, and &lt;code&gt;sk&lt;/code&gt; are also valid. See the &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;ICU&lt;/a&gt; website for more information about using locale IDs.</source>
          <target state="translated">로캘은 특정 지리적, 정치적 또는 문화적 지역입니다. 가장 일반적으로 사용되는 로캘 ID는 언어 코드와 국가 코드의 두 부분으로 구성됩니다. 예를 들어 &lt;code&gt;en-US&lt;/code&gt; , &lt;code&gt;en-AU&lt;/code&gt; 및 &lt;code&gt;zh-CN&lt;/code&gt; 은 모두 언어 코드와 국가 코드가 모두있는 유효한 로캘 ID입니다. 로캘 ID에 국가 코드를 지정하는 것은 선택 사항이므로 &lt;code&gt;en&lt;/code&gt; , &lt;code&gt;zh&lt;/code&gt; 및 &lt;code&gt;sk&lt;/code&gt; 와 같은 로캘 ID 도 유효합니다. 참고 항목 &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;ICU의&lt;/a&gt; 로케일 ID를 사용하는 방법에 대한 자세한 내용은 웹 사이트를.</target>
        </trans-unit>
        <trans-unit id="1ffed9d0df0955721113607f963949822e354ee2" translate="yes" xml:space="preserve">
          <source>A map of DOM element attribute names to the normalized name. This is needed to do reverse lookup from normalized name back to actual name.</source>
          <target state="translated">DOM 요소 속성 이름을 정규화 된 이름으로 매핑합니다. 정규화 된 이름에서 실제 이름으로 역 조회하려면이 작업이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac050f8b13fbbe0e23861b0e31a09920964b0407" translate="yes" xml:space="preserve">
          <source>A map of parameters for a given route, passed as part of the &lt;a href=&quot;componentinstruction&quot;&gt;&lt;code&gt;ComponentInstruction&lt;/code&gt;&lt;/a&gt; to the Lifecycle Hooks, such as &lt;code&gt;$routerOnActivate&lt;/code&gt; and &lt;code&gt;$routerOnDeactivate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$routerOnActivate&lt;/code&gt; 및 &lt;code&gt;$routerOnDeactivate&lt;/code&gt; 와 같이 &lt;a href=&quot;componentinstruction&quot;&gt; &lt;code&gt;ComponentInstruction&lt;/code&gt; 의&lt;/a&gt; 일부로 Lifecycle Hooks에 전달 된 지정된 경로에 대한 매개 변수 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="09b167f576d80fcd815b55aefdf9875dc0673668" translate="yes" xml:space="preserve">
          <source>A map of parameters for a given route, passed as part of the &lt;a href=&quot;ngcomponentrouter/type/componentinstruction&quot;&gt;&lt;code&gt;ComponentInstruction&lt;/code&gt;&lt;/a&gt; to the Lifecycle Hooks, such as &lt;code&gt;$routerOnActivate&lt;/code&gt; and &lt;code&gt;$routerOnDeactivate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$routerOnActivate&lt;/code&gt; 및 &lt;code&gt;$routerOnDeactivate&lt;/code&gt; 와 같이 &lt;a href=&quot;ngcomponentrouter/type/componentinstruction&quot;&gt; &lt;code&gt;ComponentInstruction&lt;/code&gt; 의&lt;/a&gt; 일부로 Lifecycle Hooks에 전달 된 지정된 경로에 대한 매개 변수 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="9324f5aeabd030e8b469f119f264258ae0a72395" translate="yes" xml:space="preserve">
          <source>A map of parameters for a given route, passed as part of the &lt;a href=&quot;type/componentinstruction&quot;&gt;&lt;code&gt;ComponentInstruction&lt;/code&gt;&lt;/a&gt; to the Lifecycle Hooks, such as &lt;code&gt;$routerOnActivate&lt;/code&gt; and &lt;code&gt;$routerOnDeactivate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$routerOnActivate&lt;/code&gt; 및 &lt;code&gt;$routerOnDeactivate&lt;/code&gt; 와 같이 &lt;a href=&quot;type/componentinstruction&quot;&gt; &lt;code&gt;ComponentInstruction&lt;/code&gt; 의&lt;/a&gt; 일부로 Lifecycle Hooks에 전달 된 지정된 경로에 대한 매개 변수 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="3aca56da114e66b6c7c9831f0302af945e2b9423" translate="yes" xml:space="preserve">
          <source>A model consisting of a string named &lt;code&gt;spice&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spice&lt;/code&gt; 라는 문자열로 구성된 모델</target>
        </trans-unit>
        <trans-unit id="ac776570f178191e1b9faf4c959abe7440ff6155" translate="yes" xml:space="preserve">
          <source>A module for each feature</source>
          <target state="translated">각 기능에 대한 모듈</target>
        </trans-unit>
        <trans-unit id="263fee6d5c3ddbbb6ce730daf5dc87f3fdbb2fed" translate="yes" xml:space="preserve">
          <source>A module for each reusable component (especially directives and filters)</source>
          <target state="translated">재사용 가능한 각 구성 요소에 대한 모듈 (특히 지시문 및 필터)</target>
        </trans-unit>
        <trans-unit id="225d25f6753d494a37f0848446bbaa811f297e5e" translate="yes" xml:space="preserve">
          <source>A module is a collection of services, directives, controllers, filters, and configuration information. &lt;code&gt;angular.module&lt;/code&gt; is used to configure the &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;.</source>
          <target state="translated">모듈은 서비스, 지시문, 컨트롤러, 필터 및 구성 정보의 모음입니다. &lt;code&gt;angular.module&lt;/code&gt; 은 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b9810a38acec3b0112fef4ba925967a0ec7560a" translate="yes" xml:space="preserve">
          <source>A more complex example, featuring different show/hide animations:</source>
          <target state="translated">다른 표시 / 숨기기 애니메이션을 특징으로하는보다 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="9802b05fcc81cdbc44d9f5ea5e204cb68b0b7cc8" translate="yes" xml:space="preserve">
          <source>A naive approach to solving this problem would be to simply insert a copy of the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element and then compile it. The problem with this approach is that compiling on every &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element that we clone would duplicate a lot of the work. Specifically, we'd be traversing &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; each time before cloning it to find the directives. This would cause the compilation process to be slower, in turn making applications less responsive when inserting new nodes.</source>
          <target state="translated">이 문제를 해결하는 순진한 접근 방법은 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 의 복사본을 삽입 한 다음 컴파일하는 것입니다. 이 접근법의 문제점 은 복제하는 모든 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 컴파일 하면 많은 작업이 복제된다는 것입니다. 특히, 우리 는 지시문을 찾기 위해 복제하기 전에 매번 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 를 순회 합니다. 이로 인해 컴파일 프로세스가 느려져 새 노드를 삽입 할 때 응용 프로그램의 응답 성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="a3f1861ea558e04a53d812f2833cbf6d5066b137" translate="yes" xml:space="preserve">
          <source>A new instance of deferred is constructed by calling &lt;code&gt;$q.defer()&lt;/code&gt;.</source>
          <target state="translated">지연된 새 인스턴스는 &lt;code&gt;$q.defer()&lt;/code&gt; 호출하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb83fe916c440c15ab744b5d59e5a6ebfa47364e" translate="yes" xml:space="preserve">
          <source>A new promise instance is created when a deferred instance is created and can be retrieved by calling &lt;code&gt;deferred.promise&lt;/code&gt;.</source>
          <target state="translated">지연된 인스턴스가 생성되고 호출하여 검색 할 수 있습니다 때 새로운 약속의 인스턴스가 만들어집니다 &lt;code&gt;deferred.promise&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="713a88d680af18fb58af607a73c855c9cc2e0e1b" translate="yes" xml:space="preserve">
          <source>A new sub-array or substring of length &lt;code&gt;limit&lt;/code&gt; or less if the input had less than &lt;code&gt;limit&lt;/code&gt; elements.</source>
          <target state="translated">입력에 &lt;code&gt;limit&lt;/code&gt; 요소 보다 작은 경우 길이 &lt;code&gt;limit&lt;/code&gt; 이하 의 새로운 하위 배열 또는 하위 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="2b7a002c87fcd8660e3544e9875caa6df20fec19" translate="yes" xml:space="preserve">
          <source>A note about browser compatibility</source>
          <target state="translated">브라우저 호환성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="29ae56a350199f61ba8d6960a863d68ba1e1280c" translate="yes" xml:space="preserve">
          <source>A numerical timeout or a promise returned from &lt;a href=&quot;%24timeout&quot;&gt;$timeout&lt;/a&gt;, will set the &lt;code&gt;xhrStatus&lt;/code&gt; in the &lt;a href=&quot;%24http#%24http-returns.html&quot;&gt;response&lt;/a&gt; to &quot;timeout&quot;, and any other resolved promise will set it to &quot;abort&quot;, following standard XMLHttpRequest behavior.</source>
          <target state="translated">숫자 시간 초과 또는 &lt;a href=&quot;%24timeout&quot;&gt;$ timeout&lt;/a&gt; 에서 리턴 된 약속 은 &lt;a href=&quot;%24http#%24http-returns.html&quot;&gt;응답&lt;/a&gt; 의 &lt;code&gt;xhrStatus&lt;/code&gt; 를 &quot;timeout&quot;으로 설정하고, 해결 된 다른 약속은 표준 XMLHttpRequest 동작에 따라 &quot;abort&quot;로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1116347f621c5180dfe109771a3b63007d50e2f3" translate="yes" xml:space="preserve">
          <source>A parameterized URL template with parameters prefixed by &lt;code&gt;:&lt;/code&gt; as in &lt;code&gt;/user/:username&lt;/code&gt;. If you are using a URL with a port number (e.g. &lt;code&gt;http://example.com:8080/api&lt;/code&gt;), it will be respected.</source>
          <target state="translated">접두사 매개 변수를 매개 변수화 된 URL 템플릿 &lt;code&gt;:&lt;/code&gt; 같이 &lt;code&gt;/user/:username&lt;/code&gt; . 포트 번호가있는 URL을 사용하는 경우 (예 : &lt;code&gt;http://example.com:8080/api&lt;/code&gt; ) 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="452392dbf344d122f7b332400f90489eab5c05a3" translate="yes" xml:space="preserve">
          <source>A path should always begin with forward slash (&lt;code&gt;/&lt;/code&gt;); the &lt;code&gt;$location.path()&lt;/code&gt; setter will add the forward slash if it is missing.</source>
          <target state="translated">경로는 항상 슬래시 ( &lt;code&gt;/&lt;/code&gt; )로 시작해야합니다 . &lt;code&gt;$location.path()&lt;/code&gt; 가 누락 된 경우 세터 슬래시를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6a8dda83e3a1b0ef1feb44da945442f04db8d3e9" translate="yes" xml:space="preserve">
          <source>A predicate (or list of predicates) to be used by the comparator to determine the order of elements.</source>
          <target state="translated">요소의 순서를 결정하기 위해 비교자가 사용하는 술어 (또는 술어 목록).</target>
        </trans-unit>
        <trans-unit id="5e0995f849e5cdc1b945ea8fbb9875c89ea13cf7" translate="yes" xml:space="preserve">
          <source>A promise from calling the &lt;code&gt;$interval&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;$interval&lt;/code&gt; 함수 호출의 약속 .</target>
        </trans-unit>
        <trans-unit id="4e7cf7245f1fe3b7e365471f31c20059d76f5920" translate="yes" xml:space="preserve">
          <source>A promise which will be notified on each iteration.</source>
          <target state="translated">각 반복에 대해 통지 할 약속.</target>
        </trans-unit>
        <trans-unit id="5212905179099b47b09b21e5997cb8a49f0a5971" translate="yes" xml:space="preserve">
          <source>A promise which will be notified on each iteration. It will resolve once all iterations of the interval complete.</source>
          <target state="translated">각 반복에 대해 통지 할 약속. 간격의 모든 반복이 완료되면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="040660a941ed0ab75c40a02ea66cad58886ab53e" translate="yes" xml:space="preserve">
          <source>A reference to the browser's &lt;code&gt;window&lt;/code&gt; object. While &lt;code&gt;window&lt;/code&gt; is globally available in JavaScript, it causes testability problems, because it is a global variable. In AngularJS we always refer to it through the &lt;code&gt;$window&lt;/code&gt; service, so it may be overridden, removed or mocked for testing.</source>
          <target state="translated">브라우저의 &lt;code&gt;window&lt;/code&gt; 객체에 대한 참조 입니다. &lt;code&gt;window&lt;/code&gt; 는 JavaScript에서 전역 적으로 사용할 수 있지만 전역 변수이므로 테스트 가능성 문제가 발생합니다. AngularJS에서는 항상 &lt;code&gt;$window&lt;/code&gt; 서비스를 통해 참조 하므로 테스트를 위해 재정의, 제거 또는 조롱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de848095c9da48c3f2897c90875017cd0e56d38e" translate="yes" xml:space="preserve">
          <source>A remote template can also be used (With &lt;a href=&quot;ngmessagesinclude&quot;&gt;&lt;code&gt;ngMessagesInclude&lt;/code&gt;&lt;/a&gt;) to promote message reusability and messages can also be overridden.</source>
          <target state="translated">원격 템플릿을 사용하여 ( &lt;a href=&quot;ngmessagesinclude&quot;&gt; &lt;code&gt;ngMessagesInclude&lt;/code&gt; 사용&lt;/a&gt; ) 메시지 재사용 성을 높이고 메시지를 재정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b9cbb30f599a8403b248268c58e667bbc74bf9" translate="yes" xml:space="preserve">
          <source>A resource &quot;class&quot; object with methods for the default set of resource actions optionally extended with custom &lt;code&gt;actions&lt;/code&gt;. The default set contains these actions:</source>
          <target state="translated">선택적으로 사용자 정의 &lt;code&gt;actions&lt;/code&gt; 확장 된 기본 자원 조치 세트에 대한 메소드가있는 자원 &quot;클래스&quot;오브젝트 . 기본 설정에는 다음 작업이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8a72795321ece67e315ace2352d61342be26d7a9" translate="yes" xml:space="preserve">
          <source>A response status code between 200 and 299 is considered a success status and will result in the success callback being called. Any response status code outside of that range is considered an error status and will result in the error callback being called. Also, status codes less than -1 are normalized to zero. -1 usually means the request was aborted, e.g. using a &lt;code&gt;config.timeout&lt;/code&gt;. More information about the status might be available in the &lt;code&gt;xhrStatus&lt;/code&gt; property.</source>
          <target state="translated">200에서 299 사이의 응답 상태 코드는 성공 상태로 간주되며 성공 콜백이 호출됩니다. 해당 범위를 벗어난 응답 상태 코드는 오류 상태로 간주되며 오류 콜백이 호출됩니다. 또한 -1보다 작은 상태 코드는 0으로 정규화됩니다. -1은 일반적으로 요청이 중단되었음을 의미합니다 (예 : &lt;code&gt;config.timeout&lt;/code&gt; 사용) . 상태에 대한 자세한 내용은 &lt;code&gt;xhrStatus&lt;/code&gt; 속성 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d78c5ef35ba9a3a351b9b8b8ececf7e7781e688" translate="yes" xml:space="preserve">
          <source>A root scope can be retrieved using the &lt;a href=&quot;../service/%24rootscope&quot;&gt;$rootScope&lt;/a&gt; key from the &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;. Child scopes are created using the &lt;a href=&quot;%24rootscope.scope#%24new.html&quot;&gt;$new()&lt;/a&gt; method. (Most scopes are created automatically when compiled HTML template is executed.) See also the &lt;a href=&quot;../../../guide/scope&quot;&gt;Scopes guide&lt;/a&gt; for an in-depth introduction and usage examples.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 에서 &lt;a href=&quot;../service/%24rootscope&quot;&gt;$ rootScope&lt;/a&gt; 키를 사용하여 루트 범위를 검색 할 수 있습니다 . 자식 범위는 &lt;a href=&quot;%24rootscope.scope#%24new.html&quot;&gt;$ new ()&lt;/a&gt; 메서드를 사용하여 만들어 집니다. (컴파일 된 HTML 템플리트가 실행될 때 대부분의 범위가 자동으로 작성됩니다.) 자세한 소개 및 사용법 예제 는 &lt;a href=&quot;../../../guide/scope&quot;&gt;범위 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="004008a8c97d3672714468bc8cfe76b2c7cab307" translate="yes" xml:space="preserve">
          <source>A root scope can be retrieved using the &lt;a href=&quot;service/%24rootscope&quot;&gt;$rootScope&lt;/a&gt; key from the &lt;a href=&quot;../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;. Child scopes are created using the &lt;a href=&quot;type/%24rootscope.scope#%24new.html&quot;&gt;$new()&lt;/a&gt; method. (Most scopes are created automatically when compiled HTML template is executed.) See also the &lt;a href=&quot;../../guide/scope&quot;&gt;Scopes guide&lt;/a&gt; for an in-depth introduction and usage examples.</source>
          <target state="translated">&lt;a href=&quot;../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 에서 &lt;a href=&quot;service/%24rootscope&quot;&gt;$ rootScope&lt;/a&gt; 키를 사용하여 루트 범위를 검색 할 수 있습니다 . 자식 범위는 &lt;a href=&quot;type/%24rootscope.scope#%24new.html&quot;&gt;$ new ()&lt;/a&gt; 메서드를 사용하여 만들어 집니다. (컴파일 된 HTML 템플리트가 실행될 때 대부분의 범위가 자동으로 작성됩니다.) 자세한 소개 및 사용법 예제 는 &lt;a href=&quot;../../guide/scope&quot;&gt;범위 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9472f1a4df3f71716a86325e4dcd0e27c0314c58" translate="yes" xml:space="preserve">
          <source>A scope can inherit from a parent scope, as in this example:</source>
          <target state="translated">이 예에서와 같이 범위는 상위 범위에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3e8603742beaaec4dd1f083ac44804290ac748" translate="yes" xml:space="preserve">
          <source>A service that can be used to create instances of component controllers. Useful for unit-testing.</source>
          <target state="translated">컴포넌트 컨트롤러 인스턴스를 작성하는 데 사용할 수있는 서비스입니다. 단위 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9909d73dae5dc48bf7bd8f099425c18f2ccd1383" translate="yes" xml:space="preserve">
          <source>A service that helps you run functions asynchronously, and use their return values (or exceptions) when they are done processing.</source>
          <target state="translated">함수를 비동기식으로 실행하고 처리가 완료되면 반환 값 (또는 예외)을 사용하도록 도와주는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="7fa98307bb925b7e78fec6db866350c8f5850d65" translate="yes" xml:space="preserve">
          <source>A shared object between directive compile / linking functions which contains normalized DOM element attributes. The values reflect current binding state &lt;code&gt;{{ }}&lt;/code&gt;. The normalization is needed since all of these are treated as equivalent in AngularJS:</source>
          <target state="translated">정규화 된 DOM 요소 속성을 포함하는 지시문 컴파일 / 링크 함수 간의 공유 객체입니다. 값은 현재 바인딩 상태 &lt;code&gt;{{ }}&lt;/code&gt; 반영합니다 . 이 모든 것이 AngularJS에서 동등한 것으로 취급되므로 정규화가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="578c6a6777e13169afd3ec0627d9cbccce541d6b" translate="yes" xml:space="preserve">
          <source>A simple &lt;code&gt;ng-csp&lt;/code&gt; (or &lt;code&gt;data-ng-csp&lt;/code&gt;) attribute will tell AngularJS to deactivate both inline styles and unsafe eval. E.g. &lt;code&gt;&amp;lt;body ng-csp&amp;gt;&lt;/code&gt;. This is backwardly compatible with previous versions of AngularJS.</source>
          <target state="translated">간단한 &lt;code&gt;ng-csp&lt;/code&gt; (또는 &lt;code&gt;data-ng-csp&lt;/code&gt; ) 속성은 AngularJS에 인라인 스타일과 안전하지 않은 eval을 모두 비활성화하도록 지시합니다. 예 &lt;code&gt;&amp;lt;body ng-csp&amp;gt;&lt;/code&gt; . 이전 버전의 AngularJS와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="8eab9356a6cee0bd4192aaa4fe8dc2252df33c89" translate="yes" xml:space="preserve">
          <source>A simple example, animating the element's opacity:</source>
          <target state="translated">요소의 불투명도에 애니메이션을 적용하는 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="13ca11ee80a7423b520a8cbb9b876c83a8413e4b" translate="yes" xml:space="preserve">
          <source>A special directive is necessary because we cannot use interpolation inside the &lt;code&gt;checked&lt;/code&gt; attribute. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;checked&lt;/code&gt; 속성 내에서 보간을 사용할 수 없으므로 특별한 지시문이 필요 합니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96ec97c9bf5c06b46afd2259dcdc487df739471f" translate="yes" xml:space="preserve">
          <source>A special directive is necessary because we cannot use interpolation inside the &lt;code&gt;disabled&lt;/code&gt; attribute. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; 속성 내에서 보간을 사용할 수 없으므로 특수 지시문이 필요 합니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e86a8cbd4ddf2dfcb7e716138595387a4e5a85fe" translate="yes" xml:space="preserve">
          <source>A special directive is necessary because we cannot use interpolation inside the &lt;code&gt;open&lt;/code&gt; attribute. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 속성 내에서 보간을 사용할 수 없으므로 특수 지시문이 필요 합니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b91103bfde51390004606921a7b8fb1ff063be2b" translate="yes" xml:space="preserve">
          <source>A special directive is necessary because we cannot use interpolation inside the &lt;code&gt;readonly&lt;/code&gt; attribute. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 속성 내에서 보간을 사용할 수 없으므로 특수 지시문이 필요 합니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6493fd9ee730755cb99067d28aafe6366edf30cf" translate="yes" xml:space="preserve">
          <source>A special directive is necessary because we cannot use interpolation inside the &lt;code&gt;selected&lt;/code&gt; attribute. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 속성 내에서 보간을 사용할 수 없으므로 특수 지시문이 필요 합니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d5e64837c87ce8f3783157fa15fe926b963dac1" translate="yes" xml:space="preserve">
          <source>A special type of scope is the &lt;code&gt;isolate&lt;/code&gt; scope, which does not inherit prototypically from the parent scope. This type of scope is useful for component directives that should be isolated from their parent scope. See the &lt;a href=&quot;directive#isolating-the-scope-of-a-directive.html&quot;&gt;directives guide&lt;/a&gt; for more information about isolate scopes in custom directives.</source>
          <target state="translated">특수한 범위 유형은 &lt;code&gt;isolate&lt;/code&gt; 범위이며 부모 범위에서 프로토 타입으로 상속되지 않습니다. 이 유형의 범위는 상위 범위에서 분리해야하는 구성 요소 지시문에 유용합니다. 참고 항목 &lt;a href=&quot;directive#isolating-the-scope-of-a-directive.html&quot;&gt;지침 가이드를&lt;/a&gt; 사용자 정의 지침에서 분리 범위에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="59ad40cb735425875e2d4a8ab8e7371e40ff26f7" translate="yes" xml:space="preserve">
          <source>A string. For example &lt;code&gt;&amp;lt;div red-on-hover&amp;gt;{{delete_str}}&amp;lt;/div&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 예를 들어 &lt;code&gt;&amp;lt;div red-on-hover&amp;gt;{{delete_str}}&amp;lt;/div&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b0ca9801d5fb35012af168b081343748fd65273" translate="yes" xml:space="preserve">
          <source>A trusted representation of value, that can be used in the given context.</source>
          <target state="translated">주어진 맥락에서 사용될 수있는 신뢰할 수있는 가치 표현.</target>
        </trans-unit>
        <trans-unit id="5b850d32e9f4e83610766a68bff4d1eb00b0f5a4" translate="yes" xml:space="preserve">
          <source>A unit test is a way of instantiating a subset of an application to apply stimulus to it. Small, structured modules help keep unit tests concise and focused.</source>
          <target state="translated">단위 테스트는 응용 프로그램의 하위 집합을 인스턴스화하여 자극을 적용하는 방법입니다. 작고 구조화 된 모듈은 단위 테스트를 간결하고 집중적으로 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cd209eeff32e50f79f69edda44a79e2b6ab0898e" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$watch()&lt;/a&gt; where it watches an array of &lt;code&gt;watchExpressions&lt;/code&gt;. If any one expression in the collection changes the &lt;code&gt;listener&lt;/code&gt; is executed.</source>
          <target state="translated">&lt;code&gt;watchExpressions&lt;/code&gt; 배열을 감시하는 &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$ watch ()&lt;/a&gt; 변형 . 컬렉션에서 하나의 표현식이 변경되면 &lt;code&gt;listener&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1b45ac319be996d2d941a9d9450c2984ad5ce01e" translate="yes" xml:space="preserve">
          <source>A version of the value that's safe to use in the given context, or throws an exception if this is impossible.</source>
          <target state="translated">주어진 맥락에서 사용하기에 안전한 값의 버전. 불가능한 경우 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="2114b9cf09c04eaad419c5fd2210545525228750" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;$sce.CSS&lt;/code&gt; context. This context is currently unused, so there are almost no reasons to use this function so far.</source>
          <target state="translated">&lt;code&gt;$sce.CSS&lt;/code&gt; 컨텍스트 에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 값 버전입니다 . 이 컨텍스트는 현재 사용되지 않으므로 지금까지이 기능을 사용할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6aac2364c23b77028d5fac2c7100d9e6ad6e89db" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;$sce.HTML&lt;/code&gt; context (like &lt;code&gt;ng-bind-html&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$sce.HTML&lt;/code&gt; 컨텍스트 ( &lt;code&gt;ng-bind-html&lt;/code&gt; 등 ) 에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 값 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="943e357106396a3e0df4457b98387b3baac1cd3d" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;$sce.JS&lt;/code&gt; context. That context is currently unused, so there are almost no reasons to use this function so far.</source>
          <target state="translated">&lt;code&gt;$sce.JS&lt;/code&gt; 컨텍스트 에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 값 버전입니다 . 해당 컨텍스트는 현재 사용되지 않으므로 지금까지이 기능을 사용할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="aee72dee5c81b8892475ad7e50e66f541550e109" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; context (template URLs in &lt;code&gt;ng-include&lt;/code&gt;, most &lt;code&gt;src&lt;/code&gt; attribute bindings, ...)</source>
          <target state="translated">&lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; 컨텍스트 에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 버전의 값 ( &lt;code&gt;ng-include&lt;/code&gt; , 대부분의 &lt;code&gt;src&lt;/code&gt; 속성 바인딩의 템플릿 URL ...)</target>
        </trans-unit>
        <trans-unit id="e93e7d74205a414b8e296caec821b600388e6ede" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;$sce.URL&lt;/code&gt; context. That context is currently unused, so there are almost no reasons to use this function so far.</source>
          <target state="translated">&lt;code&gt;$sce.URL&lt;/code&gt; 컨텍스트 에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 값 버전입니다 . 해당 컨텍스트는 현재 사용되지 않으므로 지금까지이 기능을 사용할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="94634151636234123b70b002561d0dc752c67a9e" translate="yes" xml:space="preserve">
          <source>A wrapped version of value that can be used as a trusted variant of your &lt;code&gt;value&lt;/code&gt; in the context you specified.</source>
          <target state="translated">지정한 컨텍스트에서 신뢰할 수있는 &lt;code&gt;value&lt;/code&gt; 변형으로 사용할 수있는 래핑 된 버전의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e5742b7d392c9ff17c292adaab06bd43e7effa1d" translate="yes" xml:space="preserve">
          <source>A11y Project</source>
          <target state="translated">A11y 프로젝트</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="771b5051428b8e31be4c1e9b28544157fe69eb11" translate="yes" xml:space="preserve">
          <source>Absolute links that go to a different domain</source>
          <target state="translated">다른 도메인으로 이동하는 절대 링크</target>
        </trans-unit>
        <trans-unit id="abb8862cb5fd053f1431200782dd6b2385ba3889" translate="yes" xml:space="preserve">
          <source>Absolute or relative URL of the resource that is being requested; or an object created by a call to &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt;.</source>
          <target state="translated">요청중인 자원의 절대 또는 상대 URL. 또는 &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt; 호출로 생성 된 객체 .</target>
        </trans-unit>
        <trans-unit id="d660049bc1f2f54fc0e3f4ace6fa5eb205f2f1e0" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibility</target>
        </trans-unit>
        <trans-unit id="932d041badc29d5b5f5f02116595faeaf3e79a51" translate="yes" xml:space="preserve">
          <source>Accessibility best practices that apply to web apps in general also apply to AngularJS.</source>
          <target state="translated">웹 앱에 일반적으로 적용되는 접근성 모범 사례는 AngularJS에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a368acd524486ce1ec9e162bc6921361dffc280e" translate="yes" xml:space="preserve">
          <source>Accessing the backend</source>
          <target state="translated">백엔드에 액세스</target>
        </trans-unit>
        <trans-unit id="73f18c14545e6b8de39ba7a2b2dae679a17ad3cd" translate="yes" xml:space="preserve">
          <source>Accessing the response</source>
          <target state="translated">응답에 액세스</target>
        </trans-unit>
        <trans-unit id="53dfdad6a297f31a276521fd544f3049a48d0385" translate="yes" xml:space="preserve">
          <source>Add behavior to the &lt;code&gt;$scope&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;$scope&lt;/code&gt; 객체에 동작을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="354177651f5bd3ccb60bca3a000a1293dfe5c051" translate="yes" xml:space="preserve">
          <source>Add custom attributes to the link element.</source>
          <target state="translated">링크 요소에 사용자 정의 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="aa635fd7300af5b89def28983561aaf159169195" translate="yes" xml:space="preserve">
          <source>Add the specified modules to the current injector.</source>
          <target state="translated">지정된 모듈을 현재 인젝터에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8cf8d577c9d621dfe11c43d243bcf5df4901001a" translate="yes" xml:space="preserve">
          <source>Adding Behavior to a Scope Object</source>
          <target state="translated">범위 객체에 동작 추가</target>
        </trans-unit>
        <trans-unit id="0dd3cd9ca66b96853fa6aa63eec6ed109ced7c1d" translate="yes" xml:space="preserve">
          <source>Adding UI logic: Controllers</source>
          <target state="translated">UI 로직 추가 : 컨트롤러</target>
        </trans-unit>
        <trans-unit id="16fadc2c4c92cb401aef05833ef060e854d83464" translate="yes" xml:space="preserve">
          <source>Adding via the &lt;code&gt;$templateCache&lt;/code&gt; service:</source>
          <target state="translated">&lt;code&gt;$templateCache&lt;/code&gt; 서비스 를 통해 추가 :</target>
        </trans-unit>
        <trans-unit id="92ae3f2635c80ce7fb8d316d1172975f449ef38b" translate="yes" xml:space="preserve">
          <source>Adding via the &lt;code&gt;script&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;script&lt;/code&gt; 태그 를 통해 추가 :</target>
        </trans-unit>
        <trans-unit id="d8b82f8ac1fd93a8c5863d25cc6558cb656b7f40" translate="yes" xml:space="preserve">
          <source>Additional Resources</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="8c2ac4451a90f41ac885a24324949060081e16e9" translate="yes" xml:space="preserve">
          <source>Additional tools for testing AngularJS applications</source>
          <target state="translated">AngularJS 애플리케이션 테스트를위한 추가 도구</target>
        </trans-unit>
        <trans-unit id="28b5580670d0ebc7e0ca1d7a532bdf62dab04cfd" translate="yes" xml:space="preserve">
          <source>Additionally it prevents the default action (which for form means sending the request to the server and reloading the current page), but only if the form does not contain &lt;code&gt;action&lt;/code&gt;, &lt;code&gt;data-action&lt;/code&gt;, or &lt;code&gt;x-action&lt;/code&gt; attributes.</source>
          <target state="translated">또한 양식에 &lt;code&gt;action&lt;/code&gt; , &lt;code&gt;data-action&lt;/code&gt; 또는 &lt;code&gt;x-action&lt;/code&gt; 속성이 포함되지 않은 경우에만 기본 조치 (서식이 서버에 요청을 전송하고 현재 페이지를 다시로드하는 것을 의미 함)를 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="bed9edff008eef6908d8593fd49a8d5e98f6d618" translate="yes" xml:space="preserve">
          <source>Additionally the promise api allows for composition that is very hard to do with the traditional callback (&lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt;) approach. For more on this please see the &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q documentation&lt;/a&gt; especially the section on serial or parallel joining of promises.</source>
          <target state="translated">또한 약속 API는 전통적인 콜백 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;CPS&lt;/a&gt; ) 접근 방식 과는 매우 어려운 구성을 허용합니다 . 이에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q 문서,&lt;/a&gt; 특히 약속의 직렬 또는 병렬 조인 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa2c2f3d21d9dad1d8fad53911125d3af2babd45" translate="yes" xml:space="preserve">
          <source>Additionally, there is the &lt;code&gt;$asyncValidators&lt;/code&gt; object which handles asynchronous validation, such as making an &lt;code&gt;$http&lt;/code&gt; request to the backend. Functions added to the object must return a promise that must be &lt;code&gt;resolved&lt;/code&gt; when valid or &lt;code&gt;rejected&lt;/code&gt; when invalid. In-progress async validations are stored by key in &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24pending.html&quot;&gt;&lt;code&gt;ngModelController.$pending&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 백엔드에 &lt;code&gt;$http&lt;/code&gt; 요청 과 같은 비동기 유효성 검사를 처리 하는 &lt;code&gt;$asyncValidators&lt;/code&gt; 객체가 있습니다. 오브젝트에 추가 된 함수는 유효 할 때 &lt;code&gt;resolved&lt;/code&gt; 되거나 유효하지 않은 경우 &lt;code&gt;rejected&lt;/code&gt; 되어야하는 약속을 리턴해야합니다 . 진행중인 비동기 유효성 검사는 &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24pending.html&quot;&gt; &lt;code&gt;ngModelController.$pending&lt;/code&gt; &lt;/a&gt; 키로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f35feb0b8448abd58c67d83a67eece168f7873e" translate="yes" xml:space="preserve">
          <source>Additionally, we don't want to manually have to flush mocked out requests like we do during unit testing. For this reason the e2e $httpBackend flushes mocked out requests automatically, closely simulating the behavior of the XMLHttpRequest object.</source>
          <target state="translated">또한 단위 테스트 중에와 같이 모의 요청을 수동으로 플러시하지 않아도됩니다. 이러한 이유로 e2e $ httpBackend는 모의 요청을 자동으로 플러시하여 XMLHttpRequest 객체의 동작을 면밀히 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="aacc914ff1ea9003accb975048b58f1c019e22cb" translate="yes" xml:space="preserve">
          <source>Additionally, you can inject the serializer and use it explicitly, for example to serialize form data for submission:</source>
          <target state="translated">또한 serializer를 주입하고 명시 적으로 사용하여 제출할 양식 데이터를 serialize 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb165889f8d056e976595e427b1057d57a14099" translate="yes" xml:space="preserve">
          <source>Additionally, you can provide animations via the &lt;code&gt;ngAnimate&lt;/code&gt; module to animate the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; effects.</source>
          <target state="translated">또한 &lt;code&gt;ngAnimate&lt;/code&gt; 모듈을 통해 애니메이션을 제공 하여 &lt;code&gt;enter&lt;/code&gt; 및 &lt;code&gt;leave&lt;/code&gt; 효과 를 애니메이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="652ae66e59651bbad3fc4132547c5b43954a085e" translate="yes" xml:space="preserve">
          <source>Additionally, you can use its &lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;yOffset&lt;/a&gt; property to specify a vertical scroll-offset (either fixed or dynamic).</source>
          <target state="translated">또한 &lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;yOffset&lt;/a&gt; 속성을 사용하여 세로 스크롤 오프셋 (고정 또는 동적)을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b94dcd84fce535cb2ad08093b0e0a53afb78af9" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;required&lt;/code&gt; attribute and &lt;code&gt;required&lt;/code&gt; validation constraint to the element when the ngRequired expression evaluates to true. Use &lt;code&gt;ngRequired&lt;/code&gt; instead of &lt;code&gt;required&lt;/code&gt; when you want to data-bind to the &lt;code&gt;required&lt;/code&gt; attribute.</source>
          <target state="translated">ngRequired 표현식이 true로 평가 될 때 &lt;code&gt;required&lt;/code&gt; 속성 및 &lt;code&gt;required&lt;/code&gt; 유효성 검증 제한 조건을 요소에 추가 합니다 . &lt;code&gt;required&lt;/code&gt; 속성 에 데이터 바인드하려는 경우 &lt;code&gt;required&lt;/code&gt; 대신 &lt;code&gt;ngRequired&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e69d9b4b904de4d8853a3704d0f29a9f6bee390" translate="yes" xml:space="preserve">
          <source>Adds a new route definition to the &lt;code&gt;$route&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;$route&lt;/code&gt; 서비스에 새 경로 정의를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="59c0db8eda34b5ba002750f3013c112f07dba20a" translate="yes" xml:space="preserve">
          <source>Adds and removes the appropriate CSS class values to the element based on the difference between the new and old CSS class values (specified as newClasses and oldClasses).</source>
          <target state="translated">새로운 CSS 클래스 값과 이전 CSS 클래스 값의 차이 (newClasses 및 oldClasses로 지정)를 기반으로 요소에 적절한 CSS 클래스 값을 추가하고 제거합니다.</target>
        </trans-unit>
        <trans-unit id="70ceb392ed0c1f4b5afec6718451ca7c7a9a3166" translate="yes" xml:space="preserve">
          <source>Adds required attribute and required validation constraint to the element when the ngRequired expression evaluates to true. Use ngRequired instead of required when you want to data-bind to the required attribute.</source>
          <target state="translated">ngRequired 표현식이 true로 평가 될 때 필수 속성 및 필수 유효성 검증 제한 조건을 요소에 추가합니다. 필수 속성에 데이터 바인드하려는 경우 필수 대신 ngRequired를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f110af3382ef95a8b0c07d1c94b21dc5bb62ac38" translate="yes" xml:space="preserve">
          <source>Adds the CSS class value specified by the classVal parameter to the element. If animations are enabled then an animation will be triggered for the class addition.</source>
          <target state="translated">classVal 매개 변수로 지정된 CSS 클래스 값을 요소에 추가합니다. 애니메이션이 활성화되면 클래스 추가를 위해 애니메이션이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="292c1947617a2554dd67a2e52cb2cdbd0ae73d9c" translate="yes" xml:space="preserve">
          <source>Advantages of Components:</source>
          <target state="translated">구성 요소의 장점 :</target>
        </trans-unit>
        <trans-unit id="847093b1cdaeebf405b6651e84441c000a9a1757" translate="yes" xml:space="preserve">
          <source>After a watcher is registered with the scope, the &lt;code&gt;listener&lt;/code&gt; fn is called asynchronously (via &lt;a href=&quot;%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt;) to initialize the watcher. In rare cases, this is undesirable because the listener is called when the result of &lt;code&gt;watchExpression&lt;/code&gt; didn't change. To detect this scenario within the &lt;code&gt;listener&lt;/code&gt; fn, you can compare the &lt;code&gt;newVal&lt;/code&gt; and &lt;code&gt;oldVal&lt;/code&gt;. If these two values are identical (&lt;code&gt;===&lt;/code&gt;) then the listener was called due to initialization.</source>
          <target state="translated">감시자가 범위에 등록되면 &lt;code&gt;listener&lt;/code&gt; fn이 비동기 적으로 ( &lt;a href=&quot;%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync&lt;/a&gt; 를 통해) 호출 되어 감시자를 초기화합니다. 드문 경우지만 &lt;code&gt;watchExpression&lt;/code&gt; 의 결과가 변경되지 않았을 때 리스너가 호출되므로 바람직 하지 않습니다. &lt;code&gt;listener&lt;/code&gt; fn 내에서이 시나리오를 감지하기 위해 &lt;code&gt;newVal&lt;/code&gt; 과 &lt;code&gt;oldVal&lt;/code&gt; 을 비교할 수 있습니다 . 이 두 값이 같으면 ( &lt;code&gt;===&lt;/code&gt; ) 초기화로 인해 리스너가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="6d837481cd1f8b253b815490aa92a842b47bafbe" translate="yes" xml:space="preserve">
          <source>After compilation:</source>
          <target state="translated">컴파일 후 :</target>
        </trans-unit>
        <trans-unit id="714bd774e9df38ca603bcb1b8775b4dd02aa4f0c" translate="yes" xml:space="preserve">
          <source>After evaluating the expression, the &lt;code&gt;$apply&lt;/code&gt; method performs a &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;&lt;code&gt;$digest&lt;/code&gt;&lt;/a&gt;. In the $digest phase the scope examines all of the &lt;code&gt;$watch&lt;/code&gt; expressions and compares them with the previous value. This dirty checking is done asynchronously. This means that assignment such as &lt;code&gt;$scope.username=&quot;angular&quot;&lt;/code&gt; will not immediately cause a &lt;code&gt;$watch&lt;/code&gt; to be notified, instead the &lt;code&gt;$watch&lt;/code&gt; notification is delayed until the &lt;code&gt;$digest&lt;/code&gt; phase. This delay is desirable, since it coalesces multiple model updates into one &lt;code&gt;$watch&lt;/code&gt; notification as well as guarantees that during the &lt;code&gt;$watch&lt;/code&gt; notification no other &lt;code&gt;$watch&lt;/code&gt;es are running. If a &lt;code&gt;$watch&lt;/code&gt; changes the value of the model, it will force additional &lt;code&gt;$digest&lt;/code&gt; cycle.</source>
          <target state="translated">표현식을 평가 한 후 &lt;code&gt;$apply&lt;/code&gt; 메소드는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt; &lt;code&gt;$digest&lt;/code&gt; &lt;/a&gt; 수행합니다 . $ 다이제스트 단계에서 스코프는 모든 &lt;code&gt;$watch&lt;/code&gt; 표현식을 검사 하여 이전 값과 비교합니다. 이 더티 검사는 비동기 적으로 수행됩니다. 이는 &lt;code&gt;$scope.username=&quot;angular&quot;&lt;/code&gt; 와 같은 할당으로 인해 &lt;code&gt;$watch&lt;/code&gt; 에 즉시 알림이 표시되지 않고 &lt;code&gt;$watch&lt;/code&gt; 알림이 &lt;code&gt;$digest&lt;/code&gt; 단계 까지 지연 됩니다. 이 지연은 여러 모델 업데이트를 하나의 &lt;code&gt;$watch&lt;/code&gt; 알림으로 통합 하고 &lt;code&gt;$watch&lt;/code&gt; 알림 동안 다른 &lt;code&gt;$watch&lt;/code&gt; 를 보장 하지 않기 때문에 바람직합니다.es가 실행 중입니다. 경우 &lt;code&gt;$watch&lt;/code&gt; 모델의 값을 변경, 추가적인 강제 &lt;code&gt;$digest&lt;/code&gt; 주기를.</target>
        </trans-unit>
        <trans-unit id="0f6ac511eee4f8b67cef9c9c0f8eb0dbd8113bdd" translate="yes" xml:space="preserve">
          <source>After linking the view is not updated until after a call to $digest which typically is done by AngularJS automatically.</source>
          <target state="translated">링크 후에는 일반적으로 AngularJS가 자동으로 수행하는 $ digest를 호출 할 때까지 뷰가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b4c5b8a75d9c61cd56a5a198356ed3648ef2dcc" translate="yes" xml:space="preserve">
          <source>After that, the configuration blocks (&lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; functions) are executed. This means the configuration blocks of the required modules execute before the configuration blocks of any requiring module.</source>
          <target state="translated">그 후, 구성 블록 ( &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;구성&lt;/a&gt; 기능)이 실행됩니다. 이는 필요한 모듈의 구성 블록이 필요한 모듈의 구성 블록보다 먼저 실행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d4c88341f5c5a27217b8f49b95476ac841a5d629" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;$log&lt;/code&gt; service has been instantiated the decorator is fired. The decorator function has a &lt;code&gt;$delegate&lt;/code&gt; object injected to provide access to the service that matches the selector in the decorator. This &lt;code&gt;$delegate&lt;/code&gt; will be the service you are decorating. The return value of the function &lt;em&gt;provided to the decorator&lt;/em&gt; will take place of the service, directive, or filter being decorated.</source>
          <target state="translated">애프터 &lt;code&gt;$log&lt;/code&gt; 서비스가 인스턴스화 된 장식이 발생합니다. 데코레이터 함수에는 데코레이터 의 선택기와 일치하는 서비스에 대한 액세스를 제공하기 위해 &lt;code&gt;$delegate&lt;/code&gt; 객체가 삽입되어 있습니다. 이 &lt;code&gt;$delegate&lt;/code&gt; 는 당신이 꾸미는 서비스가 될 것입니다. &lt;em&gt;데코레이터에 제공&lt;/em&gt; 되는 함수의 반환 값은 &lt;em&gt;데코레이션&lt;/em&gt; 되는 서비스, 지시문 또는 필터를 대신합니다.</target>
        </trans-unit>
        <trans-unit id="cce55f18d89c3103fa1947be1b088e997277d8d3" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;ngHide&lt;/code&gt; expression evaluates to a non truthy value and just before contents are set to visible.</source>
          <target state="translated">&lt;code&gt;ngHide&lt;/code&gt; 식이 진실 이 아닌 값으로 평가 된 후 내용이 표시되도록 설정하기 직전에.</target>
        </trans-unit>
        <trans-unit id="e1ab027a6f7956cab176653dfbf6557bc5215022" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;ngHide&lt;/code&gt; expression evaluates to a truthy value and just before the contents are set to hidden.</source>
          <target state="translated">&lt;code&gt;ngHide&lt;/code&gt; 표현식이 정확한 값으로 평가 된 후 내용이 숨김으로 설정되기 직전에.</target>
        </trans-unit>
        <trans-unit id="9d89921bca08cb6fce6a3bb709fa68541674e402" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;ngShow&lt;/code&gt; expression evaluates to a non truthy value and just before the contents are set to hidden.</source>
          <target state="translated">&lt;code&gt;ngShow&lt;/code&gt; 표현식 이 진실 이 아닌 값으로 평가 된 후 내용이 숨김으로 설정되기 직전에.</target>
        </trans-unit>
        <trans-unit id="111f924f0a9aa3bf53d410fe9609866c67688702" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;ngShow&lt;/code&gt; expression evaluates to a truthy value and just before contents are set to visible.</source>
          <target state="translated">&lt;code&gt;ngShow&lt;/code&gt; 표현식이 정확한 값으로 평가 된 후 내용이 표시되도록 설정하기 직전에.</target>
        </trans-unit>
        <trans-unit id="4f48526b77c6460bb06d0ccd8371e34af473f98d" translate="yes" xml:space="preserve">
          <source>After the controller is instantiated, the initial values of the isolate scope bindings will be bound to the controller properties. You can access these bindings once they have been initialized by providing a controller method called &lt;code&gt;$onInit&lt;/code&gt;, which is called after all the controllers on an element have been constructed and had their bindings initialized.</source>
          <target state="translated">컨트롤러가 인스턴스화 된 후 격리 범위 바인딩의 초기 값이 컨트롤러 속성에 바인딩됩니다. &lt;code&gt;$onInit&lt;/code&gt; 라는 컨트롤러 메소드를 제공하여 이러한 바인딩이 초기화되면 액세스 할 수 있습니다.이 메소드 는 요소의 모든 컨트롤러가 구성되고 바인딩이 초기화 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c607ef5c745b6810ea7c3c7628151983d81c150d" translate="yes" xml:space="preserve">
          <source>After the page and all of the code is loaded, find the root element of your AngularJS application, which is typically the root of the document.</source>
          <target state="translated">페이지와 모든 코드가로드 된 후 AngularJS 애플리케이션의 루트 요소 (일반적으로 문서의 루트)를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9cbf70d065f21f96da19dec3004f6ea32dededec" translate="yes" xml:space="preserve">
          <source>After transclusion extraction</source>
          <target state="translated">transclusion 추출 후</target>
        </trans-unit>
        <trans-unit id="ed0a35043da2cf495a2d6be468099e7a542faec9" translate="yes" xml:space="preserve">
          <source>After transclusion extraction:</source>
          <target state="translated">transclusion 추출 후 :</target>
        </trans-unit>
        <trans-unit id="e285e9768c55f6517ffdb13c849b48bbb147341e" translate="yes" xml:space="preserve">
          <source>Afterwards, bootstrap your app with this new module.</source>
          <target state="translated">그런 다음이 새로운 모듈로 앱을 부트 스트랩하십시오.</target>
        </trans-unit>
        <trans-unit id="fdc54aaa92409b498b3e55cfe625a5ae6919300c" translate="yes" xml:space="preserve">
          <source>Again, this binding is live, i.e. the DOM will be automatically updated whenever the result of the function changes. The button to pay the invoice uses the directive &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;&lt;code&gt;ngClick&lt;/code&gt;&lt;/a&gt;. This will evaluate the corresponding expression whenever the button is clicked.</source>
          <target state="translated">다시 말하지만이 바인딩은 작동합니다. 즉, 함수 결과가 변경 될 때마다 DOM이 자동으로 업데이트됩니다. 송장을 지불하는 버튼은 지시문 &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt; &lt;code&gt;ngClick&lt;/code&gt; 을&lt;/a&gt; 사용합니다 . 버튼을 클릭 할 때마다 해당 표현식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="79db2c9fda03e69529128dc503983397397f3639" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;%24q#when.html&quot;&gt;when&lt;/a&gt; to maintain naming consistency with ES6.</source>
          <target state="translated">ES6과의 이름 일관성을 유지할 &lt;a href=&quot;%24q#when.html&quot;&gt;시기의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="d53b765cff1cd744d3fd72e862c814dcbde8f0ca" translate="yes" xml:space="preserve">
          <source>Alias: &lt;a href=&quot;ngform&quot;&gt;&lt;code&gt;ngForm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">별명 : &lt;a href=&quot;ngform&quot;&gt; &lt;code&gt;ngForm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="982e50610ee1a463d2de619756fddf0b7506d21c" translate="yes" xml:space="preserve">
          <source>All 4 kinds of bindings (&lt;code&gt;@&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt;) can be made optional by adding &lt;code&gt;?&lt;/code&gt; to the expression. The marker must come after the mode and before the attribute name. See the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/service/error/%24compile/iscp&quot;&gt;Invalid Isolate Scope Definition error&lt;/a&gt; for definition examples. This is useful to refine the interface directives provide. One subtle difference between optional and non-optional happens &lt;strong&gt;when the binding attribute is not set&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 추가하여 4 가지 종류의 바인딩 ( &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; )을 모두 선택적으로 만들 수 있습니다 . 표현에. 마커는 모드 뒤 및 속성 이름 앞에 와야합니다. 정의 예제 는 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/service/error/%24compile/iscp&quot;&gt;유효하지 않은 분리 범위 정의 오류&lt;/a&gt; 를 참조하십시오 . 인터페이스 지시문이 제공하는 데 유용합니다. &lt;strong&gt;바인딩 속성이 설정되지 않은 경우&lt;/strong&gt; 선택적과 비 선택적 사이의 미묘한 차이가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="86d85c5a64cd00727842decd6d1b20b43012da09" translate="yes" xml:space="preserve">
          <source>All cookies</source>
          <target state="translated">모든 쿠키</target>
        </trans-unit>
        <trans-unit id="ec0b516f012da1a300f51233f3fc532b53f1545b" translate="yes" xml:space="preserve">
          <source>All different types of tracking functions, their syntax, and their support for duplicate items in collections can be found in the &lt;a href=&quot;ngrepeat#ngRepeat-arguments.html&quot;&gt;ngRepeat expression description&lt;/a&gt;.</source>
          <target state="translated">모든 다른 유형의 추적 기능, 구문 및 컬렉션의 중복 항목에 대한 지원은 &lt;a href=&quot;ngrepeat#ngRepeat-arguments.html&quot;&gt;ngRepeat 표현식 설명&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3159c7682fd037fbbeed77e34c757d4c52e444c" translate="yes" xml:space="preserve">
          <source>All directives and components must use the standard &lt;code&gt;{{&lt;/code&gt;&lt;code&gt;}}&lt;/code&gt; interpolation symbols in their templates. If you change the application interpolation symbols the &lt;a href=&quot;%24compile&quot;&gt;&lt;code&gt;$compile&lt;/code&gt;&lt;/a&gt; service will attempt to denormalize the standard symbols to the custom symbols. The denormalization process is not clever enough to know not to replace instances of the standard symbols where they would not normally be treated as interpolation symbols. For example in the following code snippet the closing braces of the literal object will get incorrectly denormalized:</source>
          <target state="translated">모든 지시문 및 구성 요소는 해당 템플리트에서 표준 &lt;code&gt;{{&lt;/code&gt; &lt;code&gt;}}&lt;/code&gt; 보간 기호를 사용해야합니다 . 응용 프로그램 보간 기호를 변경하면 &lt;a href=&quot;%24compile&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; &lt;/a&gt; 서비스는 표준 기호를 사용자 지정 기호로 비정규 화하려고 시도합니다. 비정규 화 프로세스는 일반적으로 보간 심볼로 취급되지 않는 표준 심볼의 인스턴스를 대체하지 않을 정도로 영리하지 않습니다. 예를 들어 다음 코드 스 니펫에서 리터럴 객체의 닫는 괄호가 잘못 비정규 화됩니다.</target>
        </trans-unit>
        <trans-unit id="73501beef5e8878433719d4f65aeedc3d1bb85c4" translate="yes" xml:space="preserve">
          <source>All items are passed through the predicate (or predicates), and the returned values are saved along with their type (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; etc). For example, an item &lt;code&gt;{label: 'foo'}&lt;/code&gt;, passed through a predicate that extracts the value of the &lt;code&gt;label&lt;/code&gt; property, would be transformed to:</source>
          <target state="translated">모든 항목은 술어 (또는 술어)를 통해 전달되며 리턴 된 값은 해당 유형 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; 등) 과 함께 저장됩니다 . 예를 들어 &lt;code&gt;label&lt;/code&gt; 속성 의 값을 추출하는 술어를 통해 전달 된 &lt;code&gt;{label: 'foo'}&lt;/code&gt; 항목 은 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a25aaffbef3857cd123066d794fffb0b8d68aa35" translate="yes" xml:space="preserve">
          <source>All localizable AngularJS components depend on locale-specific rule sets managed by the &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt;&lt;code&gt;$locale&lt;/code&gt; service&lt;/a&gt;.</source>
          <target state="translated">현지화 가능한 모든 AngularJS 컴포넌트는 &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt; &lt;code&gt;$locale&lt;/code&gt; 서비스가&lt;/a&gt; 관리하는 로케일 별 규칙 세트에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6a47817fa29a225834088f98ddaf9bf379a62572" translate="yes" xml:space="preserve">
          <source>All of the setter methods return the same &lt;code&gt;$location&lt;/code&gt; object to allow chaining. For example, to change multiple segments in one go, chain setters like this:</source>
          <target state="translated">모든 setter 메소드는 동일한 &lt;code&gt;$location&lt;/code&gt; 객체를 반환하여 연결을 허용합니다. 예를 들어, 여러 세그먼트를 한 번에 변경하려면 체인 세터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5665273a60bfa82bedc39a2b20426fbbdbe35b2" translate="yes" xml:space="preserve">
          <source>All of this compilation takes place in the web browser; no server side or pre-compilation step is involved.</source>
          <target state="translated">이 모든 편집은 웹 브라우저에서 이루어집니다. 서버 측 또는 사전 컴파일 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bb32db6893580bdfa7e771a49c32315a6221726" translate="yes" xml:space="preserve">
          <source>All parameters can be changed dynamically. The next example shows how you can make the columns of a table sortable, by binding the &lt;code&gt;expression&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; parameters to scope properties.</source>
          <target state="translated">모든 매개 변수는 동적으로 변경 될 수 있습니다. 다음 예제에서는 &lt;code&gt;expression&lt;/code&gt; 및 &lt;code&gt;reverse&lt;/code&gt; 매개 변수를 범위 속성 에 바인딩하여 테이블의 열을 정렬 할 수있는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">컨트롤러를 제외한 모든 특수 목적 객체는 공장 레시피를 통해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2cad0a05b7bc6c8be5db0377e3f07206383a266c" translate="yes" xml:space="preserve">
          <source>All that is going on here with ngShow/ngHide behind the scenes is the &lt;code&gt;.ng-hide&lt;/code&gt; class is added/removed (when the hidden state is valid). Since ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.</source>
          <target state="translated">ngShow / ngHide와 함께 여기에서 진행되는 모든 것은 &lt;code&gt;.ng-hide&lt;/code&gt; 클래스가 추가 / 제거 된 것입니다 (숨겨진 상태가 유효 할 때). ngShow와 ngHide는 애니메이션을 인식하므로 전환을 일치시킬 수 있으며 ngAnimate는 나머지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8e830154a70aba6c6c2d76c09999e74a8801b263" translate="yes" xml:space="preserve">
          <source>All values that are passed to &lt;code&gt;$location&lt;/code&gt; setter methods, &lt;code&gt;path()&lt;/code&gt;, &lt;code&gt;search()&lt;/code&gt;, &lt;code&gt;hash()&lt;/code&gt;, are encoded.</source>
          <target state="translated">&lt;code&gt;$location&lt;/code&gt; setter 메소드, &lt;code&gt;path()&lt;/code&gt; , &lt;code&gt;search()&lt;/code&gt; , &lt;code&gt;hash()&lt;/code&gt; 로 전달되는 모든 값 이 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ee866773b32bc215a390a39a4f20f9a341baa022" translate="yes" xml:space="preserve">
          <source>Allows defining the set of characters that are allowed in AngularJS expressions. The function &lt;code&gt;identifierStart&lt;/code&gt; will get called to know if a given character is a valid character to be the first character for an identifier. The function &lt;code&gt;identifierContinue&lt;/code&gt; will get called to know if a given character is a valid character to be a follow-up identifier character. The functions &lt;code&gt;identifierStart&lt;/code&gt; and &lt;code&gt;identifierContinue&lt;/code&gt; will receive as arguments the single character to be identifier and the character code point. These arguments will be &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt;. Keep in mind that the &lt;code&gt;string&lt;/code&gt; parameter can be two characters long depending on the character representation. It is expected for the function to return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, whether that character is allowed or not.</source>
          <target state="translated">AngularJS 표현식에서 허용되는 문자 세트를 정의 할 수 있습니다. 주어진 문자가 식별자의 첫 번째 문자가 될 수있는 유효한 문자인지를 &lt;code&gt;identifierStart&lt;/code&gt; 위해 identifierStart 함수 가 호출됩니다. 주어진 문자가 후속 식별자 문자가 될 수있는 유효한 문자인지를 &lt;code&gt;identifierContinue&lt;/code&gt; 위해 identifierContinue 함수 가 호출됩니다. &lt;code&gt;identifierStart&lt;/code&gt; 및 &lt;code&gt;identifierContinue&lt;/code&gt; 함수 는 단일 문자로 식별자 및 문자 코드 포인트를 인수로받습니다. 이 인수는 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;numeric&lt;/code&gt; 입니다. &lt;code&gt;string&lt;/code&gt; 을 명심하십시오매개 변수는 문자 표현에 따라 두 문자 길이 일 수 있습니다. 해당 문자의 허용 여부에 관계없이 함수가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a0dfc44a8bb5647973347c240aca24c18c76b6e" translate="yes" xml:space="preserve">
          <source>Allows multiple options to be selected. The selected values will be bound to the model as an array.</source>
          <target state="translated">여러 옵션을 선택할 수 있습니다. 선택한 값은 모델에 배열로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="6893f81d9274e77bed184d8c69170d4bd9bc82d3" translate="yes" xml:space="preserve">
          <source>Allows the user to query if the particular service exists.</source>
          <target state="translated">특정 서비스가 존재하는지 사용자가 쿼리 할 수 ​​있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c700927994271f378f5571025a478be8044ec069" translate="yes" xml:space="preserve">
          <source>Allows you to convert a JavaScript object into JSON string.</source>
          <target state="translated">JavaScript 객체를 JSON 문자열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2ed1f71a67126f9d5f6f5fb8ead5d97d9e1cdd" translate="yes" xml:space="preserve">
          <source>Also there is special case for Moz prefix starting with upper case letter.</source>
          <target state="translated">또한 대문자로 시작하는 Moz 접두사에 대한 특별한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2bcb812e9ddd641d60f5e796d9a28cdbad4e2c" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;ngIf&lt;/code&gt; recreates elements using their compiled state. An example of this behavior is if an element's class attribute is directly modified after it's compiled, using something like jQuery's &lt;code&gt;.addClass()&lt;/code&gt; method, and the element is later removed. When &lt;code&gt;ngIf&lt;/code&gt; recreates the element the added class will be lost because the original compiled state is used to regenerate the element.</source>
          <target state="translated">또한 &lt;code&gt;ngIf&lt;/code&gt; 는 컴파일 된 상태를 사용하여 요소를 다시 만듭니다. 이 동작의 예는 jQuery의 &lt;code&gt;.addClass()&lt;/code&gt; 메소드와 같은 요소를 사용하여 요소의 클래스 속성이 컴파일 된 후 직접 수정 되고 나중에 요소가 제거되는 경우입니다. 때 &lt;code&gt;ngIf&lt;/code&gt; 이 요소를 다시 만들어 원래의 컴파일 된 상태가 요소를 다시 생성하는 데 사용되기 때문에 추가 된 클래스는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="cae8ad452ed52b4364f25ab05ff05e650916df18" translate="yes" xml:space="preserve">
          <source>Alternative &lt;a href=&quot;%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; params serializer that follows jQuery's &lt;a href=&quot;http://api.jquery.com/jquery.param/&quot;&gt;&lt;code&gt;param()&lt;/code&gt;&lt;/a&gt; method logic. The serializer will also sort the params alphabetically.</source>
          <target state="translated">jQuery의 &lt;a href=&quot;http://api.jquery.com/jquery.param/&quot;&gt; &lt;code&gt;param()&lt;/code&gt; &lt;/a&gt; 메소드 로직 을 따르는 대체 &lt;a href=&quot;%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; params 시리얼 라이저 . 시리얼 라이저는 또한 매개 변수를 알파벳순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="1986d05c6408cc68f17db3c47392a453a7bfa1f3" translate="yes" xml:space="preserve">
          <source>Alternative &lt;a href=&quot;service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; params serializer that follows jQuery's &lt;a href=&quot;http://api.jquery.com/jquery.param/&quot;&gt;&lt;code&gt;param()&lt;/code&gt;&lt;/a&gt; method logic. The serializer will also sort the params alphabetically.</source>
          <target state="translated">jQuery의 &lt;a href=&quot;http://api.jquery.com/jquery.param/&quot;&gt; &lt;code&gt;param()&lt;/code&gt; &lt;/a&gt; 메소드 로직 을 따르는 대체 &lt;a href=&quot;service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; params 시리얼 라이저 . 시리얼 라이저는 또한 매개 변수를 알파벳순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="0e831c9cda5cf6bfb0807f5344ad0dc49c8046ab" translate="yes" xml:space="preserve">
          <source>Although AngularJS makes i18n convenient, there are several things you need to be conscious of as you develop your app.</source>
          <target state="translated">AngularJS는 i18n을 편리하게 만들지 만 앱을 개발할 때주의해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc361285cac50472d68caba2b407d041dcf954eb" translate="yes" xml:space="preserve">
          <source>Although the CSS is a little different than what we saw before, the idea is the same.</source>
          <target state="translated">CSS는 이전에 본 것과 약간 다르지만 아이디어는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1d3f0a93f4e12755f9ed54ee382ddaf25896e70f" translate="yes" xml:space="preserve">
          <source>Although there are many ways to test a Controller, one of the best conventions, shown below, involves injecting the &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$rootScope&lt;/a&gt; and &lt;a href=&quot;../api/ng/service/%24controller&quot;&gt;$controller&lt;/a&gt;:</source>
          <target state="translated">컨트롤러를 테스트하는 방법은 여러 가지가 있지만 아래에 나와있는 가장 좋은 규칙 중 하나는 &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$ rootScope&lt;/a&gt; 및 &lt;a href=&quot;../api/ng/service/%24controller&quot;&gt;$ controller를&lt;/a&gt; 주입하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="664ea04f360cf50ee3034fb79c72bfc990a51803" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Array.&amp;lt;DirectiveObject&amp;gt;&lt;/code&gt;&lt;sub&gt;&lt;a href=&quot;decorators#drtvArray.html&quot;&gt;1&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;code&gt;Array.&amp;lt;DirectiveObject&amp;gt;&lt;/code&gt; &lt;sub&gt;&lt;a href=&quot;decorators#drtvArray.html&quot;&gt;1&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="72132aa9016db41ce813e2e986f465c21ae9978a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;integer&lt;/code&gt; directive that validates whether the input is a valid integer. For example, &lt;code&gt;1.23&lt;/code&gt; is an invalid value, since it contains a fraction. Note that we validate the viewValue (the string value of the control), and not the modelValue. This is because input[number] converts the viewValue to a number when running the &lt;code&gt;$parsers&lt;/code&gt;.</source>
          <target state="translated">입력이 유효한 정수인지 확인 하는 &lt;code&gt;integer&lt;/code&gt; 지시문입니다. 예를 들어 &lt;code&gt;1.23&lt;/code&gt; 은 분수를 포함하므로 유효하지 않은 값입니다. modelValue가 아닌 viewValue (컨트롤의 문자열 값)의 유효성을 검사합니다. 이것은 input [number]가 &lt;code&gt;$parsers&lt;/code&gt; 실행할 때 viewValue를 숫자로 변환하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="7c21d96b949c9521f03fc61f9044eaf72551b8b6" translate="yes" xml:space="preserve">
          <source>An AngularJS &lt;strong&gt;service&lt;/strong&gt; is a singleton object created by a &lt;strong&gt;service factory&lt;/strong&gt;. These &lt;strong&gt;service factories&lt;/strong&gt; are functions which, in turn, are created by a &lt;strong&gt;service provider&lt;/strong&gt;. The &lt;strong&gt;service providers&lt;/strong&gt; are constructor functions. When instantiated they must contain a property called &lt;code&gt;$get&lt;/code&gt;, which holds the &lt;strong&gt;service factory&lt;/strong&gt; function.</source>
          <target state="translated">AngularJS &lt;strong&gt;서비스&lt;/strong&gt; 는 &lt;strong&gt;서비스 팩토리에&lt;/strong&gt; 의해 생성 된 싱글 톤 객체입니다 . 이러한 &lt;strong&gt;서비스 팩토리&lt;/strong&gt; 는 &lt;strong&gt;서비스 제공자&lt;/strong&gt; 가 작성하는 기능입니다 . &lt;strong&gt;서비스 제공자는&lt;/strong&gt; 생성자 함수입니다. 인스턴스화 할 때 &lt;strong&gt;서비스 팩토리&lt;/strong&gt; 기능 을 보유하는 &lt;code&gt;$get&lt;/code&gt; 이라는 특성을 포함해야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f5e902fbb09480c376fa0194b1e609ced186aa3" translate="yes" xml:space="preserve">
          <source>An AngularJS expression to be executed.</source>
          <target state="translated">실행할 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="b37bf8f17fc0e4cf752fc858258841e0042e4bb7" translate="yes" xml:space="preserve">
          <source>An Example of &quot;Compile&quot; Versus &quot;Link&quot;</source>
          <target state="translated">&quot;링크&quot;와 &quot;컴파일&quot;의 예</target>
        </trans-unit>
        <trans-unit id="9ef9cd2a9880a76f773b11fee32868da9ed975cc" translate="yes" xml:space="preserve">
          <source>An alternative solution to this problem would be using the &lt;a href=&quot;ngcloak&quot;&gt;ngCloak&lt;/a&gt; directive.</source>
          <target state="translated">이 문제에 대한 대안 솔루션은 &lt;a href=&quot;ngcloak&quot;&gt;ngCloak&lt;/a&gt; 지시문을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7e680432122c70e32424dcdf0fd61139308710c4" translate="yes" xml:space="preserve">
          <source>An animation runner returned by an $animate function.</source>
          <target state="translated">$ animate 함수가 반환 한 애니메이션 러너.</target>
        </trans-unit>
        <trans-unit id="7056c57ecc4a5b129adb248caf351bdeae7d09c4" translate="yes" xml:space="preserve">
          <source>An array or hash of promises.</source>
          <target state="translated">약속의 배열 또는 해시.</target>
        </trans-unit>
        <trans-unit id="438126d6254d3420fb8b54716dd74b0c0c91bd27" translate="yes" xml:space="preserve">
          <source>An example of interpolation is shown below:</source>
          <target state="translated">보간의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25266bc9e38243de1cfb398019dfc315000d1f50" translate="yes" xml:space="preserve">
          <source>An example on how to implement animations using &lt;code&gt;ngClassEven&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ngClassEven&lt;/code&gt; 을 사용하여 애니메이션을 구현하는 방법에 대한 예제 :</target>
        </trans-unit>
        <trans-unit id="255badf5f975c2e6c577cd02fbbd0dd9ce5fa56a" translate="yes" xml:space="preserve">
          <source>An example on how to implement animations using &lt;code&gt;ngClassOdd&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ngClassOdd&lt;/code&gt; 를 사용하여 애니메이션을 구현하는 방법에 대한 예제 :</target>
        </trans-unit>
        <trans-unit id="62dc53f9c709ad888e01b1a59fcc76fe0155aa4c" translate="yes" xml:space="preserve">
          <source>An expression can be optionally prefixed with &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to control the sorting direction, ascending or descending. For example, &lt;code&gt;'+label'&lt;/code&gt; or &lt;code&gt;'-label'&lt;/code&gt;. If no property is provided, (e.g. &lt;code&gt;'+'&lt;/code&gt; or &lt;code&gt;'-'&lt;/code&gt;), the collection element itself is used in comparisons.</source>
          <target state="translated">정렬 방향, 오름차순 또는 내림차순을 제어하기 위해 식 앞에 선택적으로 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 붙일 수 있습니다 . 예를 들어, &lt;code&gt;'+label'&lt;/code&gt; 또는 &lt;code&gt;'-label'&lt;/code&gt; 입니다. 속성이 제공되지 않으면 (예 : &lt;code&gt;'+'&lt;/code&gt; 또는 &lt;code&gt;'-'&lt;/code&gt; ) 수집 요소 자체가 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f036173d46ad7b878cf3296d2b2dac5c0eb15db" translate="yes" xml:space="preserve">
          <source>An expression that starts with &lt;code&gt;::&lt;/code&gt; is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 로 시작하는 표현식은 일회성 표현식으로 간주됩니다. 일회성 표현식은 일단 안정되면 재 계산을 중지합니다. 표현식 결과가 정의되지 않은 값인 경우 첫 번째 다이제스트 후에 발생합니다 (아래의 값 안정화 알고리즘 참조).</target>
        </trans-unit>
        <trans-unit id="1377c3d192d7bf8b19b573abc270573ee59d7ec8" translate="yes" xml:space="preserve">
          <source>An injectable class (constructor function) that will be instantiated.</source>
          <target state="translated">인스턴스화 할 주입 가능한 클래스 (생성자 함수)</target>
        </trans-unit>
        <trans-unit id="a9b6840dea47811dc05aae5027aa0a40ccd033fa" translate="yes" xml:space="preserve">
          <source>An injectable directive factory function. See the &lt;a href=&quot;../../../guide/directive&quot;&gt;directive guide&lt;/a&gt; and the &lt;a href=&quot;../service/%24compile&quot;&gt;compile API&lt;/a&gt; for more info.</source>
          <target state="translated">주사 가능한 지시문 팩토리 기능. 자세한 정보는 &lt;a href=&quot;../../../guide/directive&quot;&gt;지시문 안내서&lt;/a&gt; 및 &lt;a href=&quot;../service/%24compile&quot;&gt;컴파일 API&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2c035f4bab2a6ca81a26cf1561e460c12d7af3" translate="yes" xml:space="preserve">
          <source>An object hash with all failing validator ids as keys.</source>
          <target state="translated">실패한 모든 유효성 검사기 ID를 키로 사용하는 개체 해시입니다.</target>
        </trans-unit>
        <trans-unit id="7481e3cf882547d1cafefe1993d08399c2f33260" translate="yes" xml:space="preserve">
          <source>An object hash with all pending validator ids as keys.</source>
          <target state="translated">보류중인 모든 유효성 검사기 ID를 키로 사용하는 개체 해시입니다.</target>
        </trans-unit>
        <trans-unit id="f2cf8cfd906e9099c3100166fe9e3fd7080b9f49" translate="yes" xml:space="preserve">
          <source>An object hash, containing references to controls or forms with failing validators, where:</source>
          <target state="translated">검증자가 실패한 컨트롤 또는 폼에 대한 참조를 포함하는 객체 해시.</target>
        </trans-unit>
        <trans-unit id="b4699c85185b56a805c395192bbb329ac54ca51f" translate="yes" xml:space="preserve">
          <source>An object hash, containing references to controls or forms with pending validators, where:</source>
          <target state="translated">보류중인 유효성 검사기가있는 컨트롤 또는 폼에 대한 참조가 포함 된 개체 해시.</target>
        </trans-unit>
        <trans-unit id="e28988a5accfd6915ed9bed343b184db496ecd37" translate="yes" xml:space="preserve">
          <source>An object that contains information about the current AngularJS version.</source>
          <target state="translated">현재 AngularJS 버전에 대한 정보가 포함 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="174ed948b808866039efe36a930b9f1ce4822c05" translate="yes" xml:space="preserve">
          <source>An optional object which contains additional event data that is used when creating the event:</source>
          <target state="translated">이벤트를 작성할 때 사용되는 추가 이벤트 데이터가 포함 된 선택적 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="fc3637df868e602451404b5f647130a18cca9153" translate="yes" xml:space="preserve">
          <source>An optional string to provide the origin of the function call for error messages.</source>
          <target state="translated">오류 메시지에 대한 함수 호출의 출처를 제공하는 선택적 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="890f2279934dc8a6b8499be1df29aafd89f69b59" translate="yes" xml:space="preserve">
          <source>Anchoring Demo</source>
          <target state="translated">앵커링 데모</target>
        </trans-unit>
        <trans-unit id="326eb1ddaaabb3b6d3a467b41d5832d75f3ed666" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;$animateCss&lt;/code&gt; will figure out the rest. Just make sure to have the &lt;code&gt;done()&lt;/code&gt; callback fire the &lt;code&gt;doneFn&lt;/code&gt; function to signal when the animation is over.</source>
          <target state="translated">그리고 &lt;code&gt;$animateCss&lt;/code&gt; 는 나머지를 알아낼 것입니다. 애니메이션이 끝났을 때 &lt;code&gt;done()&lt;/code&gt; 콜백이 &lt;code&gt;doneFn&lt;/code&gt; 함수를 실행하여 신호를 보내 도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4e0c6972a0d5d288dd0cd636689c2317a6bcbb1" translate="yes" xml:space="preserve">
          <source>And an application level module which depends on the above modules and contains any initialization code.</source>
          <target state="translated">그리고 위의 모듈에 의존하고 초기화 코드를 포함하는 응용 프로그램 수준 모듈.</target>
        </trans-unit>
        <trans-unit id="66d5e630fa1d9e7e00b2527efa6f276e0610f85b" translate="yes" xml:space="preserve">
          <source>And since Constant recipe makes the value also available at runtime just like the Value recipe, we can also use it in our controller and template:</source>
          <target state="translated">상수 레시피는 값 레시피와 마찬가지로 런타임에도 값을 사용할 수 있으므로 컨트롤러 및 템플릿에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae7dabd4284493793044636058e6d4510506040" translate="yes" xml:space="preserve">
          <source>And the following &lt;code&gt;&amp;lt;person&amp;gt;&lt;/code&gt; element &lt;strong&gt;matches&lt;/strong&gt; the &lt;code&gt;person&lt;/code&gt; directive:</source>
          <target state="translated">그리고 다음 &lt;code&gt;&amp;lt;person&amp;gt;&lt;/code&gt; 요소 는 &lt;code&gt;person&lt;/code&gt; 지시어 &lt;strong&gt;와 일치&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="e074b907bd18b60b4c8b9d046fe304e0a1334c25" translate="yes" xml:space="preserve">
          <source>And then each individual test is defined within a call to the &lt;code&gt;it&lt;/code&gt; function:</source>
          <target state="translated">그런 다음 각 개별 테스트는 &lt;code&gt;it&lt;/code&gt; 함수 호출 내에서 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcab3a39fd9e6cc3ee88ad70caa5024094be413f" translate="yes" xml:space="preserve">
          <source>And this is how you would display it via AngularJS's data-binding:</source>
          <target state="translated">그리고 이것은 AngularJS의 데이터 바인딩을 통해 표시하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="12546996946dd46b31df4b813318ccd8f12a4142" translate="yes" xml:space="preserve">
          <source>And with an input of &lt;code&gt;['A','B']&lt;/code&gt; for the items variable in the example above, the output will evaluate to:</source>
          <target state="translated">그리고 입력과 &lt;code&gt;['A','B']&lt;/code&gt; , 출력은로 평가 될 것이다 위의 예에서 항목 변수 :</target>
        </trans-unit>
        <trans-unit id="7be54da4aeef061feb2dd88f21e1e293d3e62c45" translate="yes" xml:space="preserve">
          <source>Angular.js</source>
          <target state="translated">Angular.js</target>
        </trans-unit>
        <trans-unit id="13791425bfb26b4e4a5449e290a7555a8da39a41" translate="yes" xml:space="preserve">
          <source>AngularFire</source>
          <target state="translated">AngularFire</target>
        </trans-unit>
        <trans-unit id="ab3119bf73d8058434a4147335dfd43554aec933" translate="yes" xml:space="preserve">
          <source>AngularJS  Tag</source>
          <target state="translated">AngularJS 태그</target>
        </trans-unit>
        <trans-unit id="3f0faae0118505f14f548205980339e05517f7b2" translate="yes" xml:space="preserve">
          <source>AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of AngularJS, defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in &lt;strong&gt;JS animations taking charge of the animation&lt;/strong&gt;:</source>
          <target state="translated">AngularJS 1.4 이상은 CSS 및 JS 애니메이션의 통합을보다 유연하게하기위한 조치를 취했습니다. 그러나 이전 버전의 AngularJS와 달리 동일한 CSS 클래스에서 작동하도록 CSS 및 JS 애니메이션을 정의하면 더 이상 작동하지 않습니다. 따라서 아래 예는 &lt;strong&gt;JS 애니메이션&lt;/strong&gt; 만 &lt;strong&gt;애니메이션을 담당합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0991984fb2b8a5470a91fe03e8798b2bb70f6d5d" translate="yes" xml:space="preserve">
          <source>AngularJS &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;scopes&lt;/a&gt;;</source>
          <target state="translated">AngularJS &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;범위&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="7cf4e203d1f24008eb58eb8fa122f0e7859f0b96" translate="yes" xml:space="preserve">
          <source>AngularJS &lt;strong&gt;normalizes&lt;/strong&gt; an element's tag and attribute name to determine which elements match which directives. We typically refer to directives by their case-sensitive &lt;a href=&quot;http://en.wikipedia.org/wiki/CamelCase&quot;&gt;camelCase&lt;/a&gt;&lt;strong&gt;normalized&lt;/strong&gt; name (e.g. &lt;code&gt;ngModel&lt;/code&gt;). However, since HTML is case-insensitive, we refer to directives in the DOM by lower-case forms, typically using &lt;a href=&quot;https://en.wikipedia.org/wiki/Letter_case#Special_case_styles&quot;&gt;dash-delimited&lt;/a&gt; attributes on DOM elements (e.g. &lt;code&gt;ng-model&lt;/code&gt;).</source>
          <target state="translated">AngularJS 는 요소의 태그와 속성 이름을 &lt;strong&gt;정규화&lt;/strong&gt; 하여 어떤 요소가 어떤 지시문과 일치하는지 확인합니다. 일반적으로 대소 문자를 구분하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/CamelCase&quot;&gt;camelCase &lt;/a&gt;&lt;strong&gt;정규화 된&lt;/strong&gt; 이름 (예 : &lt;code&gt;ngModel&lt;/code&gt; ) 으로 지시문을 참조합니다 . 그러나 HTML은 대소 문자를 구분하지 않으므로 DOM 요소에서 소문자 &lt;a href=&quot;https://en.wikipedia.org/wiki/Letter_case#Special_case_styles&quot;&gt;로 구분 된&lt;/a&gt; 속성 (예 : &lt;code&gt;ng-model&lt;/code&gt; )을 사용하여 DOM의 지시문을 소문자 형식으로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f4a2157fd4651f5ccd744058540881b06b68a586" translate="yes" xml:space="preserve">
          <source>AngularJS Accessibility at ngEurope</source>
          <target state="translated">ngEurope의 AngularJS 접근성</target>
        </trans-unit>
        <trans-unit id="58966c0a99e9180ce8cf2c8238894a17e5acefa3" translate="yes" xml:space="preserve">
          <source>AngularJS Blog</source>
          <target state="translated">AngularJS 블로그</target>
        </trans-unit>
        <trans-unit id="10935422d37be07b1f9d03bd4bd4648742ed57f5" translate="yes" xml:space="preserve">
          <source>AngularJS Expressions vs. JavaScript Expressions</source>
          <target state="translated">AngularJS 표현식과 JavaScript 표현식</target>
        </trans-unit>
        <trans-unit id="fa4112920b48d03503b9cfdbeff4addf37de8003" translate="yes" xml:space="preserve">
          <source>AngularJS IRC channel</source>
          <target state="translated">AngularJS IRC 채널</target>
        </trans-unit>
        <trans-unit id="8709ab6a8289c4a260c3e11677b31fbb21a2a30d" translate="yes" xml:space="preserve">
          <source>AngularJS Material</source>
          <target state="translated">AngularJS 머티리얼</target>
        </trans-unit>
        <trans-unit id="2cced466cd886f24b57c2f6ae044b2c12669f782" translate="yes" xml:space="preserve">
          <source>AngularJS Scopes</source>
          <target state="translated">AngularJS 범위</target>
        </trans-unit>
        <trans-unit id="cc3917a0e77e480943a79e1de65aac43cd92aabb" translate="yes" xml:space="preserve">
          <source>AngularJS Seed</source>
          <target state="translated">AngularJS 씨앗</target>
        </trans-unit>
        <trans-unit id="6c5d29b4a87b1dc1dda5895fca5ac894b2cad8db" translate="yes" xml:space="preserve">
          <source>AngularJS Service API</source>
          <target state="translated">AngularJS 서비스 API</target>
        </trans-unit>
        <trans-unit id="6ea95f8da2f97d39b353d9d6c1e8c0ca783d16e2" translate="yes" xml:space="preserve">
          <source>AngularJS Styleguide</source>
          <target state="translated">AngularJS 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="19c7c3ee2f637e8d9c1e5f271cfa0f66e077975b" translate="yes" xml:space="preserve">
          <source>AngularJS Templates</source>
          <target state="translated">AngularJS 템플릿</target>
        </trans-unit>
        <trans-unit id="0453b2acb9baff1f059cf73da1f3ca1a4a489724" translate="yes" xml:space="preserve">
          <source>AngularJS Templates and Expressions</source>
          <target state="translated">AngularJS 템플릿 및 표현식</target>
        </trans-unit>
        <trans-unit id="a50311307d9b448cd7b8f1579e7819949f998f99" translate="yes" xml:space="preserve">
          <source>AngularJS UI Bootstrap</source>
          <target state="translated">AngularJS UI 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="3757aac570708761ec4fe9543f6d5b9883dd0ffc" translate="yes" xml:space="preserve">
          <source>AngularJS UI Grid</source>
          <target state="translated">AngularJS UI 그리드</target>
        </trans-unit>
        <trans-unit id="27533abdf37da8420a124cdfff17869288101509" translate="yes" xml:space="preserve">
          <source>AngularJS UI Map (Google Maps)</source>
          <target state="translated">AngularJS UI 맵 (Google Maps)</target>
        </trans-unit>
        <trans-unit id="4bfbeef31141b3d561aa7fbd5547bc14fd515a39" translate="yes" xml:space="preserve">
          <source>AngularJS also pays attention to CSS class changes on elements by triggering the &lt;strong&gt;add&lt;/strong&gt; and &lt;strong&gt;remove&lt;/strong&gt; hooks. This means that if a CSS class is added to or removed from an element then an animation can be executed in between, before the CSS class addition or removal is finalized. (Keep in mind that AngularJS will only be able to capture class changes if an &lt;strong&gt;interpolated expression&lt;/strong&gt; or the &lt;strong&gt;ng-class&lt;/strong&gt; directive is used on the element.)</source>
          <target state="translated">AngularJS는 또한 &lt;strong&gt;추가&lt;/strong&gt; 및 &lt;strong&gt;제거&lt;/strong&gt; 후크를 트리거하여 요소의 CSS 클래스 변경에주의를 기울 입니다. 즉, CSS 클래스가 요소에 추가되거나 요소에서 제거되면 CSS 클래스 추가 또는 제거가 완료되기 전에 그 사이에 애니메이션을 실행할 수 있습니다. AngularJS는 &lt;strong&gt;보간 된 표현식&lt;/strong&gt; 또는 &lt;strong&gt;ng-class&lt;/strong&gt; 지시문이 요소에 사용되는 경우에만 클래스 변경 사항을 캡처 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f88fe3aac6229871b3db2ee53f14d289253d6fe" translate="yes" xml:space="preserve">
          <source>AngularJS also provides the &lt;a href=&quot;../api/ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module, which provides mocking for your tests. This is used to inject and mock AngularJS services within unit tests. In addition, it is able to extend other modules so they are synchronous. Having tests synchronous keeps them much cleaner and easier to work with. One of the most useful parts of ngMock is &lt;a href=&quot;../api/ngmock/service/%24httpbackend&quot;&gt;&lt;code&gt;$httpBackend&lt;/code&gt;&lt;/a&gt;, which lets us mock XHR requests in tests, and return sample data instead.</source>
          <target state="translated">AngularJS는 테스트를위한 모의 기능을 제공하는 &lt;a href=&quot;../api/ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt; 모듈 도 제공합니다 . 이것은 단위 테스트 내에서 AngularJS 서비스를 주입하고 조롱하는 데 사용됩니다. 또한 다른 모듈을 확장하여 동기화 할 수 있습니다. 테스트를 동기화하면 훨씬 더 깨끗하고 작업하기 쉽습니다. ngMock의 가장 유용한 부분 중 하나는 &lt;a href=&quot;../api/ngmock/service/%24httpbackend&quot;&gt; &lt;code&gt;$httpBackend&lt;/code&gt; &lt;/a&gt; 이며, 테스트에서 XHR 요청을 조롱하고 대신 샘플 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d001fe84458eea653438a88cf62e275bc3871980" translate="yes" xml:space="preserve">
          <source>AngularJS also provides the following additional methods and events to both jQuery and jqLite:</source>
          <target state="translated">AngularJS는 또한 jQuery와 jqLite에 다음과 같은 추가 메소드와 이벤트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8c5f79197dfa3de08bf76fd8a1637d31da7b391" translate="yes" xml:space="preserve">
          <source>AngularJS and Cordova</source>
          <target state="translated">AngularJS와 코르도바</target>
        </trans-unit>
        <trans-unit id="238b92e9c0ec431391c26fbce2a871d3a4d73b04" translate="yes" xml:space="preserve">
          <source>AngularJS applications cannot be nested within each other.</source>
          <target state="translated">AngularJS 애플리케이션은 서로 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3ee826c3209863e648113706ae9e0875449b60b" translate="yes" xml:space="preserve">
          <source>AngularJS applies the &lt;code&gt;name = 'X';&lt;/code&gt; to the model.</source>
          <target state="translated">AngularJS는 &lt;code&gt;name = 'X';&lt;/code&gt; 적용합니다 . 모델에.</target>
        </trans-unit>
        <trans-unit id="8ea8fc92595d21993d4f0e0cfb641e521696f8ce" translate="yes" xml:space="preserve">
          <source>AngularJS apps don't have a main method. Instead modules declaratively specify how an application should be bootstrapped. There are several advantages to this approach:</source>
          <target state="translated">AngularJS 앱에는 기본 방법이 없습니다. 대신 모듈은 애플리케이션을 부트 스트랩하는 방법을 선언적으로 지정합니다. 이 방법에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="372bbe31b132ff0ef41b524bb7d70b9d4f2e094f" translate="yes" xml:space="preserve">
          <source>AngularJS comes pre-bundled with common directives which are useful for building any app. We also expect that you will create directives that are specific to your app. These extensions become a Domain Specific Language for building your application.</source>
          <target state="translated">AngularJS에는 모든 앱을 빌드하는 데 유용한 공통 지시문이 미리 번들로 제공됩니다. 또한 앱마다 고유 한 지시문을 만들 것으로 기대합니다. 이러한 확장은 응용 프로그램을 작성하기위한 도메인 별 언어가됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee0456d833564d457cddbf2538f4498b02003a6" translate="yes" xml:space="preserve">
          <source>AngularJS comes with &lt;a href=&quot;di&quot;&gt;dependency injection&lt;/a&gt; built-in, which makes testing components much easier, because you can pass in a component's dependencies and stub or mock them as you wish.</source>
          <target state="translated">AngularJS에는 &lt;a href=&quot;di&quot;&gt;의존성 주입 기능이&lt;/a&gt; 내장되어있어 구성 요소의 종속성을 전달하고 원하는대로 스텁하거나 조롱 할 수 있으므로 구성 요소 테스트를 훨씬 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f3285e4781ee5ee9e3f9586554d6b66101a2f5" translate="yes" xml:space="preserve">
          <source>AngularJS comes with a set of these directives built-in, like &lt;code&gt;ngBind&lt;/code&gt;, &lt;code&gt;ngModel&lt;/code&gt;, and &lt;code&gt;ngClass&lt;/code&gt;. Much like you create controllers and services, you can create your own directives for AngularJS to use. When AngularJS &lt;a href=&quot;bootstrap&quot;&gt;bootstraps&lt;/a&gt; your application, the &lt;a href=&quot;compiler&quot;&gt;HTML compiler&lt;/a&gt; traverses the DOM matching directives against the DOM elements.</source>
          <target state="translated">AngularJS에는 &lt;code&gt;ngBind&lt;/code&gt; , &lt;code&gt;ngModel&lt;/code&gt; 및 &lt;code&gt;ngClass&lt;/code&gt; 와 같은 이러한 지시문이 내장되어 있습니다. 컨트롤러와 서비스를 만드는 것과 마찬가지로 AngularJS에서 사용할 고유 한 지시문을 만들 수 있습니다. AngularJS가 애플리케이션을 &lt;a href=&quot;bootstrap&quot;&gt;부트 스트랩&lt;/a&gt; 할 때 &lt;a href=&quot;compiler&quot;&gt;HTML 컴파일러&lt;/a&gt; 는 DOM 요소에 대해 DOM 일치 지시문을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="d39b93d98b5677b7abce8f8d1889ee8550f46ef8" translate="yes" xml:space="preserve">
          <source>AngularJS does not use JavaScript's &lt;code&gt;eval()&lt;/code&gt; to evaluate expressions. Instead AngularJS's &lt;a href=&quot;../api/ng/service/%24parse&quot;&gt;$parse&lt;/a&gt; service processes these expressions.</source>
          <target state="translated">AngularJS는 JavaScript의 &lt;code&gt;eval()&lt;/code&gt; 을 사용하여 표현식을 평가 하지 않습니다 . 대신 AngularJS의 &lt;a href=&quot;../api/ng/service/%24parse&quot;&gt;$ parse&lt;/a&gt; 서비스는 이러한 표현식을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dd88c4c5702cceb2c3a9986c7e71401a0e0bd457" translate="yes" xml:space="preserve">
          <source>AngularJS enters the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; loop. The loop is made up of two smaller loops which process &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt; queue and the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$watch&lt;/a&gt; list. The &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; loop keeps iterating until the model stabilizes, which means that the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt; queue is empty and the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$watch&lt;/a&gt; list does not detect any changes.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ digest&lt;/a&gt; 루프에 들어갑니다 . 루프는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync&lt;/a&gt; 대기열과 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$ watch&lt;/a&gt; 목록 을 처리하는 두 개의 작은 루프로 구성됩니다 . &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ 소화&lt;/a&gt; 모델이 있다고하는 수단 안정 될 때까지 루프를 반복하는 유지 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync의&lt;/a&gt; 큐가 비어 있고 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$ 시계&lt;/a&gt; 목록에 어떤 변화를 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0850944e4a8643e355e181af91bde09626c238b5" translate="yes" xml:space="preserve">
          <source>AngularJS executes the &lt;code&gt;stimulusFn()&lt;/code&gt;, which typically modifies application state.</source>
          <target state="translated">AngularJS는 일반적으로 응용 프로그램 상태를 수정 하는 &lt;code&gt;stimulusFn()&lt;/code&gt; 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="7379667c8fedda0e1bbafd8c3ac9dcea1c105672" translate="yes" xml:space="preserve">
          <source>AngularJS exits the execution context, which in turn exits the &lt;code&gt;keydown&lt;/code&gt; event and with it the JavaScript execution context.</source>
          <target state="translated">AngularJS와 차례로 종료 실행 컨텍스트, 종료 &lt;code&gt;keydown&lt;/code&gt; 이벤트와 함께 자바 스크립트의 실행 컨텍스트를.</target>
        </trans-unit>
        <trans-unit id="bba6c16db1c0ce833cf612e719600df9bc77f3c2" translate="yes" xml:space="preserve">
          <source>AngularJS expression evaluating to URL. If the source is a string constant, make sure you wrap it in &lt;strong&gt;single&lt;/strong&gt; quotes, e.g. &lt;code&gt;src=&quot;'myPartialTemplate.html'&quot;&lt;/code&gt;.</source>
          <target state="translated">URL을 평가하는 AngularJS 표현식. 소스가 문자열 상수 인 경우 &lt;strong&gt;작은&lt;/strong&gt; 따옴표로 묶어야합니다 (예 : &lt;code&gt;src=&quot;'myPartialTemplate.html'&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b431f1a46f9d869b200da468e97d361380bd907" translate="yes" xml:space="preserve">
          <source>AngularJS expression that must evaluate to a &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; parsable into a &lt;code&gt;Number&lt;/code&gt;. Used as value for the &lt;code&gt;maxlength&lt;/code&gt;&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;validator&lt;/a&gt;.</source>
          <target state="translated">A를 평가해야 AngularJS와 표현 &lt;code&gt;Number&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 으로 분석 할 &lt;code&gt;Number&lt;/code&gt; . &lt;code&gt;maxlength&lt;/code&gt; &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;유효성 검사기의&lt;/a&gt; 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e509280278241209839b7c1ec5757ce68bdfb9b3" translate="yes" xml:space="preserve">
          <source>AngularJS expression that must evaluate to a &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; parsable into a &lt;code&gt;Number&lt;/code&gt;. Used as value for the &lt;code&gt;minlength&lt;/code&gt;&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;validator&lt;/a&gt;.</source>
          <target state="translated">A를 평가해야 AngularJS와 표현 &lt;code&gt;Number&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 으로 분석 할 &lt;code&gt;Number&lt;/code&gt; . &lt;code&gt;minlength&lt;/code&gt; &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;유효성 검사기의&lt;/a&gt; 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="88a4cc08f5767fe1829d07df54e5e6060eec74d4" translate="yes" xml:space="preserve">
          <source>AngularJS expression that must evaluate to a &lt;code&gt;RegExp&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt; parsable into a &lt;code&gt;RegExp&lt;/code&gt;, or a &lt;code&gt;RegExp&lt;/code&gt; literal. See above for more details.</source>
          <target state="translated">&lt;code&gt;RegExp&lt;/code&gt; 또는 &lt;code&gt;RegExp&lt;/code&gt; 로 구문 분석 가능한 &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;RegExp&lt;/code&gt; 리터럴 로 평가해야하는 AngularJS 표현식입니다 . 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97d4f64fec36f6812a573ef75120b96770cdad0c" translate="yes" xml:space="preserve">
          <source>AngularJS expression to be executed when input changes due to user interaction with the input element.</source>
          <target state="translated">입력 요소와의 사용자 상호 작용으로 인해 입력이 변경 될 때 실행되는 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="08da89807326e11b25bd5469155826eee0eb7644" translate="yes" xml:space="preserve">
          <source>AngularJS expression to be executed when selected option(s) changes due to user interaction with the select element.</source>
          <target state="translated">select 요소와의 사용자 상호 작용으로 인해 선택된 옵션이 변경 될 때 실행되는 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="2ef64a93a14456208c9b105e55c9d36b5bf65d39" translate="yes" xml:space="preserve">
          <source>AngularJS expression, whose value will be bound to the &lt;code&gt;value&lt;/code&gt; attribute and &lt;code&gt;value&lt;/code&gt; property of the element.</source>
          <target state="translated">AngularJS 표현식. 값이 요소 의 &lt;code&gt;value&lt;/code&gt; 속성 및 &lt;code&gt;value&lt;/code&gt; 특성에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d0313fcc5ce776c2589c8549f299e088d7b5bfb" translate="yes" xml:space="preserve">
          <source>AngularJS expression. If it evaluates to &lt;code&gt;true&lt;/code&gt;, it sets the &lt;code&gt;required&lt;/code&gt; attribute to the element and adds the &lt;code&gt;required&lt;/code&gt;&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;&lt;code&gt;validator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">AngularJS 표현식. &lt;code&gt;true&lt;/code&gt; 로 평가 되면 &lt;code&gt;required&lt;/code&gt; 속성을 요소에 설정 하고 &lt;code&gt;required&lt;/code&gt; &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24validators.html&quot;&gt; &lt;code&gt;validator&lt;/code&gt; &lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fc7f82d84685139363df50752ba4a48add9d5732" translate="yes" xml:space="preserve">
          <source>AngularJS expressions are JavaScript-like code snippets that are mainly placed in interpolation bindings such as &lt;code&gt;&amp;lt;span title=&quot;{{ attrBinding }}&quot;&amp;gt;{{ textBinding }}&amp;lt;/span&amp;gt;&lt;/code&gt;, but also used directly in directive attributes such as &lt;code&gt;ng-click=&quot;functionExpression()&quot;&lt;/code&gt;.</source>
          <target state="translated">AngularJS 표현식은 주로 &lt;code&gt;&amp;lt;span title=&quot;{{ attrBinding }}&quot;&amp;gt;{{ textBinding }}&amp;lt;/span&amp;gt;&lt;/code&gt; 과 같은 보간 바인딩에 배치 되지만 &lt;code&gt;ng-click=&quot;functionExpression()&quot;&lt;/code&gt; 와 같은 지시문 속성에 직접 사용되는 JavaScript와 유사한 코드 스 니펫입니다. click = &quot;functionExpression ()&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="f061af2fccf05b8fcd05482367cef5c7ff26b4bc" translate="yes" xml:space="preserve">
          <source>AngularJS expressions are like JavaScript expressions with the following differences:</source>
          <target state="translated">AngularJS 표현식은 다음과 같은 차이점이있는 JavaScript 표현식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09c3ce274e777d18b85eef65fd68287cb37a9819" translate="yes" xml:space="preserve">
          <source>AngularJS expressions do not have direct access to global variables like &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;location&lt;/code&gt;. This restriction is intentional. It prevents accidental access to the global state &amp;ndash; a common source of subtle bugs.</source>
          <target state="translated">AngularJS 표현식은 &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;document&lt;/code&gt; 또는 &lt;code&gt;location&lt;/code&gt; 와 같은 전역 변수에 직접 액세스 할 수 없습니다 . 이 제한은 의도적 인 것입니다. 미묘한 버그의 일반적인 소스 인 전역 상태에 대한 우발적 인 액세스를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e07171b2ee4be74089fb92963274de2dc91e580d" translate="yes" xml:space="preserve">
          <source>AngularJS frees you from the following pains:</source>
          <target state="translated">AngularJS는 다음과 같은 고통을 덜어줍니다.</target>
        </trans-unit>
        <trans-unit id="fdb9cdb2309b4f5036d4198e942b004700a1e259" translate="yes" xml:space="preserve">
          <source>AngularJS has some features that can conflict with certain restrictions that are applied when using &lt;a href=&quot;https://developer.mozilla.org/en/Security/CSP&quot;&gt;CSP (Content Security Policy)&lt;/a&gt; rules.</source>
          <target state="translated">AngularJS에는 &lt;a href=&quot;https://developer.mozilla.org/en/Security/CSP&quot;&gt;CSP (콘텐츠 보안 정책)&lt;/a&gt; 규칙을 사용할 때 적용되는 특정 제한 사항과 충돌 할 수있는 몇 가지 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c32413e579d205cc826666f39f4cffe4b82b826" translate="yes" xml:space="preserve">
          <source>AngularJS hooks are prefixed with &lt;code&gt;$&lt;/code&gt;, such as &lt;code&gt;$onInit&lt;/code&gt;. Angular hooks are prefixed with &lt;code&gt;ng&lt;/code&gt;, such as &lt;code&gt;ngOnInit&lt;/code&gt;.</source>
          <target state="translated">AngularJS와 후크로 시작되는 &lt;code&gt;$&lt;/code&gt; 같은 &lt;code&gt;$onInit&lt;/code&gt; . 각도 후크에는 &lt;code&gt;ngOnInit&lt;/code&gt; 와 같은 &lt;code&gt;ng&lt;/code&gt; 접두사가 붙 습니다 .</target>
        </trans-unit>
        <trans-unit id="8080861f70c5e3379f7f21148b3d91ee5e39f3d3" translate="yes" xml:space="preserve">
          <source>AngularJS hooks can be defined on the controller prototype or added to the controller inside its constructor. In Angular you can only define hooks on the prototype of the Component class.</source>
          <target state="translated">AngularJS 후크는 컨트롤러 프로토 타입에서 정의하거나 생성자 내의 컨트롤러에 추가 할 수 있습니다. Angular에서는 Component 클래스의 프로토 타입에 대한 후크 만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752e75fd10d996a8acb5cb76944e3500f3b826d7" translate="yes" xml:space="preserve">
          <source>AngularJS implements all of the basic HTML form controls (&lt;a href=&quot;../api/ng/directive/input&quot;&gt;input&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/select&quot;&gt;select&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/textarea&quot;&gt;textarea&lt;/a&gt;), which should be sufficient for most cases. However, if you need more flexibility, you can write your own form control as a directive.</source>
          <target state="translated">AngularJS는 모든 기본 HTML 양식 컨트롤 ( &lt;a href=&quot;../api/ng/directive/input&quot;&gt;input&lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/select&quot;&gt;select&lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/textarea&quot;&gt;textarea&lt;/a&gt; )을 구현하며 대부분의 경우 충분합니다. 그러나 융통성이 더 필요한 경우 자체 양식 컨트롤을 지시문으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc02d97cc07b688ab2870592f09f7fc31cc0e3f" translate="yes" xml:space="preserve">
          <source>AngularJS initializes automatically upon &lt;code&gt;DOMContentLoaded&lt;/code&gt; event or when the &lt;code&gt;angular.js&lt;/code&gt; script is evaluated if at that time &lt;code&gt;document.readyState&lt;/code&gt; is set to &lt;code&gt;'complete'&lt;/code&gt;. At this point AngularJS looks for the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ngApp&lt;/code&gt;&lt;/a&gt; directive which designates your application root. If the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ngApp&lt;/code&gt;&lt;/a&gt; directive is found then AngularJS will:</source>
          <target state="translated">AngularJS는 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 이벤트 또는 &lt;code&gt;angular.js&lt;/code&gt; 스크립트가 평가 될 때 &lt;code&gt;document.readyState&lt;/code&gt; 가 &lt;code&gt;'complete'&lt;/code&gt; 로 설정된 경우 자동으로 초기화됩니다 . 이 시점에서 AngularJS는 애플리케이션 루트를 지정 하는 &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ngApp&lt;/code&gt; &lt;/a&gt; 지시문을 찾습니다 . &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ngApp&lt;/code&gt; &lt;/a&gt; 지시어가 발견 되면 AngularJS는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4435ce23f59a011ed31e42f4b0b893d57d8d3ed1" translate="yes" xml:space="preserve">
          <source>AngularJS invokes certain functions (like service factories and controllers) via the injector. You need to annotate these functions so that the injector knows what services to inject into the function. There are three ways of annotating your code with service name information:</source>
          <target state="translated">AngularJS는 인젝터를 통해 특정 기능 (서비스 팩토리 및 컨트롤러와 같은)을 호출합니다. 인젝터가 어떤 서비스에 기능을 삽입할지 알 수 있도록 이러한 기능에 주석을 달아야합니다. 서비스 이름 정보로 코드에 주석을 달려면 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="13bc8c54b543141e4c682ca99d8268eedb15c59a" translate="yes" xml:space="preserve">
          <source>AngularJS is a structural framework for dynamic web apps. It lets you use HTML as your template language and lets you extend HTML's syntax to express your application's components clearly and succinctly. AngularJS's data binding and dependency injection eliminate much of the code you would otherwise have to write. And it all happens within the browser, making it an ideal partner with any server technology.</source>
          <target state="translated">AngularJS는 동적 웹 앱을위한 구조적 프레임 워크입니다. HTML을 템플릿 언어로 사용하고 HTML 구문을 확장하여 응용 프로그램의 구성 요소를 명확하고 간결하게 표현할 수 있습니다. AngularJS의 데이터 바인딩 및 종속성 주입은 다른 방법으로 작성해야 할 코드를 많이 제거합니다. 또한 모든 것이 브라우저 내에서 발생하므로 모든 서버 기술과 이상적인 파트너입니다.</target>
        </trans-unit>
        <trans-unit id="afa69d76d77331bc697c05156c2d935319818e67" translate="yes" xml:space="preserve">
          <source>AngularJS is built around the belief that declarative code is better than imperative when it comes to building UIs and wiring software components together, while imperative code is excellent for expressing business logic.</source>
          <target state="translated">AngularJS는 UI를 구축하고 소프트웨어 구성 요소를 함께 연결할 때 선언적 코드가 명령형보다 낫다는 신념을 바탕으로 구축되었으며, 명령형 코드는 비즈니스 로직을 표현하는 데 탁월합니다.</target>
        </trans-unit>
        <trans-unit id="c3edf37d74a9cf2efaa5aedcb37dbfd1f8ca4b39" translate="yes" xml:space="preserve">
          <source>AngularJS is different. The AngularJS compiler consumes the DOM, not string templates. The result is a linking function, which when combined with a scope model results in a live view. The view and scope model bindings are transparent. The developer does not need to make any special calls to update the view. And because &lt;code&gt;innerHTML&lt;/code&gt; is not used, you won't accidentally clobber user input. Furthermore, AngularJS directives can contain not just text bindings, but behavioral constructs as well.</source>
          <target state="translated">AngularJS는 다릅니다. AngularJS 컴파일러는 문자열 템플릿이 아닌 DOM을 사용합니다. 결과는 연결 기능으로, 스코프 모델과 결합하면 라이브 뷰가됩니다. 뷰 및 범위 모델 바인딩은 투명합니다. 개발자는보기를 업데이트하기 위해 특별한 호출을 할 필요가 없습니다. 그리고 &lt;code&gt;innerHTML&lt;/code&gt; 이 사용되지 않기 때문에 실수로 사용자 입력을 방해하지 않습니다. 또한 AngularJS 지시문에는 텍스트 바인딩뿐만 아니라 동작 구성도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9efc5db18aabed4da31047d240fa2301008411" translate="yes" xml:space="preserve">
          <source>AngularJS is not a single piece in the overall puzzle of building the client-side of a web application. It handles all of the DOM and AJAX glue code you once wrote by hand and puts it in a well-defined structure. This makes AngularJS opinionated about how a CRUD (Create, Read, Update, Delete) application should be built. But while it is opinionated, it also tries to make sure that its opinion is just a starting point you can easily change. AngularJS comes with the following out-of-the-box:</source>
          <target state="translated">AngularJS는 웹 애플리케이션의 클라이언트 측을 구축하는 전체 퍼즐에서 하나의 조각이 아닙니다. 한 번 손으로 작성한 DOM 및 AJAX 글루 코드를 모두 처리하여 잘 정의 된 구조로 만듭니다. 이를 통해 AngularJS는 CRUD (Create, Read, Update, Delete) 응용 프로그램을 작성하는 방법에 대해 의견을 제시합니다. 그러나 의견이 있지만 의견이 쉽게 바꿀 수있는 출발점이되도록 노력합니다. AngularJS는 다음과 같이 기본 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9ef3b6f1388704d540c31540844164208295dbc6" translate="yes" xml:space="preserve">
          <source>AngularJS is what HTML would have been, had it been designed for applications. HTML is a great declarative language for static documents. It does not contain much in the way of creating applications, and as a result building web applications is an exercise in &lt;em&gt;what do I have to do to trick the browser into doing what I want?&lt;/em&gt;</source>
          <target state="translated">AngularJS는 HTML이 응용 프로그램 용으로 설계된 HTML입니다. HTML은 정적 문서를위한 훌륭한 선언 언어입니다. 여기에는 응용 프로그램을 만드는 방법이 많이 포함되어 있지 않으므로 결과적으로 웹 응용 프로그램 &lt;em&gt;을 작성하는 것은 브라우저가 원하는 작업을 수행하도록 속이기 위해 무엇을해야합니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="544f9941cafe249e5d00dbb4906eca8c99f8d603" translate="yes" xml:space="preserve">
          <source>AngularJS is written with testability in mind, but it still requires that you do the right thing. We tried to make the right thing easy, but if you ignore these guidelines you may end up with an untestable application.</source>
          <target state="translated">AngularJS는 테스트 가능성을 염두에두고 작성되었지만 여전히 올바른 작업을 수행해야합니다. 우리는 옳은 일을 쉽게 만들려고 노력했지만이 지침을 무시하면 테스트 할 수없는 응용 프로그램이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7383699805e691e0daff8aa72c18b8f3565bd40d" translate="yes" xml:space="preserve">
          <source>AngularJS mailing list</source>
          <target state="translated">AngularJS 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="478efa9ac782264ed3b06bb9dbddc3848b85e795" translate="yes" xml:space="preserve">
          <source>AngularJS modifies the normal JavaScript flow by providing its own event processing loop. This splits the JavaScript into classical and AngularJS execution context. Only operations which are applied in the AngularJS execution context will benefit from AngularJS data-binding, exception handling, property watching, etc... You can also use $apply() to enter the AngularJS execution context from JavaScript. Keep in mind that in most places (controllers, services) $apply has already been called for you by the directive which is handling the event. An explicit call to $apply is needed only when implementing custom event callbacks, or when working with third-party library callbacks.</source>
          <target state="translated">AngularJS는 자체 이벤트 처리 루프를 제공하여 일반적인 JavaScript 흐름을 수정합니다. JavaScript를 클래식 및 AngularJS 실행 컨텍스트로 분할합니다. AngularJS 실행 컨텍스트에 적용되는 작업 만 AngularJS 데이터 바인딩, 예외 처리, 속성 감시 등의 이점을 얻을 수 있습니다. $ apply ()를 사용하여 JavaScript에서 AngularJS 실행 컨텍스트를 입력 할 수도 있습니다. 대부분의 장소 (컨트롤러, 서비스)에서 $ apply는 이벤트를 처리하는 지시문에 의해 이미 호출되었습니다. $ apply에 대한 명시적인 호출은 사용자 정의 이벤트 콜백을 구현하거나 타사 라이브러리 콜백을 사용하는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="716ba022bcc260438c543a5bdaff3cdd08b11838" translate="yes" xml:space="preserve">
          <source>AngularJS offers several useful services (like &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt;), but for most applications you'll also want to &lt;a href=&quot;services#creating-services.html&quot;&gt;create your own&lt;/a&gt;.</source>
          <target state="translated">AngularJS는 여러 가지 유용한 서비스 (예 &lt;a href=&quot;../api/ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; )를 제공하지만 대부분의 응용 프로그램에서는 &lt;a href=&quot;services#creating-services.html&quot;&gt;고유 한 서비스&lt;/a&gt; 를 만들고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e3aaca8b19ef9d3c826824478ea3168cc956a6ed" translate="yes" xml:space="preserve">
          <source>AngularJS on Mobile Guide</source>
          <target state="translated">모바일 가이드의 AngularJS</target>
        </trans-unit>
        <trans-unit id="1c673989115ebb8289f93a363391b8b8d9bb8a78" translate="yes" xml:space="preserve">
          <source>AngularJS on YouTube</source>
          <target state="translated">YouTube의 AngularJS</target>
        </trans-unit>
        <trans-unit id="8ffafd56c64e9c99454bda8b427b893a982e760f" translate="yes" xml:space="preserve">
          <source>AngularJS provides animation hooks for common directives such as &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;, and &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt;, as well as custom directives via the &lt;code&gt;$animate&lt;/code&gt; service. These animation hooks are set in place to trigger animations during the life cycle of various directives and when triggered, will attempt to perform a CSS Transition, CSS Keyframe Animation or a JavaScript callback Animation (depending on whether an animation is placed on the given directive). Animations can be placed using vanilla CSS by following the naming conventions set in place by AngularJS or with JavaScript code, defined as a factory.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/ngswitch&quot;&gt;ngSwitch&lt;/a&gt; 및 &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt; 와 같은 공통 지시문 뿐만 아니라 &lt;code&gt;$animate&lt;/code&gt; 서비스 를 통한 사용자 지정 지시문에 대한 애니메이션 후크를 제공합니다. 이 애니메이션 후크는 다양한 지시문의 수명주기 동안 애니메이션을 트리거하도록 설정되며, 트리거 될 때 CSS 전환, CSS 키 프레임 애니메이션 또는 JavaScript 콜백 애니메이션 (애니메이션이 지정된 지시문에 배치되는지에 따라 다름)을 수행하려고 시도합니다. . 애니메이션은 AngularJS 또는 팩토리로 정의 된 JavaScript 코드로 설정된 이름 지정 규칙을 따라 바닐라 CSS를 사용하여 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3917cb70aac3e073835c7ae97b53a67291ace6ea" translate="yes" xml:space="preserve">
          <source>AngularJS provides basic implementation for most common HTML5 &lt;a href=&quot;../api/ng/directive/input&quot;&gt;input&lt;/a&gt; types: (&lt;a href=&quot;../api/ng/input/input%5Btext%5D&quot;&gt;text&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Bnumber%5D&quot;&gt;number&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Burl%5D&quot;&gt;url&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Bemail%5D&quot;&gt;email&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Bdate%5D&quot;&gt;date&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Bradio%5D&quot;&gt;radio&lt;/a&gt;, &lt;a href=&quot;../api/ng/input/input%5Bcheckbox%5D&quot;&gt;checkbox&lt;/a&gt;), as well as some directives for validation (&lt;code&gt;required&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;minlength&lt;/code&gt;, &lt;code&gt;maxlength&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;).</source>
          <target state="translated">AngularJS는 가장 일반적인 HTML5 &lt;a href=&quot;../api/ng/directive/input&quot;&gt;입력&lt;/a&gt; 유형 (( &lt;a href=&quot;../api/ng/input/input%5Btext%5D&quot;&gt;text&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Bnumber%5D&quot;&gt;number&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Burl%5D&quot;&gt;url&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Bemail%5D&quot;&gt;email&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Bdate%5D&quot;&gt;date&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Bradio%5D&quot;&gt;radio&lt;/a&gt; , &lt;a href=&quot;../api/ng/input/input%5Bcheckbox%5D&quot;&gt;checkbox&lt;/a&gt; )에 대한 기본 구현 및 유효성 검사를위한 일부 지시문 ( &lt;code&gt;required&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; , &lt;code&gt;minlength&lt;/code&gt; , &lt;code&gt;maxlength&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56f632ed3f689df64ece7da7819dff3bf22b0ccc" translate="yes" xml:space="preserve">
          <source>AngularJS provides specific directives for many events, such as &lt;a href=&quot;ngclick&quot;&gt;&lt;code&gt;ngClick&lt;/code&gt;&lt;/a&gt;, so in most cases it is not necessary to use &lt;code&gt;ngOn&lt;/code&gt;. However, AngularJS does not support all events (e.g. the &lt;code&gt;drop&lt;/code&gt; event in the example above), and new events might be introduced in later DOM standards.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;ngclick&quot;&gt; &lt;code&gt;ngClick&lt;/code&gt; &lt;/a&gt; 과 같은 많은 이벤트에 대한 특정 지시문을 제공 하므로 대부분의 경우 &lt;code&gt;ngOn&lt;/code&gt; 을 사용할 필요는 없습니다 . 그러나 AngularJS는 모든 이벤트 (예 : 위의 예에서 &lt;code&gt;drop&lt;/code&gt; 이벤트)를 지원하지 않으며 , 새로운 이벤트가 이후 DOM 표준에 도입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2758214e55fedd29b874bf821efa5fd7b1f6d5" translate="yes" xml:space="preserve">
          <source>AngularJS provides the following default transformations:</source>
          <target state="translated">AngularJS는 다음과 같은 기본 변환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05b59926978c6bbf9d44f2a94498561c9bef96bc" translate="yes" xml:space="preserve">
          <source>AngularJS separates number and datetime format rule sets into different files, each file for a particular locale. You can find a list of currently supported locales &lt;a href=&quot;https://github.com/angular/angular.js/tree/master/src/ngLocale&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">AngularJS는 숫자 및 날짜 / 시간 형식 규칙 세트를 특정 로케일에 대한 각 파일로 다른 파일로 분리합니다. 현재 지원되는 로케일 목록은 &lt;a href=&quot;https://github.com/angular/angular.js/tree/master/src/ngLocale&quot;&gt;여기에서&lt;/a&gt; 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbbd8f92b2e2e904ae46011fc03753d219bc5d3" translate="yes" xml:space="preserve">
          <source>AngularJS services are substitutable objects that are wired together using &lt;a href=&quot;di&quot;&gt;dependency injection (DI)&lt;/a&gt;. You can use services to organize and share code across your app.</source>
          <target state="translated">AngularJS 서비스는 &lt;a href=&quot;di&quot;&gt;의존성 주입 (DI)을&lt;/a&gt; 사용하여 함께 연결된 대체 가능한 객체입니다 . 서비스를 사용하여 앱에서 코드를 구성하고 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d69f80a7b3cac2616bf246adcaf4efc8679fe0a9" translate="yes" xml:space="preserve">
          <source>AngularJS services are:</source>
          <target state="translated">AngularJS 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7422e70c60bc15b4ce5aee88f1fa3d09ecfa4487" translate="yes" xml:space="preserve">
          <source>AngularJS simplifies application development by presenting a higher level of abstraction to the developer. Like any abstraction, it comes at a cost of flexibility. In other words, not every app is a good fit for AngularJS. AngularJS was built with the CRUD application in mind. Luckily CRUD applications represent the majority of web applications. To understand what AngularJS is good at, though, it helps to understand when an app is not a good fit for AngularJS.</source>
          <target state="translated">AngularJS는 개발자에게 더 높은 수준의 추상화를 제공하여 애플리케이션 개발을 단순화합니다. 다른 추상화와 마찬가지로 유연성이 떨어집니다. 즉, 모든 앱이 AngularJS에 적합한 것은 아닙니다. AngularJS는 CRUD 응용 프로그램을 염두에두고 작성되었습니다. 다행히 CRUD 응용 프로그램은 대부분의 웹 응용 프로그램을 나타냅니다. AngularJS의 장점을 이해하려면 앱이 AngularJS에 적합하지 않은 시점을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3ac4e24f01511fd93bb16d06effbc2d6379f34" translate="yes" xml:space="preserve">
          <source>AngularJS strongly relies on contextual escaping for the security of bindings: disabling or modifying this might cause cross site scripting (XSS) vulnerabilities. For libraries owners, changes to this service will also influence users, so be extra careful and document your changes.</source>
          <target state="translated">AngularJS는 바인딩 보안을 위해 상황에 맞는 이스케이프를 사용합니다.이를 비활성화하거나 수정하면 XSS (Cross Site Scripting) 취약점이 발생할 수 있습니다. 도서관 소유자의 경우이 서비스의 변경 사항도 사용자에게 영향을 미치므로주의해서 변경 사항을 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="4431411ecab45405bde7dd419d71acb67b3391ca" translate="yes" xml:space="preserve">
          <source>AngularJS supports i18n/l10n for &lt;a href=&quot;../api/ng/filter/date&quot;&gt;date&lt;/a&gt;, &lt;a href=&quot;../api/ng/filter/number&quot;&gt;number&lt;/a&gt; and &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;currency&lt;/a&gt; filters.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;../api/ng/filter/date&quot;&gt;날짜&lt;/a&gt; , &lt;a href=&quot;../api/ng/filter/number&quot;&gt;숫자&lt;/a&gt; 및 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;통화&lt;/a&gt; 필터에 i18n / l10n을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="3a4ebceac2caf5ebdf9c2c4c4dc59c26f35d27a5" translate="yes" xml:space="preserve">
          <source>AngularJS takes another approach. It attempts to minimize the impedance mismatch between document centric HTML and what an application needs by creating new HTML constructs. AngularJS teaches the browser new syntax through a construct we call &lt;em&gt;directives&lt;/em&gt;. Examples include:</source>
          <target state="translated">AngularJS는 다른 접근 방식을 취합니다. 새로운 HTML 구문을 만들어 문서 중심 HTML과 응용 프로그램에 필요한 것 사이의 임피던스 불일치를 최소화하려고 시도합니다. AngularJS는 &lt;em&gt;지시어&lt;/em&gt; 를 호출하는 구문을 통해 브라우저에 새로운 구문을 알려 줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="769e07375c5ab3bf0b0051ac78640da73f4c7868" translate="yes" xml:space="preserve">
          <source>AngularJS templates work differently. First the template (which is the uncompiled HTML along with any additional markup or directives) is compiled on the browser. The compilation step produces a live view. Any changes to the view are immediately reflected in the model, and any changes in the model are propagated to the view. The model is the single-source-of-truth for the application state, greatly simplifying the programming model for the developer. You can think of the view as simply an instant projection of your model.</source>
          <target state="translated">AngularJS 템플릿은 다르게 작동합니다. 먼저 템플릿 (추가 마크 업 또는 지시문과 함께 컴파일되지 않은 HTML)이 브라우저에서 컴파일됩니다. 컴파일 단계는 라이브 뷰를 생성합니다. 뷰에 대한 모든 변경 사항이 모델에 즉시 반영되고 모델의 모든 변경 사항이 뷰에 전파됩니다. 이 모델은 응용 프로그램 상태의 단일 소스 소스이므로 개발자의 프로그래밍 모델을 크게 단순화합니다. 뷰를 단순히 모델의 즉각적인 투영으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc125702fe4d5d98bdb594a33013e8322f09d18" translate="yes" xml:space="preserve">
          <source>AngularJS will detect if it has been loaded into the browser more than once and only allow the first loaded script to be bootstrapped and will report a warning to the browser console for each of the subsequent scripts. This prevents strange results in applications, where otherwise multiple instances of AngularJS try to work on the DOM.</source>
          <target state="translated">AngularJS는 브라우저에 두 번 이상로드되었는지 감지하고 첫 번째로로드 된 스크립트 만 부트 스트랩 할 수 있도록 허용하고 후속 스크립트 각각에 대해 브라우저 콘솔에 경고를보고합니다. 이렇게하면 AngularJS의 여러 인스턴스가 DOM에서 작동하는 응용 프로그램에서 이상한 결과가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="015dbed2a049b3782ded1815109d25f8af8a31a3" translate="yes" xml:space="preserve">
          <source>AngularJS will strip the prefix, before processing the JSON.</source>
          <target state="translated">AngularJS는 JSON을 처리하기 전에 접두사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3086e18c373e1b050a89b62431f812b993b265f5" translate="yes" xml:space="preserve">
          <source>AngularJS's &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;currency filter&lt;/a&gt; allows you to use the default currency symbol from the &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt;locale service&lt;/a&gt;, or you can provide the filter with a custom currency symbol.</source>
          <target state="translated">AngularJS의 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;통화 필터&lt;/a&gt; 를 사용하면 &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt;로케일 서비스&lt;/a&gt; 의 기본 통화 기호를 사용 하거나 필터에 사용자 정의 통화 기호를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08db1303b33928851568ddd60cd23f21541a8af" translate="yes" xml:space="preserve">
          <source>AngularJS's &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;HTML compiler&lt;/a&gt; allows the developer to teach the browser new HTML syntax. The compiler allows you to attach behavior to any HTML element or attribute and even create new HTML elements or attributes with custom behavior. AngularJS calls these behavior extensions &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">AngularJS의 &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;HTML 컴파일러를&lt;/a&gt; 통해 개발자는 브라우저에 새로운 HTML 구문을 가르 칠 수 있습니다. 컴파일러를 사용하면 HTML 요소 또는 속성에 동작을 추가하고 사용자 지정 동작으로 새로운 HTML 요소 또는 속성을 만들 수도 있습니다. AngularJS는 이러한 행동 확장 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시어를&lt;/a&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="f50b6286f749aa08025813527659c6fc74af40dd" translate="yes" xml:space="preserve">
          <source>AngularJS's jqLite</source>
          <target state="translated">AngularJS의 jqLite</target>
        </trans-unit>
        <trans-unit id="e609b570c930b204946ccb899b6f09e78d1083ec" translate="yes" xml:space="preserve">
          <source>AngularJS's sweet spot</source>
          <target state="translated">AngularJS의 스위트 스팟</target>
        </trans-unit>
        <trans-unit id="18bb073a29d517b8a3a42b434c49bfbd5a2b2a13" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setInterval&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is executed every &lt;code&gt;delay&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;window.setInterval&lt;/code&gt; 에 대한 AngularJS의 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 기능은 모든 실행 &lt;code&gt;delay&lt;/code&gt; 밀리 초.</target>
        </trans-unit>
        <trans-unit id="f3ddbcf960e64f545ec9cb831b76819fde7f2373" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setTimeout&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is wrapped into a try/catch block and delegates any exceptions to &lt;a href=&quot;%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;window.setTimeout&lt;/code&gt; 의 AngularJS 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 함수는 try / catch 블록 위임에 대한 예외에 싸여 &lt;a href=&quot;%24exceptionhandler&quot;&gt;$ exceptionHandler의&lt;/a&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="e28ca8ee33fee303615de7b48a3ebaeeb4dda2c4" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setTimeout&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is wrapped into a try/catch block and delegates any exceptions to &lt;a href=&quot;service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;window.setTimeout&lt;/code&gt; 의 AngularJS 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 함수는 try / catch 블록 위임에 대한 예외에 싸여 &lt;a href=&quot;service/%24exceptionhandler&quot;&gt;$ exceptionHandler의&lt;/a&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="edf5ebe5a67b68ae5fca138a2a5dfbc8054af2c8" translate="yes" xml:space="preserve">
          <source>AngularStrap for Bootstrap 3</source>
          <target state="translated">부트 스트랩 3 용 AngularStrap</target>
        </trans-unit>
        <trans-unit id="aba9a35ec9eedc8eb79e6d0f03cd4eef93153ee8" translate="yes" xml:space="preserve">
          <source>Animating between value changes</source>
          <target state="translated">가치 변화 사이의 애니메이션</target>
        </trans-unit>
        <trans-unit id="62afd21e88769f01ba1c9330803baad57564d6e9" translate="yes" xml:space="preserve">
          <source>Animation</source>
          <target state="translated">Animation</target>
        </trans-unit>
        <trans-unit id="7f5f07bd5a091d92689e50573c0da813d4d14d72" translate="yes" xml:space="preserve">
          <source>Animation Anchoring (via ng-animate-ref)</source>
          <target state="translated">애니메이션 앵커링 (ng-animate-ref를 통해)</target>
        </trans-unit>
        <trans-unit id="c77dcdedc0f40e8dac08a08c8bef7255abb90e75" translate="yes" xml:space="preserve">
          <source>Animations</source>
          <target state="translated">Animations</target>
        </trans-unit>
        <trans-unit id="4fe25ebece61799897136d3106b7e79fe6ccfbc5" translate="yes" xml:space="preserve">
          <source>Animations are not available unless you include the &lt;a href=&quot;../api/nganimate&quot;&gt;&lt;code&gt;ngAnimate&lt;/code&gt; module&lt;/a&gt; as a dependency of your application.</source>
          <target state="translated">&lt;a href=&quot;../api/nganimate&quot;&gt; &lt;code&gt;ngAnimate&lt;/code&gt; 모듈&lt;/a&gt; 을 응용 프로그램의 종속성으로 포함하지 않으면 애니메이션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c0594ee2973edc0be64f9dfa8e39acbf86b8a72a" translate="yes" xml:space="preserve">
          <source>Animations in &lt;code&gt;ngShow&lt;/code&gt;/&lt;code&gt;ngHide&lt;/code&gt; work with the show and hide events that are triggered when the directive expression is true and false. This system works like the animation system present with &lt;code&gt;ngClass&lt;/code&gt; except that you must also include the &lt;code&gt;!important&lt;/code&gt; flag to override the display property so that the elements are not actually hidden during the animation.</source>
          <target state="translated">&lt;code&gt;ngShow&lt;/code&gt; / &lt;code&gt;ngHide&lt;/code&gt; 의 애니메이션 은 지시문 표현식이 true 및 false 일 때 트리거되는 show 및 hide 이벤트와 함께 작동합니다. 이 시스템은 애니메이션 중에 요소가 실제로 숨겨지지 않도록 표시 속성을 재정의하기 위해 &lt;code&gt;!important&lt;/code&gt; 플래그 도 포함해야한다는 점을 제외하고 &lt;code&gt;ngClass&lt;/code&gt; 에 있는 애니메이션 시스템과 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="0b2a60876cb65fb0147911bedc0ad0bf15f7d3ff" translate="yes" xml:space="preserve">
          <source>Animations in AngularJS are completely based on CSS classes. As long as you have a CSS class attached to an HTML element within your application, you can apply animations to it. Let's say for example that we have an HTML template with a repeater like so:</source>
          <target state="translated">AngularJS의 애니메이션은 CSS 클래스를 기반으로합니다. 응용 프로그램 내 HTML 요소에 CSS 클래스가 첨부되어 있으면 애니메이션을 적용 할 수 있습니다. 예를 들어 리피터가있는 HTML 템플릿이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="fff49af586e2c4e9b3f2dd501fcc0aaac06fb0d6" translate="yes" xml:space="preserve">
          <source>Animations in ngForm are triggered when any of the associated CSS classes are added and removed. These classes are: &lt;code&gt;.ng-pristine&lt;/code&gt;, &lt;code&gt;.ng-dirty&lt;/code&gt;, &lt;code&gt;.ng-invalid&lt;/code&gt; and &lt;code&gt;.ng-valid&lt;/code&gt; as well as any other validations that are performed within the form. Animations in ngForm are similar to how they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well as JS animations.</source>
          <target state="translated">ngForm의 애니메이션은 연결된 CSS 클래스가 추가 및 제거 될 때 트리거됩니다. 이러한 클래스는 &lt;code&gt;.ng-pristine&lt;/code&gt; , &lt;code&gt;.ng-dirty&lt;/code&gt; , &lt;code&gt;.ng-invalid&lt;/code&gt; 및 &lt;code&gt;.ng-valid&lt;/code&gt; 및 양식 내에서 수행되는 다른 유효성 검사입니다. ngForm의 애니메이션은 ngClass에서 작동하는 방식과 유사하며 CSS 전환, 키 프레임 및 JS 애니메이션을 사용하여 애니메이션을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b5c3728edc0e75f5c55a0c0056f00846acd15f" translate="yes" xml:space="preserve">
          <source>Animations on app bootstrap / page load</source>
          <target state="translated">앱 부트 스트랩 / 페이지로드의 애니메이션</target>
        </trans-unit>
        <trans-unit id="2177639f84412abd63d8ce1ffb0f9712bb859c76" translate="yes" xml:space="preserve">
          <source>Animations within custom directives can also be established by injecting &lt;code&gt;$animate&lt;/code&gt; directly into your directive and making calls to it when needed.</source>
          <target state="translated">사용자 지정 지시문 내의 애니메이션은 지시문에 &lt;code&gt;$animate&lt;/code&gt; 직접 주입 하고 필요할 때 호출하여 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29559d5d09175ad58fe92108a5edad256c28781a" translate="yes" xml:space="preserve">
          <source>Animations within models are triggered when any of the associated CSS classes are added and removed on the input element which is attached to the model. These classes include: &lt;code&gt;.ng-pristine&lt;/code&gt;, &lt;code&gt;.ng-dirty&lt;/code&gt;, &lt;code&gt;.ng-invalid&lt;/code&gt; and &lt;code&gt;.ng-valid&lt;/code&gt; as well as any other validations that are performed on the model itself. The animations that are triggered within ngModel are similar to how they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well as JS animations.</source>
          <target state="translated">모델 내의 애니메이션은 연결된 CSS 클래스가 모델에 연결된 입력 요소에서 추가 및 제거 될 때 트리거됩니다. 이러한 클래스에는 &lt;code&gt;.ng-pristine&lt;/code&gt; , &lt;code&gt;.ng-dirty&lt;/code&gt; , &lt;code&gt;.ng-invalid&lt;/code&gt; 및 &lt;code&gt;.ng-valid&lt;/code&gt; 및 모델 자체에서 수행되는 다른 유효성 검사가 포함됩니다. ngModel 내에서 트리거되는 애니메이션은 ngClass에서 작동하는 방식과 유사하며 CSS 전환, 키 프레임 및 JS 애니메이션을 사용하여 애니메이션을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1859b1a59db69babc41c14f59a24c34e903944a3" translate="yes" xml:space="preserve">
          <source>Annotated constructor function.</source>
          <target state="translated">주석 생성자 함수.</target>
        </trans-unit>
        <trans-unit id="f2c8d59d42e7c3db1d26f04eb9b0478f66b9b7d5" translate="yes" xml:space="preserve">
          <source>Another scenario is adding a directive programmatically to a compiled element and then executing compile again. See the following &lt;strong&gt;faulty example&lt;/strong&gt;:</source>
          <target state="translated">또 다른 시나리오는 프로그래밍 방식으로 컴파일 된 요소에 지시문을 추가 한 다음 컴파일을 다시 실행하는 것입니다. 다음을 참조하십시오&lt;strong&gt; 잘못된 예를&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="969a0ecaa65eb289d9a2e9d6090f5991d37b5286" translate="yes" xml:space="preserve">
          <source>Another solution is to use a &lt;code&gt;track by&lt;/code&gt; clause, because then &lt;code&gt;ngOptions&lt;/code&gt; will track the identity of the item not by reference, but by the result of the &lt;code&gt;track by&lt;/code&gt; expression. For example, if your collection items have an id property, you would &lt;code&gt;track by item.id&lt;/code&gt;.</source>
          <target state="translated">또 다른 해결책은 사용하는 것입니다 &lt;code&gt;track by&lt;/code&gt; 한 후하기 때문에, 절 &lt;code&gt;ngOptions&lt;/code&gt; 이 참조가 아닌 항목의 신원을 추적하지만, 결과에 의해 &lt;code&gt;track by&lt;/code&gt; 식입니다. 예를 들어 컬렉션 항목에 id 속성이 있으면 &lt;code&gt;track by item.id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ba7d28b3ce7cc7d01f098476d04b91469e1cbe" translate="yes" xml:space="preserve">
          <source>Another use-case for &lt;code&gt;ngOn&lt;/code&gt; is listening to &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events&quot;&gt;custom events&lt;/a&gt; fired by &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;custom elements&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ngOn&lt;/code&gt; 의 또 다른 사용 사례 는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;커스텀 요소에&lt;/a&gt; 의해 발생 된 커스텀 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events&quot;&gt;이벤트를&lt;/a&gt; 듣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c3bdf53bf457c9fc3e92bc2d910f483e037f083e" translate="yes" xml:space="preserve">
          <source>Any JavaScript object (including arrays and primitive types) to filter.</source>
          <target state="translated">필터링 할 모든 JavaScript 객체 (배열 및 기본 유형 포함)</target>
        </trans-unit>
        <trans-unit id="de4518bc294ed54cea1f8963368f0e3c1241d4ef" translate="yes" xml:space="preserve">
          <source>Any exception emitted from the &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; will be passed onto the &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;리스너&lt;/a&gt; 에서 생성 된 모든 예외 는&lt;a href=&quot;../service/%24exceptionhandler&quot;&gt; $ exceptionHandler&lt;/a&gt; 서비스 .</target>
        </trans-unit>
        <trans-unit id="eca8010205016887bae956d6ae88be83c9bd4978" translate="yes" xml:space="preserve">
          <source>Any exceptions from the execution of the expression are forwarded to the &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">표현식 실행의 모든 ​​예외는 &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$ exceptionHandler&lt;/a&gt; 로 전달됩니다. 서비스 .</target>
        </trans-unit>
        <trans-unit id="136f3a6017ec892c22b97b38e6ce1b5592c356e0" translate="yes" xml:space="preserve">
          <source>Any external event on a directive/component will not trigger a digest while the hosting scope is suspended - even if the event handler calls &lt;code&gt;$apply()&lt;/code&gt; or &lt;code&gt;$rootScope.$digest()&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러가 &lt;code&gt;$apply()&lt;/code&gt; 또는 &lt;code&gt;$rootScope.$digest()&lt;/code&gt; 호출하더라도, 지시문 / 구성 요소의 외부 이벤트는 호스팅 범위가 일시 중단 된 동안 다이제스트를 트리거하지 않습니다 . .</target>
        </trans-unit>
        <trans-unit id="6e3b668fd7f49731bcb3c1e067c00ebcd8e78ada" translate="yes" xml:space="preserve">
          <source>Any other characters in the &lt;code&gt;format&lt;/code&gt; string will be output as-is.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 다른 모든 문자 문자열의 는 그대로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="422ef3807aa704fa02f9a1d220d6afe5c46512c0" translate="yes" xml:space="preserve">
          <source>Any pending &lt;code&gt;ngModelOptions&lt;/code&gt; changes will take place immediately when an enclosing form is submitted. Note that &lt;code&gt;ngClick&lt;/code&gt; events will occur before the model is updated. Use &lt;code&gt;ngSubmit&lt;/code&gt; to have access to the updated model.</source>
          <target state="translated">보류중인 &lt;code&gt;ngModelOptions&lt;/code&gt; 변경 사항은 첨부 양식을 제출하면 즉시 이루어집니다. 참고 &lt;code&gt;ngClick&lt;/code&gt; 의 모델이 업데이트되기 전에 이벤트가 발생합니다. &lt;code&gt;ngSubmit&lt;/code&gt; 사용 을 하여 업데이트 된 모델에 액세스 .</target>
        </trans-unit>
        <trans-unit id="185b074a10fc46555a5d70fddc56be15b7205ef5" translate="yes" xml:space="preserve">
          <source>Any pending changes will take place immediately when an enclosing form is submitted via the &lt;code&gt;submit&lt;/code&gt; event. Note that &lt;code&gt;ngClick&lt;/code&gt; events will occur before the model is updated. Use &lt;code&gt;ngSubmit&lt;/code&gt; to have access to the updated model.</source>
          <target state="translated">&lt;code&gt;submit&lt;/code&gt; 이벤트 를 통해 엔 클로징 양식을 제출하면 보류중인 변경 사항이 즉시 발생합니다 . 참고 &lt;code&gt;ngClick&lt;/code&gt; 의 모델이 업데이트되기 전에 이벤트가 발생합니다. &lt;code&gt;ngSubmit&lt;/code&gt; 을 사용 하여 업데이트 된 모델에 액세스 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f782e9cb5bbdcbf217e9814a968f5294ded104d" translate="yes" xml:space="preserve">
          <source>Any time your application needs to react to a change in the current URL or if you want to change the current URL in the browser.</source>
          <target state="translated">응용 프로그램이 현재 URL의 변경에 반응하거나 브라우저에서 현재 URL을 변경하려는 경우 언제든지.</target>
        </trans-unit>
        <trans-unit id="b848ee45c3ed822427c3aa6d8e5ae09ef5cd1527" translate="yes" xml:space="preserve">
          <source>Any uncaught exception in AngularJS expressions is delegated to this service. The default implementation simply delegates to &lt;code&gt;$log.error&lt;/code&gt; which logs it into the browser console.</source>
          <target state="translated">AngularJS 표현식에서 포착되지 않은 예외는이 서비스에 위임됩니다. 기본 구현은 단순히 &lt;code&gt;$log.error&lt;/code&gt; 위임합니다. 은 브라우저 콘솔에 로그인하는 .</target>
        </trans-unit>
        <trans-unit id="66d8a5005f5b7a5ddb9208ba220fe6b30ba308b2" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to a[href] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 a [href]에 할당 될 URL은 먼저 정규화되어 절대 URL로 바뀝니다. 그 후, URL은 &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; 정규식 과 일치 합니다. 일치하는 것이 있으면 원래 URL이 돔에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 문자열이 붙고 DOM에만 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="d3d6dd2884ca2cb0baa2409af0223b0a1c7c139d" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to img[src] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 img [src]에 할당 될 URL은 먼저 정규화되어 절대 URL로 바뀝니다. 그 후, URL은 &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; 정규 표현식 과 일치 합니다. 일치하는 것이 있으면 원래 URL이 돔에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 가 붙습니다 . 문자열이 붙고 DOM에만 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="43f5d990f54d41e9398585a561e89b92ddaadd53" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;strong&gt;Top Level Component&lt;/strong&gt; (&lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;) which is associated with the &lt;a href=&quot;../service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;, every &lt;strong&gt;Routing Component&lt;/strong&gt; is associated with a &lt;code&gt;ChildRouter&lt;/code&gt;, which manages the routing for that &lt;strong&gt;Routing Component&lt;/strong&gt;.</source>
          <target state="translated">외에도에서 &lt;strong&gt;최상위 요소&lt;/strong&gt; ( &lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; 와 관련된) &lt;a href=&quot;../service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; , 모든 &lt;strong&gt;라우팅 구성 요소는&lt;/strong&gt; 와 관련된 &lt;code&gt;ChildRouter&lt;/code&gt; 그에 대한 라우팅 관리, &lt;strong&gt;라우팅 구성 요소를&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e402e007d5cf0eceb8bba2547d33af36db64dcdf" translate="yes" xml:space="preserve">
          <source>Apart from the ternary operator (&lt;code&gt;a ? b : c&lt;/code&gt;), you cannot write a control flow statement in an expression. The reason behind this is core to the AngularJS philosophy that application logic should be in controllers, not the views. If you need a real conditional, loop, or to throw from a view expression, delegate to a JavaScript method instead.</source>
          <target state="translated">삼항 연산자 ( &lt;code&gt;a ? b : c&lt;/code&gt; ) 식에 제어 흐름 문을 작성할 수 없습니다. 그 이유는 애플리케이션 로직이 뷰가 아닌 컨트롤러에 있어야한다는 AngularJS 철학의 핵심입니다. 실제 조건부, 루프 또는 뷰 표현식에서 던져야하는 경우 대신 JavaScript 메소드에 위임하십시오.</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">응용 프로그램 구조</target>
        </trans-unit>
        <trans-unit id="7fe601ec2e88419589f9146418e8e7af8c971aaa" translate="yes" xml:space="preserve">
          <source>Application Structure &amp;amp; Style Guides</source>
          <target state="translated">응용 프로그램 구조 및 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="e47fe9ae51aadfdd2d85b572285710bb9d6644ca" translate="yes" xml:space="preserve">
          <source>Application developers are free to define their own services by registering the service's name and &lt;strong&gt;service factory function&lt;/strong&gt;, with an AngularJS module.</source>
          <target state="translated">애플리케이션 개발자는 서비스 이름 및 &lt;strong&gt;서비스 팩토리 기능을&lt;/strong&gt; AngularJS 모듈 에 등록하여 자신의 서비스를 자유롭게 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="157fcee1bf70241b8658bd19f019bbfffbd57a6b" translate="yes" xml:space="preserve">
          <source>Application developers will rarely need to call this method directly. It is used internally, by &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setValidity.html&quot;&gt;NgModelController.$setValidity()&lt;/a&gt;, to propagate a control's validity state to the parent &lt;code&gt;FormController&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 개발자는이 메서드를 직접 호출 할 필요가 거의 없습니다. 컨트롤의 유효성 상태를 부모 &lt;code&gt;FormController&lt;/code&gt; 에 전파하기 위해 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setValidity.html&quot;&gt;NgModelController. $ setValidity ()에&lt;/a&gt; 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="53162fc7151bee0f7c7ba8c31bf1c2355dfc4550" translate="yes" xml:space="preserve">
          <source>Architecture, file structure, components, one-way dataflow and best practices</source>
          <target state="translated">아키텍처, 파일 구조, 구성 요소, 단방향 데이터 흐름 및 모범 사례</target>
        </trans-unit>
        <trans-unit id="c83a0088927a1633acaed10f539ea98bb1e204c3" translate="yes" xml:space="preserve">
          <source>Argument names</source>
          <target state="translated">인수 이름</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="f2d1a651267110941a7e3eba6df9faa2ed02c04d" translate="yes" xml:space="preserve">
          <source>Array containing URLs whose origins are trusted to receive the XSRF token. See the &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;Security Considerations&lt;/a&gt; sections for more details on XSRF.</source>
          <target state="translated">출처가 XSRF 토큰을 수신하도록 신뢰할 수있는 URL을 포함하는 배열입니다. XSRF에 대한 자세한 내용 은 &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;보안 고려 사항&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32c9d1434f0741f3d270e0c58ec7b6e77a762138" translate="yes" xml:space="preserve">
          <source>Array containing service factories for all synchronous or asynchronous &lt;a href=&quot;../service/%24http&quot;&gt;$http&lt;/a&gt; pre-processing of request or postprocessing of responses.</source>
          <target state="translated">요청의 모든 동기 또는 비동기 &lt;a href=&quot;../service/%24http&quot;&gt;$ http&lt;/a&gt; 사전 처리 또는 응답 후 처리를 위한 서비스 팩토리를 포함하는 배열 .</target>
        </trans-unit>
        <trans-unit id="557b5657af00498abd22b4555192836bb6d9557e" translate="yes" xml:space="preserve">
          <source>Array of config objects for currently pending requests. This is primarily meant to be used for debugging purposes.</source>
          <target state="translated">현재 보류중인 요청에 대한 구성 객체의 배열입니다. 이것은 주로 디버깅 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dda0d43b5dd90aadcea7413aa4213f341abd201c" translate="yes" xml:space="preserve">
          <source>Array of expressions that will be individually watched using &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$watch()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$ watch ()를&lt;/a&gt; 사용하여 개별적으로 볼 표현식 배열</target>
        </trans-unit>
        <trans-unit id="16a28eaf7d1396d70aa69a55073aa5ed0d533006" translate="yes" xml:space="preserve">
          <source>Array of functions to execute whenever a change to &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;$viewValue&lt;/code&gt;&lt;/a&gt; has caused a change to &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt;&lt;code&gt;$modelValue&lt;/code&gt;&lt;/a&gt;. It is called with no arguments, and its return value is ignored. This can be used in place of additional $watches against the model value.</source>
          <target state="translated">&lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;$viewValue&lt;/code&gt; &lt;/a&gt; 변경으로 인해 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt; &lt;code&gt;$modelValue&lt;/code&gt; &lt;/a&gt; 변경이 발생할 때마다 실행할 함수 배열입니다 . 인수없이 호출되며 반환 값은 무시됩니다. 모델 값에 대한 추가 $ watch 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1424ab51b27d79e61339e273ce91fa793a8714e8" translate="yes" xml:space="preserve">
          <source>Array of functions to execute, as a pipeline, whenever the bound ngModel expression changes programmatically. The &lt;code&gt;$formatters&lt;/code&gt; are not called when the value of the control is changed by user interaction.</source>
          <target state="translated">바인딩 된 ngModel 표현식이 프로그래밍 방식으로 변경 될 때마다 파이프 라인으로 실행할 함수의 배열입니다. &lt;code&gt;$formatters&lt;/code&gt; 컨트롤의 값이 사용자 상호 작용에 의해 변경 될 때 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02b2ca54d88c554ca4e1087c37aecbf0eac12226" translate="yes" xml:space="preserve">
          <source>Array of functions to execute, as a pipeline, whenever the control updates the ngModelController with a new &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;$viewValue&lt;/code&gt;&lt;/a&gt; from the DOM, usually via user input. See &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;&lt;code&gt;$setViewValue()&lt;/code&gt;&lt;/a&gt; for a detailed lifecycle explanation. Note that the &lt;code&gt;$parsers&lt;/code&gt; are not called when the bound ngModel expression changes programmatically.</source>
          <target state="translated">컨트롤이 일반적으로 사용자 입력을 통해 DOM에서 새 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;$viewValue&lt;/code&gt; &lt;/a&gt; ngModelController를 업데이트 할 때마다 파이프 라인으로 실행할 함수의 배열입니다 . 자세한 수명주기 설명 은 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt; &lt;code&gt;$setViewValue()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 있습니다 &lt;code&gt;$parsers&lt;/code&gt; 결합 된 ngModel 표현 프로그래밍 변경 될 때 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa61e073a4c0baab4b05c142ba71754be4dbe3a" translate="yes" xml:space="preserve">
          <source>Array of keys to assign to regex matches in request url described above.</source>
          <target state="translated">위에서 설명한 요청 URL에서 정규식 일치에 할당 할 키 배열입니다.</target>
        </trans-unit>
        <trans-unit id="dce6ae97df369ff12e95dc68ff11901fddbd2a92" translate="yes" xml:space="preserve">
          <source>Array of keys to assign to regex matches in request url described on &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$httpBackend mock&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$ httpBackend mock&lt;/a&gt; 에 설명 된 요청 URL에서 정규식 일치에 할당 할 키 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="9c6621304506b22ca9a68ad77ea41a030e17c566" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#debug.html&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#debug.html&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="57ea05d19a68d43106644cbce6da8d34187676e8" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="8151a9ffd2283d4619d532eaaac736b5d01ab54f" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#info.html&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#info.html&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="69d8c243e53bd946f150a38a73b18a8f0819eed0" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#log.html&quot;&gt;&lt;code&gt;log()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#log.html&quot;&gt; &lt;code&gt;log()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="787bf1b8fa54bd835ba5079f6b4ece639ed7b9ed" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#warn.html&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#warn.html&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="0fb4bcb40bc5316de7a202017017eaefa3df7c7b" translate="yes" xml:space="preserve">
          <source>Array/array-like, string or number to be limited.</source>
          <target state="translated">배열 / 배열과 같은 문자열 또는 숫자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="647955f61de2f76c3b41b2e5804a604deead0bcb" translate="yes" xml:space="preserve">
          <source>Articles, Videos, and Projects</source>
          <target state="translated">기사, 비디오 및 프로젝트</target>
        </trans-unit>
        <trans-unit id="7275de9628a1cc80191841f09611cfb2af505dfb" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;ngRepeat&lt;/code&gt; does its thing, each time a new item is added into the list, &lt;code&gt;ngRepeat&lt;/code&gt; will add an &lt;code&gt;ng-enter&lt;/code&gt; class to the element that is being added. When removed it will apply an &lt;code&gt;ng-leave&lt;/code&gt; class and when moved around it will apply an &lt;code&gt;ng-move&lt;/code&gt; class.</source>
          <target state="translated">으로 &lt;code&gt;ngRepeat&lt;/code&gt; 가 그 일을, 새 항목이 목록에 추가 될 때마다, &lt;code&gt;ngRepeat&lt;/code&gt; 이 추가됩니다 &lt;code&gt;ng-enter&lt;/code&gt; 추가되는 요소에 클래스를. 제거하면 &lt;code&gt;ng-leave&lt;/code&gt; 클래스가 적용되고 &lt;code&gt;ng-move&lt;/code&gt; 하면 ng-move 클래스 가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0695df435dac0ab2843253e78e2827b4f1a7f956" translate="yes" xml:space="preserve">
          <source>As a best practice, consider adding an &lt;code&gt;ng-strict-di&lt;/code&gt; directive on the same element as &lt;code&gt;ng-app&lt;/code&gt;:</source>
          <target state="translated">모범 사례 로 &lt;code&gt;ng-app&lt;/code&gt; 와 동일한 요소에 &lt;code&gt;ng-strict-di&lt;/code&gt; 지시문을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e65d701eca158f6dc26450435f4a299e994565af" translate="yes" xml:space="preserve">
          <source>As a result of &lt;code&gt;ngBind&lt;/code&gt;, &lt;code&gt;ngBindHtml&lt;/code&gt; or &lt;code&gt;{{...}}&lt;/code&gt; interpolations, binding data and CSS class &lt;code&gt;ng-binding&lt;/code&gt; are attached to the corresponding element.</source>
          <target state="translated">&lt;code&gt;ngBind&lt;/code&gt; , &lt;code&gt;ngBindHtml&lt;/code&gt; 또는 &lt;code&gt;{{...}}&lt;/code&gt; 보간 결과 바인딩 데이터 및 CSS 클래스 &lt;code&gt;ng-binding&lt;/code&gt; 이 해당 요소에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="67db5c7bc5d719b0ac857083a55a856d06e77a01" translate="yes" xml:space="preserve">
          <source>As a result of that, &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; creates new scope and reinstantiates the controller.</source>
          <target state="translated">그 결과 &lt;a href=&quot;../directive/ngview&quot;&gt;ngView는&lt;/a&gt; 새로운 범위를 생성하고 컨트롤러를 다시 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="2325450d98839f1a7cf5c6905e3d4f5721cb3fd3" translate="yes" xml:space="preserve">
          <source>As already mentioned in the intro, the Provider recipe is the core recipe type and all the other recipe types are just syntactic sugar on top of it. It is the most verbose recipe with the most abilities, but for most services it's overkill.</source>
          <target state="translated">서론에서 이미 언급했듯이, 제공자 레시피는 핵심 레시피 유형이며 다른 모든 레시피 유형은 그 위에 구문 설탕입니다. 가장 많은 기능을 갖춘 가장 장황한 레시피이지만 대부분의 서비스에는 과잉입니다.</target>
        </trans-unit>
        <trans-unit id="6ef852d71fd5d9cc1d2ec23dccfd5e8aa5b6791e" translate="yes" xml:space="preserve">
          <source>As already mentioned, the component helper makes it easier to structure your application with a component-based architecture. But what makes a component beyond the options that the component helper has?</source>
          <target state="translated">이미 언급했듯이 구성 요소 도우미를 사용하면 구성 요소 기반 아키텍처로 응용 프로그램을보다 쉽게 ​​구성 할 수 있습니다. 그러나 구성 요소 도우미가 갖는 옵션을 넘어서 구성 요소를 만드는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="66190f01e31088a12a65092a98ca24475f550877" translate="yes" xml:space="preserve">
          <source>As an array of injection names, where the last item in the array is the function to call.</source>
          <target state="translated">주입 이름의 배열로서, 배열의 마지막 항목은 호출 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ab19f6eb4ea00d87f713b79c4d8c813abaeab501" translate="yes" xml:space="preserve">
          <source>As an example, &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml&lt;/a&gt; uses &lt;a href=&quot;%24sce#parseAsHtml.html&quot;&gt;$sce.parseAsHtml(binding expression)&lt;/a&gt;. Here's the actual code (slightly simplified):</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml&lt;/a&gt; 은 &lt;a href=&quot;%24sce#parseAsHtml.html&quot;&gt;$ sce.parseAsHtml (binding expression)을 사용&lt;/a&gt; 합니다. 실제 코드는 다음과 같습니다 (약간 단순화).</target>
        </trans-unit>
        <trans-unit id="07153bae5bff22d9000ae9eab846630c563316f9" translate="yes" xml:space="preserve">
          <source>As applications grow in size and complexity, it becomes unrealistic to rely on manual testing to verify the correctness of new features, catch bugs and notice regressions. Unit tests are the first line of defense for catching bugs, but sometimes issues come up with integration between components which can't be captured in a unit test. End-to-end tests are made to find these problems.</source>
          <target state="translated">응용 프로그램의 크기와 복잡성이 증가함에 따라 수동 테스트를 통해 새로운 기능의 정확성을 확인하고 버그를 포착하고 회귀를 발견하는 것은 비현실적입니다. 단위 테스트는 버그를 잡기위한 첫 번째 방어선이지만 단위 테스트에서 캡처 할 수없는 구성 요소 간의 통합으로 문제가 발생하는 경우가 있습니다. 이러한 문제를 찾기 위해 종단 간 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7a55120448d479c287c566c8d98fb08b5ccd50" translate="yes" xml:space="preserve">
          <source>As discussed in the &lt;a href=&quot;concepts&quot;&gt;Concepts&lt;/a&gt; section of this guide, any objects (or primitives) assigned to the scope become model properties. Any methods assigned to the scope are available in the template/view, and can be invoked via AngularJS expressions and &lt;code&gt;ng&lt;/code&gt; event handler directives (e.g. &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ngClick&lt;/a&gt;).</source>
          <target state="translated">이 안내서 의 &lt;a href=&quot;concepts&quot;&gt;개념&lt;/a&gt; 섹션 에서 설명한대로 범위에 할당 된 모든 객체 (또는 기본 요소)는 모델 속성이됩니다. 범위에 지정된 모든 메소드는 템플리트 /보기에서 사용 가능하며 AngularJS 표현식 및 &lt;code&gt;ng&lt;/code&gt; 이벤트 핸들러 지시문 (예 : &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ngClick&lt;/a&gt; )을 통해 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="543566b9bcbd90fce5b7b69e2eb29f4197ad9e3d" translate="yes" xml:space="preserve">
          <source>As mentioned in the syntax for plural and select, the embedded messages can contain AngularJS interpolation syntax. Since you can use MessageFormat extensions in AngularJS interpolation, this allows you to nest plural and gender expressions in any order.</source>
          <target state="translated">복수 및 선택 구문에서 언급했듯이 임베드 된 메시지에는 AngularJS 보간 구문이 포함될 수 있습니다. AngularJS 보간에서 MessageFormat 확장을 사용할 수 있으므로 여러 식과 성별 식을 임의의 순서로 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a72e1e24aff22427a315dbc60e5118663742eedc" translate="yes" xml:space="preserve">
          <source>As new &lt;code&gt;action&lt;/code&gt;s are inserted, the template &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element needs to be cloned and inserted into &lt;code&gt;ul&lt;/code&gt;. But cloning the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is not enough. It also needs to compile the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; so that its directives, like &lt;code&gt;{{action.description}}&lt;/code&gt;, evaluate against the right &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;action&lt;/code&gt; 이 삽입되면 템플릿 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 복제하여 &lt;code&gt;ul&lt;/code&gt; 에 삽입해야합니다 . 그러나 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 복제하는 것만으로는 충분하지 않습니다. 또한 컴파일 할 필요가 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 그래서 그 지시어와 같은 &lt;code&gt;{{action.description}}&lt;/code&gt; 오른쪽에 대한 평가 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec13f23302b7d1dd1ac45a02e83f66da3e707c4" translate="yes" xml:space="preserve">
          <source>As of version 1.2, AngularJS ships with SCE enabled by default.</source>
          <target state="translated">버전 1.2부터 AngularJS는 기본적으로 SCE가 활성화 된 상태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8080a15a0ddec2d77c43863b3384640745b7f2b" translate="yes" xml:space="preserve">
          <source>As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application is being developed with the real backend api replaced with a mock, it is often desirable for certain category of requests to bypass the mock and issue a real http request (e.g. to fetch templates or static files from the webserver). To configure the backend with this behavior use the &lt;code&gt;passThrough&lt;/code&gt; request handler of &lt;code&gt;when&lt;/code&gt; instead of &lt;code&gt;respond&lt;/code&gt;.</source>
          <target state="translated">단위 테스트와는 달리 종단 간 테스트 시나리오 또는 실제 백엔드 API를 모의로 대체하여 응용 프로그램을 개발하는 시나리오에서는 특정 범주의 요청이 모의 및 문제를 우회하는 것이 바람직합니다. 실제 http 요청 (예 : 웹 서버에서 템플릿 또는 정적 파일 가져 오기) 이 동작으로 백엔드를 구성하려면 &lt;code&gt;respond&lt;/code&gt; 대신 &lt;code&gt;when&lt;/code&gt; 의 &lt;code&gt;passThrough&lt;/code&gt; 요청 핸들러를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f031cf7748d485e3e97d83ef88851314a68f2046" translate="yes" xml:space="preserve">
          <source>As the name suggests, the &lt;strong&gt;isolate scope&lt;/strong&gt; of the directive isolates everything except models that you've explicitly added to the &lt;code&gt;scope: {}&lt;/code&gt; hash object. This is helpful when building reusable components because it prevents a component from changing your model state except for the models that you explicitly pass in.</source>
          <target state="translated">이름에서 알 수 있듯이 지시문 의 &lt;strong&gt;격리 범위&lt;/strong&gt; 는 명시 적으로 &lt;code&gt;scope: {}&lt;/code&gt; 추가 한 모델을 제외한 모든 것을 격리합니다 : {} 해시 개체. 재사용 가능한 컴포넌트를 빌드 할 때 명시 적으로 전달한 모델을 제외하고 컴포넌트가 모델 상태를 변경하지 못하게하므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d9cf083e1eebce068119ed3315973988cd233c8" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;repeated-item&lt;/code&gt; class is present on the element that will be repeated and this class will be used as a reference within our application's CSS and/or JavaScript animation code to tell AngularJS to perform an animation.</source>
          <target state="translated">보시다시피 &lt;code&gt;repeated-item&lt;/code&gt; 클래스는 반복 될 요소에 존재 하며이 클래스는 응용 프로그램의 CSS 및 / 또는 JavaScript 애니메이션 코드 내에서 참조로 사용되어 AngularJS가 애니메이션을 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="de4fc7d19e5e0a6d0ac18488a8fccba793d3b358" translate="yes" xml:space="preserve">
          <source>Asking for dependencies solves the issue of hard coding, but it also means that the injector needs to be passed throughout the application. Passing the injector breaks the &lt;a href=&quot;http://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;Law of Demeter&lt;/a&gt;. To remedy this, we use a declarative notation in our HTML templates, to hand the responsibility of creating components over to the injector, as in this example:</source>
          <target state="translated">종속성을 요청하면 하드 코딩 문제가 해결되지만 인젝터가 애플리케이션 전체에 전달되어야합니다. 인젝터를 통과하면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;데메테르&lt;/a&gt; 의 법칙이 위반 됩니다. 이를 해결하기 위해 HTML 템플릿에 선언적 표기법을 사용하여 다음 예제와 같이 인젝터에 구성 요소를 생성하는 책임을 넘깁니다.</target>
        </trans-unit>
        <trans-unit id="602dca52ef2fb38805f8af26bdf588f7fcb1e4e4" translate="yes" xml:space="preserve">
          <source>Assert that all of the logging methods have no logged messages. If any messages are present, an exception is thrown.</source>
          <target state="translated">모든 로깅 방법에 기록 된 메시지가 없는지 확인하십시오. 메시지가 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e32c36e98ffeeb8e37e062d05cb463a7f175dbe" translate="yes" xml:space="preserve">
          <source>Assignable AngularJS expression to data-bind to.</source>
          <target state="translated">데이터 바인딩 할 수있는 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="fa624932ddb296ac5007e5591dd9bfb041b6cb1e" translate="yes" xml:space="preserve">
          <source>Assigning a property to &lt;code&gt;$scope&lt;/code&gt; creates or updates the model.</source>
          <target state="translated">&lt;code&gt;$scope&lt;/code&gt; 속성을 할당 하면 모델이 생성되거나 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="adc58ef773100f1ac890b76704547adbe78e189d" translate="yes" xml:space="preserve">
          <source>Associates the provided element with a host parent element to allow the element to be animated even if it exists outside of the DOM structure of the AngularJS application. By doing so, any animation triggered via &lt;code&gt;$animate&lt;/code&gt; can be issued on the element despite being outside the realm of the application or within another application. Say for example if the application was bootstrapped on an element that is somewhere inside of the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag, but we wanted to allow for an element to be situated as a direct child of &lt;code&gt;document.body&lt;/code&gt;, then this can be achieved by pinning the element via &lt;code&gt;$animate.pin(element)&lt;/code&gt;. Keep in mind that calling &lt;code&gt;$animate.pin(element, parentElement)&lt;/code&gt; will not actually insert into the DOM anywhere; it will just create the association.</source>
          <target state="translated">제공된 요소를 호스트 상위 요소와 연관시켜 요소가 AngularJS 애플리케이션의 DOM 구조 외부에있는 경우에도 애니메이션을 적용 할 수 있습니다. 이렇게하면 &lt;code&gt;$animate&lt;/code&gt; 를 통해 트리거 된 모든 애니메이션 은 응용 프로그램 영역 외부 나 다른 응용 프로그램 내에 있더라도 요소에서 실행될 수 있습니다. 예를 들어, &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그 안에있는 요소에서 응용 프로그램을 부트 스트랩 했지만, 요소를 &lt;code&gt;document.body&lt;/code&gt; 의 직접적인 자식으로 배치하고 싶었다면 이를 고정시킬 수 있습니다. &lt;code&gt;$animate.pin(element)&lt;/code&gt; 를 통한 요소 . 호출 &lt;code&gt;$animate.pin(element, parentElement)&lt;/code&gt; 이 실제로 DOM에 삽입되지는 않습니다. 연결을 만들뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8a319250e7a62a6449653025f2ab2f88895ac77d" translate="yes" xml:space="preserve">
          <source>Asynchronous Loading</source>
          <target state="translated">비동기식 로딩</target>
        </trans-unit>
        <trans-unit id="5bbd06015f69fbcbcdb24725f6bb1567275ce22b" translate="yes" xml:space="preserve">
          <source>At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's &lt;strong&gt;HTML compiler&lt;/strong&gt; (&lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;&lt;code&gt;$compile&lt;/code&gt;&lt;/a&gt;) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children.</source>
          <target state="translated">상위 수준에서 지시문은 DOM 요소 (예 : 속성, 요소 이름, 주석 또는 CSS 클래스)의 마커로 AngularJS의 &lt;strong&gt;HTML 컴파일러&lt;/strong&gt; ( &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; &lt;/a&gt; )에게 지정된 동작을 해당 DOM 요소에 첨부하도록 (예 : 이벤트 리스너를 통해) 지시합니다. 또는 DOM 요소와 해당 하위 요소를 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fded031893dd4b58525b3e28e5c62e3f06e82a91" translate="yes" xml:space="preserve">
          <source>At first glance, it looks like removing the original &lt;code&gt;addMouseover&lt;/code&gt; attribute is all there is needed to make this example work. However, if the directive element or its children have other directives attached, they will be compiled and linked again, because the compiler doesn't keep track of which directives have been assigned to which elements.</source>
          <target state="translated">언뜻보기에 원래 &lt;code&gt;addMouseover&lt;/code&gt; 속성을 제거하면 이 예제를 작동시키는 데 필요한 모든 것 같습니다. 그러나 지시문 요소 나 그 자식에 다른 지시문이 첨부되어 있으면 컴파일러는 어떤 지시문이 어떤 요소에 할당되었는지 추적하지 않기 때문에 다시 컴파일되고 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="16d656728db993e2d91d65f16fd40b8735a327f3" translate="yes" xml:space="preserve">
          <source>At first it might not be obvious why this extra complexity is worth the trouble. The payoff comes in the way of guarantees that promise and deferred APIs make, see &lt;a href=&quot;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&quot;&gt;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&lt;/a&gt;.</source>
          <target state="translated">처음에는 왜 이러한 추가 복잡성이 문제의 가치가 있는지 분명하지 않을 수 있습니다. 그 대가는 약속 및 지연된 API가 보장하는 방식으로 이루어집니다 ( &lt;a href=&quot;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&quot;&gt;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e100b35ab6c0fe1f3d2cdccfdad5402c15024472" translate="yes" xml:space="preserve">
          <source>At runtime the &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; watches the expression and as items are added to the array it clones the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element, creates a new &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt; for the cloned &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element and calls the link function on the cloned &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">런타임시 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; 는&lt;/a&gt; 식 시계 및 항목이 배열에 추가되는 것이 클론 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 신규 작성 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;영역&lt;/a&gt; 복제에 대한 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 및 복제에 링크 기능을 호출 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dab9e3efd9dd8deab1758a62454f3f213bdba8" translate="yes" xml:space="preserve">
          <source>At runtime: &lt;a href=&quot;../api/ng/service/%24animate#enabled.html&quot;&gt;$animate.enabled()&lt;/a&gt;</source>
          <target state="translated">런타임시 : &lt;a href=&quot;../api/ng/service/%24animate#enabled.html&quot;&gt;$ animate.enabled ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67e221630aa693d76075a22c1ba1f64147ff501" translate="yes" xml:space="preserve">
          <source>At the end of &lt;code&gt;$apply&lt;/code&gt;, AngularJS performs a &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; cycle on the root scope, which then propagates throughout all child scopes. During the &lt;code&gt;$digest&lt;/code&gt; cycle, all &lt;code&gt;$watch&lt;/code&gt;ed expressions or functions are checked for model mutation and if a mutation is detected, the &lt;code&gt;$watch&lt;/code&gt; listener is called.</source>
          <target state="translated">&lt;code&gt;$apply&lt;/code&gt; 의 끝 에서 AngularJS 는 루트 범위에서 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트&lt;/a&gt; 주기를 수행 한 다음 모든 하위 범위에 전파됩니다. &lt;code&gt;$digest&lt;/code&gt; 주기 동안 모든 &lt;code&gt;$watch&lt;/code&gt; watched 표현식 또는 함수는 모델 돌연변이를 검사하고 돌연변이가 감지되면 &lt;code&gt;$watch&lt;/code&gt; 리스너가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="811060f5b400ba59f43a01f37e35d2b7526adfec" translate="yes" xml:space="preserve">
          <source>At this point you may wonder why the compile process has separate compile and link phases. The short answer is that compile and link separation is needed any time a change in a model causes a change in the &lt;strong&gt;structure&lt;/strong&gt; of the DOM.</source>
          <target state="translated">이 시점에서 컴파일 프로세스에 별도의 컴파일 및 링크 단계가있는 이유가 궁금 할 수 있습니다. 짧은 대답은 모델의 변경으로 인해 DOM &lt;strong&gt;구조&lt;/strong&gt; 가 변경 될 때마다 컴파일 및 링크 분리가 필요하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7d38f6daaef849032ab49cae508751fbd896de2c" translate="yes" xml:space="preserve">
          <source>Attaching new behavior to DOM elements, such as DOM event handling.</source>
          <target state="translated">DOM 이벤트 처리와 같은 DOM 요소에 새로운 동작 추가</target>
        </trans-unit>
        <trans-unit id="f18ef5bd3a9704f6d7f339924ddd7e7a2c353300" translate="yes" xml:space="preserve">
          <source>Attribute values are not merged</source>
          <target state="translated">속성 값이 병합되지 않습니다</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="9cf83f638488303498c3d24f3e3e27d978f4e28e" translate="yes" xml:space="preserve">
          <source>Attributes such as &lt;code&gt;disabled&lt;/code&gt; are called &lt;code&gt;boolean&lt;/code&gt; attributes, because their presence means &lt;code&gt;true&lt;/code&gt; and their absence means &lt;code&gt;false&lt;/code&gt;. We cannot use normal attribute bindings with them, because the HTML specification does not require browsers to preserve the values of boolean attributes. This means that if we put an AngularJS interpolation expression into such an attribute then the binding information would be lost, because the browser ignores the attribute value.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; 와 같은 속성을 &lt;code&gt;boolean&lt;/code&gt; 속성 이라고 합니다. 존재 여부는 &lt;code&gt;true&lt;/code&gt; 이고 부재는 &lt;code&gt;false&lt;/code&gt; 입니다. . HTML 스펙에는 브라우저가 부울 속성 값을 보존 할 필요가 없으므로 일반적인 속성 바인딩을 사용할 수 없습니다. 즉, AngularJS 보간 표현식을 이러한 속성에 넣으면 브라우저가 속성 값을 무시하기 때문에 바인딩 정보가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ec94b23d4cf5e5552507a5899b9e011b45a154d6" translate="yes" xml:space="preserve">
          <source>Augment the $delegate</source>
          <target state="translated">$ 대리인 보강</target>
        </trans-unit>
        <trans-unit id="41869ae502e1528f5e860a994dc5f7a5715f3cc3" translate="yes" xml:space="preserve">
          <source>Automatic Initialization</source>
          <target state="translated">자동 초기화</target>
        </trans-unit>
        <trans-unit id="1105b837870d87e705ed3933cf58b23765b1ac5f" translate="yes" xml:space="preserve">
          <source>Available task types:</source>
          <target state="translated">사용 가능한 작업 유형 :</target>
        </trans-unit>
        <trans-unit id="b158354eab7dcfad40f037bfff4be8583770ec91" translate="yes" xml:space="preserve">
          <source>Back to the initial question: How does the &lt;code&gt;InvoiceController&lt;/code&gt; get a reference to the &lt;code&gt;currencyConverter&lt;/code&gt; function? In AngularJS, this is done by simply defining arguments on the constructor function. With this, the injector is able to create the objects in the right order and pass the previously created objects into the factories of the objects that depend on them. In our example, the &lt;code&gt;InvoiceController&lt;/code&gt; has an argument named &lt;code&gt;currencyConverter&lt;/code&gt;. By this, AngularJS knows about the dependency between the controller and the service and calls the controller with the service instance as argument.</source>
          <target state="translated">초기 질문으로 돌아 가기 : &lt;code&gt;InvoiceController&lt;/code&gt; 는 &lt;code&gt;currencyConverter&lt;/code&gt; 함수에 대한 참조를 어떻게 얻 습니까? AngularJS에서는 생성자 함수에 인수를 정의하기 만하면됩니다. 이를 통해 인젝터는 올바른 순서로 오브젝트를 작성하고 이전에 작성된 오브젝트를 종속 오브젝트의 팩토리로 전달할 수 있습니다. 이 예에서 &lt;code&gt;InvoiceController&lt;/code&gt; 에는 &lt;code&gt;currencyConverter&lt;/code&gt; 라는 인수가 있습니다. 이를 통해 AngularJS는 컨트롤러와 서비스 간의 종속성에 대해 알고 서비스 인스턴스를 인수로 사용하여 컨트롤러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d9c883a905731bc3ab1e5b1797dcc17a576c4565" translate="yes" xml:space="preserve">
          <source>Back to top</source>
          <target state="translated">맨 위로</target>
        </trans-unit>
        <trans-unit id="667908f902838bdc241aa234ee74229ead2f1562" translate="yes" xml:space="preserve">
          <source>Backend definitions</source>
          <target state="translated">백엔드 정의</target>
        </trans-unit>
        <trans-unit id="dd04a0ffb87db83b44ae4c32b0c0f5c8813e323e" translate="yes" xml:space="preserve">
          <source>Backend definitions allow you to define a fake backend for your application which doesn't assert if a particular request was made or not, it just returns a trained response if a request is made. The test will pass whether or not the request gets made during testing.</source>
          <target state="translated">백엔드 정의를 사용하면 특정 요청이 있었는지 여부를 주장하지 않고 요청이 이루어진 경우 훈련 된 응답 만 반환하는 애플리케이션에 대한 가짜 백엔드를 정의 할 수 있습니다. 테스트는 테스트 중에 요청이 이루어 졌는지 여부를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="59f299125e1e43938ff9695b8c50f5b33268fea4" translate="yes" xml:space="preserve">
          <source>Base href constraints</source>
          <target state="translated">기본 href 제약</target>
        </trans-unit>
        <trans-unit id="f8401938c390cf3e82bf20e8f5b954ce826b2925" translate="yes" xml:space="preserve">
          <source>Based on the context, other options may exist to mark a value as trusted / configure the behavior of &lt;a href=&quot;../service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt;. For example, to restrict the &lt;code&gt;RESOURCE_URL&lt;/code&gt; context to specific origins, use the &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist()&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;resourceUrlBlacklist()&lt;/a&gt;.</source>
          <target state="translated">컨텍스트를 기반으로 &lt;a href=&quot;../service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 의 동작을 신뢰 / 구성으로 표시하는 다른 옵션이있을 수 있습니다 . 예를 들어, &lt;code&gt;RESOURCE_URL&lt;/code&gt; 컨텍스트를 특정 출처 로 제한 하려면 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist ()&lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;resourceUrlBlacklist ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="a630ca8deb35f0b3fd6f775e263194a67f9726ee" translate="yes" xml:space="preserve">
          <source>Basic transclusion</source>
          <target state="translated">기본 번역</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="a8f4a3a1f0d4e06e71d9546076fd38b396b53d8c" translate="yes" xml:space="preserve">
          <source>Be aware that a scope may not be included in digests if it has a suspended ancestor, even if &lt;code&gt;$isSuspended()&lt;/code&gt; returns false.</source>
          <target state="translated">&lt;code&gt;$isSuspended()&lt;/code&gt; 가 false를 반환 하더라도 조상에 일시 중단 된 범위가 있으면 다이제스트에 범위가 포함되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb178cd3edcfd7946fd6725c07d458de69029a68" translate="yes" xml:space="preserve">
          <source>Be aware that the attribute values to match against cannot be expressions. They are interpreted as literal string values to match against. For example, &lt;strong&gt;&lt;code&gt;ng-switch-when=&quot;someVal&quot;&lt;/code&gt;&lt;/strong&gt; will match against the string &lt;code&gt;&quot;someVal&quot;&lt;/code&gt; not against the value of the expression &lt;code&gt;$scope.someVal&lt;/code&gt;.</source>
          <target state="translated">일치시킬 속성 값은 표현식이 될 수 없습니다. 일치하는 리터럴 문자열 값으로 해석됩니다. 예를 들어 &lt;strong&gt; &lt;code&gt;ng-switch-when=&quot;someVal&quot;&lt;/code&gt; &lt;/strong&gt; 은 표현식 &lt;code&gt;$scope.someVal&lt;/code&gt; 의 값이 아니라 &lt;code&gt;&quot;someVal&quot;&lt;/code&gt; 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d57c89c178c1084f792baa907f8b2cd67bfc1260" translate="yes" xml:space="preserve">
          <source>Be aware that the controller will be instantiated and attached to the scope as specified in the component definition object. If you do not provide a &lt;code&gt;$scope&lt;/code&gt; object in the &lt;code&gt;locals&lt;/code&gt; param then the helper will create a new isolated scope as a child of &lt;code&gt;$rootScope&lt;/code&gt;.</source>
          <target state="translated">구성 요소 정의 오브젝트에 지정된대로 컨트롤러가 인스턴스화되고 범위에 연결됩니다. &lt;code&gt;locals&lt;/code&gt; 매개 변수 에 &lt;code&gt;$scope&lt;/code&gt; 객체를 제공하지 않으면 도우미는 &lt;code&gt;$rootScope&lt;/code&gt; 의 자식으로 격리 된 새 범위를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6ed3cc776f278e962e755c71673491d092cfea71" translate="yes" xml:space="preserve">
          <source>Be aware that, before AngularJS 1.7.0, &lt;code&gt;a[href]&lt;/code&gt; and &lt;code&gt;img[src]&lt;/code&gt; used to sanitize their interpolated values directly rather than rely upon &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;&lt;code&gt;$sce.getTrusted&lt;/code&gt;&lt;/a&gt;. &lt;strong&gt;As of 1.7.0, this is no longer the case.&lt;/strong&gt; Now such interpolations are marked as requiring &lt;code&gt;$sce.URL&lt;/code&gt; (for &lt;code&gt;a[href]&lt;/code&gt;) or &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; (for &lt;code&gt;img[src]&lt;/code&gt;), so that the sanitization happens (via &lt;code&gt;$sce.getTrusted...&lt;/code&gt;) when the &lt;code&gt;$interpolate&lt;/code&gt; service evaluates the expressions.</source>
          <target state="translated">AngularJS 1.7.0 이전에는 &lt;code&gt;a[href]&lt;/code&gt; 및 &lt;code&gt;img[src]&lt;/code&gt; 가 &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt; &lt;code&gt;$sce.getTrusted&lt;/code&gt; &lt;/a&gt; 의존하지 않고 보간 된 값을 직접 위생 처리하는 데 사용되었습니다 . &lt;strong&gt;1.7.0부터는 더 이상 그렇지 않습니다. &lt;/strong&gt;이제 보간이 필요한 것으로 표시되어 &lt;code&gt;$sce.URL&lt;/code&gt; (위한 &lt;code&gt;a[href]&lt;/code&gt; 또는) &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; (위한 &lt;code&gt;img[src]&lt;/code&gt; ) 때문에, 살균이 (통해 일어나는 &lt;code&gt;$sce.getTrusted...&lt;/code&gt; ) 때 &lt;code&gt;$interpolate&lt;/code&gt; 서비스는 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="2dc590986ab9f4a1c9c7cd048d14ee382cfa0665" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; in the same expression.</source>
          <target state="translated">같은 식으로 &lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; 및 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 를 사용할 때주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="756d08e3929f443998e8b33d291e1c7ac910d9d7" translate="yes" xml:space="preserve">
          <source>Be ready to update rapidly when new security-centric patches are available.</source>
          <target state="translated">새로운 보안 중심 패치가 제공되면 신속하게 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="064da4156fc4de43ba0aa3698866646d47db5fcc" translate="yes" xml:space="preserve">
          <source>Be sure to check all relative links, images, scripts etc. AngularJS requires you to specify the url base in the head of your main html file (&lt;code&gt;&amp;lt;base href=&quot;/my-base/index.html&quot;&amp;gt;&lt;/code&gt;) unless &lt;code&gt;html5Mode.requireBase&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; in the html5Mode definition object passed to &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt;. With that, relative urls will always be resolved to this base url, even if the initial url of the document was different.</source>
          <target state="translated">모든 상대 링크, 이미지, 스크립트 등을 확인하십시오. AngularJS는 &lt;code&gt;html5Mode.requireBase&lt;/code&gt; 가 아닌 한 기본 HTML 파일 ( &lt;code&gt;&amp;lt;base href=&quot;/my-base/index.html&quot;&amp;gt;&lt;/code&gt; ) 의 머리글에 URL 기준을 지정해야합니다. &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt; 전달 된 html5Mode 정의 객체에서 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . 따라서 문서의 초기 URL이 다르더라도 상대 URL은 항상이 기본 URL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ccae1d4f176aa022cf0467d0a41874c687b05c" translate="yes" xml:space="preserve">
          <source>Bear in mind that calling &lt;code&gt;$http.jsonp&lt;/code&gt; gives the remote server (and, if the request is not secured, any Man-in-the-Middle attackers) instant remote code execution in your application: the result of these requests is handed off to the browser as a regular &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;$http.jsonp&lt;/code&gt; 를 호출 하면 응용 프로그램 에서 원격 서버 (및 요청이 보안되지 않은 경우 모든 Man-in-the-Middle 공격자)에게 즉시 원격 코드 실행을 제공합니다. 이러한 요청의 결과는 다음과 같습니다. 브라우저를 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="913a9f820820f8fa1cd66701b894a4992b1a3a57" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$location&lt;/code&gt; uses getters/setters, you can use &lt;code&gt;ng-model-options=&quot;{ getterSetter: true }&quot;&lt;/code&gt; to bind it to &lt;code&gt;ngModel&lt;/code&gt;:</source>
          <target state="translated">때문에 &lt;code&gt;$location&lt;/code&gt; 의 getter / setter를 사용하여, 당신은 사용할 수 있습니다 &lt;code&gt;ng-model-options=&quot;{ getterSetter: true }&quot;&lt;/code&gt; 에 바인딩하는 &lt;code&gt;ngModel&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66918714be29738338a327fa4d2ac2597587dfb7" translate="yes" xml:space="preserve">
          <source>Because AngularJS separates logic from the view layer, it keeps controllers easy to test. Let's take a look at how we might test the controller below, which provides &lt;code&gt;$scope.grade&lt;/code&gt;, which sets a property on the scope based on the length of the password.</source>
          <target state="translated">AngularJS는 뷰 레이어에서 로직을 분리하기 때문에 컨트롤러를 쉽게 테스트 할 수 있습니다. 아래에서 컨트롤러를 테스트하는 방법을 살펴 보겠습니다. 아래에서 &lt;code&gt;$scope.grade&lt;/code&gt; 를 제공 하여 암호 길이에 따라 범위에 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1af7e1fd57a13d91c70dd236e289a06c3575397f" translate="yes" xml:space="preserve">
          <source>Because calling the &lt;code&gt;then&lt;/code&gt; method of a promise returns a new derived promise, it is easily possible to create a chain of promises:</source>
          <target state="translated">promise 의 &lt;code&gt;then&lt;/code&gt; 메소드를 호출하면 새로운 파생 약속이 리턴되므로 약속 체인을 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9672864e0e40f75d7a0f50f10bc9d756a2e191b3" translate="yes" xml:space="preserve">
          <source>Because controllers are not available on the global scope, we need to use &lt;a href=&quot;../api/ngmock/function/angular.mock.inject&quot;&gt;&lt;code&gt;angular.mock.inject&lt;/code&gt;&lt;/a&gt; to inject our controller first. The first step is to use the &lt;code&gt;module&lt;/code&gt; function, which is provided by angular-mocks. This loads in the module it's given, so it is available in your tests. We pass this into &lt;code&gt;beforeEach&lt;/code&gt;, which is a function Jasmine provides that lets us run code before each test. Then we can use &lt;code&gt;inject&lt;/code&gt; to access &lt;code&gt;$controller&lt;/code&gt;, the service that is responsible for instantiating controllers.</source>
          <target state="translated">컨트롤러는 글로벌 범위에서 사용할 수 &lt;a href=&quot;../api/ngmock/function/angular.mock.inject&quot;&gt; &lt;code&gt;angular.mock.inject&lt;/code&gt; &lt;/a&gt; 컨트롤러를 먼저 주입 하려면 angular.mock.inject 를 사용해야 합니다. 첫 번째 단계는 각도 모의에 의해 제공되는 &lt;code&gt;module&lt;/code&gt; 기능 을 사용하는 것 입니다. 이것은 주어진 모듈에로드되므로 테스트에서 사용할 수 있습니다. 이를 Jasmine이 제공하는 함수 인 &lt;code&gt;beforeEach&lt;/code&gt; 로 전달하여 각 테스트 전에 코드를 실행할 수 있도록합니다. 그런 다음 &lt;code&gt;inject&lt;/code&gt; 를 사용 하여 &lt;code&gt;$controller&lt;/code&gt; 인스턴스화를 담당하는 서비스 인 $ controller 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f9e4a032b3c265ca8bc0abd382f689fad90b1d" translate="yes" xml:space="preserve">
          <source>Because of rewriting capability in HTML5 mode, your users will be able to open regular url links in legacy browsers and hashbang links in modern browser:</source>
          <target state="translated">HTML5 모드의 재 작성 기능으로 인해 사용자는 기존 브라우저에서 일반 URL 링크를 열고 최신 브라우저에서 해시 뱅 링크를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf8e5fddffa8c784285c98c1c4d48d93b7de849" translate="yes" xml:space="preserve">
          <source>Because of these caveats, we recommend avoiding this style of annotation.</source>
          <target state="translated">이러한 경고 때문에 이러한 스타일의 주석을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f831e48daf5bfcb79f6cbc1cd4201ba14ebde551" translate="yes" xml:space="preserve">
          <source>Because template loading is asynchronous the compiler will suspend compilation of directives on that element for later when the template has been resolved. In the meantime it will continue to compile and link sibling and parent elements as though this element had not contained any directives.</source>
          <target state="translated">템플릿 로딩은 비동기식이므로 컴파일러는 템플릿이 해결 될 때 나중에 해당 요소에 대한 지시문 컴파일을 일시 중단합니다. 그 동안이 요소에 지시문이 포함되지 않은 것처럼 형제 및 상위 요소를 계속 컴파일하고 링크합니다.</target>
        </trans-unit>
        <trans-unit id="c2686aeaeb26c6b0f88a3e35dc78028d0d367579" translate="yes" xml:space="preserve">
          <source>Because the constants are fixed, they get applied before other provide methods. See &lt;a href=&quot;../../auto/service/%24provide#constant.html&quot;&gt;$provide.constant()&lt;/a&gt;.</source>
          <target state="translated">상수는 고정되어 있으므로 다른 제공 메소드보다 먼저 적용됩니다. &lt;a href=&quot;../../auto/service/%24provide#constant.html&quot;&gt;$ provide.constant ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe7c5eb34e275ba1c5c585a6d36df4df0abd8a0c" translate="yes" xml:space="preserve">
          <source>Because the view is just a projection of the model, the controller is completely separated from the view and unaware of it. This makes testing a snap because it is easy to test your controller in isolation without the view and the related DOM/browser dependency.</source>
          <target state="translated">뷰는 모델의 투영 일 뿐이므로 컨트롤러는 뷰와 완전히 분리되어이를 인식하지 못합니다. 뷰와 관련 DOM / 브라우저 의존성없이 컨트롤러를 독립적으로 테스트하기가 쉽기 때문에 테스트가 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d2474582b13c2c5cbe322f103e9aa433011581de" translate="yes" xml:space="preserve">
          <source>Because these messages can themselves contain AngularJS expressions, you could also write this as follows:</source>
          <target state="translated">이러한 메시지 자체에는 AngularJS 표현식이 포함될 수 있으므로 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="eac5d76c03a8af1becda5e52ec3a36ad44266321" translate="yes" xml:space="preserve">
          <source>Before animating, &lt;code&gt;ngAnimate&lt;/code&gt; checks if the animated element is inside the application DOM tree. If not, no animation is run. Usually, this is not a problem since most apps use the &lt;code&gt;html&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; elements as their root.</source>
          <target state="translated">애니메이션을 적용하기 전에 &lt;code&gt;ngAnimate&lt;/code&gt; 는 애니메이션 요소가 응용 프로그램 DOM 트리 내에 있는지 확인합니다. 그렇지 않으면 애니메이션이 실행되지 않습니다. 대부분의 앱은 &lt;code&gt;html&lt;/code&gt; 또는 &lt;code&gt;body&lt;/code&gt; 요소를 루트로 사용하기 때문에 일반적으로 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9dea2dff9695dcee2903587ddf4721df61dee63" translate="yes" xml:space="preserve">
          <source>Before compilation</source>
          <target state="translated">컴파일하기 전에</target>
        </trans-unit>
        <trans-unit id="f741ff2771fb251149a44e53c3845e34e949b99f" translate="yes" xml:space="preserve">
          <source>Before compilation:</source>
          <target state="translated">컴파일하기 전에 :</target>
        </trans-unit>
        <trans-unit id="d2ed330fba12b5acc7c29421a0cc662fa9ec96e4" translate="yes" xml:space="preserve">
          <source>Before we can write a directive, we need to know how AngularJS's &lt;a href=&quot;compiler&quot;&gt;HTML compiler&lt;/a&gt; determines when to use a given directive.</source>
          <target state="translated">지시문을 작성하기 전에 AngularJS의 &lt;a href=&quot;compiler&quot;&gt;HTML 컴파일러&lt;/a&gt; 가 주어진 지시문을 언제 사용할지 결정 하는 방법을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4244aeaf237de0bd45b29f36dc3172737bcea80" translate="yes" xml:space="preserve">
          <source>Before you start creating interceptors, be sure to understand the &lt;a href=&quot;%24q&quot;&gt;$q and deferred/promise APIs&lt;/a&gt;.</source>
          <target state="translated">인터셉터 작성을 시작하기 전에 &lt;a href=&quot;%24q&quot;&gt;$ q 및 지연 / 약속 API&lt;/a&gt; 를 이해하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9130bc666cd2fae643b177fd9066f63c8444f18" translate="yes" xml:space="preserve">
          <source>Below is a more detailed breakdown of the attributes handled by ngAria:</source>
          <target state="translated">다음은 ngAria가 처리하는 속성에 대한 자세한 분석입니다.</target>
        </trans-unit>
        <trans-unit id="11bbabfeedc954ff982e0a78487164bd01cf2aef" translate="yes" xml:space="preserve">
          <source>Below is a pseudo code showing how a simplified dialog component may work.</source>
          <target state="translated">아래는 단순화 된 대화 상자 구성 요소가 어떻게 작동하는지 보여주는 의사 코드입니다.</target>
        </trans-unit>
        <trans-unit id="8780b9b9f2ecc23a18832842a6331d7e904cf4bd" translate="yes" xml:space="preserve">
          <source>Below is a quick example of animations being enabled for &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;ngShow&lt;/code&gt; 및 &lt;code&gt;ngHide&lt;/code&gt; 에 사용되는 애니메이션의 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="be1db57587b85598644961ce203ff84d2d516194" translate="yes" xml:space="preserve">
          <source>Below is the corresponding code using the &lt;code&gt;$compile&lt;/code&gt; service. This should help give you an idea of what AngularJS does internally.</source>
          <target state="translated">아래는 &lt;code&gt;$compile&lt;/code&gt; 서비스를 사용하는 해당 코드 입니다. 이것은 AngularJS가 내부적으로하는 일에 대한 아이디어를 제공하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="95b8e9add7e9e88cd1012d17110827a722b230cd" translate="yes" xml:space="preserve">
          <source>Besides making it possible to bind different data to the scope inside a directive, using an isolated scope has another effect.</source>
          <target state="translated">지시문 내의 범위에 다른 데이터를 바인딩 할 수있게하는 것 외에도 격리 된 범위를 사용하면 다른 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93406408f653eced71823f50bb1a33f720c1359a" translate="yes" xml:space="preserve">
          <source>Besides the new file that contains the controller code, we also added an &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;&lt;code&gt;ng-controller&lt;/code&gt;&lt;/a&gt; directive to the HTML. This directive tells AngularJS that the new &lt;code&gt;InvoiceController&lt;/code&gt; is responsible for the element with the directive and all of the element's children. The syntax &lt;code&gt;InvoiceController as invoice&lt;/code&gt; tells AngularJS to instantiate the controller and save it in the variable &lt;code&gt;invoice&lt;/code&gt; in the current scope.</source>
          <target state="translated">컨트롤러 코드가 포함 된 새 파일 외에도 &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt; &lt;code&gt;ng-controller&lt;/code&gt; &lt;/a&gt; 지시문을 HTML에 추가했습니다 . 이 지시문은 AngularJS에 새 &lt;code&gt;InvoiceController&lt;/code&gt; 가 지시문이있는 요소와 모든 요소의 자식을 담당 함을 알려줍니다 . &lt;code&gt;InvoiceController as invoice&lt;/code&gt; 구문 은 AngularJS에게 컨트롤러를 인스턴스화 하고 현재 범위 의 변수 &lt;code&gt;invoice&lt;/code&gt; 에 저장하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="5dce4dc5831fd9122f1e8fb1725d04397f36283e" translate="yes" xml:space="preserve">
          <source>Besides these few cases, you should use &lt;a href=&quot;../../../guide/component&quot;&gt;Components&lt;/a&gt; or &lt;a href=&quot;../../../guide/controller&quot;&gt;Controllers&lt;/a&gt; rather than &lt;code&gt;ngInit&lt;/code&gt; to initialize values on a scope.</source>
          <target state="translated">이러한 몇 가지 경우 외에 &lt;code&gt;ngInit&lt;/code&gt; 대신 &lt;a href=&quot;../../../guide/component&quot;&gt;구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;../../../guide/controller&quot;&gt;컨트롤러를&lt;/a&gt; 사용 하여 범위의 값을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd3e4ab482cc2518af6697be2e20841e8a579b32" translate="yes" xml:space="preserve">
          <source>Beware that using &lt;code&gt;angular.module('myModule', [])&lt;/code&gt; will create the module &lt;code&gt;myModule&lt;/code&gt; and overwrite any existing module named &lt;code&gt;myModule&lt;/code&gt;. Use &lt;code&gt;angular.module('myModule')&lt;/code&gt; to retrieve an existing module.</source>
          <target state="translated">그 사용에주의 &lt;code&gt;angular.module('myModule', [])&lt;/code&gt; 모듈 만드는 것 &lt;code&gt;myModule&lt;/code&gt; 하고 기존 모듈이라는 덮어 &lt;code&gt;myModule&lt;/code&gt; . 사용 &lt;code&gt;angular.module('myModule')&lt;/code&gt; 기존의 모듈을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8807c9bb60191c14db0f1b18c1ea78b4f82dbc02" translate="yes" xml:space="preserve">
          <source>Bind to built-in DOM events</source>
          <target state="translated">내장 DOM 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="657d28f8e1850fbaf57c9e8970ad485efff54816" translate="yes" xml:space="preserve">
          <source>Bind to custom DOM events</source>
          <target state="translated">커스텀 DOM 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="d5b9dbf27d5fc4d4a4c313e066f87df8c57477db" translate="yes" xml:space="preserve">
          <source>Binding expressions to arbitrary properties poses a security risk, as properties like &lt;code&gt;innerHTML&lt;/code&gt; can insert potentially dangerous HTML into the application, e.g. script tags that execute malicious code. For this reason, &lt;code&gt;ngProp&lt;/code&gt; applies Strict Contextual Escaping with the &lt;a href=&quot;../service/%24sce&quot;&gt;$sce service&lt;/a&gt;. This means vulnerable properties require their content to be &quot;trusted&quot;, based on the context of the property. For example, the &lt;code&gt;innerHTML&lt;/code&gt; is in the &lt;code&gt;HTML&lt;/code&gt; context, and the &lt;code&gt;iframe.src&lt;/code&gt; property is in the &lt;code&gt;RESOURCE_URL&lt;/code&gt; context, which requires that values written to this property are trusted as a &lt;code&gt;RESOURCE_URL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;innerHTML&lt;/code&gt; 과 같은 속성은 잠재적으로 위험한 HTML (예 : 악성 코드를 실행하는 스크립트 태그)을 응용 프로그램에 삽입 할 수 있으므로 임의의 속성에 식을 바인딩하면 보안 위험이 발생 합니다. 이러한 이유로 &lt;code&gt;ngProp&lt;/code&gt; 은 &lt;a href=&quot;../service/%24sce&quot;&gt;$ sce 서비스&lt;/a&gt; 와 함께 엄격한 컨텍스트 이스케이프를 적용 합니다 . 즉, 취약한 속성은 속성에 따라 콘텐츠를 &quot;신뢰할 수 있어야&quot;합니다. 예를 들어 &lt;code&gt;innerHTML&lt;/code&gt; 은 &lt;code&gt;HTML&lt;/code&gt; 컨텍스트에 있고 &lt;code&gt;iframe.src&lt;/code&gt; 속성은 &lt;code&gt;RESOURCE_URL&lt;/code&gt; 컨텍스트 에 있으며이 속성에 기록 된 값은 &lt;code&gt;RESOURCE_URL&lt;/code&gt; 로 신뢰되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c95abad5a4fb01b2daa804b21d3bcaa9976b850" translate="yes" xml:space="preserve">
          <source>Binding select to a non-string value via ngModel parsing / formatting</source>
          <target state="translated">ngModel 구문 분석 / 형식화를 통해 선택을 문자열이 아닌 값에 바인딩</target>
        </trans-unit>
        <trans-unit id="87c4c92c7cc5c40f37665ead791df5e9d4951a3e" translate="yes" xml:space="preserve">
          <source>Binding the view into the model, which other directives such as &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt; or &lt;code&gt;select&lt;/code&gt; require.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; , &lt;code&gt;textarea&lt;/code&gt; 또는 &lt;code&gt;select&lt;/code&gt; 과 같은 다른 지시문이 필요한 뷰를 모델에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="bb8d1dbec2383b2ace68d315a5505325a07603fe" translate="yes" xml:space="preserve">
          <source>Binding to a getter/setter</source>
          <target state="translated">게터 / 세터에 바인딩</target>
        </trans-unit>
        <trans-unit id="25ace093925e2814896e0582fd4ff55182dce1a7" translate="yes" xml:space="preserve">
          <source>Binding to boolean attributes</source>
          <target state="translated">부울 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="8bce3a109839f438e000945b18acdd32b0210c8c" translate="yes" xml:space="preserve">
          <source>Binding to camelCase properties</source>
          <target state="translated">camelCase 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="99b5983ad3dd8a0fefc84a6eff022b8d33c135fe" translate="yes" xml:space="preserve">
          <source>Binding to different contexts</source>
          <target state="translated">다른 상황에 바인딩</target>
        </trans-unit>
        <trans-unit id="d0561b07cc318a1f09fc9de10ee57ff0d9c80f3a" translate="yes" xml:space="preserve">
          <source>Binding to form and control state</source>
          <target state="translated">형태 및 제어 상태에 대한 바인딩</target>
        </trans-unit>
        <trans-unit id="ebd58a4a7b83d78b2f35d5de1c469945d20cbdfa" translate="yes" xml:space="preserve">
          <source>Binding to innerHTML with ngSanitize</source>
          <target state="translated">ngSanitize를 사용하여 innerHTML에 바인딩</target>
        </trans-unit>
        <trans-unit id="b6fc4d77d0ae47604bdf44f931ee45b700a34949" translate="yes" xml:space="preserve">
          <source>Binds the given expression to the value of the element.</source>
          <target state="translated">주어진 표현식을 요소의 값에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="0b9d2b2362bc33581ba11fddcb0cf0590ebd3a7a" translate="yes" xml:space="preserve">
          <source>Blog</source>
          <target state="translated">Blog</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="89ec4ec2bf400e823f3ca49d0cb938b0fedd7bab" translate="yes" xml:space="preserve">
          <source>Bootstrap</source>
          <target state="translated">Bootstrap</target>
        </trans-unit>
        <trans-unit id="443f17a7b86f51793bfee7a9b599be7411962f49" translate="yes" xml:space="preserve">
          <source>Both approaches described above require you to prepare different &lt;code&gt;index.html&lt;/code&gt; pages or JavaScript files for each locale that your app may use. You also need to configure your server to serve the correct file that corresponds to the desired locale.</source>
          <target state="translated">위에서 설명한 두 가지 방법 모두 앱에서 사용할 수있는 각 로캘마다 다른 &lt;code&gt;index.html&lt;/code&gt; 페이지 또는 JavaScript 파일 을 준비해야합니다 . 또한 원하는 로케일에 해당하는 올바른 파일을 제공하도록 서버를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca64c991bfb8f51ff1d5093045e9b7f736452f5" translate="yes" xml:space="preserve">
          <source>Both controllers and directives have reference to the scope, but not to each other. This arrangement isolates the controller from the directive as well as from the DOM. This is an important point since it makes the controllers view agnostic, which greatly improves the testing story of the applications.</source>
          <target state="translated">컨트롤러와 지시문은 범위를 참조하지만 서로를 참조하지는 않습니다. 이 배열은 컨트롤러를 지시문 및 DOM에서 분리합니다. 컨트롤러를 무시해도되므로 응용 프로그램의 테스트 스토리가 크게 향상되므로 이는 중요한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="40dcb3b95121f56d8a5d3c7eb1620ecb8cb8dc8b" translate="yes" xml:space="preserve">
          <source>Both methods return the &lt;code&gt;requestHandler&lt;/code&gt; object for possible overrides.</source>
          <target state="translated">두 메소드 모두 가능한 대체를 위해 &lt;code&gt;requestHandler&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d46a182956cbe1896d122a91a94ab7a7d4100cc8" translate="yes" xml:space="preserve">
          <source>Both objects or values are of the same type and all of their properties are equal by comparing them with &lt;code&gt;angular.equals&lt;/code&gt;.</source>
          <target state="translated">객체 또는 값은 모두 동일한 유형이며 &lt;code&gt;angular.equals&lt;/code&gt; 와 비교하여 모든 속성이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3e5005cfde41f6cbdc44666fa883267220053196" translate="yes" xml:space="preserve">
          <source>Both objects or values pass &lt;code&gt;===&lt;/code&gt; comparison.</source>
          <target state="translated">객체 또는 값 모두 &lt;code&gt;===&lt;/code&gt; 비교를 통과 합니다.</target>
        </trans-unit>
        <trans-unit id="a125206df8681fa85102404723fa7cd9d26dd16c" translate="yes" xml:space="preserve">
          <source>Both requests and responses can be transformed using transformation functions: &lt;code&gt;transformRequest&lt;/code&gt; and &lt;code&gt;transformResponse&lt;/code&gt;. These properties can be a single function that returns the transformed value (&lt;code&gt;function(data, headersGetter, status)&lt;/code&gt;) or an array of such transformation functions, which allows you to &lt;code&gt;push&lt;/code&gt; or &lt;code&gt;unshift&lt;/code&gt; a new transformation function into the transformation chain.</source>
          <target state="translated">요청과 응답 모두 &lt;code&gt;transformRequest&lt;/code&gt; 및 &lt;code&gt;transformResponse&lt;/code&gt; 변환 기능을 사용하여 변환 할 수 있습니다 . 이러한 특성은 하나의 함수가 될 수 복귀 변환 값 ( &lt;code&gt;function(data, headersGetter, status)&lt;/code&gt; 가 수 있음) 또는 변환 함수의 배열 &lt;code&gt;push&lt;/code&gt; 또는 &lt;code&gt;unshift&lt;/code&gt; 변환 체인에 새로운 변환 함수.</target>
        </trans-unit>
        <trans-unit id="75b4106a74d08ca7beaa672015bdedf0fbb0610c" translate="yes" xml:space="preserve">
          <source>Both server and the client must cooperate in order to eliminate these threats. AngularJS comes pre-configured with strategies that address these issues, but for this to work backend server cooperation is required.</source>
          <target state="translated">이러한 위협을 제거하려면 서버와 클라이언트 모두 협력해야합니다. AngularJS에는 이러한 문제를 해결하는 전략이 사전 구성되어 있지만이를 위해서는 백엔드 서버 협력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d7a06053351dcacb0958c1d7874174fafa3e176f" translate="yes" xml:space="preserve">
          <source>Both services use the array notation to declare their dependencies.</source>
          <target state="translated">두 서비스 모두 배열 표기법을 사용하여 종속성을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="453b6ec0bdcf074f42019bd759bd4f46fe479c1d" translate="yes" xml:space="preserve">
          <source>Both values are NaN. (In JavaScript, NaN == NaN =&amp;gt; false. But we consider two NaN as equal)</source>
          <target state="translated">두 값 모두 NaN입니다. (JavaScript에서는 NaN == NaN =&amp;gt; false입니다. 그러나 우리는 두 NaN을 동일한 것으로 간주합니다)</target>
        </trans-unit>
        <trans-unit id="8238aa1fee0718d12fd25bfcbae5d91e5efcde6e" translate="yes" xml:space="preserve">
          <source>Both values represent the same regular expression (In JavaScript, /abc/ == /abc/ =&amp;gt; false. But we consider two regular expressions as equal when their textual representation matches).</source>
          <target state="translated">두 값 모두 동일한 정규 표현식을 나타냅니다 (JavaScript에서는 / abc / == / abc / =&amp;gt; false. 그러나 텍스트 표현이 일치 할 경우 두 정규 표현식을 동일한 것으로 간주합니다).</target>
        </trans-unit>
        <trans-unit id="236ab44b7fba5a5f64f75f18c707a81aa8471a1c" translate="yes" xml:space="preserve">
          <source>BreezeJS</source>
          <target state="translated">BreezeJS</target>
        </trans-unit>
        <trans-unit id="a0cdfd5795b7e2c68f3f565bde94c8cda195a6da" translate="yes" xml:space="preserve">
          <source>Broadcasted after a URL was changed.</source>
          <target state="translated">URL이 변경된 후 방송됩니다.</target>
        </trans-unit>
        <trans-unit id="5717f71e7e0404413a5bac0d197a4f54f36c5557" translate="yes" xml:space="preserve">
          <source>Broadcasted after a route change has happened successfully. The &lt;code&gt;resolve&lt;/code&gt; dependencies are now available in the &lt;code&gt;current.locals&lt;/code&gt; property.</source>
          <target state="translated">경로 변경이 완료된 후 브로드 캐스팅됩니다. &lt;code&gt;resolve&lt;/code&gt; 종속성은 이제 사용할 수 있습니다 &lt;code&gt;current.locals&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="db63277f54c549ffb9ccc9b41975c00069d4fd0b" translate="yes" xml:space="preserve">
          <source>Broadcasted before a URL will change.</source>
          <target state="translated">URL이 변경되기 전에 방송됩니다.</target>
        </trans-unit>
        <trans-unit id="a528b7c196e8ddc0cb9c7f059079eae85e556a77" translate="yes" xml:space="preserve">
          <source>Broadcasted before a route change. At this point the route services starts resolving all of the dependencies needed for the route change to occur. Typically this involves fetching the view template as well as any dependencies defined in &lt;code&gt;resolve&lt;/code&gt; route property. Once all of the dependencies are resolved &lt;code&gt;$routeChangeSuccess&lt;/code&gt; is fired.</source>
          <target state="translated">경로 변경 전에 방송됩니다. 이 시점에서 경로 서비스는 경로 변경이 발생하는 데 필요한 모든 종속성을 해결하기 시작합니다. 일반적으로이 뷰 템플릿뿐만 아니라에 정의 된 모든 종속성을 가져 오는 포함 &lt;code&gt;resolve&lt;/code&gt; 경로 속성을. 모든 종속성이 해결되면 &lt;code&gt;$routeChangeSuccess&lt;/code&gt; 가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0e142877d6ef7e5d1e6c077814dcc5637d27b1f7" translate="yes" xml:space="preserve">
          <source>Broadcasted if a redirection function fails or any redirection or resolve promises are rejected.</source>
          <target state="translated">리디렉션 기능이 실패하거나 리디렉션 또는 해결 약속이 거부 된 경우 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfcce92d36aeb1c520e9b5db15f22bee58c5791" translate="yes" xml:space="preserve">
          <source>Broadcasted if the same instance of a route (including template, controller instance, resolved dependencies, etc.) is being reused. This can happen if either &lt;code&gt;reloadOnSearch&lt;/code&gt; or &lt;code&gt;reloadOnUrl&lt;/code&gt; has been set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">라우트의 동일한 인스턴스 (템플릿, 컨트롤러 인스턴스, 해결 된 종속성 등 포함)가 재사용되는 경우 브로드 캐스팅됩니다. &lt;code&gt;reloadOnSearch&lt;/code&gt; 또는 &lt;code&gt;reloadOnUrl&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a8322d960d47320dc5989c276e6b8166c048003" translate="yes" xml:space="preserve">
          <source>Broadcasted when a scope and its children are being destroyed.</source>
          <target state="translated">스코프와 그 자식이 파괴 될 때 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="7d70e82b9c499004d1850cf08803f0ce4e7e5cfd" translate="yes" xml:space="preserve">
          <source>Browser in HTML5 Fallback mode (Hashbang mode)</source>
          <target state="translated">HTML5 대체 모드의 브라우저 (Hashbang 모드)</target>
        </trans-unit>
        <trans-unit id="ecc6c180b9874f1a6748cfecac7f942eda9570d6" translate="yes" xml:space="preserve">
          <source>Browser in HTML5 mode</source>
          <target state="translated">HTML5 모드의 브라우저</target>
        </trans-unit>
        <trans-unit id="e83b0bc612367cc74978d533e0e30cf24b965e7c" translate="yes" xml:space="preserve">
          <source>Built-in validation tokens:</source>
          <target state="translated">내장 된 검증 토큰 :</target>
        </trans-unit>
        <trans-unit id="02e264495bc8c8e6e9753884128090bbb591476a" translate="yes" xml:space="preserve">
          <source>But &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; has a dilemma.</source>
          <target state="translated">그러나 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; 에는 딜레마가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c3592d94e357cca81ab82eb84d5087a88626ed" translate="yes" xml:space="preserve">
          <source>But given that the token is just a string literal, sticking with the Value recipe is still more appropriate as it makes the code easier to follow.</source>
          <target state="translated">그러나 토큰은 문자열 리터럴이므로 코드를 더 쉽게 따라갈 수 있으므로 Value 레시피를 사용하는 것이 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fce344d9abbbab9562c13cd7f34c0b9da8dd4d9c" translate="yes" xml:space="preserve">
          <source>But unlike &lt;a href=&quot;%24provide#value.html&quot;&gt;value&lt;/a&gt;, a constant can be injected into a module configuration function (see &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;) and it cannot be overridden by an AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;decorator&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;%24provide#value.html&quot;&gt;값&lt;/a&gt; 과 달리 상수는 모듈 구성 함수 ( &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; &lt;/a&gt; 참조)에 삽입 될 수 있으며 AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;데코레이터&lt;/a&gt; 로 재정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="405847fd05efd79761c86b02e94559369547dbc6" translate="yes" xml:space="preserve">
          <source>By adding an &lt;code&gt;$inject&lt;/code&gt; property onto a function the injection parameters can be specified.</source>
          <target state="translated">함수에 &lt;code&gt;$inject&lt;/code&gt; 속성을 추가하면 주입 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa2da9f3a76efbcb9284be63afad1a9da922618" translate="yes" xml:space="preserve">
          <source>By default $animate doesn't trigger any animations. This is because the &lt;code&gt;ngAnimate&lt;/code&gt; module isn't included and only when it is active then the animation hooks that &lt;code&gt;$animate&lt;/code&gt; triggers will be functional. Once active then all structural &lt;code&gt;ng-&lt;/code&gt; directives will trigger animations as they perform their DOM-related operations (enter, leave and move). Other directives such as &lt;code&gt;ngClass&lt;/code&gt;, &lt;code&gt;ngShow&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt; and &lt;code&gt;ngMessages&lt;/code&gt; also provide support for animations.</source>
          <target state="translated">기본적으로 $ animate는 애니메이션을 트리거하지 않습니다. 이는 &lt;code&gt;ngAnimate&lt;/code&gt; 모듈이 포함되어 있지 않고 활성화 된 경우에만 &lt;code&gt;$animate&lt;/code&gt; 트리거가 작동하도록 하는 애니메이션 후크입니다 . 활성화 된 모든 구조되면 &lt;code&gt;ng-&lt;/code&gt; 그들의 DOM 관련 작업 (입력, 휴가 및 이동)을 수행 할 때 지침이 애니메이션을 트리거합니다. &lt;code&gt;ngClass&lt;/code&gt; , &lt;code&gt;ngShow&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; 및 &lt;code&gt;ngMessages&lt;/code&gt; 와 같은 다른 지시문 도 애니메이션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6a63f23b39aeafeeeef2f721b04b4097b6810a86" translate="yes" xml:space="preserve">
          <source>By default AngularJS attaches information about binding and scopes to DOM nodes, and adds CSS classes to data-bound elements:</source>
          <target state="translated">기본적으로 AngularJS는 바인딩 및 범위에 대한 정보를 DOM 노드에 연결하고 CSS 클래스를 데이터 바인딩 된 요소에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="370ccd1eb19dc0d611cfd9491b8afea309b7a0df" translate="yes" xml:space="preserve">
          <source>By default AngularJS compiles and executes all directives inside comments and element classes. In order to perform this task, the AngularJS compiler must look for directives by:</source>
          <target state="translated">기본적으로 AngularJS는 주석과 요소 클래스 내부의 모든 지시문을 컴파일하고 실행합니다. 이 작업을 수행하려면 AngularJS 컴파일러는 다음을 통해 지시문을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="1e2842d70be7f65d0a8c45bdabb3581c644cabee" translate="yes" xml:space="preserve">
          <source>By default you don't need to override anything in CSS and the animations will work around the display style.</source>
          <target state="translated">기본적으로 CSS에서 어떤 것도 무시할 필요가 없으며 애니메이션은 표시 스타일을 중심으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cfc9fd29727c805e8bcd27c2fd78719670ad599e" translate="yes" xml:space="preserve">
          <source>By default you don't need to override in CSS anything and the animations will work around the display style.</source>
          <target state="translated">기본적으로 CSS에서 재정의 할 필요는 없으며 애니메이션은 표시 스타일을 중심으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e2db882ad5f7a39f81879fd1d5e758ebc4f4597" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$anchorScroll()&lt;/a&gt; will automatically detect changes to &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; and scroll to the element matching the new hash.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$ anchorScroll ()&lt;/a&gt; 은 &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$ location.hash ()의&lt;/a&gt; 변경 사항을 자동으로 감지 하고 새 해시와 일치하는 요소로 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="c70a53728f1b21d2741de003d4f7d107644ad595" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;$sce&lt;/code&gt; will throw an error if it detects untrusted HTML content, and will not bind the content. However, if you include the &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize module&lt;/a&gt;, it will try to sanitize the potentially dangerous HTML, e.g. strip non-whitelisted tags and attributes when binding to &lt;code&gt;innerHTML&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;$sce&lt;/code&gt; 는 신뢰할 수없는 HTML 내용을 감지하면 내용을 바인딩하지 않으며 오류를 발생시킵니다. 그러나 &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize 모듈&lt;/a&gt; 을 포함하면 잠재적으로 위험한 HTML을 삭제하려고 시도합니다 (예 : &lt;code&gt;innerHTML&lt;/code&gt; 에 바인딩 할 때 화이트리스트에없는 태그 및 속성 제거) .</target>
        </trans-unit>
        <trans-unit id="79c69d18163b4e263908e7612db7c38c1f192b89" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngMessages&lt;/code&gt; will only display one message for a particular key/value collection at any time. If more than one message (or error) key is currently true, then which message is shown is determined by the order of messages in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have to prioritize messages using custom JavaScript code.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngMessages&lt;/code&gt; 는 언제든지 특정 키 / 값 수집에 대해 하나의 메시지 만 표시합니다. 둘 이상의 메시지 (또는 오류) 키가 현재 true 인 경우 표시되는 메시지는 HTML 템플리트 코드의 메시지 순서에 따라 결정됩니다 (먼저 선언 된 메시지가 우선 순위가 지정됨). 이 메커니즘은 개발자가 사용자 정의 JavaScript 코드를 사용하여 메시지의 우선 순위를 지정할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="24c1da0bbb6770f2b962ebbc35b060bf09623b8f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngModel&lt;/code&gt; watches the model by reference, not value. This is important to know when binding inputs to models that are objects (e.g. &lt;code&gt;Date&lt;/code&gt;) or collections (e.g. arrays). If only properties of the object or collection change, &lt;code&gt;ngModel&lt;/code&gt; will not be notified and so the input will not be re-rendered.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngModel&lt;/code&gt; 은 값이 아닌 참조로 모델을 감시합니다. 입력을 객체 (예 : &lt;code&gt;Date&lt;/code&gt; ) 또는 컬렉션 (예 : 배열) 인 모델에 바인딩 할 때 알아야 합니다. 객체 또는 컬렉션의 속성 만 변경되면 &lt;code&gt;ngModel&lt;/code&gt; 에 알리지 않으므로 입력이 다시 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7190d37e5aa54069ede2834cb78f273c5c43c428" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngModel&lt;/code&gt; watches the model by reference, not value. This is important to know when binding the select to a model that is an object or a collection.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngModel&lt;/code&gt; 은 값이 아닌 참조로 모델을 감시합니다. 선택을 개체 또는 컬렉션 인 모델에 바인딩 할 때 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="6903112b079eaf8ffdf3aec857a1afc48c94199d" translate="yes" xml:space="preserve">
          <source>By default, AngularJS only loads templates from the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on the template URL. To load templates from other domains and/or protocols, you may either &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelist them&lt;/a&gt; or &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;wrap it&lt;/a&gt; into a trusted value.</source>
          <target state="translated">기본적으로 AngularJS는 응용 프로그램 문서와 동일한 도메인 및 프로토콜의 템플릿 만로드합니다. 템플릿 URL에서 &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출하면됩니다 . 다른 도메인 및 / 또는 프로토콜에서 템플릿을로드하려면 템플릿을 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;허용 목록에 포함 시키&lt;/a&gt; 거나 신뢰할 수있는 값으로 줄 &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;바꿈 할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1966d304ab081cea6a8b5d7d37a52d0b976b638f" translate="yes" xml:space="preserve">
          <source>By default, animations are disabled when the AngularJS app &lt;a href=&quot;bootstrap&quot;&gt;bootstraps&lt;/a&gt;. If you are using the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ngApp&lt;/code&gt;&lt;/a&gt; directive, this happens in the &lt;code&gt;DOMContentLoaded&lt;/code&gt; event, so immediately after the page has been loaded. Animations are disabled, so that UI and content are instantly visible. Otherwise, with many animations on the page, the loading process may become too visually overwhelming, and the performance may suffer.</source>
          <target state="translated">AngularJS 앱이 &lt;a href=&quot;bootstrap&quot;&gt;부트 스트랩&lt;/a&gt; 될 때 애니메이션은 기본적으로 비활성화되어 있습니다 . &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ngApp&lt;/code&gt; &lt;/a&gt; 지시문을 사용하는 경우 이는 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 이벤트 에서 발생 하므로 페이지가로드 된 직후에 발생합니다. 애니메이션이 비활성화되어 UI와 내용을 즉시 볼 수 있습니다. 그렇지 않으면 페이지에 많은 애니메이션이 있으면로드 프로세스가 시각적으로 너무 압도되어 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4843033cbd0e8a2de04acc71992eef26af1ccc" translate="yes" xml:space="preserve">
          <source>By default, any &lt;code&gt;ngAnimate&lt;/code&gt;-enabled directives will assume that &lt;code&gt;transition&lt;/code&gt; / &lt;code&gt;animation&lt;/code&gt; styles on the element are part of an &lt;code&gt;ngAnimate&lt;/code&gt; animation. This can lead to problems when the styles are actually for animations that are independent of &lt;code&gt;ngAnimate&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngAnimate&lt;/code&gt; 사용 가능 지시문은 요소의 &lt;code&gt;transition&lt;/code&gt; / &lt;code&gt;animation&lt;/code&gt; 스타일이 &lt;code&gt;ngAnimate&lt;/code&gt; 애니메이션의 일부 라고 가정합니다 . 스타일이 실제로 &lt;code&gt;ngAnimate&lt;/code&gt; 와 독립적 인 애니메이션에 대한 경우 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a89e6cd1f35ad33962ebab128b602ce984b62740" translate="yes" xml:space="preserve">
          <source>By default, any change to the content will trigger a model update and form validation. You can override this behavior using the &lt;a href=&quot;../api/ng/directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; directive to bind only to specified list of events. I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'blur' }&quot;&lt;/code&gt; will update and validate only after the control loses focus. You can set several events using a space delimited list. I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'mousedown blur' }&quot;&lt;/code&gt;</source>
          <target state="translated">기본적으로 컨텐츠를 변경하면 모델 업데이트 및 양식 유효성 검사가 트리거됩니다. 지정된 이벤트 목록에만 바인딩하기 위해 &lt;a href=&quot;../api/ng/directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; 지시문을 사용하여이 동작을 재정의 할 수 있습니다 . 즉, &lt;code&gt;ng-model-options=&quot;{ updateOn: 'blur' }&quot;&lt;/code&gt; 은 컨트롤이 포커스를 잃은 후에 만 ​​업데이트하고 유효성을 검사합니다. 공백으로 구분 된 목록을 사용하여 여러 이벤트를 설정할 수 있습니다. 즉 &lt;code&gt;ng-model-options=&quot;{ updateOn: 'mousedown blur' }&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="500f830c32748a1f53ff5f9a7775baaecd3aa39e" translate="yes" xml:space="preserve">
          <source>By default, ngMock will create an injector per test case to ensure your tests do not affect each other. However, if we want to use &lt;code&gt;beforeAll()&lt;/code&gt;, ngMock will have to create the injector before any test cases are run, and share that injector through all the cases for that &lt;code&gt;describe&lt;/code&gt;. That is where &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector()&lt;/a&gt; comes in. When it's called within a &lt;code&gt;describe&lt;/code&gt; block, a single injector is shared between all hooks and test cases run in that block.</source>
          <target state="translated">기본적으로 ngMock은 테스트가 서로 영향을 미치지 않도록 테스트 사례별로 인젝터를 만듭니다. 그러나 &lt;code&gt;beforeAll()&lt;/code&gt; 을 사용하려면 ngMock 은 테스트 사례가 실행되기 전에 인젝터를 생성하고 해당 인젝터를 &lt;code&gt;describe&lt;/code&gt; 의 모든 사례를 통해 공유해야 합니다 . 곳이다 &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector ()가&lt;/a&gt; 제공됩니다. 그것이 내라고하면 &lt;code&gt;describe&lt;/code&gt; 블록을 하나의 인젝터가 그 블록에서 실행되는 모든 후크 및 테스트 케이스 사이에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="85a705fceaf0b765e21238642283db4e9a9de198" translate="yes" xml:space="preserve">
          <source>By default, query parameters on request URLs are parsed into the &lt;code&gt;params&lt;/code&gt; object. So a request URL of &lt;code&gt;/list?q=searchstr&amp;amp;orderby=-name&lt;/code&gt; would set &lt;code&gt;params&lt;/code&gt; to be &lt;code&gt;{q: 'searchstr', orderby: '-name'}&lt;/code&gt;.</source>
          <target state="translated">기본적으로 요청 URL의 쿼리 매개 변수는 &lt;code&gt;params&lt;/code&gt; 객체 로 구문 분석됩니다 . 의 요청 URL 그래서 &lt;code&gt;/list?q=searchstr&amp;amp;orderby=-name&lt;/code&gt; 설정합니다 &lt;code&gt;params&lt;/code&gt; 수 &lt;code&gt;{q: 'searchstr', orderby: '-name'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7198ac8768b77ff593616dc4b6e2aca0b18676a4" translate="yes" xml:space="preserve">
          <source>By default, the &quot;required&quot; error on the ngModelController is only set on a required select when the empty option is selected. This example adds a custom directive that also sets the error when the unknown option is selected.</source>
          <target state="translated">기본적으로 ngModelController의 &quot;필수&quot;오류는 빈 옵션이 선택된 경우 필수 선택에서만 설정됩니다. 이 예제는 알 수없는 옵션을 선택할 때 오류를 설정하는 사용자 지정 지시문을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e221e45c15e66ddc82e3f4a4feda670a95e982cd" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt;&lt;code&gt;$watch&lt;/code&gt;&lt;/a&gt; method is used for tracking changes, and the equality check is based on object identity. However, if an object literal or an array literal is passed as the binding expression, the equality check is done by value (using the &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; function). It's also possible to watch the evaluated value shallowly with &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt;&lt;code&gt;$watchCollection&lt;/code&gt;&lt;/a&gt;: use &lt;code&gt;=*&lt;/code&gt; or &lt;code&gt;=*attr&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt; &lt;code&gt;$watch&lt;/code&gt; &lt;/a&gt; 메소드는 변경 사항을 추적하는 데 사용되며 동등성 검사는 개체 ID를 기반으로합니다. 그러나 객체 리터럴 또는 배열 리터럴이 바인딩 표현식으로 전달되면 값에 의해 동등성 검사가 수행됩니다 ( &lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;/a&gt; 함수 사용). &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt; &lt;code&gt;$watchCollection&lt;/code&gt; &lt;/a&gt; 사용 하여 평가 된 값을 얕게 볼 수도 있습니다 . use &lt;code&gt;=*&lt;/code&gt; 또는 &lt;code&gt;=*attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0973385c3a816fcb28f0098577f72a074edba112" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt;&lt;code&gt;$watch&lt;/code&gt;&lt;/a&gt; method is used for tracking changes, and the equality check is based on object identity. It's also possible to watch the evaluated value shallowly with &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt;&lt;code&gt;$watchCollection&lt;/code&gt;&lt;/a&gt;: use &lt;code&gt;&amp;lt;*&lt;/code&gt; or &lt;code&gt;&amp;lt;*attr&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt; &lt;code&gt;$watch&lt;/code&gt; &lt;/a&gt; 메소드는 변경 사항을 추적하는 데 사용되며 동등성 검사는 개체 ID를 기반으로합니다. &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt; &lt;code&gt;$watchCollection&lt;/code&gt; &lt;/a&gt; 평가 된 값을 얕게 볼 수도 있습니다 : use &lt;code&gt;&amp;lt;*&lt;/code&gt; or &lt;code&gt;&amp;lt;*attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb24723013a0e6e79cb996d2a10e6b4c5257acc0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;.ng-hide&lt;/code&gt; class will style the element with &lt;code&gt;display: none !important&lt;/code&gt;. If you wish to change the hide behavior with &lt;code&gt;ngShow&lt;/code&gt;/&lt;code&gt;ngHide&lt;/code&gt;, you can simply overwrite the styles for the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class. Note that the selector that needs to be used is actually &lt;code&gt;.ng-hide:not(.ng-hide-animate)&lt;/code&gt; to cope with extra animation classes that can be added.</source>
          <target state="translated">기본적으로 &lt;code&gt;.ng-hide&lt;/code&gt; 클래스는 &lt;code&gt;display: none !important&lt;/code&gt; 요소의 스타일을 지정합니다 . &lt;code&gt;ngShow&lt;/code&gt; / &lt;code&gt;ngHide&lt;/code&gt; 로 숨기기 동작을 변경 하려면 &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스 의 스타일을 덮어 쓰면 됩니다. 사용해야 할 선택기는 실제로 추가 할 수있는 추가 애니메이션 클래스에 대처하기 위해 &lt;code&gt;.ng-hide:not(.ng-hide-animate)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fce47139951721d70fff4365f4ba57737c92ef63" translate="yes" xml:space="preserve">
          <source>By default, the template URL is restricted to the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on it. To load templates from other domains or protocols you may either &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelist them&lt;/a&gt; or &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;wrap them&lt;/a&gt; as trusted values. Refer to AngularJS's &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping&lt;/a&gt;.</source>
          <target state="translated">기본적으로 템플릿 URL은 응용 프로그램 문서와 동일한 도메인 및 프로토콜로 제한됩니다. &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출 하면됩니다. 다른 도메인이나 프로토콜에서 템플릿을로드하려면 해당 템플릿을 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;화이트리스트에 추가&lt;/a&gt; 하거나 신뢰할 수있는 값으로 &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;래핑 할&lt;/a&gt; 수 있습니다. AngularJS의 &lt;a href=&quot;../service/%24sce&quot;&gt;엄격한 컨텍스트 이스케이프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32e44cbd14ed433730fe544c3bfd62ca5f7ab6e5" translate="yes" xml:space="preserve">
          <source>By default, trailing slashes will be stripped from the calculated URLs, which can pose problems with server backends that do not expect that behavior. This can be disabled by configuring the &lt;code&gt;$resourceProvider&lt;/code&gt; like this:</source>
          <target state="translated">기본적으로 후행 슬래시는 계산 된 URL에서 제거되므로 해당 동작이 예상되지 않는 서버 백엔드에 문제가 발생할 수 있습니다. &lt;code&gt;$resourceProvider&lt;/code&gt; 과 같이 구성하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="523150288e3d3cbcdab71e7b4b769b8742b51985" translate="yes" xml:space="preserve">
          <source>By enabling this setting without taking other precautions, you might expose your application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned outside of the containing element and be rendered over other elements on the page (e.g. a login link). Such behavior can then result in phishing incidents.</source>
          <target state="translated">다른 예방 조치를 취하지 않고이 설정을 활성화하면 응용 프로그램이 클릭 하이재킹 공격에 노출 될 수 있습니다. 이러한 공격에서 위생 처리 된 svg 요소는 포함 요소 외부에 배치되어 페이지의 다른 요소 (예 : 로그인 링크) 위에 렌더링 될 수 있습니다. 그런 동작으로 피싱 사고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa28a200094d0f8e4952a2572b5bf5b51a4cfccf" translate="yes" xml:space="preserve">
          <source>By implementing these methods, your component can hook into its lifecycle.</source>
          <target state="translated">이러한 방법을 구현하면 구성 요소를 수명주기에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c9ccc283e35e9d7b41129880c9316c7594e9f5" translate="yes" xml:space="preserve">
          <source>By listening to this event, you can remove event listeners that might cause memory leaks. Listeners registered to scopes and elements are automatically cleaned up when they are destroyed, but if you registered a listener on a service, or registered a listener on a DOM node that isn't being deleted, you'll have to clean it up yourself or you risk introducing a memory leak.</source>
          <target state="translated">이 이벤트를 수신하면 메모리 누수를 일으킬 수있는 이벤트 리스너를 제거 할 수 있습니다. 스코프 및 요소에 등록 된 리스너는 소멸 될 때 자동으로 정리되지만 서비스에 리스너를 등록하거나 삭제되지 않은 DOM 노드에 리스너를 등록한 경우 직접 정리해야합니다. 메모리 누수가 발생할 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c171fe9b3aaa70bdfa6d6276dcd49d45e27676fa" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;transition: 0s&lt;/code&gt;, &lt;code&gt;ngAnimate&lt;/code&gt; will ignore the existing transition styles, and not try to animate them (Javascript animations will still execute, though). This can be used to prevent &lt;a href=&quot;animations#preventing-collisions-with-existing-animations-and-third-party-libraries.html&quot;&gt;issues with existing animations interfering with &lt;code&gt;ngAnimate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transition: 0s&lt;/code&gt; 를 설정 하면 &lt;code&gt;ngAnimate&lt;/code&gt; 는 기존 전환 스타일을 무시하고 애니메이션을 적용하지 않습니다 (Javascript 애니메이션은 계속 실행 됨). &lt;a href=&quot;animations#preventing-collisions-with-existing-animations-and-third-party-libraries.html&quot;&gt;기존 애니메이션이 &lt;code&gt;ngAnimate&lt;/code&gt; 를&lt;/a&gt; 방해 하는 문제 를 방지하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="763c7e134cede96adf42badc199f39b157262036" translate="yes" xml:space="preserve">
          <source>By setting the &lt;code&gt;getterSetter&lt;/code&gt; property to true you are telling ngModel that the &lt;code&gt;ngModel&lt;/code&gt; expression on the scope refers to a &quot;getter/setter&quot; function rather than the value itself.</source>
          <target state="translated">&lt;code&gt;getterSetter&lt;/code&gt; 속성을 true 로 설정하면 범위 의 &lt;code&gt;ngModel&lt;/code&gt; 표현식이 값 자체가 아닌 &quot;getter / setter&quot;함수를 참조 한다고 ngModel에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d37d16187a12d14dca29958bee98c95dd2595b03" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;!important&lt;/code&gt;, the show and hide behavior will work as expected despite any clash between CSS selector specificity (when &lt;code&gt;!important&lt;/code&gt; isn't used with any conflicting styles). If a developer chooses to override the styling to change how to hide an element then it is just a matter of using &lt;code&gt;!important&lt;/code&gt; in their own CSS code.</source>
          <target state="translated">&lt;code&gt;!important&lt;/code&gt; 를 사용 하면 CSS 선택기의 특수성 ( &lt;code&gt;!important&lt;/code&gt; 가 충돌하는 스타일과 함께 사용되지 않는 경우)간에 충돌이 발생하더라도 show 및 hide 동작이 예상대로 작동 합니다. 개발자가 스타일을 재정 의하여 요소를 숨기는 방법을 변경하기로 결정한 경우 자체 CSS 코드에서 &lt;code&gt;!important&lt;/code&gt; 를 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7870cd0f2f0c17b236bdc86d6ea708504a5cb8" translate="yes" xml:space="preserve">
          <source>CSS + JS Animations Together</source>
          <target state="translated">CSS + JS 애니메이션</target>
        </trans-unit>
        <trans-unit id="43bd3c1e45e7e9c523e66a4eeb74db09cdd9706e" translate="yes" xml:space="preserve">
          <source>CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out what CSS classes differ between the starting element and the destination element. These different CSS classes will be added/removed on the anchor element and a transition will be applied (the transition that is provided in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since the cloned element is placed inside of root element which is likely close to the body element).</source>
          <target state="translated">CSS Anchoring은 전환과 키 프레임에 의존하며 내부 코드는 시작 요소와 대상 요소 사이의 CSS 클래스가 무엇인지 파악할 수있을 정도로 지능적입니다. 이러한 다른 CSS 클래스는 앵커 요소에서 추가 / 제거되고 전환 (앵커 클래스에서 제공되는 전환)이 적용됩니다. 간단히 말해, ngAnimate는 추가 및 제거 할 클래스를 찾아서 요소를 최대한 부드럽고 자동으로 전환합니다. 앵커 요소가 시작 요소와 동일하게 표시되도록 DOM 중첩 구조에 의존하지 않는 간단한 CSS 클래스를 사용해야합니다 (복제 요소가 본문 요소에 가까운 루트 요소 내에 배치되므로).</target>
        </trans-unit>
        <trans-unit id="0f55d5c092d0ff662c046991d7571e5ba312c6ba" translate="yes" xml:space="preserve">
          <source>CSS Class-based Animations</source>
          <target state="translated">CSS 클래스 기반 애니메이션</target>
        </trans-unit>
        <trans-unit id="bbe967875f19b43ebcf8ae9cc8592cc142b0fc64" translate="yes" xml:space="preserve">
          <source>CSS Staggering Animations</source>
          <target state="translated">CSS 스 태거 애니메이션</target>
        </trans-unit>
        <trans-unit id="21444efa9494abd66434381371c755d1d31f0244" translate="yes" xml:space="preserve">
          <source>CSS classes</source>
          <target state="translated">CSS 클래스</target>
        </trans-unit>
        <trans-unit id="4785c5decce46adb9da8916ce47b654ac25c1fa0" translate="yes" xml:space="preserve">
          <source>CSS-based Animations</source>
          <target state="translated">CSS 기반 애니메이션</target>
        </trans-unit>
        <trans-unit id="b0a851e9310143c493ee5626ebda91ac22925d52" translate="yes" xml:space="preserve">
          <source>CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML and CSS code we can create an animation that will be picked up by AngularJS when an underlying directive performs an operation.</source>
          <target state="translated">ngAnimate를 사용하는 CSS 기반 애니메이션은 JavaScript 코드가 전혀 필요하지 않으므로 고유합니다. HTML과 CSS 코드 사이에서 참조하는 CSS 클래스를 사용하여 기본 지시문이 작업을 수행 할 때 AngularJS가 선택할 애니메이션을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2cd38d164b13f9a7249cbfb4a4b5ef9fc8b5c5d" translate="yes" xml:space="preserve">
          <source>Cache name of the template.</source>
          <target state="translated">템플릿의 캐시 이름.</target>
        </trans-unit>
        <trans-unit id="4841830df2aa5c0a9fdc5cf539d835c1b65395ec" translate="yes" xml:space="preserve">
          <source>Cache object identified by the cacheId or undefined if no such cache.</source>
          <target state="translated">cacheId로 식별 된 캐시 오브젝트 또는 그러한 캐시가없는 경우 정의되지 않음.</target>
        </trans-unit>
        <trans-unit id="322c7ca089e85e4cdaa343c933e86bd05885e89f" translate="yes" xml:space="preserve">
          <source>Cached responses are returned asynchronously, in the same way as responses from the server.</source>
          <target state="translated">캐시 된 응답은 서버의 응답과 같은 방식으로 비동기식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="78d83114a9f21cb004c811c700f1ebf657586754" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;compiler&quot;&gt;compile&lt;/a&gt; the element into an executable, bi-directionally bound application.</source>
          <target state="translated">&lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; 을 호출 하여 양방향으로 바인딩 된 실행 가능한 응용 프로그램으로 요소 를 &lt;a href=&quot;compiler&quot;&gt;컴파일&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b162081de98877f8d47457aad07d35f7c7120470" translate="yes" xml:space="preserve">
          <source>Call this method as a setter to enable/disable eager instantiation of the &lt;a href=&quot;../service/%24route&quot;&gt;$route&lt;/a&gt; service upon application bootstrap. You can also call it as a getter (i.e. without any arguments) to get the current value of the &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; flag.</source>
          <target state="translated">응용 프로그램 부트 스트랩 에서 &lt;a href=&quot;../service/%24route&quot;&gt;$ route&lt;/a&gt; 서비스 의 빠른 인스턴스화를 활성화 / 비활성화하려면이 메소드를 setter로 호출하십시오 . 또한 &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; 의 현재 값을 얻기 위해 getter (인수없이)로 호출 할 수도 있습니다. 플래그 .</target>
        </trans-unit>
        <trans-unit id="e14131abb69b67447b042d7e96d77593367604f4" translate="yes" xml:space="preserve">
          <source>Call this method to determine if this scope has been explicitly suspended. It will not tell you whether an ancestor has been suspended. To determine if this scope will be excluded from a digest triggered at the $rootScope, for example, you must check all its ancestors:</source>
          <target state="translated">이 범위를 명시 적으로 일시 중단했는지 확인하려면이 메서드를 호출하십시오. 조상이 정지되었는지 여부는 알려주지 않습니다. 예를 들어, $ rootScope에서 트리거 된 다이제스트에서이 범위가 제외되는지 확인하려면 모든 조상을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f35d12cb9238244359750cfa0d0a76f474d059bf" translate="yes" xml:space="preserve">
          <source>Call this method to enable / disable the strict component bindings check. If enabled, the compiler will enforce that all scope / controller bindings of a &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;directive&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;component&lt;/a&gt; that are not set as optional with &lt;code&gt;?&lt;/code&gt;, must be provided when the directive is instantiated. If not provided, the compiler will throw the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$compile:missingattr error&lt;/a&gt;.</source>
          <target state="translated">엄격한 컴포넌트 바인딩 확인을 사용하거나 사용하지 않으려면이 메소드를 호출하십시오. 활성화 된 경우 컴파일러는 &lt;code&gt;?&lt;/code&gt; 옵션으로 설정되지 않은 &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;구성 요소&lt;/a&gt; 의 모든 범위 / 컨트롤러 바인딩을 강제 실행 합니까? 지시문이 인스턴스화 될 때 제공되어야합니다. 제공하지 않으면 컴파일러는 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$ compile : missingattr error를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4eaaf9dbe4e310951ac61cd764aaa491556cb9" translate="yes" xml:space="preserve">
          <source>Call this method to enable/disable various debug runtime information in the compiler such as adding binding information and a reference to the current scope on to DOM elements. If enabled, the compiler will add the following to DOM elements that have been bound to the scope</source>
          <target state="translated">바인딩 정보 및 DOM 요소에 대한 현재 범위에 대한 참조 추가와 같은 컴파일러에서 다양한 디버그 런타임 정보를 활성화 / 비활성화하려면이 메소드를 호출하십시오. 활성화 된 경우 컴파일러는 범위에 바인딩 된 DOM 요소에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1440403750e2ed45b458c5ac229f85fb683fa150" translate="yes" xml:space="preserve">
          <source>Callback called whenever the return value of any expression in &lt;code&gt;watchExpressions&lt;/code&gt; changes The &lt;code&gt;newValues&lt;/code&gt; array contains the current values of the &lt;code&gt;watchExpressions&lt;/code&gt;, with the indexes matching those of &lt;code&gt;watchExpression&lt;/code&gt; and the &lt;code&gt;oldValues&lt;/code&gt; array contains the previous values of the &lt;code&gt;watchExpressions&lt;/code&gt;, with the indexes matching those of &lt;code&gt;watchExpression&lt;/code&gt; The &lt;code&gt;scope&lt;/code&gt; refers to the current scope.</source>
          <target state="translated">어떤 식의 리턴 값마다 콜백 전화 &lt;code&gt;watchExpressions&lt;/code&gt; 가 변경 &lt;code&gt;newValues&lt;/code&gt; 의 배열은 현재의 값이 포함 &lt;code&gt;watchExpressions&lt;/code&gt; 을 들과 일치하는 인덱스, &lt;code&gt;watchExpression&lt;/code&gt; 을 상기 &lt;code&gt;oldValues&lt;/code&gt; 의 배열은 이전 값을 포함 &lt;code&gt;watchExpressions&lt;/code&gt; 을 들과 일치하는 인덱스, &lt;code&gt;watchExpression&lt;/code&gt; 을 &lt;code&gt;scope&lt;/code&gt; 는 현재 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d70eaf5bd89066c1b42f522abbd8dee8568dd708" translate="yes" xml:space="preserve">
          <source>Callback called whenever the value of &lt;code&gt;watchExpression&lt;/code&gt; changes.</source>
          <target state="translated">&lt;code&gt;watchExpression&lt;/code&gt; 값이 변경 될 때마다 콜백이 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c689cdead0e90f013714cd4077f4ea01b650f8c" translate="yes" xml:space="preserve">
          <source>Callbacks and Promises</source>
          <target state="translated">콜백 및 약속</target>
        </trans-unit>
        <trans-unit id="6f75995f3b255bdefeacf9e236456a83f540b1a9" translate="yes" xml:space="preserve">
          <source>Called when the view needs to be updated. It is expected that the user of the ng-model directive will implement this method.</source>
          <target state="translated">뷰를 업데이트해야 할 때 호출됩니다. ng-model 지시문의 사용자가이 메소드를 구현할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="63675a1d70484b5f1fc1c3405a8ded5f332fcc61" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;$digest()&lt;/code&gt; directly on a descendant of a suspended scope will still run the watchers for that scope and its descendants. When digesting we only check whether the current scope is locally suspended, rather than checking whether it has a suspended ancestor.</source>
          <target state="translated">일시 중단 된 범위의 하위 항목에서 &lt;code&gt;$digest()&lt;/code&gt; 직접 호출 하면 해당 범위 및 해당 하위 항목의 감시자가 계속 실행됩니다. 다이제스트 할 때 조상이 일시 중단되었는지 확인하는 것이 아니라 현재 범위가 로컬로 일시 중단되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="49fc3e72976c3ca65e702be767e99bb84f601ccf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;$resume()&lt;/code&gt; on a scope that has a suspended ancestor will not cause the scope to be included in future digests until all its ancestors have been resumed.</source>
          <target state="translated">조상이 일시 중단 된 범위에서 &lt;code&gt;$resume()&lt;/code&gt; 을 호출 하면 모든 조상이 다시 시작될 때까지 이후 다이제스트에 해당 범위가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20c938d13e09b0f80b5576ad14ce6af88219cf0d" translate="yes" xml:space="preserve">
          <source>Calling the linking function returns the element of the template. It is either the original element passed in, or the clone of the element if the &lt;code&gt;cloneAttachFn&lt;/code&gt; is provided.</source>
          <target state="translated">연결 함수를 호출하면 템플릿의 요소가 반환됩니다. &lt;code&gt;cloneAttachFn&lt;/code&gt; 이 제공된 경우 전달 된 원래 요소이거나 요소의 복제본입니다 .</target>
        </trans-unit>
        <trans-unit id="e6781591ce11dba9f9d2938ebe354ec4a507a51c" translate="yes" xml:space="preserve">
          <source>Calling these methods invoke &lt;a href=&quot;../../ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; with the specified http method, destination and parameters. When the data is returned from the server then the object is an instance of the resource class. The actions &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; are available on it as methods with the &lt;code&gt;$&lt;/code&gt; prefix. This allows you to easily perform CRUD operations (create, read, update, delete) on server-side data like this:</source>
          <target state="translated">이러한 메소드를 호출 하면 지정된 http 메소드, 대상 및 매개 변수로 &lt;a href=&quot;../../ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 가 호출 됩니다. 서버에서 데이터가 리턴되면 오브젝트는 자원 클래스의 인스턴스입니다. &lt;code&gt;save&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 조치 는 &lt;code&gt;$&lt;/code&gt; 접 두부 가있는 메소드로 사용 가능 합니다. 이를 통해 다음과 같이 서버 측 데이터에서 CRUD 작업 (만들기, 읽기, 업데이트, 삭제)을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31893b7919db92062b0a54add3dc3c1b08b461ce" translate="yes" xml:space="preserve">
          <source>Calling these methods invokes &lt;code&gt;$http&lt;/code&gt; on the &lt;code&gt;url&lt;/code&gt; template with the given HTTP &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;headers&lt;/code&gt;.</source>
          <target state="translated">이러한 메소드를 호출 하면 주어진 HTTP &lt;code&gt;method&lt;/code&gt; , &lt;code&gt;params&lt;/code&gt; 및 &lt;code&gt;headers&lt;/code&gt; 를 사용하여 &lt;code&gt;url&lt;/code&gt; 템플리트 에서 &lt;code&gt;$http&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="91a3b32b3f576fa1a25afa0ab7e2394916694e74" translate="yes" xml:space="preserve">
          <source>Calling this function with false disables the compilation of directives on comments for the whole application. This results in a compilation performance gain, as the compiler doesn't have to check comments when looking for directives. This should however only be used if you are sure that no comment directives are used in the application (including any 3rd party directives).</source>
          <target state="translated">이 함수를 false로 호출하면 전체 응용 프로그램의 주석에 대한 지시문 컴파일이 비활성화됩니다. 컴파일러가 지시문을 찾을 때 주석을 확인할 필요가 없기 때문에 컴파일 성능이 향상됩니다. 그러나 응용 프로그램에 주석 지시문이 사용되지 않은 경우 (타사 지시문 포함)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbbb4b5eaa44b0b5551e31e4b0525bc03141436e" translate="yes" xml:space="preserve">
          <source>Calling this function with false disables the compilation of directives on element classes for the whole application. This results in a compilation performance gain, as the compiler doesn't have to check element classes when looking for directives. This should however only be used if you are sure that no class directives are used in the application (including any 3rd party directives).</source>
          <target state="translated">이 함수를 false로 호출하면 전체 응용 프로그램의 요소 클래스에서 지시문 컴파일이 비활성화됩니다. 컴파일러가 지시문을 찾을 때 요소 클래스를 확인할 필요가 없기 때문에 컴파일 성능이 향상됩니다. 그러나 응용 프로그램에서 클래스 지시문이 사용되지 않는 경우 (타사 지시문 포함)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a4aefee23fa0c2ddc499c67e421bc097332c1e9" translate="yes" xml:space="preserve">
          <source>Can I disable SCE completely?</source>
          <target state="translated">SCE를 완전히 비활성화 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="38a4b640b107f7de6465c3ff929cb568050eaed3" translate="yes" xml:space="preserve">
          <source>Can be one of:</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3816f23c92cddb7d9eb035e560daee147a023eaf" translate="yes" xml:space="preserve">
          <source>Cancel an update and reset the input element's value to prevent an update to the &lt;code&gt;$modelValue&lt;/code&gt;, which may be caused by a pending debounced event or because the input is waiting for some future event.</source>
          <target state="translated">보류중인 디 바운스 된 이벤트로 인해 또는 입력이 향후 이벤트를 기다리고 있기 때문에 &lt;code&gt;$modelValue&lt;/code&gt; 대한 업데이트를 방지하려면 업데이트를 취소하고 입력 요소의 값을 재설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="da189d192d9888fffe6e40083bb8393ace97b3e9" translate="yes" xml:space="preserve">
          <source>Cancelling requests</source>
          <target state="translated">요청 취소</target>
        </trans-unit>
        <trans-unit id="838a9d672c095a05992dfe53058bf7ccd9ff411d" translate="yes" xml:space="preserve">
          <source>Cancels a task associated with the &lt;code&gt;promise&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise&lt;/code&gt; 과 관련된 작업을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="5fc80b14e6aaae3cc1ada473f23aa327b69f4333" translate="yes" xml:space="preserve">
          <source>Cancels a task associated with the &lt;code&gt;promise&lt;/code&gt;. As a result of this, the promise will be resolved with a rejection.</source>
          <target state="translated">&lt;code&gt;promise&lt;/code&gt; 과 관련된 작업을 취소합니다 . 그 결과 약속은 거절로 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="edecf4dc2de919262a28ba9a2f7840added3c399" translate="yes" xml:space="preserve">
          <source>Cancels the provided animation and applies the end state of the animation. Note that this does not cancel the underlying operation, e.g. the setting of classes or adding the element to the DOM.</source>
          <target state="translated">제공된 애니메이션을 취소하고 애니메이션의 종료 상태를 적용합니다. 이렇게하면 기본 설정 (예 : 클래스 설정 또는 요소를 DOM에 추가)이 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43a94b1cd16e828fd25f079b0c6f119d1c492ce3" translate="yes" xml:space="preserve">
          <source>Case Studies</source>
          <target state="translated">사례 연구</target>
        </trans-unit>
        <trans-unit id="f2e31c0705378a0ca912d442b249a5361708204c" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;$route&lt;/code&gt; service to reload the current route even if &lt;a href=&quot;../../ng/service/%24location&quot;&gt;$location&lt;/a&gt; hasn't changed.</source>
          <target state="translated">원인 &lt;code&gt;$route&lt;/code&gt; 경우에도 현재의 경로를 다시로드 서비스 &lt;a href=&quot;../../ng/service/%24location&quot;&gt;$ 위치가&lt;/a&gt; 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="60afdcebb41362038962725243c0aed09552fc50" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;$route&lt;/code&gt; service to update the current URL, replacing current route parameters with those specified in &lt;code&gt;newParams&lt;/code&gt;. Provided property names that match the route's path segment definitions will be interpolated into the location's path, while remaining properties will be treated as query params.</source>
          <target state="translated">원인 &lt;code&gt;$route&lt;/code&gt; 에 지정된 전류 경로 매개 변수 교체, 현재 URL을 업데이트 서비스를 &lt;code&gt;newParams&lt;/code&gt; 을 . 라우트의 경로 세그먼트 정의와 일치하는 제공된 특성 이름은 위치의 경로로 보간되며 나머지 특성은 쿼리 매개 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="72d71a668e56adbe90d2fa9fb6ee8972c0b66e4a" translate="yes" xml:space="preserve">
          <source>Chaining promises</source>
          <target state="translated">연쇄 약속</target>
        </trans-unit>
        <trans-unit id="58e493046d8fd6e3081b6c746a33e60405b9effa" translate="yes" xml:space="preserve">
          <source>Change path when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 경로를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca2424dc0deb99a58c19e534f338127124d9aab" translate="yes" xml:space="preserve">
          <source>Change path, search and hash, when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 경로, 검색 및 해시를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="da91b66135a4f77c9cc08ce3eaa7130f2a6d2b72" translate="yes" xml:space="preserve">
          <source>Change search part when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 검색 파트를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="c02c34ae53310357e58911c775459e9c3de3ba96" translate="yes" xml:space="preserve">
          <source>Change the URL.</source>
          <target state="translated">URL을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="927385537fbe1015a617be665c6693f672fb3a52" translate="yes" xml:space="preserve">
          <source>Change the history state object when called with one parameter and return &lt;code&gt;$location&lt;/code&gt;. The state object is later passed to &lt;code&gt;pushState&lt;/code&gt; or &lt;code&gt;replaceState&lt;/code&gt;.</source>
          <target state="translated">하나의 매개 변수로 호출 될 때 히스토리 상태 오브젝트를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 . 상태 객체는 나중에 &lt;code&gt;pushState&lt;/code&gt; 또는 &lt;code&gt;replaceState&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fa9f4c8eaa824574dae37f62154980d60ca28a4" translate="yes" xml:space="preserve">
          <source>Change the validity state of the form, and notify the parent form (if any).</source>
          <target state="translated">양식의 유효성 상태를 변경하고 부모 양식 (있는 경우)에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="667e7970ed20e88c4e980d20c8d0629557dd7400" translate="yes" xml:space="preserve">
          <source>Change the validity state, and notify the form.</source>
          <target state="translated">유효성 상태를 변경하고 양식에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="1403f945a22ede84f416992deee9c6911dc2c57f" translate="yes" xml:space="preserve">
          <source>Changes the address bar.</source>
          <target state="translated">주소 표시 줄을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="318dfbf2d67fa7b4fded5ca142121201dcf2c9ef" translate="yes" xml:space="preserve">
          <source>Changes the address in the browser's address bar.</source>
          <target state="translated">브라우저의 주소 표시 줄에서 주소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5b764ac2b679596bebc6492993329bbb0d3fd0d8" translate="yes" xml:space="preserve">
          <source>Changes the hash fragment when called with a parameter and returns &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 해시 조각을 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c0bb203b42d991b17fac172d8578a01b132de763" translate="yes" xml:space="preserve">
          <source>Changes to the model inside &lt;code&gt;$doCheck&lt;/code&gt; will trigger new turns of the digest loop, which will cause the changes to be propagated throughout the application. Angular does not allow the &lt;code&gt;ngDoCheck&lt;/code&gt; hook to trigger a change outside of the component. It will either throw an error or do nothing depending upon the state of &lt;code&gt;enableProdMode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$doCheck&lt;/code&gt; 내에서 모델을 변경 하면 다이제스트 루프의 새로운 회전이 트리거되어 변경 사항이 애플리케이션 전체에 전파됩니다. Angular는 &lt;code&gt;ngDoCheck&lt;/code&gt; 후크가 컴포넌트 외부에서 변경을 트리거 할 수 없습니다 . &lt;code&gt;enableProdMode()&lt;/code&gt; 상태에 따라 오류가 발생하거나 아무 것도 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7409e3021a2ae10433e51958a73352a869dfdffa" translate="yes" xml:space="preserve">
          <source>Changing parameters dynamically</source>
          <target state="translated">동적으로 매개 변수 변경</target>
        </trans-unit>
        <trans-unit id="5e785584860674d65fa52977c48c6a2d8ab7530e" translate="yes" xml:space="preserve">
          <source>ChildRouter</source>
          <target state="translated">ChildRouter</target>
        </trans-unit>
        <trans-unit id="395f9525e05660c43c121056b86241cf54b50bdc" translate="yes" xml:space="preserve">
          <source>Choose: &lt;code&gt;angular-[version].js&lt;/code&gt; for a human-readable file, suitable for development and debugging.</source>
          <target state="translated">개발 및 디버깅에 적합한 사람이 읽을 수있는 파일의 경우 &lt;code&gt;angular-[version].js&lt;/code&gt; 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d01471977547f403988a18fa90d7812ed92cad5" translate="yes" xml:space="preserve">
          <source>Choose: &lt;code&gt;angular-[version].min.js&lt;/code&gt; for a compressed and obfuscated file, suitable for use in production.</source>
          <target state="translated">프로덕션에 사용하기에 적합한 압축 및 난독 처리 된 파일의 경우 &lt;code&gt;angular-[version].min.js&lt;/code&gt; 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0fa5d9e8c5bdec155184c067e6fec7c8bb15af2" translate="yes" xml:space="preserve">
          <source>Choosing between ngRepeat and ngOptions</source>
          <target state="translated">ngRepeat와 ngOptions 중에서 선택</target>
        </trans-unit>
        <trans-unit id="6f950f66f6524d1d6d701a16679a2f3ae7d90d78" translate="yes" xml:space="preserve">
          <source>Chrome Accessibility Developer Tools</source>
          <target state="translated">Chrome 접근성 개발자 도구</target>
        </trans-unit>
        <trans-unit id="71c207df916db009b3057f6560a48a47fcc25310" translate="yes" xml:space="preserve">
          <source>Class actions return an empty instance (with the additional properties listed below). Instance actions return a promise for the operation.</source>
          <target state="translated">클래스 작업은 빈 인스턴스를 반환합니다 (아래에 나열된 추가 속성 포함). 인스턴스 작업은 작업에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ec0ce07d9481bf4db4c020b148a12c1b4c3112a" translate="yes" xml:space="preserve">
          <source>Class and ngClass animation hooks</source>
          <target state="translated">클래스 및 ngClass 애니메이션 후크</target>
        </trans-unit>
        <trans-unit id="2a0863a04b4ee272c83f2a94dd23442cc0eb6c51" translate="yes" xml:space="preserve">
          <source>Class-based animations (animations that are triggered via &lt;code&gt;ngClass&lt;/code&gt;, &lt;code&gt;ngShow&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt; and some other directives) have a slightly different naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added and removed.</source>
          <target state="translated">클래스 기반 애니메이션 ( &lt;code&gt;ngClass&lt;/code&gt; , &lt;code&gt;ngShow&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; 및 기타 지시문을 통해 트리거되는 애니메이션 )의 명명 규칙은 약간 다릅니다. 클래스 기반 애니메이션은 표준 전환 또는 키 프레임을 추가 및 제거중인 클래스에서 참조 할 수있을 정도로 기본적입니다.</target>
        </trans-unit>
        <trans-unit id="9191759140319ff20e9dd16485bf237db76b0c98" translate="yes" xml:space="preserve">
          <source>Clears the cache object of any entries.</source>
          <target state="translated">모든 항목의 캐시 개체를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e515212a1c11de2835082ada05e6ec961879403e" translate="yes" xml:space="preserve">
          <source>Click here &lt;a href=&quot;../../ng/service/%24animate&quot;&gt;to learn more about animations with &lt;code&gt;$animate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; &lt;/a&gt; 애니메이션에 대한 자세한 내용을 보려면 여기 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4fed55c7291e2ae4022dc03f74858153d78fbbe" translate="yes" xml:space="preserve">
          <source>Click here &lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;to read the documentation for $animateCss&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;$ animateCss 설명서를 읽으&lt;/a&gt; 려면 여기 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="32484b33993cf9537f02013fd9f85c2ec6cd936f" translate="yes" xml:space="preserve">
          <source>Clicking on the &quot;show&quot; button will open the dialog. The dialog will have a title, which is data bound to &lt;code&gt;username&lt;/code&gt;, and it will also have a body which we would like to transclude into the dialog.</source>
          <target state="translated">&quot;표시&quot;버튼을 클릭하면 대화 상자가 열립니다. 대화 상자는 title을 가지며,이 데이터는 &lt;code&gt;username&lt;/code&gt; 에 바인딩 되어 있으며, 대화 상자로 변환 할 본문도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c724973f7e774a94420a9f7d99e10433c417d579" translate="yes" xml:space="preserve">
          <source>Clicks on a link in the page.</source>
          <target state="translated">페이지에서 링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="730424b9edeae148b8ff6d50d8ca98ceee4c119c" translate="yes" xml:space="preserve">
          <source>Clicks on a link.</source>
          <target state="translated">링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="9ab2e40fdeb36ffa03fcf8447b001724a990908a" translate="yes" xml:space="preserve">
          <source>Clicks the back or forward button (or clicks a History link).</source>
          <target state="translated">뒤로 또는 앞으로 버튼을 클릭하거나 내역 링크를 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="74d1f7b3edab4ca6a434b8e934d29da720f08e4a" translate="yes" xml:space="preserve">
          <source>Clicks the back or forward button in the browser (or clicks a History link).</source>
          <target state="translated">브라우저에서 뒤로 또는 앞으로 단추를 클릭하거나 히스토리 링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="09ef3902bc825a92dc2ab7a4572699d9bb63ce7f" translate="yes" xml:space="preserve">
          <source>Code licensed under &lt;a href=&quot;https://github.com/angular/angular.js/blob/master/LICENSE&quot;&gt;The MIT License&lt;/a&gt;. Documentation licensed under &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;CC BY 3.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/LICENSE&quot;&gt;MIT 라이센스에&lt;/a&gt; 따라 라이센스가 부여 된 코드 . &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;CC BY 3.0에&lt;/a&gt; 따라 라이센스가 부여 된 문서 .</target>
        </trans-unit>
        <trans-unit id="2dfc49fb8ca872a4cafc6a47501eb288da5ef7b5" translate="yes" xml:space="preserve">
          <source>CoffeeScript Tutorial</source>
          <target state="translated">CoffeeScript 튜토리얼</target>
        </trans-unit>
        <trans-unit id="c548b316d570083f3666806fff6f562e7eab1bab" translate="yes" xml:space="preserve">
          <source>Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.</source>
          <target state="translated">여러 약속을 단일 약속으로 결합하여 모든 입력 약속이 해결 될 때 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="fd5f82d40e47be64b2bc3a51357dc831a7c9ccc1" translate="yes" xml:space="preserve">
          <source>Combining directives with different scope defintions</source>
          <target state="translated">다른 범위 정의와 지시문 결합</target>
        </trans-unit>
        <trans-unit id="3030caa6c289f4c08d71dfe3a1f33564ff7465d0" translate="yes" xml:space="preserve">
          <source>Commit a pending update to the &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$modelValue&lt;/code&gt; 보류중인 업데이트를 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="a521630b4593fb9bacca2130761b0f7eae72e200" translate="yes" xml:space="preserve">
          <source>Commit all form controls pending updates to the &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$modelValue&lt;/code&gt; 업데이트 보류중인 모든 양식 컨트롤을 커밋하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dcd19b6ea69063f828f5ff860efae73d6849a4b" translate="yes" xml:space="preserve">
          <source>Common Accessibility Patterns</source>
          <target state="translated">일반적인 접근성 패턴</target>
        </trans-unit>
        <trans-unit id="dcd05a800dce1c0a95f1b07835a587a1fa065ad4" translate="yes" xml:space="preserve">
          <source>Community Resources</source>
          <target state="translated">커뮤니티 리소스</target>
        </trans-unit>
        <trans-unit id="f087c397aade898e8ebf5017a565387063b4caf7" translate="yes" xml:space="preserve">
          <source>Comparator which is used in determining if values retrieved using &lt;code&gt;expression&lt;/code&gt; (when it is not a function) should be considered a match based on the expected value (from the filter expression) and actual value (from the object in the array).</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; 사용하여 검색된 값 (함수가 아닌 경우)을 판별하는 데 사용되는 비교기 는 예상 값 (필터 표현식에서)과 실제 값 (배열의 오브젝트에서)을 기반으로 일치로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="666fd1f458daf70bc53cddeb4eeb774d87e18c31" translate="yes" xml:space="preserve">
          <source>Compare for object equality using &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; instead of comparing for reference equality.</source>
          <target state="translated">참조 동등성을 비교하는 대신 &lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;/a&gt; 를 사용하여 오브젝트 동등성을 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="3877d9f9528e5e589937b6c5e2e2222e153bc4a4" translate="yes" xml:space="preserve">
          <source>Comparing $location to window.location</source>
          <target state="translated">$ location과 window.location 비교</target>
        </trans-unit>
        <trans-unit id="e9bfd3462dbe8e77bcf76ca7642f0a152f0c0338" translate="yes" xml:space="preserve">
          <source>Comparison between Directive definition and Component definition</source>
          <target state="translated">지시어 정의와 구성 요소 정의의 비교</target>
        </trans-unit>
        <trans-unit id="53cb52234319d0132a4da6be7bbd0b5b04aa75f1" translate="yes" xml:space="preserve">
          <source>Comparison of the two approaches</source>
          <target state="translated">두 가지 접근법의 비교</target>
        </trans-unit>
        <trans-unit id="70d88717d38b547780477523d9cbf84942fc4774" translate="yes" xml:space="preserve">
          <source>Comparison with life-cycle hooks in the new Angular</source>
          <target state="translated">새로운 Angular의 수명주기 후크와 비교</target>
        </trans-unit>
        <trans-unit id="17ab47599110d104d7ae0defacdd1ff429aa3f51" translate="yes" xml:space="preserve">
          <source>Compile the element, but restrict the maximum priority, so that any already compiled directives (including the &lt;code&gt;addOptions&lt;/code&gt; directive) are not compiled again.</source>
          <target state="translated">이미 컴파일 된 지시문 ( &lt;code&gt;addOptions&lt;/code&gt; 지시문 포함)이 다시 컴파일되지 않도록 요소를 컴파일하되 최대 우선 순위를 제한 하십시오.</target>
        </trans-unit>
        <trans-unit id="341a20e237ff5c4b89204a3d4d8c8af5f8aa63bb" translate="yes" xml:space="preserve">
          <source>Compiler</source>
          <target state="translated">Compiler</target>
        </trans-unit>
        <trans-unit id="1782e5208f00a046cef2996ed8671fed74f08a08" translate="yes" xml:space="preserve">
          <source>Compiler is an AngularJS service which traverses the DOM looking for attributes. The compilation process happens in two phases.</source>
          <target state="translated">컴파일러는 속성을 찾는 DOM을 통과하는 AngularJS 서비스입니다. 컴파일 과정은 두 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="fa46964e2997513f5edb8da69c2a884d9e0d6812" translate="yes" xml:space="preserve">
          <source>Compiles a string with markup into an interpolation function. This service is used by the HTML &lt;a href=&quot;%24compile&quot;&gt;$compile&lt;/a&gt; service for data binding. See &lt;a href=&quot;../provider/%24interpolateprovider&quot;&gt;$interpolateProvider&lt;/a&gt; for configuring the interpolation markup.</source>
          <target state="translated">마크 업이있는 문자열을 보간 함수로 컴파일합니다. 이 서비스는 데이터 바인딩을 위해 HTML &lt;a href=&quot;%24compile&quot;&gt;$ compile&lt;/a&gt; 서비스에서 사용됩니다 . 보간 마크 업 구성에 대해서는 &lt;a href=&quot;../provider/%24interpolateprovider&quot;&gt;$ interpolateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca1135b84c5a41b83e29f018e5f8bc1af9b4725" translate="yes" xml:space="preserve">
          <source>Compiles a string with markup into an interpolation function. This service is used by the HTML &lt;a href=&quot;service/%24compile&quot;&gt;$compile&lt;/a&gt; service for data binding. See &lt;a href=&quot;provider/%24interpolateprovider&quot;&gt;$interpolateProvider&lt;/a&gt; for configuring the interpolation markup.</source>
          <target state="translated">마크 업이있는 문자열을 보간 함수로 컴파일합니다. 이 서비스는 데이터 바인딩을 위해 HTML &lt;a href=&quot;service/%24compile&quot;&gt;$ compile&lt;/a&gt; 서비스에서 사용됩니다 . 보간 마크 업 구성에 대해서는 &lt;a href=&quot;provider/%24interpolateprovider&quot;&gt;$ interpolateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35e0dd7e6479d72ea347ebf52f30653b69adb513" translate="yes" xml:space="preserve">
          <source>Compiles an HTML string or DOM into a template and produces a template function, which can then be used to link &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; and the template together.</source>
          <target state="translated">HTML 문자열 또는 DOM을 템플릿으로 컴파일하고 템플릿 함수를 생성하여 &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 를 연결하는 데 사용할 수 있습니다. 와 템플릿을 함께 .</target>
        </trans-unit>
        <trans-unit id="443f4ce80e9a994956ec0834e6c655a3bb098864" translate="yes" xml:space="preserve">
          <source>Compiles an HTML string or DOM into a template and produces a template function, which can then be used to link &lt;a href=&quot;type/%24rootscope.scope&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; and the template together.</source>
          <target state="translated">HTML 문자열 또는 DOM을 템플릿으로 컴파일하고 템플릿 함수를 생성하여 &lt;a href=&quot;type/%24rootscope.scope&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 와 템플릿을 함께 연결하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952c4e08cf22564bbdb9648e98a02a3602d26f59" translate="yes" xml:space="preserve">
          <source>Complementary Libraries</source>
          <target state="translated">보완 라이브러리</target>
        </trans-unit>
        <trans-unit id="1660cae935161f6c4359132ab0d198129c40fd5d" translate="yes" xml:space="preserve">
          <source>Complete list of shortcut methods:</source>
          <target state="translated">바로 가기 방법의 전체 목록 :</target>
        </trans-unit>
        <trans-unit id="ddddba8622d54a1019f55ac5d840e4b03ae004df" translate="yes" xml:space="preserve">
          <source>Completely Replace the $delegate</source>
          <target state="translated">$ delegate를 완전히 교체하십시오</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
