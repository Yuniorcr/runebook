<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angularjs">
    <body>
      <group id="angularjs">
        <trans-unit id="3452bf57ac43f5bb1c78e3470aa773a04375cfd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModel&lt;/code&gt; directive binds an &lt;code&gt;input&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt; (or custom form control) to a property on the scope using &lt;a href=&quot;type/ngmodel.ngmodelcontroller&quot;&gt;NgModelController&lt;/a&gt;, which is created and exposed by this directive.</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 의 지시어는 결합 &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;textarea&lt;/code&gt; 사용 범위의 속성 (또는 사용자 정의 형식 제어) &lt;a href=&quot;type/ngmodel.ngmodelcontroller&quot;&gt;NgModelController&lt;/a&gt; 생성하고이 지시에 의해 노출된다.</target>
        </trans-unit>
        <trans-unit id="b487d1121c7dae27fef086afefdf78374bec811f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModelOptions&lt;/code&gt; expression is only evaluated once when the directive is linked; it is not watched for changes. However, it is possible to override the options on a single &lt;a href=&quot;../type/ngmodel.ngmodelcontroller&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; instance with &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24overrideModelOptions.html&quot;&gt;&lt;code&gt;NgModelController#$overrideModelOptions()&lt;/code&gt;&lt;/a&gt;. See also the example for &lt;a href=&quot;ngmodeloptions#default-events-extra-triggers-and-catch-all-debounce-values.html&quot;&gt;Default events, extra triggers, and catch-all debounce values&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ngModelOptions&lt;/code&gt; 의 표현은 지시문이 링크 될 때 한 번 평가; 변경 사항을 감시하지 않습니다. 그러나 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24overrideModelOptions.html&quot;&gt; &lt;code&gt;NgModelController#$overrideModelOptions()&lt;/code&gt; &lt;/a&gt; 로 단일 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt; 인스턴스 의 옵션을 재정의 할 수 있습니다 . &lt;a href=&quot;ngmodeloptions#default-events-extra-triggers-and-catch-all-debounce-values.html&quot;&gt;기본 이벤트, 추가 트리거 및 포괄 디 바운스 값에&lt;/a&gt; 대한 예제도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd5b88d74d5a86e48055f8cee80df84b803c4347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngModelOptions&lt;/code&gt; settings are found by evaluating the value of the attribute directive as an AngularJS expression. This expression should evaluate to an object, whose properties contain the settings. For example: &lt;code&gt;&amp;lt;div ng-model-options=&quot;{ debounce: 100 }&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngModelOptions&lt;/code&gt; 의 설정은 AngularJS와 같은 발현 특성 지시자의 값을 평가함으로써 발견된다. 이 표현식은 속성이 설정을 포함하는 객체로 평가되어야합니다. 예를 들면 다음과 같습니다. &lt;code&gt;&amp;lt;div ng-model-options=&quot;{ debounce: 100 }&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4a18f3d8624d933a72990e8d9aace68d9a5fa17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngNonBindable&lt;/code&gt; directive tells AngularJS not to compile or bind the contents of the current DOM element, including directives on the element itself that have a lower priority than &lt;code&gt;ngNonBindable&lt;/code&gt;. This is useful if the element contains what appears to be AngularJS directives and bindings but which should be ignored by AngularJS. This could be the case if you have a site that displays snippets of code, for instance.</source>
          <target state="translated">&lt;code&gt;ngNonBindable&lt;/code&gt; 지시어는 컴파일하지 AngularJS와 지시 또는 바인드보다 낮은 우선 순위를 가지고있는 요소 자체에 대한 지침을 포함하여 현재 DOM 요소의 내용, &lt;code&gt;ngNonBindable&lt;/code&gt; 을 . 요소에 AngularJS 지시문 및 바인딩으로 표시되지만 AngularJS에서 무시해야하는 내용이 포함 된 경우에 유용합니다. 예를 들어 코드 스 니펫을 표시하는 사이트가있는 경우가 이에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="18a8b01c2ac198af1bf17bd98c83cf041280c3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOn&lt;/code&gt; directive adds an event listener to a DOM element via &lt;a href=&quot;../function/angular.element&quot;&gt;angular.element().on()&lt;/a&gt;, and evaluates an expression when the event is fired. &lt;code&gt;ngOn&lt;/code&gt; allows adding listeners for arbitrary events by including the event name in the attribute, e.g. &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; executes the 'onDrop()' expression when the &lt;code&gt;drop&lt;/code&gt; event is fired.</source>
          <target state="translated">&lt;code&gt;ngOn&lt;/code&gt; 의 지시자를 통해 DOM 요소에 이벤트 리스너를 추가 &lt;a href=&quot;../function/angular.element&quot;&gt;()에 (). angular.element&lt;/a&gt; 및 이벤트가 트리거 될 때 발현을 평가한다. &lt;code&gt;ngOn&lt;/code&gt; 을 사용하면 속성에 이벤트 이름을 포함시켜 임의의 이벤트에 대한 리스너를 추가 할 수 있습니다. 예를 들어 &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; 은 &lt;code&gt;drop&lt;/code&gt; 이벤트가 발생할 때 'onDrop ()'식을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="2138d9397e0192f72c874be961465bd1c28d35a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOn&lt;/code&gt; directive adds an event listener to a DOM element via &lt;a href=&quot;function/angular.element&quot;&gt;angular.element().on()&lt;/a&gt;, and evaluates an expression when the event is fired. &lt;code&gt;ngOn&lt;/code&gt; allows adding listeners for arbitrary events by including the event name in the attribute, e.g. &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; executes the 'onDrop()' expression when the &lt;code&gt;drop&lt;/code&gt; event is fired.</source>
          <target state="translated">&lt;code&gt;ngOn&lt;/code&gt; 의 지시자를 통해 DOM 요소에 이벤트 리스너를 추가 &lt;a href=&quot;function/angular.element&quot;&gt;()에 (). angular.element&lt;/a&gt; 및 이벤트가 트리거 될 때 발현을 평가한다. &lt;code&gt;ngOn&lt;/code&gt; 을 사용하면 속성에 이벤트 이름을 포함시켜 임의의 이벤트에 대한 리스너를 추가 할 수 있습니다. 예를 들어 &lt;code&gt;ng-on-drop=&quot;onDrop()&quot;&lt;/code&gt; 은 &lt;code&gt;drop&lt;/code&gt; 이벤트가 발생할 때 'onDrop ()'식을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="3a5a3a5904b2e8cda5702d2eb4603a6e9e1ab0ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOptions&lt;/code&gt; attribute can be used to dynamically generate a list of &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements for the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element using the array or object obtained by evaluating the &lt;code&gt;ngOptions&lt;/code&gt; comprehension expression.</source>
          <target state="translated">&lt;code&gt;ngOptions&lt;/code&gt; 속성은 동적 목록 생성하는데 사용될 수있다 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 요소 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 수치화하여 얻은 배열 요소 또는 객체 사용 &lt;code&gt;ngOptions&lt;/code&gt; 이해 발현.</target>
        </trans-unit>
        <trans-unit id="edcab80c917b627233174b158849e232c488cd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngParseExt&lt;/code&gt; module provides functionality to allow Unicode characters in identifiers inside AngularJS expressions.</source>
          <target state="translated">&lt;code&gt;ngParseExt&lt;/code&gt; 의 모듈은 AngularJS와 식 내부 식별자에서 유니 코드 문자를 허용하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="09d3a0b1ee99482f4b3b7b520c3b0c94485099f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngPattern&lt;/code&gt; attribute must be an expression, while the &lt;code&gt;pattern&lt;/code&gt; value must be interpolated.</source>
          <target state="translated">&lt;code&gt;ngPattern&lt;/code&gt; 의 그동안 특성은, 식이어야 &lt;code&gt;pattern&lt;/code&gt; 값을 보간한다.</target>
        </trans-unit>
        <trans-unit id="271ae01d79e2590ed7016379f17a5f47d6f0272e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngProp&lt;/code&gt; directive binds an expression to a DOM element property. &lt;code&gt;ngProp&lt;/code&gt; allows writing to arbitrary properties by including the property name in the attribute, e.g. &lt;code&gt;ng-prop-value=&quot;'my value'&quot;&lt;/code&gt; binds 'my value' to the &lt;code&gt;value&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;ngProp&lt;/code&gt; 의 지시어는 DOM 요소 속성에 식을 결합한다. &lt;code&gt;ngProp&lt;/code&gt; 을 사용하면 속성에 속성 이름을 포함시켜 임의의 속성에 쓸 수 있습니다. 예를 들어 &lt;code&gt;ng-prop-value=&quot;'my value'&quot;&lt;/code&gt; 'my value'를 &lt;code&gt;value&lt;/code&gt; 속성에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="56078d890909a913d837393b28aca4870aaa743e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRef&lt;/code&gt; attribute tells AngularJS to assign the controller of a component (or a directive) to the given property in the current scope. It is also possible to add the jqlite-wrapped DOM element to the scope.</source>
          <target state="translated">&lt;code&gt;ngRef&lt;/code&gt; 의 특성은 현재 범위에 지정된 속성에 구성 요소의 제어 (또는 지시)을 할당 AngularJS와 말한다. jqlite-wrapped DOM 요소를 범위에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff4989bbff6fa7c231c2f0eb3505b944b90b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRepeat&lt;/code&gt; directive instantiates a template once per item from a collection. Each template instance gets its own scope, where the given loop variable is set to the current collection item, and &lt;code&gt;$index&lt;/code&gt; is set to the item index or key.</source>
          <target state="translated">&lt;code&gt;ngRepeat&lt;/code&gt; 의 지시어는 컬렉션에서 항목 당 한 번 템플릿을 인스턴스화합니다. 각 템플릿 인스턴스는 자체 범위를 가져옵니다. 여기서 주어진 루프 변수는 현재 컬렉션 항목 으로 설정 되고 &lt;code&gt;$index&lt;/code&gt; 는 항목 인덱스 또는 키로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3258a5d7b59d2f657f7fe17a611da1f014e37dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngResource&lt;/code&gt; module provides interaction support with RESTful services via the $resource service.</source>
          <target state="translated">&lt;code&gt;ngResource&lt;/code&gt; 의 모듈은 $ 자원 서비스를 통해 편안하고 서비스와 상호 작용을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9ddc195a90e2c72b0358a7cc99d02ccb7323a2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngRoute&lt;/code&gt; module provides routing and deeplinking services and directives for AngularJS apps.</source>
          <target state="translated">&lt;code&gt;ngRoute&lt;/code&gt; 의 모듈은 라우팅 및 AngularJS와 애플 리케이션을위한 서비스 및 지침을 딥 링크 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b3e208ecff40d20920929e835051dd884ba87ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngSanitize&lt;/code&gt; module provides functionality to sanitize HTML.</source>
          <target state="translated">&lt;code&gt;ngSanitize&lt;/code&gt; 의 모듈은 위생적으로 HTML에 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="52b3ba27765007bf524e878fcbc2019dfd26ae3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngShow&lt;/code&gt; directive shows or hides the given HTML element based on the expression provided to the &lt;code&gt;ngShow&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;ngShow&lt;/code&gt; 받는 제공된 식에 기초하여 지정 보이거나 숨겨 지정된 HTML 요소 &lt;code&gt;ngShow&lt;/code&gt; 의 속성.</target>
        </trans-unit>
        <trans-unit id="faf99d24631b3a829e4bcd7302c5c47d13b5ad16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngStyle&lt;/code&gt; directive allows you to set CSS style on an HTML element conditionally.</source>
          <target state="translated">&lt;code&gt;ngStyle&lt;/code&gt; 의 지시자는 조건부 HTML 요소에 CSS 스타일을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100ff07ef6149d7ca57d5a58fc1db3c2ed44c1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngSwitch&lt;/code&gt; directive is used to conditionally swap DOM structure on your template based on a scope expression. Elements within &lt;code&gt;ngSwitch&lt;/code&gt; but without &lt;code&gt;ngSwitchWhen&lt;/code&gt; or &lt;code&gt;ngSwitchDefault&lt;/code&gt; directives will be preserved at the location as specified in the template.</source>
          <target state="translated">&lt;code&gt;ngSwitch&lt;/code&gt; 의 지시어는 범위의 표현을 기반으로 템플릿을 조건부 스왑 DOM 구조에 사용됩니다. 내 요소 &lt;code&gt;ngSwitch&lt;/code&gt; 하지만없는 &lt;code&gt;ngSwitchWhen&lt;/code&gt; 또는 &lt;code&gt;ngSwitchDefault&lt;/code&gt; 템플릿에 지정된 지시어는 위치에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a891433d4f844a3439f6448464836003a6666e46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngTouch&lt;/code&gt; module provides helpers for touch-enabled devices. The implementation is based on jQuery Mobile touch event handling (&lt;a href=&quot;http://jquerymobile.com/&quot;&gt;jquerymobile.com&lt;/a&gt;). *</source>
          <target state="translated">&lt;code&gt;ngTouch&lt;/code&gt; 의 모듈은 터치 지원 장치를 헬퍼를 제공합니다. 구현은 jQuery Mobile 터치 이벤트 처리 ( &lt;a href=&quot;http://jquerymobile.com/&quot;&gt;jquerymobile.com&lt;/a&gt; )를 기반으로 합니다. *</target>
        </trans-unit>
        <trans-unit id="719edff275929380e8a63e3ec29b0aaffc381b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; collection is observed via standard $watch operation and is examined on every call to $digest() to see if any items have been added, removed, or moved.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 컬렉션 표준 $ 시계 작업을 통해 관찰하고 모든 항목이 추가, 삭제, 또는 이동되어 있는지 확인하기 위해 $ 다이제스트 ()에 대한 모든 호출에 조사된다.</target>
        </trans-unit>
        <trans-unit id="851c27c48ef1a184f216635c0032b8034ac64b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt; returned by the service</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 또는 &lt;code&gt;function&lt;/code&gt; 서비스에 의해 반환</target>
        </trans-unit>
        <trans-unit id="78f03e71ba8da4c772e22f7cefb6a86de28fb156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; attribute allows further customization of pluralized text, which can result in a better user experience. For example, instead of the message &quot;4 people are viewing this document&quot;, you might display &quot;John, Kate and 2 others are viewing this document&quot;. The offset attribute allows you to offset a number by any desired value. Let's take a look at an example:</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 속성은 더 나은 사용자 경험을 초래할 수 복수로 텍스트의 추가 지정을 할 수 있습니다. 예를 들어 &quot;4 명이이 문서를보고 있습니다&quot;라는 메시지 대신 &quot;John, Kate 및 2 명이이 문서를보고 있습니다&quot;라는 메시지가 표시 될 수 있습니다. 오프셋 속성을 사용하면 원하는 값으로 숫자를 오프셋 할 수 있습니다. 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3841cc9d8c6ce2f408224f3cae680aa991a2ad9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oldCollection&lt;/code&gt; object is a copy of the former collection data. Due to performance considerations, the&lt;code&gt;oldCollection&lt;/code&gt; value is computed only if the &lt;code&gt;listener&lt;/code&gt; function declares two or more arguments.</source>
          <target state="translated">&lt;code&gt;oldCollection&lt;/code&gt; 의 목적은 전자 수집 된 데이터의 사본이다. 성능 고려 사항으로 인해 &lt;code&gt;listener&lt;/code&gt; 함수가 둘 이상의 인수를 선언 한 경우에만 &lt;code&gt;oldCollection&lt;/code&gt; 값이 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="92de2adf4257cb98e99d7c66015a3a4463b7f324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; object in the &lt;strong&gt;callback&lt;/strong&gt; will now have properties with these keys, which hold the value of the corresponding &lt;strong&gt;group&lt;/strong&gt; in the &lt;strong&gt;regex&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;콜백&lt;/strong&gt; 의 &lt;code&gt;params&lt;/code&gt; 객체 는 이제 이러한 키를 가진 속성을 가지게되는데, 이는 &lt;strong&gt;regex&lt;/strong&gt; 에서 해당 &lt;strong&gt;그룹&lt;/strong&gt; 의 값을 보유합니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c809664e3f03c3d8135c609d28867a41b149ee5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;required&lt;/code&gt; message will be displayed to the user since it appears before the &lt;code&gt;email&lt;/code&gt; message in the DOM. Once the user types a single character, the &lt;code&gt;required&lt;/code&gt; message will disappear (since the field now has a value) but the &lt;code&gt;email&lt;/code&gt; message will be visible because it is still applicable.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; 가 앞에 표시하기 때문에 메시지가 사용자에게 표시되는 &lt;code&gt;email&lt;/code&gt; 은 DOM의 메시지. 사용자가 단일 문자를 입력 하면 필드에 값이 있으므로 &lt;code&gt;required&lt;/code&gt; 메시지가 사라지지만 &lt;code&gt;email&lt;/code&gt; 메시지는 여전히 적용 가능하므로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4185c522e4249b9336c8172126c02efcc1c08358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restrict&lt;/code&gt; option is typically set to:</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; 옵션은 일반적으로 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="a4a3705bd9ff2aae6d9842de77dd5be730d87c0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routeTemplateMonitor&lt;/code&gt; service depends on the built-in &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;&lt;code&gt;$route&lt;/code&gt;&lt;/a&gt; service and our custom &lt;code&gt;batchLog&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;routeTemplateMonitor&lt;/code&gt; 의 서비스는 내장에 따라 &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt; &lt;code&gt;$route&lt;/code&gt; &lt;/a&gt; 서비스와 우리의 사용자 정의 &lt;code&gt;batchLog&lt;/code&gt; 의 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="afc148e7de524b6d85fc2a2af328dfe7cc13d5f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope()&lt;/code&gt; function is only available when &lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt;&lt;code&gt;$compileProvider.debugInfoEnabled()&lt;/code&gt;&lt;/a&gt; is true (which is the default).</source>
          <target state="translated">&lt;code&gt;scope()&lt;/code&gt; 경우에만 사용할 수 있습니다 &lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt; &lt;code&gt;$compileProvider.debugInfoEnabled()&lt;/code&gt; &lt;/a&gt; (기본값) 사실이다.</target>
        </trans-unit>
        <trans-unit id="9fe9f3176578380f2a8892095126bf450cc2e55b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; argument refers to the current scope.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 인수는 현재 범위를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="081d217fe995efb27d071685f735b72868a5a5e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; directive is used together with &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; to provide data-binding between the scope and the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; control (including setting default values). It also handles dynamic &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements, which can be added using the &lt;a href=&quot;ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ngoptions&quot;&gt;&lt;code&gt;ngOptions&lt;/code&gt;&lt;/a&gt; directives.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 지시자와 함께 사용된다 &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 데이터 바인딩 범위와 사이에 제공하는 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; (설정 기본값 포함)를 제어. 또한 &lt;a href=&quot;ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ngoptions&quot;&gt; &lt;code&gt;ngOptions&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 추가 할 수있는 동적 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 요소 도 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="764c088d4b58451c39c5d707cf0b855450c788f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; for the invoked method.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 호출 된 방법.</target>
        </trans-unit>
        <trans-unit id="1f00eea4dd41ef348229b3babc12267733b6ae2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transclude&lt;/code&gt; option changes the way scopes are nested. It makes it so that the &lt;strong&gt;contents&lt;/strong&gt; of a transcluded directive have whatever scope is outside the directive, rather than whatever scope is on the inside. In doing so, it gives the contents access to the outside scope.</source>
          <target state="translated">&lt;code&gt;transclude&lt;/code&gt; 의 옵션은 범위가 중첩되는 방식을 변경합니다. 변환 된 지시문 의 &lt;strong&gt;내용&lt;/strong&gt; 이 내부에있는 범위가 아닌 지시문 외부에있는 범위를 갖도록합니다. 그렇게하면 내용에 외부 범위에 대한 액세스 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="0592776fbfd3e45c05d0a220d4166d8e78eef8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;updateOn&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; properties allow you to specify a custom list of events that will trigger a model update and/or a debouncing delay so that the actual update only takes place when a timer expires; this timer will be reset after another change takes place.</source>
          <target state="translated">&lt;code&gt;updateOn&lt;/code&gt; 및 &lt;code&gt;debounce&lt;/code&gt; 속성은 모델 업데이트 및 / 또는 타이머가 만료 될 때 실제 업데이트는 발생 있도록하는 디 바운싱 지연 트리거 이벤트의 사용자 지정 목록을 지정할 수 있습니다; 이 타이머는 다른 변경이 발생한 후 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="865d012686bd8519148229c77d24cb9da639e749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; that was originally provided to &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;value&lt;/code&gt; is the result of such a call. Otherwise, returns &lt;code&gt;value&lt;/code&gt; unchanged.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 원래 제공 한 &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;value&lt;/code&gt; 같은 호출의 결과입니다. 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 변경하지 않고 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="024e3409a1e0aafe121f0936f278bfdbd6b8eded" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;watchExpression&lt;/code&gt; is called on every call to &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt; and should return the value that will be watched. (&lt;code&gt;watchExpression&lt;/code&gt; should not change its value when executed multiple times with the same input because it may be executed multiple times by &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt;. That is, &lt;code&gt;watchExpression&lt;/code&gt; should be &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;watchExpression&lt;/code&gt; 는 호출 할 때마다 호출됩니다 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트 ()&lt;/a&gt; 및 감시 될 값을 반환해야합니다. ( &lt;code&gt;watchExpression&lt;/code&gt; 는 이 여러 번 수행 될 수 있기 때문에 동일한 입력으로 여러 번 수행 될 때 그 값을 변경해서는 안 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트 ()&lt;/a&gt; . 즉, &lt;code&gt;watchExpression&lt;/code&gt; 가 있어야 &lt;a href=&quot;http://en.wikipedia.org/wiki/Idempotence&quot;&gt;멱등&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c77aba6041c9b36ae3635fef59bf7730092422df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; attribute specifies the mappings between plural categories and the actual string to be displayed. The value of the attribute should be a JSON object.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 속성은 복수의 카테고리와 실제 문자열 사이의 매핑을 표시하도록 지정한다. 속성 값은 JSON 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="29c7438c3e58ad6cfeb1ab043f1d56e6013584d8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default value&lt;/strong&gt; when no whitelist has been explicitly set is &lt;code&gt;['self']&lt;/code&gt; allowing only same origin resource requests.</source>
          <target state="translated">화이트리스트가 명시 적으로 설정되지 않은 경우 의 &lt;strong&gt;기본값&lt;/strong&gt; 은 &lt;code&gt;['self']&lt;/code&gt; 로 동일한 오리진 자원 요청 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="971a8e0fa1cf0babaa204065768792f07fb82390" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default value&lt;/strong&gt; when no whitelist has been explicitly set is the empty array (i.e. there is no blacklist.)</source>
          <target state="translated">&lt;strong&gt;디폴트 값&lt;/strong&gt; 을 명시 적으로 설정되어있는 화이트리스트 결코 빈 배열 (즉, 더 블랙리스트가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="30b3a9c87fe99e11ad5c482f252d8b2795c7d39c" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;normalization&lt;/strong&gt; process is as follows:</source>
          <target state="translated">&lt;strong&gt;정규화&lt;/strong&gt; 다음과 같이 프로세스는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="c92de0945f5d858e55599f74eae5a30cddcf871d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;scope option&lt;/strong&gt; is an object that contains a property for each isolate scope binding. In this case it has just one property:</source>
          <target state="translated">&lt;strong&gt;범위 옵션은&lt;/strong&gt; 바인딩 각각 분리 범위에 대한 속성을 포함하는 객체입니다. 이 경우 하나의 속성 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b40743da77f9678b10414f875798e060c42324" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;service factory function&lt;/strong&gt; generates the single object or function that represents the service to the rest of the application. The object or function returned by the service is injected into any component (controller, service, filter or directive) that specifies a dependency on the service.</source>
          <target state="translated">&lt;strong&gt;서비스 공장 기능은&lt;/strong&gt; 응용 프로그램의 나머지 부분에 대한 서비스를 나타내는 단일 개체 또는 함수를 생성합니다. 서비스가 반환 한 객체 또는 함수는 서비스에 대한 종속성을 지정하는 모든 구성 요소 (컨트롤러, 서비스, 필터 또는 지시문)에 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="5ceadcbdd30d6b737f519c6b13401595572885d1" translate="yes" xml:space="preserve">
          <source>The AngularJS approach produces a stable DOM. The DOM element instance bound to a model item instance does not change for the lifetime of the binding. This means that the code can get hold of the elements and register event handlers and know that the reference will not be destroyed by template data merge.</source>
          <target state="translated">AngularJS 접근 방식은 안정적인 DOM을 생성합니다. 모델 항목 인스턴스에 바인딩 된 DOM 요소 인스턴스는 바인딩 수명 동안 변경되지 않습니다. 즉, 코드가 요소를 보유하고 이벤트 핸들러를 등록 할 수 있으며 템플리트 데이터 병합으로 참조가 손상되지 않음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda5f891e99782bb7f2b57b3956c0a05ebdb49e3" translate="yes" xml:space="preserve">
          <source>The AngularJS datetime filter uses the time zone settings of the browser. The same application will show different time information depending on the time zone settings of the computer that the application is running on. Neither JavaScript nor AngularJS currently supports displaying the date with a timezone specified by the developer.</source>
          <target state="translated">AngularJS 날짜 시간 필터는 브라우저의 시간대 설정을 사용합니다. 동일한 응용 프로그램은 응용 프로그램이 실행되는 컴퓨터의 시간대 설정에 따라 다른 시간 정보를 표시합니다. JavaScript 나 AngularJS는 현재 개발자가 지정한 시간대로 날짜 표시를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ed09a1c05ea064927146d6b96bb2d8d5f52f6be" translate="yes" xml:space="preserve">
          <source>The AngularJS expression is followed by &lt;code&gt;, select,&lt;/code&gt; where the spaces are optional.</source>
          <target state="translated">AngularJS 표현식 다음에 는 공백이 선택적인 &lt;code&gt;, select,&lt;/code&gt; 가옵니다 .</target>
        </trans-unit>
        <trans-unit id="3e68d99150c2f319df83ed6c3b871e24960e46dc" translate="yes" xml:space="preserve">
          <source>The AngularJS injector subsystem is in charge of creating components, resolving their dependencies, and providing them to other components as requested.</source>
          <target state="translated">AngularJS 인젝터 서브 시스템은 컴포넌트 작성, 종속성 해결 및 요청에 따라 다른 컴포넌트에 제공을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">기초</target>
        </trans-unit>
        <trans-unit id="9d032f695a01d9cd7a1b6d3c12def6c50b9bd99f" translate="yes" xml:space="preserve">
          <source>The Component config object. (Note that, unlike the &lt;code&gt;.directive()&lt;/code&gt; method, this method does &lt;strong&gt;not&lt;/strong&gt; take a factory function.)</source>
          <target state="translated">구성 요소 구성 오브젝트. &lt;code&gt;.directive()&lt;/code&gt; 메소드 와 달리이 메소드는 팩토리 함수를 사용하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8bac82729a1c26fcbe3c4f5867ac3b7453bf9540" translate="yes" xml:space="preserve">
          <source>The Controller methods and properties are available in the template (for both the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element and its children).</source>
          <target state="translated">컨트롤러 메소드 및 속성은 템플릿에서 사용할 수 있습니다 ( &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소 및 해당 하위 요소 모두에 대해 ).</target>
        </trans-unit>
        <trans-unit id="af868017ccf0c187453928340ab193c6139324bb" translate="yes" xml:space="preserve">
          <source>The DOM property name.</source>
          <target state="translated">DOM 속성 이름</target>
        </trans-unit>
        <trans-unit id="d443ac9ac3502ca4aa895decc917e0fc27f2931f" translate="yes" xml:space="preserve">
          <source>The Deferred API</source>
          <target state="translated">지연된 API</target>
        </trans-unit>
        <trans-unit id="1e7c1b13eac086e0802b173f73532f7f37f2370c" translate="yes" xml:space="preserve">
          <source>The DemoController is instantiated via its constructor, every time the app needs an instance of DemoController (in our simple app it's just once). So unlike services, controllers are not singletons. The constructor is called with all the requested services, in our case the &lt;code&gt;clientId&lt;/code&gt; service.</source>
          <target state="translated">DemoController는 앱이 DemoController의 인스턴스를 필요로 할 때마다 생성자를 통해 인스턴스화됩니다 (단순한 앱에서는 단 한 번). 따라서 서비스와 달리 컨트롤러는 싱글 톤이 아닙니다. 생성자는 요청 된 모든 서비스 (이 경우 &lt;code&gt;clientId&lt;/code&gt; 서비스) 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3fa2746de6d7246f13d0d1cffdff95010c93ad4" translate="yes" xml:space="preserve">
          <source>The Factory recipe constructs a new service using a function with zero or more arguments (these are dependencies on other services). The return value of this function is the service instance created by this recipe.</source>
          <target state="translated">팩토리 레시피는 0 개 이상의 인수가있는 함수를 사용하여 새 서비스를 구성합니다 (이것은 다른 서비스에 대한 종속성입니다). 이 함수의 리턴 값은이 레시피로 작성된 서비스 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="ac50a19bbd375fef86664e01f67fa8affc02aed1" translate="yes" xml:space="preserve">
          <source>The HTTP request template URL</source>
          <target state="translated">HTTP 요청 템플릿 URL</target>
        </trans-unit>
        <trans-unit id="ae5f1f8e1b81cdc0e20901352fa4e651557871f5" translate="yes" xml:space="preserve">
          <source>The JavaScript specification does not define the order of keys returned for an object, so AngularJS relies on the order returned by the browser when running &lt;code&gt;for key in myObj&lt;/code&gt;. Browsers generally follow the strategy of providing keys in the order in which they were defined, although there are exceptions when keys are deleted and reinstated. See the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_notes&quot;&gt;MDN page on &lt;code&gt;delete&lt;/code&gt; for more info&lt;/a&gt;.</source>
          <target state="translated">JavaScript 사양에서는 객체에 대해 반환되는 키 순서를 정의하지 않으므로 AngularJS &lt;code&gt;for key in myObj&lt;/code&gt; 실행할 때 브라우저가 반환 한 순서 를 따릅니다 . 키를 삭제하고 복원 할 때 예외가 있지만 브라우저는 일반적으로 정의 된 순서대로 키를 제공하는 전략을 따릅니다. 참고 항목 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_notes&quot;&gt;에 MDN 페이지 &lt;code&gt;delete&lt;/code&gt; 추가 정보를 원하시면&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf8ccad6f9791756a44c25e1221b6b0a5e4e10b" translate="yes" xml:space="preserve">
          <source>The Promise API</source>
          <target state="translated">약속 API</target>
        </trans-unit>
        <trans-unit id="c9652e0712d85f53b10f54c8b3d21746e8926806" translate="yes" xml:space="preserve">
          <source>The Provider recipe is syntactically defined as a custom type that implements a &lt;code&gt;$get&lt;/code&gt; method. This method is a factory function just like the one we use in the Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the &lt;code&gt;$get&lt;/code&gt; method set to your factory function is automatically created under the hood.</source>
          <target state="translated">제공자 레시피는 구문 적으로 &lt;code&gt;$get&lt;/code&gt; 메소드 를 구현하는 사용자 정의 유형으로 정의됩니다 . 이 방법은 팩토리 레시피에서 사용하는 것과 같은 팩토리 기능입니다. 실제로 팩토리 레시피를 정의하면 &lt;code&gt;$get&lt;/code&gt; 메소드가 팩토리 함수로 설정된 빈 제공자 유형 이 자동으로 후드 아래에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">공급자 레시피는 핵심 레시피 유형이며 다른 모든 유형은 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="a892a7bf5def9b0ea2286339b6f7a5da993546d3" translate="yes" xml:space="preserve">
          <source>The Resource instances and collections have these additional methods:</source>
          <target state="translated">자원 인스턴스 및 콜렉션에는 다음과 같은 추가 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e66076755327d887f686ad69f837103a8b754a30" translate="yes" xml:space="preserve">
          <source>The Resource instances and collections have these additional properties:</source>
          <target state="translated">자원 인스턴스 및 콜렉션에는 다음과 같은 추가 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34621a3a20f723701bf1858b04f4ad3fb921a112" translate="yes" xml:space="preserve">
          <source>The Resource instances have these additional methods:</source>
          <target state="translated">리소스 인스턴스에는 다음과 같은 추가 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71937c0cf05c12db3a4b4bba8de6a062c6cf8f4" translate="yes" xml:space="preserve">
          <source>The Router holds reference to one or more of Outlets.</source>
          <target state="translated">라우터는 하나 이상의 콘센트에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="87ff180e9a06b8bf6a17a8b51f3125e4d192aa91" translate="yes" xml:space="preserve">
          <source>The SCE context in which this result will be used.</source>
          <target state="translated">이 결과가 사용될 SCE 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="823fe0827cbf252db7bc25081089c81fb8cdd103" translate="yes" xml:space="preserve">
          <source>The Safari browser throws a &lt;code&gt;RangeError&lt;/code&gt; instead of returning &lt;code&gt;null&lt;/code&gt; when it tries to stringify a &lt;code&gt;Date&lt;/code&gt; object with an invalid date value. The only reliable way to prevent this is to monkeypatch the &lt;code&gt;Date.prototype.toJSON&lt;/code&gt; method as follows:</source>
          <target state="translated">Safari 브라우저는 잘못된 날짜 값 으로 &lt;code&gt;Date&lt;/code&gt; 객체 를 문자열 화하려고 할 때 &lt;code&gt;null&lt;/code&gt; 을 반환 하는 대신 &lt;code&gt;RangeError&lt;/code&gt; 를 발생 시킵니다. 이를 막는 유일한 확실한 방법은 다음과 같이 &lt;code&gt;Date.prototype.toJSON&lt;/code&gt; 메소드 를 monkeypatch하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="afb43aa0cd18509de40731a13b780ba28edd09b0" translate="yes" xml:space="preserve">
          <source>The Service recipe produces a service just like the Value or Factory recipes, but it does so by &lt;em&gt;invoking a constructor with the &lt;code&gt;new&lt;/code&gt; operator&lt;/em&gt;. The constructor can take zero or more arguments, which represent dependencies needed by the instance of this type.</source>
          <target state="translated">서비스 레시피는 Value 또는 Factory 레시피와 같은 서비스를 생성하지만 &lt;em&gt; &lt;code&gt;new&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 연산자 &lt;/em&gt;&lt;em&gt;로 생성자를 호출하여 수행&lt;/em&gt; 합니다. 생성자는이 유형의 인스턴스에 필요한 종속성을 나타내는 0 개 이상의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25546288f27af1b214ed293ad490dde0ee7283f3" translate="yes" xml:space="preserve">
          <source>The Value recipe is very simple to write, but lacks some important features we often need when creating services. Let's now look at the Value recipe's more powerful sibling, the Factory. The Factory recipe adds the following abilities:</source>
          <target state="translated">Value 레시피는 작성이 매우 간단하지만 서비스를 생성 할 때 자주 필요한 몇 가지 중요한 기능이 없습니다. 이제 Value 레시피의 더 강력한 형제 인 팩토리를 살펴 보겠습니다. 팩토리 레시피는 다음과 같은 능력을 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="f208762d78ff0661e5bda0e7aac4b7d59f109453" translate="yes" xml:space="preserve">
          <source>The Zen of AngularJS</source>
          <target state="translated">AngularJS의 선</target>
        </trans-unit>
        <trans-unit id="c29d1c1afd3d55fd76dd7231c901e094f9916538" translate="yes" xml:space="preserve">
          <source>The above affects all kinds of element re-use due to tracking, but may be especially visible when tracking by &lt;code&gt;$index&lt;/code&gt; due to the way ngRepeat re-uses elements.</source>
          <target state="translated">위의 내용은 추적으로 인해 모든 유형의 요소 재사용에 영향을 주지만 ngRepeat가 요소를 재사용하는 방식으로 인해 &lt;code&gt;$index&lt;/code&gt; 로 추적 할 때 특히 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d020ab0c4519b74d0e2f34f58f59c7bb5764a61" translate="yes" xml:space="preserve">
          <source>The above is a suggestion. Tailor it to your needs.</source>
          <target state="translated">위의 제안입니다. 필요에 맞게 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="97d188a64eaf391575058d7091fc3fa4a7f72e3b" translate="yes" xml:space="preserve">
          <source>The action methods on the class object or instance object can be invoked with the following parameters:</source>
          <target state="translated">클래스 객체 또는 인스턴스 객체의 액션 메서드는 다음 매개 변수를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eff8e112c923d4408ba2e75a0a922cfc87c536b" translate="yes" xml:space="preserve">
          <source>The actual value from the control's view. For &lt;code&gt;input&lt;/code&gt; elements, this is a String. See &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; for information about when the $viewValue is set.</source>
          <target state="translated">컨트롤보기의 실제 값입니다. 들어 &lt;code&gt;input&lt;/code&gt; 요소,이 문자열이다. $ viewValue 설정시기에 대한 정보는 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48378b09bf8458398be6b8d6a8a1f336579bf8ba" translate="yes" xml:space="preserve">
          <source>The amount of time moved forward.</source>
          <target state="translated">앞으로 이동 한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2b948d265fc57c10625e1ce0862575d8dd243a43" translate="yes" xml:space="preserve">
          <source>The application can have multiple scopes, because &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt; can create new child scopes. When new scopes are created, they are added as children of their parent scope. This creates a tree structure which parallels the DOM where they're attached.</source>
          <target state="translated">&lt;a href=&quot;directive&quot;&gt;지시문&lt;/a&gt; 은 새로운 자식 범위를 만들 수 있으므로 응용 프로그램에는 여러 범위가있을 수 있습니다. 새 범위가 만들어지면 부모 범위의 자식으로 추가됩니다. 이것은 첨부 된 DOM과 비슷한 트리 구조를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="38e5bbdd08561c9153847e92a500562dc014b342" translate="yes" xml:space="preserve">
          <source>The application developer is responsible for loading the code containing the modules; and for ensuring that lazy scripts are not downloaded and executed more often that desired.</source>
          <target state="translated">응용 프로그램 개발자는 모듈이 포함 된 코드를로드해야합니다. 게으른 스크립트를 다운로드하여 원하는 횟수만큼 자주 실행하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="60f11f10d202320b748ee12a06796244dbd227a5" translate="yes" xml:space="preserve">
          <source>The arguments present in the callback function are:</source>
          <target state="translated">콜백 함수에 존재하는 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81e6f0d0a80e18b7562f471ce77dd5009db58a45" translate="yes" xml:space="preserve">
          <source>The array notation</source>
          <target state="translated">배열 표기법</target>
        </trans-unit>
        <trans-unit id="9ca59792e60c6511fe9a49d6033cb2a4c1439819" translate="yes" xml:space="preserve">
          <source>The attribute magic of ngAria may not work for every scenario. To disable individual attributes, you can use the &lt;a href=&quot;../api/ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt; method. Just keep in mind this will tell ngAria to ignore the attribute globally.</source>
          <target state="translated">ngAria의 속성 마법은 모든 시나리오에서 작동하지 않을 수 있습니다. 개별 속성을 비활성화하려면 &lt;a href=&quot;../api/ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt; 방법을 사용하십시오 . 이것은 ngAria가 전역 적으로 속성을 무시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="14d833ec5a36b34606ff7ead177dd258878c59e5" translate="yes" xml:space="preserve">
          <source>The behaviour of the directive is affected by the use of the &lt;code&gt;ngTrim&lt;/code&gt; attribute.</source>
          <target state="translated">지시문의 동작은 &lt;code&gt;ngTrim&lt;/code&gt; 속성 사용에 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="8aeca93c2626363ee4548fe610e8099df9c9c8b3" translate="yes" xml:space="preserve">
          <source>The boolean &lt;code&gt;readonly&lt;/code&gt; attribute is only valid for native form controls such as &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;textarea&lt;/code&gt;. To properly indicate custom element directives such as &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; as required, using ngAria with &lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt;ngReadonly&lt;/a&gt; will also add &lt;code&gt;aria-readonly&lt;/code&gt;. This tells accessibility APIs when a custom control is read-only.</source>
          <target state="translated">부울 &lt;code&gt;readonly&lt;/code&gt; 속성은 &lt;code&gt;input&lt;/code&gt; 및 &lt;code&gt;textarea&lt;/code&gt; 와 같은 기본 양식 컨트롤에만 유효합니다 . 제대로 같은 사용자 지정 요소 지시자 표시하기 위해 &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; 필요로 ngAria를 사용 &lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt;ngReadonly&lt;/a&gt; 도 추가 할 것이다 &lt;code&gt;aria-readonly&lt;/code&gt; . 이것은 커스텀 컨트롤이 읽기 전용 일 때 접근성 API를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="935e2113acf37c8fa60e8d363d9a4163dc3c40a0" translate="yes" xml:space="preserve">
          <source>The boolean &lt;code&gt;required&lt;/code&gt; attribute is only valid for native form controls such as &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;textarea&lt;/code&gt;. To properly indicate custom element directives such as &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; as required, using ngAria with &lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt;ngRequired&lt;/a&gt; will also add &lt;code&gt;aria-required&lt;/code&gt;. This tells accessibility APIs when a custom control is required.</source>
          <target state="translated">부울 &lt;code&gt;required&lt;/code&gt; 속성은 &lt;code&gt;input&lt;/code&gt; 및 &lt;code&gt;textarea&lt;/code&gt; 와 같은 기본 양식 컨트롤에만 유효합니다 . 필요에 따라 &lt;code&gt;&amp;lt;md-checkbox&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;custom-input&amp;gt;&lt;/code&gt; 과 같은 사용자 정의 요소 지시문을 올바르게 표시하기 위해 ngRequire와 함께 &lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt;ngAria&lt;/a&gt; 를 사용 하면 &lt;code&gt;aria-required&lt;/code&gt; 가 추가됩니다 . 이것은 사용자 정의 제어가 필요할 때 내게 필요한 옵션 API를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="9e8a4e50e5a91fb8867fe908b441bbfda7d826ab" translate="yes" xml:space="preserve">
          <source>The browser re-renders the view with the updated text.</source>
          <target state="translated">브라우저는 업데이트 된 텍스트로 뷰를 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="65cf3e169c60d4db4937d1da68550b314b1b6e3d" translate="yes" xml:space="preserve">
          <source>The browser's event-loop waits for an event to arrive. An event is a user interaction, timer event, or network event (response from a server).</source>
          <target state="translated">브라우저의 이벤트 루프는 이벤트가 도착하기를 기다립니다. 이벤트는 사용자 상호 작용, 타이머 이벤트 또는 네트워크 이벤트 (서버의 응답)입니다.</target>
        </trans-unit>
        <trans-unit id="707ecbb38e755bff0a1ac8d5a41800f59ce92ee0" translate="yes" xml:space="preserve">
          <source>The buggy way to write it:</source>
          <target state="translated">그것을 쓰는 버기 방법 :</target>
        </trans-unit>
        <trans-unit id="7daed9593b5b371d72c261edea4b25b4a7fbc58e" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;$id()&lt;/code&gt; function can be used to assign a unique &lt;code&gt;$$hashKey&lt;/code&gt; property to each item in the collection. This property is then used as a key to associated DOM elements with the corresponding item in the collection by identity. Moving the same object would move the DOM element in the same way in the DOM. Note that the default id function does not support duplicate primitive values (&lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;), but supports duplictae non-primitive values (&lt;code&gt;object&lt;/code&gt;) that are &lt;em&gt;equal&lt;/em&gt; in shape.</source>
          <target state="translated">내장 된 &lt;code&gt;$id()&lt;/code&gt; 함수를 사용 하여 컬렉션의 각 항목에 고유 한 &lt;code&gt;$$hashKey&lt;/code&gt; 속성을 할당 할 수 있습니다 . 그런 다음이 특성은 ID별로 콜렉션의 해당 항목과 연관된 DOM 요소의 키로 사용됩니다. 동일한 객체를 이동하면 DOM에서 동일한 방식으로 DOM 요소가 이동합니다. 기본 id 함수는 중복 기본 값 ( &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; )을 지원하지 않지만 모양 이 &lt;em&gt;동일한&lt;/em&gt; 중복 기본이 아닌 값 ( &lt;code&gt;object&lt;/code&gt; )을 지원합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de84fb848d7974c1538967d70a061f09d136e209" translate="yes" xml:space="preserve">
          <source>The built-in AngularJS directives show in their documentation page which type of matching they support.</source>
          <target state="translated">내장 AngularJS 지시문은 지원되는 일치 유형을 설명서 페이지에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="962a6ec28bdb795347091d826dbdec1364731a71" translate="yes" xml:space="preserve">
          <source>The built-in DOM manipulation directives, such as &lt;a href=&quot;../directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../directive/ngswitch&quot;&gt;&lt;code&gt;ngSwitch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; automatically destroy their transcluded clones as necessary so you do not need to worry about this if you are simply using &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt; to inject the transclusion into your directive.</source>
          <target state="translated">&lt;a href=&quot;../directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../directive/ngswitch&quot;&gt; &lt;code&gt;ngSwitch&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt; 와 같은 내장 DOM 조작 지시문 은 필요에 따라 변환 된 복제본을 자동으로 제거하므로 지시문에 변환을 삽입하기 위해 &lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8d5255e53ef3607b163dc1dff9b5cf6c85ff7edd" translate="yes" xml:space="preserve">
          <source>The built-in filters &lt;a href=&quot;../filter/orderby&quot;&gt;orderBy&lt;/a&gt; and &lt;a href=&quot;../filter/filter&quot;&gt;filter&lt;/a&gt; do not work with objects, and will throw an error if used with one.</source>
          <target state="translated">내장 필터 &lt;a href=&quot;../filter/orderby&quot;&gt;orderBy&lt;/a&gt; 및 &lt;a href=&quot;../filter/filter&quot;&gt;filter&lt;/a&gt; 는 객체에서 작동하지 않으며 객체와 함께 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff2c0fad2a4d5f40e3c8e45c0cb4b216d27b9103" translate="yes" xml:space="preserve">
          <source>The cache key is the request URL including search parameters; headers are not considered.</source>
          <target state="translated">캐시 키는 검색 매개 변수를 포함하는 요청 URL입니다. 헤더는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4616eff1fba05855b623c26f362604c6b703e08" translate="yes" xml:space="preserve">
          <source>The child elements of the &lt;code&gt;ngMessages&lt;/code&gt; directive are matched to the collection keys by a &lt;code&gt;ngMessage&lt;/code&gt; or &lt;code&gt;ngMessageExp&lt;/code&gt; directive. The value of these attributes must match a key in the collection that is provided by the &lt;code&gt;ngMessages&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;ngMessages&lt;/code&gt; 지시문 의 하위 요소 는 &lt;code&gt;ngMessage&lt;/code&gt; 또는 &lt;code&gt;ngMessageExp&lt;/code&gt; 지시문에 의해 콜렉션 키와 일치합니다 . 이러한 속성의 값은 &lt;code&gt;ngMessages&lt;/code&gt; 지시문 이 제공하는 컬렉션의 키와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5336897e60e004333ab19b29ea3db63cbe8dfa69" translate="yes" xml:space="preserve">
          <source>The className expression which will be checked against all animations</source>
          <target state="translated">모든 애니메이션에 대해 확인할 className 표현식</target>
        </trans-unit>
        <trans-unit id="2c1b1a48a0af433b1673ea81113c3f7424fa7fcb" translate="yes" xml:space="preserve">
          <source>The className value that will be added to the element</source>
          <target state="translated">요소에 추가 될 className 값</target>
        </trans-unit>
        <trans-unit id="01da935870671cfe5daa21f385f055010d61e8c9" translate="yes" xml:space="preserve">
          <source>The className value that will be removed from the element</source>
          <target state="translated">요소에서 제거 될 className 값</target>
        </trans-unit>
        <trans-unit id="4ee4fb39e9e5de140b856309f8187236336a4e7a" translate="yes" xml:space="preserve">
          <source>The collection (array or array-like object) to sort.</source>
          <target state="translated">정렬 할 컬렉션 (배열 또는 배열 유사 객체)입니다.</target>
        </trans-unit>
        <trans-unit id="e22835faffad5508a02cb513445c12617c69ea54" translate="yes" xml:space="preserve">
          <source>The comparator function is used to sort the items, based on the derived values, types and indices.</source>
          <target state="translated">비교기 함수는 파생 된 값, 유형 및 색인을 기반으로 항목을 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a43646046dc2a965f4d42e43008db64616266c7b" translate="yes" xml:space="preserve">
          <source>The comparator function used to determine the relative order of value pairs. If omitted, the built-in comparator will be used.</source>
          <target state="translated">비교기 함수는 값 쌍의 상대 순서를 결정하는 데 사용됩니다. 생략하면 내장 비교기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6baf3ab50c289d17bf3cfb5a4993fa32161e5046" translate="yes" xml:space="preserve">
          <source>The comparison is done using the &lt;code&gt;comparator&lt;/code&gt; function. If none is specified, a default, built-in comparator is used (see below for details - in a nutshell, it compares numbers numerically and strings alphabetically).</source>
          <target state="translated">&lt;code&gt;comparator&lt;/code&gt; 기능을 사용하여 비교가 수행됩니다 . 아무것도 지정하지 않으면 기본 내장 비교기가 사용됩니다 (자세한 내용은 아래에서 숫자와 문자열을 알파벳순으로 비교).</target>
        </trans-unit>
        <trans-unit id="67bff779900ff80c2c3c68a68a6f55dc6ec358a9" translate="yes" xml:space="preserve">
          <source>The compilation is a process of walking the DOM tree and matching DOM elements to &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">컴파일은 DOM 트리를 걷고 DOM 요소를 &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;지시문에&lt;/a&gt; 일치시키는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="10e4998d3da4ae02bc4b02f740db293d195492a3" translate="yes" xml:space="preserve">
          <source>The compile function deals with transforming the template DOM. Since most directives do not do template transformation, it is not used often. The compile function takes the following arguments:</source>
          <target state="translated">컴파일 함수는 템플릿 DOM 변환을 처리합니다. 대부분의 지시문은 템플릿 변환을 수행하지 않으므로 자주 사용되지 않습니다. 컴파일 함수는 다음 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e3ba37f0f20632b21daa2b1d0d783a59cb927a72" translate="yes" xml:space="preserve">
          <source>The compiler does not suspend the entire compilation to wait for templates to be loaded because this would result in the whole app &quot;stalling&quot; until all templates are loaded asynchronously - even in the case when only one deeply nested directive has &lt;code&gt;templateUrl&lt;/code&gt;.</source>
          <target state="translated">심지어 경우에 하나의 중첩 지시가있을 때 - 컴파일러는 템플릿이로드 될이 모든 템플릿을 비동기 적으로로드 될 때까지 &quot;실속&quot;전체 응용 프로그램을 초래할 것이기 때문에 기다릴 전체 컴파일을 중단하지 않습니다 &lt;code&gt;templateUrl&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="8325dd3ca7b9ffd07716c535f23b0e8400e6a2b0" translate="yes" xml:space="preserve">
          <source>The component can create the dependency, typically using the &lt;code&gt;new&lt;/code&gt; operator.</source>
          <target state="translated">구성 요소는 일반적으로 &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 종속성을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="079e1d898e7f8138744541edc30b9716548afef5" translate="yes" xml:space="preserve">
          <source>The component can have the dependency passed to it where it is needed.</source>
          <target state="translated">컴포넌트는 필요한 곳으로 종속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d494d536751a59fe5fb79ed0078239843fed4f8" translate="yes" xml:space="preserve">
          <source>The component can look up the dependency, by referring to a global variable.</source>
          <target state="translated">컴포넌트는 글로벌 변수를 참조하여 종속성을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1696b0ee510ce7b698742d313d7841389de75d" translate="yes" xml:space="preserve">
          <source>The configuration object. May only contain the options that need to be updated. Supported keys:</source>
          <target state="translated">구성 객체. 업데이트해야하는 옵션 만 포함 할 수 있습니다. 지원되는 키 :</target>
        </trans-unit>
        <trans-unit id="c0221af8fa9351901bedb66ce06849fb170fa5da" translate="yes" xml:space="preserve">
          <source>The constant value.</source>
          <target state="translated">상수 값.</target>
        </trans-unit>
        <trans-unit id="21b4017fe5c763384985b8ae7689d4c632ed24d0" translate="yes" xml:space="preserve">
          <source>The context in which this value is safe for use, e.g. &lt;code&gt;$sce.URL&lt;/code&gt;, &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt;, &lt;code&gt;$sce.HTML&lt;/code&gt;, &lt;code&gt;$sce.JS&lt;/code&gt; or &lt;code&gt;$sce.CSS&lt;/code&gt;.</source>
          <target state="translated">이 값이 사용하기에 안전한 컨텍스트 (예 : &lt;code&gt;$sce.URL&lt;/code&gt; , &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; , &lt;code&gt;$sce.HTML&lt;/code&gt; , &lt;code&gt;$sce.JS&lt;/code&gt; 또는 &lt;code&gt;$sce.CSS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e02f32b11d4a96e094cc4cd481703dd1fae3a4d8" translate="yes" xml:space="preserve">
          <source>The context in which this value is to be used (such as &lt;code&gt;$sce.HTML&lt;/code&gt;).</source>
          <target state="translated">이 값이 사용될 컨텍스트 (예 : &lt;code&gt;$sce.HTML&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2a00503e1aada1817f217fc39da46317b85f521" translate="yes" xml:space="preserve">
          <source>The context in which this value is to be used.</source>
          <target state="translated">이 값이 사용될 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="527160a78c0a817c7ef349fdf9b2c7b8b40a0021" translate="yes" xml:space="preserve">
          <source>The contexts that can be sanitized are $sce.MEDIA_URL, $sce.URL and $sce.HTML. The first two are available by default, and the third one relies on the &lt;code&gt;$sanitize&lt;/code&gt; service (which may be loaded through the &lt;code&gt;ngSanitize&lt;/code&gt; module). Furthermore, for $sce.RESOURCE_URL context, a plain string may be accepted if the resource url policy defined by &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/code&gt;&lt;/a&gt; accepts that resource.</source>
          <target state="translated">삭제 가능한 컨텍스트는 $ sce.MEDIA_URL, $ sce.URL 및 $ sce.HTML입니다. 처음 두 개는 기본적으로 사용 가능하며 세 번째는 &lt;code&gt;$sanitize&lt;/code&gt; 서비스 ( &lt;code&gt;ngSanitize&lt;/code&gt; 모듈을 통해로드 될 수 있음 )에 의존 합니다. 또한 $ sce.RESOURCE_URL 컨텍스트의 경우 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/code&gt; &lt;/a&gt; 의해 정의 된 자원 URL 정책이 해당 자원을 승인하는 경우 일반 문자열이 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ed1aa0329c6ec125f16d62f3f72745317d7c05" translate="yes" xml:space="preserve">
          <source>The control in this example updates by &quot;default&quot;, &quot;click&quot;, and &quot;blur&quot;, with different &lt;code&gt;debounce&lt;/code&gt; values. You can see that &quot;click&quot; doesn't have an individual &lt;code&gt;debounce&lt;/code&gt; value - therefore it uses the &lt;code&gt;*&lt;/code&gt; debounce value.</source>
          <target state="translated">이 예제의 컨트롤은 다른 &lt;code&gt;debounce&lt;/code&gt; 값 으로 &quot;default&quot;, &quot;click&quot;및 &quot;blur&quot;로 업데이트됩니다 . &quot;클릭&quot;에는 개별 &lt;code&gt;debounce&lt;/code&gt; 값이 없으므로 &lt;code&gt;*&lt;/code&gt; 디 바운스 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="abfb67eb59ab08df12629d4b3ef24f1ebe6f52a0" translate="yes" xml:space="preserve">
          <source>The control is considered valid only if value is entered.</source>
          <target state="translated">값을 입력 한 경우에만 컨트롤이 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fa321ff4c1ce8fe572062a8932217d90b3164a6f" translate="yes" xml:space="preserve">
          <source>The controller for the &lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; directive. The controller exposes a few utility methods that can be used to augment the behavior of a regular or an &lt;a href=&quot;../directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select element.</source>
          <target state="translated">&lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; 지시문 의 컨트롤러입니다 . 컨트롤러는 일반 또는 &lt;a href=&quot;../directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; 선택 요소 의 동작을 향상시키는 데 사용할 수있는 몇 가지 유틸리티 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7009c81217bd6326e450d4c97f26dbfd83bc15a0" translate="yes" xml:space="preserve">
          <source>The controller for the &lt;a href=&quot;directive/select&quot;&gt;select&lt;/a&gt; directive. The controller exposes a few utility methods that can be used to augment the behavior of a regular or an &lt;a href=&quot;directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; select element.</source>
          <target state="translated">&lt;a href=&quot;directive/select&quot;&gt;select&lt;/a&gt; 지시문 의 컨트롤러입니다 . 컨트롤러는 일반 또는 &lt;a href=&quot;directive/ngoptions&quot;&gt;ngOptions&lt;/a&gt; 선택 요소 의 동작을 향상시키는 데 사용할 수있는 몇 가지 유틸리티 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="498432a4da793f7e778133b7144b7aa9f4769cd3" translate="yes" xml:space="preserve">
          <source>The controller instance can be published into a scope property by specifying &lt;code&gt;ng-controller=&quot;as propertyName&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ng-controller=&quot;as propertyName&quot;&lt;/code&gt; 을 지정하여 컨트롤러 인스턴스를 범위 속성으로 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8ae95787b8cec655ad357bed40a98949c9101e8" translate="yes" xml:space="preserve">
          <source>The controller whose validity state is triggering the change.</source>
          <target state="translated">유효성 상태가 변경을 트리거하는 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="5e5b86677d2c9438f2a6d9bb85589a00354fcb67" translate="yes" xml:space="preserve">
          <source>The controls can be accessed normally, but adding to, or removing controls from the array has no effect on the form. Instead, use &lt;a href=&quot;form.formcontroller#%24addControl.html&quot;&gt;&lt;code&gt;$addControl()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;form.formcontroller#%24removeControl.html&quot;&gt;&lt;code&gt;$removeControl()&lt;/code&gt;&lt;/a&gt; for this use-case. Likewise, adding a control to, or removing a control from the form is not reflected in the shallow copy. That means you should get a fresh copy from &lt;code&gt;$getControls()&lt;/code&gt; every time you need access to the controls.</source>
          <target state="translated">컨트롤은 정상적으로 액세스 할 수 있지만 배열에 컨트롤을 추가하거나 제거해도 폼에는 영향을 미치지 않습니다. 대신 이 사용 사례에 &lt;a href=&quot;form.formcontroller#%24addControl.html&quot;&gt; &lt;code&gt;$addControl()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;form.formcontroller#%24removeControl.html&quot;&gt; &lt;code&gt;$removeControl()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오. 마찬가지로 폼에 컨트롤을 추가하거나 폼에서 컨트롤을 제거해도 얕은 복사본에는 반영되지 않습니다. 즉 , 컨트롤에 액세스해야 할 때마다 &lt;code&gt;$getControls()&lt;/code&gt; 에서 새로운 사본을 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="90313e345675668509c608402c284aebafe8c90b" translate="yes" xml:space="preserve">
          <source>The copy or updated &lt;code&gt;destination&lt;/code&gt;, if &lt;code&gt;destination&lt;/code&gt; was specified.</source>
          <target state="translated">&lt;code&gt;destination&lt;/code&gt; 이 지정된 경우 복사 또는 업데이트 된 &lt;code&gt;destination&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ced3c50f80c61d3e28cb231ba0b8420428955dc" translate="yes" xml:space="preserve">
          <source>The correct way to write it:</source>
          <target state="translated">그것을 쓰는 올바른 방법 :</target>
        </trans-unit>
        <trans-unit id="8375ae9af024014319d46b0caa7eb954a5fa2f4b" translate="yes" xml:space="preserve">
          <source>The current CSS className expression value. If null then there is no expression value</source>
          <target state="translated">현재 CSS className 표현식 값입니다. null의 경우, 표현 치가 없다</target>
        </trans-unit>
        <trans-unit id="4382786c94714f27b89613774f7c4bebd55f76e9" translate="yes" xml:space="preserve">
          <source>The current CSS className value</source>
          <target state="translated">현재 CSS className 값</target>
        </trans-unit>
        <trans-unit id="c0b92d2699b7faed501975cc1cf13d3e78b33478" translate="yes" xml:space="preserve">
          <source>The current default is 10 iterations.</source>
          <target state="translated">현재 기본값은 10 회입니다.</target>
        </trans-unit>
        <trans-unit id="7aedd08ef47f8be2668af8dd80fb24b7ee28cfe2" translate="yes" xml:space="preserve">
          <source>The current filter function or &lt;code&gt;null&lt;/code&gt; if there is none set.</source>
          <target state="translated">현재의 필터 기능 . 설정되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66a28e07fb4d893df0b667def66654991100a49e" translate="yes" xml:space="preserve">
          <source>The current info object for this module if called as a getter, or &lt;code&gt;this&lt;/code&gt; if called as a setter.</source>
          <target state="translated">이 모듈에 대한 현재 정보 객체는 경우 게터로 불리는, 또는 &lt;code&gt;this&lt;/code&gt; 경우 세터로했다.</target>
        </trans-unit>
        <trans-unit id="9a9d02cc8cc112d35feadb1312a2714232a47ad3" translate="yes" xml:space="preserve">
          <source>The current scope is excluded from the count. The count includes all isolate child scopes.</source>
          <target state="translated">현재 범위는 카운트에서 제외됩니다. 이 계수에는 모든 분리 하위 범위가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a3ef084525022e52ff91e7bc6b6be1d8ef3c412b" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; flag if used as a getter or itself (for chaining) if used as a setter.</source>
          <target state="translated">게터로 사용되는 경우 &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; 플래그 의 현재 값 또는 세터로 사용되는 경우 자체 (체인 용)</target>
        </trans-unit>
        <trans-unit id="3c55e9fab58239a31ab41674e07793cb9edc1d92" translate="yes" xml:space="preserve">
          <source>The currently set blacklist array.</source>
          <target state="translated">현재 설정된 블랙리스트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9b8df1933a459dcfe4c11ef0936f54fd838b71b8" translate="yes" xml:space="preserve">
          <source>The currently set whitelist array.</source>
          <target state="translated">현재 설정된 화이트리스트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="8c2f3e1e231bfffe01f6a171d21c8de2da159f70" translate="yes" xml:space="preserve">
          <source>The custom &lt;code&gt;redirectTo&lt;/code&gt; function is expected to return a string which will be used to update &lt;code&gt;$location.url()&lt;/code&gt;. If the function throws an error, no further processing will take place and the &lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$routeChangeError&lt;/a&gt; event will be fired.</source>
          <target state="translated">사용자 지정 &lt;code&gt;redirectTo&lt;/code&gt; 함수는 &lt;code&gt;$location.url()&lt;/code&gt; 을 업데이트하는 데 사용될 문자열을 반환해야합니다 . 함수가 오류를 발생 시키면 더 이상 처리되지 않으며 &lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$ routeChangeError&lt;/a&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="517928a1a0c975c35a5f6371b16dbf98f8e18922" translate="yes" xml:space="preserve">
          <source>The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such as &lt;strong&gt;data-ng-repeat-start&lt;/strong&gt;, &lt;strong&gt;x-ng-repeat-start&lt;/strong&gt; and &lt;strong&gt;ng:repeat-start&lt;/strong&gt;).</source>
          <target state="translated">ngRepeat의 사용자 정의 시작 및 종료 지점은 AngularJS에서 제공하는 다른 모든 HTML 지시문 구문을 지원합니다 (예 : &lt;strong&gt;data-ng-repeat-start&lt;/strong&gt; , &lt;strong&gt;x-ng-repeat-start&lt;/strong&gt; 및 &lt;strong&gt;ng : repeat-start&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cf9ca1b48f086d137d2fcb4ce7667c3b44ff3ed" translate="yes" xml:space="preserve">
          <source>The debugger allows you to access the currently selected element in the console as &lt;code&gt;$0&lt;/code&gt; variable.</source>
          <target state="translated">디버거를 사용하면 콘솔에서 현재 선택된 요소에 &lt;code&gt;$0&lt;/code&gt; 변수 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3082e7b0af57ed1e4eff6c089ae1878d3da1901b" translate="yes" xml:space="preserve">
          <source>The declaration should be created in the format of &lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$http.config&lt;/a&gt;:</source>
          <target state="translated">선언은 &lt;a href=&quot;../../ng/service/%24http#usage.html&quot;&gt;$ http.config&lt;/a&gt; 형식으로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d28f0c2f0f5b42bd7a8d61c72d07ab41bac315ed" translate="yes" xml:space="preserve">
          <source>The declarative process is easier to understand.</source>
          <target state="translated">선언적 프로세스는 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c0cfb0f1a7c425f909fe0bc36aa9ca3838fbff7c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;$isEmpty&lt;/code&gt; function checks whether the value is &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;$isEmpty&lt;/code&gt; 함수는 값이 &lt;code&gt;undefined&lt;/code&gt; 않은지 , &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="6418bf8b84a736c531737d93d5eebd5e4c6bf159" translate="yes" xml:space="preserve">
          <source>The default CSS for &lt;code&gt;ngHide&lt;/code&gt;, the inverse method to &lt;code&gt;ngShow&lt;/code&gt;, makes ngAria redundant. It toggles &lt;code&gt;aria-hidden&lt;/code&gt; on the directive when it is hidden or shown, but the content is already hidden with &lt;code&gt;display: none&lt;/code&gt;. See explanation for &lt;a href=&quot;accessibility#ngshow.html&quot;&gt;ngShow&lt;/a&gt; when overriding the default CSS.</source>
          <target state="translated">의 기본 CSS &lt;code&gt;ngHide&lt;/code&gt; 에 역 방법 &lt;code&gt;ngShow&lt;/code&gt; 은 , ngAria의 중복을합니다. 지시문이 숨겨 지거나 표시되면 지시문에서 &lt;code&gt;aria-hidden&lt;/code&gt; 을 토글 하지만 내용은 이미 &lt;code&gt;display: none&lt;/code&gt; 숨겨져 있습니다. 기본 CSS를 재정의 할 때 &lt;a href=&quot;accessibility#ngshow.html&quot;&gt;ngShow에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58168ad0626f3db21d1a561fbfb468e194ad0a4e" translate="yes" xml:space="preserve">
          <source>The default actions are:</source>
          <target state="translated">기본 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="165f67c4b986077c141a0b4eb8be5a4d57bb86e9" translate="yes" xml:space="preserve">
          <source>The default behaviour in &lt;code&gt;ngModel&lt;/code&gt; is that the model value is set to &lt;code&gt;undefined&lt;/code&gt; when the validation determines that the value is invalid. By setting the &lt;code&gt;allowInvalid&lt;/code&gt; property to true, the model will still be updated even if the value is invalid.</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 의 기본 동작 은 유효성 검사에서 값이 유효하지 않다고 결정할 때 모델 값이 &lt;code&gt;undefined&lt;/code&gt; 것으로 설정되는 것 입니다. &lt;code&gt;allowInvalid&lt;/code&gt; 속성을 true 로 설정하면 값이 유효하지 않은 경우에도 모델이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="f996c0e32ed6964a734c9d13e1970793b933d9c8" translate="yes" xml:space="preserve">
          <source>The default cache value can be set by updating the &lt;a href=&quot;%24http#defaults.html&quot;&gt;&lt;code&gt;$http.defaults.cache&lt;/code&gt;&lt;/a&gt; property or the &lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt;&lt;code&gt;$httpProvider.defaults.cache&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">기본 캐시 값은 &lt;a href=&quot;%24http#defaults.html&quot;&gt; &lt;code&gt;$http.defaults.cache&lt;/code&gt; &lt;/a&gt; 속성 또는&lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt; &lt;code&gt;$httpProvider.defaults.cache&lt;/code&gt; &lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="a306ec119f2eaccbe8d649fada9aaf660ff1448f" translate="yes" xml:space="preserve">
          <source>The default comparator</source>
          <target state="translated">기본 비교기</target>
        </trans-unit>
        <trans-unit id="465c73e00ec2667af675d53734d888ec91f718c7" translate="yes" xml:space="preserve">
          <source>The default instance of &lt;code&gt;$sceDelegate&lt;/code&gt; should work out of the box with little pain. While you can override it completely to change the behavior of &lt;code&gt;$sce&lt;/code&gt;, the common case would involve configuring the &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$sceDelegateProvider&lt;/a&gt; instead by setting your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as templates. Refer &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;$sceDelegateProvider.resourceUrlBlacklist&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;$sceDelegate&lt;/code&gt; 의 기본 인스턴스는 별다른 고통없이 작동합니다. &lt;code&gt;$sce&lt;/code&gt; 의 동작을 변경하기 위해 완전히 무시할 수 있지만 일반적인 경우에는&lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;&lt;/a&gt; 템플릿과 같은 AngularJS 리소스를로드하는 데 사용되는 URL을 신뢰하기 위해 자체 화이트리스트 및 블랙리스트를 설정하여 $ sceDelegateProvider 를 입니다. &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;$ sceDelegateProvider.resourceUrlWhitelist&lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;$ sceDelegateProvider.resourceUrlBlacklist를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fe33aadf3de1f1f3b0fe8806c8376a4a04f5ea1" translate="yes" xml:space="preserve">
          <source>The default is to log &lt;code&gt;debug&lt;/code&gt; messages. You can use &lt;a href=&quot;../provider/%24logprovider&quot;&gt;ng.$logProvider#debugEnabled&lt;/a&gt; to change this.</source>
          <target state="translated">기본값은 로그입니다 &lt;code&gt;debug&lt;/code&gt; 메시지 하는 것 입니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;../provider/%24logprovider&quot;&gt;NG. $ logProvider # debugEnabled을&lt;/a&gt; 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04bb80a0e51b2e3fa92fe97b18ff2c753c1617a0" translate="yes" xml:space="preserve">
          <source>The default value for the prefix is &lt;code&gt;'!'&lt;/code&gt;.</source>
          <target state="translated">접두사의 기본값은 &lt;code&gt;'!'&lt;/code&gt; 입니다..</target>
        </trans-unit>
        <trans-unit id="5bced592a048c4e28bc51dd718accfdb3fc3710b" translate="yes" xml:space="preserve">
          <source>The default value is false.</source>
          <target state="translated">기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="d93c5aa93414c0c9151cab4bbeb573041c98a22c" translate="yes" xml:space="preserve">
          <source>The default value is true.</source>
          <target state="translated">기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="1d4e6cb0347f97a10e0bfcabf516d77b15974d7c" translate="yes" xml:space="preserve">
          <source>The default values satisfy a wide range of usecases, but you may choose to overwrite any of them to further customize your instances. The available properties are:</source>
          <target state="translated">기본값은 광범위한 사용 사례를 충족하지만 인스턴스를 추가로 사용자 지정하기 위해이를 덮어 쓰도록 선택할 수 있습니다. 사용 가능한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d058a405d150881e8c02cef5a763d1a9cac9129" translate="yes" xml:space="preserve">
          <source>The default, built-in comparator should be sufficient for most usecases. In short, it compares numbers numerically, strings alphabetically (and case-insensitively), for objects falls back to using their index in the original collection, sorts values of different types by type and puts &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; values at the end of the sorted list.</source>
          <target state="translated">기본 내장 비교기는 대부분의 사용 사례에 충분해야합니다. 즉, 숫자를 숫자 순으로, 문자열을 알파벳순으로 (대소 문자를 구분하지 않고) 비교합니다. 객체가 원래 컬렉션에서 색인을 사용하여 다시 돌아오고 유형별로 다른 유형의 값을 정렬하고 정렬 &lt;code&gt;undefined&lt;/code&gt; 값 과 &lt;code&gt;null&lt;/code&gt; 값을 정렬 된 목록의 끝에 넣습니다. .</target>
        </trans-unit>
        <trans-unit id="f8a104f5d8a2055e932927787187ea1605cde61f" translate="yes" xml:space="preserve">
          <source>The defaults can also be set at runtime via the &lt;code&gt;$http.defaults&lt;/code&gt; object in the same fashion. For example:</source>
          <target state="translated">기본값은 런타임시 다음을 통해 설정할 수도 있습니다. &lt;code&gt;$http.defaults&lt;/code&gt; 동일한 방식으로 $ http.defaults 객체 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a63d9c4d9deff7d05bd9e7b756db067981e19e91" translate="yes" xml:space="preserve">
          <source>The diagram and the example below describe how AngularJS interacts with the browser's event loop.</source>
          <target state="translated">아래 다이어그램과 예제는 AngularJS가 브라우저의 이벤트 루프와 상호 작용하는 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5985a11da86b3a9b2c8dd516c741a69a00b22550" translate="yes" xml:space="preserve">
          <source>The difference between Compile and Link</source>
          <target state="translated">컴파일과 링크의 차이점</target>
        </trans-unit>
        <trans-unit id="282c0e17a8f643432cf46d1ac582e22bfd94be70" translate="yes" xml:space="preserve">
          <source>The difference resides in the return value of the factory function. You can either return a &lt;a href=&quot;%24compile#directive-definition-object.html&quot;&gt;Directive Definition Object (see below)&lt;/a&gt; that defines the directive properties, or just the &lt;code&gt;postLink&lt;/code&gt; function (all other properties will have the default values).</source>
          <target state="translated">차이는 팩토리 함수의 반환 값에 있습니다. 지시문 속성을 정의하는 지시문 &lt;a href=&quot;%24compile#directive-definition-object.html&quot;&gt;정의 객체 (아래 참조)&lt;/a&gt; 또는 &lt;code&gt;postLink&lt;/code&gt; 만 반환 할 수 있습니다. 함수 (다른 모든 속성에는 기본값이 있음).</target>
        </trans-unit>
        <trans-unit id="9dd111b228d3d65fff5c43c5f7db648c685d4fa3" translate="yes" xml:space="preserve">
          <source>The directive can be applied to the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; element, but the preferred usage is to apply multiple &lt;code&gt;ngCloak&lt;/code&gt; directives to small portions of the page to permit progressive rendering of the browser view.</source>
          <target state="translated">지시문은 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 요소에 적용 할 수 있지만 선호하는 사용법은 여러 &lt;code&gt;ngCloak&lt;/code&gt; 지시문을 페이지의 작은 부분에 적용 하여 브라우저보기를 점진적으로 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73b6dab32084cac10b23ad24d2acde7b9e588021" translate="yes" xml:space="preserve">
          <source>The directive definition object provides instructions to the &lt;a href=&quot;%24compile&quot;&gt;compiler&lt;/a&gt;. The attributes are:</source>
          <target state="translated">지시문 정의 객체는 &lt;a href=&quot;%24compile&quot;&gt; 컴파일러에&lt;/a&gt; . 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15084cf390b2739682db07ef53f0e5ed0841df53" translate="yes" xml:space="preserve">
          <source>The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it from the template cache), &lt;code&gt;ngSwitch&lt;/code&gt; simply chooses one of the nested elements and makes it visible based on which element matches the value obtained from the evaluated expression. In other words, you define a container element (where you place the directive), place an expression on the &lt;strong&gt;&lt;code&gt;on=&quot;...&quot;&lt;/code&gt; attribute&lt;/strong&gt; (or the &lt;strong&gt;&lt;code&gt;ng-switch=&quot;...&quot;&lt;/code&gt; attribute&lt;/strong&gt;), define any inner elements inside of the directive and place a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on expression is evaluated. If a matching expression is not found via a when attribute then an element with the default attribute is displayed.</source>
          <target state="translated">지시문 자체는 ngInclude와 유사하게 작동하지만 템플릿 코드를 다운로드하거나 템플릿 캐시에서로드하는 대신 &lt;code&gt;ngSwitch&lt;/code&gt; 는 중첩 된 요소 중 하나를 선택하여 평가 된 식에서 얻은 값과 일치하는 요소를 기반으로 표시합니다. 즉, 컨테이너 요소 (지시문을 배치 할 위치)를 정의하고 &lt;strong&gt; &lt;code&gt;on=&quot;...&quot;&lt;/code&gt; 속성&lt;/strong&gt; (또는 &lt;strong&gt; &lt;code&gt;ng-switch=&quot;...&quot;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 속성 &lt;/strong&gt;&lt;strong&gt;에&lt;/strong&gt; 표현식을 배치 &lt;strong&gt;합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;), 지시문 내부에 내부 요소를 정의하고 요소 당 when 속성을 배치하십시오. when 속성은 on 표현식이 평가 될 때 표시 할 요소를 ngSwitch에 알리는 데 사용됩니다. when 속성을 통해 일치하는 표현식을 찾지 못하면 기본 속성을 가진 요소가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bc305a9daf06fb29b927a141c769f1857bf13fe7" translate="yes" xml:space="preserve">
          <source>The directive operates in three different ways, depending on which of three types the expression evaluates to:</source>
          <target state="translated">지시문은식이 평가하는 세 가지 유형에 따라 세 가지 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="00457ef4c0d1bfc1d66159cc11032117ca66eb2f" translate="yes" xml:space="preserve">
          <source>The directive sets the &lt;code&gt;required&lt;/code&gt; attribute on the element if the AngularJS expression inside &lt;code&gt;ngRequired&lt;/code&gt; evaluates to true. A special directive for setting &lt;code&gt;required&lt;/code&gt; is necessary because we cannot use interpolation inside &lt;code&gt;required&lt;/code&gt;. See the &lt;a href=&quot;../../../guide/interpolation&quot;&gt;interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">지시문은 &lt;code&gt;ngRequired&lt;/code&gt; 내의 AngularJS 표현식 이 true로 평가되는 경우 요소에 &lt;code&gt;required&lt;/code&gt; 속성을 설정 합니다. &lt;code&gt;required&lt;/code&gt; 내부에 보간을 사용할 수 없기 때문에 필요한 설정에 대한 특수 지시문 이 필요 &lt;code&gt;required&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="511cc4dca94e3becdfd05d6159bf6c72e0c27b2a" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;../type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;../type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 가 &lt;strong&gt;구성 요소를&lt;/strong&gt; 렌더링해야하는 위치를 식별하는 지시문&lt;strong&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="a19715b5a8ea141e59e2b3d389be6963e887a773" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 가 &lt;strong&gt;구성 요소를&lt;/strong&gt; 렌더링해야하는 위치를 식별하는 지시문 .</target>
        </trans-unit>
        <trans-unit id="91b3106d7e0128b073f59400b2d855bf5dc85ef6" translate="yes" xml:space="preserve">
          <source>The directive that identifies where the &lt;a href=&quot;type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt; should render its &lt;strong&gt;Components&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 가 &lt;strong&gt;구성 요소를&lt;/strong&gt; 렌더링해야하는 위치를 식별하는 지시문 .</target>
        </trans-unit>
        <trans-unit id="f8e427fdf8b7a0e2bc769988a131cb6027a72d85" translate="yes" xml:space="preserve">
          <source>The directive won't add duplicate classes if a particular class was already set.</source>
          <target state="translated">지시문은 특정 클래스가 이미 설정된 경우 중복 클래스를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af273d442182f77e2838bf78efeac232e7701baf" translate="yes" xml:space="preserve">
          <source>The easiest way to reference the control's &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; method is by making sure the input is placed inside a form that has a &lt;code&gt;name&lt;/code&gt; attribute. This is important because &lt;code&gt;form&lt;/code&gt; controllers are published to the related scope under the name in their &lt;code&gt;name&lt;/code&gt; attribute.</source>
          <target state="translated">컨트롤의 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt; 메서드 를 참조하는 가장 쉬운 방법 은 &lt;code&gt;name&lt;/code&gt; 속성 이있는 양식 안에 입력을 배치하는 것입니다 . &lt;code&gt;form&lt;/code&gt; 컨트롤러는 &lt;code&gt;name&lt;/code&gt; 속성 의 이름으로 관련 범위에 게시 되므로 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="b2fa37ba708729a70880e839aacbcf83f7ee4ecc" translate="yes" xml:space="preserve">
          <source>The easiest way to unit-test a component controller is by using the &lt;a href=&quot;../api/ngmock/service/%24componentcontroller&quot;&gt;$componentController&lt;/a&gt; that is included in &lt;a href=&quot;../api/ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt;. The advantage of this method is that you do not have to create any DOM elements. The following example shows how to do this for the &lt;code&gt;heroDetail&lt;/code&gt; component from above.</source>
          <target state="translated">컴포넌트 컨트롤러를 단위 테스트하는 가장 쉬운 방법 은 &lt;a href=&quot;../api/ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; 에&lt;/a&gt; 포함 된 &lt;a href=&quot;../api/ngmock/service/%24componentcontroller&quot;&gt;$ componentController&lt;/a&gt; 를 사용하는 것 입니다. 이 방법의 장점은 DOM 요소를 만들 필요가 없다는 것입니다. 다음 예제는 &lt;code&gt;heroDetail&lt;/code&gt; 에 대해이를 수행하는 방법을 보여줍니다. 위에서 컴포넌트에 .</target>
        </trans-unit>
        <trans-unit id="1dba15ddc68176129beff67ce23ae391d8f5e9b2" translate="yes" xml:space="preserve">
          <source>The element is shown or hidden by removing or adding the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class onto the element. The &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is predefined in AngularJS and sets the display style to none (using an &lt;code&gt;!important&lt;/code&gt; flag). For CSP mode please add &lt;code&gt;angular-csp.css&lt;/code&gt; to your HTML file (see &lt;a href=&quot;ngcsp&quot;&gt;ngCsp&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스를 요소에서 제거하거나 추가하여 요소가 표시되거나 숨겨집니다 . &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스는 AngularJS와의 사전 정의 (AN 사용 none으로 표시 스타일 설정입니다 &lt;code&gt;!important&lt;/code&gt; 플래그). CSP 모드의 경우 &lt;code&gt;angular-csp.css&lt;/code&gt; 를 HTML 파일에 추가 하십시오 ( &lt;a href=&quot;ngcsp&quot;&gt;ngCsp&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7ccfb7caa29243ea5f83ef0ab8642feaa5add93c" translate="yes" xml:space="preserve">
          <source>The element name or '*' to match any element.</source>
          <target state="translated">요소 이름 또는 '*'는 요소와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d6f6332d7faa347a9930f464a7c8e2d5542086d4" translate="yes" xml:space="preserve">
          <source>The empty array in &lt;code&gt;angular.module('myApp', [])&lt;/code&gt;. This array is the list of modules &lt;code&gt;myApp&lt;/code&gt; depends on.</source>
          <target state="translated">&lt;code&gt;angular.module('myApp', [])&lt;/code&gt; 의 빈 배열입니다 . 이 배열은 &lt;code&gt;myApp&lt;/code&gt; 모듈 목록입니다. 의존하는 .</target>
        </trans-unit>
        <trans-unit id="7bc9a115378ed99db9c2142b56d9fc3aa535767e" translate="yes" xml:space="preserve">
          <source>The enter and leave animation occur concurrently.</source>
          <target state="translated">들어오고 나가는 애니메이션이 동시에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b13d56ee0aa77bc8cf191a0098e0ae12681eb3cb" translate="yes" xml:space="preserve">
          <source>The event life cycle starts at the scope on which &lt;code&gt;$broadcast&lt;/code&gt; was called. All &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; listening for &lt;code&gt;name&lt;/code&gt; event on this scope get notified. Afterwards, the event propagates to all direct and indirect scopes of the current scope and calls all registered listeners along the way. The event cannot be canceled.</source>
          <target state="translated">이벤트 수명주기는 &lt;code&gt;$broadcast&lt;/code&gt; 가 호출 된 범위에서 시작됩니다 . 이 범위 에서 &lt;code&gt;name&lt;/code&gt; 이벤트를 수신하는 모든 &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;리스너&lt;/a&gt; 에게 알립니다. 그 후 이벤트는 현재 범위의 모든 직접 및 간접 범위로 전파되고 등록 된 모든 리스너를 도중에 호출합니다. 이벤트를 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef1ec4f5065965f767cdb19361d488e339b8e865" translate="yes" xml:space="preserve">
          <source>The event life cycle starts at the scope on which &lt;code&gt;$emit&lt;/code&gt; was called. All &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; listening for &lt;code&gt;name&lt;/code&gt; event on this scope get notified. Afterwards, the event traverses upwards toward the root scope and calls all registered listeners along the way. The event will stop propagating if one of the listeners cancels it.</source>
          <target state="translated">이벤트 수명주기는 &lt;code&gt;$emit&lt;/code&gt; 이 호출 된 범위에서 시작됩니다 . &lt;code&gt;name&lt;/code&gt; 듣는 모든 &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;청취자&lt;/a&gt;이 범위 이벤트를 에게 알립니다. 그 후, 이벤트는 루트 범위를 향해 위쪽으로 이동하고 등록 된 모든 리스너를 그 길을 따라 호출합니다. 리스너 중 하나가 취소하면 이벤트 전파가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="9dba21cdf767393b24f9c532ed6d7024629e7654" translate="yes" xml:space="preserve">
          <source>The event listener function format is: &lt;code&gt;function(event, args...)&lt;/code&gt;. The &lt;code&gt;event&lt;/code&gt; object passed into the listener has the following attributes:</source>
          <target state="translated">이벤트 리스너 함수 형식은 &lt;code&gt;function(event, args...)&lt;/code&gt; 입니다. 리스너에 전달 된 &lt;code&gt;event&lt;/code&gt; 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9dc8aea8f492b469f1f28002083ced0171b9068" translate="yes" xml:space="preserve">
          <source>The event's callback gets executed. This enters the JavaScript context. The callback can modify the DOM structure.</source>
          <target state="translated">이벤트의 콜백이 실행됩니다. JavaScript 컨텍스트로 들어갑니다. 콜백은 DOM 구조를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6d577c1df19a49c4d3d3fea271e11112de46dcd" translate="yes" xml:space="preserve">
          <source>The example above also contains a &lt;a href=&quot;filter&quot;&gt;filter&lt;/a&gt;. A filter formats the value of an expression for display to the user. In the example above, the filter &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;&lt;code&gt;currency&lt;/code&gt;&lt;/a&gt; formats a number into an output that looks like money.</source>
          <target state="translated">위의 예에는 &lt;a href=&quot;filter&quot;&gt;필터&lt;/a&gt; 도 포함되어 있습니다 . 필터는 사용자에게 표시 할 표현식 값의 형식을 지정합니다. 위의 예에서 필터 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt; &lt;code&gt;currency&lt;/code&gt; &lt;/a&gt; 는 숫자를 돈처럼 보이는 출력 형식으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="93c49d25f095d6630edee2c4ee7687214904ed84" translate="yes" xml:space="preserve">
          <source>The example above sets up a transition for both the in and out phases, but we can also target the out or in phases directly via &lt;code&gt;ng-anchor-out&lt;/code&gt; and &lt;code&gt;ng-anchor-in&lt;/code&gt;.</source>
          <target state="translated">위의 예는 시작 및 종료 단계 모두에 대한 전환을 설정하지만 &lt;code&gt;ng-anchor-out&lt;/code&gt; 및 &lt;code&gt;ng-anchor-in&lt;/code&gt; 을 통해 직접 또는 단계를 대상으로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae348e668faf38c45aa29b06f0b38359e62a7332" translate="yes" xml:space="preserve">
          <source>The example also shows the &quot;offset&quot; keyword, which allows you to offset the value of the &quot;#&quot; variable.</source>
          <target state="translated">또한 &quot;#&quot;변수의 값을 오프셋 할 수있는 &quot;offset&quot;키워드도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dcef32a0c9e7e773d2caa1d0facc04649077955b" translate="yes" xml:space="preserve">
          <source>The example below demonstrates a simple &lt;a href=&quot;../directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;, where the data is sorted by age in descending order (expression is set to &lt;code&gt;'-age'&lt;/code&gt;). The &lt;code&gt;comparator&lt;/code&gt; is not set, which means it defaults to the built-in comparator.</source>
          <target state="translated">아래 예제는 간단한 &lt;a href=&quot;../directive/ngrepeat&quot;&gt;ngRepeat를&lt;/a&gt; 보여줍니다. 여기서 데이터는 연령별로 내림차순으로 정렬됩니다 (표현식은 &lt;code&gt;'-age'&lt;/code&gt; 로 설정 됨 ). &lt;code&gt;comparator&lt;/code&gt; 내장 비교기에 기본값을 의미하는 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="118b4a4365ad487da58b1630aea69b571bfdefff" translate="yes" xml:space="preserve">
          <source>The example below demonstrates how to perform animations using ngClass.</source>
          <target state="translated">아래 예제는 ngClass를 사용하여 애니메이션을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b5901cc794ac4afcb24616439a439ca1a38725ff" translate="yes" xml:space="preserve">
          <source>The example below illustrates the use of a vertical scroll-offset (specified as a fixed value). See &lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;$anchorScroll.yOffset&lt;/a&gt; for more details.</source>
          <target state="translated">아래 예제는 세로 스크롤 오프셋 (고정 값으로 지정)을 사용하는 방법을 보여줍니다. 자세한 내용은 &lt;a href=&quot;%24anchorscroll#yOffset.html&quot;&gt;$ anchorScroll.yOffset&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a78d05887665a9a98ad3b3ca5dd98170ce670e6e" translate="yes" xml:space="preserve">
          <source>The example below makes use of this feature:</source>
          <target state="translated">아래 예는이 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="14f320b8cc2e2763c82039f6b188aeca101a77fe" translate="yes" xml:space="preserve">
          <source>The example below showcases a more advanced version of the &lt;code&gt;.fold-animation&lt;/code&gt; from the example above:</source>
          <target state="translated">아래 예는 위 예에서 &lt;code&gt;.fold-animation&lt;/code&gt; 의 고급 버전을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e6fe351ea2c33b51b2ae753847781d2a1ebb1324" translate="yes" xml:space="preserve">
          <source>The example below shows how an &lt;code&gt;enter&lt;/code&gt; animation can be made possible on an element using &lt;code&gt;ng-if&lt;/code&gt;:</source>
          <target state="translated">아래 예제는 &lt;code&gt;ng-if&lt;/code&gt; 를 사용하여 요소에서 &lt;code&gt;enter&lt;/code&gt; 애니메이션을 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d01c3c0993f97fc120473f6fed8b31a7663c420f" translate="yes" xml:space="preserve">
          <source>The example below shows how to perform animations during class changes:</source>
          <target state="translated">아래 예는 수업 변경 중에 애니메이션을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6205078d09d3fd1c6edadc598319a67cba2952e4" translate="yes" xml:space="preserve">
          <source>The example below shows how we can create a folding animation on an element using &lt;code&gt;ng-if&lt;/code&gt;:</source>
          <target state="translated">아래 예제는 &lt;code&gt;ng-if&lt;/code&gt; 를 사용하여 요소에 접는 애니메이션을 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9e746afeaac000344d9d6b97ab0c580a09fc7751" translate="yes" xml:space="preserve">
          <source>The example below therefore calls the filter directly in the controller. By this, the controller is able to call the filter only when needed (e.g. when the data is loaded from the backend or the filter expression is changed).</source>
          <target state="translated">따라서 아래 예제는 컨트롤러에서 직접 필터를 호출합니다. 이를 통해 컨트롤러는 필요할 때만 (예 : 백엔드에서 데이터가로드되거나 필터식이 변경 될 때) 필터를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de23243571a260c0d0fc8a2c48e1af5d73b5b207" translate="yes" xml:space="preserve">
          <source>The example below uses the filter called &lt;a href=&quot;../api/ng/filter/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;. This filter reduces arrays into sub arrays based on conditions. The filter can be applied in the view template with markup like &lt;code&gt;{{ctrl.array | filter:'a'}}&lt;/code&gt;, which would do a fulltext search for &quot;a&quot;. However, using a filter in a view template will reevaluate the filter on every digest, which can be costly if the array is big.</source>
          <target state="translated">아래 예제는 filter라는 &lt;a href=&quot;../api/ng/filter/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 사용합니다 . 이 필터는 조건에 따라 배열을 하위 배열로 줄입니다. 이 필터는 &lt;code&gt;{{ctrl.array | filter:'a'}}&lt;/code&gt; &quot;a&quot;에 대한 전체 텍스트 검색을 수행하는 filter : 'a'}} 그러나 뷰 템플릿에서 필터를 사용하면 모든 다이제스트에서 필터를 다시 평가하므로 배열이 큰 경우 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dffb86218d7a4f9da6fc690c45a79f6af3702634" translate="yes" xml:space="preserve">
          <source>The example below will overwrite the default &lt;code&gt;$exceptionHandler&lt;/code&gt; in order to (a) log uncaught errors to the backend for later inspection by the developers and (b) to use &lt;code&gt;$log.warn()&lt;/code&gt; instead of &lt;code&gt;$log.error()&lt;/code&gt;.</source>
          <target state="translated">아래의 예는 기본 덮어 &lt;code&gt;$exceptionHandler&lt;/code&gt; (가) 사용 후에 개발자에 의한 검사와 (b)에 대한 백엔드에 포착되지 않은 오류 로그에 위해를 &lt;code&gt;$log.warn()&lt;/code&gt; 대신 &lt;code&gt;$log.error()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffbd243d6aa30bd959233397fedd53c9c8be3b8b" translate="yes" xml:space="preserve">
          <source>The example module below has two services, each with various dependencies:</source>
          <target state="translated">아래 예제 모듈에는 각각 다양한 종속성이있는 두 가지 서비스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b88996606efd1a2fa2d1f8ee91c2b93f5de125" translate="yes" xml:space="preserve">
          <source>The examples use the &lt;a href=&quot;http://jasmine.github.io/&quot;&gt;Jasmine&lt;/a&gt; testing framework.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;http://jasmine.github.io/&quot;&gt;Jasmine&lt;/a&gt; 테스트 프레임 워크를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="69df9ff2c507a1bca5d9605667ecdf1f7c1667e3" translate="yes" xml:space="preserve">
          <source>The expression indicating how to enumerate a collection. These formats are currently supported:</source>
          <target state="translated">컬렉션을 열거하는 방법을 나타내는 식입니다. 이 형식은 현재 지원됩니다 :</target>
        </trans-unit>
        <trans-unit id="fb146546194737424a42b8fcad30d7883d5da959" translate="yes" xml:space="preserve">
          <source>The factory function is invoked only once when the &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;compiler&lt;/a&gt; matches the directive for the first time. You can perform any initialization work here. The function is invoked using &lt;a href=&quot;../api/auto/service/%24injector#invoke.html&quot;&gt;$injector.invoke&lt;/a&gt; which makes it injectable just like a controller.</source>
          <target state="translated">팩토리 함수는 &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;컴파일러&lt;/a&gt; 가 지시문을 처음으로 일치시킬 때 한 번만 호출됩니다 . 여기서 초기화 작업을 수행 할 수 있습니다. 이 함수는 &lt;a href=&quot;../api/auto/service/%24injector#invoke.html&quot;&gt;$ injector.invoke&lt;/a&gt; 를 사용하여 호출 되므로 컨트롤러처럼 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac0300463ee737a9762b2ab131e79710f19a302" translate="yes" xml:space="preserve">
          <source>The factory function that will be executed to return the animation object.</source>
          <target state="translated">애니메이션 객체를 반환하기 위해 실행될 팩토리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9b2b49cac29c83329e4d2e42cf31d5ed84a9baa0" translate="yes" xml:space="preserve">
          <source>The filter function is registered with the &lt;code&gt;$injector&lt;/code&gt; under the filter name suffix with &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="translated">필터 기능은 &lt;code&gt;$injector&lt;/code&gt; 에 &lt;code&gt;Filter&lt;/code&gt; 의 필터 이름 접미사로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad14f184c35849cbc77ad9f33986e01e4fc80461" translate="yes" xml:space="preserve">
          <source>The filter function should be a &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure function&lt;/a&gt;, which means that it should always return the same result given the same input arguments and should not affect external state, for example, other AngularJS services. AngularJS relies on this contract and will by default execute a filter only when the inputs to the function change. &lt;a href=&quot;filter#stateful-filters.html&quot;&gt;Stateful filters&lt;/a&gt; are possible, but less performant.</source>
          <target state="translated">필터 함수는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;순수&lt;/a&gt; 함수 여야합니다. 즉, 동일한 입력 인수가 지정된 경우 항상 동일한 결과를 반환해야하며 다른 AngularJS 서비스와 같은 외부 상태에는 영향을 미치지 않아야합니다. AngularJS는이 계약에 의존하며 기본적으로 함수 입력이 변경 될 때만 필터를 실행합니다. &lt;a href=&quot;filter#stateful-filters.html&quot;&gt;상태 저장 필터&lt;/a&gt; 는 가능하지만 성능이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="17c03d18cc2cc78ca4084addd3298d3bc070061e" translate="yes" xml:space="preserve">
          <source>The filter function which will be used to filter all animations. If a falsy value is returned, no animation will be performed. The function will be called with the following arguments:</source>
          <target state="translated">모든 애니메이션을 필터링하는 데 사용되는 필터 기능입니다. 잘못된 값이 반환되면 애니메이션이 수행되지 않습니다. 이 함수는 다음과 같은 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a937ae27c98f5d7954639b98bccb584d67a2cdbf" translate="yes" xml:space="preserve">
          <source>The final result is an array of those elements that the predicate returned true for.</source>
          <target state="translated">최종 결과는 술어가 true를 리턴 한 해당 요소의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c07e6b5dfc2388c07c722e7af813875eb5b9564a" translate="yes" xml:space="preserve">
          <source>The first issue we have to solve is that the dialog box template expects &lt;code&gt;title&lt;/code&gt; to be defined. But we would like the template's scope property &lt;code&gt;title&lt;/code&gt; to be the result of interpolating the &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; element's &lt;code&gt;title&lt;/code&gt; attribute (i.e. &lt;code&gt;&quot;Hello {{username}}&quot;&lt;/code&gt;). Furthermore, the buttons expect the &lt;code&gt;onOk&lt;/code&gt; and &lt;code&gt;onCancel&lt;/code&gt; functions to be present in the scope. This limits the usefulness of the widget. To solve the mapping issue we use the &lt;code&gt;scope&lt;/code&gt; to create local variables which the template expects as follows:</source>
          <target state="translated">우리가 해결해야 할 첫 번째 문제는 대화 상자 템플릿에 &lt;code&gt;title&lt;/code&gt; 이 정의되어 있어야한다는 것입니다. 그러나 템플릿의 스코프 속성 &lt;code&gt;title&lt;/code&gt; 이 보간 결과입니다. &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;title&lt;/code&gt; 속성 (예 : &lt;code&gt;&quot;Hello {{username}}&quot;&lt;/code&gt; ) . 또한 버튼은 &lt;code&gt;onOk&lt;/code&gt; 및 &lt;code&gt;onCancel&lt;/code&gt; 기능이 범위에있을 것으로 예상합니다 . 이것은 위젯의 유용성을 제한합니다. 매핑 문제를 해결하기 위해 &lt;code&gt;scope&lt;/code&gt; 를 사용하여 템플릿에서 다음과 같이 예상되는 로컬 변수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="afe6d764a0f6fdc60d923fd9d9a7197ddd360bfa" translate="yes" xml:space="preserve">
          <source>The first kind of new markup are the &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt;. They apply special behavior to attributes or elements in the HTML. In the example above we use the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ng-app&lt;/code&gt;&lt;/a&gt; attribute, which is linked to a directive that automatically initializes our application. AngularJS also defines a directive for the &lt;a href=&quot;../api/ng/directive/input&quot;&gt;&lt;code&gt;input&lt;/code&gt;&lt;/a&gt; element that adds extra behavior to the element. The &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;&lt;code&gt;ng-model&lt;/code&gt;&lt;/a&gt; directive stores/updates the value of the input field into/from a variable.</source>
          <target state="translated">새로운 마크 업의 첫 번째 종류는 &lt;a href=&quot;directive&quot;&gt; 지시어&lt;/a&gt; 입니다. HTML의 속성 또는 요소에 특수 동작을 적용합니다. 위의 예제에서 &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ng-app&lt;/code&gt; &lt;/a&gt; 속성을 사용합니다.이 속성은 응용 프로그램을 자동으로 초기화하는 지시문에 연결되어 있습니다. AngularJS는 또한 요소에 추가 동작을 추가 하는 &lt;a href=&quot;../api/ng/directive/input&quot;&gt; &lt;code&gt;input&lt;/code&gt; &lt;/a&gt; 요소에 대한 지시문을 정의합니다 . &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt; &lt;code&gt;ng-model&lt;/code&gt; &lt;/a&gt; 지시자 저장 / 가변으로부터 /으로의 입력 필드의 값을 갱신한다.</target>
        </trans-unit>
        <trans-unit id="72248b4ea7e8efbe0801cfc5a9d27f183313c350" translate="yes" xml:space="preserve">
          <source>The first time a template is used, it is loaded in the template cache for quick retrieval. You can load templates directly into the cache in a &lt;code&gt;script&lt;/code&gt; tag, by using &lt;a href=&quot;%24templaterequest&quot;&gt;&lt;code&gt;$templateRequest&lt;/code&gt;&lt;/a&gt;, or by consuming the &lt;code&gt;$templateCache&lt;/code&gt; service directly.</source>
          <target state="translated">템플릿을 처음 사용하는 경우 빠른 검색을 위해 템플릿 캐시에로드됩니다. &lt;a href=&quot;%24templaterequest&quot;&gt; &lt;code&gt;$templateRequest&lt;/code&gt; &lt;/a&gt; 를 사용 하거나 &lt;code&gt;$templateCache&lt;/code&gt; 서비스를 직접 사용하여 &lt;code&gt;script&lt;/code&gt; 태그 의 캐시에 템플릿을 직접로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61770f6e44a5dc9205ef2b85eee18df352de6525" translate="yes" xml:space="preserve">
          <source>The first two options of creating or looking up dependencies are not optimal because they hard code the dependency to the component. This makes it difficult, if not impossible, to modify the dependencies. This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.</source>
          <target state="translated">종속성을 생성하거나 조회하는 처음 두 옵션은 구성 요소에 대한 종속성을 하드 코딩하기 때문에 최적이 아닙니다. 이것은 불가능하지는 않지만 의존성을 수정하는 것을 어렵게 만듭니다. 이는 테스트 격리에 모의 종속성을 제공하는 것이 바람직한 테스트에서 특히 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="62d51362fba403748b0965a7020906ff662204d7" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element also &lt;strong&gt;matches&lt;/strong&gt;&lt;code&gt;ngModel&lt;/code&gt;:</source>
          <target state="translated">다음 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소는 &lt;code&gt;ngModel&lt;/code&gt; 과도 &lt;strong&gt;일치 &lt;/strong&gt;합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce1ad6bc1a7291d5ceb94bf63f28f4491ef44ee" translate="yes" xml:space="preserve">
          <source>The following CSS classes are added and removed on the associated input/select/textarea element depending on the validity of the model.</source>
          <target state="translated">다음 CSS 클래스는 모델의 유효성에 따라 연관된 입력 / 선택 / 텍스트 영역 요소에서 추가 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="24d21f0a2fb05faaab9a9fee5841089389838e09" translate="yes" xml:space="preserve">
          <source>The following actions are performed by this method:</source>
          <target state="translated">이 방법으로 다음 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="973c90fb359da23554571110c18a1c4f53efc003" translate="yes" xml:space="preserve">
          <source>The following always holds true:</source>
          <target state="translated">다음은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="36b240b14e8533a4756636899c699ce28b123d00" translate="yes" xml:space="preserve">
          <source>The following code demonstrates adding a new response transformation to be run after the default response transformations have been run.</source>
          <target state="translated">다음 코드는 기본 응답 변환이 실행 된 후 실행될 새 응답 변환을 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5254b655f465a130e45d925ee2b74ce105150f95" translate="yes" xml:space="preserve">
          <source>The following code shows how to setup and use the mock backend when unit testing a controller. First we create the controller under test:</source>
          <target state="translated">다음 코드는 컨트롤러를 테스트 할 때 모의 백엔드를 설정하고 사용하는 방법을 보여줍니다. 먼저 테스트중인 컨트롤러를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="df345b34d500c13d2031f5af048b74463c6d90d4" translate="yes" xml:space="preserve">
          <source>The following code snippet shows a template with &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt; and curly-brace &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; bindings:</source>
          <target state="translated">다음 코드 스 니펫은 &lt;a href=&quot;directive&quot;&gt;지시문&lt;/a&gt; 및 중괄호 &lt;a href=&quot;expression&quot;&gt;표현식&lt;/a&gt; 바인딩이 있는 템플리트를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c60eb5d3ceb258f2551ba66c48b7dc7f79064316" translate="yes" xml:space="preserve">
          <source>The following code will issue the &lt;strong&gt;ng-leave-stagger&lt;/strong&gt; event on the element provided:</source>
          <target state="translated">다음 코드는 제공된 요소 에서 &lt;strong&gt;ng-leave-stagger&lt;/strong&gt; 이벤트를 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd205de158756329787742f78166e78f85ffa62" translate="yes" xml:space="preserve">
          <source>The following default rules in CSP affect AngularJS:</source>
          <target state="translated">CSP의 다음 기본 규칙은 AngularJS에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="90134ab79d7f6b3200f1037dc0cc7a63032e5047" translate="yes" xml:space="preserve">
          <source>The following demonstrates the various ways a directive (&lt;code&gt;myDir&lt;/code&gt; in this case) that matches all 4 types can be referenced from within a template.</source>
          <target state="translated">다음 은 템플릿 내에서 4 가지 유형 모두와 일치 하는 지시문 ( 이 경우 &lt;code&gt;myDir&lt;/code&gt; )을 참조 할 수있는 다양한 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="cc2bb4d34c36efedb43f32cea70a8768eb4ff2f4" translate="yes" xml:space="preserve">
          <source>The following directives are &quot;animation aware&quot;:</source>
          <target state="translated">다음 지시문은 &quot;애니메이션 인식&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4afa83c5e442e93a0c03e046c0962ecf7210c99b" translate="yes" xml:space="preserve">
          <source>The following example demonstrates creating a &lt;code&gt;GreetingController&lt;/code&gt;, which attaches a &lt;code&gt;greeting&lt;/code&gt; property containing the string &lt;code&gt;'Hola!'&lt;/code&gt; to the &lt;code&gt;$scope&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 문자열 &lt;code&gt;'Hola!'&lt;/code&gt; 를 포함 하는 &lt;code&gt;greeting&lt;/code&gt; 속성 을 첨부 하는 &lt;code&gt;GreetingController&lt;/code&gt; 를 만드는 방법을 보여줍니다 . 받는 &lt;code&gt;$scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f31c0ae4dcad4687f763e1857697fa67941c2cf" translate="yes" xml:space="preserve">
          <source>The following example expands on the simple component example and incorporates the concepts we introduced above:</source>
          <target state="translated">다음 예제는 간단한 컴포넌트 예제를 확장하고 위에서 소개 한 개념을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="a68dc016c804a0669d2cdafc91c3941186cea38f" translate="yes" xml:space="preserve">
          <source>The following example shows a simple way to utilize CSS transitions to style a form element that has been rendered as invalid after it has been validated:</source>
          <target state="translated">다음 예제는 유효성 검사 후 유효하지 않은 것으로 렌더링 된 양식 요소의 스타일을 지정하기 위해 CSS 전환을 활용하는 간단한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="56aa8c2fcf843e9817067b3a89350a550b362ccb" translate="yes" xml:space="preserve">
          <source>The following example shows a simple way to utilize CSS transitions to style an input element that has been rendered as invalid after it has been validated:</source>
          <target state="translated">다음 예제는 유효성 검사 후 유효하지 않은 것으로 렌더링 된 입력 요소의 스타일을 지정하기 위해 CSS 전환을 활용하는 간단한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="afb31a9a68862c6afcf96f6c3e11bb32e67080a5" translate="yes" xml:space="preserve">
          <source>The following example shows how to add two-way data-binding to contentEditable elements.</source>
          <target state="translated">다음 예제는 contentEditable 요소에 양방향 데이터 바인딩을 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d29bf3e06de230de3418eaafced38ca904f8bad6" translate="yes" xml:space="preserve">
          <source>The following example shows how to bind to getter/setters:</source>
          <target state="translated">다음 예제는 getter / setter에 바인딩하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cf64ab22fdb663548e6a4a5465819cfebca2122b" translate="yes" xml:space="preserve">
          <source>The following example shows how to configure ngPluralize:</source>
          <target state="translated">다음 예제는 ngPluralize를 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e211088f2987b057c3e47ee8d0f916c1b541890a" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a simple event tracking service and register it using &lt;a href=&quot;%24provide#provider.html&quot;&gt;$provide.provider()&lt;/a&gt;.</source>
          <target state="translated">다음 예제는 간단한 이벤트 추적 서비스를 작성하고 &lt;a href=&quot;%24provide#provider.html&quot;&gt;$ provide.provider ()를&lt;/a&gt; 사용하여 등록하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="49e8cb0259845374b5503fd5a0834e0ef3de3ec3" translate="yes" xml:space="preserve">
          <source>The following example shows how to override immediate updates. Changes on the inputs within the form will update the model only when the control loses focus (blur event).</source>
          <target state="translated">다음 예는 즉시 업데이트를 무시하는 방법을 보여줍니다. 폼 내 입력의 변경은 컨트롤이 포커스를 잃을 때만 (블러 이벤트) 모델을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="608da6d18fbad58a833f943d30704c458a019301" translate="yes" xml:space="preserve">
          <source>The following example shows how to override immediate updates. Changes on the inputs within the form will update the model only when the control loses focus (blur event). If &lt;code&gt;escape&lt;/code&gt; key is pressed while the input field is focused, the value is reset to the value in the current model.</source>
          <target state="translated">다음 예는 즉시 업데이트를 무시하는 방법을 보여줍니다. 폼 내 입력의 변경은 컨트롤이 포커스를 잃을 때만 (블러 이벤트) 모델을 업데이트합니다. 경우 &lt;code&gt;escape&lt;/code&gt; 입력 필드에 초점이 맞춰있는 동안 키를 누르면, 값은 현재 모델의 값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="e25b61977236b595c690c1add8ceee3f297224e6" translate="yes" xml:space="preserve">
          <source>The following example shows how to use &lt;code&gt;ngModel&lt;/code&gt; with a getter/setter:</source>
          <target state="translated">다음 예제는 &lt;code&gt;ngModel&lt;/code&gt; 을 getter / setter와 함께 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d8828073febfc88b7e929349ee1005c112427e4d" translate="yes" xml:space="preserve">
          <source>The following example shows the effects of different actions with tracking:</source>
          <target state="translated">다음 예는 추적시 다양한 작업의 영향을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49526c0cbe72823024948149f2ba222e9dcacf1d" translate="yes" xml:space="preserve">
          <source>The following example uses a Controller to add a method, which doubles a number, to the scope:</source>
          <target state="translated">다음 예제에서는 Controller를 사용하여 숫자를 두 배로 늘리는 메소드를 범위에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c5d5572a6af9e099a94051501ec7017d831c20b8" translate="yes" xml:space="preserve">
          <source>The following example uses the CSS to display validity of each form control. In the example both &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; are required, but are rendered with red background only after the input is blurred (loses focus). This ensures that the user is not distracted with an error until after interacting with the control, and failing to satisfy its validity.</source>
          <target state="translated">다음 예제는 CSS를 사용하여 각 양식 컨트롤의 유효성을 표시합니다. 이 예에서는 &lt;code&gt;user.name&lt;/code&gt; 과 &lt;code&gt;user.email&lt;/code&gt; 이 모두 필요하지만 입력이 흐려진 후에 만 ​​초점이 사라진 빨간색 배경으로 렌더링됩니다. 이렇게하면 컨트롤과 상호 작용 한 후 유효성을 충족하지 못할 때까지 사용자가주의를 산만하게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33f68f854869fc32d143f52645cecc54d4d0c1ad" translate="yes" xml:space="preserve">
          <source>The following graphic shows how everything works together after we introduced the controller:</source>
          <target state="translated">다음 그래픽은 컨트롤러를 소개 한 후 모든 것이 어떻게 작동하는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="385ffec593477822ca164a235f1fdf7ebf15040e" translate="yes" xml:space="preserve">
          <source>The following is a unit test for the &lt;code&gt;notify&lt;/code&gt; service from the &lt;a href=&quot;services#creating-services.html&quot;&gt;Creating AngularJS Services&lt;/a&gt; example above. The unit test example uses a Jasmine spy (mock) instead of a real browser alert.</source>
          <target state="translated">다음은 위의 &lt;a href=&quot;services#creating-services.html&quot;&gt;AngularJS 서비스 작성&lt;/a&gt; 예제 에서 &lt;code&gt;notify&lt;/code&gt; 서비스에 대한 단위 테스트입니다 . 단위 테스트 예제는 실제 브라우저 경보 대신 Jasmine spy (mock)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fb989a297b5370085b89e00c936b323f1015a9ee" translate="yes" xml:space="preserve">
          <source>The following sample filter reverses a text string. In addition, it conditionally makes the text upper-case.</source>
          <target state="translated">다음 샘플 필터는 텍스트 문자열을 반대로 바꿉니다. 또한 조건부로 텍스트를 대문자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5abf89865b72c60e74a4308a79f260298a1552b3" translate="yes" xml:space="preserve">
          <source>The following sections provide examples each of a service decorator, a directive decorator, and a filter decorator.</source>
          <target state="translated">다음 섹션에서는 서비스 데코레이터, 지시어 데코레이터 및 필터 데코레이터 각각의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef6e74dc8057c84b4bdc44fbe57d05d3eb5ca2ac" translate="yes" xml:space="preserve">
          <source>The former CSS className value</source>
          <target state="translated">이전 CSS className 값</target>
        </trans-unit>
        <trans-unit id="c347b16354fe80c4ac3b3f67a7e1632c4e3f4b10" translate="yes" xml:space="preserve">
          <source>The four events are &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;cancel&lt;/code&gt;. &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;end&lt;/code&gt; receive as a parameter a coordinates object of the form &lt;code&gt;{ x: 150, y: 310 }&lt;/code&gt; and the raw &lt;code&gt;event&lt;/code&gt;. &lt;code&gt;cancel&lt;/code&gt; receives the raw &lt;code&gt;event&lt;/code&gt; as its single parameter.</source>
          <target state="translated">네 가지 이벤트는 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;move&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;cancel&lt;/code&gt; 입니다. &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;move&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 는 매개 변수로 &lt;code&gt;{ x: 150, y: 310 }&lt;/code&gt; 형식의 좌표 객체 와 raw &lt;code&gt;event&lt;/code&gt; 를 받습니다. &lt;code&gt;cancel&lt;/code&gt; 은 원시 &lt;code&gt;event&lt;/code&gt; 를 단일 매개 변수로 받습니다 .</target>
        </trans-unit>
        <trans-unit id="2c9494e0230a76ef255530c7ab61e30820ac57e4" translate="yes" xml:space="preserve">
          <source>The function that will decide whether the given character is a valid identifier continue character.</source>
          <target state="translated">주어진 문자가 유효한 식별자 연속 문자인지 여부를 결정하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e9633fa9ea971735772836de085d84d26552cd07" translate="yes" xml:space="preserve">
          <source>The function that will decide whether the given character is a valid identifier start character.</source>
          <target state="translated">주어진 문자가 유효한 식별자 시작 문자인지를 결정하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f07c9484695ff7d7e62cb833d2009d5141f8f9c6" translate="yes" xml:space="preserve">
          <source>The functions are called in array order, each passing its return value through to the next. The last return value is forwarded to the &lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;&lt;code&gt;$validators&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">함수는 배열 순서로 호출되며 각각 반환 값을 다음 값으로 전달합니다. 마지막 반환 값은 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt; &lt;code&gt;$validators&lt;/code&gt; &lt;/a&gt; 컬렉션으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dae7ea2912e98ee65a104da6c13925bc30a72664" translate="yes" xml:space="preserve">
          <source>The functions are called in reverse array order, each passing the value through to the next. The last return value is used as the actual DOM value.</source>
          <target state="translated">함수는 값을 다음 배열로 전달하는 역 배열 순서로 호출됩니다. 마지막 반환 값은 실제 DOM 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1882a81b786a1f235f2e723e4c9aff45edba984" translate="yes" xml:space="preserve">
          <source>The gender support is provided by the more generic &quot;select&quot; syntax that is more akin to a switch statement. It is general enough to support use for gender based messages.</source>
          <target state="translated">성별 지원은 switch 문과 더 유사한보다 일반적인 &quot;select&quot;구문에 의해 제공됩니다. 성별 기반 메시지 사용을 지원하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="f59bd7db60de9ce08437e7f3e011e5ca3fab98ac" translate="yes" xml:space="preserve">
          <source>The general syntax in templates is as follows:</source>
          <target state="translated">템플릿의 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56c426b734bed528f39225878bb25f07045e803d" translate="yes" xml:space="preserve">
          <source>The goal of ngAria is to improve AngularJS's default accessibility by enabling common &lt;a href=&quot;http://www.w3.org/TR/wai-aria/&quot;&gt;ARIA&lt;/a&gt; attributes that convey state or semantic information for assistive technologies used by persons with disabilities.</source>
          <target state="translated">ngAria의 목표는 장애인이 사용하는 보조 기술에 대한 상태 또는 의미 정보를 전달 하는 일반적인 &lt;a href=&quot;http://www.w3.org/TR/wai-aria/&quot;&gt;ARIA&lt;/a&gt; 속성을 활성화하여 AngularJS의 기본 접근성을 향상시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="62f795492acd77aa418074f3e83eb0705e35bd74" translate="yes" xml:space="preserve">
          <source>The hash specifying the element to scroll to. If omitted, the value of &lt;a href=&quot;%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; will be used.</source>
          <target state="translated">스크롤 할 요소를 지정하는 해시입니다. 생략하면 &lt;a href=&quot;%24location#hash.html&quot;&gt;$ location.hash ()&lt;/a&gt; 의 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02053663b4fa96bc136f66df077e6715d30724e9" translate="yes" xml:space="preserve">
          <source>The header will &amp;mdash; by default &amp;mdash; &lt;strong&gt;not&lt;/strong&gt; be set for cross-domain requests. This prevents unauthorized servers (e.g. malicious or compromised 3rd-party APIs) from gaining access to your users' XSRF tokens and exposing them to Cross Site Request Forgery. If you want to, you can whitelist additional origins to also receive the XSRF token, by adding them to &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;xsrfWhitelistedOrigins&lt;/a&gt;. This might be useful, for example, if your application, served from &lt;code&gt;example.com&lt;/code&gt;, needs to access your API at &lt;code&gt;api.example.com&lt;/code&gt;. See &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;$httpProvider.xsrfWhitelistedOrigins&lt;/a&gt; for more details.</source>
          <target state="translated">기본적 으로 도메인 간 요청 에는 헤더가 설정 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 이렇게하면 권한이없는 서버 (예 : 악의적이거나 손상된 타사 API)가 사용자의 XSRF 토큰에 액세스하여 크로스 사이트 요청 위조에 노출되는 것을 방지 할 수 있습니다. 원하는 경우 &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;xsrfWhitelistedOrigins&lt;/a&gt; 에 추가하여 XSRF 토큰을 수신하도록 추가 오리진을 화이트리스트에 추가 할 수 있습니다 . 예를 들어 &lt;code&gt;example.com&lt;/code&gt; 에서 제공되는 애플리케이션이 &lt;code&gt;api.example.com&lt;/code&gt; 의 API에 액세스해야하는 경우에 유용 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../provider/%24httpprovider#xsrfWhitelistedOrigins.html&quot;&gt;$ httpProvider.xsrfWhitelistedOrigins&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9d882e0eea82bc7f30ad5b0b72c42474eb4cf87" translate="yes" xml:space="preserve">
          <source>The heroDetail component now contains new functionality:</source>
          <target state="translated">heroDetail 컴포넌트는 이제 새로운 기능을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="118554a0cc7bb4ae6da007dc27bdce1b33af2df3" translate="yes" xml:space="preserve">
          <source>The impedance mismatch between dynamic applications and static documents is often solved with:</source>
          <target state="translated">동적 응용 프로그램과 정적 문서 간의 임피던스 불일치는 종종 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="bc88ca9137a8a789d4223b3543e8b24f06c1df98" translate="yes" xml:space="preserve">
          <source>The important thing in the example is that AngularJS provides &lt;em&gt;live&lt;/em&gt; bindings: Whenever the input values change, the value of the expressions are automatically recalculated and the DOM is updated with their values. The concept behind this is &lt;a href=&quot;databinding&quot;&gt;two-way data binding&lt;/a&gt;.</source>
          <target state="translated">예제에서 중요한 것은 AngularJS가 &lt;em&gt;라이브&lt;/em&gt; 바인딩을 제공한다는 것입니다. 입력 값이 변경 될 때마다 표현식 값이 자동으로 다시 계산되고 DOM이 해당 값으로 업데이트됩니다. 이것의 기본 개념은 &lt;a href=&quot;databinding&quot;&gt;양방향 데이터 바인딩&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="feb47f0357163525e9a17e43f4fdaa136b3a9b3a" translate="yes" xml:space="preserve">
          <source>The included &lt;a href=&quot;%24scedelegate&quot;&gt;$sceDelegate&lt;/a&gt; comes with sane defaults to allow you to load templates in &lt;code&gt;ng-include&lt;/code&gt; from your application's domain without having to even know about SCE. It blocks loading templates from other domains or loading templates over http from an https served document. You can change these by setting your own custom &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelists&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;blacklists&lt;/a&gt; for matching such URLs.</source>
          <target state="translated">포함 된 &lt;a href=&quot;%24scedelegate&quot;&gt;$ sceDelegate&lt;/a&gt; 는 SCE에 대해 알 필요없이 애플리케이션 도메인에서 템플릿을 &lt;code&gt;ng-include&lt;/code&gt; 로로드 할 수 있도록 정상 기본값으로 제공됩니다 . 다른 도메인에서 템플릿을로드하거나 https 제공 문서에서 http를 통해 템플릿을로드하는 것을 차단합니다. 이러한 URL과 일치하도록 사용자 정의 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;화이트리스트&lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;블랙리스트&lt;/a&gt; 를 설정하여이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d86ce90e809e5dafdbfc54a177b73d2ccac67ae" translate="yes" xml:space="preserve">
          <source>The inject function wraps a function into an injectable function. The inject() creates new instance of &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; per test, which is then used for resolving references.</source>
          <target state="translated">주입 기능은 기능을 주입 가능한 기능으로 랩핑합니다. inject () 는 테스트 당 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 의 새 인스턴스를 생성 한 다음 참조 해결에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1092c772bcfea30a4aa4090625e6d56119e573a" translate="yes" xml:space="preserve">
          <source>The injectable $getFn for the instance creation. Internally this is a short hand for &lt;code&gt;$provide.provider(name, {$get: $getFn})&lt;/code&gt;.</source>
          <target state="translated">인스턴스 작성을위한 주입 가능한 $ getFn. 내부적으로 이것은 &lt;code&gt;$provide.provider(name, {$get: $getFn})&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="605987405f3ba59ce7d26ad7a79cb1575f0f779c" translate="yes" xml:space="preserve">
          <source>The injectable function to invoke. Function parameters are injected according to the &lt;a href=&quot;../../../guide/di&quot;&gt;$inject Annotation&lt;/a&gt; rules.</source>
          <target state="translated">호출 할 함수입니다. 기능 매개 변수는 &lt;a href=&quot;../../../guide/di&quot;&gt;$ inject Annotation&lt;/a&gt; 규칙 에 따라 주입 됩니다.</target>
        </trans-unit>
        <trans-unit id="677dfa999d3a98fad688a00276274a8900d320b0" translate="yes" xml:space="preserve">
          <source>The injector creates two types of objects, &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;specialized objects&lt;/strong&gt;.</source>
          <target state="translated">인젝터는 &lt;strong&gt;서비스&lt;/strong&gt; 와 &lt;strong&gt;특수 객체&lt;/strong&gt; 라는 두 가지 유형의 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0e94cb4879f562aa129066b04f883ce6312f54d9" translate="yes" xml:space="preserve">
          <source>The injector needs to know how to create these objects. You tell it by registering a &quot;recipe&quot; for creating your object with the injector. There are five recipe types.</source>
          <target state="translated">인젝터는 이러한 오브젝트를 작성하는 방법을 알아야합니다. 인젝터로 객체를 만들기위한 &quot;레시피&quot;를 등록하여 알려줍니다. 5 가지 레시피 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services and special purpose objects</source>
          <target state="translated">인젝터는 레시피를 사용하여 서비스 및 특수 목적 오브젝트의 두 가지 유형의 오브젝트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f953d4b077ce6a518bf5b06d0aef4b5f97e7e535" translate="yes" xml:space="preserve">
          <source>The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are then serialized back to a properly escaped HTML string. This means that no unsafe input can make it into the returned string.</source>
          <target state="translated">HTML을 토큰으로 구문 분석하여 입력을 삭제합니다. 그런 다음 화이트리스트의 모든 안전한 토큰은 올바르게 이스케이프 된 HTML 문자열로 다시 직렬화됩니다. 이것은 안전하지 않은 입력이 리턴 된 문자열로 입력 될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="59f809f5d96cab71f45dcf3fd61d5ada6a5b1113" translate="yes" xml:space="preserve">
          <source>The input may also contain SVG markup if this is enabled via &lt;a href=&quot;../provider/%24sanitizeprovider&quot;&gt;&lt;code&gt;$sanitizeProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24sanitizeprovider&quot;&gt; &lt;code&gt;$sanitizeProvider&lt;/code&gt; &lt;/a&gt; 를 통해 활성화 된 경우 입력에 SVG 마크 업이 포함될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9721cff229ea27eaddea830cb215d9ecb24c54d" translate="yes" xml:space="preserve">
          <source>The instance.</source>
          <target state="translated">인스턴스.</target>
        </trans-unit>
        <trans-unit id="d06ec46a0f6db466ce39dca76188695efd2cff45" translate="yes" xml:space="preserve">
          <source>The instructions for the injector to create these special objects (with the exception of the Controller objects) use the Factory recipe behind the scenes.</source>
          <target state="translated">인젝터가 이러한 특수 객체를 생성하기위한 지침 (컨트롤러 객체 제외)은 뒤에서 팩토리 레시피를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9641656e0f057252f61c1fb2d165a7e89b9e6899" translate="yes" xml:space="preserve">
          <source>The interceptors are service factories that are registered with the &lt;code&gt;$httpProvider&lt;/code&gt; by adding them to the &lt;code&gt;$httpProvider.interceptors&lt;/code&gt; array. The factory is called and injected with dependencies (if specified) and returns the interceptor.</source>
          <target state="translated">인터셉터는 &lt;code&gt;$httpProvider.interceptors&lt;/code&gt; 배열 에 추가 하여 &lt;code&gt;$httpProvider&lt;/code&gt; 에 등록 된 서비스 팩토리입니다 . 팩토리는 호출되어 종속성이 지정된 경우 (지정된 경우) 인터셉터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="259abe29ae4ace32d8058fd4b583122111a0a58c" translate="yes" xml:space="preserve">
          <source>The items in the &lt;code&gt;watchExpressions&lt;/code&gt; array are observed via the standard &lt;code&gt;$watch&lt;/code&gt; operation. Their return values are examined for changes on every call to &lt;code&gt;$digest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;watchExpressions&lt;/code&gt; 배열 의 항목 은 표준 &lt;code&gt;$watch&lt;/code&gt; 작업을 통해 관찰됩니다 . 반환 값은 &lt;code&gt;$digest&lt;/code&gt; 호출 할 때마다 변경 사항이 있는지 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="ac4e2ed2134c4627770fca158ca734471daad86e" translate="yes" xml:space="preserve">
          <source>The key directive in understanding two-way data-binding is &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt;. The &lt;code&gt;ngModel&lt;/code&gt; directive provides the two-way data-binding by synchronizing the model to the view, as well as view to the model. In addition it provides an &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller&quot;&gt;API&lt;/a&gt; for other directives to augment its behavior.</source>
          <target state="translated">양방향 데이터 바인딩을 이해하기위한 주요 지시문은 &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt; 입니다. &lt;code&gt;ngModel&lt;/code&gt; 의 지시문 제공 양방향 모델의 뷰에 모델뿐만 아니라보기를 동기화하여 데이터 바인딩. 또한 다른 지시문에서 동작을 향상시키기위한 &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller&quot;&gt;API&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cf8fd3854844a5b37d09ac63b2f2a2265faf671e" translate="yes" xml:space="preserve">
          <source>The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two generated CSS classes will be applied to the element; in the example above we have &lt;code&gt;.ng-enter&lt;/code&gt; and &lt;code&gt;.ng-enter-active&lt;/code&gt;. For CSS transitions, the transition code &lt;strong&gt;must&lt;/strong&gt; be defined within the starting CSS class (in this case &lt;code&gt;.ng-enter&lt;/code&gt;). The destination class is what the transition will animate towards.</source>
          <target state="translated">여기서 기억해야 할 것은 애니메이션 이벤트 (위의 각 지시문이 진행 상황에 따라 트리거 됨)에 따라 두 개의 생성 된 CSS 클래스가 요소에 적용된다는 것입니다. 위의 예에서는 &lt;code&gt;.ng-enter&lt;/code&gt; 및 &lt;code&gt;.ng-enter-active&lt;/code&gt; 가 있습니다. CSS 전환의 경우 전환 CSS는 시작 CSS 클래스 (이 경우 &lt;code&gt;.ng-enter&lt;/code&gt; ) 내에 정의 &lt;strong&gt;해야합니다&lt;/strong&gt; . 대상 클래스는 전환이 애니메이션되는 대상입니다.</target>
        </trans-unit>
        <trans-unit id="9bfe88c198504d0cc14a7b1ffef4d2e83779de3b" translate="yes" xml:space="preserve">
          <source>The last thing that changed in the example between the previous section and this section is that we now pass an array to the &lt;code&gt;module.controller&lt;/code&gt; function, instead of a plain function. The array first contains the names of the service dependencies that the controller needs. The last entry in the array is the controller constructor function. AngularJS uses this array syntax to define the dependencies so that the DI also works after minifying the code, which will most probably rename the argument name of the controller constructor function to something shorter like &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이전 섹션과이 섹션 사이의 예제에서 변경된 마지막 사항은 이제 일반 함수 대신 배열을 &lt;code&gt;module.controller&lt;/code&gt; 함수에 전달한다는 것 입니다. 배열에는 먼저 컨트롤러에 필요한 서비스 종속성의 이름이 포함됩니다. 배열의 마지막 항목은 컨트롤러 생성자 함수입니다. AngularJS와는 DI도 아마 같은 짧은 뭔가 컨트롤러 생성자 함수의 인수 이름을 이름을 변경합니다 코드, 축소에 후 작동하도록 종속성을 정의하려면이 배열 구문을 사용 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bc17242596383b2aa73f58fe188aa93577a2dc8" translate="yes" xml:space="preserve">
          <source>The length of the returned array or string. If the &lt;code&gt;limit&lt;/code&gt; number is positive, &lt;code&gt;limit&lt;/code&gt; number of items from the beginning of the source array/string are copied. If the number is negative, &lt;code&gt;limit&lt;/code&gt; number of items from the end of the source array/string are copied. The &lt;code&gt;limit&lt;/code&gt; will be trimmed if it exceeds &lt;code&gt;array.length&lt;/code&gt;. If &lt;code&gt;limit&lt;/code&gt; is undefined, the input will be returned unchanged.</source>
          <target state="translated">반환 된 배열 또는 문자열의 길이입니다. 는 IF &lt;code&gt;limit&lt;/code&gt; 수는 양수, &lt;code&gt;limit&lt;/code&gt; 소스 배열 / 문자열의 시작 부분에서 항목의 수는 복사됩니다. 숫자가 음수이면 소스 배열 / 문자열 끝에서 항목 수 &lt;code&gt;limit&lt;/code&gt; 이 복사됩니다. &lt;code&gt;limit&lt;/code&gt; 이 초과하는 경우 트리밍 할 것이다 &lt;code&gt;array.length&lt;/code&gt; . &lt;code&gt;limit&lt;/code&gt; 이 정의되지 않으면 입력은 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="96f80bb4132ab5893f0e229db73744e61363387b" translate="yes" xml:space="preserve">
          <source>The link function is responsible for registering DOM listeners as well as updating the DOM. It is executed after the template has been cloned. This is where most of the directive logic will be put.</source>
          <target state="translated">링크 기능은 DOM 리스너를 등록하고 DOM을 업데이트합니다. 템플릿이 복제 된 후에 실행됩니다. 이것은 대부분의 지시어 로직이 배치되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="25992899d7d94510e26d6aadc430072c9ca0c0f0" translate="yes" xml:space="preserve">
          <source>The main method of &lt;code&gt;$swipe&lt;/code&gt;. It takes an element to be watched for swipe motions, and an object containing event handlers. The pointer types that should be used can be specified via the optional third argument, which is an array of strings &lt;code&gt;'mouse'&lt;/code&gt;, &lt;code&gt;'touch'&lt;/code&gt; and &lt;code&gt;'pointer'&lt;/code&gt;. By default, &lt;code&gt;$swipe&lt;/code&gt; will listen for &lt;code&gt;mouse&lt;/code&gt;, &lt;code&gt;touch&lt;/code&gt; and &lt;code&gt;pointer&lt;/code&gt; events.</source>
          <target state="translated">&lt;code&gt;$swipe&lt;/code&gt; 의 주요 방법 . 스 와이프 동작을 감시 할 요소와 이벤트 핸들러를 포함하는 객체가 필요합니다. 사용해야하는 포인터 유형은 선택적 문자열 인 &lt;code&gt;'mouse'&lt;/code&gt; , &lt;code&gt;'touch'&lt;/code&gt; 및 &lt;code&gt;'pointer'&lt;/code&gt; 의 배열 인 세 번째 인수를 통해 지정할 수 있습니다 . 기본적으로 &lt;code&gt;$swipe&lt;/code&gt; 는 &lt;code&gt;mouse&lt;/code&gt; , &lt;code&gt;touch&lt;/code&gt; 및 &lt;code&gt;pointer&lt;/code&gt; 이벤트를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="1a172ed357f81e2238a43ea9dd78f148e9988e2e" translate="yes" xml:space="preserve">
          <source>The main purpose is to create Date-like instances with timezone fixed to the specified timezone offset, so that we can test code that depends on local timezone settings without dependency on the time zone settings of the machine where the code is running.</source>
          <target state="translated">기본 목적은 시간대가 지정된 시간대 오프셋으로 고정 된 날짜와 유사한 인스턴스를 작성하여 코드가 실행되는 시스템의 시간대 설정에 의존하지 않고 로컬 시간대 설정에 의존하는 코드를 테스트 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b310ca323bcc83d7a5a4af3c0bc0d4391022eb7" translate="yes" xml:space="preserve">
          <source>The main purpose of one-time binding expression is to provide a way to create a binding that gets deregistered and frees up resources once the binding is stabilized. Reducing the number of expressions being watched makes the digest loop faster and allows more information to be displayed at the same time.</source>
          <target state="translated">일회성 바인딩 표현식의 주요 목적은 바인딩이 안정화되면 등록 해제되고 리소스를 해제하는 바인딩을 작성하는 방법을 제공하는 것입니다. 감시되는 표현식의 수를 줄이면 다이제스트 루프가 빨라지고 더 많은 정보를 동시에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25503d1e5d98a9ab3cd9eaf52b8e382fdd6b749a" translate="yes" xml:space="preserve">
          <source>The main purpose of this service is to simplify debugging and troubleshooting.</source>
          <target state="translated">이 서비스의 주요 목적은 디버깅 및 문제 해결을 단순화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="91c342052b273fbc763e3a770d83c916c0e2fd15" translate="yes" xml:space="preserve">
          <source>The map object is:</source>
          <target state="translated">지도 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3ba921f13d5d29a579ae0d65aabb1cf6c6ce2b7" translate="yes" xml:space="preserve">
          <source>The mapping between plural category to its corresponding strings.</source>
          <target state="translated">복수 범주와 해당 문자열 간의 매핑</target>
        </trans-unit>
        <trans-unit id="91b978fa871e53cfbb4757ac12f850437d085924" translate="yes" xml:space="preserve">
          <source>The message in our template contains a binding to the &lt;code&gt;spice&lt;/code&gt; model which, by default, is set to the string &quot;very&quot;. Depending on which button is clicked, the &lt;code&gt;spice&lt;/code&gt; model is set to &lt;code&gt;chili&lt;/code&gt; or &lt;code&gt;jalape&amp;ntilde;o&lt;/code&gt;, and the message is automatically updated by data-binding.</source>
          <target state="translated">템플릿의 메시지에는 기본적으로 문자열 &quot;very&quot;로 설정되는 &lt;code&gt;spice&lt;/code&gt; 모델에 대한 바인딩이 포함되어 있습니다 . 클릭 한 버튼에 따라, &lt;code&gt;spice&lt;/code&gt; 모델은 &lt;code&gt;chili&lt;/code&gt; 또는 &lt;code&gt;jalape&amp;ntilde;o&lt;/code&gt; 로 설정되며 메시지는 데이터 바인딩에 의해 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c79e17a2b6e79907beb19b379baae598ffbe689b" translate="yes" xml:space="preserve">
          <source>The missing pieces here are that we do not have a transition set (within the CSS code nor within the &lt;code&gt;$animateCss&lt;/code&gt; options) and the duration of the animation is going to be detected from what the keyframe styles on the CSS class are. In this event, &lt;code&gt;$animateCss&lt;/code&gt; will automatically create an inline transition style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition and keyframe animations to run in parallel on the element. Then when the animation is underway the provided &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; CSS styles will be applied and spread across the transition and keyframe animation.</source>
          <target state="translated">여기서 누락 된 부분은 CSS 코드 또는 &lt;code&gt;$animateCss&lt;/code&gt; 옵션 내에 전환 세트가 없으며 CSS 클래스의 키 프레임 스타일에서 애니메이션 지속 시간이 감지된다는 것입니다. 이 경우 &lt;code&gt;$animateCss&lt;/code&gt; 는 키 프레임 스타일 (추가되는 CSS 클래스에 있음)에서 감지 된 지속 시간과 일치하는 인라인 전환 스타일을 자동으로 만든 다음 전환 및 키 프레임 애니메이션을 요소에서 동시에 실행할 수 있도록 준비합니다. . 그런 다음 애니메이션이 진행 중일 때 제공된 &lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;to&lt;/code&gt; CSS 스타일이 적용되어 전환 및 키 프레임 애니메이션에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0949f1bb9728ff0ffb32f807d413d44806a30f" translate="yes" xml:space="preserve">
          <source>The model must be assigned an entirely new object or collection before a re-rendering will occur.</source>
          <target state="translated">다시 렌더링하기 전에 모델에 완전히 새로운 객체 또는 컬렉션을 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ae22dc48b481f4e02eb16cb19edc1733fe699ba" translate="yes" xml:space="preserve">
          <source>The modules can be loaded in any order (or even in parallel) because modules delay execution.</source>
          <target state="translated">모듈은 실행이 지연되므로 임의의 순서로 (또는 병렬로)로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="529f242a37709897dbd946c5165c8aee6256feb1" translate="yes" xml:space="preserve">
          <source>The most common way to keep Controllers slim is by encapsulating work that doesn't belong to controllers into services and then using these services in Controllers via dependency injection. This is discussed in the &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; and &lt;a href=&quot;services&quot;&gt;Services&lt;/a&gt; sections of this guide.</source>
          <target state="translated">컨트롤러를 슬림하게 유지하는 가장 일반적인 방법은 컨트롤러에 속하지 않는 작업을 서비스로 캡슐화 한 다음 종속성 주입을 통해 컨트롤러에서 이러한 서비스를 사용하는 것입니다. 이에 대해서는 이 안내서 의 &lt;a href=&quot;di&quot;&gt;의존성 주입&lt;/a&gt; 및 &lt;a href=&quot;services&quot;&gt;서비스&lt;/a&gt; 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="faf758b67dc590ad824277c5b5f2a314b0605341" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider recipe. The remaining four recipe types &amp;mdash; Value, Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe.</source>
          <target state="translated">가장 장황하지만 가장 포괄적 인 것은 제공자 레시피입니다. 나머지 4 가지 레시피 유형 (Value, Factory, Service 및 Constant)은 공급자 레시피 위에있는 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="e93ee1a6dab4177437aeb5008d2c15cdeb9c5c03" translate="yes" xml:space="preserve">
          <source>The name attribute of the control.</source>
          <target state="translated">컨트롤의 이름 속성입니다.</target>
        </trans-unit>
        <trans-unit id="52a1406be0fd9b4498790d2b937925b4d86eab44" translate="yes" xml:space="preserve">
          <source>The name of the Component (as string).</source>
          <target state="translated">구성 요소의 이름 (문자열).</target>
        </trans-unit>
        <trans-unit id="f6aadfe17e9d7e5921f17aa8f89b4addde7625ab" translate="yes" xml:space="preserve">
          <source>The name of the animation (this is what the class-based CSS value will be compared to).</source>
          <target state="translated">애니메이션의 이름입니다 (이것은 클래스 기반 CSS 값과 비교됩니다).</target>
        </trans-unit>
        <trans-unit id="5fa60c10f1cb65ee0552af457bf2e526a3e8f002" translate="yes" xml:space="preserve">
          <source>The name of the constant.</source>
          <target state="translated">상수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5ebd3314617eb25c4ca63e475dab29179d07a68b" translate="yes" xml:space="preserve">
          <source>The name of the cookie and the header can be specified using the &lt;code&gt;xsrfCookieName&lt;/code&gt; and &lt;code&gt;xsrfHeaderName&lt;/code&gt; properties of either &lt;code&gt;$httpProvider.defaults&lt;/code&gt; at config-time, &lt;code&gt;$http.defaults&lt;/code&gt; at run-time, or the per-request config object.</source>
          <target state="translated">쿠키와 헤더의 이름은 사용하여 지정할 수 있습니다 &lt;code&gt;xsrfCookieName&lt;/code&gt; 및 &lt;code&gt;xsrfHeaderName&lt;/code&gt; 중 하나의 특성 &lt;code&gt;$httpProvider.defaults&lt;/code&gt; 설정-시간에 &lt;code&gt;$http.defaults&lt;/code&gt; 실행시, 또는 당 요청 설정 객체입니다.</target>
        </trans-unit>
        <trans-unit id="b5688f633c9943ed9963b6fac42bbab391f315da" translate="yes" xml:space="preserve">
          <source>The name of the instance to retrieve.</source>
          <target state="translated">검색 할 인스턴스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3ce9a1a3f858c924570c179ce1f797aef67a7010" translate="yes" xml:space="preserve">
          <source>The name of the instance.</source>
          <target state="translated">인스턴스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6914eeeb46cd50ced441dc387497bcc06ba59c09" translate="yes" xml:space="preserve">
          <source>The name of the instance. NOTE: the provider will be available under &lt;code&gt;name +
                        'Provider'&lt;/code&gt; key.</source>
          <target state="translated">인스턴스 이름입니다. 참고 : 공급자는 &lt;code&gt;name + 'Provider'&lt;/code&gt; 키 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef527986f7dd95521960193aaf626a363e2146dd" translate="yes" xml:space="preserve">
          <source>The name of the module to create or retrieve.</source>
          <target state="translated">작성하거나 검색 할 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5d9dc085c378b2687e35cbb2d483853c9af87fd6" translate="yes" xml:space="preserve">
          <source>The name of the service to decorate.</source>
          <target state="translated">꾸미는 서비스의 이름.</target>
        </trans-unit>
        <trans-unit id="a630443a3a5826d0976b6447615bfaff1727aedd" translate="yes" xml:space="preserve">
          <source>The names of the services which the function requires.</source>
          <target state="translated">기능에 필요한 서비스 이름.</target>
        </trans-unit>
        <trans-unit id="d6e70987a77c802441d477d6206f9cfb9463cba2" translate="yes" xml:space="preserve">
          <source>The new Angular also uses life-cycle hooks for its components. While the AngularJS life-cycle hooks are similar there are some differences that you should be aware of, especially when it comes to moving your code from AngularJS to Angular:</source>
          <target state="translated">새로운 Angular는 또한 구성 요소에 수명주기 후크를 사용합니다. AngularJS 수명주기 후크는 비슷하지만 특히 AngularJS에서 Angular로 코드를 이동할 때 알아야 할 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41b334b9554bd05233c2fb4d0a3daaade91fce8" translate="yes" xml:space="preserve">
          <source>The newly created child scope.</source>
          <target state="translated">새로 작성된 하위 범위.</target>
        </trans-unit>
        <trans-unit id="f3ce6bf462a57a8d8b163717a5d0f046f25c3465" translate="yes" xml:space="preserve">
          <source>The newly created promise.</source>
          <target state="translated">새로 만든 약속.</target>
        </trans-unit>
        <trans-unit id="ae09afc16f38ae9a9387c7b12e77a3a66d8888da" translate="yes" xml:space="preserve">
          <source>The next example shows how to debounce model changes. Model will be updated only 1 sec after last change. If the &lt;code&gt;Clear&lt;/code&gt; button is pressed, any debounced action is canceled and the value becomes empty.</source>
          <target state="translated">다음 예제는 모델 변경 사항을 디 바운스하는 방법을 보여줍니다. 마지막 변경 후 1 초만에 모델이 업데이트됩니다. 는 IF &lt;code&gt;Clear&lt;/code&gt; 버튼을 누르면 모든 디 바운스 동작이 취소되고 값은 비어가된다.</target>
        </trans-unit>
        <trans-unit id="b76887d9d0fb60e4fc34d27b04b0219ff2d5a890" translate="yes" xml:space="preserve">
          <source>The ng-[event]-prepare class</source>
          <target state="translated">ng- [event] -prepare 클래스</target>
        </trans-unit>
        <trans-unit id="83832e96d19a35ce36d51f03002d6ffdbe1a0358" translate="yes" xml:space="preserve">
          <source>The ng-animate CSS class</source>
          <target state="translated">ng 애니메이션 CSS 클래스</target>
        </trans-unit>
        <trans-unit id="9a9d315c0358a5c5e8b194937e0eee872f4b7280" translate="yes" xml:space="preserve">
          <source>The ngAnimate &lt;code&gt;$animate&lt;/code&gt; service documentation is the same for the core &lt;code&gt;$animate&lt;/code&gt; service.</source>
          <target state="translated">ngAnimate &lt;code&gt;$animate&lt;/code&gt; 서비스 설명서는 핵심 &lt;code&gt;$animate&lt;/code&gt; 서비스 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c26c0cdee12de4e472917c56086b0a3fb2d3b22f" translate="yes" xml:space="preserve">
          <source>The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure. Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure to view the step by step details of &lt;a href=&quot;../service/%24animate#addClass.html&quot;&gt;$animate.addClass&lt;/a&gt; and &lt;a href=&quot;../service/%24animate#removeClass.html&quot;&gt;$animate.removeClass&lt;/a&gt;.</source>
          <target state="translated">ngClass 지시문은 ngAnimate CSS 명명 구조를 따르지 않더라도 CSS3 전환 / 애니메이션을 계속 지원합니다. 애니메이션시 ngAnimate는 보조 CSS 클래스를 적용하여 애니메이션의 시작과 끝을 추적하지만 요소에 이미 존재하는 CSS 전환을 방해하지는 않습니다. 클래스 기반 애니메이션 중에 발생하는 상황을 이해하려면 &lt;a href=&quot;../service/%24animate#addClass.html&quot;&gt;$ animate.addClass&lt;/a&gt; 및 &lt;a href=&quot;../service/%24animate#removeClass.html&quot;&gt;$ animate.removeClass&lt;/a&gt; 의 단계별 세부 사항을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0635f6269423a28f71e76e780ec63cd5fb218795" translate="yes" xml:space="preserve">
          <source>The ngClick directive allows you to specify custom behavior when an element is clicked.</source>
          <target state="translated">ngClick 지시문을 사용하면 요소를 클릭 할 때 사용자 정의 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223eb922ce0ea7ac3447fe285277dffc1916f050" translate="yes" xml:space="preserve">
          <source>The ngMessageFormat module extends the AngularJS &lt;a href=&quot;ng/service/%24interpolate&quot;&gt;&lt;code&gt;$interpolate&lt;/code&gt;&lt;/a&gt; service with a syntax for handling pluralization and gender specific messages, which is based on the &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;ICU MessageFormat syntax&lt;/a&gt;.</source>
          <target state="translated">ngMessageFormat 모듈은 &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;ICU MessageFormat 구문을&lt;/a&gt; 기반으로하는 복수화 및 성별 특정 메시지를 처리하기위한 구문으로 AngularJS &lt;a href=&quot;ng/service/%24interpolate&quot;&gt; &lt;code&gt;$interpolate&lt;/code&gt; &lt;/a&gt; 서비스를 확장 합니다 .</target>
        </trans-unit>
        <trans-unit id="d6139af9198c6ea6591d92b0c6e44a5918b0ef3f" translate="yes" xml:space="preserve">
          <source>The ngMessages module makes it easy to display form validation or other messages with priority sequencing and animation. To expose these visual messages to screen readers, ngAria injects &lt;code&gt;aria-live=&quot;assertive&quot;&lt;/code&gt;, causing them to be read aloud any time a message is shown, regardless of the user's focus location.</source>
          <target state="translated">ngMessages 모듈을 사용하면 양식 확인 또는 우선 순위 시퀀싱 및 애니메이션이있는 기타 메시지를 쉽게 표시 할 수 있습니다. 이러한 시각적 메시지를 화면 판독기에 표시하기 위해 ngAria는 &lt;code&gt;aria-live=&quot;assertive&quot;&lt;/code&gt; 를 삽입 하여 사용자의 초점 위치에 관계없이 메시지가 표시 될 때마다 소리내어 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e5dcb2f0c1ee73bf49cf4d3307449f52a66c89cb" translate="yes" xml:space="preserve">
          <source>The ngMousedown directive allows you to specify custom behavior on mousedown event.</source>
          <target state="translated">ngMousedown 지시문을 사용하면 mousedown 이벤트에 대한 사용자 정의 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a24db6cdaf7c8d7b5c7c9ac1712f0a02f045a2" translate="yes" xml:space="preserve">
          <source>The ngTouch module with the &lt;a href=&quot;ngtouch/service/%24swipe&quot;&gt;&lt;code&gt;$swipe&lt;/code&gt;&lt;/a&gt; service and the &lt;a href=&quot;ngtouch/directive/ngswipeleft&quot;&gt;&lt;code&gt;ngSwipeLeft&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ngtouch/directive/ngswiperight&quot;&gt;&lt;code&gt;ngSwipeRight&lt;/code&gt;&lt;/a&gt; directives are deprecated. Instead, stand-alone libraries for touch handling and gesture interaction should be used, for example &lt;a href=&quot;https://hammerjs.github.io/&quot;&gt;HammerJS&lt;/a&gt; (which is also used by Angular).</source>
          <target state="translated">&lt;a href=&quot;ngtouch/service/%24swipe&quot;&gt; &lt;code&gt;$swipe&lt;/code&gt; &lt;/a&gt; 서비스 및 &lt;a href=&quot;ngtouch/directive/ngswipeleft&quot;&gt; &lt;code&gt;ngSwipeLeft&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ngtouch/directive/ngswiperight&quot;&gt; &lt;code&gt;ngSwipeRight&lt;/code&gt; &lt;/a&gt; 지시문이 있는 ngTouch 모듈 은 더 이상 사용되지 않습니다. 대신, 터치 조작과 제스처 상호 작용을위한 독립형 라이브러리는 예를 들어, 사용되어야한다 &lt;a href=&quot;https://hammerjs.github.io/&quot;&gt;HammerJS&lt;/a&gt; (도 각도로 사용된다).</target>
        </trans-unit>
        <trans-unit id="bd0e07d269ab6c4c785c9230592a8e454b8abbf0" translate="yes" xml:space="preserve">
          <source>The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as greensock.js and velocity.js.</source>
          <target state="translated">JS 기반 애니메이션의 장점은 다른 서비스를 삽입하고 greensock.js 및 velocity.js와 같은 고급 애니메이션 라이브러리를 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc6b6e566f3c4a65197842b008029ca49468b417" translate="yes" xml:space="preserve">
          <source>The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.</source>
          <target state="translated">여기서 좋은 점은 CSS 기반 애니메이션 코드를 사용하여 대역폭을 절약 할 수 있으며 타사 애니메이션 프레임 워크에 의존 할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b33d91c29f5b7375a54f9743cd38ebe14c38ac55" translate="yes" xml:space="preserve">
          <source>The normal flow of a browser receiving an event is that it executes a corresponding JavaScript callback. Once the callback completes the browser re-renders the DOM and returns to waiting for more events.</source>
          <target state="translated">이벤트를 수신하는 브라우저의 일반적인 흐름은 해당 JavaScript 콜백을 실행하는 것입니다. 콜백이 완료되면 브라우저는 DOM을 다시 렌더링하고 추가 이벤트 대기로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e595827e846ea3517809cce5d8c144967ea0c1ef" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;$onChanges&lt;/code&gt; hook iterations.</source>
          <target state="translated">수 &lt;code&gt;$onChanges&lt;/code&gt; 후크 반복.</target>
        </trans-unit>
        <trans-unit id="10748404b29dfc81bb9c7e5cd26dc4c6c3875599" translate="yes" xml:space="preserve">
          <source>The number of digest iterations.</source>
          <target state="translated">다이제스트 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="0ec2f5ba906afbf68077b33918a003e2cbe4f8cd" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to flush.</source>
          <target state="translated">플러시 할 밀리 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="3ec3b6d1b9bf0ba9bca47ebec8531321e98b8a2c" translate="yes" xml:space="preserve">
          <source>The number of spaces to use per indentation, defaults to 2.</source>
          <target state="translated">들여 쓰기 당 사용할 공백 수는 기본적으로 2입니다.</target>
        </trans-unit>
        <trans-unit id="e318b90e5449cb088bf22638bad5bf3451b67f6f" translate="yes" xml:space="preserve">
          <source>The object may have following properties:</source>
          <target state="translated">객체는 다음과 같은 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c455371f2478051b104228b4d093ce69f37c3dee" translate="yes" xml:space="preserve">
          <source>The object returned from a call to &lt;code&gt;$resource&lt;/code&gt; is a resource &quot;class&quot; which has one &quot;static&quot; method for each action in the definition.</source>
          <target state="translated">&lt;code&gt;$resource&lt;/code&gt; 호출에서 리턴 된 오브젝트 는 정의의 각 조치에 대해 하나의 &quot;정적&quot;메소드가있는 자원 &quot;클래스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0021d7966fedb869c64e8e751b9c6b3663b8b853" translate="yes" xml:space="preserve">
          <source>The observer function will be invoked once during the next &lt;code&gt;$digest&lt;/code&gt; following compilation. The observer is then invoked whenever the interpolated value changes.</source>
          <target state="translated">옵저버 함수는 컴파일 후 다음 &lt;code&gt;$digest&lt;/code&gt; 동안 한 번 호출됩니다 . 보간 된 값이 변경 될 때마다 관찰자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f09b420cec82adc9e93555eea36b1573051e63e6" translate="yes" xml:space="preserve">
          <source>The options to be passed to the &lt;a href=&quot;../service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making the request. You can use this to override options such as the &quot;Accept&quot; header for template requests.</source>
          <target state="translated">요청시 &lt;a href=&quot;../service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 서비스에 전달할 옵션 입니다. 이를 사용하여 템플리트 요청에 대한 &quot;수락&quot;헤더와 같은 옵션을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f020acdfb92309bd111f3fab8ddc649fcd4938a1" translate="yes" xml:space="preserve">
          <source>The order of identifiers in the array is the same as the order of argument names in the factory function.</source>
          <target state="translated">배열의 식별자 순서는 팩토리 함수의 인수 이름 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="035c8a97bdb0e87e941aebeda2e7e759c1233766" translate="yes" xml:space="preserve">
          <source>The page should reload and the debug information should now be available.</source>
          <target state="translated">페이지가 다시로드되고 이제 디버그 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="269c704d66caa90f4de39092f24e2ae227e2de22" translate="yes" xml:space="preserve">
          <source>The parent scope will propagate the &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt; event. The scope can be removed from the scope hierarchy using &lt;a href=&quot;%24rootscope.scope#%24destroy.html&quot;&gt;$destroy()&lt;/a&gt;.</source>
          <target state="translated">부모 범위는 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ digest ()&lt;/a&gt; 이벤트를 전파합니다 . &lt;a href=&quot;%24rootscope.scope#%24destroy.html&quot;&gt;$ destroy ()를&lt;/a&gt; 사용하여 범위를 범위 계층에서 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8541058d76a0f7d9d5c86cb32a517c836066fea" translate="yes" xml:space="preserve">
          <source>The plural syntax supports an optional &lt;code&gt;offset&lt;/code&gt; syntax that is used in matching. It's simpler to explain this with an example.</source>
          <target state="translated">복수 구문은 매칭에 사용되는 선택적 &lt;code&gt;offset&lt;/code&gt; 구문을 지원한다 . 예를 들어 이것을 설명하는 것이 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="ba16850007938f287f3d5f3ebf4f4bdd4d282552" translate="yes" xml:space="preserve">
          <source>The predicate to be used for selecting items from &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; 에서 항목을 선택하는 데 사용되는 술어 .</target>
        </trans-unit>
        <trans-unit id="82cb53a88d473e7292dcc9cba41cca1fec750b0a" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;draggable&lt;/code&gt; attribute on any element gives the element new behavior. We extended the vocabulary of the browser in a way which is natural to anyone who is familiar with the principles of HTML.</source>
          <target state="translated">의 존재 &lt;code&gt;draggable&lt;/code&gt; 모든 요소에 대한 속성은 요소 새로운 동작을 제공합니다. 우리는 HTML의 원리에 익숙한 모든 사람에게 자연스러운 방식으로 브라우저의 어휘를 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="e8b3768b71fbf0ccd49b698b097de049160fa839" translate="yes" xml:space="preserve">
          <source>The previous &lt;code&gt;ModelOptions&lt;/code&gt; value will not be modified. Instead, a new &lt;code&gt;ModelOptions&lt;/code&gt; object will inherit from the previous one overriding or inheriting settings that are defined in the given parameter.</source>
          <target state="translated">이전 &lt;code&gt;ModelOptions&lt;/code&gt; 값은 수정되지 않습니다. 대신, 새 &lt;code&gt;ModelOptions&lt;/code&gt; 객체는 지정된 매개 변수에 정의 된 이전 설정을 무시하거나 상속하는 설정에서 상속합니다.</target>
        </trans-unit>
        <trans-unit id="f32c9a1255f13a76d79607f3121c109beee3aef7" translate="yes" xml:space="preserve">
          <source>The purpose of the deferred object is to expose the associated Promise instance as well as APIs that can be used for signaling the successful or unsuccessful completion, as well as the status of the task.</source>
          <target state="translated">지연된 개체의 목적은 작업 상태뿐만 아니라 성공 또는 실패한 완료를 알리는 데 사용할 수있는 API뿐만 아니라 관련 Promise 인스턴스를 노출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="84e8768d7c2eb6eea9fb7b09e5578fa5d987cd4d" translate="yes" xml:space="preserve">
          <source>The purpose of the promise object is to allow for interested parties to get access to the result of the deferred task when it completes.</source>
          <target state="translated">약속의 목적은 이해 당사자가 연기 된 작업이 완료 될 때 결과에 ​​액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12c0a0d61ee769dc0a7c1715994804f7277a2078" translate="yes" xml:space="preserve">
          <source>The recipe for getting help on your unique issue is to create an example that could work (even if it doesn't) in a shareable example on &lt;a href=&quot;http://plnkr.co/&quot;&gt;Plunker&lt;/a&gt;, &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle&lt;/a&gt;, or similar site and then post to one of the following:</source>
          <target state="translated">고유 한 문제에 대한 도움을 얻는 방법은 &lt;a href=&quot;http://plnkr.co/&quot;&gt;Plunker&lt;/a&gt; , &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle&lt;/a&gt; 또는 이와 유사한 사이트 에서 공유 가능한 예제에서 작동 할 수있는 예제를 작성하고 ( 다음 중 하나에 게시하는) 것입니다.</target>
        </trans-unit>
        <trans-unit id="35fb232d4894865030ea1759887368f2aded3f73" translate="yes" xml:space="preserve">
          <source>The reference to &lt;code&gt;myApp&lt;/code&gt; module in &lt;code&gt;&amp;lt;div ng-app=&quot;myApp&quot;&amp;gt;&lt;/code&gt;. This is what bootstraps the app using your module.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div ng-app=&quot;myApp&quot;&amp;gt;&lt;/code&gt; 의 &lt;code&gt;myApp&lt;/code&gt; 모듈에 대한 참조 입니다. 모듈을 사용하여 앱을 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="d8810477942beaeaee286fe81161c775d9da02eb" translate="yes" xml:space="preserve">
          <source>The regular expression must be an instance of RegExp (i.e. not a string.) It is matched against the &lt;strong&gt;entire&lt;/strong&gt;&lt;em&gt;normalized / absolute URL&lt;/em&gt; of the resource being tested (even when the RegExp did not have the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; codes.) In addition, any flags present on the RegExp (such as multiline, global, ignoreCase) are ignored.</source>
          <target state="translated">정규식은 RegExp의 인스턴스 여야합니다 (예 : 문자열이 아님). 테스트중인 리소스의 &lt;em&gt;정규화 / 절대 URL &lt;/em&gt;&lt;strong&gt;전체&lt;/strong&gt; 와 일치 합니다 (RegExp에 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 코드 가없는 경우에도 ). RegExp에있는 플래그 (예 : multiline, global, ignoreCase)는 무시됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="862fa8a8a687fa2b536d9c358bd6db3e5af9b82c" translate="yes" xml:space="preserve">
          <source>The replacement process migrates all of the attributes / classes from the old element to the new one. See the &lt;a href=&quot;../../../guide/directive#template-expanding-directive.html&quot;&gt;Directives Guide&lt;/a&gt; for an example.</source>
          <target state="translated">대체 프로세스는 모든 속성 / 클래스를 이전 요소에서 새 요소로 마이그레이션합니다. 예 는 &lt;a href=&quot;../../../guide/directive#template-expanding-directive.html&quot;&gt;지시문 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baae8e3179a72344916f02ad84053532a8debe76" translate="yes" xml:space="preserve">
          <source>The response object has these properties:</source>
          <target state="translated">응답 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="954fa0733320ae27181ccf9760b44cb912d27915" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24sce#trustAs.html&quot;&gt;&lt;code&gt;$sce.trustAs&lt;/code&gt;&lt;/a&gt; call, or anything else (which will not be considered trusted.)</source>
          <target state="translated">이전 &lt;a href=&quot;%24sce#trustAs.html&quot;&gt; &lt;code&gt;$sce.trustAs&lt;/code&gt; &lt;/a&gt; 호출 의 결과 또는 기타 (신뢰할 수없는 것으로 간주 됨)</target>
        </trans-unit>
        <trans-unit id="778ed68784500d80168f4f1cb8de42f22ef35550" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; call or anything else.</source>
          <target state="translated">이전의 &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 호출 또는 다른 결과.</target>
        </trans-unit>
        <trans-unit id="f6e45a4404226652de8c58acd05d8e6b3ea99beb" translate="yes" xml:space="preserve">
          <source>The result of a prior &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; call, or anything else (which will not be considered trusted.)</source>
          <target state="translated">이전 &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 호출 의 결과 또는 기타 (신뢰할 수없는 것으로 간주 됨)</target>
        </trans-unit>
        <trans-unit id="0fbfd9ab10f2fcfc0e43605231238f6c0ded7faf" translate="yes" xml:space="preserve">
          <source>The result of evaluating the expression.</source>
          <target state="translated">식을 평가 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="24d1f7d570b94cc6ad9c9b7d800fac81d6320b04" translate="yes" xml:space="preserve">
          <source>The result of this is a live binding between the scope and the DOM. So at this point, a change in a model on the compiled scope will be reflected in the DOM.</source>
          <target state="translated">이것의 결과는 범위와 DOM 사이의 라이브 바인딩입니다. 따라서이 시점에서 컴파일 된 범위의 모델 변경 사항이 DOM에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b6643299e7c2857ed4c1427bec152f0e242127" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.CSS, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.CSS, value)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="45a813410d787bc2a054b283286cdbe7c1020ab1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.HTML, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.HTML, value)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="b3ca9d9ba8ef58892b2647a2857931cb76ed96f4" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.JS, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.JS, value)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="7f0c5cf3a8e15099fba3a60e6508cb831477a19c" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.RESOURCE_URL, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.RESOURCE_URL, value)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="295e8d1672e32e8c877e2dda418b912ffdc21e8b" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;$sce.getTrusted($sce.URL, value)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted($sce.URL, value)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="85ef2c181da5028df11fbde1df5de14ad91e5d03" translate="yes" xml:space="preserve">
          <source>The return value of calling &lt;code&gt;$timeout&lt;/code&gt; is a promise, which will be resolved when the delay has passed and the timeout function, if provided, is executed.</source>
          <target state="translated">&lt;code&gt;$timeout&lt;/code&gt; 호출의 반환 값은 약속이며 지연이 지났을 때 해결되고 시간 초과 기능 (제공된 경우)이 실행될 때 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="3b91569091098ef8818bad33c1660a55b8735e97" translate="yes" xml:space="preserve">
          <source>The return value of registering an interval function is a promise. This promise will be notified upon each tick of the interval, and will be resolved after &lt;code&gt;count&lt;/code&gt; iterations, or run indefinitely if &lt;code&gt;count&lt;/code&gt; is not defined. The value of the notification will be the number of iterations that have run. To cancel an interval, call &lt;code&gt;$interval.cancel(promise)&lt;/code&gt;.</source>
          <target state="translated">인터벌 함수 등록의 반환 값은 약속입니다. 이 약속은 간격의 각 틱마다 통지되며 &lt;code&gt;count&lt;/code&gt; 반복 후에 해결 되거나 &lt;code&gt;count&lt;/code&gt; 가 정의되지 않은 경우 무기한으로 실행됩니다 . 알림 값은 실행 된 반복 횟수입니다. 간격을 취소하려면 &lt;code&gt;$interval.cancel(promise)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffa5113ebf43540eb4e8acfea21d2d33bd174676" translate="yes" xml:space="preserve">
          <source>The returned function also has the following properties:</source>
          <target state="translated">반환 된 함수에는 다음과 같은 속성도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5179be6b86116655b38058f0ad19bd9de4712c8" translate="yes" xml:space="preserve">
          <source>The returned resource object has action methods which provide high-level behaviors without the need to interact with the low level &lt;a href=&quot;../../ng/service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">리턴 된 자원 오브젝트에는 하위 레벨 &lt;a href=&quot;../../ng/service/%24http&quot;&gt;$ http&lt;/a&gt; 서비스 와 상호 작용할 필요없이 상위 레벨 작동을 제공하는 조치 메소드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6023496af7670d9c11586559bb4cd6e937a06ca6" translate="yes" xml:space="preserve">
          <source>The root element of AngularJS application. This is either the element where &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt; was declared or the element passed into &lt;a href=&quot;../function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt;. The element represents the root element of application. It is also the location where the application's &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; service gets published, and can be retrieved using &lt;code&gt;$rootElement.injector()&lt;/code&gt;.</source>
          <target state="translated">AngularJS 애플리케이션의 루트 요소입니다. 이 두 요소입니다 &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp는&lt;/a&gt; 선언이나에 전달 된 요소 &lt;a href=&quot;../function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; . 요소는 응용 프로그램의 루트 요소를 나타냅니다. 또한 응용 프로그램의 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 서비스가 게시 되는 위치이며 &lt;code&gt;$rootElement.injector()&lt;/code&gt; 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24dbde550866bde503deb0950b1e8e1246eac032" translate="yes" xml:space="preserve">
          <source>The root element of AngularJS application. This is either the element where &lt;a href=&quot;directive/ngapp&quot;&gt;ngApp&lt;/a&gt; was declared or the element passed into &lt;a href=&quot;function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt;. The element represents the root element of application. It is also the location where the application's &lt;a href=&quot;../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt; service gets published, and can be retrieved using &lt;code&gt;$rootElement.injector()&lt;/code&gt;.</source>
          <target state="translated">AngularJS 애플리케이션의 루트 요소입니다. 이 두 요소입니다 &lt;a href=&quot;directive/ngapp&quot;&gt;ngApp는&lt;/a&gt; 선언이나에 전달 된 요소 &lt;a href=&quot;function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; . 요소는 응용 프로그램의 루트 요소를 나타냅니다. 또한 응용 프로그램의 &lt;a href=&quot;../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 서비스가 게시 되는 위치이며 &lt;code&gt;$rootElement.injector()&lt;/code&gt; 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcf79b2ca7c0e61431c4ddcce676e6a46e50533" translate="yes" xml:space="preserve">
          <source>The root scope</source>
          <target state="translated">루트 범위</target>
        </trans-unit>
        <trans-unit id="af6c0993a1b0bfa5a18a6aaa404dc362b0e915a7" translate="yes" xml:space="preserve">
          <source>The route change (and the &lt;code&gt;$location&lt;/code&gt; change that triggered it) can be prevented by calling &lt;code&gt;preventDefault&lt;/code&gt; method of the event. See &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; for more details about event object.</source>
          <target state="translated">&lt;code&gt;preventDefault&lt;/code&gt; 메소드를 호출 하여 라우트 변경 (및이 를 트리거 한 &lt;code&gt;$location&lt;/code&gt; 변경)을 막을 수 있습니다 . 참조 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 이벤트 객체에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="fa7560a7875748906d4d03990b3f182804ac86d0" translate="yes" xml:space="preserve">
          <source>The route parameters are a combination of &lt;a href=&quot;../../ng/service/%24location&quot;&gt;&lt;code&gt;$location&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;../../ng/service/%24location#search.html&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ng/service/%24location#path.html&quot;&gt;&lt;code&gt;path()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;path&lt;/code&gt; parameters are extracted when the &lt;a href=&quot;%24route&quot;&gt;&lt;code&gt;$route&lt;/code&gt;&lt;/a&gt; path is matched.</source>
          <target state="translated">라우트 매개 변수는 &lt;a href=&quot;../../ng/service/%24location&quot;&gt; &lt;code&gt;$location&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../ng/service/%24location#search.html&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ng/service/%24location#path.html&quot;&gt; &lt;code&gt;path()&lt;/code&gt; &lt;/a&gt; 의 조합입니다 . &lt;code&gt;path&lt;/code&gt; 경우 파라미터 추출 &lt;a href=&quot;%24route&quot;&gt; &lt;code&gt;$route&lt;/code&gt; &lt;/a&gt; 경로가 일치한다.</target>
        </trans-unit>
        <trans-unit id="a43d955a33928fdf9831543b7e1ccfb18aac7d0a" translate="yes" xml:space="preserve">
          <source>The same approach to animation can be used using JavaScript code (&lt;strong&gt;for simplicity, we rely on jQuery to perform animations here&lt;/strong&gt;):</source>
          <target state="translated">JavaScript 코드를 사용하여 동일한 애니메이션 접근 방식을 사용할 수 있습니다 ( &lt;strong&gt;간단하게하기 위해 여기서는 jQuery를 사용하여 애니메이션을 수행함&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="523d2b0e20860e85d563f00d6bc85a673967639f" translate="yes" xml:space="preserve">
          <source>The sanitization is a security measure aimed at prevent XSS attacks via html links.</source>
          <target state="translated">살균은 html 링크를 통한 XSS 공격을 방지하기위한 보안 조치입니다.</target>
        </trans-unit>
        <trans-unit id="1c5c39472248d0e17c07e839034df405aa0eb20b" translate="yes" xml:space="preserve">
          <source>The sanitization is a security measure aimed at preventing XSS attacks via html links.</source>
          <target state="translated">살균은 html 링크를 통한 XSS 공격을 방지하기위한 보안 조치입니다.</target>
        </trans-unit>
        <trans-unit id="b4a02425298ded7dac67b95b4a87a03949623e78" translate="yes" xml:space="preserve">
          <source>The scope property can be &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or an object:</source>
          <target state="translated">scope 속성은 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 또는 객체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f955ab37c085081f8ecb0e355fa65bbe8fdd0a33" translate="yes" xml:space="preserve">
          <source>The second approach (including the locale JavaScript file in &lt;code&gt;index.html&lt;/code&gt;) may be slower because an extra script needs to be loaded.</source>
          <target state="translated">추가 스크립트를로드해야하므로 두 번째 방법 ( &lt;code&gt;index.html&lt;/code&gt; 의 로캘 JavaScript 파일 포함 )이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0a91ee83246c2362ec6b21594ab31561d60a90" translate="yes" xml:space="preserve">
          <source>The second kind of new markup are the double curly braces &lt;code&gt;{{ expression | filter }}&lt;/code&gt;: When the compiler encounters this markup, it will replace it with the evaluated value of the markup. An &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; in a template is a JavaScript-like code snippet that allows AngularJS to read and write variables. Note that those variables are not global variables. Just like variables in a JavaScript function live in a scope, AngularJS provides a &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; for the variables accessible to expressions. The values that are stored in variables on the scope are referred to as the &lt;em&gt;model&lt;/em&gt; in the rest of the documentation. Applied to the example above, the markup directs AngularJS to &quot;take the data we got from the input widgets and multiply them together&quot;.</source>
          <target state="translated">새로운 마크 업의 두 번째 종류는 이중 중괄호 &lt;code&gt;{{ expression | filter }}&lt;/code&gt; : 컴파일러가이 마크 업을 만나면 평가 된 마크 업 값으로 대체합니다. 템플릿 의 &lt;a href=&quot;expression&quot;&gt;표현식&lt;/a&gt; 은 AngularJS가 변수를 읽고 쓸 수있게하는 JavaScript와 유사한 코드 스 니펫입니다. 이러한 변수는 전역 변수가 아닙니다. JavaScript 함수의 변수가 범위 내에있는 것처럼 AngularJS는 표현식에 액세스 할 수있는 변수 의 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 를 제공합니다 . 범위의 변수에 저장된 값 은 나머지 문서에서 &lt;em&gt;모델&lt;/em&gt; 이라고합니다 . 위의 예에 적용된 마크 업은 AngularJS가 &quot;입력 위젯에서 얻은 데이터를 가져 와서 곱하도록&quot;지시합니다.</target>
        </trans-unit>
        <trans-unit id="2ebae70ef1fa6d7815534c38bd1f7fc688ed15c4" translate="yes" xml:space="preserve">
          <source>The second option is more common in the AngularJS community, and is generally used in boilerplates and in this guide. However, there are advantages to binding properties directly to the controller and avoiding scope.</source>
          <target state="translated">두 번째 옵션은 AngularJS 커뮤니티에서 더 일반적이며 상용구 및이 안내서에서 일반적으로 사용됩니다. 그러나 속성을 컨트롤러에 직접 바인딩하고 범위를 피하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b2b19de1ee7661079f7d4e8bb9f6b0ded798f9" translate="yes" xml:space="preserve">
          <source>The section &lt;a href=&quot;scope#directives-that-create-scopes.html&quot;&gt;Directives that Create Scopes&lt;/a&gt; has more info about which directives create scopes.</source>
          <target state="translated">&lt;a href=&quot;scope#directives-that-create-scopes.html&quot;&gt;범위를 작성&lt;/a&gt; 하는 지시문 섹션 에는 범위를 작성 하는 지시문에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7899b56cd85970f84bbdd5c6f66e1f854610afa5" translate="yes" xml:space="preserve">
          <source>The selection keywords can be either exact matches or language dependent &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural categories&lt;/a&gt;.</source>
          <target state="translated">선택 키워드는 정확히 일치하거나 언어에 따른 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;복수 범주 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8625b6727f5759d3c8e5906c05a932804143e94" translate="yes" xml:space="preserve">
          <source>The service guarantees that the identity of the &lt;code&gt;$routeParams&lt;/code&gt; object will remain unchanged (but its properties will likely change) even when a route change occurs.</source>
          <target state="translated">이 서비스 는 경로 변경이 발생하더라도 &lt;code&gt;$routeParams&lt;/code&gt; 객체 의 ID 가 변경되지 않고 유지되지만 (속성이 변경 될 수 있음) 보장 합니다.</target>
        </trans-unit>
        <trans-unit id="60b4ba9fbc0c43d1d89edc827281cf4b26db6b11" translate="yes" xml:space="preserve">
          <source>The simplest form is to extract the dependencies from the arguments of the function. This is done by converting the function into a string using &lt;code&gt;toString()&lt;/code&gt; method and extracting the argument names.</source>
          <target state="translated">가장 간단한 형식은 함수의 인수에서 종속성을 추출하는 것입니다. &lt;code&gt;toString()&lt;/code&gt; 메서드를 사용하여 함수를 문자열로 변환 하고 인수 이름을 추출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3d8b353bfb07213b4379a03d5d422c15fb95b7ac" translate="yes" xml:space="preserve">
          <source>The simplest way to get hold of the dependencies is to assume that the function parameter names are the names of the dependencies.</source>
          <target state="translated">종속성을 얻는 가장 간단한 방법은 함수 매개 변수 이름이 종속성의 이름이라고 가정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c64a50b85ba98a676c625d981a6a8bbf9f4f8a52" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;../type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;a href=&quot;%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; 와 연관된 &lt;a href=&quot;../type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt; 유형 의 싱글 톤 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="ba995a06669ab9293ed40548419fa1f16acfcf3f" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;ngcomponentrouter/type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;ngcomponentrouter/service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;a href=&quot;ngcomponentrouter/service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; 와 연관된 &lt;a href=&quot;ngcomponentrouter/type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt; 유형 의 싱글 톤 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="d028290d2d263328b04957680190b4fc0e324747" translate="yes" xml:space="preserve">
          <source>The singleton instance of the &lt;a href=&quot;type/rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; type, which is associated with the top level &lt;a href=&quot;service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;a href=&quot;service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; 와 연관된 &lt;a href=&quot;type/rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt; 유형 의 싱글 톤 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="767e784d7ccc55d7ed23bfc011d3d6882f0b815d" translate="yes" xml:space="preserve">
          <source>The solution is to break the compilation process into two phases:</source>
          <target state="translated">해결책은 컴파일 프로세스를 두 단계로 나누는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44bd33d4e5c5dbd425e1b01d352cce7c15b457b1" translate="yes" xml:space="preserve">
          <source>The sorted array.</source>
          <target state="translated">정렬 된 배열.</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">소스 배열</target>
        </trans-unit>
        <trans-unit id="0e88179bff5210ac7427674521c7a3345e2dd3b9" translate="yes" xml:space="preserve">
          <source>The source that will be used to make a copy. Can be any type, including primitives, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">사본을 만드는 데 사용될 소스입니다. 프리미티브, &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 포함한 모든 유형이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d85a9cbe026aa1a3ba5f747284fb0ad3f412ddf3" translate="yes" xml:space="preserve">
          <source>The special &lt;strong&gt;string&lt;/strong&gt;, &lt;code&gt;'self'&lt;/code&gt;, can be used to match against all URLs of the &lt;strong&gt;same domain&lt;/strong&gt; as the application document using the &lt;strong&gt;same protocol&lt;/strong&gt;.</source>
          <target state="translated">특수 &lt;strong&gt;문자열&lt;/strong&gt; , &lt;code&gt;'self'&lt;/code&gt; ,의 모든 URL에 대해 일치하는 데 사용할 수있는 &lt;strong&gt;동일한 도메인&lt;/strong&gt; 사용하여 응용 프로그램 문서와 &lt;strong&gt;같은 프로토콜을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b55be8e2b115455f7e384250866854b317142fba" translate="yes" xml:space="preserve">
          <source>The special property name that matches against any property. By default &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">모든 속성과 일치하는 특수 속성 이름입니다. 기본적으로 &lt;code&gt;$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7279a354975752084c586a2a76858e65adbcf9b6" translate="yes" xml:space="preserve">
          <source>The streamlined ES6 style promise is essentially just using $q as a constructor which takes a &lt;code&gt;resolver&lt;/code&gt; function as the first argument. This is similar to the native Promise implementation from ES6, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">간소화 된 ES6 스타일 약속은 본질적으로 $ q를 생성자 로 사용하여 첫 번째 인수로 &lt;code&gt;resolver&lt;/code&gt; 함수를 사용합니다. 이것은 ES6의 기본 Promise 구현과 유사합니다 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="a25884531cd967bc8dd68721f141065ccbf8a1a8" translate="yes" xml:space="preserve">
          <source>The string can use the &lt;code&gt;controller as property&lt;/code&gt; syntax, where the controller instance is published as the specified property on the &lt;code&gt;scope&lt;/code&gt;; the &lt;code&gt;scope&lt;/code&gt; must be injected into &lt;code&gt;locals&lt;/code&gt; param for this to work correctly.</source>
          <target state="translated">문자열은 &lt;code&gt;controller as property&lt;/code&gt; 구문 으로 사용할 수 있습니다. 여기서 컨트롤러 인스턴스는 &lt;code&gt;scope&lt;/code&gt; 에서 지정된 속성으로 게시됩니다 . 이것이 제대로 작동 하려면 &lt;code&gt;scope&lt;/code&gt; 를 &lt;code&gt;locals&lt;/code&gt; 매개 변수에 삽입해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a64f560cdc5bc1215f3896949fd70a8f33418cdb" translate="yes" xml:space="preserve">
          <source>The string is matched against the full &lt;em&gt;normalized / absolute URL&lt;/em&gt; of the resource being tested (substring matches are not good enough.)</source>
          <target state="translated">문자열이 테스트중인 자원의 &lt;em&gt;정규화 된 / 절대 URL&lt;/em&gt; 과 일치합니다 (하위 문자열 일치가 충분하지 않음).</target>
        </trans-unit>
        <trans-unit id="14ebe6cf667e2257d2375b20acaba4b014d40a48" translate="yes" xml:space="preserve">
          <source>The syntax extension is based on a subset of the ICU MessageFormat syntax that covers plurals and gender selections. Please refer to the links in the &amp;ldquo;Further Reading&amp;rdquo; section at the bottom of this section.</source>
          <target state="translated">구문 확장은 복수 및 성별 선택을 다루는 ICU MessageFormat 구문의 하위 세트를 기반으로합니다. 이 섹션 하단의 &quot;추가 정보&quot;섹션에있는 링크를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b15b3f178b589324cba127ffcc8609a03ddf2842" translate="yes" xml:space="preserve">
          <source>The syntax for gender based message selection looks like the following:</source>
          <target state="translated">성별 기반 메시지 선택 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="514dc6d368ee619bf7af44246bc3cca46261a937" translate="yes" xml:space="preserve">
          <source>The syntax for plural based message selection looks like the following:</source>
          <target state="translated">복수 기반 메시지 선택 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="331463984a3b27be7e66de67f6ec1c8959531bed" translate="yes" xml:space="preserve">
          <source>The text with markup to interpolate.</source>
          <target state="translated">보간 할 마크 업이있는 텍스트</target>
        </trans-unit>
        <trans-unit id="236530003226f5a2700778994862268772faf8ef" translate="yes" xml:space="preserve">
          <source>The third option is the most viable, since it removes the responsibility of locating the dependency from the component. The dependency is simply handed to the component.</source>
          <target state="translated">세 번째 옵션은 구성 요소에서 종속성을 찾는 책임을 제거하므로 가장 실행 가능성이 높습니다. 종속성은 단순히 구성 요소에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4caf4221a8f1aa9f8dc16ac34dd67bede58930f0" translate="yes" xml:space="preserve">
          <source>The thrown error or the rejection reason of the promise. Usually the rejection reason is the error that caused the promise to get rejected.</source>
          <target state="translated">던진 오류 또는 약속의 거부 이유. 일반적으로 거부 이유는 약속이 거부 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7a7b44ea3970e86105ad586eeb8a71485b91c29b" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; 와 연관된 최상위 &lt;strong&gt;라우팅 구성 요소&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="548afd75a531de9081c581cb6d8715fb94f8f938" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;ngcomponentrouter/service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ngcomponentrouter/service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; 와 연관된 최상위 &lt;strong&gt;라우팅 구성 요소&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="386ecc261ed1232a9a17fbea9ac69f87afe81bba" translate="yes" xml:space="preserve">
          <source>The top level &lt;strong&gt;Routing Component&lt;/strong&gt; associated with the &lt;a href=&quot;service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; 와 연관된 최상위 &lt;strong&gt;라우팅 구성 요소&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5864476324c5e315d5688546efeaae47300579a1" translate="yes" xml:space="preserve">
          <source>The two images match since they share the same ref value. ngAnimate will now create a transport element (which is a clone of the first image element) and it will then attempt to animate to the position of the second image element in the next view. For the animation to work a special CSS class called &lt;code&gt;ng-anchor&lt;/code&gt; will be added to the transported element.</source>
          <target state="translated">두 이미지는 동일한 참조 값을 공유하므로 일치합니다. ngAnimate는 이제 전송 요소 (첫 번째 이미지 요소의 복제본)를 만들고 다음보기에서 두 번째 이미지 요소의 위치에 애니메이션을 적용하려고 시도합니다. 애니메이션이 작동하도록 &lt;code&gt;ng-anchor&lt;/code&gt; 라는 특수 CSS 클래스 가 전송 된 요소에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e52841430957d24c12d016a27d0ebbbbee23eb5" translate="yes" xml:space="preserve">
          <source>The type of tasks to check for.</source>
          <target state="translated">확인할 작업 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c9809d2c6f9fe9599eaef845df8e9b7ac65b418e" translate="yes" xml:space="preserve">
          <source>The types of tasks that are flushed include:</source>
          <target state="translated">플러시되는 작업 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46b2bd429084177f8681f56d4ade922af6dc9c27" translate="yes" xml:space="preserve">
          <source>The typical usage for the blacklist is to &lt;strong&gt;block &lt;a href=&quot;http://cwe.mitre.org/data/definitions/601.html&quot;&gt;open redirects&lt;/a&gt;&lt;/strong&gt; served by your domain as these would otherwise be trusted but actually return content from the redirected domain.</source>
          <target state="translated">블랙리스트의 일반적인 사용법은 신뢰할 수 있지만 실제로 리디렉션 된 도메인에서 콘텐츠를 반환하기 때문에 도메인에서 제공하는 &lt;strong&gt;&lt;a href=&quot;http://cwe.mitre.org/data/definitions/601.html&quot;&gt;열린 리디렉션&lt;/a&gt;&lt;/strong&gt; 을 &lt;strong&gt;차단&lt;/strong&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0870b31834bb02fbc73aaf4c9ab88489da8144fb" translate="yes" xml:space="preserve">
          <source>The underlying API is the &lt;a href=&quot;../api/ng/provider/%24filterprovider&quot;&gt;&lt;code&gt;$filterProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 API는 &lt;a href=&quot;../api/ng/provider/%24filterprovider&quot;&gt; &lt;code&gt;$filterProvider&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7da48aa48cb58f7d4f1b84542c5c4e396f23ea4f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;eval()&lt;/code&gt;, &lt;code&gt;Function(string)&lt;/code&gt; and similar functions to dynamically create and execute code from strings is forbidden. AngularJS makes use of this in the &lt;a href=&quot;../service/%24parse&quot;&gt;&lt;code&gt;$parse&lt;/code&gt;&lt;/a&gt; service to provide a 30% increase in the speed of evaluating AngularJS expressions. (This CSP rule can be disabled with the CSP keyword &lt;code&gt;unsafe-eval&lt;/code&gt;, but it is generally not recommended as it would weaken the protections offered by CSP.)</source>
          <target state="translated">사용 &lt;code&gt;eval()&lt;/code&gt; , &lt;code&gt;Function(string)&lt;/code&gt; 동적 문자열의 코드를 생성하고 실행하기 위해 유사한 기능은 금지된다. AngularJS는 &lt;a href=&quot;../service/%24parse&quot;&gt; &lt;code&gt;$parse&lt;/code&gt; &lt;/a&gt; 서비스 에서 이것을 사용하여 AngularJS 표현식 평가 속도를 30 % 향상시킵니다. (이 CSP 규칙은 CSP 키워드 &lt;code&gt;unsafe-eval&lt;/code&gt; 로 비활성화 할 수 있지만 일반적으로 CSP가 제공하는 보호 기능을 약화 시키므로 권장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="ab18458a0f8961320a15a220d2d9624ea8d111c4" translate="yes" xml:space="preserve">
          <source>The use of inline resources, such as inline &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; elements, are forbidden. This prevents apps from injecting custom styles directly into the document. AngularJS makes use of this to include some CSS rules (e.g. &lt;a href=&quot;ngcloak&quot;&gt;&lt;code&gt;ngCloak&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;). To make these directives work when a CSP rule is blocking inline styles, you must link to the &lt;code&gt;angular-csp.css&lt;/code&gt; in your HTML manually. (This CSP rule can be disabled with the CSP keyword &lt;code&gt;unsafe-inline&lt;/code&gt;, but it is generally not recommended as it would weaken the protections offered by CSP.)</source>
          <target state="translated">인라인 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 요소 와 같은 인라인 리소스 사용 은 금지되어 있습니다. 이렇게하면 앱이 문서에 직접 사용자 정의 스타일을 주입하지 못합니다. AngularJS는이를 사용하여 일부 CSS 규칙 (예 : &lt;a href=&quot;ngcloak&quot;&gt; &lt;code&gt;ngCloak&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt; )을 포함시킵니다. CSP 규칙이 인라인 스타일을 차단할 때 이러한 지시문이 작동하게하려면 HTML에서 &lt;code&gt;angular-csp.css&lt;/code&gt; 에 수동으로 연결해야합니다. (이 CSP 규칙은 CSP 키워드 &lt;code&gt;unsafe-inline&lt;/code&gt; 으로 비활성화 할 수 있지만 일반적으로 CSP가 제공하는 보호 기능을 약화 시키므로 권장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="eebb37fdb7d6c174eb9c065210d8ec5ba28ee2bf" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;maxlength&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; is longer than the integer obtained by evaluating the AngularJS expression given in the &lt;code&gt;ngMaxlength&lt;/code&gt; attribute value.</source>
          <target state="translated">&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ngMaxlength&lt;/code&gt; 속성 값에 제공된 AngularJS 표현식을 평가하여 얻은 정수보다 긴 경우 유효성 검증기는 &lt;code&gt;maxlength&lt;/code&gt; 오류 키를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="95e23f64426ffefd09f928fb9dadff94eb920e6f" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;minlength&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; is shorter than the integer obtained by evaluating the AngularJS expression given in the &lt;code&gt;ngMinlength&lt;/code&gt; attribute value.</source>
          <target state="translated">검사기는 설정 &lt;code&gt;minlength&lt;/code&gt; 경우 생성 오류 키 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt; 에 주어진 AngularJS와 식 평가에 의해 얻어진 정수보다 짧은 &lt;code&gt;ngMinlength&lt;/code&gt; 의 특성 값.</target>
        </trans-unit>
        <trans-unit id="e24301c2cb5d52b2ea32feb0ec399b5f0d739449" translate="yes" xml:space="preserve">
          <source>The validator sets the &lt;code&gt;pattern&lt;/code&gt; error key if the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; does not match a RegExp which is obtained from the &lt;code&gt;ngPattern&lt;/code&gt; attribute value:</source>
          <target state="translated">&lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ngPattern&lt;/code&gt; 속성 값 에서 얻은 RegExp와 일치하지 않으면 유효성 검사기는 &lt;code&gt;pattern&lt;/code&gt; 오류 키를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8b8747fb2ca401641b1a4ecf5eb6042bf5b61777" translate="yes" xml:space="preserve">
          <source>The validator will set the &lt;code&gt;required&lt;/code&gt; error key to true if the &lt;code&gt;required&lt;/code&gt; attribute is set and calling &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24isEmpty.html&quot;&gt;&lt;code&gt;NgModelController.$isEmpty&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;ngModel.$viewValue&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;. For example, the &lt;code&gt;$isEmpty()&lt;/code&gt; implementation for &lt;code&gt;input[text]&lt;/code&gt; checks the length of the &lt;code&gt;$viewValue&lt;/code&gt;. When developing custom controls, &lt;code&gt;$isEmpty()&lt;/code&gt; can be overwritten to account for a $viewValue that is not string-based.</source>
          <target state="translated">발리는 설정합니다 &lt;code&gt;required&lt;/code&gt; 경우 생성 true로 오류 키를 &lt;code&gt;required&lt;/code&gt; 속성이 설정되어 및 호출 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24isEmpty.html&quot;&gt; &lt;code&gt;NgModelController.$isEmpty&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;ngModel.$viewValue&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; . 예를 들어 &lt;code&gt;input[text]&lt;/code&gt; 의 &lt;code&gt;$isEmpty()&lt;/code&gt; 구현 은 &lt;code&gt;$viewValue&lt;/code&gt; 의 길이를 확인합니다 . 사용자 지정 컨트롤을 개발할 때 문자열 기반이 아닌 $ viewValue를 설명하기 위해 &lt;code&gt;$isEmpty()&lt;/code&gt; 를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da43acb6e9a82ff95654a25655433849b9f27b07" translate="yes" xml:space="preserve">
          <source>The value in the model that the control is bound to.</source>
          <target state="translated">컨트롤이 바인딩 된 모델의 값입니다.</target>
        </trans-unit>
        <trans-unit id="14b23e5ee2cfb999b445acbc780311b9a12fe737" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ngModel&lt;/code&gt; won't be set unless it passes validation for the input field. For example: inputs of type &lt;code&gt;email&lt;/code&gt; must have a value in the form of &lt;code&gt;user@domain&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 의 값은 입력 필드의 유효성 검사를 통과하지 않으면 설정되지 않습니다. 예를 들어, &lt;code&gt;email&lt;/code&gt; 유형의 입력 은 &lt;code&gt;user@domain&lt;/code&gt; 형식의 값을 가져야 합니다 .</target>
        </trans-unit>
        <trans-unit id="b7c0a4135d026e4590cabdf020b1214be6ef8102" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;count&lt;/code&gt; attribute can be either a string or an &lt;a href=&quot;../../../guide/expression&quot;&gt;AngularJS expression&lt;/a&gt;; these are evaluated on the current scope for its bound value.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 속성 값은 문자열 또는 &lt;a href=&quot;../../../guide/expression&quot;&gt;AngularJS 표현식&lt;/a&gt; 일 수 있습니다 . 이들은 현재 범위에서 해당 바운드 값에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1b73e986ca72f64054cdba299a9701373d5dfec0" translate="yes" xml:space="preserve">
          <source>The value of the input to check for emptiness.</source>
          <target state="translated">공허를 점검하기위한 입력 값.</target>
        </trans-unit>
        <trans-unit id="44463f976abf31a5394099b3a0a4e6208a67f0fc" translate="yes" xml:space="preserve">
          <source>The value referenced by &lt;code&gt;ng-model&lt;/code&gt; is changed programmatically and both the &lt;code&gt;$modelValue&lt;/code&gt; and the &lt;code&gt;$viewValue&lt;/code&gt; are different from last time.</source>
          <target state="translated">&lt;code&gt;ng-model&lt;/code&gt; 이 참조하는 값 은 프로그래밍 방식으로 변경되며 &lt;code&gt;$modelValue&lt;/code&gt; 와 &lt;code&gt;$viewValue&lt;/code&gt; 는 마지막 시간과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6b0143fd9ece1d0387124beb89dd5c7fd4bc5a91" translate="yes" xml:space="preserve">
          <source>The value that should be considered trusted.</source>
          <target state="translated">신뢰할 수있는 것으로 간주해야 할 가치.</target>
        </trans-unit>
        <trans-unit id="6b506880f20531602ad2eb0fa099daa12bfb5b84" translate="yes" xml:space="preserve">
          <source>The value that that should be considered trusted.</source>
          <target state="translated">신뢰할 수있는 것으로 간주해야하는 가치.</target>
        </trans-unit>
        <trans-unit id="3174f6de2b1a572b3ef68f749f440587119fa478" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.CSS&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.CSS&lt;/code&gt; 컨텍스트에 신뢰할 수있는 것으로 표시 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c130aa44236fc44f23102a665d5d5963b688f052" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.HTML&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.HTML&lt;/code&gt; 컨텍스트에 대해 신뢰할 수있는 것으로 표시 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="cf9b76745715759b224d248b10d334a51d267341" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.JS&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.JS&lt;/code&gt; 컨텍스트에 대해 신뢰할 수있는 것으로 표시 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="def9516ca7a6eb4975cef660dfbfbd813f67783b" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; 컨텍스트에 신뢰할 수있는 것으로 표시 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="055605c6f52998605859dc20359c0bf18aa8a534" translate="yes" xml:space="preserve">
          <source>The value to mark as trusted for &lt;code&gt;$sce.URL&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;$sce.URL&lt;/code&gt; 컨텍스트에 신뢰할 수있는 것으로 표시 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="435759993cef3a1ebd9ea38393b7168b54598cf3" translate="yes" xml:space="preserve">
          <source>The value to pass to &lt;code&gt;$sce.getTrusted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$sce.getTrusted&lt;/code&gt; 에 전달할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="35971100dfde05b044e38f25dc4ec52471feb171" translate="yes" xml:space="preserve">
          <source>The value to pass to &lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt; 에 전달할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">가치.</target>
        </trans-unit>
        <trans-unit id="62a76571179e7a797adcf5b0dca4482159e1774f" translate="yes" xml:space="preserve">
          <source>The variable to be bound to.</source>
          <target state="translated">바인딩 할 변수입니다.</target>
        </trans-unit>
        <trans-unit id="eb0c8dfaa72fe998ded88b434f150524ba3c8874" translate="yes" xml:space="preserve">
          <source>The version could then be read back out by accessing the module elsewhere:</source>
          <target state="translated">그런 다음 다른 곳에서 모듈에 액세스하여 버전을 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43454983a5496d952f24ef6981aa235148e2e821" translate="yes" xml:space="preserve">
          <source>The watch &lt;code&gt;listener&lt;/code&gt; may change the model, which may trigger other &lt;code&gt;listener&lt;/code&gt;s to fire. This is achieved by rerunning the watchers until no changes are detected. The rerun iteration limit is 10 to prevent an infinite loop deadlock.</source>
          <target state="translated">시계 &lt;code&gt;listener&lt;/code&gt; 가 모델을 변경하여 다른 &lt;code&gt;listener&lt;/code&gt; 가 시작될 수 있습니다 . 변경 사항이 감지되지 않을 때까지 감시자를 다시 실행하면됩니다. 무한 루프 교착 상태를 방지하기 위해 재실행 반복 한계는 10입니다.</target>
        </trans-unit>
        <trans-unit id="b3908c90281bc35a0fa4df23a51dff370901b1f6" translate="yes" xml:space="preserve">
          <source>The watchers of the current scope are included in the count and so are all the watchers of isolate child scopes.</source>
          <target state="translated">현재 범위의 감시자는 수에 포함되며 격리 된 하위 범위의 모든 감시자도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f561ff816ae7aefdfc8fd009517d7b9fcbad64ce" translate="yes" xml:space="preserve">
          <source>The way you define a directive, service, or filter is with a factory function. The factory methods are registered with modules. The recommended way of declaring factories is:</source>
          <target state="translated">지시문, 서비스 또는 필터를 정의하는 방법은 팩토리 기능을 사용합니다. 팩토리 메소드는 모듈에 등록되어 있습니다. 팩토리를 선언하는 권장 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb5175d364ed0ee1ef08306c1d28e391169ff525" translate="yes" xml:space="preserve">
          <source>The whitelist for URL sanitization of attribute values is configured using the functions &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; and &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; of &lt;a href=&quot;../../ng/provider/%24compileprovider&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성 값의 URL 삭제를위한 화이트리스트 는 &lt;a href=&quot;../../ng/provider/%24compileprovider&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; 및 &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; 함수를 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bcb4b40a369e071e66ceee940ccd85ed11ee25c" translate="yes" xml:space="preserve">
          <source>The workaround is to ensure that such instances are separated by whitespace:</source>
          <target state="translated">해결 방법은 이러한 인스턴스가 공백으로 분리되도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b08b5bc31a0f9b0aaed1244795ed5323c9f55509" translate="yes" xml:space="preserve">
          <source>The wrong way to write it:</source>
          <target state="translated">그것을 쓰는 잘못된 방법 :</target>
        </trans-unit>
        <trans-unit id="987f327e589afcef1c088418e5aec840d608c486" translate="yes" xml:space="preserve">
          <source>Then load the module in your application by adding it as a dependent module:</source>
          <target state="translated">그런 다음 모듈을 종속 모듈로 추가하여 애플리케이션에 모듈을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="7d2b29d57502f260e757766c62c868a34c233461" translate="yes" xml:space="preserve">
          <source>Then the CSS animation code for the message container looks like so:</source>
          <target state="translated">그런 다음 메시지 컨테이너의 CSS 애니메이션 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4420f082e957bdeb70a28e331407c72ac0fa9f6e" translate="yes" xml:space="preserve">
          <source>Then you can create an injector and load your modules like this:</source>
          <target state="translated">그런 다음 인젝터를 작성하고 다음과 같이 모듈을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74684d8de56bfaa1c2e51da13b1734863d4fb9f" translate="yes" xml:space="preserve">
          <source>Then, configure your test runner to load &lt;code&gt;angular-mocks.js&lt;/code&gt; after &lt;code&gt;angular.js&lt;/code&gt;. This example uses &lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;Karma&lt;/a&gt;:</source>
          <target state="translated">그런 다음,로드 테스트 러너 구성 &lt;code&gt;angular-mocks.js&lt;/code&gt; 한 후 &lt;code&gt;angular.js&lt;/code&gt; 을 . 이 예는 &lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;Karma&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d32bb96d5e92506ee0985b73373006273831ce51" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-animate.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-animate.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="be42b1b9ea22296aed835ed67fd0503f2d1c7ce1" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-aria.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-aria.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ac37b863957206f52a67a02d8148afa2722ae351" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-cookies.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-cookies.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ae69b27ed53748a28e2133d629a343fe3e5b36d0" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-message-format.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-message-format.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="33510a8d30ee13097925c8687d0b4a0dc5b54dd9" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-messages.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-messages.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="bb1a4ae9bcaf5171467ecc41d0db098c41b54bdb" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-mocks.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-mocks.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="b063c697f244bfb6f28cfccd98309c35fe2f0e16" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-parse-ext.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-parse-ext.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="14e0b01648408cdb8437a7490c7878d70c602c47" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-resource.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-resource.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="d20a74b3dd55a1d4eca8992c7a14fa2a1d9e3918" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-route.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-route.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="e735fd0e46663b7101645180fb23c07bb057a514" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-sanitize.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-sanitize.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="4104e34a174331405f4b0d2b7199cfaf3401d567" translate="yes" xml:space="preserve">
          <source>Then, include &lt;code&gt;angular-touch.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">그런 다음 HTML에 &lt;code&gt;angular-touch.js&lt;/code&gt; 를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="d12134494475237ef73f311dad22d23a4a004ddd" translate="yes" xml:space="preserve">
          <source>Then, the &lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;run&lt;/a&gt; blocks that have been collected from each module are executed in order of requirement.</source>
          <target state="translated">그런 다음 각 모듈에서 수집 된 &lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;실행&lt;/a&gt; 블록이 요구 사항 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2e850ec6b850797a6a79db638c878c1fdc64c72f" translate="yes" xml:space="preserve">
          <source>There also exists a special &lt;a href=&quot;http://code.google.com/web/ajaxcrawling/docs/specification.html&quot;&gt;AJAX crawling scheme&lt;/a&gt; developed by Google that allows bots to crawl the static equivalent of a dynamically generated page, but this schema has been deprecated, and support for it may vary by search engine.</source>
          <target state="translated">또한 Google에서 개발 한 특수 &lt;a href=&quot;http://code.google.com/web/ajaxcrawling/docs/specification.html&quot;&gt;AJAX 크롤링 체계&lt;/a&gt; 가있어 봇이 동적으로 생성 된 페이지와 동일한 정적 크롤링을 크롤링 할 수 있지만이 스키마는 더 이상 사용되지 않으며이 기능에 대한 지원은 검색 엔진에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="130d9b350defbba659ae904cdf720b49833cb081" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note here. Just like the &lt;code&gt;module.controller&lt;/code&gt; API, the function argument in &lt;code&gt;module.directive&lt;/code&gt; is dependency injected. Because of this, we can use &lt;code&gt;$interval&lt;/code&gt; and &lt;code&gt;dateFilter&lt;/code&gt; inside our directive's &lt;code&gt;link&lt;/code&gt; function.</source>
          <target state="translated">여기에 몇 가지주의 할 사항이 있습니다. &lt;code&gt;module.controller&lt;/code&gt; API 와 마찬가지로 &lt;code&gt;module.directive&lt;/code&gt; 의 함수 인수 는 종속성 주입입니다. 이 때문에 지시문의 &lt;code&gt;link&lt;/code&gt; 함수 내에서 &lt;code&gt;$interval&lt;/code&gt; 및 &lt;code&gt;dateFilter&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22aac06fcbba861d9deabbd7db65ea5290a0d817" translate="yes" xml:space="preserve">
          <source>There are a few examples that showcase how to use AngularJS filters with various locale rule sets in the &lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/e2e&quot;&gt;&lt;code&gt;i18n/e2e&lt;/code&gt; directory&lt;/a&gt; of the AngularJS source code.</source>
          <target state="translated">AngularJS 소스 코드 의 &lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/e2e&quot;&gt; &lt;code&gt;i18n/e2e&lt;/code&gt; 디렉토리&lt;/a&gt; 에 다양한 로케일 규칙 세트와 함께 AngularJS 필터를 사용하는 방법을 보여주는 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1bfb8991ae5c4f9e31fb56a70d6baff7aba4e7f" translate="yes" xml:space="preserve">
          <source>There are a few special events that AngularJS emits. When a DOM node that has been compiled with AngularJS's compiler is destroyed, it emits a &lt;code&gt;$destroy&lt;/code&gt; event. Similarly, when an AngularJS scope is destroyed, it broadcasts a &lt;code&gt;$destroy&lt;/code&gt; event to listening scopes.</source>
          <target state="translated">AngularJS가 내보내는 몇 가지 특별한 이벤트가 있습니다. AngularJS의 컴파일러로 컴파일 된 DOM 노드가 소멸되면 &lt;code&gt;$destroy&lt;/code&gt; 이벤트가 발생합니다 . 마찬가지로 AngularJS 범위가 소멸되면 &lt;code&gt;$destroy&lt;/code&gt; 이벤트를 청취 범위로 브로드 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="2f1db69945853c0d37d9a79a76c27844cddebc4a" translate="yes" xml:space="preserve">
          <source>There are a few things to keep in mind regardless of automatic or manual bootstrapping:</source>
          <target state="translated">자동 또는 수동 부트 스트랩과 관계없이 명심해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="95101ca63f8d69f5d9cdd1c823a21dd5e29b3a87" translate="yes" xml:space="preserve">
          <source>There are a few things to keep in mind when using &lt;code&gt;ngApp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ngApp&lt;/code&gt; 을 사용할 때 명심해야 할 것이 몇 가지 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf3ee4bd5875653a956ae013e1f9a754843ecf9" translate="yes" xml:space="preserve">
          <source>There are a few things you might consider when running your AngularJS application in production.</source>
          <target state="translated">프로덕션 환경에서 AngularJS 애플리케이션을 실행할 때 고려해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c519b820846227a1173c2c2eabfe5a86e6afa6" translate="yes" xml:space="preserve">
          <source>There are a number of ways that templates and expressions can be controlled:</source>
          <target state="translated">템플릿과 표현식을 제어 할 수있는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f12a2ba7d25176e96b87dc8a9715efae8e42b4f" translate="yes" xml:space="preserve">
          <source>There are exactly &lt;strong&gt;two wildcard sequences&lt;/strong&gt; - &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt;. All other characters match themselves.</source>
          <target state="translated">정확히이 있습니다 &lt;strong&gt;이 와일드 카드 시퀀스&lt;/strong&gt; - &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;**&lt;/code&gt; 는 . 다른 모든 캐릭터는 서로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, Factory, Service, Provider and Constant.</source>
          <target state="translated">객체 생성 방법을 정의하는 5 가지 레시피 유형이 있습니다 : Value, Factory, Service, Provider 및 Constant.</target>
        </trans-unit>
        <trans-unit id="b990c7868d77b4c950319ea8bf70ed42696c2ff8" translate="yes" xml:space="preserve">
          <source>There are many different options for a directive.</source>
          <target state="translated">지시문에는 여러 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44a999479cdafb004f6c8616bcc95ef2dfa72651" translate="yes" xml:space="preserve">
          <source>There are no CSS or JS context bindings in AngularJS currently, so their corresponding &lt;code&gt;$sce.trustAs&lt;/code&gt; functions aren't useful yet. This might evolve.</source>
          <target state="translated">현재 AngularJS에는 CSS 또는 JS 컨텍스트 바인딩이 없으므로 해당 &lt;code&gt;$sce.trustAs&lt;/code&gt; 함수는 아직 유용하지 않습니다. 이것은 진화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f60ceec8589342669960dc8d147c35c7893ead" translate="yes" xml:space="preserve">
          <source>There are only three ways a component (object or function) can get a hold of its dependencies:</source>
          <target state="translated">컴포넌트 (객체 또는 함수)가 의존성을 유지할 수있는 방법은 세 가지뿐입니다.</target>
        </trans-unit>
        <trans-unit id="66f6fbd80fe8ea46a687b78aa0411b5df8473d11" translate="yes" xml:space="preserve">
          <source>There are several different ways to disable animations, both globally and for specific animations. Disabling specific animations can help to speed up the render performance, for example for large &lt;code&gt;ngRepeat&lt;/code&gt; lists that don't actually have animations. Because &lt;code&gt;ngAnimate&lt;/code&gt; checks at runtime if animations are present, performance will take a hit even if an element has no animation.</source>
          <target state="translated">전역 및 특정 애니메이션에 대해 애니메이션을 비활성화하는 방법에는 여러 가지가 있습니다. 특정 애니메이션을 비활성화하면 실제로 애니메이션이없는 큰 &lt;code&gt;ngRepeat&lt;/code&gt; 목록의 경우 렌더링 성능을 높일 수 있습니다 . &lt;code&gt;ngAnimate&lt;/code&gt; 는 애니메이션이 존재하는 경우 런타임에 확인 하기 때문에 요소에 애니메이션이없는 경우에도 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="5215767d4d7638b5c9fa856bf4e4ce676b7f648e" translate="yes" xml:space="preserve">
          <source>There are several way to mitigate this problem:</source>
          <target state="translated">이 문제를 완화하는 방법은 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6acde2bec5e72bfd06e3cfbf1f79236cbb60d66" translate="yes" xml:space="preserve">
          <source>There are three kinds of transclusion depending upon whether you want to transclude just the contents of the directive's element, the entire element or multiple parts of the element contents:</source>
          <target state="translated">지시어 요소의 내용 만, 전체 요소 또는 요소 내용의 여러 부분 만 포함할지 여부에 따라 세 가지 유형의 변환이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2199989a69d3b490219217eaf3cfa4a17c693346" translate="yes" xml:space="preserve">
          <source>There are two &lt;a href=&quot;http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&quot;&gt;plural categories&lt;/a&gt; in AngularJS's default en-US locale: &quot;one&quot; and &quot;other&quot;.</source>
          <target state="translated">AngularJS의 기본 en-US 로켈에는 &quot;하나&quot;와 &quot;다른&quot;이라는 두 가지 &lt;a href=&quot;http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&quot;&gt;범주&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e4cfb93c504b3cf5f31483d3014aea04a7a10e9" translate="yes" xml:space="preserve">
          <source>There are two approaches to providing locale rules to AngularJS:</source>
          <target state="translated">AngularJS에 로케일 규칙을 제공하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a315166c5b92460227594ad824a5f7dffe1174e" translate="yes" xml:space="preserve">
          <source>There are two kinds of Router: &lt;a href=&quot;rootrouter&quot;&gt;&lt;code&gt;RootRouter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;childrouter&quot;&gt;&lt;code&gt;ChildRouter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">라우터에는 &lt;a href=&quot;rootrouter&quot;&gt; &lt;code&gt;RootRouter&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;childrouter&quot;&gt; &lt;code&gt;ChildRouter&lt;/code&gt; &lt;/a&gt; 의 두 가지 종류가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8457172152396945221a9bb7abc47bdb2fb360a4" translate="yes" xml:space="preserve">
          <source>There are two kinds of interceptors (and two kinds of rejection interceptors):</source>
          <target state="translated">두 종류의 인터셉터 (및 두 종류의 거부 인터셉터)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="984ce92ebd9ffa671cbef47120514527e6ec5ced" translate="yes" xml:space="preserve">
          <source>There are two main differences:</source>
          <target state="translated">두 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71aafbc13740296ddff7de52f6fd4b006802c2b8" translate="yes" xml:space="preserve">
          <source>There are two ways to register decorators</source>
          <target state="translated">데코레이터를 등록하는 두 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="f29586d91e000a0120c5f20624018b52e64c8adc" translate="yes" xml:space="preserve">
          <source>There are two ways to specify what test data should be returned as http responses by the mock backend when the code under test makes http requests:</source>
          <target state="translated">테스트중인 코드가 http 요청을 할 때 모의 백엔드가 http 응답으로 리턴 할 테스트 데이터를 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="05eed5a5bae2275e702df7fc9bbddf5598e8921e" translate="yes" xml:space="preserve">
          <source>There are various places that the browser can store (or cache) data. Within AngularJS there are objects created by the &lt;a href=&quot;../api/ng/service/%24cachefactory&quot;&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;&lt;/a&gt;. These objects, such as &lt;a href=&quot;../api/ng/service/%24templatecache&quot;&gt;&lt;code&gt;$templateCache&lt;/code&gt;&lt;/a&gt; are used to store and retrieve data, primarily used by &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../api/ng/directive/script&quot;&gt;&lt;code&gt;script&lt;/code&gt;&lt;/a&gt; directive to cache templates and other data.</source>
          <target state="translated">브라우저가 데이터를 저장 (또는 캐시) 할 수있는 다양한 위치가 있습니다. AngularJS에는 &lt;a href=&quot;../api/ng/service/%24cachefactory&quot;&gt; &lt;code&gt;$cacheFactory&lt;/code&gt; &lt;/a&gt; 의해 생성 된 객체가 있습니다 . &lt;a href=&quot;../api/ng/service/%24templatecache&quot;&gt; &lt;code&gt;$templateCache&lt;/code&gt; &lt;/a&gt; 와 같은 이러한 개체 는 데이터를 저장하고 검색하는 데 사용되며 주로 &lt;a href=&quot;../api/ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ng/directive/script&quot;&gt; &lt;code&gt;script&lt;/code&gt; &lt;/a&gt; 지시문에서 템플릿 및 기타 데이터를 캐시 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8876989e9de229aee2aea75b9ae2ca7d7de6211" translate="yes" xml:space="preserve">
          <source>There are very few scenarios where element replacement is required for the application function, the main one being reusable custom components that are used within SVG contexts (because SVG doesn't work with custom elements in the DOM tree).</source>
          <target state="translated">SVG가 컨텍스트에서 사용되는 재사용 가능한 사용자 정의 컴포넌트 인 SVG는 DOM 트리의 사용자 정의 요소와 작동하지 않기 때문에 애플리케이션 기능에 요소 교체가 필요한 시나리오는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e6b2724368909d72a2a983621849f26c6af516a" translate="yes" xml:space="preserve">
          <source>There is a special &lt;code&gt;replace&lt;/code&gt; method which can be used to tell the $location service that the next time the $location service is synced with the browser, the last history record should be replaced instead of creating a new one. This is useful when you want to implement redirection, which would otherwise break the back button (navigating back would retrigger the redirection). To change the current URL without creating a new browser history record you can call:</source>
          <target state="translated">$ location 서비스에 다음 번 $ location 서비스가 브라우저와 동기화 될 때 새 기록을 생성하는 대신 마지막 기록 레코드를 교체해야한다는 것을 알려주 는 특별한 &lt;code&gt;replace&lt;/code&gt; 방법이 있습니다. 이는 리디렉션을 구현할 때 유용합니다. 그렇지 않으면 뒤로 버튼이 손상됩니다 (뒤로 이동하면 리디렉션이 다시 트리거 됨). 새 브라우저 기록 레코드를 작성하지 않고 현재 URL을 변경하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ad79f1d43f88c0ade864387a26e37d58a6049c9d" translate="yes" xml:space="preserve">
          <source>There is also a button that calls &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;$setViewValue&lt;/a&gt; directly with a &quot;custom&quot; event. Since &quot;custom&quot; is not defined in the &lt;code&gt;updateOn&lt;/code&gt; list, it is considered a &quot;default&quot; event and will update the control if &quot;default&quot; is defined in &lt;code&gt;updateOn&lt;/code&gt;, and will receive the &quot;default&quot; debounce value. Note that this is just to illustrate how custom controls would possibly call &lt;code&gt;$setViewValue&lt;/code&gt;.</source>
          <target state="translated">&quot;custom&quot;이벤트와 함께 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;$ setViewValue를&lt;/a&gt; 직접 호출하는 버튼도 있습니다 . &quot;custom&quot;은 &lt;code&gt;updateOn&lt;/code&gt; 목록에 정의되어 있지 않으므로 &quot;default&quot;이벤트로 간주되며 &lt;code&gt;updateOn&lt;/code&gt; 에 &quot;default&quot;가 정의되어 있으면 컨트롤을 업데이트 하고 &quot;default&quot;디 바운스 값을받습니다. 이것은 사용자 지정 컨트롤이 &lt;code&gt;$setViewValue&lt;/code&gt; 호출하는 방법을 보여주기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="36ecab9037408b71383cabd20abb76e35492f942" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it works for every directive, because interpolation itself is a directive. If another directive accesses attribute data before interpolation has run, it will get the raw interpolation markup and not data.</source>
          <target state="translated">보간 자체가 지시문이므로 모든 지시문에 대해 작동한다고 보장 할 수 없습니다. 보간이 실행되기 전에 다른 지시문이 속성 데이터에 액세스하면 데이터가 아닌 원시 보간 마크 업이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4803d73431676005c82886122ad66c28a6c074d3" translate="yes" xml:space="preserve">
          <source>There is one exception: Links that only contain a hash fragment (e.g. &lt;code&gt;&amp;lt;a href=&quot;#target&quot;&amp;gt;&lt;/code&gt;) will only change &lt;code&gt;$location.hash()&lt;/code&gt; and not modify the url otherwise. This is useful for scrolling to anchors on the same page without needing to know on which page the user currently is.</source>
          <target state="translated">한 가지 예외가 있습니다. 해시 조각 만 포함 된 링크 (예 : &lt;code&gt;&amp;lt;a href=&quot;#target&quot;&amp;gt;&lt;/code&gt; )는 &lt;code&gt;$location.hash()&lt;/code&gt; 만 변경 하고 그렇지 않으면 URL을 수정하지 않습니다. 사용자가 현재 어느 페이지인지 알 필요없이 동일한 페이지에서 앵커로 스크롤 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2027737bb7068a96f000d4d33b193fa46fdcc492" translate="yes" xml:space="preserve">
          <source>There is only one instance of this type in a Component Router application injectable as the &lt;a href=&quot;../service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt; service. This &lt;strong&gt;Router&lt;/strong&gt; is associate with the &lt;strong&gt;Top Level Component&lt;/strong&gt; (&lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;). It acts as the connection between the &lt;strong&gt;Routers&lt;/strong&gt; and the &lt;strong&gt;Location&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;../service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; 서비스 로 주입 가능한 컴포넌트 라우터 애플리케이션에는이 유형의 인스턴스가 하나만 있습니다 . 이 &lt;strong&gt;라우터&lt;/strong&gt; 는 &lt;strong&gt;최상위 구성 요소&lt;/strong&gt; ( &lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; ) 와 연관됩니다 . &lt;strong&gt;라우터&lt;/strong&gt; 와 &lt;strong&gt;위치&lt;/strong&gt; 간의 연결 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="72de6f193fb85300105ca6265046e6df92fea694" translate="yes" xml:space="preserve">
          <source>There was an error loading this resource. Please try again later.</source>
          <target state="translated">이 리소스를로드하는 중에 오류가 발생했습니다. 나중에 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3eda2078fc3d76325ba60baef00e4fc07ad7239d" translate="yes" xml:space="preserve">
          <source>Therefore the above can be simplified as:</source>
          <target state="translated">따라서 위와 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02108554d592d8fbabf9029cd9d2d981395f0bae" translate="yes" xml:space="preserve">
          <source>Therefore the final directive definition looks something like this:</source>
          <target state="translated">따라서 최종 지시문 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd132ceaead68d5aa4334853896ecc475000f044" translate="yes" xml:space="preserve">
          <source>Therefore, animations can be applied to an element using this temporary class directly via CSS.</source>
          <target state="translated">따라서이 임시 클래스를 사용하여 CSS를 통해 직접 애니메이션을 요소에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76f4192528514d19abc24671684646a83898011" translate="yes" xml:space="preserve">
          <source>Therefore, the CSS code for the inner messages looks like so:</source>
          <target state="translated">따라서 내부 메시지의 CSS 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="258dce51948dfa8d6b97e686c254e38bdd7527fc" translate="yes" xml:space="preserve">
          <source>These are the types of AngularJS elements and attributes you can use:</source>
          <target state="translated">다음은 사용할 수있는 AngularJS 요소 및 속성 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b4f66b8b15edc1f5323a3f2fe41e4c47e2e5caa0" translate="yes" xml:space="preserve">
          <source>These directives take an expression inside the attribute, and set the corresponding boolean attribute to true when the expression evaluates to truthy.</source>
          <target state="translated">이러한 지시문은 속성 내부에서 표현식을 가져 와서 표현식이 진실로 평가 될 때 해당 부울 속성을 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0914ebf2d4a4b0b0e72a29f4b227f8a9a21e62e7" translate="yes" xml:space="preserve">
          <source>These restrictions can all be combined as needed:</source>
          <target state="translated">이러한 제한은 모두 필요에 따라 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1cc4346d96d189e151b816986a2f69e722fafcd" translate="yes" xml:space="preserve">
          <source>These service factories are ordered by request, i.e. they are applied in the same order as the array, on request, but reverse order, on response.</source>
          <target state="translated">이러한 서비스 팩토리는 요청에 따라 주문됩니다. 즉, 요청시 어레이와 동일한 순서로 적용되지만 응답시 역순으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="86ea12079184e49e6888fb5f8e9bf4a333312277" translate="yes" xml:space="preserve">
          <source>They can be used in view templates, controllers or services. AngularJS comes with a collection of &lt;a href=&quot;../filter&quot;&gt;built-in filters&lt;/a&gt;, but it is easy to define your own as well.</source>
          <target state="translated">뷰 템플릿, 컨트롤러 또는 서비스에서 사용할 수 있습니다. AngularJS에는 &lt;a href=&quot;../filter&quot;&gt;내장 필터&lt;/a&gt; 모음이 포함되어 있지만 자신 만의 필터를 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4824221375d3ce9b6f04cd13e1f0c90e7b5aac9d" translate="yes" xml:space="preserve">
          <source>Things to keep in mind</source>
          <target state="translated">명심해야 할 것들</target>
        </trans-unit>
        <trans-unit id="ab45627ffd28ba0b37493f184de9a27c3fad2e12" translate="yes" xml:space="preserve">
          <source>Things to notice in the example above:</source>
          <target state="translated">위 예에서 유의할 사항 :</target>
        </trans-unit>
        <trans-unit id="4d9616f497178549a1ceba85134b191dff85dc0a" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../api/ng/type/angular.module#decorator.html&quot;&gt;function&lt;/a&gt; is the same as the &lt;code&gt;$provide.decorator&lt;/code&gt; function except it is exposed through the module API. This allows you to separate your decorator patterns from your module config blocks.</source>
          <target state="translated">이 &lt;a href=&quot;../api/ng/type/angular.module#decorator.html&quot;&gt;함수&lt;/a&gt; 는 모듈 API를 통해 노출된다는 점을 제외하고 &lt;code&gt;$provide.decorator&lt;/code&gt; 함수와 동일합니다. 이를 통해 데코레이터 패턴을 모듈 구성 블록에서 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d2df585301cdbd155523396bd3c907ba55115f87" translate="yes" xml:space="preserve">
          <source>This allows to easily create arbitrarily complex rules for filtering animations, such as allowing specific events only, or enabling animations on specific subtrees of the DOM, etc. Filtering animations can also boost performance for low-powered devices, as well as applications containing a lot of structural operations.</source>
          <target state="translated">이를 통해 특정 이벤트 만 허용하거나 DOM의 특정 하위 트리에서 애니메이션을 활성화하는 등 애니메이션 필터링을위한 임의의 복잡한 규칙을 쉽게 만들 수 있습니다. 애니메이션 필터링은 저전력 장치 및 로트가 많은 애플리케이션의 성능을 향상시킬 수도 있습니다 구조 작업.</target>
        </trans-unit>
        <trans-unit id="62506bcdde04f9729f5e76db6021ecd55a120d85" translate="yes" xml:space="preserve">
          <source>This allows us to extend the above example with these features:</source>
          <target state="translated">이를 통해 위의 예제를 다음 기능으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b868a8a849cb543857bdf88802803ebaca814e1" translate="yes" xml:space="preserve">
          <source>This also applies to the &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;expect&lt;/code&gt; shortcut methods.</source>
          <target state="translated">이는 &lt;code&gt;when&lt;/code&gt; 및 &lt;code&gt;expect&lt;/code&gt; 바로 가기 방법 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e5d6967a2a93dd0eac33db309a1c3df407c1b33" translate="yes" xml:space="preserve">
          <source>This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation, applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with &lt;code&gt;$animateCss&lt;/code&gt;. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order to provide a working animation that will run in CSS.</source>
          <target state="translated">이는 클래스 추가, 클래스 제거, 스타일 설정, 동적으로 키 프레임 애니메이션 설정, 하드 코딩 된 지속 시간 또는 지연 값 적용, 애니메이션 변경 또는 스 태거 애니메이션 적용의 모든 조합이 &lt;code&gt;$animateCss&lt;/code&gt; 와 함께 작동하는 모든 옵션을 의미합니다 . 이 서비스 자체는 옵션 조합을 파악하고 CSS에서 실행될 작동 애니메이션을 제공하기 위해 요소 스타일 속성을 검사 할 수있을 정도로 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="9b79236b9af035a359b621e03d1e7e1f5da1644b" translate="yes" xml:space="preserve">
          <source>This applies both to the &lt;a href=&quot;../directive/nginclude&quot;&gt;&lt;code&gt;ng-include&lt;/code&gt;&lt;/a&gt; directive as well as &lt;code&gt;templateUrl&lt;/code&gt;'s specified by &lt;a href=&quot;../../../guide/directive&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../directive/nginclude&quot;&gt; &lt;code&gt;ng-include&lt;/code&gt; &lt;/a&gt; 지시문과 &lt;a href=&quot;../../../guide/directive&quot;&gt;지시문에&lt;/a&gt; 지정된 &lt;code&gt;templateUrl&lt;/code&gt; 모두에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="58dd13a809bb64e55c8c52e976d75660f7dabd26" translate="yes" xml:space="preserve">
          <source>This behavior makes sense for a directive that wraps some content, because otherwise you'd have to pass in each model you wanted to use separately. If you have to pass in each model that you want to use, then you can't really have arbitrary contents, can you?</source>
          <target state="translated">이 동작은 일부 내용을 래핑하는 지시문에 적합합니다. 그렇지 않으면 별도로 사용하려는 각 모델을 전달해야하기 때문입니다. 사용하려는 각 모델을 전달 해야하는 경우 실제로 임의의 내용을 가질 수는 없습니까?</target>
        </trans-unit>
        <trans-unit id="1a337bc5cc0b991a707d4b759d185330407dbe1c" translate="yes" xml:space="preserve">
          <source>This can be set explicitly by calling $sce.trustAs(type, value) on the value that is trusted before passing it to the &lt;code&gt;ng-prop-*&lt;/code&gt; directive. There are exist shorthand methods for each context type in the form of &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;$sce.trustAsResourceUrl()&lt;/a&gt; et al.</source>
          <target state="translated">&lt;code&gt;ng-prop-*&lt;/code&gt; 지시문에 전달하기 전에 신뢰할 수있는 값에서 $ sce.trustAs (type, value)를 호출하여 명시 적으로 설정할 수 있습니다 . &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;$ sce.trustAsResourceUrl ()&lt;/a&gt; 등 의 형식으로 각 컨텍스트 유형에 대한 속기 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a642393bdc5a3f60fc505ec099d289ef977421cd" translate="yes" xml:space="preserve">
          <source>This can be used to optimize your application when you know that running those watchers is redundant.</source>
          <target state="translated">이는 감시자를 실행하는 것이 중복됨을 알고있을 때 응용 프로그램을 최적화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5484a478821be02a7e449725201e87872e9c0d6b" translate="yes" xml:space="preserve">
          <source>This can be used to queue up multiple expressions which need to be evaluated in the same digest.</source>
          <target state="translated">동일한 다이제스트에서 평가해야하는 여러 식을 대기열에 넣는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eafa978f765a5d0f54a51aca4a5c7f591b5982c5" translate="yes" xml:space="preserve">
          <source>This can cause unpredictable behavior, e.g. &lt;code&gt;ngClick&lt;/code&gt; or other event handlers will be attached again. It can also degrade performance, as watchers for text interpolation are added twice to the scope.</source>
          <target state="translated">&lt;code&gt;ngClick&lt;/code&gt; 또는 다른 이벤트 처리기가 다시 연결되는 등 예기치 않은 동작이 발생할 수 있습니다 . 텍스트 보간 감시자가 범위에 두 번 추가되므로 성능이 저하 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31737a8a0cfe19e93889da90104baa99509af66f" translate="yes" xml:space="preserve">
          <source>This change can be prevented by calling &lt;code&gt;preventDefault&lt;/code&gt; method of the event. See &lt;a href=&quot;../type/%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; for more details about event object. Upon successful change &lt;a href=&quot;%24location#%24locationChangeSuccess.html&quot;&gt;$locationChangeSuccess&lt;/a&gt; is fired.</source>
          <target state="translated">이 변경은 &lt;code&gt;preventDefault&lt;/code&gt; 메소드를 호출하여 방지 할 수 있습니다 . 참조 &lt;a href=&quot;../type/%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 이벤트 객체에 대한 자세한 내용은. 변경에 성공하면 &lt;a href=&quot;%24location#%24locationChangeSuccess.html&quot;&gt;$ locationChangeSuccess&lt;/a&gt; 가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="deaca4d4f1715e3cb81009a0b59af1557a02ca34" translate="yes" xml:space="preserve">
          <source>This continues until all module dependencies has been resolved.</source>
          <target state="translated">이것은 모든 모듈 종속성이 해결 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="0fdd710f9dc596720a9478bac918072a2e288c46" translate="yes" xml:space="preserve">
          <source>This directive allows you to modify the behaviour of &lt;a href=&quot;directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives within your application. You can specify an &lt;code&gt;ngModelOptions&lt;/code&gt; directive on any element. All &lt;a href=&quot;directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives will use the options of their nearest &lt;code&gt;ngModelOptions&lt;/code&gt; ancestor.</source>
          <target state="translated">이 지시문을 사용하면 응용 프로그램 내에서 &lt;a href=&quot;directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 지시문 의 동작을 수정할 수 있습니다 . 모든 요소에 &lt;code&gt;ngModelOptions&lt;/code&gt; 지시문을 지정할 수 있습니다 . 모든 &lt;a href=&quot;directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 지시문은 가장 가까운 &lt;code&gt;ngModelOptions&lt;/code&gt; 조상 의 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ac964e329bac06459a562f99c7acc0f4d9f8bc69" translate="yes" xml:space="preserve">
          <source>This directive allows you to modify the behaviour of &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives within your application. You can specify an &lt;code&gt;ngModelOptions&lt;/code&gt; directive on any element. All &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; directives will use the options of their nearest &lt;code&gt;ngModelOptions&lt;/code&gt; ancestor.</source>
          <target state="translated">이 지시문을 사용하면 응용 프로그램 내에서 &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 지시문 의 동작을 수정할 수 있습니다 . 모든 요소에 &lt;code&gt;ngModelOptions&lt;/code&gt; 지시문을 지정할 수 있습니다 . 모든 &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 지시문은 가장 가까운 &lt;code&gt;ngModelOptions&lt;/code&gt; 조상 의 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7965d373726e20c973548077757bfccc70ce0246" translate="yes" xml:space="preserve">
          <source>This directive can be abused to add unnecessary amounts of logic into your templates. There are only a few appropriate uses of &lt;code&gt;ngInit&lt;/code&gt;:</source>
          <target state="translated">이 지시문은 남은 템플릿에 불필요한 양의 논리를 추가하기 위해 남용 될 수 있습니다. &lt;code&gt;ngInit&lt;/code&gt; 의 적절한 사용법은 몇 가지 뿐입니다 .</target>
        </trans-unit>
        <trans-unit id="cbcba47b501b44e1b242996ce2f2fcb658bdde02" translate="yes" xml:space="preserve">
          <source>This directive can be applied only within the scope of an &lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat&lt;/a&gt;.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; 범위 내에서만 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eed1d5dab4e2a48debbd34ee6dd14a061b9c554b" translate="yes" xml:space="preserve">
          <source>This directive can be used as &lt;a href=&quot;../service/%24compile#-multielement-.html&quot;&gt;multiElement&lt;/a&gt;</source>
          <target state="translated">이 지시어는 &lt;a href=&quot;../service/%24compile#-multielement-.html&quot;&gt;multiElement&lt;/a&gt; 로 사용될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="408d771ebedb5301b2e1e5d11014f21ad0ac991f" translate="yes" xml:space="preserve">
          <source>This directive creates new scope.</source>
          <target state="translated">이 지시문은 새로운 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b9eb9dfc0b36b5fb31bc5f06b2291cbce4731e8e" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level -400.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 -400에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="11bb46f7885f2d0fb62afc45043a006f99b5c779" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 0.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 0에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ba1fba935acedd5a393ae9e732b4ecad2e9ba52a" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 1에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="57fa09288f6c223f6b042c6fed89bc149865df0e" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 10.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 10에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="20282e77f198233dc571257734f9c2d2da4f5aef" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 100.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 100에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="83a14caae6f6310a1c64fde8d891125d5595d161" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1000.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 1000에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9042e7730b88dc8812901abaa43a978bb9618917" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 1200.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 1200에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1b9ad97e1cbe1b2045ab90cbbde8cfbd6f81734f" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 400 restrict: AE.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 400 제한에서 실행됩니다. AE.</target>
        </trans-unit>
        <trans-unit id="35ed58116dc2b01b349cc12677bcd3280b0cd2dd" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 400.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 400에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b6c8d120968e554de79c9923d45c2f7f16a1758c" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 450.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 450에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa13b7c0c442d44e8f33979384eb48bd2e2e8df" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 500.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 500에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7df93f519af67379f099a16f4ead3293cda924b8" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 600.</source>
          <target state="translated">이 지시문은 우선 순위 수준 600에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d60b4c0c247cba5c4a5f6b245e42416ae3e44c71" translate="yes" xml:space="preserve">
          <source>This directive executes at priority level 99.</source>
          <target state="translated">이 지시문은 우선 순위 레벨 99에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="749a139249322e3a0fa2d9fc94fa82bcb541e03b" translate="yes" xml:space="preserve">
          <source>This directive is used as a tag &lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt;. It replaces the entire tag with the template &lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt;. Now we are going to write a jasmine unit test to verify this functionality. Note that the expression &lt;code&gt;{{1 + 1}}&lt;/code&gt; times will also be evaluated in the rendered content.</source>
          <target state="translated">이 지시어는 &lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt; 태그로 사용됩니다 . 전체 태그를 &lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt; 템플릿으로 바꿉니다 . 이제이 기능을 확인하기 위해 자스민 단위 테스트를 작성할 것입니다. 렌더링 된 컨텐츠에서 &lt;code&gt;{{1 + 1}}&lt;/code&gt; 시간 표현 도 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0988891d1e4c9bf100a94a539e74ab83063f9e67" translate="yes" xml:space="preserve">
          <source>This directive sets the &lt;code&gt;disabled&lt;/code&gt; attribute on the element (typically a form control, e.g. &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; etc.) if the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; inside &lt;code&gt;ngDisabled&lt;/code&gt; evaluates to truthy.</source>
          <target state="translated">이 지시문은 &lt;code&gt;ngDisabled&lt;/code&gt; 내부 의 &lt;a href=&quot;../../../guide/expression&quot;&gt;표현식&lt;/a&gt; 이 진실로 평가되는 경우 요소 의 &lt;code&gt;disabled&lt;/code&gt; 속성 (일반적으로 양식 컨트롤 (예 : &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;button&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; 등))을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c070fd68811002fede70f580a5780cdfa9a578c2" translate="yes" xml:space="preserve">
          <source>This directive sets the &lt;code&gt;disabled&lt;/code&gt; attribute on the element (typically a form control, e.g. &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; etc.) if the &lt;a href=&quot;../../guide/expression&quot;&gt;expression&lt;/a&gt; inside &lt;code&gt;ngDisabled&lt;/code&gt; evaluates to truthy.</source>
          <target state="translated">이 지시문은 &lt;code&gt;ngDisabled&lt;/code&gt; 내부 의 &lt;a href=&quot;../../guide/expression&quot;&gt;표현식&lt;/a&gt; 이 진실로 평가되는 경우 요소 의 &lt;code&gt;disabled&lt;/code&gt; 속성 (일반적으로 양식 컨트롤 (예 : &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;button&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; 등))을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e956b460cca90e672670086cda8aabd21f1997" translate="yes" xml:space="preserve">
          <source>This document explains some of AngularJS's security features and best practices that you should keep in mind as you build your application.</source>
          <target state="translated">이 문서는 애플리케이션을 빌드 할 때 명심해야 할 AngularJS의 보안 기능과 모범 사례에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="637bbb3be2c198a8a65ee2584634b52d3430c20e" translate="yes" xml:space="preserve">
          <source>This document explains when you'd want to create your own directives in your AngularJS app, and how to implement them.</source>
          <target state="translated">이 문서는 AngularJS 앱에서 자신의 지시문을 만들고 싶을 때와 그 구현 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba8f1e4ba7e8dbd333bd05bd1a50c7b95a9e90fd" translate="yes" xml:space="preserve">
          <source>This enables web-servers to prevent script injection attacks and defacing attacks, to some degree, while also enabling code examples to work without relying on the &lt;a href=&quot;../directive/ngnonbindable&quot;&gt;ngNonBindable&lt;/a&gt; directive.</source>
          <target state="translated">이를 통해 웹 서버는 스크립트 삽입 공격 및 공격의 공격을 어느 정도 방지 할 수 있으며 &lt;a href=&quot;../directive/ngnonbindable&quot;&gt;ngNonBindable&lt;/a&gt; 지시문 에 의존하지 않고 코드 예제가 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="076b9997e5dd41c8b9220b76be3ac831b79b0b74" translate="yes" xml:space="preserve">
          <source>This error is harmless but annoying. To prevent the error from showing up, put the &lt;code&gt;ngCsp&lt;/code&gt; directive on an element of the HTML document that appears before the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that loads the &lt;code&gt;angular.js&lt;/code&gt; file.</source>
          <target state="translated">이 오류는 무해하지만 성가시다. 오류가 표시되지 않도록하려면 &lt;code&gt;angular.js&lt;/code&gt; 파일 을로드하는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 앞에 나타나는 HTML 문서의 요소에 &lt;code&gt;ngCsp&lt;/code&gt; 지시문을 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="0f6664d3c705a07b165dfd285730cd6fb277477c" translate="yes" xml:space="preserve">
          <source>This example demonstrates basic transclusion of content into a component directive.</source>
          <target state="translated">이 예제는 컨텐츠를 컴포넌트 지시문으로 기본적으로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1f9ed6e6472967fa32c46a4975e28dfb3de3211f" translate="yes" xml:space="preserve">
          <source>This example demonstrates the &quot;attach to &lt;code&gt;$scope&lt;/code&gt;&quot; style of controller.</source>
          <target state="translated">이 예제는 &quot;attach to &lt;code&gt;$scope&lt;/code&gt; &quot;스타일의 컨트롤러 를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="28190992499c1193b7ef8ed135006e6081be0f60" translate="yes" xml:space="preserve">
          <source>This example demonstrates the &lt;code&gt;controller as&lt;/code&gt; syntax.</source>
          <target state="translated">이 예제는 &lt;code&gt;controller as&lt;/code&gt; 구문으로 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="62ca703b8851a5d6363ffcdd5aa7392a42b74357" translate="yes" xml:space="preserve">
          <source>This example demonstrates using multi-slot transclusion in a component directive.</source>
          <target state="translated">이 예제는 구성 요소 지시문에서 다중 슬롯 변환을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54d4f92cb5daaa1c9a5ccf8ff554cfa4e0608d51" translate="yes" xml:space="preserve">
          <source>This example illustrates scopes in application, and prototypical inheritance of properties. The example is followed by a diagram depicting the scope boundaries.</source>
          <target state="translated">이 예제는 응용 프로그램의 범위와 속성의 프로토 타입 상속을 보여줍니다. 예제 다음에는 범위 경계를 나타내는 다이어그램이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="964cf011bd5b116e12f4ea04fcf7924afb7cb764" translate="yes" xml:space="preserve">
          <source>This example sets a custom error &quot;unknownValue&quot; on the ngModelController when the select element's unknown option is selected, i.e. when the model is set to a value that is not matched by any option.</source>
          <target state="translated">이 예제는 select 요소의 알 수없는 옵션이 선택된 경우, 즉 모델이 옵션과 일치하지 않는 값으로 설정된 경우 ngModelController에서 사용자 정의 오류 &quot;unknownValue&quot;를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2d1c53bde144ac2b71271ea09e4914b32aa2f17e" translate="yes" xml:space="preserve">
          <source>This example show how you might use &lt;code&gt;$doCheck&lt;/code&gt; to trigger changes in your component's inputs even if the actual identity of the component doesn't change. (Be aware that cloning and deep equality checks on large arrays or objects can have a negative impact on your application performance)</source>
          <target state="translated">이 예제는 컴포넌트의 실제 ID가 변경되지 않더라도 &lt;code&gt;$doCheck&lt;/code&gt; 를 사용 하여 컴포넌트의 입력에서 변경 사항을 트리거 하는 방법을 보여줍니다 . (대형 배열 또는 객체에 대한 복제 및 동일 동등 검사는 응용 프로그램 성능에 부정적인 영향을 줄 수 있음에 유의하십시오)</target>
        </trans-unit>
        <trans-unit id="5ae8a0234d80385adab6edf6c69b9755596e3742" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;ngRef&lt;/code&gt; works with child scopes. The &lt;code&gt;ngRepeat&lt;/code&gt;-ed &lt;code&gt;myWrapper&lt;/code&gt; components are assigned to the scope of &lt;code&gt;myRoot&lt;/code&gt;, because the &lt;code&gt;toggles&lt;/code&gt; property has been initialized. The repeated &lt;code&gt;myToggle&lt;/code&gt; components are published to the child scopes created by &lt;code&gt;ngRepeat&lt;/code&gt;. &lt;code&gt;ngIf&lt;/code&gt; behaves similarly - the assignment of &lt;code&gt;myToggle&lt;/code&gt; happens in the &lt;code&gt;ngIf&lt;/code&gt; child scope, because the target property has not been initialized on the &lt;code&gt;myRoot&lt;/code&gt; component controller.</source>
          <target state="translated">이 예제는 &lt;code&gt;ngRef&lt;/code&gt; 가 하위 범위와 작동 하는 방식을 보여줍니다 . &lt;code&gt;ngRepeat&lt;/code&gt; 는 -ed &lt;code&gt;myWrapper&lt;/code&gt; 구성 요소의 영역에 할당 &lt;code&gt;myRoot&lt;/code&gt; 때문에, &lt;code&gt;toggles&lt;/code&gt; 재산권 초기화되었다. 반복되는 &lt;code&gt;myToggle&lt;/code&gt; 구성 요소는 &lt;code&gt;ngRepeat&lt;/code&gt; 에 의해 생성 된 자식 범위에 게시됩니다 . &lt;code&gt;ngIf&lt;/code&gt; 가 유사하게 동작- 대상 속성이 &lt;code&gt;myRoot&lt;/code&gt; 구성 요소 컨트롤러 에서 초기화되지 않았기 때문에 &lt;code&gt;myToggle&lt;/code&gt; 이 &lt;code&gt;ngIf&lt;/code&gt; 자식 범위 에서 할당 됩니다.</target>
        </trans-unit>
        <trans-unit id="ee14ef2d78087f730132d6249684daaf02439508" translate="yes" xml:space="preserve">
          <source>This example shows how changing the URL hash causes the &lt;code&gt;$route&lt;/code&gt; to match a route against the URL, and the &lt;code&gt;ngView&lt;/code&gt; pulls in the partial.</source>
          <target state="translated">이 예제는 URL 해시를 변경하여 &lt;code&gt;$route&lt;/code&gt; 가 URL과 경로 를 일치시키고 &lt;code&gt;ngView&lt;/code&gt; 가 부분을 가져 오는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9f4785f3aeb8fb8df8ff217d8f7532f2381938df" translate="yes" xml:space="preserve">
          <source>This example shows how the &quot;plural&quot; keyword is used to account for a variable number of entities. The &quot;#&quot; variable holds the current number and can be embedded in the message.</source>
          <target state="translated">이 예는 &quot;복수&quot;키워드를 사용하여 가변 개수의 엔티티를 설명하는 방법을 보여줍니다. &quot;#&quot;변수는 현재 번호를 보유하며 메시지에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55cb6ec0ca6093526d7c62828c0edb1a5287a8f" translate="yes" xml:space="preserve">
          <source>This example shows how the controller of the component toggle is reused in the template through the scope to use its logic.</source>
          <target state="translated">이 예제는 컴포넌트 토글의 컨트롤러가 스코프를 통해 템플리트에서 해당 로직을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="69e881047eb340059e7a5c610f077c2d20a3c79a" translate="yes" xml:space="preserve">
          <source>This example shows how to apply the &lt;code&gt;ngCsp&lt;/code&gt; directive to the &lt;code&gt;html&lt;/code&gt; tag.</source>
          <target state="translated">이 예제는 &lt;code&gt;ngCsp&lt;/code&gt; 지시문을 &lt;code&gt;html&lt;/code&gt; 태그 에 적용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ed56fc3aaeb01e292a55fc62f95abc22c84a204a" translate="yes" xml:space="preserve">
          <source>This example shows how to debounce model changes. Model will be updated only 250 milliseconds after last change.</source>
          <target state="translated">이 예제는 모델 변경 사항을 디 바운스하는 방법을 보여줍니다. 모델은 마지막 변경 후 250 밀리 초 만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="dc222f9782b698d44e5acc2eade213e958921a1d" translate="yes" xml:space="preserve">
          <source>This example shows how to force jqLite using the &lt;code&gt;ngJq&lt;/code&gt; directive to the &lt;code&gt;html&lt;/code&gt; tag.</source>
          <target state="translated">이 예제는 &lt;code&gt;ngJq&lt;/code&gt; 지시문을 사용하여 jqLite 를 &lt;code&gt;html&lt;/code&gt; 태그 에 강제로 적용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="29ee8b3617765a9363a9be166a628c4aca7bac28" translate="yes" xml:space="preserve">
          <source>This example shows how to use &lt;code&gt;NgModelController&lt;/code&gt; with a custom control to achieve data-binding. Notice how different directives (&lt;code&gt;contenteditable&lt;/code&gt;, &lt;code&gt;ng-model&lt;/code&gt;, and &lt;code&gt;required&lt;/code&gt;) collaborate together to achieve the desired result.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;NgModelController&lt;/code&gt; 를 사용자 지정 컨트롤과 함께 사용 하여 데이터 바인딩을 수행하는 방법을 보여줍니다 . 원하는 결과를 얻기 위해 서로 다른 지시문 ( &lt;code&gt;contenteditable&lt;/code&gt; , &lt;code&gt;ng-model&lt;/code&gt; 및 &lt;code&gt;required&lt;/code&gt; )이 어떻게 협력하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="61fd9907007de818b0a51eb35a082e1bfacde0e8" translate="yes" xml:space="preserve">
          <source>This example shows how to use &lt;code&gt;NgTransclude&lt;/code&gt; with fallback content, that is displayed if no transcluded content is provided.</source>
          <target state="translated">이 예제는 대체 컨텐츠가 제공되지 않은 경우 표시되는 대체 컨텐츠와 함께 &lt;code&gt;NgTransclude&lt;/code&gt; 를 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e6557ff22ab6eb5f2546a30b5f46c79ffc013794" translate="yes" xml:space="preserve">
          <source>This example shows how to use a jQuery based library of a different name. The library name must be available at the top most 'window'.</source>
          <target state="translated">이 예제는 다른 이름의 jQuery 기반 라이브러리를 사용하는 방법을 보여줍니다. 라이브러리 이름은 최상위 '창'에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc1e70306fccb4e924402e50a8c62fd84c5d7bf" translate="yes" xml:space="preserve">
          <source>This example shows how we can replace the $log service with our own to display log messages.</source>
          <target state="translated">이 예는 $ log 서비스를 자체 로그 서비스로 대체하여 로그 메시지를 표시하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="98d3805b27d8a26b73944c9f271d3372cd57cd4f" translate="yes" xml:space="preserve">
          <source>This example shows how you can check for mutations to a Date object even though the identity of the object has not changed.</source>
          <target state="translated">이 예제에서는 개체의 ID가 변경되지 않은 경우에도 Date 개체의 돌연변이를 확인하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="85cde9bfa8ac1bdf2bd3651b32a94cf481a55c6e" translate="yes" xml:space="preserve">
          <source>This example shows how you can specify gender rules for specific plural matches - in this case, =1 is special cased for gender.</source>
          <target state="translated">이 예는 특정 복수 경기에 대해 성별 규칙을 지정하는 방법을 보여줍니다.이 경우 성별에 특별한 경우 = 1이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9749a4623a260025246f8b93aa5465ed0e4db5e8" translate="yes" xml:space="preserve">
          <source>This example shows the recommended path for integrating AngularJS with what we call automatic initialization.</source>
          <target state="translated">이 예제는 AngularJS를 자동 초기화라고 부르는 권장 경로를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="16aad3f4a7cb6d7e3f26212344ec18cf12df0870" translate="yes" xml:space="preserve">
          <source>This example shows the relationship between &quot;default&quot; update events and additional &lt;code&gt;updateOn&lt;/code&gt; triggers.</source>
          <target state="translated">이 예는 &quot;기본&quot;업데이트 이벤트와 추가 &lt;code&gt;updateOn&lt;/code&gt; 트리거 간의 관계를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5a8998cc45e803c5f7423eaa2a721c7a2920c113" translate="yes" xml:space="preserve">
          <source>This example shows various combinations of &lt;code&gt;href&lt;/code&gt;, &lt;code&gt;ng-href&lt;/code&gt; and &lt;code&gt;ng-click&lt;/code&gt; attributes in links and their different behaviors:</source>
          <target state="translated">이 예제는 링크에서 &lt;code&gt;href&lt;/code&gt; , &lt;code&gt;ng-href&lt;/code&gt; 및 &lt;code&gt;ng-click&lt;/code&gt; 속성 의 다양한 조합 과 다른 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="05ca10821b1fd973b5ab4a8e10404776b2b56f8c" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;ngRepeat&lt;/code&gt; to display a list of people. A filter is used to restrict the displayed results by name or by age. New (entering) and removed (leaving) items are animated.</source>
          <target state="translated">이 예에서는 &lt;code&gt;ngRepeat&lt;/code&gt; 를 사용 하여 사람 목록을 표시합니다. 필터는 이름 또는 연령별로 표시된 결과를 제한하는 데 사용됩니다. 새로운 (들어가기) 및 제거 된 (나가기) 항목이 애니메이션으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="69806b8ba755780069d6f6cc5178b21da806ae26" translate="yes" xml:space="preserve">
          <source>This example uses the &quot;select&quot; keyword to specify the message based on gender.</source>
          <target state="translated">이 예에서는 &quot;select&quot;키워드를 사용하여 성별을 기준으로 메시지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9d7aedeff039b8214af79d9d1aa1f2262c75c572" translate="yes" xml:space="preserve">
          <source>This feature enables tools like &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; and test runners to hook into angular's bootstrap process and sneak in more modules into the DI registry which can replace or augment DI services for the purpose of instrumentation or mocking out heavy dependencies.</source>
          <target state="translated">이 기능을 사용하면 &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; 및 테스트 러너와 같은 툴이 앵귤러의 부트 스트랩 프로세스에 연결하고 더 많은 모듈을 DI 레지스트리에 몰래 넣을 수 있습니다. DI 레지스트리는 계측을 위해 DI 서비스를 대체하거나 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02ae2a8961bbe5f114d4fe421285b2cfe5838cc" translate="yes" xml:space="preserve">
          <source>This feature is sometimes used to mix different markup languages, e.g. to wrap an AngularJS template within a Python Jinja template (or any other template language). Mixing templating languages is &lt;strong&gt;very dangerous&lt;/strong&gt;. The embedding template language will not safely escape AngularJS expressions, so any user-controlled values in the template will cause Cross Site Scripting (XSS) security bugs!</source>
          <target state="translated">이 기능은 다른 마크 업 언어를 혼합하는 데 사용됩니다 (예 : Python Jinja 템플릿 (또는 다른 템플릿 언어) 내에서 AngularJS 템플릿을 래핑하는 데 사용). 템플릿 언어를 혼합하는 것은 &lt;strong&gt;매우 위험&lt;/strong&gt; 합니다. 임베드 된 템플리트 언어는 AngularJS 표현식을 안전하게 이스케이프하지 않으므로 템플리트의 사용자 제어 값으로 인해 XSS (Cross Site Scripting) 보안 버그가 발생합니다!</target>
        </trans-unit>
        <trans-unit id="72e289eefaf5aaf4145ca3a0206a0d8bebdbb225" translate="yes" xml:space="preserve">
          <source>This feels like too much overhead</source>
          <target state="translated">오버 헤드가 너무 많은 것 같습니다</target>
        </trans-unit>
        <trans-unit id="e37ade63953d0e46c93b36ee67acdb6a7374a215" translate="yes" xml:space="preserve">
          <source>This filter is mostly useful for debugging. When using the double curly {{value}} notation the binding is automatically converted to JSON.</source>
          <target state="translated">이 필터는 주로 디버깅에 유용합니다. 이중 중괄호 {{value}} 표기법을 사용하면 바인딩이 자동으로 JSON으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="55e88b554c469156081629a31c90300b4541a621" translate="yes" xml:space="preserve">
          <source>This function can be called during the &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase of an app. It takes a filter function as the only argument, which will then be used to &quot;filter&quot; animations (based on the animated element, the event type, and the animation options). Only when the filter function returns &lt;code&gt;true&lt;/code&gt;, will the animation be performed. This allows great flexibility - you can easily create complex rules, such as allowing specific events only or enabling animations on specific subtrees of the DOM, and dynamically modify them, for example disabling animations at certain points in time or under certain circumstances.</source>
          <target state="translated">이 기능은 앱 의 &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;구성&lt;/a&gt; 단계에서 호출 할 수 있습니다 . 필터 함수를 유일한 인수로 사용하여 애니메이션 요소 (이벤트 애니메이션 요소, 이벤트 유형 및 애니메이션 옵션을 기반으로)를 &quot;필터링&quot;하는 데 사용됩니다. 필터 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때만 애니메이션이 수행됩니다. 따라서 유연성이 뛰어납니다. 특정 이벤트 만 허용하거나 DOM의 특정 하위 트리에서 애니메이션을 활성화하는 등 복잡한 규칙을 쉽게 생성하고 동적으로 수정하여 특정 시점 또는 특정 상황에서 애니메이션을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59700d24630b5cf9b8040af13c05f801039b3bd8" translate="yes" xml:space="preserve">
          <source>This function can be used to enable / disable animations in two different ways:</source>
          <target state="translated">이 기능은 두 가지 방법으로 애니메이션을 활성화 / 비활성화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c8ee3e6d86ff0ba46d68a1e4de3e4dd2d574fb" translate="yes" xml:space="preserve">
          <source>This function can be used when the &lt;code&gt;$viewValue&lt;/code&gt; or the rendered DOM value are not correctly formatted and the &lt;code&gt;$modelValue&lt;/code&gt; must be run through the &lt;code&gt;$formatters&lt;/code&gt; again.</source>
          <target state="translated">이 함수는 &lt;code&gt;$viewValue&lt;/code&gt; 또는 렌더링 된 DOM 값의 형식이 올바르지 않고 &lt;code&gt;$modelValue&lt;/code&gt; 가 &lt;code&gt;$formatters&lt;/code&gt; 통해 다시 실행되어야 할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbe05ce09a70d470f85ee4dd7a1f4dd51855e2eb" translate="yes" xml:space="preserve">
          <source>This function ensures a single injector will be used for all tests in a given describe context. This contrasts with the default behaviour where a new injector is created per test case.</source>
          <target state="translated">이 기능을 사용하면 지정된 설명 컨텍스트에서 단일 인젝터를 모든 테스트에 사용할 수 있습니다. 이것은 테스트 케이스마다 새로운 인젝터가 생성되는 기본 동작과 대조됩니다.</target>
        </trans-unit>
        <trans-unit id="874dbb62e56a0d601c13b08f260529654912b687" translate="yes" xml:space="preserve">
          <source>This function is deprecated, but will not be removed in the 1.x lifecycle. There are edge cases (see &lt;a href=&quot;angular.merge#known-issues.html&quot;&gt;known issues&lt;/a&gt;) that are not supported by this function. We suggest using another, similar library for all-purpose merging, such as &lt;a href=&quot;https://lodash.com/docs/4.17.4#merge&quot;&gt;lodash's merge()&lt;/a&gt;.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않지만 1.x 수명주기에서는 제거되지 않습니다. 이 기능이 지원하지 않는 경우 ( &lt;a href=&quot;angular.merge#known-issues.html&quot;&gt;알려진 문제&lt;/a&gt; 참조 )가 있습니다. &lt;a href=&quot;https://lodash.com/docs/4.17.4#merge&quot;&gt;lodash의 merge ()&lt;/a&gt; 와 같이 다목적 병합을 위해 다른 유사한 라이브러리를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="104e4ee7bf47164b402b647bc9d4f92d3444f4cb" translate="yes" xml:space="preserve">
          <source>This function registers a module configuration code. It collects the configuration information which will be used when the injector is created by &lt;a href=&quot;angular.mock.inject&quot;&gt;inject&lt;/a&gt;.</source>
          <target state="translated">이 기능은 모듈 구성 코드를 등록합니다. 인젝터가 &lt;a href=&quot;angular.mock.inject&quot;&gt;inject&lt;/a&gt; 로 작성 될 때 사용될 구성 정보를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="66a348d878643285a3617b02bb385a84d7bd067c" translate="yes" xml:space="preserve">
          <source>This function too can be called during the &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase of an app. It takes a regex as the only argument, which will then be matched against the classes of any element that is about to be animated. The regex allows a lot of flexibility - you can either allow animations for specific classes only (useful when you are working with 3rd party animations), or exclude specific classes from getting animated.</source>
          <target state="translated">이 기능 은 앱 의 &lt;a href=&quot;../api/ng/type/angular.module#config.html&quot;&gt;구성&lt;/a&gt; 단계에서 호출 할 수도 있습니다 . 정규 표현식을 유일한 인수로 사용하여 애니메이션을 적용하려는 모든 요소의 클래스와 일치시킵니다. 정규식은 많은 유연성을 허용합니다. 특정 클래스에 대해서만 애니메이션을 허용하거나 (타사 애니메이션을 사용할 때 유용) 특정 클래스에 애니메이션을 적용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c159109652872117256320d96144b40d035fe7a8" translate="yes" xml:space="preserve">
          <source>This function will be invoked when the service needs to be instantiated and should return the decorated service instance.</source>
          <target state="translated">이 기능은 서비스를 인스턴스화해야 할 때 호출되며 데코 레이팅 된 서비스 인스턴스를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a119154461db6dbbb0ee1429bb68c89f82a67750" translate="yes" xml:space="preserve">
          <source>This function will be invoked when the service needs to be provided and should return the decorated service instance. The function is called using the &lt;a href=&quot;%24injector#invoke.html&quot;&gt;injector.invoke&lt;/a&gt; method and is therefore fully injectable. Local injection arguments:</source>
          <target state="translated">이 기능은 서비스를 제공해야 할 때 호출되며 데코 레이팅 된 서비스 인스턴스를 반환해야합니다. 이 함수는 &lt;a href=&quot;%24injector#invoke.html&quot;&gt;injector.invoke&lt;/a&gt; 메소드를 사용하여 호출 되므로 완전히 삽입 가능합니다. 국소 주입 인자 :</target>
        </trans-unit>
        <trans-unit id="7ace1d7e9d12a0251168d9e9c7837973f650e71b" translate="yes" xml:space="preserve">
          <source>This function will throw if the safe type isn't appropriate for this context, or if the value given cannot be accepted in the context (which might be caused by sanitization not being available, or the value not being recognized as safe).</source>
          <target state="translated">안전 유형이이 컨텍스트에 적합하지 않거나 주어진 값을 컨텍스트에서 허용 할 수없는 경우 (위생을 사용할 수 없거나 값이 안전하지 않은 값으로 인해 발생할 수 있음)이 함수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="868f6b7d204bd6db32315fed3c1b9cdaa4a62fb2" translate="yes" xml:space="preserve">
          <source>This implementation can be used to respond with static or dynamic responses via the &lt;code&gt;when&lt;/code&gt; api and its shortcuts (&lt;code&gt;whenGET&lt;/code&gt;, &lt;code&gt;whenPOST&lt;/code&gt;, etc) and optionally pass through requests to the real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch templates from a webserver).</source>
          <target state="translated">이 구현은 &lt;code&gt;when&lt;/code&gt; api 및 해당 바로 가기 ( &lt;code&gt;whenGET&lt;/code&gt; , &lt;code&gt;whenPOST&lt;/code&gt; 등) 를 통해 정적 또는 동적 응답으로 응답 하고 선택적으로 특정 요청에 대한 실제 $ httpBackend로 요청을 전달합니다 (예 : 특정 원격 API와 상호 작용하거나 가져 오기 위해) 웹 서버에서 템플릿).</target>
        </trans-unit>
        <trans-unit id="bbf3e56350b9c22d5e436b82ecd7c89f7a51c73d" translate="yes" xml:space="preserve">
          <source>This implies that the internal state of both the form and the control is available for binding in the view using the standard binding primitives.</source>
          <target state="translated">이는 표준 바인딩 프리미티브를 사용하여 뷰에서 바인딩 할 수있는 폼과 컨트롤의 내부 상태가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6e4e2dd3c9342812b2650439b3f4dfe11726f42e" translate="yes" xml:space="preserve">
          <source>This includes the &quot;special&quot; numbers &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;+Infinity&lt;/code&gt; and &lt;code&gt;-Infinity&lt;/code&gt;.</source>
          <target state="translated">여기에는 &quot;특수&quot;숫자 &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+Infinity&lt;/code&gt; 및 &lt;code&gt;-Infinity&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="80c58f6b6a5db22c94200d23e6f5ba515e0f7db1" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt;-compliant implementation of promises/deferred objects inspired by &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal's Q&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal의 Q에서&lt;/a&gt; 영감을 얻은 약속 / 지연된 개체 의 &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;약속 / A +&lt;/a&gt; 호환 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="0dba2df7f6ddcb854fb3341d09b04f21dab2773e" translate="yes" xml:space="preserve">
          <source>This is a collection of external, 3rd party resources for learning and developing AngularJS.</source>
          <target state="translated">AngularJS를 배우고 개발하기위한 외부의 타사 리소스 모음입니다.</target>
        </trans-unit>
        <trans-unit id="21aeaba9662970643b7a9fb7ec7ea1ef8bfe63ac" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;../../ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt; 모듈이 포함 된 경우에만 사용할 수있는 전역 (창) 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="3aeed192065b716e51303fafb7933c0cc0d12aa7" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;../ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">이것은 &lt;a href=&quot;../ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt; 모듈이 포함 된 경우에만 사용할 수있는 전역 (창) 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="940be712194ff22a2b0c9f05c98206545090b459" translate="yes" xml:space="preserve">
          <source>This is a global (window) function that is only available when the &lt;a href=&quot;ngmock&quot;&gt;&lt;code&gt;ngMock&lt;/code&gt;&lt;/a&gt; module is included.</source>
          <target state="translated">이것은 &lt;a href=&quot;ngmock&quot;&gt; &lt;code&gt;ngMock&lt;/code&gt; &lt;/a&gt; 모듈이 포함 된 경우에만 사용할 수있는 전역 (창) 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="a9bc078a3179c93a01b2304ea5af8b2a3d4add3a" translate="yes" xml:space="preserve">
          <source>This is a list of (known) object types that are not handled correctly by this function:</source>
          <target state="translated">다음은이 함수에서 올바르게 처리되지 않는 알려진 객체 유형의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e8e04a228b77e4ceb9e95143b611a06958ab031c" translate="yes" xml:space="preserve">
          <source>This is a list of libraries that enhance AngularJS, add common UI components or integrate with other libraries. You can find a larger list of AngularJS external libraries at &lt;a href=&quot;http://ngmodules.org/&quot;&gt;ngmodules.org&lt;/a&gt;.</source>
          <target state="translated">AngularJS를 향상 시키거나 공통 UI 구성 요소를 추가하거나 다른 라이브러리와 통합하는 라이브러리 목록입니다. &lt;a href=&quot;http://ngmodules.org/&quot;&gt;ngmodules.org&lt;/a&gt; 에서 AngularJS 외부 라이브러리의 더 큰 목록을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b4d2f9c6398ff6489ba72736fd69aa6792f94f7" translate="yes" xml:space="preserve">
          <source>This is a non-exhaustive list of object types / features that are not handled correctly by &lt;code&gt;angular.copy&lt;/code&gt;. Note that since this functions is used by the change detection code, this means binding or watching objects of these types (or that include these types) might not work correctly.</source>
          <target state="translated">이것은 &lt;code&gt;angular.copy&lt;/code&gt; 가 올바르게 처리하지 않은 객체 유형 / 기능의 전체 목록입니다 . 이 기능은 변경 감지 코드에서 사용되므로 이러한 유형의 객체 (또는 이러한 유형을 포함하는)를 바인딩하거나 감시하면 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243531736be9806625723a16f6421de48871a398" translate="yes" xml:space="preserve">
          <source>This is a special class that can be used to prevent unwanted flickering / flash of content before the actual animation starts. The class is added as soon as an animation is initialized, but removed before the actual animation starts (after waiting for a $digest). It is also only added for &lt;em&gt;structural&lt;/em&gt; animations (&lt;code&gt;enter&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;leave&lt;/code&gt;).</source>
          <target state="translated">실제 애니메이션이 시작되기 전에 원하지 않는 내용의 깜박임 / 플래시를 방지하는 데 사용할 수있는 특수 클래스입니다. 클래스는 애니메이션이 초기화되는 즉시 추가되지만 실제 애니메이션이 시작되기 전에 제거됩니다 ($ digest를 기다린 후). 또한 &lt;em&gt;구조적&lt;/em&gt; 애니메이션 ( &lt;code&gt;enter&lt;/code&gt; , &lt;code&gt;move&lt;/code&gt; , &lt;code&gt;leave&lt;/code&gt; ) 에만 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c921d5dab3491a0ede284d2c4169c0796dd9692" translate="yes" xml:space="preserve">
          <source>This is all done behind the scenes. Notice that by having the &lt;code&gt;ng-controller&lt;/code&gt; ask the injector to instantiate the class, it can satisfy all of the dependencies of &lt;code&gt;MyController&lt;/code&gt; without the controller ever knowing about the injector.</source>
          <target state="translated">이 모든 것이 뒤에서 이루어집니다. 함으로써 통지 &lt;code&gt;ng-controller&lt;/code&gt; 클래스의 인스턴스를 인젝터를 물어, 그것은의 종속성을 모두 만족시킬 수 &lt;code&gt;MyController&lt;/code&gt; 에를 컨트롤러가 이제까지 인젝터에 대해 모른 채.</target>
        </trans-unit>
        <trans-unit id="c0c13bc636a5e20f5b33c815c14d171efa71421f" translate="yes" xml:space="preserve">
          <source>This is called when we need to determine if the value of an input is empty.</source>
          <target state="translated">입력 값이 비어 있는지 확인해야 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0705b013e2055b12840aa9f33bf1c6e01e702f6d" translate="yes" xml:space="preserve">
          <source>This is clearly not a great solution.</source>
          <target state="translated">이것은 분명히 훌륭한 해결책이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8c0b33e0f52faca414488a07a74d8d29174945ba" translate="yes" xml:space="preserve">
          <source>This is desirable, but it puts the responsibility of getting hold of the dependency on the code that constructs &lt;code&gt;SomeClass&lt;/code&gt;.</source>
          <target state="translated">이것은 바람직하지만 &lt;code&gt;SomeClass&lt;/code&gt; 를 구성하는 코드에 대한 종속성을 가져야 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e19cc504a64dbc7e5223f67be790ee5a786042e" translate="yes" xml:space="preserve">
          <source>This is followed by a list of selection keyword and corresponding message pairs. The &quot;other&quot; keyword and corresponding message are &lt;strong&gt;required&lt;/strong&gt; but you may have as few or as many of the other categories as you need.</source>
          <target state="translated">다음에는 선택 키워드 및 해당 메시지 쌍 목록이옵니다. &quot;기타&quot;키워드 및 해당 메시지가 &lt;strong&gt;필요&lt;/strong&gt; 하지만 &lt;strong&gt;필요한&lt;/strong&gt; 만큼 다른 범주가 많거나 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830044fcd0e944858b0f63daf06beb477ee3aa4f" translate="yes" xml:space="preserve">
          <source>This is followed by a list of selection keyword and corresponding message pairs. The &quot;other&quot; keyword and corresponding message are &lt;strong&gt;required&lt;/strong&gt; but you may have as few or as many of the other gender values as you need (i.e. it isn't restricted to male/female.) Note however, that the matching is &lt;strong&gt;case-sensitive&lt;/strong&gt;.</source>
          <target state="translated">다음에는 선택 키워드 및 해당 메시지 쌍 목록이옵니다. &quot;other&quot;키워드와 해당 메시지가 &lt;strong&gt;필요&lt;/strong&gt; 하지만 &lt;strong&gt;필요한&lt;/strong&gt; 만큼 다른 성별 값을 가질 수 있습니다 (즉, 남성 / 여성으로 제한되지 않음). 그러나 일치하는 &lt;strong&gt;대소 문자를 구분합니다.&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc3f10937fdf2eb5b1c0d43e9871f7899de9628" translate="yes" xml:space="preserve">
          <source>This is necessary when developing things like Google Chrome Extensions or Universal Windows Apps.</source>
          <target state="translated">이것은 Chrome 확장 프로그램 또는 Universal Windows Apps와 같은 것을 개발할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6f9743eeaff280817f27f1c2c3f8c185c14b8871" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;template&lt;/code&gt; but the template is loaded from the specified URL, asynchronously.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 과 비슷 하지만 템플릿은 지정된 URL에서 비동기 적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a22a93c5db90cc0e312d0bd6caa04b04b4c2eb" translate="yes" xml:space="preserve">
          <source>This is taken from the above example.</source>
          <target state="translated">이것은 위의 예에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cc3106a660e4677bcc273826723ac7286f55964" translate="yes" xml:space="preserve">
          <source>This is the best outcome. The application code simply declares the dependencies it needs, without having to deal with the injector. This setup does not break the Law of Demeter.</source>
          <target state="translated">이것이 가장 좋은 결과입니다. 응용 프로그램 코드는 인젝터를 다루지 않고도 필요한 종속성을 선언합니다. 이 설정은 데 미터 법칙을 위반하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42cf60690a82822d827602db3861e00f4b6e5726" translate="yes" xml:space="preserve">
          <source>This is the core version of &lt;code&gt;$animateCss&lt;/code&gt;. By default, only when the &lt;code&gt;ngAnimate&lt;/code&gt; is included, then the &lt;code&gt;$animateCss&lt;/code&gt; service will actually perform animations.</source>
          <target state="translated">&lt;code&gt;$animateCss&lt;/code&gt; 의 핵심 버전입니다 . 기본적으로 &lt;code&gt;ngAnimate&lt;/code&gt; 가 포함 된 경우에만 &lt;code&gt;$animateCss&lt;/code&gt; 서비스가 실제로 애니메이션을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8fe7c930ab124d17cccc4266216fed96a7db7677" translate="yes" xml:space="preserve">
          <source>This is the preferred way to annotate application components. This is how the examples in the documentation are written.</source>
          <target state="translated">응용 프로그램 구성 요소에 주석을 달 때 선호되는 방법입니다. 이것이 문서의 예제가 작성되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="e99173c0622fc29819acb26a64190ef25cec6946" translate="yes" xml:space="preserve">
          <source>This is the sequence that your code should follow:</source>
          <target state="translated">다음은 코드가 따라야하는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="bd952f6c2b0ab426ac04bd58194e1818a961d2b2" translate="yes" xml:space="preserve">
          <source>This is useful if a you have a default response that is overriden inside specific tests.</source>
          <target state="translated">특정 테스트 내에서 재정의 된 기본 응답이있는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="106a413d228469230b2f1ee6489f09b04a5ce051" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; comes into play. Dependency Injection (DI) is a software design pattern that deals with how objects and functions get created and how they get a hold of their dependencies. Everything within AngularJS (directives, filters, controllers, services, ...) is created and wired using dependency injection. Within AngularJS, the DI container is called the &lt;a href=&quot;di&quot;&gt;injector&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;di&quot;&gt;의존성 주입&lt;/a&gt; 이 시작 되는 곳 입니다. 의존성 주입 (DI)은 객체와 함수가 생성되는 방법과 의존성을 유지하는 방법을 다루는 소프트웨어 디자인 패턴입니다. AngularJS (디렉티브, 필터, 컨트롤러, 서비스 등) 내의 모든 것은 의존성 주입을 사용하여 생성되고 연결됩니다. AngularJS 내에서 DI 컨테이너를 &lt;a href=&quot;di&quot;&gt;인젝터&lt;/a&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="bd73e2280f08f2867f649e593661732c488f0cde" translate="yes" xml:space="preserve">
          <source>This is, however, exactly the use-case that the Service recipe is the most suitable for.</source>
          <target state="translated">그러나 이것은 서비스 레시피가 가장 적합한 유스 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="7558a0b4c85e4c406f419884da5d0524791d2c44" translate="yes" xml:space="preserve">
          <source>This looks like normal HTML, with some new markup. In AngularJS, a file like this is called a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt;. When AngularJS starts your application, it parses and processes this new markup from the template using the &lt;a href=&quot;compiler&quot;&gt;compiler&lt;/a&gt;. The loaded, transformed and rendered DOM is then called the &lt;em&gt;view&lt;/em&gt;.</source>
          <target state="translated">이것은 새로운 HTML을 가진 일반 HTML처럼 보입니다. AngularJS에서 이와 같은 파일을 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 이라고합니다 . AngularJS는 애플리케이션을 시작할 때 &lt;a href=&quot;compiler&quot;&gt;컴파일러를&lt;/a&gt; 사용하여 템플릿에서이 새로운 마크 업을 구문 분석하고 처리합니다 . 로드, 변환 및 렌더링 된 DOM을 &lt;em&gt;뷰&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="38b2e8311081c7751c2533d1619c905371007bd7" translate="yes" xml:space="preserve">
          <source>This makes it easier to write an app in a way that's similar to using Web Components or using the new Angular's style of application architecture.</source>
          <target state="translated">따라서 웹 구성 요소를 사용하거나 새로운 Angular 스타일의 응용 프로그램 아키텍처를 사용하는 것과 유사한 방식으로 응용 프로그램을보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f46c84b99f6c66daf57e614d0604305863fdee" translate="yes" xml:space="preserve">
          <source>This makes it possible for the widget to have private state for its template, while the transcluded content has access to its originating scope.</source>
          <target state="translated">이를 통해 위젯은 템플리트에 대한 개인 상태를 가질 수 있으며, 변환 된 컨텐츠는 원래 범위에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b547a3365f5455bb23472c7583140ed975d34a1" translate="yes" xml:space="preserve">
          <source>This may seem to be unexpected complexity, but it gives the widget user and developer the least surprise.</source>
          <target state="translated">이것은 예상치 못한 복잡한 것처럼 보이지만 위젯 사용자와 개발자에게 가장 놀라운 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c9d2b0a1a474c5c524a2e46ab836d1ad41fbe991" translate="yes" xml:space="preserve">
          <source>This means that any changes to the data need to be re-merged with the template and then &lt;code&gt;innerHTML&lt;/code&gt;ed into the DOM. Some of the issues with this approach are:</source>
          <target state="translated">즉, 데이터에 대한 모든 변경 사항은 템플릿과 다시 병합 된 다음 &lt;code&gt;innerHTML&lt;/code&gt; 을 DOM에 병합해야합니다 . 이 접근 방식의 일부 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3797c257375c657fdb65bc7afd3178dde6553049" translate="yes" xml:space="preserve">
          <source>This method &lt;em&gt;returns a new promise&lt;/em&gt; which is resolved or rejected via the return value of the &lt;code&gt;successCallback&lt;/code&gt;, &lt;code&gt;errorCallback&lt;/code&gt; (unless that value is a promise, in which case it is resolved with the value which is resolved in that promise using &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues&quot;&gt;promise chaining&lt;/a&gt;). It also notifies via the return value of the &lt;code&gt;notifyCallback&lt;/code&gt; method. The promise cannot be resolved or rejected from the notifyCallback method. The errorCallback and notifyCallback arguments are optional.</source>
          <target state="translated">이 메소드 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;successCallback&lt;/code&gt; , &lt;code&gt;errorCallback&lt;/code&gt; 의 반환 값을 통해 해결되거나 거부되는 &lt;em&gt;새 약속&lt;/em&gt; 을 리턴합니다 (값이 약속이 아닌 경우 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues&quot;&gt;약속 체인을&lt;/a&gt; 사용하여 해당 약속에서 해결 된 값으로 해석 됨 ). 또한 &lt;code&gt;notifyCallback&lt;/code&gt; 메소드 의 리턴 값을 통해 통지합니다 . notifyCallback 메소드에서 약속을 해결하거나 거부 할 수 없습니다. errorCallback 및 notifyCallback 인수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="dfa92648c02e81fae7a25858df34af1dba44e2d7" translate="yes" xml:space="preserve">
          <source>This method can be called to add the 'ng-dirty' class and set the form to a dirty state (ng-dirty class). This method will also propagate to parent forms.</source>
          <target state="translated">이 메소드는 'ng-dirty'클래스를 추가하고 양식을 더티 상태 (ng-dirty 클래스)로 설정하기 위해 호출 될 수 있습니다. 이 방법은 부모 양식에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b64a60d991bc92f86edf62edf6b119177e9387d" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the 'ng-touched' class and set the form controls to their untouched state (ng-untouched class).</source>
          <target state="translated">이 메소드를 호출하여 'ng-touched'클래스를 제거하고 양식 컨트롤을 터치되지 않은 상태 (ng-untouched 클래스)로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce764038d2f1e780d1e96003245444b77962bbc" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-dirty&lt;/code&gt; class and set the control to its pristine state (&lt;code&gt;ng-pristine&lt;/code&gt; class). A model is considered to be pristine when the control has not been changed from when first compiled.</source>
          <target state="translated">&lt;code&gt;ng-dirty&lt;/code&gt; 클래스 를 제거 하고 컨트롤을 원래 상태 ( &lt;code&gt;ng-pristine&lt;/code&gt; 클래스)로 설정하기 위해이 메서드를 호출 할 수 있습니다 . 컨트롤이 처음 컴파일 될 때부터 변경되지 않은 경우 모델은 원시적 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a104f18bb62aee421639fe99f1a6b3715893e9cd" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-pristine&lt;/code&gt; class and set the control to its dirty state (&lt;code&gt;ng-dirty&lt;/code&gt; class). A model is considered to be dirty when the control has been changed from when first compiled.</source>
          <target state="translated">이 메소드를 호출하여 &lt;code&gt;ng-pristine&lt;/code&gt; 클래스 를 제거 하고 컨트롤을 더티 상태 ( &lt;code&gt;ng-dirty&lt;/code&gt; 클래스)로 설정할 수 있습니다 . 처음 컴파일 할 때부터 컨트롤을 변경하면 모델이 더티 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="be236d70e3b76ac627108d742a7d930b6e5345dc" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-touched&lt;/code&gt; class and set the control to its untouched state (&lt;code&gt;ng-untouched&lt;/code&gt; class). Upon compilation, a model is set as untouched by default, however this function can be used to restore that state if the model has already been touched by the user.</source>
          <target state="translated">이 메소드를 호출하여 &lt;code&gt;ng-touched&lt;/code&gt; 클래스 를 제거 하고 제어되지 않은 상태 ( &lt;code&gt;ng-untouched&lt;/code&gt; 클래스)로 제어를 설정할 수 있습니다 . 컴파일시 기본적으로 모델은 손대지 않은 상태로 설정되지만 사용자가 모델을 이미 터치 한 경우이 기능을 사용하여 해당 상태를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d3c1d51e251c93d6c1a6dd38b04fbbfccbd791" translate="yes" xml:space="preserve">
          <source>This method can be called to remove the &lt;code&gt;ng-untouched&lt;/code&gt; class and set the control to its touched state (&lt;code&gt;ng-touched&lt;/code&gt; class). A model is considered to be touched when the user has first focused the control element and then shifted focus away from the control (blur event).</source>
          <target state="translated">터치하지 &lt;code&gt;ng-untouched&lt;/code&gt; 클래스 를 제거 하고 컨트롤을 터치 된 상태 ( &lt;code&gt;ng-touched&lt;/code&gt; 클래스)로 설정하기 위해이 메소드를 호출 할 수 있습니다 . 사용자가 제어 요소에 먼저 초점을 맞춘 다음 초점을 제어에서 멀어지게하면 모델이 터치 된 것으로 간주됩니다 (흐림 이벤트).</target>
        </trans-unit>
        <trans-unit id="039cf05d82b99db28639e2f0df0e8df9fed6d706" translate="yes" xml:space="preserve">
          <source>This method can be called within $parsers/$formatters or a custom validation implementation. However, in most cases it should be sufficient to use the &lt;code&gt;ngModel.$validators&lt;/code&gt; and &lt;code&gt;ngModel.$asyncValidators&lt;/code&gt; collections which will call &lt;code&gt;$setValidity&lt;/code&gt; automatically.</source>
          <target state="translated">이 메소드는 $ parsers / $ formatters 또는 사용자 정의 유효성 검증 구현 내에서 호출 될 수 있습니다. 그러나 대부분의 경우 &lt;code&gt;$setValidity&lt;/code&gt; 자동으로 호출 하는 &lt;code&gt;ngModel.$validators&lt;/code&gt; 및 &lt;code&gt;ngModel.$asyncValidators&lt;/code&gt; 컬렉션 을 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="2a0539f5b7dcaa5c95fe933397c2c13fa49ebc03" translate="yes" xml:space="preserve">
          <source>This method can be used to change which mocked responses &lt;code&gt;$httpBackend&lt;/code&gt; returns, when defining them with &lt;a href=&quot;%24httpbackend#when.html&quot;&gt;$httpBackend.when()&lt;/a&gt; (and shortcut methods). By default, &lt;code&gt;$httpBackend&lt;/code&gt; returns the first definition that matches. When setting &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt;, it will use the last response that matches, i.e. the one that was added last.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;%24httpbackend#when.html&quot;&gt;$ httpBackend.when ()&lt;/a&gt; 및 단축키 메소드로 정의 할 때 &lt;code&gt;$httpBackend&lt;/code&gt; 리턴하는 모의 응답을 변경하는 데 사용할 수 있습니다 . 기본적으로 &lt;code&gt;$httpBackend&lt;/code&gt; 는 일치하는 첫 번째 정의를 반환합니다. &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt; 설정하면 일치하는 마지막 응답, 즉 마지막에 추가 된 응답을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dcc61f9b44cb07452831de5334ffe49067b455e3" translate="yes" xml:space="preserve">
          <source>This method can be used to change which mocked responses &lt;code&gt;$httpBackend&lt;/code&gt; returns, when defining them with &lt;a href=&quot;../../ngmock/service/%24httpbackend#when.html&quot;&gt;$httpBackend.when()&lt;/a&gt; (and shortcut methods). By default, &lt;code&gt;$httpBackend&lt;/code&gt; returns the first definition that matches. When setting &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt;, it will use the last response that matches, i.e. the one that was added last.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../../ngmock/service/%24httpbackend#when.html&quot;&gt;$ httpBackend.when ()&lt;/a&gt; 및 단축키 메소드로 정의 할 때 &lt;code&gt;$httpBackend&lt;/code&gt; 리턴하는 모의 응답을 변경하는 데 사용할 수 있습니다 . 기본적으로 &lt;code&gt;$httpBackend&lt;/code&gt; 는 일치하는 첫 번째 정의를 반환합니다. &lt;code&gt;$http.matchLatestDefinitionEnabled(true)&lt;/code&gt; 설정하면 일치하는 마지막 응답, 즉 마지막에 추가 된 응답을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95660a3cb5771d7b45b7bbb186218a518c26a470" translate="yes" xml:space="preserve">
          <source>This method does not work with code minification / obfuscation. For this reason the following annotation strategies are supported.</source>
          <target state="translated">이 방법은 코드 축소 / 난독 처리에는 작동하지 않습니다. 이러한 이유로 다음 주석 전략이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3743c06b6e4464fc92789fb6a0e779ba20b62ec9" translate="yes" xml:space="preserve">
          <source>This method flushes all types of tasks (not only timeouts), which is unintuitive. It is recommended to use &lt;a href=&quot;%24flushpendingtasks&quot;&gt;&lt;code&gt;$flushPendingTasks&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 직관적이지 않은 모든 유형의 작업 (시간 초과뿐만 아니라)을 플러시합니다. 대신 &lt;a href=&quot;%24flushpendingtasks&quot;&gt; &lt;code&gt;$flushPendingTasks&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8360fbd33c9d5e68f4591a6c59f7a211a01b3d67" translate="yes" xml:space="preserve">
          <source>This method is called by ngModel internally when the bound scope value changes. Application developers usually do not have to call this function themselves.</source>
          <target state="translated">이 메서드는 바운드 범위 값이 변경 될 때 ngModel에 의해 내부적으로 호출됩니다. 응용 프로그램 개발자는 일반적으로이 기능을 스스로 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="111861b1f33e6ba16e0e2a46b6e09b6bdb15aa32" translate="yes" xml:space="preserve">
          <source>This method is getter / setter.</source>
          <target state="translated">이 메소드는 getter / setter입니다.</target>
        </trans-unit>
        <trans-unit id="ae01763d0e34b30b2df6b37f5dcec088ef8e5dfa" translate="yes" xml:space="preserve">
          <source>This method is getter only.</source>
          <target state="translated">이 메소드는 getter 전용입니다.</target>
        </trans-unit>
        <trans-unit id="c81e50c18dfe60ee4fd5f2abbf2491d1ef6cf978" translate="yes" xml:space="preserve">
          <source>This method is used to flush the pending callbacks and animation frames to either start an animation or conclude an animation. Note that this will not actually close an actively running animation (see &lt;a href=&quot;%24animate#closeAndFlush.html&quot;&gt;&lt;code&gt;closeAndFlush()&lt;/code&gt;&lt;/a&gt; for that).</source>
          <target state="translated">이 메소드는 보류중인 콜백 및 애니메이션 프레임을 비우고 애니메이션을 시작하거나 애니메이션을 마무리하는 데 사용됩니다. 이렇게하면 실제로 실행중인 애니메이션이 닫히지는 않습니다 ( &lt;a href=&quot;%24animate#closeAndFlush.html&quot;&gt; &lt;code&gt;closeAndFlush()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2f5be6e2442f3e5478eb9133bc83673c67fcec1" translate="yes" xml:space="preserve">
          <source>This method must be called during the &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;config&lt;/a&gt; phase. Once the &lt;code&gt;$sanitize&lt;/code&gt; service has been instantiated, this method has no effect.</source>
          <target state="translated">&lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;구성&lt;/a&gt; 단계 중에이 메소드를 호출해야합니다 . 한때 &lt;code&gt;$sanitize&lt;/code&gt; 서비스가 인스턴스화되고,이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8fcc4fc5c0078d0531686af3fc817e06fcdb9f7" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;strong&gt;shallow copy&lt;/strong&gt; of the controls that are currently part of this form. The controls can be instances of &lt;a href=&quot;form.formcontroller&quot;&gt;&lt;code&gt;FormController&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../directive/ngform&quot;&gt;&quot;child-forms&quot;&lt;/a&gt;) and of &lt;a href=&quot;ngmodel.ngmodelcontroller&quot;&gt;&lt;code&gt;NgModelController&lt;/code&gt;&lt;/a&gt;. If you need access to the controls of child-forms, you have to call &lt;code&gt;$getControls()&lt;/code&gt; recursively on them. This can be used for example to iterate over all controls to validate them.</source>
          <target state="translated">이 메서드 는 현재이 폼의 일부인 컨트롤 의 &lt;strong&gt;얕은 복사본&lt;/strong&gt; 을 반환합니다 . 컨트롤은 &lt;a href=&quot;form.formcontroller&quot;&gt; &lt;code&gt;FormController&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../directive/ngform&quot;&gt;&quot;child-forms&quot;&lt;/a&gt; ) 및 &lt;a href=&quot;ngmodel.ngmodelcontroller&quot;&gt; &lt;code&gt;NgModelController&lt;/code&gt; 의&lt;/a&gt; 인스턴스 일 수 있습니다 . 자식 폼의 컨트롤에 액세스해야하는 경우 &lt;code&gt;$getControls()&lt;/code&gt; 반복적으로 호출 해야합니다. 예를 들어 모든 컨트롤을 반복하여 유효성을 검사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb2bbddf37cf7ff14a48397a4375854d8e571a9" translate="yes" xml:space="preserve">
          <source>This method sets the form's &lt;code&gt;$pristine&lt;/code&gt; state to true, the &lt;code&gt;$dirty&lt;/code&gt; state to false, removes the &lt;code&gt;ng-dirty&lt;/code&gt; class and adds the &lt;code&gt;ng-pristine&lt;/code&gt; class. Additionally, it sets the &lt;code&gt;$submitted&lt;/code&gt; state to false.</source>
          <target state="translated">이 메소드는 양식의 &lt;code&gt;$pristine&lt;/code&gt; 상태를 true로 설정하고 &lt;code&gt;$dirty&lt;/code&gt; 상태를 false로 설정하고 &lt;code&gt;ng-dirty&lt;/code&gt; 클래스를 제거 하고 &lt;code&gt;ng-pristine&lt;/code&gt; 클래스를 추가합니다 . 또한 &lt;code&gt;$submitted&lt;/code&gt; 상태를 false로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="00f75c22912ee6d84e2b4439725f1730667f3fa5" translate="yes" xml:space="preserve">
          <source>This method should be called when a control wants to change the view value; typically, this is done from within a DOM event handler. For example, the &lt;a href=&quot;../directive/input&quot;&gt;input&lt;/a&gt; directive calls it when the value of the input changes and &lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; calls it when an option is selected.</source>
          <target state="translated">컨트롤이 뷰 값을 변경하려고 할 때이 메서드를 호출해야합니다. 일반적으로 이는 DOM 이벤트 핸들러 내에서 수행됩니다. 예를 들어, &lt;a href=&quot;../directive/input&quot;&gt;입력&lt;/a&gt; 지시문 은 입력 값이 변경 될 때이를 호출 하고 &lt;a href=&quot;../directive/select&quot;&gt;select&lt;/a&gt; 는 옵션이 선택 될 때 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f87b6459717eafeb949467a7b18ce6ab71215fa0" translate="yes" xml:space="preserve">
          <source>This method takes all types of tasks (not only timeouts) into account, which is unintuitive. It is recommended to use &lt;a href=&quot;%24verifynopendingtasks&quot;&gt;&lt;code&gt;$verifyNoPendingTasks&lt;/code&gt;&lt;/a&gt; instead, which additionally allows checking for timeouts only (with &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt;).</source>
          <target state="translated">이 방법은 시간 초과뿐만 아니라 모든 유형의 작업을 고려하므로 직관적이지 않습니다. 대신 &lt;a href=&quot;%24verifynopendingtasks&quot;&gt; &lt;code&gt;$verifyNoPendingTasks&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다.이 경우 시간 초과 만 검사 할 수 있습니다 ( &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d2705a3d550a46eddae0f388fab27d18be36a157" translate="yes" xml:space="preserve">
          <source>This method will add each of the injectables to the injector and execute all of the config and run blocks for each module passed to the method.</source>
          <target state="translated">이 메소드는 인젝터에 각 인젝터 블을 추가하고 메소드에 전달 된 각 모듈에 대해 모든 구성 및 실행 블록을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2a37d1349d00a1da78883f5fe65c38c4d72feb8f" translate="yes" xml:space="preserve">
          <source>This method will also propagate to all the controls contained in this form.</source>
          <target state="translated">이 방법은이 양식에 포함 된 모든 컨트롤에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="27ac794b33b9e4188249c87bb5a53b20e784a575" translate="yes" xml:space="preserve">
          <source>This method will close all pending animations (both &lt;a href=&quot;../../nganimate#javascript-based-animations.html&quot;&gt;Javascript&lt;/a&gt; and &lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;CSS&lt;/a&gt;) and it will also flush any remaining animation frames and/or callbacks.</source>
          <target state="translated">이 메소드는 보류중인 모든 애니메이션 ( &lt;a href=&quot;../../nganimate#javascript-based-animations.html&quot;&gt;Javascript&lt;/a&gt; 및 &lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;CSS&lt;/a&gt; 모두)을 닫고 나머지 애니메이션 프레임 및 / 또는 콜백도 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="915cfaa2d3ed2fa450c656592c6f02599354a0d6" translate="yes" xml:space="preserve">
          <source>This might also happen because some third-party frameworks place animation duration defaults across many element or className selectors in order to make their code small and reusable.</source>
          <target state="translated">일부 타사 프레임 워크는 코드를 작고 재사용 할 수 있도록 많은 요소 또는 className 선택기에 애니메이션 지속 시간 기본값을 배치하기 때문에 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee006904db7800e4b79b052720172e93492d2b3" translate="yes" xml:space="preserve">
          <source>This mock implementation can be used to respond with static or dynamic responses via the &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; apis and their shortcuts (&lt;code&gt;expectGET&lt;/code&gt;, &lt;code&gt;whenPOST&lt;/code&gt;, etc).</source>
          <target state="translated">이 모의 구현은 &lt;code&gt;expect&lt;/code&gt; 및 &lt;code&gt;when&lt;/code&gt; apis 및 해당 바로 가기 ( &lt;code&gt;expectGET&lt;/code&gt; , &lt;code&gt;whenPOST&lt;/code&gt; 등) 를 통해 정적 또는 동적 응답으로 응답하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb22f4802e38eb9995c979b6ca1295aabe3cf8e8" translate="yes" xml:space="preserve">
          <source>This mode is implemented by the &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt; service and various core directives.</source>
          <target state="translated">이 모드는 &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 서비스 및 다양한 핵심 지시문으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="c233a6582d2d1e6bb77664600a84be278e1f11d2" translate="yes" xml:space="preserve">
          <source>This module allows the usage of any identifier that follows ES6 identifier naming convention to be used as an identifier in an AngularJS expression. ES6 delegates some of the identifier rules definition to Unicode, this module uses ES6 and Unicode 8.0 identifiers convention.</source>
          <target state="translated">이 모듈을 사용하면 ES6 식별자 이름 지정 규칙을 따르는 식별자를 AngularJS 표현식의 식별자로 사용할 수 있습니다. ES6는 일부 식별자 규칙 정의를 유니 코드로 위임합니다.이 모듈은 ES6 및 유니 코드 8.0 식별자 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="da9bb8e1f58198b53e9f9b910bc27da80d253883" translate="yes" xml:space="preserve">
          <source>This object has the following properties:</source>
          <target state="translated">이 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dde314902c57d9644c192713d0db6e938ac456" translate="yes" xml:space="preserve">
          <source>This object is a map where the keys are the name of the slot to fill and the value is an element selector used to match the HTML to the slot. The element selector should be in normalized form (e.g. &lt;code&gt;myElement&lt;/code&gt;) and will match the standard element variants (e.g. &lt;code&gt;my-element&lt;/code&gt;, &lt;code&gt;my:element&lt;/code&gt;, &lt;code&gt;data-my-element&lt;/code&gt;, etc).</source>
          <target state="translated">이 객체는 키가 채울 슬롯의 이름이고 값이 HTML을 슬롯에 일치시키는 데 사용되는 요소 선택기 인 맵입니다. 요소 선택기는 정규화 된 형식 (예 : &lt;code&gt;myElement&lt;/code&gt; ) 이어야 하고 표준 요소 변형 (예 : &lt;code&gt;my-element&lt;/code&gt; , &lt;code&gt;my:element&lt;/code&gt; , &lt;code&gt;data-my-element&lt;/code&gt; 등) 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f1709dc043ae963fcb6fd267e6b932727b496895" translate="yes" xml:space="preserve">
          <source>This page explains the AngularJS initialization process and how you can manually initialize AngularJS if necessary.</source>
          <target state="translated">이 페이지에서는 AngularJS 초기화 프로세스와 필요한 경우 AngularJS를 수동으로 초기화하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2b833d5b65cdc313f0a542c48b1308d0e041ebe8" translate="yes" xml:space="preserve">
          <source>This property is used only if the &lt;code&gt;compile&lt;/code&gt; property is not defined.</source>
          <target state="translated">이 특성은 &lt;code&gt;compile&lt;/code&gt; 특성이 정의되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="883346a7fad915ebeff0e77021b15cf3830eda47" translate="yes" xml:space="preserve">
          <source>This property is used to bind scope properties directly to the controller. It can be either &lt;code&gt;true&lt;/code&gt; or an object hash with the same format as the &lt;code&gt;scope&lt;/code&gt; property.</source>
          <target state="translated">이 속성은 범위 속성을 컨트롤러에 직접 바인딩하는 데 사용됩니다. &lt;code&gt;scope&lt;/code&gt; 속성 과 동일한 형식의 &lt;code&gt;true&lt;/code&gt; 또는 개체 해시 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a357c7aacd82c6ccff19e2526aedf02dcd86f146" translate="yes" xml:space="preserve">
          <source>This provider allows controller registration via the &lt;a href=&quot;%24controllerprovider#register.html&quot;&gt;register&lt;/a&gt; method.</source>
          <target state="translated">이 공급자는 &lt;a href=&quot;%24controllerprovider#register.html&quot;&gt;등록&lt;/a&gt; 방법을 통해 컨트롤러 등록을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="0617c66c55cb594ee37dad4d27bb3dac77e7f902" translate="yes" xml:space="preserve">
          <source>This section briefly touches on all of the important parts of AngularJS using a simple example. For a more in-depth explanation, see the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 간단한 예제를 사용하여 AngularJS의 모든 중요한 부분을 간략하게 설명합니다. 보다 자세한 설명은 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;튜토리얼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e465c56fdc1919202e61b4c838abdb2efdbe6b09" translate="yes" xml:space="preserve">
          <source>This section is useful to you if you're already familiar with the ICU MessageFormat syntax.</source>
          <target state="translated">이 섹션은 ICU MessageFormat 구문에 이미 익숙한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="629fe3d641b010dc22c32cf60d9c51461dbc815f" translate="yes" xml:space="preserve">
          <source>This section motivates and explains AngularJS's use of DI. For how to use DI, see above.</source>
          <target state="translated">이 섹션에서는 AngularJS의 DI 사용에 대한 동기를 부여하고 설명합니다. DI 사용 방법은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b368495e290571221704fff68dedde03e3d8a9d" translate="yes" xml:space="preserve">
          <source>This service handles the lifecycle of callbacks to handle JSONP requests. Override this service if you wish to customise where the callbacks are stored and how they vary compared to the requested url.</source>
          <target state="translated">이 서비스는 콜백 수명주기를 처리하여 JSONP 요청을 처리합니다. 콜백이 저장된 위치와 요청 된 URL과 비교하여 콜백이 어떻게 다른지를 사용자 정의하려면이 서비스를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="91d45badcd0e43333ab51b6632a69a56a2a8478d" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;../../ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">이 서비스는 &quot;flush&quot;및 &quot;verifyNoPendingTasks&quot;메소드를 추가하는 &lt;a href=&quot;../../ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt; 서비스 의 단순한 데코레이터입니다 .</target>
        </trans-unit>
        <trans-unit id="11801c68b71dbf7b43ee58c584c0b6ddc76ef833" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;../ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">이 서비스는 &quot;flush&quot;및 &quot;verifyNoPendingTasks&quot;메소드를 추가하는 &lt;a href=&quot;../ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt; 서비스 의 단순한 데코레이터입니다 .</target>
        </trans-unit>
        <trans-unit id="1f835173917891572ec34a779591da7e750f83cc" translate="yes" xml:space="preserve">
          <source>This service is just a simple decorator for &lt;a href=&quot;ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; service that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.</source>
          <target state="translated">이 서비스는 &quot;flush&quot;및 &quot;verifyNoPendingTasks&quot;메소드를 추가하는 &lt;a href=&quot;ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt; 서비스 의 단순한 데코레이터입니다 .</target>
        </trans-unit>
        <trans-unit id="0ea40af4b0cece7853eaf6005c23cbc42ab9d2f2" translate="yes" xml:space="preserve">
          <source>This should not be used to watch for changes in objects that are (or contain) &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/File&quot;&gt;File&lt;/a&gt; objects due to limitations with &lt;a href=&quot;../function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; 의&lt;/a&gt; 제한으로 인해 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/File&quot;&gt;File&lt;/a&gt; 객체 이거나 포함 된 객체의 변경 사항을 감시하는 데 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a1af7647b98d0fb330f0d8c1c4942701a28f04d" translate="yes" xml:space="preserve">
          <source>This significantly reduces the overhead. It is far easier to pay the small overhead and have an application that's secure and can be audited to verify that with much more ease than bolting security onto an application later.</source>
          <target state="translated">이는 오버 헤드를 크게 줄입니다. 적은 오버 헤드를 지불하는 것이 훨씬 쉽고 보안이 뛰어난 애플리케이션을 보유하고 있으며 나중에 애플리케이션에 보안을 적용하는 것보다 훨씬 쉽게 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fef39daed2db411efe5a4c7dfa116cf26686648" translate="yes" xml:space="preserve">
          <source>This simple example shows a formatter that would convert the model value to uppercase:</source>
          <target state="translated">이 간단한 예제는 모델 값을 대문자로 변환하는 포맷터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c4a9089b94815bb38543c89a6cef1127501717c7" translate="yes" xml:space="preserve">
          <source>This simple example shows a parser that would convert text input value to lowercase:</source>
          <target state="translated">이 간단한 예제는 텍스트 입력 값을 소문자로 변환하는 파서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="514273f310733c11cdf3627df583ea49721cf88c" translate="yes" xml:space="preserve">
          <source>This site and all of its contents are referring to AngularJS (version 1.x), if you are looking for the latest Angular, please visit &lt;a href=&quot;https://angular.io/&quot;&gt;angular.io&lt;/a&gt;.</source>
          <target state="translated">이 사이트와 모든 내용은 AngularJS (버전 1.x)를 참조하고 있습니다. 최신 Angular를 찾고 있다면 &lt;a href=&quot;https://angular.io/&quot;&gt;angular.io&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="3996593ddc4d041ab4093149112bcf781b10defe" translate="yes" xml:space="preserve">
          <source>This site refers to AngularJS (v1.x). &lt;a href=&quot;https://angular.io/&quot;&gt;Go to the latest Angular&lt;/a&gt;.</source>
          <target state="translated">이 사이트는 AngularJS (v1.x)를 나타냅니다. &lt;a href=&quot;https://angular.io/&quot;&gt;최신 Angular로 이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13256ca7859242e20651198514af51bbfcbee712" translate="yes" xml:space="preserve">
          <source>This syntax extension is provided by way of the &lt;code&gt;ngMessageFormat&lt;/code&gt; module that your application can depend upon (shipped separately as &lt;code&gt;angular-message-format.min.js&lt;/code&gt; and &lt;code&gt;angular-message-format.js&lt;/code&gt;.) A current limitation of the &lt;code&gt;ngMessageFormat&lt;/code&gt; module, is that it does not support redefining the &lt;code&gt;$interpolate&lt;/code&gt; start and end symbols. Only the default &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; are allowed.</source>
          <target state="translated">이 구문 확장은 애플리케이션이 의존 할 수 있는 &lt;code&gt;ngMessageFormat&lt;/code&gt; 모듈을 통해 제공됩니다 ( &lt;code&gt;angular-message-format.min.js&lt;/code&gt; 및 &lt;code&gt;angular-message-format.js&lt;/code&gt; 로 별도로 제공) . &lt;code&gt;ngMessageFormat&lt;/code&gt; 모듈 의 현재 제한 사항은 다음 과 같습니다 . &lt;code&gt;$interpolate&lt;/code&gt; 시작 및 끝 기호 재정의를 지원하지 않습니다 . 기본 &lt;code&gt;{{&lt;/code&gt; 및 &lt;code&gt;}}&lt;/code&gt; 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa80acf811fb7d3bc5d4d2945ffc786c2f86cb56" translate="yes" xml:space="preserve">
          <source>This syntax extension, while based on MessageFormat, has been designed to be backwards compatible with existing AngularJS interpolation expressions. The key rule is simply this: &lt;strong&gt;All interpolations are done inside double curlies.&lt;/strong&gt; The top level comma operator after an expression inside the double curlies causes MessageFormat extensions to be recognized. Such a top level comma is otherwise illegal in an AngularJS expression and is used by MessageFormat to specify the function (such as plural/select) and it's related syntax.</source>
          <target state="translated">이 구문 확장은 MessageFormat을 기반으로하지만 기존 AngularJS 보간 표현식과 호환되도록 설계되었습니다. 핵심 규칙은 간단합니다. &lt;strong&gt;모든 보간은 이중 컬 내부에서 수행됩니다. &lt;/strong&gt;이중 curlies 내에서 표현식을 사용한 후 최상위 쉼표 연산자를 사용하면 MessageFormat 확장이 인식됩니다. 이러한 최상위 쉼표는 AngularJS 표현식에서 유효하지 않으며 MessageFormat에서 함수 (예 : 복수 / 선택)와 관련 구문을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e599113b0edd4e670329932acb818d5adc536965" translate="yes" xml:space="preserve">
          <source>This technique is often used in unit tests to mock out a service's dependencies.</source>
          <target state="translated">이 기술은 종종 단위 테스트에서 서비스의 종속성을 조롱하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="addac971dd419fb36735ec5e40bf3e153ccc3c01" translate="yes" xml:space="preserve">
          <source>This test describes the requirements of a ToDo list, specifically, that it should be able to filter the list of items.</source>
          <target state="translated">이 테스트는 ToDo 목록의 요구 사항, 특히 항목 목록을 필터링 할 수 있어야한다는 요구 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="00229fe7fc0568eb82dd05f9f9c12e34d0b73a38" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;ngcomponentrouter/type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="9a55be7ee54799e91a1baaf9ec346a8b069e7054" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="3c90b3267c6b0702ff318db2cb8b8a8a313f9b31" translate="yes" xml:space="preserve">
          <source>This type extends the &lt;a href=&quot;type/router&quot;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;type/router&quot;&gt; &lt;code&gt;Router&lt;/code&gt; &lt;/a&gt; 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="194bdef428dc42d35d6d30db6c9d019109b9627e" translate="yes" xml:space="preserve">
          <source>This usually happens when the &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate module&lt;/a&gt; is included, but no actual animations are defined for &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;. Internet Explorer is affected more often than other browsers.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate 모듈&lt;/a&gt; 이 포함되어 있지만 실제 애니메이션이 정의되어 있지 않은 경우에 발생 합니다.&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; /&lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; 에&lt;/a&gt;. Internet Explorer는 다른 브라우저보다 더 자주 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="89941c3846f435420c0a0b5a2605676a55d335a2" translate="yes" xml:space="preserve">
          <source>This will ensure that all services in your application are properly annotated. See the &lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;dependency injection strict mode&lt;/a&gt; docs for more.</source>
          <target state="translated">이렇게하면 응용 프로그램의 모든 서비스에 주석이 제대로 달립니다. 자세한 내용은 &lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;의존성 주입 엄격 모드&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f281cdd5d821befaa87c95331b8e4df644d3d012" translate="yes" xml:space="preserve">
          <source>This will not render properly, unless we do some scope magic.</source>
          <target state="translated">우리가 스코프 마술을하지 않으면 제대로 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b981c7b156731dee59fa70a3a4d07e3181b03de" translate="yes" xml:space="preserve">
          <source>This will work:</source>
          <target state="translated">This will work:</target>
        </trans-unit>
        <trans-unit id="aa02d37789c0eb90c790d94a8e42c3470d3ddc29" translate="yes" xml:space="preserve">
          <source>Those that stray from AngularJS standards (such as modifying AngularJS's core) may have difficulty updating, so keeping to AngularJS standards is not just a functionality issue, it's also critical in order to facilitate rapid security updates.</source>
          <target state="translated">AngularJS의 핵심을 수정하는 것과 같이 AngularJS 표준에서 벗어난 것은 업데이트가 어려울 수 있으므로 AngularJS 표준을 유지하는 것은 기능적인 문제 일뿐만 아니라 신속한 보안 업데이트를 촉진하는 데 중요합니다.</target>
        </trans-unit>
        <trans-unit id="18ff4d25dda80968c984aa603ada71e7f8445542" translate="yes" xml:space="preserve">
          <source>Though we have a core group of core contributors at Google, AngularJS is an open source project with hundreds of contributors. We'd love you to be one of them. When you're ready, please read the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/misc/contribute&quot;&gt;Guide for contributing to AngularJS&lt;/a&gt;.</source>
          <target state="translated">Google에는 핵심 핵심 기고자 그룹이 있지만 AngularJS는 수백 명의 기고자를 가진 오픈 소스 프로젝트입니다. 우리는 당신이 그들 중 하나가되기를 바랍니다. 준비가되면 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/misc/contribute&quot;&gt;AngularJS에 기여하기위한 안내서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="d2c02671e16ad1b484fd37216c00f1f05c7c934d" translate="yes" xml:space="preserve">
          <source>Timestamp representing the desired time in &lt;em&gt;UTC&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UTC로&lt;/em&gt; 원하는 시간을 나타내는 타임 스탬프&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf36ae8fcb1d23b61ad6567c0e9d250610eb4692" translate="yes" xml:space="preserve">
          <source>Timezone to be used for formatting. It understands UTC/GMT and the continental US time zone abbreviations, but for general use, use a time zone offset, for example, &lt;code&gt;'+0430'&lt;/code&gt; (4 hours, 30 minutes east of the Greenwich meridian) If not specified, the timezone of the browser will be used.</source>
          <target state="translated">포맷팅에 사용되는 시간대. UTC / GMT 및 미국 대륙 시간대 약어를 이해하지만 일반적으로 사용하는 경우 시간대 오프셋을 사용하십시오 (예 : &lt;code&gt;'+0430'&lt;/code&gt; (그리니치 자오선에서 동쪽으로 4 시간 30 분)) 브라우저가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="791214dda21a45673e6a00a407416e403372c00e" translate="yes" xml:space="preserve">
          <source>Timezones</source>
          <target state="translated">Timezones</target>
        </trans-unit>
        <trans-unit id="a6f821f5dc3ea799d7cb08f9d99e08572d83b3a9" translate="yes" xml:space="preserve">
          <source>To actually start the animation we need to run &lt;code&gt;animation.start()&lt;/code&gt; which will then return a promise that we can hook into to detect when the animation ends. If we choose not to run the animation then we MUST run &lt;code&gt;animation.end()&lt;/code&gt; to perform a cleanup on the element (since some CSS classes and styles may have been applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties and that changing them will not reconfigure the parameters of the animation.</source>
          <target state="translated">실제로 애니메이션을 시작하려면 &lt;code&gt;animation.start()&lt;/code&gt; 를 실행해야합니다 . 그러면 애니메이션이 끝나는 시점을 감지하기 위해 연결할 수있는 약속이 반환됩니다. 애니메이션을 실행하지 않기로 선택한 경우, 애니메이션 에서 요소를 정리하기 위해 &lt;code&gt;animation.end()&lt;/code&gt; 를 실행해야합니다 ( 준비 단계에서 일부 CSS 클래스 및 스타일이 요소에 적용될 수 있으므로). 지속 시간, 지연, 전환 및 키 프레임과 같은 다른 모든 속성은 속성 일 뿐이며 변경하면 애니메이션의 매개 변수가 재구성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9fc69ae1586e6188ab11de16fef9caf3e9a3443" translate="yes" xml:space="preserve">
          <source>To add or overwrite these defaults, simply add or remove a property from these configuration objects. To add headers for an HTTP method other than POST or PUT, simply add a new object with the lowercased HTTP method name as the key, e.g. &lt;code&gt;$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }&lt;/code&gt;.</source>
          <target state="translated">이러한 기본값을 추가하거나 덮어 쓰려면 이러한 구성 개체에서 속성을 추가하거나 제거하면됩니다. POST 또는 PUT 이외의 HTTP 메소드에 대한 헤더를 추가하려면 소문자 HTTP 메소드 이름을 키로 사용하여 새 오브젝트를 추가하십시오 (예 : &lt;code&gt;$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="440d40ccd05fbc44211e69b24f08900b7177a1db" translate="yes" xml:space="preserve">
          <source>To allow styling of form as well as controls, &lt;code&gt;ngModel&lt;/code&gt; adds these CSS classes:</source>
          <target state="translated">컨트롤과 폼의 스타일을 허용하기 위해 &lt;code&gt;ngModel&lt;/code&gt; 은 다음 CSS 클래스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="978b24255f9e2043c3815ab1e3ee6525a4048630" translate="yes" xml:space="preserve">
          <source>To allow the minifiers to rename the function parameters and still be able to inject the right services, the function needs to be annotated with the &lt;code&gt;$inject&lt;/code&gt; property. The &lt;code&gt;$inject&lt;/code&gt; property is an array of service names to inject.</source>
          <target state="translated">축소 기에서 함수 매개 변수의 이름을 바꾸고 올바른 서비스를 계속 주입 할 수있게하려면 &lt;code&gt;$inject&lt;/code&gt; 속성 을 사용하여 함수에 주석을 달아야 합니다. &lt;code&gt;$inject&lt;/code&gt; 속성을 주입하는 서비스 이름의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="227bb446f977c7e7c29690779a58e5dcd3f7bc4a" translate="yes" xml:space="preserve">
          <source>To be secure by default, AngularJS makes sure bindings go through that sanitization, or any similar validation process, unless there's a good reason to trust the given value in this context. That trust is formalized with a function call. This means that as a developer, you can assume all untrusted bindings are safe. Then, to audit your code for binding security issues, you just need to ensure the values you mark as trusted indeed are safe - because they were received from your server, sanitized by your library, etc. You can organize your codebase to help with this - perhaps allowing only the files in a specific directory to do this. Ensuring that the internal API exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.</source>
          <target state="translated">기본적으로 보안을 유지하기 위해 AngularJS는이 컨텍스트에서 지정된 값을 신뢰할만한 이유가없는 한 바인딩이 해당 살균 또는 유사한 유효성 검사 프로세스를 거치도록합니다. 이 신뢰는 함수 호출로 공식화됩니다. 즉, 개발자는 신뢰할 수없는 모든 바인딩이 안전하다고 가정 할 수 있습니다. 그런 다음 바인딩 보안 문제에 대한 코드를 감사하려면 신뢰할 수있는 것으로 표시 한 값이 실제로 안전한지 확인해야합니다. 서버에서받은 값, 라이브러리에서 위생 처리 된 것 등입니다.이를 위해 코드베이스를 구성 할 수 있습니다. -아마도 특정 디렉토리의 파일만이 가능합니다. 해당 코드에 의해 노출 된 내부 API가 임의의 값을 안전한 것으로 마크 업하지 않도록하여보다 관리하기 쉬운 작업이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3936bf1237487c27fb7d5526e836b9e6d510539" translate="yes" xml:space="preserve">
          <source>To bind the model to a non-string value, you can use one of the following strategies:</source>
          <target state="translated">모델을 문자열이 아닌 값에 바인딩하려면 다음 전략 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23a4965aa6aa6aa1e840b66494467e36b1d73b3a" translate="yes" xml:space="preserve">
          <source>To cancel a timeout request, call &lt;code&gt;$timeout.cancel(promise)&lt;/code&gt;.</source>
          <target state="translated">시간 초과 요청을 취소하려면 &lt;code&gt;$timeout.cancel(promise)&lt;/code&gt; 전화하십시오 .</target>
        </trans-unit>
        <trans-unit id="56d3d8bb492af54889dcc66038949954edcd5e47" translate="yes" xml:space="preserve">
          <source>To configure the &lt;code&gt;$location&lt;/code&gt; service, retrieve the &lt;a href=&quot;../api/ng/provider/%24locationprovider&quot;&gt;$locationProvider&lt;/a&gt; and set the parameters as follows:</source>
          <target state="translated">구성하기 위해 &lt;code&gt;$location&lt;/code&gt; 서비스를 검 &lt;a href=&quot;../api/ng/provider/%24locationprovider&quot;&gt;$ locationProvider을&lt;/a&gt; 다음과 같이하고, 매개 변수를 설정합니다 :</target>
        </trans-unit>
        <trans-unit id="14e661d075a8d1d3220a38ac7fd86eacc04d62de" translate="yes" xml:space="preserve">
          <source>To cope with this you simply ensure that your 'element' transclude directive is wrapped in an element, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이에 대처하기 위해 단순히 'element'transclude 지시문이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 같은 요소로 랩핑되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="31fe0e47804d71db9cfd7fffc117d4ab85d47fab" translate="yes" xml:space="preserve">
          <source>To disable comment and css class directives use the &lt;code&gt;$compileProvider&lt;/code&gt;:</source>
          <target state="translated">주석 및 CSS 클래스 지시문을 비활성화하려면 &lt;code&gt;$compileProvider&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5387d2c27cc9dee45bb8cdc85e369fc9f5f17777" translate="yes" xml:space="preserve">
          <source>To disable the mouse click and drag functionality, add &lt;code&gt;ng-swipe-disable-mouse&lt;/code&gt; to the &lt;code&gt;ng-swipe-left&lt;/code&gt; or &lt;code&gt;ng-swipe-right&lt;/code&gt; DOM Element.</source>
          <target state="translated">마우스 클릭 및 드래그 기능을 비활성화하려면 &lt;code&gt;ng-swipe-disable-mouse&lt;/code&gt; 를 &lt;code&gt;ng-swipe-left&lt;/code&gt; 또는 &lt;code&gt;ng-swipe-right&lt;/code&gt; DOM 요소에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc2cad6e2a562908f313cb486e4136ebcb8eee1" translate="yes" xml:space="preserve">
          <source>To do this, we need to use the &lt;code&gt;transclude&lt;/code&gt; option.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;transclude&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="035a6a87408acdde8a23ee0cf037d6f472188af6" translate="yes" xml:space="preserve">
          <source>To ease the transition between native inputs and custom controls, ngAria now supports &lt;a href=&quot;../api/ng/directive/ngvalue&quot;&gt;ngValue&lt;/a&gt; and &lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt;ngChecked&lt;/a&gt;. The original directives were created for native inputs only, so ngAria extends support to custom elements by managing &lt;code&gt;aria-checked&lt;/code&gt; for accessibility.</source>
          <target state="translated">기본 입력과 사용자 지정 컨트롤 간의 전환을 쉽게하기 위해 ngAria는 이제 &lt;a href=&quot;../api/ng/directive/ngvalue&quot;&gt;ngValue&lt;/a&gt; 및 &lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt;ngChecked를&lt;/a&gt; 지원합니다 . 원래 지시문은 기본 입력에 대해서만 작성되었으므로 ngAria는 &lt;code&gt;aria-checked&lt;/code&gt; accessibility를 관리하여 사용자 정의 요소에 대한 지원을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="5d168eb9b869dbfb344d7855a584554963333f9c" translate="yes" xml:space="preserve">
          <source>To enable strict di mode, you have two options:</source>
          <target state="translated">엄격한 di 모드를 사용하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fb64437b796f4ba9a62ece5fde0e8c967dba837" translate="yes" xml:space="preserve">
          <source>To examine the scope in the debugger:</source>
          <target state="translated">디버거에서 범위를 검사하려면</target>
        </trans-unit>
        <trans-unit id="b590774031a2cf4725192dcbb7db9c57480cef1d" translate="yes" xml:space="preserve">
          <source>To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis, Use the &lt;code&gt;headers&lt;/code&gt; property, setting the desired header to &lt;code&gt;undefined&lt;/code&gt;. For example:</source>
          <target state="translated">요청별로 $ httpProvider.defaults.headers를 통해 자동으로 추가 된 헤더를 명시 적으로 제거하려면 &lt;code&gt;headers&lt;/code&gt; 속성을 사용하여 원하는 헤더를 &lt;code&gt;undefined&lt;/code&gt; 로 설정하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c80d1fb8ce1e4bf1cd40c9acaf0eb4fe7ea79e3f" translate="yes" xml:space="preserve">
          <source>To help with this, the injected parameters can, optionally, be enclosed with underscores. These are ignored by the injector when the reference name is resolved.</source>
          <target state="translated">이를 위해 주입 된 매개 변수를 선택적으로 밑줄로 묶을 수 있습니다. 참조 이름이 확인되면 인젝터에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="220d6276002b8cffd3f24e9bec07ba42bc0c1add" translate="yes" xml:space="preserve">
          <source>To illustrate further how Controller components work in AngularJS, let's create a little app with the following components:</source>
          <target state="translated">AngularJS에서 컨트롤러 구성 요소가 작동하는 방식을 자세히 설명하기 위해 다음 구성 요소를 사용하여 작은 응용 프로그램을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4f97b5d532edfe4940fd9b38ad40a3cd6585eed2" translate="yes" xml:space="preserve">
          <source>To illustrate this, consider the &lt;code&gt;ng-bind-html&lt;/code&gt; directive. It renders its value directly as HTML: we call that the &lt;em&gt;context&lt;/em&gt;. When given an untrusted input, AngularJS will attempt to sanitize it before rendering if a sanitizer is available, and throw otherwise. To bypass sanitization and render the input as-is, you will need to mark it as trusted for that context before attempting to bind it.</source>
          <target state="translated">이를 설명하기 위해 &lt;code&gt;ng-bind-html&lt;/code&gt; 지시문을 고려하십시오 . 값을 HTML로 직접 렌더링합니다 . &lt;em&gt;문맥&lt;/em&gt; 이라고합니다 . 신뢰할 수없는 입력이 주어지면 AngularJS는 소독제를 사용할 수있는 경우 렌더링하기 전에 소독을 시도하고 그렇지 않으면 던집니다. 위생 처리를 무시하고 입력을 그대로 렌더링하려면 바인딩하기 전에 해당 컨텍스트에 대해 신뢰할 수있는 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="902ec43adccfdb69ffa83ad123da01d2e0b94c0b" translate="yes" xml:space="preserve">
          <source>To illustrate this, see the example below. Notice that we've added a &lt;code&gt;link&lt;/code&gt; function in &lt;code&gt;script.js&lt;/code&gt; that redefines &lt;code&gt;name&lt;/code&gt; as &lt;code&gt;Jeff&lt;/code&gt;. What do you think the &lt;code&gt;{{name}}&lt;/code&gt; binding will resolve to now?</source>
          <target state="translated">이를 설명하려면 아래 예를 참조하십시오. &lt;code&gt;script.js&lt;/code&gt; 에 &lt;code&gt;name&lt;/code&gt; 을 &lt;code&gt;Jeff&lt;/code&gt; 로 재정의 하는 &lt;code&gt;link&lt;/code&gt; 함수를 추가 했습니다 . &lt;code&gt;{{name}}&lt;/code&gt; 바인딩이 이제 어떻게 해결 될 것이라고 생각 하십니까?</target>
        </trans-unit>
        <trans-unit id="e178b4a4fddd5e3eedf206140142188444cdeb8c" translate="yes" xml:space="preserve">
          <source>To learn more about enabling animation support, click here to visit the &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate module page&lt;/a&gt;.</source>
          <target state="translated">애니메이션 지원 활성화에 대한 자세한 내용을 보려면 여기를 클릭하여 &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate 모듈 페이지&lt;/a&gt; 를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="adee17c33df52d3638d95bce546f5bc1b50438c9" translate="yes" xml:space="preserve">
          <source>To learn more about what's possible be sure to visit the &lt;a href=&quot;nganimate/service/%24animatecss&quot;&gt;$animateCss service&lt;/a&gt;.</source>
          <target state="translated">가능한 것에 대한 자세한 내용은 &lt;a href=&quot;nganimate/service/%24animatecss&quot;&gt;$ animateCss 서비스&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="97a771699a9dc113a310959b23249232d9279e3f" translate="yes" xml:space="preserve">
          <source>To manage the responsibility of dependency creation, each AngularJS application has an &lt;a href=&quot;../api/ng/function/angular.injector&quot;&gt;injector&lt;/a&gt;. The injector is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;service locator&lt;/a&gt; that is responsible for construction and lookup of dependencies.</source>
          <target state="translated">종속성 작성의 책임을 관리하기 위해 각 AngularJS 애플리케이션에는 &lt;a href=&quot;../api/ng/function/angular.injector&quot;&gt;인젝터가&lt;/a&gt; 있습니다. 인젝터는 종속성의 구성 및 조회를 담당 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;서비스 로케이터&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87b7d6ced2affdb289caee17d8f374aa66ff02f9" translate="yes" xml:space="preserve">
          <source>To minimize creation of DOM elements, &lt;code&gt;ngRepeat&lt;/code&gt; uses a function to &quot;keep track&quot; of all items in the collection and their corresponding DOM elements. For example, if an item is added to the collection, &lt;code&gt;ngRepeat&lt;/code&gt; will know that all other items already have DOM elements, and will not re-render them.</source>
          <target state="translated">DOM 요소의 생성을 최소화하기 위해 &lt;code&gt;ngRepeat&lt;/code&gt; 는 함수를 사용하여 컬렉션의 모든 항목과 해당 DOM 요소를 &quot;추적&quot;합니다. 예를 들어 항목이 컬렉션에 추가되면 &lt;code&gt;ngRepeat&lt;/code&gt; 는 다른 모든 항목에 이미 DOM 요소가 있다는 것을 알고 다시 렌더링하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dec799d727684b5ec439ffba56606b33413cfdb2" translate="yes" xml:space="preserve">
          <source>To prevent double execution of the handler, use only one of the &lt;a href=&quot;ngsubmit&quot;&gt;ngSubmit&lt;/a&gt; or &lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt; directives. This is because of the following form submission rules in the HTML specification:</source>
          <target state="translated">핸들러의 이중 실행을 방지하려면 &lt;a href=&quot;ngsubmit&quot;&gt;ngSubmit&lt;/a&gt; 또는 &lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt; 지시문 중 하나만 사용하십시오 . 이는 HTML 사양에서 다음과 같은 양식 제출 규칙 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7f0c03c455bcc97cd1a6acf7ad3e2c93c1a12ed0" translate="yes" xml:space="preserve">
          <source>To prevent this, you can apply styles to the &lt;code&gt;ng-[event]-prepare&lt;/code&gt; class, which is added as soon as an animation is initialized, but removed before the actual animation starts (after waiting for a &lt;code&gt;$digest&lt;/code&gt;). This class is only added for &lt;em&gt;structural&lt;/em&gt; animations (&lt;code&gt;enter&lt;/code&gt;, &lt;code&gt;move&lt;/code&gt;, and &lt;code&gt;leave&lt;/code&gt;).</source>
          <target state="translated">이를 방지하기 위해 &lt;code&gt;ng-[event]-prepare&lt;/code&gt; 클래스에 스타일을 적용 할 수 있습니다.이 클래스는 애니메이션이 초기화 되 자마자 추가되지만 실제 애니메이션이 시작되기 전에 제거됩니다 ( &lt;code&gt;$digest&lt;/code&gt; 대기 후 ). 이 클래스는 &lt;em&gt;구조적&lt;/em&gt; 애니메이션 ( &lt;code&gt;enter&lt;/code&gt; , &lt;code&gt;move&lt;/code&gt; , &lt;code&gt;leave&lt;/code&gt; ) 에만 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="fea899b0c5f1ec32df106a9c01c18f45fc405eb5" translate="yes" xml:space="preserve">
          <source>To protect against these, explicitly setup &lt;code&gt;overflow: hidden&lt;/code&gt; css rule for all potential svg tags within the sanitized content:</source>
          <target state="translated">이러한 문제를 방지하기 위해 위생적으로 처리 된 컨텐츠 내의 모든 잠재적 svg 태그에 대해 &lt;code&gt;overflow: hidden&lt;/code&gt; css rule을 명시 적으로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="943f7d13999a1f50a97c045b022c8dd2e2f3dcbb" translate="yes" xml:space="preserve">
          <source>To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending the range of the repeater by defining explicit start and end points by using &lt;strong&gt;ng-repeat-start&lt;/strong&gt; and &lt;strong&gt;ng-repeat-end&lt;/strong&gt; respectively. The &lt;strong&gt;ng-repeat-start&lt;/strong&gt; directive works the same as &lt;strong&gt;ng-repeat&lt;/strong&gt;, but will repeat all the HTML code (including the tag it's defined on) up to and including the ending HTML tag where &lt;strong&gt;ng-repeat-end&lt;/strong&gt; is placed.</source>
          <target state="translated">하나의 부모 요소 대신 일련의 요소를 반복하기 위해 ngRepeat (및 다른 ng 지시문)는 각각 &lt;strong&gt;ng-repeat-start&lt;/strong&gt; 및 &lt;strong&gt;ng-repeat-end&lt;/strong&gt; 를 사용하여 명시적인 시작 및 끝점을 정의하여 리피터 범위 확장을 지원합니다. . &lt;strong&gt;NG 반복 스타트&lt;/strong&gt; 지시어와 동일하게 작동 &lt;strong&gt;ng를 반복&lt;/strong&gt; 하지만, 반복 모든까지 (이에 정의되어 태그 포함) 끝 HTML 태그를 포함하여 HTML 코드 &lt;strong&gt;ng를 반복 엔드가&lt;/strong&gt; 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="f668b9db355d141127ee33b275331ca28c9dfb88" translate="yes" xml:space="preserve">
          <source>To retrieve the associated scope in console execute: &lt;code&gt;angular.element($0).scope()&lt;/code&gt;</source>
          <target state="translated">콘솔에서 관련 범위를 검색하려면 &lt;code&gt;angular.element($0).scope()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de4573d3b8e714d7e13c12a8ebcb5312e186616d" translate="yes" xml:space="preserve">
          <source>To retrieve the template later, simply use it in your component:</source>
          <target state="translated">나중에 템플릿을 검색하려면 구성 요소에서 템플릿을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b58c4c9070bb055028259d5cf6d5b517e4abcc6" translate="yes" xml:space="preserve">
          <source>To reveal the location of the calls to &lt;code&gt;$log&lt;/code&gt; in the JavaScript console, you can &quot;blackbox&quot; the AngularJS source in your browser:</source>
          <target state="translated">JavaScript 콘솔에서 &lt;code&gt;$log&lt;/code&gt; 호출 위치를 나타내 려면 브라우저에서 AngularJS 소스를 &quot;블랙 박스&quot;로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2541170fa16acdab2fc366c6c63c6f8ff8ecc82c" translate="yes" xml:space="preserve">
          <source>To see a complete demo, see the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/step_14&quot;&gt;animation step in the phonecat tutorial&lt;/a&gt;.</source>
          <target state="translated">전체 데모를 보려면 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/step_14&quot;&gt;phonecat 튜토리얼&lt;/a&gt; 의 애니메이션 단계를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d8130d29419030e1a83b2c86e3ff758ba4c5db" translate="yes" xml:space="preserve">
          <source>To see the functional implementation check out &lt;code&gt;src/ngAnimate/animate.js&lt;/code&gt;.</source>
          <target state="translated">기능 구현을 보려면 &lt;code&gt;src/ngAnimate/animate.js&lt;/code&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="48944de5e140f1f4917a4abe8d0e9716456f969d" translate="yes" xml:space="preserve">
          <source>To setup the application to run with this http backend, you have to create a module that depends on the &lt;code&gt;ngMockE2E&lt;/code&gt; and your application modules and defines the fake backend:</source>
          <target state="translated">이 http 백엔드와 함께 실행되도록 애플리케이션을 설정하려면 &lt;code&gt;ngMockE2E&lt;/code&gt; 및 애플리케이션 모듈 에 의존 하고 가짜 백엔드를 정의 하는 모듈을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22caed9641a69d6681b70e0e73387ff932f2cc11" translate="yes" xml:space="preserve">
          <source>To solve the issue of lack of isolation, the directive declares a new &lt;code&gt;isolated&lt;/code&gt; scope. An isolated scope does not prototypically inherit from the parent scope, and therefore we don't have to worry about accidentally clobbering any properties.</source>
          <target state="translated">분리 부족 문제를 해결하기 위해이 지시문은 새로운 &lt;code&gt;isolated&lt;/code&gt; 범위를 선언합니다 . 격리 된 범위는 부모 범위에서 프로토 타입을 상속받지 않으므로 실수로 속성을 무단 복제하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a25c283d366fb9b4b8a14a99d214847f2dc0c90" translate="yes" xml:space="preserve">
          <source>To systematically block XSS security bugs, AngularJS treats all values as untrusted by default in HTML or sensitive URL bindings. When binding untrusted values, AngularJS will automatically run security checks on them (sanitizations, whitelists, depending on context), or throw when it cannot guarantee the security of the result. That behavior depends strongly on contexts: HTML can be sanitized, but template URLs cannot, for instance.</source>
          <target state="translated">XSS 보안 버그를 체계적으로 차단하기 위해 AngularJS는 기본적으로 HTML 또는 민감한 URL 바인딩에서 모든 값을 신뢰할 수없는 것으로 처리합니다. 신뢰할 수없는 값을 바인딩 할 때 AngularJS는 자동으로 값에 대한 보안 검사 (위생에 따라 위생, 화이트리스트)를 실행하거나 결과의 보안을 보장 할 수 없을 때 발생합니다. 이러한 동작은 컨텍스트에 따라 크게 달라집니다. HTML은 삭제 될 수 있지만 템플릿 URL은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06ebef4f171a37657a117bc224081111b0d7f222" translate="yes" xml:space="preserve">
          <source>To take advantage of this, your server needs to set a token in a JavaScript readable session cookie called &lt;code&gt;XSRF-TOKEN&lt;/code&gt; on the first HTTP GET request. On subsequent XHR requests the server can verify that the cookie matches the &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; HTTP header, and therefore be sure that only JavaScript running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server (to prevent the JavaScript from making up its own tokens). We recommend that the token is a digest of your site's authentication cookie with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;salt&lt;/a&gt; for added security.</source>
          <target state="translated">이를 활용하려면 서버가 첫 번째 HTTP GET 요청에서 &lt;code&gt;XSRF-TOKEN&lt;/code&gt; 이라는 JavaScript 읽기 가능 세션 쿠키에 토큰을 설정해야합니다 . 후속 XHR 요청에서 서버는 쿠키가 &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; HTTP 헤더 와 일치하는지 확인할 수 있으므로 도메인에서 실행중인 JavaScript 만 요청을 보낼 수 있는지 확인하십시오. 토큰은 각 사용자마다 고유해야하며, JavaScript가 자체 토큰을 구성하지 못하도록 서버에서 확인할 수 있어야합니다. 토큰은 보안 강화를 위해 &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;소금으로&lt;/a&gt; 사이트의 인증 쿠키를 요약 한 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a0203afddf9d65db821d61605534ec6d67099780" translate="yes" xml:space="preserve">
          <source>To turn the tinfoil shielding on in our app, we need to create a config function via the module API and have the UnicornLauncherProvider injected into it:</source>
          <target state="translated">앱에서 은박지 차폐를 켜려면 모듈 API를 통해 구성 기능을 만들고 UnicornLauncherProvider에 주입해야합니다.</target>
        </trans-unit>
        <trans-unit id="553205f92ef2e18fbc6290adc32954aaf6a56cd0" translate="yes" xml:space="preserve">
          <source>To understand the extension, take a look at the ICU MessageFormat syntax as specified by the ICU documentation. Anywhere in that MessageFormat that you have regular message text and you want to substitute an expression, just put it in double curlies instead of single curlies that MessageFormat dictates. This has a huge advantage. &lt;strong&gt;You are no longer limited to simple identifiers for substitutions&lt;/strong&gt;. Because you are using double curlies, you can stick in any arbitrary interpolation syntax there, including nesting more MessageFormat expressions!</source>
          <target state="translated">확장을 이해하려면 ICU 설명서에 지정된 ICU MessageFormat 구문을 살펴보십시오. 해당 MessageFormat에서 정규 메시지 텍스트가 있고 표현식을 대체하려는 경우 MessageFormat이 지시하는 단일 curl 대신 이중 curl에 넣으십시오. 이것은 큰 장점이 있습니다. &lt;strong&gt;더 이상 대체를위한 간단한 식별자로 제한되지 않습니다&lt;/strong&gt; . 이중 컬을 사용하기 때문에 더 많은 MessageFormat 표현식 중첩을 포함하여 임의의 보간 구문을 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="668388e5a3f0bc129762bfbfd5aa23b7c1098592" translate="yes" xml:space="preserve">
          <source>To understand, let's look at a real-world example with &lt;code&gt;ngRepeat&lt;/code&gt;:</source>
          <target state="translated">이해하기 위해 &lt;code&gt;ngRepeat&lt;/code&gt; 을 사용한 실제 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3d7ed49b07662b8833b62e5f33bb9164b025e055" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;jQuery&lt;/code&gt;, simply ensure it is loaded before the &lt;code&gt;angular.js&lt;/code&gt; file. You can also use the &lt;a href=&quot;../directive/ngjq&quot;&gt;&lt;code&gt;ngJq&lt;/code&gt;&lt;/a&gt; directive to specify that jqlite should be used over jQuery, or to use a specific version of jQuery if multiple versions exist on the page.</source>
          <target state="translated">&lt;code&gt;jQuery&lt;/code&gt; 를 사용하려면 &lt;code&gt;angular.js&lt;/code&gt; 파일 보다 먼저 jQuery를 로드해야 합니다. &lt;a href=&quot;../directive/ngjq&quot;&gt; &lt;code&gt;ngJq&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 jqlite 를 jQuery보다 사용하도록 지정하거나 페이지에 여러 버전이있는 경우 특정 버전의 jQuery를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b532a90142adf829020e98b53c46a1fe9b0e63b" translate="yes" xml:space="preserve">
          <source>To use DI, there needs to be a place where all the things that should work together are registered. In AngularJS, this is the purpose of the &lt;a href=&quot;module&quot;&gt;modules&lt;/a&gt;. When AngularJS starts, it will use the configuration of the module with the name defined by the &lt;code&gt;ng-app&lt;/code&gt; directive, including the configuration of all modules that this module depends on.</source>
          <target state="translated">DI를 사용하려면 함께 작동해야하는 모든 것이 등록되어 있어야합니다. AngularJS에서 이것은 &lt;a href=&quot;module&quot;&gt;모듈&lt;/a&gt; 의 목적입니다 . AngularJS가 시작되면 이 모듈이 의존하는 모든 모듈의 구성을 포함하여 &lt;code&gt;ng-app&lt;/code&gt; 지시문에 의해 정의 된 이름으로 모듈의 구성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="61b10e4c62d5b605a789c76144449e0198436d85" translate="yes" xml:space="preserve">
          <source>To use an AngularJS service, you add it as a dependency for the component (controller, service, filter or directive) that depends on the service. AngularJS's &lt;a href=&quot;di&quot;&gt;dependency injection&lt;/a&gt; subsystem takes care of the rest.</source>
          <target state="translated">AngularJS 서비스를 사용하려면 서비스에 의존하는 컴포넌트 (컨트롤러, 서비스, 필터 또는 지시문)의 종속성으로 서비스를 추가하십시오. AngularJS의 &lt;a href=&quot;di&quot;&gt;의존성 주입&lt;/a&gt; 서브 시스템은 나머지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="eb5a31df8b9aafc070a499ecf9c86a92d155038d" translate="yes" xml:space="preserve">
          <source>To use it for serializing &lt;code&gt;$http&lt;/code&gt; request parameters, set it as the &lt;code&gt;paramSerializer&lt;/code&gt; property:</source>
          <target state="translated">&lt;code&gt;$http&lt;/code&gt; 요청 매개 변수 를 직렬화하는 데 사용하려면 &lt;code&gt;paramSerializer&lt;/code&gt; 특성 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="34fe5ca24f7655ef4c0df8a8ce1da864c5daffcc" translate="yes" xml:space="preserve">
          <source>To wrap it up, let's summarize the most important points:</source>
          <target state="translated">마무리하기 위해 가장 중요한 사항을 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="67e87905406bc002d915c4e863d71aecb21a48f5" translate="yes" xml:space="preserve">
          <source>Toaster Notifications</source>
          <target state="translated">토스터 알림</target>
        </trans-unit>
        <trans-unit id="89699e63b193e1ad3c1e57e75c1c6bbec6885d66" translate="yes" xml:space="preserve">
          <source>Token for the literal value. The literal name value must be a valid literal name.</source>
          <target state="translated">리터럴 값에 대한 토큰입니다. 리터럴 이름 값은 유효한 리터럴 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="43fad2672c530239402dc3cd0dc6902dc62473f7" translate="yes" xml:space="preserve">
          <source>Tools like &lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt; and &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; need this information to run, but you can disable this in production for a significant performance boost with:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/angular/angularjs-batarang&quot;&gt;Batarang&lt;/a&gt; 과 같은 도구 를 실행하려면이 정보가 필요하지만 다음과 같은 경우 성능을 크게 향상시키기 위해 프로덕션에서이 정보를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1530f9880b2af5eaf175a15ace085e93796c97a" translate="yes" xml:space="preserve">
          <source>Tools like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; let you use implicit dependency annotations in your app and automatically add inline array annotations prior to minifying. If you decide to take this approach, you probably want to use &lt;code&gt;ng-strict-di&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; 와 같은 도구 를 사용하면 앱에서 암시 적 종속성 주석을 사용하고 축소하기 전에 인라인 배열 주석을 자동으로 추가 할 수 있습니다. 이 방법을 사용하기로 결정했다면 아마도 &lt;code&gt;ng-strict-di&lt;/code&gt; 를 사용하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aafa2966091cfe18b0886a79db159933dbbadccd" translate="yes" xml:space="preserve">
          <source>Total number of child scopes.</source>
          <target state="translated">총 자식 범위 수</target>
        </trans-unit>
        <trans-unit id="a47abbef75ed2b9d1d65dbb4c1ee8007c1065795" translate="yes" xml:space="preserve">
          <source>Total number of watchers.</source>
          <target state="translated">총 시청자 수</target>
        </trans-unit>
        <trans-unit id="4d568499903ebd2d220b4d1aebe5751fe7c8e35c" translate="yes" xml:space="preserve">
          <source>Tracking and Duplicates</source>
          <target state="translated">추적 및 복제</target>
        </trans-unit>
        <trans-unit id="66e03a0ac4dbd759832dd1962270988fb63c7705" translate="yes" xml:space="preserve">
          <source>Transclude fallback content</source>
          <target state="translated">대체 콘텐츠를 포함</target>
        </trans-unit>
        <trans-unit id="2ff8fb7265f6145db1964ce88bbfd53d7161548a" translate="yes" xml:space="preserve">
          <source>Transcluded content exists on a scope that inherits from outside a directive but exists as a child of the directive's containing scope. If the containing scope is suspended the transcluded scope will also be suspended, even if the scope from which the transcluded scope inherits is not suspended.</source>
          <target state="translated">포함 된 컨텐츠는 지시문 외부에서 상속하지만 지시문 포함 범위의 하위 항목으로 존재하는 범위에 있습니다. 포함 범위가 일시 중단 된 경우 포함 된 범위가 상속하는 범위가 일시 중단되지 않은 경우에도 포함 된 범위도 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="795ce1bfcced4d4049cae5ddaeacbcb0c25e5cff" translate="yes" xml:space="preserve">
          <source>Transclusion</source>
          <target state="translated">Transclusion</target>
        </trans-unit>
        <trans-unit id="a5ed75b850fe44412f536f842d6bad363b3d1dc0" translate="yes" xml:space="preserve">
          <source>Transclusion Functions</source>
          <target state="translated">변환 함수</target>
        </trans-unit>
        <trans-unit id="989bb50d78d8c039c498ff1aa5c4035592d45823" translate="yes" xml:space="preserve">
          <source>Transclusion Scopes</source>
          <target state="translated">번역 범위</target>
        </trans-unit>
        <trans-unit id="bd9f20a87bc27f598593beab138842764756b017" translate="yes" xml:space="preserve">
          <source>Transclusion is the process of extracting a collection of DOM elements from one part of the DOM and copying them to another part of the DOM, while maintaining their connection to the original AngularJS scope from where they were taken.</source>
          <target state="translated">Transclusion은 DOM의 한 부분에서 DOM 요소의 컬렉션을 추출하여 DOM의 다른 부분으로 복사하는 과정입니다.</target>
        </trans-unit>
        <trans-unit id="34a69ce955b679dd8ef55bd68ef5d2fb2de59126" translate="yes" xml:space="preserve">
          <source>Transclusion is used (often with &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt;) to insert the original contents of a directive's element into a specified place in the template of the directive. The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded content has access to the properties on the scope from which it was taken, even if the directive has isolated scope. See the &lt;a href=&quot;../../../guide/directive#creating-a-directive-that-wraps-other-elements.html&quot;&gt;Directives Guide&lt;/a&gt;.</source>
          <target state="translated">지시문 요소의 원래 내용을 지시문 템플리트의 지정된 위치에 삽입하기 위해 &lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 . 단순히 DOM 요소를 수동으로 이동시키는 것보다 전이의 이점은 전치 된 컨텐츠가 지시어가 분리 된 범위를 가지고 있어도 해당 범위의 특성에 액세스 할 수 있다는 것입니다. &lt;a href=&quot;../../../guide/directive#creating-a-directive-that-wraps-other-elements.html&quot;&gt;지시문 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f5aa3a8fc4b42447f88fc712a14afe2cdc1f412" translate="yes" xml:space="preserve">
          <source>Transforming Requests and Responses</source>
          <target state="translated">요청 및 응답 변환</target>
        </trans-unit>
        <trans-unit id="e66820e4851b71dffa2d6714b446c9480ae287d1" translate="yes" xml:space="preserve">
          <source>Translated strings/datetime formats can vary greatly in length. For example, &lt;code&gt;June 3, 1977&lt;/code&gt; will be translated to Spanish as &lt;code&gt;3 de junio de 1977&lt;/code&gt;.</source>
          <target state="translated">번역 된 문자열 / 날짜 / 시간 형식은 길이가 크게 다를 수 있습니다. 예를 들어, &lt;code&gt;June 3, 1977&lt;/code&gt; &lt;code&gt;3 de junio de 1977&lt;/code&gt; 1977 년 3 월 6 일 스페인어로 번역됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ea519c83af9abea32e76f378b69d1f735efd77a" translate="yes" xml:space="preserve">
          <source>Translation length</source>
          <target state="translated">번역 길이</target>
        </trans-unit>
        <trans-unit id="529ba88fd78ba49c6c2f6f2560bd2ca3b71c2359" translate="yes" xml:space="preserve">
          <source>Triggering and debouncing model updates</source>
          <target state="translated">모델 업데이트 트리거 및 제거</target>
        </trans-unit>
        <trans-unit id="b30aa7b64c97b21bb201e26ce39656a62ae3ba6f" translate="yes" xml:space="preserve">
          <source>Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon execution, the removeClass operation will only be handled after the next digest and it will not trigger an animation if element does not contain the CSS class or if the class is added at a later step. Note that class-based animations are treated differently compared to structural animations (like enter, move and leave) since the CSS classes may be added/removed at different points depending if CSS or JavaScript animations are used.</source>
          <target state="translated">제공된 CSS 클래스 제거를 둘러싼 removeClass 애니메이션을 트리거합니다. 실행시 removeClass 작업은 다음 다이제스트 후에 만 ​​처리되며 요소에 CSS 클래스가 없거나 이후 단계에서 클래스가 추가 된 경우 애니메이션을 트리거하지 않습니다. CSS 또는 JavaScript 애니메이션의 사용 여부에 따라 CSS 클래스가 다른 지점에서 추가 / 제거 될 수 있으므로 클래스 기반 애니메이션은 구조 애니메이션 (입력, 이동 및 휴가 등)과 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c60d34c5c475354e584429d0db24f6b56f4c26" translate="yes" xml:space="preserve">
          <source>Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon execution, the addClass operation will only be handled after the next digest and it will not trigger an animation if element already contains the CSS class or if the class is removed at a later step. Note that class-based animations are treated differently compared to structural animations (like enter, move and leave) since the CSS classes may be added/removed at different points depending if CSS or JavaScript animations are used.</source>
          <target state="translated">제공된 CSS 클래스 추가를 둘러싼 addClass 애니메이션을 트리거합니다. 실행시 addClass 작업은 다음 다이제스트 후에 만 ​​처리되며 요소에 CSS 클래스가 이미 포함되어 있거나 이후 단계에서 클래스가 제거 된 경우 애니메이션을 트리거하지 않습니다. CSS 또는 JavaScript 애니메이션의 사용 여부에 따라 CSS 클래스가 다른 지점에서 추가 / 제거 될 수 있으므로 클래스 기반 애니메이션은 구조 애니메이션 (입력, 이동 및 휴가 등)과 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ea2af226764114c06246658ad6eb3995bac408" translate="yes" xml:space="preserve">
          <source>Triggers an animation and then removes the element from the DOM. When the function is called a promise is returned that will be resolved during the next digest once the animation has completed.</source>
          <target state="translated">애니메이션을 트리거 한 다음 DOM에서 요소를 제거합니다. 함수가 호출되면 약속이 반환되고 애니메이션이 완료되면 다음 다이제스트 중에 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="d33a09cfae6955e8ea96021c02a14a6f2135e6d2" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is &quot;empty&quot;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; true 인 경우 이 &quot;비어 있으면&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="7e9f928080be6817472e3edba6cd3728c6b44b07" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;Date&lt;/code&gt; 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="9d4620ea3af47d4b59be6c1ad6d376625a3bc5a3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;Function&lt;/code&gt; 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="f2dc22bb4abc37c763c32e208299d55940817939" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;Number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;Number&lt;/code&gt; 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="629f2e041c0522e13feab339a108446527250afa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;String&lt;/code&gt; 이면 참 .</target>
        </trans-unit>
        <trans-unit id="c7206f8d3d0972b3265fbd63b451b2d141ee6fe8" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is a DOM element (or wrapped jQuery element).</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; true 인 경우 가 DOM 요소 (또는 래핑 된 jQuery 요소) 입니다.</target>
        </trans-unit>
        <trans-unit id="e55cf1550d8a7a76c67c0e00faabad1dcabda075" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;Array&lt;/code&gt; 이면 참 .</target>
        </trans-unit>
        <trans-unit id="b7156770c7f10d6373aa8baaafb2baaeb8df6fff" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;Object&lt;/code&gt; but not &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 이지만 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="61bd97fd0cb8d2d1c177255faefe3a90f7d26d11" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; true 인 경우 이 정의되어 입니다.</target>
        </trans-unit>
        <trans-unit id="f4ccefcaf72f594cb16e5d8ae91db2c94271cc38" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;value&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; true 인 경우 이 정의되지 않은 입니다.</target>
        </trans-unit>
        <trans-unit id="0aa8d4b081c0f21cabda208483e50d393282d028" translate="yes" xml:space="preserve">
          <source>True if SCE is enabled, false otherwise.</source>
          <target state="translated">SCE가 활성화되어 있으면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="9974e802cce85a25ca164e8503f6d27e58b29226" translate="yes" xml:space="preserve">
          <source>True if SCE is enabled, false otherwise. If you want to set the value, you have to do it at module config time on &lt;a href=&quot;../provider/%24sceprovider&quot;&gt;$sceProvider&lt;/a&gt;.</source>
          <target state="translated">SCE가 활성화되어 있으면 true이고, 그렇지 않으면 false입니다. 값을 설정하려면 &lt;a href=&quot;../provider/%24sceprovider&quot;&gt;$ sceProvider의&lt;/a&gt; 모듈 구성 시간에 설정해야합니다. .</target>
        </trans-unit>
        <trans-unit id="7b26669371aa537bd9fb78e54420fba225d69357" translate="yes" xml:space="preserve">
          <source>True if all of the containing forms and controls are valid.</source>
          <target state="translated">포함하는 모든 폼과 컨트롤이 유효한 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="43aa5083507a3dfc1a3cb7fdf232cd1f4bf4e91f" translate="yes" xml:space="preserve">
          <source>True if arguments are equal.</source>
          <target state="translated">인수가 같으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="9d333018eec7b900f39b653771161777b87197ae" translate="yes" xml:space="preserve">
          <source>True if at least one containing control or form is invalid.</source>
          <target state="translated">컨트롤이나 폼을 포함하는 하나 이상이 유효하지 않은 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="181d1025fe366a64c937b96da6ec883bbf6e7ba0" translate="yes" xml:space="preserve">
          <source>True if at least one error on the control.</source>
          <target state="translated">컨트롤에 오류가 하나 이상 있으면 true입니다.</target>
        </trans-unit>
        <trans-unit id="56ff20210bccab95fcbf58367144ac067af68148" translate="yes" xml:space="preserve">
          <source>True if control has lost focus.</source>
          <target state="translated">컨트롤의 포커스가 없으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="c7fbe9ee2795fbddf37ec8d8c2d62f113e612f3b" translate="yes" xml:space="preserve">
          <source>True if control has not lost focus yet.</source>
          <target state="translated">컨트롤이 아직 포커스를 잃지 않은 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa62205eae963b6a217b7f9c96dcf716528f35e" translate="yes" xml:space="preserve">
          <source>True if there is no error.</source>
          <target state="translated">오류가 없으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="25ffcfd59486b9a5399542b4690b410851ea2474" translate="yes" xml:space="preserve">
          <source>True if user has already interacted with the control.</source>
          <target state="translated">사용자가 이미 컨트롤과 상호 작용 한 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="dbcbfbb295b5a8ea5518852d000e90ababb1c7f2" translate="yes" xml:space="preserve">
          <source>True if user has already interacted with the form.</source>
          <target state="translated">사용자가 이미 양식과 상호 작용 한 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="29b344f09475639539f4e83c2d015aaaed0bbd1d" translate="yes" xml:space="preserve">
          <source>True if user has not interacted with the control yet.</source>
          <target state="translated">사용자가 아직 컨트롤과 상호 작용하지 않은 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="635c3755d9bde31ca73c1d749bc707a37d18b709" translate="yes" xml:space="preserve">
          <source>True if user has not interacted with the form yet.</source>
          <target state="translated">사용자가 아직 양식과 상호 작용하지 않은 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="65825ee641a9445d6459e2ab76bdc68b70985738" translate="yes" xml:space="preserve">
          <source>True if user has submitted the form even if its invalid.</source>
          <target state="translated">사용자가 유효하지 않은 양식을 제출 한 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="b88445bdd7bea1365372168f7dbf74b80d853d03" translate="yes" xml:space="preserve">
          <source>Try it here: enter text in text box and watch the greeting change.</source>
          <target state="translated">여기에 시도하십시오 : 텍스트 상자에 텍스트를 입력하고 인사말이 바뀌는 것을보십시오.</target>
        </trans-unit>
        <trans-unit id="df5a54a82b0bebef0de0f478ec3ab5b4c9f5c3ea" translate="yes" xml:space="preserve">
          <source>Try out the Live Preview above, and then let's walk through the example and describe what's going on.</source>
          <target state="translated">위의 라이브 미리보기를 시도한 다음 예제를 살펴보고 진행 상황을 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="5392c950bdde4be7e5f5b8fdc6a1ca5f21e905cf" translate="yes" xml:space="preserve">
          <source>Twitter</source>
          <target state="translated">Twitter</target>
        </trans-unit>
        <trans-unit id="96e344023c95f59d40b4739ed0a85a635eee1b78" translate="yes" xml:space="preserve">
          <source>Two different declaration styles are included below:</source>
          <target state="translated">두 가지 다른 선언 스타일이 아래에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb76bbc89ca1321805d931b227686253a851eed" translate="yes" xml:space="preserve">
          <source>Two objects or values are considered equivalent if at least one of the following is true:</source>
          <target state="translated">다음 중 하나 이상에 해당하면 두 객체 또는 값이 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="85d3dd1c7508b8b456f004ed6161495afea6f854" translate="yes" xml:space="preserve">
          <source>Two-way binding to $location</source>
          <target state="translated">$ location에 대한 양방향 바인딩</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="e80662327a53bb36ba8ecc569bceb07d8d355e87" translate="yes" xml:space="preserve">
          <source>Type components in ng</source>
          <target state="translated">ng의 유형 구성 요소</target>
        </trans-unit>
        <trans-unit id="a435bd7da8a147120f1a4b79e547e5c008143436" translate="yes" xml:space="preserve">
          <source>Type components in ngComponentRouter</source>
          <target state="translated">ngComponentRouter의 유형 구성 요소</target>
        </trans-unit>
        <trans-unit id="50a5d371f802a731c130768b7356728d742c17f8" translate="yes" xml:space="preserve">
          <source>Type components in ngMock</source>
          <target state="translated">ngMock의 유형 구성 요소</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="a37965c6d74cd91c105a5af7d17ac48c2ae2ac45" translate="yes" xml:space="preserve">
          <source>Typical usage</source>
          <target state="translated">일반적인 사용법</target>
        </trans-unit>
        <trans-unit id="c8d61bd71fa3d7cafbb7128d3d9893fb96df94a4" translate="yes" xml:space="preserve">
          <source>Typically beforeAll is used to make many assertions about a single operation. This can cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed tests each with a single assertion.</source>
          <target state="translated">일반적으로 beforeAll은 단일 작업에 대해 많은 어설 션을 만드는 데 사용됩니다. 테스트 설정을 다시 실행할 필요가없고 테스트를 한 번만 수행하면 집중 테스트를 수행 할 수 있으므로 테스트 런타임을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6f0ae9524ce6acd2d2f63e97dbf18fe3aca600b" translate="yes" xml:space="preserve">
          <source>Typically, when you create an application you need to set up the initial state for the AngularJS &lt;code&gt;$scope&lt;/code&gt;. You set up the initial state of a scope by attaching properties to the &lt;code&gt;$scope&lt;/code&gt; object. The properties contain the &lt;strong&gt;view model&lt;/strong&gt; (the model that will be presented by the view). All the &lt;code&gt;$scope&lt;/code&gt; properties will be available to the &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; at the point in the DOM where the Controller is registered.</source>
          <target state="translated">일반적으로 애플리케이션을 작성할 때 AngularJS &lt;code&gt;$scope&lt;/code&gt; 의 초기 상태를 설정해야합니다 . &lt;code&gt;$scope&lt;/code&gt; 객체에 속성을 첨부하여 범위의 초기 상태를 설정 합니다. 속성에는 &lt;strong&gt;뷰 모델&lt;/strong&gt; ( &lt;strong&gt;뷰에서&lt;/strong&gt; 제공 할 모델)이 포함됩니다. 컨트롤러가 등록 된 DOM의 시점에서 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 에 모든 &lt;code&gt;$scope&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82ca3e622f497504b13ae95ba5174ca088e4d1be" translate="yes" xml:space="preserve">
          <source>Typically, you don't use &lt;code&gt;ngBind&lt;/code&gt; directly, but instead you use the double curly markup like &lt;code&gt;{{ expression }}&lt;/code&gt; which is similar but less verbose.</source>
          <target state="translated">일반적으로 &lt;code&gt;ngBind&lt;/code&gt; 를 직접 사용 하지는 않지만 비슷하지만 덜 장황한 &lt;code&gt;{{ expression }}&lt;/code&gt; 과 같이 이중 곱슬 마크 업을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f6a19ff69e8d695fff05426906779eaaae870446" translate="yes" xml:space="preserve">
          <source>Typically, you would call this method following each test case that asserts requests using an &quot;afterEach&quot; clause.</source>
          <target state="translated">일반적으로 &quot;afterEach&quot;절을 사용하여 요청을 주장하는 각 테스트 사례에 따라이 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7fdf8e24fee9641029d910c77e727fa987ff0d84" translate="yes" xml:space="preserve">
          <source>Typically, you would configure or override the &lt;a href=&quot;%24scedelegate&quot;&gt;$sceDelegate&lt;/a&gt; instead of the &lt;code&gt;$sce&lt;/code&gt; service to customize the way Strict Contextual Escaping works in AngularJS. This is because, while the &lt;code&gt;$sce&lt;/code&gt; provides numerous shorthand methods, etc., you really only need to override 3 core functions (&lt;code&gt;trustAs&lt;/code&gt;, &lt;code&gt;getTrusted&lt;/code&gt; and &lt;code&gt;valueOf&lt;/code&gt;) to replace the way things work because &lt;code&gt;$sce&lt;/code&gt; delegates to &lt;code&gt;$sceDelegate&lt;/code&gt; for these operations.</source>
          <target state="translated">일반적으로 &lt;code&gt;$sce&lt;/code&gt; 서비스 대신 &lt;a href=&quot;%24scedelegate&quot;&gt;$ sceDelegate&lt;/a&gt; 를 구성하거나 무시하여 AngularJS에서 엄격한 컨텍스트 이스케이프 작동 방식을 사용자 정의합니다. 이것은 &lt;code&gt;$sce&lt;/code&gt; 가 수많은 속기 메소드 등을 제공 하지만 $ sce 가 이러한 작업 을 위해 &lt;code&gt;$sceDelegate&lt;/code&gt; 에 위임하기 때문에 3 가지 핵심 함수 ( &lt;code&gt;trustAs&lt;/code&gt; , &lt;code&gt;getTrusted&lt;/code&gt; 및 &lt;code&gt;valueOf&lt;/code&gt; )를 대체하여 작동 방식을 대체하기 만하면 되기 때문 &lt;code&gt;$sce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4949e7b471c62f07ef5e8f49abbfc90b2fcee84d" translate="yes" xml:space="preserve">
          <source>URL format</source>
          <target state="translated">URL 형식</target>
        </trans-unit>
        <trans-unit id="e18613f7569df4e87d46ab0c50bd2f0aa9fd3721" translate="yes" xml:space="preserve">
          <source>URL of content to load.</source>
          <target state="translated">로드 할 콘텐츠의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="30e531717661ab3417ebc4cbe0c1de475ab6be26" translate="yes" xml:space="preserve">
          <source>URL of the request.</source>
          <target state="translated">요청의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="d7bbc289db7f0b0052507421a9bcb3e65c45c45e" translate="yes" xml:space="preserve">
          <source>URL that was before it was changed.</source>
          <target state="translated">변경되기 전의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="218f37ac7c7d3d4188879070d19d295a2d90c29a" translate="yes" xml:space="preserve">
          <source>Under the hood</source>
          <target state="translated">후드</target>
        </trans-unit>
        <trans-unit id="443978f12d579b038c008dea8e752b5d3e01d6d0" translate="yes" xml:space="preserve">
          <source>Understanding How Scopes Work with Transcluded Directives</source>
          <target state="translated">범위가 포함 된 지시문과 작동하는 방식 이해</target>
        </trans-unit>
        <trans-unit id="b476afa4e9575435e81ebe1e34e1ccc258d54e8e" translate="yes" xml:space="preserve">
          <source>Understanding Scopes</source>
          <target state="translated">범위 이해</target>
        </trans-unit>
        <trans-unit id="3aea8612a3778098d091872872cceefb5e6bd7de" translate="yes" xml:space="preserve">
          <source>Understanding View</source>
          <target state="translated">보기 이해</target>
        </trans-unit>
        <trans-unit id="629ffb1444dbbb1b0dac1c29021a48b25b040df3" translate="yes" xml:space="preserve">
          <source>Unique scope ID (monotonically increasing) useful for debugging.</source>
          <target state="translated">디버깅에 유용한 고유 범위 ID (단일 증가).</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="3b563841706d01128f360a08ae70337b23f59c44" translate="yes" xml:space="preserve">
          <source>Unit testing with mock $httpBackend</source>
          <target state="translated">모의 $ httpBackend로 단위 테스트</target>
        </trans-unit>
        <trans-unit id="03f9dd1dbb0519b8fb0d50867eeaf9173813a3e3" translate="yes" xml:space="preserve">
          <source>Unit testing, as the name implies, is about testing individual units of code. Unit tests try to answer questions such as &quot;Did I think about the logic correctly?&quot; or &quot;Does the sort function order the list in the right order?&quot;</source>
          <target state="translated">단위 테스트는 이름에서 알 수 있듯이 개별 코드 단위를 테스트하는 것입니다. 단위 테스트는 &quot;논리에 대해 올바르게 생각 했습니까?&quot;와 같은 질문에 답하려고합니다. 또는 &quot;정렬 기능이 목록을 올바른 순서로 정렬합니까?&quot;</target>
        </trans-unit>
        <trans-unit id="57c368e336d005ba762d838d65c9d99e26f84dac" translate="yes" xml:space="preserve">
          <source>Unit tests only have to load relevant modules, which keeps them fast.</source>
          <target state="translated">단위 테스트는 관련 모듈 만로드하면되므로 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="3fb4e286e502a759b76367b0dba26a4db6774e6a" translate="yes" xml:space="preserve">
          <source>Unit-testing Component Controllers</source>
          <target state="translated">단위 테스트 구성 요소 컨트롤러</target>
        </trans-unit>
        <trans-unit id="c532fb030d4057cff1a4adcec6eb4756fc91ef75" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;angular.extend&quot;&gt;extend()&lt;/a&gt;, &lt;code&gt;merge()&lt;/code&gt; recursively descends into object properties of source objects, performing a deep copy.</source>
          <target state="translated">달리 &lt;a href=&quot;angular.extend&quot;&gt;확장 ()&lt;/a&gt; , &lt;code&gt;merge()&lt;/code&gt; 재귀 전체 복사본을 수행 소스 객체의 객체 속성에 가져갈.</target>
        </trans-unit>
        <trans-unit id="c99e4d44f0c339bd48a75c15f4c96bd079f56c71" translate="yes" xml:space="preserve">
          <source>Unlike ES262's &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18&quot;&gt;Array.prototype.forEach&lt;/a&gt;, providing 'undefined' or 'null' values for &lt;code&gt;obj&lt;/code&gt; will not throw a TypeError, but rather just return the value provided.</source>
          <target state="translated">ES262의 달리 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18&quot;&gt;Array.prototype.forEach&lt;/a&gt; 제공하는 '정의되지 않은'나에 대한 '널 (null)'값 &lt;code&gt;obj&lt;/code&gt; TypeError가 던져 아니라 방금 입력 한 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="209c8097836b9258765844c6a5792b2eb42a2408" translate="yes" xml:space="preserve">
          <source>Unlike services, there can be many instances of the same type of controller in an application.</source>
          <target state="translated">서비스와 달리 응용 프로그램에는 동일한 유형의 컨트롤러 인스턴스가 많이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ae88da458d1d682765ae9e4d1fc2981948283c" translate="yes" xml:space="preserve">
          <source>Unlike simple values, object-literals are watched until every key is defined. See &lt;a href=&quot;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&quot;&gt;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&lt;/a&gt;</source>
          <target state="translated">단순한 값과 달리, 모든 키가 정의 될 때까지 객체 리터럴이 감시됩니다. &lt;a href=&quot;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm&quot;&gt;http://www.bennadel.com/blog/2760-one-time-data-bindings-for-object-literal-expressions-in-angularjs-1-3.htm을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73ae224e8735ac30c004ffdc6115aecdf9718361" translate="yes" xml:space="preserve">
          <source>Up until AngularJS 1.3, &lt;code&gt;$cookies&lt;/code&gt; exposed properties that represented the current browser cookie values. In version 1.4, this behavior has changed, and &lt;code&gt;$cookies&lt;/code&gt; now provides a standard api of getters, setters etc.</source>
          <target state="translated">AngularJS 1.3까지 &lt;code&gt;$cookies&lt;/code&gt; 는 현재 브라우저 쿠키 값을 나타내는 속성을 노출했습니다. 버전 1.4에서는이 동작이 변경되었으며 &lt;code&gt;$cookies&lt;/code&gt; 이제 getter, setter 등의 표준 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a24966329bd38080b15cb29a9d8d9bbe7a67aba" translate="yes" xml:space="preserve">
          <source>Update the view value.</source>
          <target state="translated">보기 값을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="48d94c781db18d8b60bf067bb589536cbf58bd78" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. This method is rarely needed as &lt;code&gt;NgModelController&lt;/code&gt; usually handles calling this in response to input events.</source>
          <target state="translated">디 바운스 된 이벤트에 의해 또는 입력이 &lt;code&gt;ng-model-options&lt;/code&gt; 에 정의 된 일부 미래 이벤트를 기다리는 중이므로 업데이트가 보류 중일 수 있습니다 . &lt;code&gt;NgModelController&lt;/code&gt; 는 일반적으로 입력 이벤트에 대한 응답으로 이것을 호출하기 때문에이 메소드는 거의 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a5ece24f05232383c973b3dcd8d5ec955602e4f9" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. This method is typically needed by the reset button of a form that uses &lt;code&gt;ng-model-options&lt;/code&gt; to pend updates.</source>
          <target state="translated">디 바운스 된 이벤트에 의해 또는 입력이 &lt;code&gt;ng-model-options&lt;/code&gt; 에 정의 된 일부 미래 이벤트를 기다리는 중이므로 업데이트가 보류 중일 수 있습니다 . 이 방법은 일반적으로 &lt;code&gt;ng-model-options&lt;/code&gt; 를 사용하여 업데이트를 보류 하는 양식의 재설정 단추에 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="c32c26b09b60884932de0735cac06908d3f7ccf0" translate="yes" xml:space="preserve">
          <source>Updates may be pending by a debounced event or because the input is waiting for a some future event defined in &lt;code&gt;ng-model-options&lt;/code&gt;. this method is rarely needed as &lt;code&gt;NgModelController&lt;/code&gt; usually handles calling this in response to input events.</source>
          <target state="translated">디 바운스 된 이벤트에 의해 또는 입력이 &lt;code&gt;ng-model-options&lt;/code&gt; 에 정의 된 일부 미래 이벤트를 기다리는 중이므로 업데이트가 보류 중일 수 있습니다 . &lt;code&gt;NgModelController&lt;/code&gt; 는 일반적으로 입력 이벤트에 대한 응답으로 이것을 호출하기 때문에이 메소드는 거의 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e78c2b095e755aab9f8caa006dd4fd278929ad41" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;%24interval#flush.html&quot;&gt;&lt;code&gt;$interval.flush(millis)&lt;/code&gt;&lt;/a&gt; to move forward by &lt;code&gt;millis&lt;/code&gt; milliseconds and trigger any functions scheduled to run in that time.</source>
          <target state="translated">&lt;a href=&quot;%24interval#flush.html&quot;&gt; &lt;code&gt;$interval.flush(millis)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;millis&lt;/code&gt; 초 단위 로 앞으로 이동 하고 해당 시간에 실행되도록 예약 된 기능을 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="9d10cf3ebaf3f699b7cd183a40113d2096935796" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../provider/%24interpolateprovider#endSymbol.html&quot;&gt;&lt;code&gt;$interpolateProvider.endSymbol&lt;/code&gt;&lt;/a&gt; to change the symbol.</source>
          <target state="translated">사용 &lt;a href=&quot;../provider/%24interpolateprovider#endSymbol.html&quot;&gt; &lt;code&gt;$interpolateProvider.endSymbol&lt;/code&gt; &lt;/a&gt; 기호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d014a1c84c0cea27fad3b0edad9bcbb55cee2222" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../provider/%24interpolateprovider#startSymbol.html&quot;&gt;&lt;code&gt;$interpolateProvider.startSymbol&lt;/code&gt;&lt;/a&gt; to change the symbol.</source>
          <target state="translated">사용 &lt;a href=&quot;../provider/%24interpolateprovider#startSymbol.html&quot;&gt; &lt;code&gt;$interpolateProvider.startSymbol&lt;/code&gt; &lt;/a&gt; 기호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6a641c4af45db61a4d45240e4bc451c61620dd29" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ngswitch&quot;&gt;&lt;code&gt;ngSwitch&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ngswitch&quot;&gt; &lt;code&gt;ngSwitch&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="218b05a9d83c943a410d416413419b99ab64cf02" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$anchorScrollProvider&lt;/code&gt; to disable automatic scrolling whenever &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; changes.</source>
          <target state="translated">&lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$ location.hash ()가&lt;/a&gt; 변경 될 때마다 자동 스크롤을 비활성화 하려면 &lt;code&gt;$anchorScrollProvider&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b968b0787da9eecc71135a165258514b44ef0734" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$anchorScrollProvider&lt;/code&gt; to disable automatic scrolling whenever &lt;a href=&quot;service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; changes.</source>
          <target state="translated">&lt;a href=&quot;service/%24location#hash.html&quot;&gt;$ location.hash ()가&lt;/a&gt; 변경 될 때마다 자동 스크롤을 비활성화 하려면 &lt;code&gt;$anchorScrollProvider&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="354512147e4e601cc546a9ec65841a61f9421903" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$cookiesProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;../service/%24cookies&quot;&gt;$ cookies&lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a148f7331f736ce00c51361a431bda51bee1ed1d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$cookiesProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt;$ cookies&lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef936e3e20232f9a1650cc302f357cad6c4156ca" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$cookiesProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24cookies&quot;&gt;$cookies&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$cookiesProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;service/%24cookies&quot;&gt;$ cookies&lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="15fb01e25077c75bad5d011e5094bc75c8f3d896" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$httpProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$httpProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;../service/%24http&quot;&gt;$ http&lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="687465cea5c0906f2e3249d57fd88fb9d657fefe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$httpProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24http&quot;&gt;$http&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$httpProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;service/%24http&quot;&gt;$ http&lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="2392b2da1088beefbc29590ab2eda9ddba143d0a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;../service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$resourceProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;../service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="b88771011fc3cd5358447dc36675101538ddffcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;ngresource/service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$resourceProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;ngresource/service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ca460ac7b4debf1921b9d34cfa7a7f3a1ebd02a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$resourceProvider&lt;/code&gt; to change the default behavior of the &lt;a href=&quot;service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;$resourceProvider&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 서비스 의 기본 동작을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc1ec7cfcbd0280881371f3aa4ee3069843966fe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ng-class=&quot;{'ng-hide': expression}&lt;/code&gt; instead of instead of &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;ng-class=&quot;{'ng-hide': expression}&lt;/code&gt; 대신 대신 &lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="252932316ac080237bfbd49d94e69b42c8202774" translate="yes" xml:space="preserve">
          <source>Use controllers to:</source>
          <target state="translated">컨트롤러를 사용하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ec78e24bb1beaec2fff0a05e747e3a518fdbd042" translate="yes" xml:space="preserve">
          <source>Use sharedInjector when you want to take advantage of Jasmine's &lt;code&gt;beforeAll()&lt;/code&gt;, or mocha's &lt;code&gt;before()&lt;/code&gt; methods. Call &lt;code&gt;module.sharedInjector()&lt;/code&gt; before you setup any other hooks that will create (i.e call &lt;code&gt;module()&lt;/code&gt;) or use (i.e call &lt;code&gt;inject()&lt;/code&gt;) the injector.</source>
          <target state="translated">Jasmine의 &lt;code&gt;beforeAll()&lt;/code&gt; 또는 mocha의 &lt;code&gt;before()&lt;/code&gt; 메소드를 활용하려면 sharedInjector를 사용하십시오 . 전화 &lt;code&gt;module.sharedInjector()&lt;/code&gt; 이 설정 (즉, 호출이 생성됩니다 다른 후크 전에 &lt;code&gt;module()&lt;/code&gt; ) 또는 사용 (예 : 콜 &lt;code&gt;inject()&lt;/code&gt; ) 인젝터를.</target>
        </trans-unit>
        <trans-unit id="eb362d3d265854877b73c2022104238b8f662f3f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$locationProvider&lt;/code&gt; to configure how the application deep linking paths are stored.</source>
          <target state="translated">&lt;code&gt;$locationProvider&lt;/code&gt; 를 사용하여 응용 프로그램 딥 링크 경로가 저장되는 방법을 구성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a7084daedcbcf3cf58f8478d3a4ef6d9e3042e1" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$logProvider&lt;/code&gt; to configure how the application logs messages</source>
          <target state="translated">&lt;code&gt;$logProvider&lt;/code&gt; 를 사용하여 응용 프로그램이 메시지를 기록하는 방법을 구성 하십시오.</target>
        </trans-unit>
        <trans-unit id="359920a71e60b24c3e8679f4d1142b9de40dfe80" translate="yes" xml:space="preserve">
          <source>Use the latest AngularJS possible</source>
          <target state="translated">최신 AngularJS를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="9d4a7cc07d13aee2118147eae5b6204e02526bb6" translate="yes" xml:space="preserve">
          <source>Use the special CSS selector &lt;code&gt;ng-hide.ng-hide-animate&lt;/code&gt; to set &lt;code&gt;{display: none}&lt;/code&gt; or similar on the affected elements.</source>
          <target state="translated">특수 CSS 선택기 &lt;code&gt;ng-hide.ng-hide-animate&lt;/code&gt; 를 사용 하여 영향을받는 요소에 &lt;code&gt;{display: none}&lt;/code&gt; 또는 이와 유사한 것을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01b6831d8484c409e8aabc8e2f585a365a461d33" translate="yes" xml:space="preserve">
          <source>Use this directive to &lt;strong&gt;auto-bootstrap&lt;/strong&gt; an AngularJS application. The &lt;code&gt;ngApp&lt;/code&gt; directive designates the &lt;strong&gt;root element&lt;/strong&gt; of the application and is typically placed near the root element of the page - e.g. on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">AngularJS 응용 프로그램 을 &lt;strong&gt;자동 부트 스트랩&lt;/strong&gt; 하려면이 지정 문을 사용하십시오 . &lt;code&gt;ngApp&lt;/code&gt; 의 지시어는 지정 &lt;strong&gt;루트 요소&lt;/strong&gt; 예를에 - 응용 프로그램을 일반적으로 페이지의 루트 요소 근처에 배치되어 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그입니다.</target>
        </trans-unit>
        <trans-unit id="cffba56063404188829cf8f1f82edf386bbc1e59" translate="yes" xml:space="preserve">
          <source>Use this directive to force the angular.element library. This should be used to force either jqLite by leaving ng-jq blank or setting the name of the jquery variable under window (eg. jQuery).</source>
          <target state="translated">이 지시문을 사용하여 angular.element 라이브러리를 강제 실행하십시오. 이것은 ng-jq를 비워 두거나 창 아래에 jquery 변수의 이름을 설정하여 jqLite를 강제 실행하는 데 사용해야합니다 (예 : jQuery).</target>
        </trans-unit>
        <trans-unit id="294fecfb6e5d5ea18318309468bfa41aee69ee2b" translate="yes" xml:space="preserve">
          <source>Use this function to manually start up AngularJS application.</source>
          <target state="translated">AngularJS 애플리케이션을 수동으로 시작하려면이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6f82f5bd67956f87473eb69dd807927f89430cf" translate="yes" xml:space="preserve">
          <source>Use this function to reload the current application with debug information turned on. This takes precedence over a call to &lt;code&gt;$compileProvider.debugInfoEnabled(false)&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하여 디버그 정보가 설정된 상태에서 현재 응용 프로그램을 다시로드하십시오. 이것은 &lt;code&gt;$compileProvider.debugInfoEnabled(false)&lt;/code&gt; 호출보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="d5a771a46afd23a79112854e27f186a09e2c9ba1" translate="yes" xml:space="preserve">
          <source>Use this method to configure services by injecting their &lt;a href=&quot;angular.module#provider.html&quot;&gt;&lt;code&gt;providers&lt;/code&gt;&lt;/a&gt;, e.g. for adding routes to the &lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt;$routeProvider&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt;$ routeProvider에&lt;/a&gt; 경로를 추가하기 위해 &lt;a href=&quot;angular.module#provider.html&quot;&gt; &lt;code&gt;providers&lt;/code&gt; &lt;/a&gt; 를 주입하여 서비스를 구성하려면이 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94c8a5728df153aa8ef0f96f8c05e84b03dfd3da" translate="yes" xml:space="preserve">
          <source>Use this method to disable automatic scrolling.</source>
          <target state="translated">이 방법을 사용하여 자동 스크롤을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="b46c8e2625e9d1d564150470d764ef83f44ed6cd" translate="yes" xml:space="preserve">
          <source>Use this method to register work which should be performed when the injector is done loading all modules.</source>
          <target state="translated">인젝터가 모든 모듈의 로딩을 완료했을 때 수행해야하는 작업을 등록하려면이 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e2c9ca4a68dc2a6884892d41b5a73fcdd5783521" translate="yes" xml:space="preserve">
          <source>Used for configuring routes.</source>
          <target state="translated">경로를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e20f817510e56e9b96cac2070c3e22126811c3b" translate="yes" xml:space="preserve">
          <source>Used for configuring the ARIA attributes injected and managed by ngAria.</source>
          <target state="translated">ngAria가 주입하고 관리하는 ARIA 속성을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="655c8e5a053e43f0c11ecfabef9bcc1912abfe26" translate="yes" xml:space="preserve">
          <source>Used for configuring the interpolation markup. Defaults to &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">보간 마크 업을 구성하는 데 사용됩니다. 기본값은 &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1fb44e414995a58ae7d8e047aff02bcff4d56e5c" translate="yes" xml:space="preserve">
          <source>Used to configure the options passed to the &lt;a href=&quot;../service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making a template request.</source>
          <target state="translated">템플릿 요청을 할 때 &lt;a href=&quot;../service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 서비스에 전달 된 옵션을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e98fe6396bfb3427cbaf00c58b5487eb76c4659a" translate="yes" xml:space="preserve">
          <source>Used to configure the options passed to the &lt;a href=&quot;service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; service when making a template request.</source>
          <target state="translated">템플릿 요청을 할 때 &lt;a href=&quot;service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 서비스에 전달 된 옵션을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1992cf3bd475bebb63dff75def762449cd8f0921" translate="yes" xml:space="preserve">
          <source>Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This function can be called in four ways:</source>
          <target state="translated">전체 응용 프로그램이나 요소 및 해당 자식에서 애니메이션을 사용할지 여부를 가져오고 설정하는 데 사용됩니다. 이 함수는 다음 네 가지 방법으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ca86ada0f9252bb106a6e6efdbff01c4a20438" translate="yes" xml:space="preserve">
          <source>Using $animate in your directive code</source>
          <target state="translated">지시문 코드에서 $ animate 사용</target>
        </trans-unit>
        <trans-unit id="613a81888b42fb0d4ca5df60f2f42af801bb1b12" translate="yes" xml:space="preserve">
          <source>Using $location</source>
          <target state="translated">$ location 사용</target>
        </trans-unit>
        <trans-unit id="27c0cbbddba59723567250ee8aaf043d300dad88" translate="yes" xml:space="preserve">
          <source>Using $location outside of the scope life-cycle</source>
          <target state="translated">스코프 수명주기 외부에서 $ location 사용</target>
        </trans-unit>
        <trans-unit id="29169efc69847444ce3da0120339548bb93f2578" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../api/ngaria&quot;&gt;ngAria&lt;/a&gt; is as simple as requiring the ngAria module in your application. ngAria hooks into standard AngularJS directives and quietly injects accessibility support into your application at runtime.</source>
          <target state="translated">&lt;a href=&quot;../api/ngaria&quot;&gt;ngAria를&lt;/a&gt; 사용 하는 것은 어플리케이션에 ngAria 모듈을 요구하는 것만 큼 간단합니다. ngAria는 표준 AngularJS 지시문에 연결하고 런타임시 애플리케이션에 접근성 지원을 자동으로 주입합니다.</target>
        </trans-unit>
        <trans-unit id="187503b822cc41efce6fddb7ffa2ed2aec83c324" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;controller as&lt;/code&gt; makes it obvious which controller you are accessing in the template when multiple controllers apply to an element.</source>
          <target state="translated">&lt;code&gt;controller as&lt;/code&gt; 사용 하면 여러 컨트롤러가 요소에 적용될 때 템플릿에서 어떤 컨트롤러에 액세스하고 있는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75fa788af800c949aecf96d72fda73c3d6a4da58" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ngStrictDi&lt;/code&gt;, you would see something like this:</source>
          <target state="translated">&lt;code&gt;ngStrictDi&lt;/code&gt; 를 사용하면 다음과 같은 것을 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="618b214c025a81d4cdc55abe11cf88128651105c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt; will bind the result of the &lt;code&gt;select&lt;/code&gt; expression to the model, but the value of the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; html elements will be either the index (for array data sources) or property name (for object data sources) of the value within the collection. If a &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression is used, the result of that expression will be set as the value of the &lt;code&gt;option&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; 를 사용 하면 &lt;code&gt;select&lt;/code&gt; 표현식 의 결과가 모델에 바인딩 되지만 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; html 요소 의 값은 인덱스 (배열 데이터 소스의 경우) 또는 속성 이름 (객체 데이터 소스의 경우)이됩니다. 컬렉션 내의 값 식별 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 사용하는 경우 해당 식의 결과는 &lt;code&gt;option&lt;/code&gt; 및 &lt;code&gt;select&lt;/code&gt; 요소 의 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b48a3f6a40b09344260d8ec7bc24924a4a77ab6a" translate="yes" xml:space="preserve">
          <source>Using ARIA in HTML</source>
          <target state="translated">HTML에서 ARIA 사용</target>
        </trans-unit>
        <trans-unit id="c4171cbd1d6f3ea14fcb721dacfb4707975d43ea" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in a &lt;code&gt;src&lt;/code&gt; attribute doesn't work right: The browser will fetch from the URL with the literal text &lt;code&gt;{{hash}}&lt;/code&gt; until AngularJS replaces the expression inside &lt;code&gt;{{hash}}&lt;/code&gt;. The &lt;code&gt;ngSrc&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 속성 에서 &lt;code&gt;{{hash}}&lt;/code&gt; 와 같은 AngularJS 마크 업을 사용 하는 것은 제대로 작동하지 않습니다. AngularJS가 &lt;code&gt;{{hash}}&lt;/code&gt; 내부의 표현식을 대체 할 때까지 브라우저는 리터럴 텍스트 &lt;code&gt;{{hash}}&lt;/code&gt; 로 URL에서 가져옵니다 . &lt;code&gt;ngSrc&lt;/code&gt; 의 지시어는이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="1544e2d4e4ae1fb37109d1352ffdb29d3bc70e81" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in a &lt;code&gt;srcset&lt;/code&gt; attribute doesn't work right: The browser will fetch from the URL with the literal text &lt;code&gt;{{hash}}&lt;/code&gt; until AngularJS replaces the expression inside &lt;code&gt;{{hash}}&lt;/code&gt;. The &lt;code&gt;ngSrcset&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">&lt;code&gt;srcset&lt;/code&gt; 속성 에서 &lt;code&gt;{{hash}}&lt;/code&gt; 와 같은 AngularJS 마크 업을 사용하면 제대로 작동하지 않습니다. AngularJS가 &lt;code&gt;{{hash}}&lt;/code&gt; 내부의 표현식을 대체 할 때까지 브라우저는 리터럴 텍스트 &lt;code&gt;{{hash}}&lt;/code&gt; 로 URL에서 가져옵니다 . &lt;code&gt;ngSrcset&lt;/code&gt; 의 지시어는이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="1c81f10b2e8d7a29e274525eca136b9b2754c57d" translate="yes" xml:space="preserve">
          <source>Using AngularJS markup like &lt;code&gt;{{hash}}&lt;/code&gt; in an href attribute will make the link go to the wrong URL if the user clicks it before AngularJS has a chance to replace the &lt;code&gt;{{hash}}&lt;/code&gt; markup with its value. Until AngularJS replaces the markup the link will be broken and will most likely return a 404 error. The &lt;code&gt;ngHref&lt;/code&gt; directive solves this problem.</source>
          <target state="translated">href 속성에 &lt;code&gt;{{hash}}&lt;/code&gt; 와 같은 AngularJS 마크 업을 사용하면 AngularJS 가 &lt;code&gt;{{hash}}&lt;/code&gt; 마크 업을 해당 값 으로 대체하기 전에 사용자가 링크를 클릭하면 링크가 잘못된 URL로 이동 합니다. AngularJS가 마크 업을 교체 할 때까지 링크가 끊어지고 404 오류가 발생합니다. &lt;code&gt;ngHref&lt;/code&gt; 의 지시어는이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="26651671e648d817c38c64754ab40d68a2c9123a" translate="yes" xml:space="preserve">
          <source>Using CSS classes</source>
          <target state="translated">CSS 클래스 사용</target>
        </trans-unit>
        <trans-unit id="22c59955943e9707b80f15aec8a1b0a32409db33" translate="yes" xml:space="preserve">
          <source>Using Dependency Injection</source>
          <target state="translated">의존성 주입 사용</target>
        </trans-unit>
        <trans-unit id="3f12d56b74c2eb2c6b5988dda7a6704cc676d3d4" translate="yes" xml:space="preserve">
          <source>Using Factory recipes, you can also define AngularJS's filters and animations, but the controllers are a bit special. You create a controller as a custom type that declares its dependencies as arguments for its constructor function. This constructor is then registered with a module. Let's take a look at the &lt;code&gt;DemoController&lt;/code&gt;, created in one of the early examples:</source>
          <target state="translated">팩토리 레시피를 사용하여 AngularJS의 필터와 애니메이션을 정의 할 수도 있지만 컨트롤러는 약간 특별합니다. 컨트롤러를 생성자 함수의 인수로 선언하는 컨트롤러를 커스텀 타입으로 생성합니다. 그런 다음이 생성자는 모듈에 등록됩니다. 초기 예제 중 하나에서 생성 된 &lt;code&gt;DemoController&lt;/code&gt; 를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="142274a4bb4939c13a749da4226dd8927425fd22" translate="yes" xml:space="preserve">
          <source>Using Local Caches</source>
          <target state="translated">로컬 캐시 사용</target>
        </trans-unit>
        <trans-unit id="e8729bc93021a2e5283ed88952093ee0c9a0a8f3" translate="yes" xml:space="preserve">
          <source>Using Protractor</source>
          <target state="translated">각도기 사용</target>
        </trans-unit>
        <trans-unit id="cf6f695a6a43d5695aeb78a9aefcac36d5324914" translate="yes" xml:space="preserve">
          <source>Using Strict Dependency Injection</source>
          <target state="translated">엄격한 의존성 주입 사용</target>
        </trans-unit>
        <trans-unit id="9e041c266624208fa4e65afd24d87690238c5434" translate="yes" xml:space="preserve">
          <source>Using a Service</source>
          <target state="translated">서비스 사용</target>
        </trans-unit>
        <trans-unit id="1870160824edb5f5d781284d76bb684b36c8a3ae" translate="yes" xml:space="preserve">
          <source>Using a custom comparator</source>
          <target state="translated">커스텀 비교기 사용</target>
        </trans-unit>
        <trans-unit id="1513de7002759ec420dfa96ea93dd443a199efcb" translate="yes" xml:space="preserve">
          <source>Using an element for the &lt;code&gt;myCustomer&lt;/code&gt; directive is clearly the right choice because you're not decorating an element with some &quot;customer&quot; behavior; you're defining the core behavior of the element as a customer component.</source>
          <target state="translated">&quot;고객&quot;동작 으로 요소를 &lt;code&gt;myCustomer&lt;/code&gt; 않기 때문에 myCustomer 지시문에 요소를 사용하는 것이 분명히 올바른 선택입니다. 요소의 핵심 동작을 고객 구성 요소로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0b7f582cdde801c5eb7ccd1f5f093fd2b744221d" translate="yes" xml:space="preserve">
          <source>Using beforeAll()</source>
          <target state="translated">beforeAll () 사용</target>
        </trans-unit>
        <trans-unit id="3bf81a946b8d6c54f33bc47f1e13b86d15e48e46" translate="yes" xml:space="preserve">
          <source>Using filters in controllers, services, and directives</source>
          <target state="translated">컨트롤러, 서비스 및 지시문에서 필터 사용</target>
        </trans-unit>
        <trans-unit id="e5733313ce1e48569bbeb7efa880f179d91eb616" translate="yes" xml:space="preserve">
          <source>Using filters in view templates</source>
          <target state="translated">뷰 템플릿에서 필터 사용</target>
        </trans-unit>
        <trans-unit id="77968546fbbe30427c877e1f02f60fd695c65843" translate="yes" xml:space="preserve">
          <source>Using interceptors</source>
          <target state="translated">인터셉터 사용</target>
        </trans-unit>
        <trans-unit id="ebf3d55846a7cd7f43e5f8cb0e431673ff8d2495" translate="yes" xml:space="preserve">
          <source>Using ngAria</source>
          <target state="translated">ngAria 사용</target>
        </trans-unit>
        <trans-unit id="0f90dda5b5582c6398d02b0a5b0ebe328da00024" translate="yes" xml:space="preserve">
          <source>Using ngDisabled with ngAria:</source>
          <target state="translated">ngAria와 함께 ngDisabled 사용 :</target>
        </trans-unit>
        <trans-unit id="1937d07736980fa1e1cf14044c2d1eaa38088d68" translate="yes" xml:space="preserve">
          <source>Using ngRepeat to generate select options</source>
          <target state="translated">ngRepeat를 사용하여 선택 옵션 생성</target>
        </trans-unit>
        <trans-unit id="5f900837ceda875bf4c544ccac4d6058c4d6e857" translate="yes" xml:space="preserve">
          <source>Using ngValue to bind the model to an array of objects</source>
          <target state="translated">ngValue를 사용하여 모델을 객체 배열에 바인딩</target>
        </trans-unit>
        <trans-unit id="175501655ff7f1694fc035936c74e9c893e388e0" translate="yes" xml:space="preserve">
          <source>Using orderBy inside a controller</source>
          <target state="translated">컨트롤러 내부에서 orderBy 사용</target>
        </trans-unit>
        <trans-unit id="e38d72e573ba15e9d4f27541cef1ca49dafb855c" translate="yes" xml:space="preserve">
          <source>Using select with ngOptions and setting a default value</source>
          <target state="translated">ngOptions와 함께 select 사용 및 기본값 설정</target>
        </trans-unit>
        <trans-unit id="0726f73ae0c0e6e634886be4cf9fd3ceb9cfeaff" translate="yes" xml:space="preserve">
          <source>Using strict di mode in your production application will throw errors when an injectable function is not &lt;a href=&quot;di#dependency-annotation.html&quot;&gt;annotated explicitly&lt;/a&gt;. Strict di mode is intended to help you make sure that your code will work when minified. However, it also will force you to make sure that your injectable functions are explicitly annotated which will improve angular's performance when injecting dependencies in your injectable functions because it doesn't have to dynamically discover a function's dependencies. It is recommended to automate the explicit annotation via a tool like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; when you deploy to production (and enable strict di mode)</source>
          <target state="translated">프로덕션 응용 프로그램에서 엄격한 di 모드를 사용하면 주입 가능한 함수에 &lt;a href=&quot;di#dependency-annotation.html&quot;&gt;명시 적으로 주석을 달지&lt;/a&gt; 않은 경우 오류가 발생합니다 . 엄격 모드는 코드가 축소 될 때 작동하도록하기위한 것입니다. 그러나 또한 주입 가능 함수에 명시 적으로 주석을 달아 주입 가능 함수에 의존성을 주입 할 때 각도의 성능을 향상시켜 함수의 종속성을 동적으로 발견 할 필요가 없기 때문에 강제로 주석을 달아야합니다. 프로덕션에 배포 할 때 &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; 와 같은 도구를 통해 명시 적 주석을 자동화하고 엄격한 di 모드를 활성화 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c094e712cb148afcafcaaa4238f6b76abc53b26" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$inject&lt;/code&gt; property annotation</source>
          <target state="translated">은 Using &lt;code&gt;$inject&lt;/code&gt; 속성 주석을</target>
        </trans-unit>
        <trans-unit id="cc139db8875164b29e6054bd8d872efa13f3e432" translate="yes" xml:space="preserve">
          <source>Using the inline array annotation (preferred)</source>
          <target state="translated">인라인 배열 주석 사용 (권장)</target>
        </trans-unit>
        <trans-unit id="a32ba4858e6ecdf40bb878f10445086068b003aa" translate="yes" xml:space="preserve">
          <source>Using this mode requires URL rewriting on server side, basically you have to rewrite all your links to entry point of your application (e.g. index.html). Requiring a &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag is also important for this case, as it allows AngularJS to differentiate between the part of the url that is the application base and the path that should be handled by the application.</source>
          <target state="translated">이 모드를 사용하려면 서버 측에서 URL을 다시 작성해야합니다. 기본적으로 모든 링크를 응용 프로그램의 진입 점 (예 : index.html)에 다시 작성해야합니다. 요구 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 이 AngularJS 및 어플리케이션 기반 및 애플리케이션에 의해 처리되어야하는 경로 URL의 일부를 구별 할 수 있도록하는 태그로서,이 경우에 중요하다.</target>
        </trans-unit>
        <trans-unit id="dd90e467c164134d79cd404122f3459c75ef6850" translate="yes" xml:space="preserve">
          <source>Using your favorite element inspector, look for attributes added by ngAria in your own code.</source>
          <target state="translated">자주 사용하는 요소 검사기를 사용하여 자신의 코드에서 ngAria가 추가 한 속성을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a66911e37d51e0c3a3a47af728e0570297be65e2" translate="yes" xml:space="preserve">
          <source>Usually, it's not necessary to write to properties in AngularJS, as the built-in directives handle the most common use cases (instead of the above example, you would use &lt;a href=&quot;ngvalue&quot;&gt;&lt;code&gt;ngValue&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">내장 지시문이 가장 일반적인 사용 사례를 처리하므로 일반적으로 AngularJS의 속성에 쓸 필요는 없습니다 (위의 예제 대신 &lt;a href=&quot;ngvalue&quot;&gt; &lt;code&gt;ngValue&lt;/code&gt; 를&lt;/a&gt; 사용 합니다) ).</target>
        </trans-unit>
        <trans-unit id="9117e3d156ca57a740fa2681f3cbe9bcb779f7cd" translate="yes" xml:space="preserve">
          <source>Usually, you don't call &lt;code&gt;$digest()&lt;/code&gt; directly in &lt;a href=&quot;../directive/ngcontroller&quot;&gt;controllers&lt;/a&gt; or in &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;. Instead, you should call &lt;a href=&quot;%24rootscope.scope#%24apply.html&quot;&gt;$apply()&lt;/a&gt; (typically from within a &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;directive&lt;/a&gt;), which will force a &lt;code&gt;$digest()&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../directive/ngcontroller&quot;&gt;컨트롤러&lt;/a&gt; 나 &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 에서 직접 &lt;code&gt;$digest()&lt;/code&gt; 호출하지 않습니다 . 대신 &lt;a href=&quot;%24rootscope.scope#%24apply.html&quot;&gt;$ apply ()&lt;/a&gt; (일반적으로 &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 내에서 )를 호출해야 합니다. &lt;code&gt;$digest()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5cff1d4dcbaa6169803c618f64323129b1539f3d" translate="yes" xml:space="preserve">
          <source>Value Recipe</source>
          <target state="translated">가치 레시피</target>
        </trans-unit>
        <trans-unit id="c113bc7c7f7db6557f503b649e374f64b15937e5" translate="yes" xml:space="preserve">
          <source>Value for this literal. All literal values must be primitives or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">이 리터럴의 값입니다. 모든 리터럴 값은 프리미티브이거나 &lt;code&gt;undefined&lt;/code&gt; 않아야합니다. .</target>
        </trans-unit>
        <trans-unit id="48274bf7792e3199e036a65ed34f449dc89eaf60" translate="yes" xml:space="preserve">
          <source>Value may be:</source>
          <target state="translated">값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c7b89964a32b7847cc384c42d59157b6aa66118" translate="yes" xml:space="preserve">
          <source>Value or a promise</source>
          <target state="translated">가치 또는 약속</target>
        </trans-unit>
        <trans-unit id="6c81a08fcf7fb2e50a04e9b948fa82e0ea17df4a" translate="yes" xml:space="preserve">
          <source>Value services are similar to constant services, except that they cannot be injected into a module configuration function (see &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;) but they can be overridden by an AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;decorator&lt;/a&gt;.</source>
          <target state="translated">값 서비스는 모듈 구성 함수 ( &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; &lt;/a&gt; 참조)에 삽입 될 수는 없지만 AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;데코레이터&lt;/a&gt; 로 재정의 될 수 있다는 점을 제외하면 상수 서비스와 유사합니다. .</target>
        </trans-unit>
        <trans-unit id="3aa197e2c8a5fb13e9b7816824a89f4b3c5b3507" translate="yes" xml:space="preserve">
          <source>Value stabilization algorithm</source>
          <target state="translated">가치 안정화 알고리즘</target>
        </trans-unit>
        <trans-unit id="6c469ec6aaa554802630547915725303bf8f8b8f" translate="yes" xml:space="preserve">
          <source>Value to be stored.</source>
          <target state="translated">저장할 값입니다.</target>
        </trans-unit>
        <trans-unit id="605788684850e8a238a8726e1a0cb4c5099a9922" translate="yes" xml:space="preserve">
          <source>Value to set the attribute to. The value can be an interpolated string.</source>
          <target state="translated">속성을 설정할 값입니다. 값은 보간 된 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a47ec135f296824132839931bbbe778322d52156" translate="yes" xml:space="preserve">
          <source>Verifies that all of the requests defined via the &lt;code&gt;expect&lt;/code&gt; api were made. If any of the requests were not made, verifyNoOutstandingExpectation throws an exception.</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 통해 정의 된 모든 요청을 확인합니다. API 이 이루어 졌는지 확인합니다. 요청이없는 경우 verifyNoOutstandingExpectation에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b0950bdfc9c6382c1d7d6a757ca980cb3de9e74" translate="yes" xml:space="preserve">
          <source>Verifies that there are no outstanding requests that need to be flushed.</source>
          <target state="translated">비워야하는 미해결 요청이 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d7f325a18a825f860634333d989a1d777ced5162" translate="yes" xml:space="preserve">
          <source>Verifies that there are no pending tasks that need to be flushed. It throws an error if there are still pending tasks.</source>
          <target state="translated">비워야하는 보류중인 작업이 없는지 확인합니다. 아직 보류중인 작업이 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c6656dc823a752a3eb9bcea6c50275b8cfac7b8" translate="yes" xml:space="preserve">
          <source>Via CSS styles: overwriting styles in the ng-animate CSS class</source>
          <target state="translated">CSS 스타일을 통해 : 애니메이션이 적용된 CSS 클래스에서 스타일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="56b71e89fb1079caaadefd0889e9a22e8b0560e3" translate="yes" xml:space="preserve">
          <source>Videos</source>
          <target state="translated">Videos</target>
        </trans-unit>
        <trans-unit id="aa76b6711f0b6f7b9b50c7a4cf8c5e8df5a2790e" translate="yes" xml:space="preserve">
          <source>Videos:</source>
          <target state="translated">Videos:</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="8a0159fc319678e56cbe357335bec37e3f693d44" translate="yes" xml:space="preserve">
          <source>View &amp;mdash; The template (HTML with data bindings) that is rendered into the View.</source>
          <target state="translated">보기 &amp;mdash;보기에 렌더링되는 템플릿 (데이터 바인딩이있는 HTML)입니다.</target>
        </trans-unit>
        <trans-unit id="a0f83aaccc440d1cf25ada9bc1856e7eb2641833" translate="yes" xml:space="preserve">
          <source>View-independent business logic: Services</source>
          <target state="translated">보기 독립적 인 비즈니스 로직 : 서비스</target>
        </trans-unit>
        <trans-unit id="80fbd7d99df33af15d63e1fddfb91adaa3951721" translate="yes" xml:space="preserve">
          <source>Views and routes (see the example)</source>
          <target state="translated">보기 및 경로 (예 참조)</target>
        </trans-unit>
        <trans-unit id="346631241a6bd165883391eb2bf20f0dac472e27" translate="yes" xml:space="preserve">
          <source>W3C Accessibility Testing</source>
          <target state="translated">W3C 접근성 테스트</target>
        </trans-unit>
        <trans-unit id="6173f8eb0b947a810d1db5e56255e90b7667262d" translate="yes" xml:space="preserve">
          <source>Watch and observe the URL.</source>
          <target state="translated">URL을보고 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="3db346c9726b530d1a2ae4cfb73287c8e81c97cc" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;by reference&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;scope.$watch&lt;/a&gt;&lt;code&gt;(watchExpression, listener)&lt;/code&gt;) detects a change when the whole value returned by the watch expression switches to a new value. If the value is an array or an object, changes inside it are not detected. This is the most efficient strategy.</source>
          <target state="translated">보고 &lt;em&gt;참조&lt;/em&gt; ( &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;범위. $ 시계 &lt;/a&gt; &lt;code&gt;(watchExpression, listener)&lt;/code&gt; 시계 식으로 돌려 온 값이 새로운 값으로 전환 할 때)의 변화를 검출한다. 값이 배열 또는 객체 인 경우 값이 변경되지 않습니다. 이것이 가장 효율적인 전략입니다.</target>
        </trans-unit>
        <trans-unit id="473a9c40eedd5fb0f115c451dd30526bd2c650ad" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;by value&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;scope.$watch&lt;/a&gt;&lt;code&gt;(watchExpression, listener, true)&lt;/code&gt;) detects any change in an arbitrarily nested data structure. It is the most powerful change detection strategy, but also the most expensive. A full traversal of the nested data structure is needed on each digest, and a full copy of it needs to be held in memory.</source>
          <target state="translated">구경 &lt;em&gt;값&lt;/em&gt; ( &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;범위. $ 시계 &lt;/a&gt; &lt;code&gt;(watchExpression, listener, true)&lt;/code&gt; ) 임의로 중첩 데이터 구조의 변화를 검출한다. 가장 강력한 변경 감지 전략이지만 가장 비쌉니다. 각 다이제스트마다 중첩 된 데이터 구조의 전체 순회가 필요하며 전체 사본을 메모리에 보유해야합니다.</target>
        </trans-unit>
        <trans-unit id="2af6bb4a94b9a1cb0fd67c6d5fc0095196e94650" translate="yes" xml:space="preserve">
          <source>Watching &lt;em&gt;collection contents&lt;/em&gt; (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watchCollection.html&quot;&gt;scope.$watchCollection&lt;/a&gt;&lt;code&gt;(watchExpression, listener)&lt;/code&gt;) detects changes that occur inside an array or an object: When items are added, removed, or reordered. The detection is shallow - it does not reach into nested collections. Watching collection contents is more expensive than watching by reference, because copies of the collection contents need to be maintained. However, the strategy attempts to minimize the amount of copying required.</source>
          <target state="translated">관람 &lt;em&gt;컬렉션 콘텐츠&lt;/em&gt; ( &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watchCollection.html&quot;&gt;. 범위 $ watchCollection &lt;/a&gt; &lt;code&gt;(watchExpression, listener)&lt;/code&gt; 항목이 추가 될 때, 제거 또는 재정렬 :) 배열 또는 개체 내부에서 발생하는 변화를 검출한다. 감지가 얕습니다. 중첩 된 콜렉션에 도달하지 않습니다. 수집 내용의 사본을 유지해야하기 때문에 수집 내용을 보는 것이 참조로 보는 것보다 비쌉니다. 그러나이 전략은 필요한 복사량을 최소화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e57f32a79f955dc80e7b98c93ef9c5dff9e8992b" translate="yes" xml:space="preserve">
          <source>We also &lt;strong&gt;must&lt;/strong&gt; include animations for the views that are being entered and removed (otherwise anchoring wouldn't be possible since the new view would be inserted right away).</source>
          <target state="translated">또한 입력 및 제거되는 뷰에 대한 애니메이션을 포함 &lt;strong&gt;해야합니다&lt;/strong&gt; (그렇지 않으면 새 뷰가 즉시 삽입되므로 고정 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="48d50b84720d06df376f308744283f116a6daf37" translate="yes" xml:space="preserve">
          <source>We also changed all expressions in the page to read and write variables within that controller instance by prefixing them with &lt;code&gt;invoice.&lt;/code&gt; . The possible currencies are defined in the controller and added to the template using &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ng-repeat&lt;/code&gt;&lt;/a&gt;. As the controller contains a &lt;code&gt;total&lt;/code&gt; function we are also able to bind the result of that function to the DOM using &lt;code&gt;{{ invoice.total(...) }}&lt;/code&gt;.</source>
          <target state="translated">또한 페이지의 모든 표현식을 변경하여 &lt;code&gt;invoice.&lt;/code&gt; 을 접두어로 붙여 해당 컨트롤러 인스턴스 내에서 변수를 읽고 씁니다 . . 가능한 통화는 컨트롤러에서 정의되고 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ng-repeat&lt;/code&gt; 를&lt;/a&gt; 사용하여 템플릿에 추가됩니다 . 컨트롤러에 &lt;code&gt;total&lt;/code&gt; 함수가 포함되어 있으므로 &lt;code&gt;{{ invoice.total(...) }}&lt;/code&gt; 사용하여 해당 함수의 결과를 DOM에 바인딩 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e45e195299e27595cc434211c5af3181e81a8bd7" translate="yes" xml:space="preserve">
          <source>We are now ready to launch unicorns, but notice that UnicornLauncher depends on our &lt;code&gt;apiToken&lt;/code&gt;. We can satisfy this dependency on &lt;code&gt;apiToken&lt;/code&gt; using the Factory recipe:</source>
          <target state="translated">우리는 지금 유니콘을 시작할 준비가되어 있지만, 통지 UnicornLauncher 우리에 따라 달라 &lt;code&gt;apiToken&lt;/code&gt; . 팩토리 레시피를 사용하여 &lt;code&gt;apiToken&lt;/code&gt; 에 대한 이러한 종속성을 충족시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac1ea31a9d43166687a50ed3692e05ce4153dc7a" translate="yes" xml:space="preserve">
          <source>We are using the &lt;a href=&quot;../service/%24sce&quot;&gt;$sce&lt;/a&gt; service here and include the &lt;a href=&quot;../../ngsanitize&quot;&gt;$sanitize&lt;/a&gt; module to automatically remove &quot;bad&quot; content like inline event listener (e.g. &lt;code&gt;&amp;lt;span onclick=&quot;...&quot;&amp;gt;&lt;/code&gt;). However, as we are using &lt;code&gt;$sce&lt;/code&gt; the model can still decide to provide unsafe content if it marks that content using the &lt;code&gt;$sce&lt;/code&gt; service.</source>
          <target state="translated">우리는 사용하는 &lt;a href=&quot;../service/%24sce&quot;&gt;$의 SCE의&lt;/a&gt; 여기에 서비스를하고 포함 &lt;a href=&quot;../../ngsanitize&quot;&gt;$의 위생적의&lt;/a&gt; 인라인 이벤트 리스너와 같은 제거 자동으로 모듈을 &quot;나쁜&quot;내용 (예를 들어 &lt;code&gt;&amp;lt;span onclick=&quot;...&quot;&amp;gt;&lt;/code&gt; ). 그러나 &lt;code&gt;$sce&lt;/code&gt; 사용함에 따라 모델은 &lt;code&gt;$sce&lt;/code&gt; 서비스를 사용하여 해당 컨텐츠를 표시하는 경우 안전하지 않은 컨텐츠를 제공하기로 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ddbe3412df53532770a5870b95d26cf007568fd" translate="yes" xml:space="preserve">
          <source>We attach our controller to the DOM using the &lt;code&gt;ng-controller&lt;/code&gt; directive. The &lt;code&gt;greeting&lt;/code&gt; property can now be data-bound to the template:</source>
          <target state="translated">&lt;code&gt;ng-controller&lt;/code&gt; 지시문을 사용하여 컨트롤러를 DOM에 연결 합니다. &lt;code&gt;greeting&lt;/code&gt; 속성은 이제 템플릿에 데이터 바인딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ddeae2cedf9a788113de391be2a82b5796c82f33" translate="yes" xml:space="preserve">
          <source>We can also make use of &lt;strong&gt;CSS Keyframes&lt;/strong&gt; by referencing the keyframe animation within the starting CSS class:</source>
          <target state="translated">시작 CSS 클래스 내에서 키 프레임 애니메이션을 참조하여 &lt;strong&gt;CSS 키 프레임&lt;/strong&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a40a9d552fb5bc988807680efe848c3a0e26cf2b" translate="yes" xml:space="preserve">
          <source>We can also make use of CSS keyframes by placing them within the CSS classes.</source>
          <target state="translated">CSS 키 프레임을 CSS 클래스 내에 배치하여 CSS 키 프레임을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="844c06e399ab04678015537239ffb4d4f3dc9652" translate="yes" xml:space="preserve">
          <source>We can now attach a transition onto the &lt;code&gt;.banner.ng-anchor&lt;/code&gt; CSS class and then ngAnimate will handle the entire transition for us as well as the addition and removal of any changes of CSS classes between the elements:</source>
          <target state="translated">이제 &lt;code&gt;.banner.ng-anchor&lt;/code&gt; CSS 클래스에 전환을 첨부 한 다음 ngAnimate가 요소 전체에서 CSS 클래스의 변경 사항을 추가 및 제거 할뿐만 아니라 전체 전환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4e80494b0409a0d993fa81a7d1f333388f5be423" translate="yes" xml:space="preserve">
          <source>We can show this by adding another property, &lt;code&gt;vojta&lt;/code&gt;, to our scope and trying to access it from within our directive's template:</source>
          <target state="translated">우리는 범위에 다른 속성 &lt;code&gt;vojta&lt;/code&gt; 를 추가 하고 지시문의 템플릿 내에서 액세스하려고 시도하여이를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce0871e367a5372f3bc98dd4c0252dc8c77c3c6" translate="yes" xml:space="preserve">
          <source>We can specify functions to run at configuration and run time for a module by calling the &lt;code&gt;config&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; methods. These functions are injectable with dependencies just like the factory functions above.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 및 &lt;code&gt;run&lt;/code&gt; 메소드를 호출하여 모듈의 구성 및 런타임에 실행할 함수를 지정할 수 있습니다 . 이러한 기능은 위의 공장 기능과 마찬가지로 종속성으로 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e36459843d047d9df4a4211084dc5c402b38cf07" translate="yes" xml:space="preserve">
          <source>We can then use the component like this:</source>
          <target state="translated">그런 다음 컴포넌트를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21324a462f2b8d5e0c7c5b4446052c135414c236" translate="yes" xml:space="preserve">
          <source>We could then configure the unicornLauncherProvider like this:</source>
          <target state="translated">그런 다음 unicornLauncherProvider를 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac57f6df21dcb977cf78d72cfa768c34c7356753" translate="yes" xml:space="preserve">
          <source>We create an &lt;a href=&quot;module&quot;&gt;AngularJS Module&lt;/a&gt;, &lt;code&gt;myApp&lt;/code&gt;, for our application. Then we add the controller's constructor function to the module using the &lt;code&gt;.controller()&lt;/code&gt; method. This keeps the controller's constructor function out of the global scope.</source>
          <target state="translated">우리는 만들 &lt;a href=&quot;module&quot;&gt;AngularJS와 모듈&lt;/a&gt; , &lt;code&gt;myApp&lt;/code&gt; 우리의 응용 프로그램. 그런 다음 컨트롤러의 생성자 함수를 &lt;code&gt;.controller()&lt;/code&gt; 메서드를 사용하여 모듈에 추가합니다 . 이렇게하면 컨트롤러의 생성자 함수가 전역 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="90dc4f28f2aa88baf0a0053350aecee511d1b878" translate="yes" xml:space="preserve">
          <source>We do our best to intercept calls to &quot;unimplemented&quot; methods, but since the list of methods is incomplete we might be missing some non-standard methods. This can result in errors like: &quot;Date.prototype.foo called on incompatible Object&quot;.</source>
          <target state="translated">&quot;구현되지 않은&quot;메소드에 대한 호출을 가로 채기 위해 최선을 다하지만 메소드 목록이 불완전하기 때문에 일부 비표준 메소드가 누락 될 수 있습니다. &quot;호환되지 않는 개체에서 호출 된 Date.prototype.foo&quot;와 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6fc82dc5284ffbf38ea98e85e63bcc39b7510a8" translate="yes" xml:space="preserve">
          <source>We have built &lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt;, an end to end test runner which simulates user interactions that will help you verify the health of your AngularJS application.</source>
          <target state="translated">우리는 AngularJS 애플리케이션의 상태를 확인하는 데 도움이되는 사용자 상호 작용을 시뮬레이션하는 엔드 투 엔드 테스트 러너 인 &lt;a href=&quot;https://github.com/angular/protractor&quot;&gt;Protractor&lt;/a&gt; 를 구축했습니다 .</target>
        </trans-unit>
        <trans-unit id="eff730b8cb2d8bb324e06d0e737eb8eccaed14f5" translate="yes" xml:space="preserve">
          <source>We have set up a guide to many resources provided by the community, where you can find lots of additional information and material on these topics, a list of complimentary libraries, and much more.</source>
          <target state="translated">커뮤니티에서 제공하는 많은 리소스에 대한 안내서를 설정했습니다. 여기에서 이러한 주제에 대한 추가 정보와 자료, 무료 라이브러리 목록 등을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca17b1356cdf6d9a99a47902186386c56a19dd9d" translate="yes" xml:space="preserve">
          <source>We have used an &lt;strong&gt;inline injection annotation&lt;/strong&gt; to explicitly specify the dependency of the Controller on the &lt;code&gt;$scope&lt;/code&gt; service provided by AngularJS. See the guide on &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; for more information.</source>
          <target state="translated">우리는 사용하고 있습니다 &lt;strong&gt;인라인 주입 주석을&lt;/strong&gt; 명시 적으로에 컨트롤러의 의존성 지정 &lt;code&gt;$scope&lt;/code&gt; AngularJS와가 제공하는 서비스를. 자세한 내용은 &lt;a href=&quot;di&quot;&gt;Dependency Injection&lt;/a&gt; 가이드 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ca11f9dea4678a83cbe765017c379b901fb7de5" translate="yes" xml:space="preserve">
          <source>We inject the $compile service and $rootScope before each jasmine test. The $compile service is used to render the aGreatEye directive. After rendering the directive we ensure that the directive has replaced the content and &quot;lidless, wreathed in flame, 2 times&quot; is present.</source>
          <target state="translated">우리는 각 jasmine 테스트 전에 $ compile 서비스와 $ rootScope를 주입합니다. $ compile 서비스는 aGreatEye 지시문을 렌더링하는 데 사용됩니다. 지시문을 렌더링 한 후에는 지시문이 내용을 대체하고 &quot;뚜껑이없는 화염에 2 번&quot;존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ae572490bcf1a384d00d809014f9ef3a389a0f5d" translate="yes" xml:space="preserve">
          <source>We moved the &lt;code&gt;convertCurrency&lt;/code&gt; function and the definition of the existing currencies into the new file &lt;code&gt;finance2.js&lt;/code&gt;. But how does the controller get a hold of the now separated function?</source>
          <target state="translated">우리는 이동 &lt;code&gt;convertCurrency&lt;/code&gt; 의 기능과 새 파일에 기존 통화의 정의 &lt;code&gt;finance2.js&lt;/code&gt; 을 . 그러나 컨트롤러는 어떻게 지금 분리 된 기능을 유지합니까?</target>
        </trans-unit>
        <trans-unit id="023a9b93224bd84cddfe8a629e03f8aa9c858380" translate="yes" xml:space="preserve">
          <source>We register an event &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt;. What fires this &lt;code&gt;$destroy&lt;/code&gt; event?</source>
          <target state="translated">이벤트 &lt;code&gt;element.on('$destroy', ...)&lt;/code&gt; 합니다. 이 &lt;code&gt;$destroy&lt;/code&gt; 이벤트를 발생시키는 원인은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="9d48b2c91f5a6af75293c06facac5a89ab2fa1aa" translate="yes" xml:space="preserve">
          <source>We saw earlier how to use &lt;code&gt;=attr&lt;/code&gt; in the &lt;code&gt;scope&lt;/code&gt; option, but in the above example, we're using &lt;code&gt;&amp;amp;attr&lt;/code&gt; instead. The &lt;code&gt;&amp;amp;&lt;/code&gt; binding allows a directive to trigger evaluation of an expression in the context of the original scope, at a specific time. Any legal expression is allowed, including an expression which contains a function call. Because of this, &lt;code&gt;&amp;amp;&lt;/code&gt; bindings are ideal for binding callback functions to directive behaviors.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 옵션 에서 &lt;code&gt;=attr&lt;/code&gt; 을 사용하는 방법을 앞에서 보았지만 위의 예에서는 대신 &lt;code&gt;&amp;amp;attr&lt;/code&gt; 사용하고 있습니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 결합은 특정 시간에, 원본 영역의 맥락에서 발현의 트리거의 평가에 지시 할 수있다. 함수 호출을 포함하는 표현식을 포함한 모든 법적 표현식이 허용됩니다. 이 때문에 &lt;code&gt;&amp;amp;&lt;/code&gt; 바인딩은 콜백 함수를 지시문 동작에 바인딩하는 데 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="d1926692f60d5568acf1d0bee7f667e3d7c0c99e" translate="yes" xml:space="preserve">
          <source>We want to run the function we pass by invoking it from the directive's scope, but have it run in the context of the scope where it's registered.</source>
          <target state="translated">지시문의 범위에서 호출하여 전달하는 함수를 실행하려고하지만 등록 된 범위의 컨텍스트에서 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="e8e0776ae3afa2fad60ff172ae662a5d77e9f6f7" translate="yes" xml:space="preserve">
          <source>We would expect AngularJS to be able to bind to this, but when we check the console we see something like &lt;code&gt;Error: Invalid value for attribute cx=&quot;{{cx}}&quot;&lt;/code&gt;. Because of the SVG DOM API's restrictions, you cannot simply write &lt;code&gt;cx=&quot;{{cx}}&quot;&lt;/code&gt;.</source>
          <target state="translated">AngularJS가 이것에 바인딩 할 수있을 것으로 기대하지만 콘솔을 확인할 때 &lt;code&gt;Error: Invalid value for attribute cx=&quot;{{cx}}&quot;&lt;/code&gt; 와 같은 것을 볼 수 있습니다. SVG DOM API의 제한으로 인해 단순히 &lt;code&gt;cx=&quot;{{cx}}&quot;&lt;/code&gt; 를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="252941e0a55657728f76a621bbe228cd9bed318b" translate="yes" xml:space="preserve">
          <source>We'll go over a few common examples of directives, then dive deep into the different options and compilation process.</source>
          <target state="translated">몇 가지 일반적인 지시문 예제를 살펴본 다음 다양한 옵션 및 컴파일 프로세스에 대해 자세히 알아 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3db74eddb5abe4c6d69ca5073939b2ffdcd30492" translate="yes" xml:space="preserve">
          <source>We've just learned how AngularJS splits the life-cycle into configuration phase and run phase and how you can provide configuration to your application via the config function. Since the config function runs in the configuration phase when no services are available, it doesn't have access even to simple value objects created via the Value recipe.</source>
          <target state="translated">우리는 AngularJS가 라이프 사이클을 구성 단계와 실행 단계로 나누는 방법과 구성 기능을 통해 애플리케이션에 구성을 제공하는 방법을 배웠습니다. 구성 기능은 서비스를 사용할 수 없을 때 구성 단계에서 실행되므로 값 레시피를 통해 생성 된 간단한 값 개체에도 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7c295f69a771afaeb6fd0ffad7c2c66be9dc3e3" translate="yes" xml:space="preserve">
          <source>We've moved the duplication out and into the &lt;code&gt;beforeEach&lt;/code&gt; block. Each individual test now only contains the code specific to that test, and not code that is general across all tests. As you expand your tests, keep an eye out for locations where you can use &lt;code&gt;beforeEach&lt;/code&gt; to tidy up tests. &lt;code&gt;beforeEach&lt;/code&gt; isn't the only function of this sort that Jasmine provides, and the &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&quot;&gt;documentation lists the others&lt;/a&gt;.</source>
          <target state="translated">중복을 &lt;code&gt;beforeEach&lt;/code&gt; 블록 으로 옮겼습니다 . 각 개별 테스트에는 이제 해당 테스트에 특정한 코드 만 포함되며 모든 테스트에서 일반적인 코드는 포함되지 않습니다. 테스트를 확장 할 때 각 테스트 를 정리하기 &lt;code&gt;beforeEach&lt;/code&gt; 사용할 수있는 위치를 주시하십시오 . &lt;code&gt;beforeEach&lt;/code&gt; 는 Jasmine이 제공하는 이러한 기능의 유일한 기능은 아니며 &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&quot;&gt;설명서에는 다른&lt;/a&gt; 기능이 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5f49816240da5c5e93a09a217e5e15251e2f600" translate="yes" xml:space="preserve">
          <source>We've seen that you can pass in models to a directive using the isolate scope, but sometimes it's desirable to be able to pass in an entire template rather than a string or an object. Let's say that we want to create a &quot;dialog box&quot; component. The dialog box should be able to wrap any arbitrary content.</source>
          <target state="translated">분리 범위를 사용하여 모델을 지시문에 전달할 수 있지만 문자열이나 객체가 아닌 전체 템플릿을 전달하는 것이 바람직한 경우가 있습니다. &quot;대화 상자&quot;구성 요소를 만들고 싶다고 가정 해 봅시다. 대화 상자는 임의의 내용을 감쌀 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="abb1d6054f0ea55e7ce30bf24912bdf732c1589f" translate="yes" xml:space="preserve">
          <source>Web browsers are sometimes picky about what values they consider valid for attributes.</source>
          <target state="translated">웹 브라우저는 때때로 속성에 어떤 값이 유효한 지에 대해 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="4f9f39d112f26b6b483e5752ed5019d0587ba101" translate="yes" xml:space="preserve">
          <source>WebAIM</source>
          <target state="translated">WebAIM</target>
        </trans-unit>
        <trans-unit id="216b85a80c0458fafdebd3ba9ff38b76e657305e" translate="yes" xml:space="preserve">
          <source>What are Directives?</source>
          <target state="translated">지시어 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="12c179e827df1ac7383cddb213d45ff08f32ebad" translate="yes" xml:space="preserve">
          <source>What are decorators?</source>
          <target state="translated">데코레이터 란?</target>
        </trans-unit>
        <trans-unit id="f9f442481556abfd102cc7155daba690e1a9a733" translate="yes" xml:space="preserve">
          <source>What changed?</source>
          <target state="translated">무엇이 바뀌 었습니까?</target>
        </trans-unit>
        <trans-unit id="6352305971f4abc98ce5ffab5abff8ed01207f3c" translate="yes" xml:space="preserve">
          <source>What changed? Our &lt;code&gt;currencyConverter&lt;/code&gt; service of the &lt;code&gt;finance&lt;/code&gt; module now uses the &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt;, a built-in service provided by AngularJS for accessing a server backend. &lt;code&gt;$http&lt;/code&gt; is a wrapper around &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; transports.</source>
          <target state="translated">무엇이 바뀌 었습니까? &lt;code&gt;finance&lt;/code&gt; 모듈 의 &lt;code&gt;currencyConverter&lt;/code&gt; 서비스는 이제 서버 백엔드에 액세스하기 위해 AngularJS가 제공하는 내장 서비스 &lt;a href=&quot;../api/ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 사용합니다 . &lt;code&gt;$http&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; 전송에 대한 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="c9eedc43181be3fbaa803cb63186981f99ccc887" translate="yes" xml:space="preserve">
          <source>What does it not do?</source>
          <target state="translated">무엇을하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="3cfacea0972e3e84df3a18186fd33468ca795ebb" translate="yes" xml:space="preserve">
          <source>What does this &lt;code&gt;transclude&lt;/code&gt; option do, exactly? &lt;code&gt;transclude&lt;/code&gt; makes the contents of a directive with this option have access to the scope &lt;strong&gt;outside&lt;/strong&gt; of the directive rather than inside.</source>
          <target state="translated">이 &lt;code&gt;transclude&lt;/code&gt; 옵션은 정확히 무엇을합니까? &lt;code&gt;transclude&lt;/code&gt; 는이 옵션을 사용하여 지시문의 내용 이 내부가 아닌 지시문 &lt;strong&gt;외부&lt;/strong&gt; 의 범위에 액세스 할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="ada0e0f2c7af87060d54e95e4a96fd7138d3489e" translate="yes" xml:space="preserve">
          <source>What is AngularJS?</source>
          <target state="translated">AngularJS 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="447644911a568d0214e937333a19ccc004de8c3e" translate="yes" xml:space="preserve">
          <source>What is a Module?</source>
          <target state="translated">모듈이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fe08c3c8244699c5a8b273b2cab8b4200356ffcb" translate="yes" xml:space="preserve">
          <source>What is a locale ID?</source>
          <target state="translated">로캘 ID는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="beba7ea743f1dc2173ee282f653943a35f2a106b" translate="yes" xml:space="preserve">
          <source>What is ngMessageFormat?</source>
          <target state="translated">ngMessageFormat은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3943480da5771dbbb46c706aaaea42bf22c5390d" translate="yes" xml:space="preserve">
          <source>What is returned</source>
          <target state="translated">반환되는 것</target>
        </trans-unit>
        <trans-unit id="fbe9fcf5a0f59f8dbc56de5c706eccfe1288f8b9" translate="yes" xml:space="preserve">
          <source>What trusted context types are supported?</source>
          <target state="translated">어떤 신뢰할 수있는 컨텍스트 유형이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="a4e67c138282d3bd3498f65dbfecf946d52210e9" translate="yes" xml:space="preserve">
          <source>What we want to be able to do is separate the scope inside a directive from the scope outside, and then map the outer scope to a directive's inner scope. We can do this by creating what we call an &lt;strong&gt;isolate scope&lt;/strong&gt;. To do this, we can use a &lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;directive's &lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">우리가 할 수있는 것은 지시문 내부의 범위를 외부 범위와 분리 한 다음 외부 범위를 지시문의 내부 범위에 매핑하는 것입니다. &lt;strong&gt;분리 범위&lt;/strong&gt; 라고하는 것을 만들어서이를 수행 할 수 있습니다 . 이를 위해 &lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;지시문의 &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be6b5657e71d140a3fc95978d677de4ea44df671" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$animate&lt;/code&gt; is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has ended by chaining onto the returned promise that animation method returns.</source>
          <target state="translated">때 &lt;code&gt;$animate&lt;/code&gt; 라고는 애니메이션이 종료 할 때 캡처하는 데 사용할 수있는 약속을 반환합니다. 따라서 (지시문 코드 내에서) 애니메이션을 트리거하는 경우 애니메이션이 반환 된 약속에 연결하여 애니메이션이 종료 된 후 애니메이션이 종료 된 후 지시문 및 범위 관련 활동을 계속 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e660649c875315903afc08f2df11dfa21f3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$setViewValue&lt;/code&gt; is called, the new &lt;code&gt;value&lt;/code&gt; will be staged for committing through the &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$validators&lt;/code&gt; pipelines. If there are no special &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; specified then the staged value is sent directly for processing through the &lt;code&gt;$parsers&lt;/code&gt; pipeline. After this, the &lt;code&gt;$validators&lt;/code&gt; and &lt;code&gt;$asyncValidators&lt;/code&gt; are called and the value is applied to &lt;code&gt;$modelValue&lt;/code&gt;. Finally, the value is set to the &lt;strong&gt;expression&lt;/strong&gt; specified in the &lt;code&gt;ng-model&lt;/code&gt; attribute and all the registered change listeners, in the &lt;code&gt;$viewChangeListeners&lt;/code&gt; list are called.</source>
          <target state="translated">때 &lt;code&gt;$setViewValue&lt;/code&gt; 라고하며, 새로운 &lt;code&gt;value&lt;/code&gt; 관통 투입을 위해 개최됩니다 &lt;code&gt;$parsers&lt;/code&gt; 및 &lt;code&gt;$validators&lt;/code&gt; 파이프 라인. 특별한 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; 가&lt;/a&gt; 지정 되지 않은 경우 &lt;code&gt;$parsers&lt;/code&gt; 파이프 라인을 통해 처리하기 위해 준비된 값이 직접 전송됩니다 . 그런 다음 &lt;code&gt;$validators&lt;/code&gt; 및 &lt;code&gt;$asyncValidators&lt;/code&gt; 가 호출되고 값이 &lt;code&gt;$modelValue&lt;/code&gt; 적용됩니다 . 마지막으로, 값은 &lt;code&gt;ng-model&lt;/code&gt; 속성에 지정된 &lt;strong&gt;표현식&lt;/strong&gt; 으로 설정되며 &lt;code&gt;$viewChangeListeners&lt;/code&gt; 목록 에서 등록 된 모든 변경 리스너 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="15cbb91f0e77da9c30b5e74feba1ad5742a72dcd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;objectEquality == true&lt;/code&gt;, inequality of the &lt;code&gt;watchExpression&lt;/code&gt; is determined according to the &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; function. To save the value of the object for later comparison, the &lt;a href=&quot;../function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt; function is used. This therefore means that watching complex objects will have adverse memory and performance implications.</source>
          <target state="translated">경우 &lt;code&gt;objectEquality == true&lt;/code&gt; 의 불평등 &lt;code&gt;watchExpression&lt;/code&gt; 가 받는 따라 결정된다 &lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; 의&lt;/a&gt; 기능. 나중에 비교하기 위해 객체의 값을 저장하기 위해 &lt;a href=&quot;../function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt; 함수가 사용됩니다. 따라서 복잡한 객체를 시청하면 메모리와 성능에 부정적인 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="8ce2cc0dab402897ec4863ce029e781d2d6d52fb" translate="yes" xml:space="preserve">
          <source>When AngularJS compiles the HTML, it processes the &lt;code&gt;ng-controller&lt;/code&gt; directive, which in turn asks the injector to create an instance of the controller and its dependencies.</source>
          <target state="translated">AngularJS는 HTML을 컴파일 할 때 &lt;code&gt;ng-controller&lt;/code&gt; 지시문을 처리 하여 인젝터에게 컨트롤러의 인스턴스와 해당 종속 항목을 작성하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="ec9b10f946fc02c68139f8c80da5ef591eb2ef7e" translate="yes" xml:space="preserve">
          <source>When AngularJS evaluates &lt;code&gt;{{name}}&lt;/code&gt;, it first looks at the scope associated with the given element for the &lt;code&gt;name&lt;/code&gt; property. If no such property is found, it searches the parent scope and so on until the root scope is reached. In JavaScript this behavior is known as prototypical inheritance, and child scopes prototypically inherit from their parents.</source>
          <target state="translated">AngularJS는 &lt;code&gt;{{name}}&lt;/code&gt; 을 평가할 때 먼저 &lt;code&gt;name&lt;/code&gt; 특성에 대해 주어진 요소와 연관된 범위를 확인합니다 . 이러한 속성이 없으면 루트 범위에 도달 할 때까지 상위 범위 등을 검색합니다. JavaScript에서이 동작은 프로토 타입 상속이라고하며 자식 범위는 프로토 타입에서 부모로부터 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="51c935ad5701756b22938226bcc6b67e883b4629" translate="yes" xml:space="preserve">
          <source>When DOM elements are re-used, ngRepeat updates the scope for the element, which will automatically update any active bindings on the template. However, other functionality will not be updated, because the element is not re-created:</source>
          <target state="translated">DOM 요소를 재사용하면 ngRepeat는 요소의 범위를 업데이트하여 템플릿의 모든 활성 바인딩을 자동으로 업데이트합니다. 그러나 요소가 다시 작성되지 않기 때문에 다른 기능은 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="185ed32d1839cf6b6b86790a50f091c5cad18d3a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;replace&lt;/code&gt; directive encounters the same attribute on the original and the replace node, it will simply deduplicate the attribute and join the values with a space or with a &lt;code&gt;;&lt;/code&gt; in case of the &lt;code&gt;style&lt;/code&gt; attribute.</source>
          <target state="translated">A는 경우 &lt;code&gt;replace&lt;/code&gt; 원래의 지시자 만남에 동일한 속성 및 대체 노드, 단순히 속성 중복을 제거하고 공간 또는 값으로 참여한다 &lt;code&gt;;&lt;/code&gt; &lt;code&gt;style&lt;/code&gt; 속성의 경우</target>
        </trans-unit>
        <trans-unit id="5c230d77dd585240729675f16f4ddd67901e2eba" translate="yes" xml:space="preserve">
          <source>When a directive requests transclusion, the compiler extracts its contents and provides a &lt;strong&gt;transclusion function&lt;/strong&gt; to the directive's &lt;code&gt;link&lt;/code&gt; function and &lt;code&gt;controller&lt;/code&gt;. This transclusion function is a special &lt;strong&gt;linking function&lt;/strong&gt; that will return the compiled contents linked to a new transclusion scope.</source>
          <target state="translated">지시문이 변환을 요청하면 컴파일러는 내용을 추출하고 지시문의 &lt;code&gt;link&lt;/code&gt; 함수 및 &lt;code&gt;controller&lt;/code&gt; &lt;strong&gt;변환 함수&lt;/strong&gt; 를 제공합니다 . 이 transclusion 함수는 새로운 transclusion 범위에 연결된 컴파일 된 내용을 반환 하는 특별한 &lt;strong&gt;연결 함수&lt;/strong&gt; 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27ba11fbb2203f0c5d97308aa2a93fd81f5c7f9e" translate="yes" xml:space="preserve">
          <source>When a user clicks on this link,</source>
          <target state="translated">사용자가이 링크를 클릭하면</target>
        </trans-unit>
        <trans-unit id="fbf62f2a97f03d4ac746191d9d45dd4869d7d443" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;offset&lt;/code&gt; is specified, the matching works as follows. First, the exact value of the AngularJS expression is matched against the exact matches (i.e. &lt;code&gt;=N&lt;/code&gt; selectors) to find a match. If there is one, that message is used. If there was no match, then the offset value is subtracted from the value of the expression and locale specific pluralization rules are applied to this new value to obtain its plural category (such as &amp;ldquo;one&amp;rdquo;, &amp;ldquo;few&amp;rdquo;, &amp;ldquo;many&amp;rdquo;, etc.) and a match is attempted against the keyword selectors and the matching message is used. If there was no match, then the &amp;ldquo;other&amp;rdquo; category (required) is used. The value of the &lt;code&gt;#&lt;/code&gt; character inside a message is the value of original expression reduced by the offset value that was specified.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 을 지정 하면 다음과 같이 일치합니다. 먼저 AngularJS 표현식의 정확한 값이 정확한 일치 (즉, &lt;code&gt;=N&lt;/code&gt; 선택기)와 일치하여 일치하는 것을 찾습니다. 있는 경우 해당 메시지가 사용됩니다. 일치하는 것이없는 경우 오프셋 값을 표현식 값에서 빼고 로케일 별 복수 규칙을이 새 값에 적용하여 복수 범주 (예 : &quot;하나&quot;, &quot;몇&quot;, &quot;많은&quot;등)를 얻습니다. )) 키워드 선택기와 일치하고 일치하는 메시지가 사용됩니다. 일치하는 항목이 없으면 &quot;기타&quot;범주 (필수)가 사용됩니다. 의 값 &lt;code&gt;#&lt;/code&gt; 의 메시지 안에 문자 지정된 오프셋 값만큼 감소 일본어 표현의 값이다.</target>
        </trans-unit>
        <trans-unit id="a149b30987e7663899511dac68ffedfef81a9f01" translate="yes" xml:space="preserve">
          <source>When an AngularJS application needs some data from a server, it calls the $http service, which sends the request to a real server using $httpBackend service. With dependency injection, it is easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify the requests and respond with some testing data without sending a request to a real server.</source>
          <target state="translated">AngularJS 애플리케이션이 서버의 일부 데이터를 필요로하는 경우 $ http 서비스를 호출하여 $ httpBackend 서비스를 사용하여 요청을 실제 서버로 보냅니다. 의존성 주입을 사용하면 $ httpBackend mock ($ httpBackend와 동일한 API)을 주입하고이를 사용하여 요청을 확인하고 실제 서버에 요청을 보내지 않고도 일부 테스트 데이터로 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0819d9d7539f9a79a347a5055715a2649bfc1a04" translate="yes" xml:space="preserve">
          <source>When an AngularJS application starts with a given application module, AngularJS creates a new instance of injector, which in turn creates a registry of recipes as a union of all recipes defined in the core &quot;ng&quot; module, application module and its dependencies. The injector then consults the recipe registry when it needs to create an object for your application.</source>
          <target state="translated">AngularJS 응용 프로그램이 주어진 응용 프로그램 모듈로 시작할 때 AngularJS는 새로운 인젝터 인스턴스를 작성하며, 그 결과 핵심 &quot;ng&quot;모듈, 응용 프로그램 모듈 및 그 종속물에 정의 된 모든 레시피의 결합으로 레시피 레지스트리가 작성됩니다. 그런 다음 인젝터는 응용 프로그램의 오브젝트를 작성해야 할 때 레시피 레지스트리를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="65f2bf10923606bb898bed54285676cbbd6a723c" translate="yes" xml:space="preserve">
          <source>When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting element is located on screen via absolute positioning. The cloned element will be placed inside of the root element of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The element will then animate into the &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;in&lt;/code&gt; animations and will eventually reach the coordinates and match the dimensions of the destination element. During the entire animation a CSS class of &lt;code&gt;.ng-animate-shim&lt;/code&gt; will be applied to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class is: &lt;code&gt;visibility:hidden&lt;/code&gt;). Once the anchor reaches its destination then it will be removed and the destination element will become visible since the shim class will be removed.</source>
          <target state="translated">앵커 애니메이션이 발생하면 ngAnimate는 시작 요소를 복제하고 절대 위치 지정을 통해 시작 요소가 화면에있는 위치에 정확하게 배치합니다. 복제 된 요소는 응용 프로그램의 루트 요소 (ng-app가 정의 된 위치) 안에 배치되고 시작 요소의 모든 CSS 클래스가 적용됩니다. 요소는 다음에 애니메이션 것입니다 &lt;code&gt;out&lt;/code&gt; 와 &lt;code&gt;in&lt;/code&gt; 애니메이션은 결국 좌표에 도달하고 대상 요소의 크기와 일치합니다. 전체 애니메이션 중에 &lt;code&gt;.ng-animate-shim&lt;/code&gt; 의 CSS 클래스가 시작 및 대상 요소 모두에 적용되어 보이지 않게 숨길 수 있습니다 (클래스의 CSS 스타일은 다음과 같습니다. visible &lt;code&gt;visibility:hidden&lt;/code&gt; ). 앵커가 목적지에 도달하면 해당 클래스가 제거되고 shim 클래스가 제거되므로 목적지 요소가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="14f3f7bcb4a87c6124202a009713b7534c14dfdf" translate="yes" xml:space="preserve">
          <source>When an external event (such as a user action, timer or XHR) is received, the associated &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; must be applied to the scope through the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply()&lt;/a&gt; method so that all listeners are updated correctly.</source>
          <target state="translated">외부 이벤트 (예 : 사용자 조치, 타이머 또는 XHR)가 수신되면 모든 리스너가 올바르게 업데이트되도록 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply ()&lt;/a&gt; 메소드를 통해 연관된 &lt;a href=&quot;expression&quot;&gt;표현식&lt;/a&gt; 을 범위에 적용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c139d2a36c5e7dae8ba86d6f3fc970378a2fd7a1" translate="yes" xml:space="preserve">
          <source>When an isolate scope is used for a directive (see above), &lt;code&gt;bindToController: true&lt;/code&gt; will allow a component to have its properties bound to the controller, rather than to scope.</source>
          <target state="translated">격리 범위가 지시문에 사용되면 (위 참조) &lt;code&gt;bindToController: true&lt;/code&gt; 를 사용하면 구성 요소가 범위가 아닌 컨트롤러에 속성을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3153ef599b44531bab9272b7bd946ae582bdb412" translate="yes" xml:space="preserve">
          <source>When an item in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; menu is selected, the array element or object property represented by the selected option will be bound to the model identified by the &lt;code&gt;ngModel&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 메뉴 에서 항목을 선택 하면 선택한 옵션으로 표시되는 배열 요소 또는 객체 속성이 &lt;code&gt;ngModel&lt;/code&gt; 지시문으로 식별 된 모델에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a676ca96b413f93e2b10f02f22a45badb9199fb" translate="yes" xml:space="preserve">
          <source>When an item in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; menu is selected, the value of the selected option will be bound to the model identified by the &lt;code&gt;ngModel&lt;/code&gt; directive. With static or repeated options, this is the content of the &lt;code&gt;value&lt;/code&gt; attribute or the textContent of the &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;, if the value attribute is missing. Value and textContent can be interpolated.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 메뉴 에서 항목을 선택 하면 선택한 옵션의 값이 &lt;code&gt;ngModel&lt;/code&gt; 지시문으로 식별 된 모델에 바인딩됩니다 . 정적 또는 반복 옵션이이 내용 인 &lt;code&gt;value&lt;/code&gt; 특성 또는하는 TextContent의 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; value 속성이없는 경우. 값과 텍스트 내용을 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91d5acbcb6e8adb1db7278d2b85940b8c059799" translate="yes" xml:space="preserve">
          <source>When an item is added, a new instance of the template is added to the DOM.</source>
          <target state="translated">항목이 추가되면 템플릿의 새 인스턴스가 DOM에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6812fd0a944e938e939802bbf208e98821182752" translate="yes" xml:space="preserve">
          <source>When an item is removed, its template instance is removed from the DOM.</source>
          <target state="translated">항목이 제거되면 해당 템플리트 인스턴스가 DOM에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="81dc823adbdf6d2fe5dc8bb040d0c817d8aeaa14" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; stores the response from the server using the relevant cache object. The next time the same request is made, the response is returned from the cache without sending a request to the server.</source>
          <target state="translated">캐싱이 활성화되면 &lt;a href=&quot;%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 는 관련 캐시 개체를 사용하여 서버의 응답을 저장합니다. 다음에 동일한 요청이 작성되면 서버로 요청을 보내지 않고 캐시에서 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="789467cb9245497d6ba720add302b2f1f1af706a" translate="yes" xml:space="preserve">
          <source>When called with a single argument the method acts as a setter, setting the &lt;code&gt;search&lt;/code&gt; component of &lt;code&gt;$location&lt;/code&gt; to the specified value.</source>
          <target state="translated">단일 인수로 호출되면 메소드는 &lt;code&gt;$location&lt;/code&gt; 의 &lt;code&gt;search&lt;/code&gt; 컴포넌트를 지정된 값으로 설정하는 세터 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="14865eb2b6a51a444dc86a06c71f0100af295db4" translate="yes" xml:space="preserve">
          <source>When called, it scrolls to the element related to the specified &lt;code&gt;hash&lt;/code&gt; or (if omitted) to the current value of &lt;a href=&quot;%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt;, according to the rules specified in the &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec&lt;/a&gt;.</source>
          <target state="translated">호출되면 &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec에&lt;/a&gt; 지정된 규칙에 따라 지정된 &lt;code&gt;hash&lt;/code&gt; 와 관련된 요소 또는 &lt;a href=&quot;%24location#hash.html&quot;&gt;$ location.hash ()&lt;/a&gt; 의 현재 값으로 스크롤됩니다 .</target>
        </trans-unit>
        <trans-unit id="e711b7dd7dcf0670b3366c5231f7791291b42079" translate="yes" xml:space="preserve">
          <source>When called, it scrolls to the element related to the specified &lt;code&gt;hash&lt;/code&gt; or (if omitted) to the current value of &lt;a href=&quot;service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt;, according to the rules specified in the &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec&lt;/a&gt;.</source>
          <target state="translated">호출되면 &lt;a href=&quot;http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indicated-part-of-the-document&quot;&gt;HTML5 spec에&lt;/a&gt; 지정된 규칙에 따라 지정된 &lt;code&gt;hash&lt;/code&gt; 와 관련된 요소 또는 &lt;a href=&quot;service/%24location#hash.html&quot;&gt;$ location.hash ()&lt;/a&gt; 의 현재 값으로 스크롤됩니다 .</target>
        </trans-unit>
        <trans-unit id="20cc03eae13b474c55c6832e1df3a3881e25f1de" translate="yes" xml:space="preserve">
          <source>When calling instance methods, the instance itself is used as the request body (if the action should have a body). By default, only actions using &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt; have request bodies, but you can use the &lt;code&gt;hasBody&lt;/code&gt; configuration option to specify whether an action should have a body or not (regardless of its HTTP method).</source>
          <target state="translated">인스턴스 메소드를 호출 할 때 인스턴스 자체는 요청 본문으로 사용됩니다 (활동에 본문이있는 경우). 기본적으로 &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; 또는 &lt;code&gt;PATCH&lt;/code&gt; 를 사용하는 조치에만 요청 본문이 있지만 &lt;code&gt;hasBody&lt;/code&gt; 구성 옵션을 사용하여 조치에 본문이 있어야하는지 여부를 지정할 수 있습니다 (HTTP 메소드에 관계없이).</target>
        </trans-unit>
        <trans-unit id="839a4c899e007e634295e0d40ee38c44ffb9e7a9" translate="yes" xml:space="preserve">
          <source>When child scopes are no longer needed, it is the responsibility of the child scope creator to destroy them via &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24destroy.html&quot;&gt;scope.$destroy()&lt;/a&gt; API. This will stop propagation of &lt;code&gt;$digest&lt;/code&gt; calls into the child scope and allow for memory used by the child scope models to be reclaimed by the garbage collector.</source>
          <target state="translated">하위 범위가 더 이상 필요하지 않은 경우 하위 범위 작성자는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24destroy.html&quot;&gt;scope. $ destroy ()&lt;/a&gt; API 를 통해이를 삭제해야 합니다. 이렇게하면 &lt;code&gt;$digest&lt;/code&gt; 호출이 하위 범위로 전파되지 않고 가비지 수집기에서 하위 범위 모델에 사용 된 메모리를 회수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22459911d88501ffcc063a47051430d4e2088c3f" translate="yes" xml:space="preserve">
          <source>When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of &lt;code&gt;reject&lt;/code&gt; as the &lt;code&gt;throw&lt;/code&gt; keyword in JavaScript. This also means that if you &quot;catch&quot; an error via a promise error callback and you want to forward the error to the promise derived from the current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via &lt;code&gt;reject&lt;/code&gt;.</source>
          <target state="translated">지연 / 약속을 try / catch / throw의 익숙한 동작과 비교할 때는 JavaScript에서 &lt;code&gt;reject&lt;/code&gt; 를 &lt;code&gt;throw&lt;/code&gt; 키워드 로 생각 하십시오 . 이는 약속 오류 콜백을 통해 오류를 &quot;잡아&quot;현재 약속에서 파생 된 약속으로 오류를 전달하려는 경우 &lt;code&gt;reject&lt;/code&gt; 를 통해 생성 된 거부를 반환하여 오류를 &quot;다시 던져야&quot;함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7544d7a6d40240f2568b1c59cdeebb817b07875a" translate="yes" xml:space="preserve">
          <source>When designing web applications, consider security threats from:</source>
          <target state="translated">웹 애플리케이션을 설계 할 때 다음과 같은 보안 위협을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1be6f29866ea88fbd287202394805d3eb43fe1cb" translate="yes" xml:space="preserve">
          <source>When digest loop is done and all the values have settled, process the queue of watch deregistration tasks. For each watch to be deregistered, check if it still evaluates to a value that is not &lt;code&gt;undefined&lt;/code&gt;. If that's the case, deregister the watch. Otherwise, keep dirty-checking the watch in the future digest loops by following the same algorithm starting from step 1</source>
          <target state="translated">다이제스트 루프가 완료되고 모든 값이 정해지면 감시 등록 해제 작업 대기열을 처리합니다. 등록 해제 할 각 시계에 대해 아직 &lt;code&gt;undefined&lt;/code&gt; 되지 않은 값으로 평가되는지 확인하십시오 . 이 경우 시계 등록을 취소하십시오. 그렇지 않으면, 1 단계부터 시작하는 동일한 알고리즘을 따라 향후 다이제스트 루프에서 시계를 더티 검사로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="ada11b8bb4889ba1645ad55c7065dc38a11b087e" translate="yes" xml:space="preserve">
          <source>When filters are executed</source>
          <target state="translated">필터가 실행될 때</target>
        </trans-unit>
        <trans-unit id="bc763fc382925e726e695a57a972bb42b82d1fcf" translate="yes" xml:space="preserve">
          <source>When interacting with &lt;code&gt;Scope&lt;/code&gt; in tests, additional helper methods are available on the instances of &lt;code&gt;Scope&lt;/code&gt; type. See &lt;a href=&quot;../../ngmock/type/%24rootscope.scope&quot;&gt;ngMock Scope&lt;/a&gt; for additional details.</source>
          <target state="translated">테스트에서 &lt;code&gt;Scope&lt;/code&gt; 와 상호 작용할 때 &lt;code&gt;Scope&lt;/code&gt; 유형 의 인스턴스에서 추가 도우미 메서드를 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../../ngmock/type/%24rootscope.scope&quot;&gt;ngMock 범위&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="2316ea99ea91caa4a7fb2d4b06f1b8e10ed600db" translate="yes" xml:space="preserve">
          <source>When internationalizing your app, you need to do thorough testing to make sure UI components behave as expected even when their contents vary greatly in content size.</source>
          <target state="translated">앱을 국제화 할 때는 콘텐츠의 크기가 매우 큰 경우에도 UI 구성 요소가 예상대로 작동하는지 철저히 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="750c827a48343dda9e5fe8addc1f6d41b2ad613b" translate="yes" xml:space="preserve">
          <source>When interpolating text or attributes:</source>
          <target state="translated">텍스트 나 속성을 보간 할 때 :</target>
        </trans-unit>
        <trans-unit id="3383a24d31d85f720ecee22674153dda0032675f" translate="yes" xml:space="preserve">
          <source>When items are reordered, their respective templates are reordered in the DOM.</source>
          <target state="translated">항목이 재정렬되면 해당 템플리트가 DOM에서 재정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6632f6bff4755ea5460332c4224ec9a11c1cb149" translate="yes" xml:space="preserve">
          <source>When nesting elements with structural animations, such as &lt;code&gt;ngIf&lt;/code&gt;, into elements that have class-based animations such as &lt;code&gt;ngClass&lt;/code&gt;, it sometimes happens that before the actual animation starts, there is a brief flicker or flash of content where the animated element is briefly visible.</source>
          <target state="translated">같은 구조 애니메이션과 중첩 요소 때 &lt;code&gt;ngIf&lt;/code&gt; 같은 클래스 기반 애니메이션이 소자 내로 &lt;code&gt;ngClass&lt;/code&gt; 는 , 때때로 실제 애니메이션이 시작되기 전에 상기 애니메이션 요소는 간략하게 표시 간단한 플리커 나 콘텐츠의 플래시가 있다고 일어난다.</target>
        </trans-unit>
        <trans-unit id="f71bcb4df00d381895c0df3a5c8a7dbd4ffa348d" translate="yes" xml:space="preserve">
          <source>When ngAnimate is animating an element it will apply the &lt;code&gt;ng-animate&lt;/code&gt; CSS class to the element for the duration of the animation. This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).</source>
          <target state="translated">ngAnimate가 요소에 애니메이션을 적용 하면 애니메이션 지속 시간 동안 &lt;code&gt;ng-animate&lt;/code&gt; aniimate CSS 클래스를 요소에 적용합니다 . 이것은 임시 CSS 클래스이며 애니메이션이 끝나면 JavaScript와 CSS 기반 애니메이션 모두에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8455755d949278198fe66a8823e52081309775" translate="yes" xml:space="preserve">
          <source>When not to use Components:</source>
          <target state="translated">구성 요소를 사용하지 않을 경우 :</target>
        </trans-unit>
        <trans-unit id="6625b1391d7be3b24e194fa9d4b7155f0f6abba7" translate="yes" xml:space="preserve">
          <source>When provided, replaces the resourceUrlBlacklist with the value provided. This must be an array or null. A snapshot of this array is used so further changes to the array are ignored.</source>
          <target state="translated">제공된 경우 resourceUrlBlacklist를 제공된 값으로 바꿉니다. 배열이거나 null이어야합니다. 이 어레이의 스냅 샷이 사용되므로 어레이에 대한 추가 변경 사항은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d9fdadc8992417ef4226cc2cbace2ccffdff1f6" translate="yes" xml:space="preserve">
          <source>When provided, replaces the resourceUrlWhitelist with the value provided. This must be an array or null. A snapshot of this array is used so further changes to the array are ignored. Follow &lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;this link&lt;/a&gt; for a description of the items allowed in this array.</source>
          <target state="translated">제공된 경우 resourceUrlWhitelist를 제공된 값으로 바꿉니다. 배열이거나 null이어야합니다. 이 어레이의 스냅 샷이 사용되므로 어레이에 대한 추가 변경 사항은 무시됩니다. 이 배열에서 허용되는 항목에 대한 설명을 보려면 &lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;이 링크&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="fefb6e795ed34de308a60ccca17742a8573190c3" translate="yes" xml:space="preserve">
          <source>When should I use $location?</source>
          <target state="translated">언제 $ location을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="fc081f8c14691f7b31edca6d4fe98a8c36e29d01" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;placeholder&lt;/code&gt; attribute of &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, Internet Explorer will temporarily insert the placeholder value as the textarea's content. If the placeholder value contains interpolation (&lt;code&gt;{{ ... }}&lt;/code&gt;), an error will be logged in the console when AngularJS tries to update the value of the by-then-removed text node. This doesn't affect the functionality of the textarea, but can be undesirable.</source>
          <target state="translated">&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 의 &lt;code&gt;placeholder&lt;/code&gt; 속성을 지정하면 Internet Explorer는 자리 표시 자 값을 텍스트 영역의 내용으로 임시로 삽입합니다. 자리 표시 자 값에 보간 ( &lt;code&gt;{{ ... }}&lt;/code&gt; )이 포함 된 경우 AngularJS가 제거 된 텍스트 노드의 값을 업데이트하려고하면 콘솔에 오류가 기록됩니다. 이것은 텍스트 영역의 기능에는 영향을 미치지 않지만 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f2ae1c603fd24b2d92261b8648add410fc1b1db" translate="yes" xml:space="preserve">
          <source>When testing promises, it's important to know that the resolution of promises is tied to the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;digest cycle&lt;/a&gt;. That means a promise's &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; callback functions are only called after a digest has run. In tests, you can trigger a digest by calling a scope's &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;&lt;code&gt;$apply&lt;/code&gt; function&lt;/a&gt;. If you don't have a scope in your test, you can inject the &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$rootScope&lt;/a&gt; and call &lt;code&gt;$apply&lt;/code&gt; on it. There is also an example of testing promises in the &lt;a href=&quot;../api/ng/service/%24q#testing.html&quot;&gt;&lt;code&gt;$q&lt;/code&gt; service documentation&lt;/a&gt;.</source>
          <target state="translated">약속을 테스트 할 때는 약속의 해결이 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;다이제스트주기&lt;/a&gt; 와 연결되어 있음을 알아야합니다 . 즉, promise의 &lt;code&gt;then&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;finally&lt;/code&gt; 콜백 함수는 다이제스트가 실행 된 후에 만 ​​호출됩니다. 테스트에서 범위의 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt; &lt;code&gt;$apply&lt;/code&gt; 함수를&lt;/a&gt; 호출하여 다이제스트를 트리거 할 수 있습니다 . 당신이 당신의 시험 범위가없는 경우, 당신은 삽입 할 수 &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;$ rootScope을&lt;/a&gt; 하고 전화를 &lt;code&gt;$apply&lt;/code&gt; 그 위에. &lt;a href=&quot;../api/ng/service/%24q#testing.html&quot;&gt; &lt;code&gt;$q&lt;/code&gt; 서비스 문서에&lt;/a&gt; 약속을 테스트하는 예제도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a9b3721c7237b75d3afd4715763f1ab811416bc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ngHide&lt;/code&gt; expression evaluates to a truthy value then the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is added to the class attribute on the element causing it to become hidden. When falsy, the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is removed from the element causing the element not to appear hidden.</source>
          <target state="translated">때 &lt;code&gt;ngHide&lt;/code&gt; 의 truthy 값으로 표현 평가하여 다음 &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스는 숨겨진되기 위해 원인이되는 요소에 class 속성에 추가됩니다. 거짓 인 경우 &lt;code&gt;.ng-hide&lt;/code&gt; 에서 .ng-hide CSS 클래스가 제거되어 요소가 숨겨진 것처럼 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a297ab931629d5a0763f7da3d096f081788fc874" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ngShow&lt;/code&gt; expression evaluates to a falsy value then the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is added to the class attribute on the element causing it to become hidden. When truthy, the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class is removed from the element causing the element not to appear hidden.</source>
          <target state="translated">때 &lt;code&gt;ngShow&lt;/code&gt; 의 falsy 값으로 표현 평가하여 다음 &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스는 숨겨진되기 위해 원인이되는 요소에 class 속성에 추가됩니다. 사실 인 경우 &lt;code&gt;.ng-hide&lt;/code&gt; 에서 .ng-hide CSS 클래스가 제거되어 요소가 숨겨지지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="4bfc193dcf03be5fdd2e2cdb87b257d2455c123e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;willBreak&lt;/code&gt; service is instantiated, AngularJS will throw an error because of strict mode. This is useful when using a tool like &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; to ensure that all of your application components have annotations.</source>
          <target state="translated">하면 &lt;code&gt;willBreak&lt;/code&gt; 서비스가 인스턴스화, AngularJS와 때문에 엄격 모드의 오류가 발생합니다. 이것은 &lt;a href=&quot;https://github.com/olov/ng-annotate&quot;&gt;ng-annotate&lt;/a&gt; 와 같은 도구를 사용하여 모든 응용 프로그램 구성 요소에 주석 이 있는지 확인하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c7c18ae4170652195c550cf6ea2dba7c36696d41" translate="yes" xml:space="preserve">
          <source>When the above example is compiled, the compiler visits every node and looks for directives.</source>
          <target state="translated">위의 예제가 컴파일되면 컴파일러는 모든 노드를 방문하여 지시문을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4f3975f977c06069a05aff73f180e1132f61ab9c" translate="yes" xml:space="preserve">
          <source>When the application containing &lt;code&gt;angular_de-de.js&lt;/code&gt; script instead of the generic angular.js script starts, AngularJS is automatically pre-configured with localization rules for the german locale.</source>
          <target state="translated">일반 &lt;code&gt;angular_de-de.js&lt;/code&gt; 스크립트 대신 angular_de-de.js 스크립트를 포함하는 애플리케이션이 시작되면 AngularJS는 독일어 로케일에 대한 현지화 규칙으로 자동으로 사전 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9dc89b2e726de5f584f7c7b43803949e197d4a32" translate="yes" xml:space="preserve">
          <source>When the browser calls into JavaScript the code executes outside the AngularJS execution context, which means that AngularJS is unaware of model modifications. To properly process model modifications the execution has to enter the AngularJS execution context using the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;&lt;code&gt;$apply&lt;/code&gt;&lt;/a&gt; method. Only model modifications which execute inside the &lt;code&gt;$apply&lt;/code&gt; method will be properly accounted for by AngularJS. For example if a directive listens on DOM events, such as &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;&lt;code&gt;ng-click&lt;/code&gt;&lt;/a&gt; it must evaluate the expression inside the &lt;code&gt;$apply&lt;/code&gt; method.</source>
          <target state="translated">브라우저가 JavaScript를 호출하면 코드가 AngularJS 실행 컨텍스트 외부에서 실행되므로 AngularJS는 모델 수정을 인식하지 못합니다. 모델 수정을 올바르게 처리하려면 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt; &lt;code&gt;$apply&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 AngularJS 실행 컨텍스트로 실행을 실행 해야 합니다. &lt;code&gt;$apply&lt;/code&gt; 메소드 내에서 실행되는 모델 수정 만 AngularJS에 의해 올바르게 설명됩니다. 예를 들어 지시문이 &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt; &lt;code&gt;ng-click&lt;/code&gt; &lt;/a&gt; 과 같은 DOM 이벤트를 수신하는 경우 &lt;code&gt;$apply&lt;/code&gt; 메소드 내부의 표현식을 평가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4a0073d43d8ed80547cc46f1c39992f55fe9dcd" translate="yes" xml:space="preserve">
          <source>When the data is returned from the server then the object is an instance of the resource type and all of the non-GET methods are available with &lt;code&gt;$&lt;/code&gt; prefix. This allows you to easily support CRUD operations (create, read, update, delete) on server-side data.</source>
          <target state="translated">서버에서 데이터가 리턴되면 오브젝트는 자원 유형의 인스턴스이며 모든 비 GET 메소드는 &lt;code&gt;$&lt;/code&gt; 접두어 로 사용할 수 있습니다 . 이를 통해 서버 측 데이터에서 CRUD 작업 (만들기, 읽기, 업데이트, 삭제)을 쉽게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ed9027d5eb4faa2d10f802af6772e8ffd7a989" translate="yes" xml:space="preserve">
          <source>When the expression changes, the previously added classes are removed and only then are the new classes added.</source>
          <target state="translated">식이 변경되면 이전에 추가 한 클래스가 제거 된 다음 새 클래스 만 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3821805d3a6f4eb90bb7345d51e2b2e665b5adba" translate="yes" xml:space="preserve">
          <source>When the first argument is a native DOM or jqLite/jQuery element, the function enables / disables animations on this element &lt;em&gt;and all its children&lt;/em&gt;: &lt;code&gt;$animate.enabled(myElement, false)&lt;/code&gt;. You can still use it to re-enable animations for a child element, even if you have disabled them on a parent element. And compared to the &lt;code&gt;classNameFilter&lt;/code&gt;, you can change the animation status at runtime instead of during the config phase.</source>
          <target state="translated">첫 번째 인수가 기본 DOM 또는 jqLite / jQuery 요소 인 경우이 함수는이 요소 &lt;em&gt;와 모든 하위&lt;/em&gt; 요소에서 애니메이션을 활성화 / 비활성화합니다 : &lt;code&gt;$animate.enabled(myElement, false)&lt;/code&gt; . 부모 요소에서 애니메이션을 비활성화 한 경우에도이를 사용하여 자식 요소에 대한 애니메이션을 다시 활성화 할 수 있습니다. 그리고 &lt;code&gt;classNameFilter&lt;/code&gt; 와 비교 하여 구성 단계 대신 런타임에 애니메이션 상태를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b8c3726e19191da644ea15837b664d0107b25a" translate="yes" xml:space="preserve">
          <source>When the original node and the replace template declare the same directive(s), they will be &lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;compiled twice&lt;/a&gt; because the compiler does not deduplicate them. In many cases, this is not noticable, but e.g. &lt;a href=&quot;../directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; will attach &lt;code&gt;$formatters&lt;/code&gt; and &lt;code&gt;$parsers&lt;/code&gt; twice.</source>
          <target state="translated">원래 노드와 바꾸기 템플릿이 동일한 지시문을 선언 하면 컴파일러가 중복 제거하지 않기 때문에 &lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;두 번 컴파일&lt;/a&gt; 됩니다. 많은 경우에 이것은 눈에 &lt;a href=&quot;../directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 않지만 ngModel 은 &lt;code&gt;$formatters&lt;/code&gt; 와 &lt;code&gt;$parsers&lt;/code&gt; 두 번 부착 합니다.</target>
        </trans-unit>
        <trans-unit id="fd9c02d96b63bdc77f81f45e93ccaf214f2bcea7" translate="yes" xml:space="preserve">
          <source>When the replace template has a directive at the root node that uses &lt;a href=&quot;%24compile#-transclude-.html&quot;&gt;&lt;code&gt;transclude: element&lt;/code&gt;&lt;/a&gt;, e.g. &lt;a href=&quot;../directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt;, the DOM structure or scope inheritance can be incorrect. See the following issues:</source>
          <target state="translated">replace 템플리트에 루트 노드에 &lt;a href=&quot;../directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;%24compile#-transclude-.html&quot;&gt; &lt;code&gt;transclude: element&lt;/code&gt; &lt;/a&gt; 를 사용하는 지시문이있는 경우 (예 : ngIf 또는 &lt;a href=&quot;../directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt; ) DOM 구조 또는 범위 상속이 올바르지 않을 수 있습니다. 다음 문제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9342cec159ce1c208d8802a510ac44a9f06fba8a" translate="yes" xml:space="preserve">
          <source>When the user clicks the &lt;code&gt;x&lt;/code&gt; in the dialog, the directive's &lt;code&gt;close&lt;/code&gt; function is called, thanks to &lt;code&gt;ng-click.&lt;/code&gt; This call to &lt;code&gt;close&lt;/code&gt; on the isolated scope actually evaluates the expression &lt;code&gt;hideDialog(message)&lt;/code&gt; in the context of the original scope, thus running &lt;code&gt;Controller&lt;/code&gt;'s &lt;code&gt;hideDialog&lt;/code&gt; function.</source>
          <target state="translated">사용자 가 대화 상자 에서 &lt;code&gt;x&lt;/code&gt; 를 클릭하면 &lt;code&gt;ng-click.&lt;/code&gt; 덕분에 지시문의 &lt;code&gt;close&lt;/code&gt; 기능이 호출 됩니다. 격리 된 범위 를 &lt;code&gt;close&lt;/code&gt; 이 호출은 실제로 원래 범위의 컨텍스트에서 표현식 &lt;code&gt;hideDialog(message)&lt;/code&gt; 를 평가 하므로 &lt;code&gt;Controller&lt;/code&gt; 의 &lt;code&gt;hideDialog&lt;/code&gt; 함수 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="88a38c58d7d80b367d19d209a82c71a873027d20" translate="yes" xml:space="preserve">
          <source>When there are multiple directives defined on a single DOM element, sometimes it is necessary to specify the order in which the directives are applied. The &lt;code&gt;priority&lt;/code&gt; is used to sort the directives before their &lt;code&gt;compile&lt;/code&gt; functions get called. Priority is defined as a number. Directives with greater numerical &lt;code&gt;priority&lt;/code&gt; are compiled first. Pre-link functions are also run in priority order, but post-link functions are run in reverse order. The order of directives with the same priority is undefined. The default priority is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">단일 DOM 요소에 여러 지시문이 정의 된 경우 지시문이 적용되는 순서를 지정해야하는 경우가 있습니다. &lt;code&gt;priority&lt;/code&gt; 그 전에 지시를 정렬하는 데 사용되는 &lt;code&gt;compile&lt;/code&gt; 기능이 호출됩니다. 우선 순위는 숫자로 정의됩니다. &lt;code&gt;priority&lt;/code&gt; 가 더 큰 지시문이 먼저 컴파일됩니다. 사전 링크 기능도 우선 순위에 따라 실행되지만 사후 링크 기능은 역순으로 실행됩니다. 우선 순위가 같은 지시문의 순서는 정의되어 있지 않습니다. 기본 우선 순위는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="848b2612d0c87e93e24fbe2550122caa0f1c577b" translate="yes" xml:space="preserve">
          <source>When this css rule is loaded by the browser, all html elements (including their children) that are tagged with the &lt;code&gt;ngCloak&lt;/code&gt; directive are hidden. When AngularJS encounters this directive during the compilation of the template it deletes the &lt;code&gt;ngCloak&lt;/code&gt; element attribute, making the compiled element visible.</source>
          <target state="translated">이 CSS 규칙이 브라우저에 의해로드되면 &lt;code&gt;ngCloak&lt;/code&gt; 지시문으로 태그가 지정된 모든 html 요소 (자식 포함) 가 숨겨집니다. 템플릿을 컴파일하는 동안 AngularJS가이 지시어를 만나면 &lt;code&gt;ngCloak&lt;/code&gt; 요소 속성 이 삭제 되어 컴파일 된 요소가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fc91990fa11ae11c26ee5a24353aaebf1125812" translate="yes" xml:space="preserve">
          <source>When this property is set to true (default is &lt;code&gt;false&lt;/code&gt;), the HTML compiler will collect DOM nodes between nodes with the attributes &lt;code&gt;directive-name-start&lt;/code&gt; and &lt;code&gt;directive-name-end&lt;/code&gt;, and group them together as the directive elements. It is recommended that this feature be used on directives which are not strictly behavioral (such as &lt;a href=&quot;../directive/ngclick&quot;&gt;&lt;code&gt;ngClick&lt;/code&gt;&lt;/a&gt;), and which do not manipulate or replace child nodes (such as &lt;a href=&quot;../directive/nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 속성이 true로 설정되면 (기본값은 &lt;code&gt;false&lt;/code&gt; ) HTML 컴파일러는 &lt;code&gt;directive-name-start&lt;/code&gt; 및 &lt;code&gt;directive-name-end&lt;/code&gt; 속성을 가진 노드 사이에서 DOM 노드를 수집 하여 지시문 요소로 그룹화합니다. 이 기능은 엄격하게 동작 하지 않는 (예 : &lt;a href=&quot;../directive/nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; ) 하위 노드를 조작하거나 대체하지 않는 지시문 (예 : &lt;a href=&quot;../directive/ngclick&quot;&gt; &lt;code&gt;ngClick&lt;/code&gt; &lt;/a&gt; ) 에 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0235d8d7bcd040be16e73b4398069ebc939ca474" translate="yes" xml:space="preserve">
          <source>When to use directives, controllers or services</source>
          <target state="translated">지시문, 컨트롤러 또는 서비스를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="799c93d8465b6c7356d72990ebf0c31dcca5897e" translate="yes" xml:space="preserve">
          <source>When unit testing (using &lt;a href=&quot;../../ngmock&quot;&gt;ngMock&lt;/a&gt;), it is necessary to call &lt;a href=&quot;../../ngmock/service/%24httpbackend#flush.html&quot;&gt;$httpBackend.flush()&lt;/a&gt; to flush each pending request using trained responses.</source>
          <target state="translated">단위 테스트 ( &lt;a href=&quot;../../ngmock&quot;&gt;ngMock&lt;/a&gt; 사용 )를 수행 할 때 &lt;a href=&quot;../../ngmock/service/%24httpbackend#flush.html&quot;&gt;$ httpBackend.flush ()&lt;/a&gt; 를 호출 하여 훈련 된 응답을 사용하여 보류중인 각 요청을 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="866465e227471da7aace7e851aaccc0bf7b51a44" translate="yes" xml:space="preserve">
          <source>When used with standard inputs, the view value will always be a string (which is in some cases parsed into another type, such as a &lt;code&gt;Date&lt;/code&gt; object for &lt;code&gt;input[date]&lt;/code&gt;.) However, custom controls might also pass objects to this method. In this case, we should make a copy of the object before passing it to &lt;code&gt;$setViewValue&lt;/code&gt;. This is because &lt;code&gt;ngModel&lt;/code&gt; does not perform a deep watch of objects, it only looks for a change of identity. If you only change the property of the object then ngModel will not realize that the object has changed and will not invoke the &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$validators&lt;/code&gt; pipelines. For this reason, you should not change properties of the copy once it has been passed to &lt;code&gt;$setViewValue&lt;/code&gt;. Otherwise you may cause the model value on the scope to change incorrectly.</source>
          <target state="translated">표준 입력과 함께 사용하면보기 값은 항상 문자열이됩니다 (일부 경우 &lt;code&gt;input[date]&lt;/code&gt; 의 &lt;code&gt;Date&lt;/code&gt; 객체 와 같은 다른 유형으로 구문 분석 됨 ). 그러나 사용자 정의 컨트롤은이 메소드에 객체를 전달할 수도 있습니다. 이 경우 &lt;code&gt;$setViewValue&lt;/code&gt; 전달하기 전에 객체의 복사본을 만들어야 합니다. 이는 &lt;code&gt;ngModel&lt;/code&gt; 이 객체에 대한 심층 감시를 수행하지 않기 때문에 변경 사항 만 찾습니다. 객체의 속성 만 변경하면 ngModel은 객체가 변경되었음을 인식하지 못하고 &lt;code&gt;$parsers&lt;/code&gt; 및 &lt;code&gt;$validators&lt;/code&gt; 파이프 라인을 호출하지 않습니다 . 따라서 복사본이 전달 된 후에는 복사본의 속성을 변경해서는 안됩니다. &lt;code&gt;$setViewValue&lt;/code&gt; . 그렇지 않으면 범위의 모델 값이 잘못 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc64a729cd2e490dc065221b82d1cb45ab84daeb" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../api/ngroute/provider/%24routeprovider&quot;&gt;$routeProvider&lt;/a&gt;, you can often avoid some boilerplate, by passing the resolved route dependencies directly to the component. Since 1.5, ngRoute automatically assigns the resolves to the route scope property &lt;code&gt;$resolve&lt;/code&gt; (you can also configure the property name via &lt;code&gt;resolveAs&lt;/code&gt;). When using components, you can take advantage of this and pass resolves directly into your component without creating an extra route controller:</source>
          <target state="translated">&lt;a href=&quot;../api/ngroute/provider/%24routeprovider&quot;&gt;$ routeProvider를&lt;/a&gt; 사용 하면 해결 된 경로 종속성을 구성 요소에 직접 전달하여 일부 상용구를 피할 수 있습니다. 1.5 이후 ngRoute는 자동으로 확인을 경로 범위 속성 &lt;code&gt;$resolve&lt;/code&gt; 할당합니다 ( &lt;code&gt;resolveAs&lt;/code&gt; 를 통해 속성 이름을 구성 할 수도 있습니다 ). 컴포넌트를 사용할 때 추가 라우트 컨트롤러를 작성하지 않고이를 활용하여 컴포넌트로 직접 해석을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ba0f63480183afb2de1595c7ae8b25bef84a87f" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; and / or &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt; to toggle between elements, it can happen that both the element to show and the element to hide are visible for a very short time.</source>
          <target state="translated">&lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt; 를 사용하여 요소 간을 전환하면 표시 할 요소와 숨길 요소가 아주 짧은 시간 동안 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d06d724db84ddaaec9c56ac07d4b9edf55b4c22" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;$location&lt;/code&gt; service during testing, you are outside of the angular's &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt; life-cycle. This means it's your responsibility to call &lt;code&gt;scope.$apply()&lt;/code&gt;.</source>
          <target state="translated">테스트 중에 &lt;code&gt;$location&lt;/code&gt; 서비스를 사용 하는 경우 각도의 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;범위&lt;/a&gt; 수명주기를 벗어납니다 . 즉, &lt;code&gt;scope.$apply()&lt;/code&gt; 를 호출하는 것은 귀하의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="308def7ce1040ce8f8e90c771104d822bf9c454e" translate="yes" xml:space="preserve">
          <source>When using a directive that takes an expression:</source>
          <target state="translated">표현식을 사용하는 지시문을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="9af3cc5f2e0ae3fda308cd5ccc2df4b745158ea7" translate="yes" xml:space="preserve">
          <source>When using a directive with bidirectional binding and parameters that will not change:</source>
          <target state="translated">양방향 바인딩 및 변경되지 않는 매개 변수와 함께 지시문을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ce320691763ef56ed7bc8d8107895e1c4a8418eb" translate="yes" xml:space="preserve">
          <source>When using this type of annotation, take care to keep the annotation array in sync with the parameters in the function declaration.</source>
          <target state="translated">이 유형의 주석을 사용할 때는 주석 배열이 함수 선언의 매개 변수와 동기화되도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="0788f3e044fd333f645148040ef0b7a3426b7c04" translate="yes" xml:space="preserve">
          <source>When you call a transclude function it returns a DOM fragment that is pre-bound to a &lt;strong&gt;transclusion scope&lt;/strong&gt;. This scope is special, in that it is a child of the directive's scope (and so gets destroyed when the directive's scope gets destroyed) but it inherits the properties of the scope from which it was taken.</source>
          <target state="translated">transclude 함수를 호출하면 &lt;strong&gt;transclusion scope에&lt;/strong&gt; 사전 바인딩 된 DOM 단편이 리턴 &lt;strong&gt;됩니다&lt;/strong&gt; . 이 범위는 지시문 범위의 자식이므로 지시문 범위가 소멸 될 때 소멸된다는 점에서 특별하지만, 해당 범위의 특성을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="adc8cb01135df3a93cfcf63923b01b0b4bcfd2e2" translate="yes" xml:space="preserve">
          <source>When you call a transclusion function you can pass in a &lt;strong&gt;clone attach function&lt;/strong&gt;. This function accepts two parameters, &lt;code&gt;function(clone, scope) { ... }&lt;/code&gt;, where the &lt;code&gt;clone&lt;/code&gt; is a fresh compiled copy of your transcluded content and the &lt;code&gt;scope&lt;/code&gt; is the newly created transclusion scope, which the clone will be linked to.</source>
          <target state="translated">transclusion 함수를 호출하면 &lt;strong&gt;clone attach 함수를&lt;/strong&gt; 전달할 수 있습니다 . 이 함수는 &lt;code&gt;function(clone, scope) { ... }&lt;/code&gt; 두 매개 변수를 허용합니다 . 여기서 &lt;code&gt;clone&lt;/code&gt; 은 변환 된 컨텐츠 의 새로 컴파일 된 사본이고 &lt;code&gt;scope&lt;/code&gt; 는 복제본이 링크 될 새로 작성된 변환 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c0d63bac8ebb474dd0a18c50994a65c24b136a76" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;absUrl()&lt;/code&gt; method, the returned value is a full url with its segments encoded.</source>
          <target state="translated">&lt;code&gt;absUrl()&lt;/code&gt; 메서드 를 호출하면 반환 된 값은 해당 세그먼트가 인코딩 된 전체 URL입니다.</target>
        </trans-unit>
        <trans-unit id="96856534f37714d279ae2c0dc01f3e86884722a6" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;url()&lt;/code&gt; method, the returned value is path, search and hash, in the form &lt;code&gt;/path?search=a&amp;amp;b=c#hash&lt;/code&gt;. The segments are encoded as well.</source>
          <target state="translated">&lt;code&gt;url()&lt;/code&gt; 메서드 를 호출하면 반환 된 값은 &lt;code&gt;/path?search=a&amp;amp;b=c#hash&lt;/code&gt; 형식의 path, search 및 hash 입니다. 세그먼트도 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8e2a897977982bc35240ddd6d90240a08cedadc8" translate="yes" xml:space="preserve">
          <source>When you request a service, the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt; is responsible for finding the correct &lt;strong&gt;service provider&lt;/strong&gt;, instantiating it and then calling its &lt;code&gt;$get&lt;/code&gt;&lt;strong&gt;service factory&lt;/strong&gt; function to get the instance of the &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">당신이 서비스를 요청하면 &lt;a href=&quot;%24injector&quot;&gt;$ 인젝터는&lt;/a&gt; 올바른 발견에 대한 책임 &lt;strong&gt;서비스 제공 업체&lt;/strong&gt; , 그것을 인스턴스화하고 그것의 호출 &lt;code&gt;$get&lt;/code&gt; &lt;strong&gt;서비스 공장&lt;/strong&gt; 의 인스턴스를 얻을 기능을 &lt;strong&gt;서비스&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6de81ecf4cb6e26917389d536bee77c7c57932" translate="yes" xml:space="preserve">
          <source>When you use HTML5 history API mode, you will not need special hashbang links. All you have to do is specify regular URL links, such as: &lt;code&gt;&amp;lt;a href=&quot;/some?foo=bar&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</source>
          <target state="translated">HTML5 히스토리 API 모드를 사용하는 경우 특수 해시 뱅 링크가 필요하지 않습니다. &lt;code&gt;&amp;lt;a href=&quot;/some?foo=bar&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt; 와 같은 일반 URL 링크 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8d89b9c3c7ad0e72f71a638e459b847a4a1b6c92" translate="yes" xml:space="preserve">
          <source>Whenever an animation is started, &lt;code&gt;ngAnimate&lt;/code&gt; applies the &lt;code&gt;ng-animate&lt;/code&gt; class to the element for the whole duration of the animation. By applying CSS transition / animation styling to that class, you can skip an animation:</source>
          <target state="translated">애니메이션이 시작될 때마다 &lt;code&gt;ngAnimate&lt;/code&gt; 는 &lt;code&gt;ng-animate&lt;/code&gt; 의 전체 지속 시간 동안 ng-animate 클래스를 요소에 적용합니다 . 해당 클래스에 CSS 전환 / 애니메이션 스타일을 적용하면 애니메이션을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986037565cd6579ad9d0ba68772c304b34c53a56" translate="yes" xml:space="preserve">
          <source>Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter and leave animation is triggered for each particular element bound to the &lt;code&gt;ngMessage&lt;/code&gt; directive.</source>
          <target state="translated">내부 메시지가 첨부 (표시)되거나 제거 (숨겨 &lt;code&gt;ngMessage&lt;/code&gt; 될 때 마다 ngMessage 지시문에 바인딩 된 각 특정 요소에 대해 enter 및 leave 애니메이션이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="65ee722d839e36aed52fa460253fb75029459549" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;ngMessages&lt;/code&gt; directive contains one or more visible messages then the &lt;code&gt;.ng-active&lt;/code&gt; CSS class will be added to the element. The &lt;code&gt;.ng-inactive&lt;/code&gt; CSS class will be applied when there are no messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can hook into the animations whenever these classes are added/removed.</source>
          <target state="translated">때마다 &lt;code&gt;ngMessages&lt;/code&gt; 의 지시어는 하나 이상의 눈에 보이는 메시지가 포함 된 &lt;code&gt;.ng-active&lt;/code&gt; CSS 클래스는 요소에 추가됩니다. &lt;code&gt;.ng-inactive&lt;/code&gt; 현재 메시지가 없을 때 CSS 클래스가 적용됩니다. 따라서 JavaScript 전환뿐만 아니라 CSS 전환 및 키 프레임도 이러한 클래스를 추가 / 제거 할 때마다 애니메이션에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7960d3c2618b44613a36486dbb58d967ec476048" translate="yes" xml:space="preserve">
          <source>Whenever your application makes requests to a server there are potential security issues that need to be blocked. Both server and the client must cooperate in order to eliminate these threats. AngularJS comes pre-configured with strategies that address these issues, but for this to work backend server cooperation is required.</source>
          <target state="translated">응용 프로그램이 서버에 요청할 때마다 차단해야 할 잠재적 인 보안 문제가 있습니다. 이러한 위협을 제거하려면 서버와 클라이언트 모두 협력해야합니다. AngularJS에는 이러한 문제를 해결하는 전략이 사전 구성되어 있지만이를 위해서는 백엔드 서버 협력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="460854c303f2e0076b9be3c2cbeafbd2741f25c0" translate="yes" xml:space="preserve">
          <source>Where the compiler has created a new scope, the scope and either &lt;code&gt;ng-scope&lt;/code&gt; or &lt;code&gt;ng-isolated-scope&lt;/code&gt; CSS class are attached to the corresponding element. These scope references can then be accessed via &lt;code&gt;element.scope()&lt;/code&gt; and &lt;code&gt;element.isolateScope()&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 새 범위를 만든 경우 범위와 &lt;code&gt;ng-scope&lt;/code&gt; 또는 &lt;code&gt;ng-isolated-scope&lt;/code&gt; CSS 클래스가 해당 요소에 연결됩니다. 그런 다음 &lt;code&gt;element.scope()&lt;/code&gt; 및 &lt;code&gt;element.isolateScope()&lt;/code&gt; 를 통해 이러한 범위 참조에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="750881ed39d8d4dbbabc8a525246358035450087" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;ngInclude&lt;/code&gt; should call &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$anchorScroll&lt;/a&gt; to scroll the viewport after the content is loaded.</source>
          <target state="translated">여부 &lt;code&gt;ngInclude&lt;/code&gt; 는 호출해야 &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$ anchorScroll을&lt;/a&gt; 내용이로드 된 후 뷰포트를 스크롤 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e30e407f19a0df15c35e9a06f966233d1296da" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;ngView&lt;/code&gt; should call &lt;a href=&quot;../../ng/service/%24anchorscroll&quot;&gt;$anchorScroll&lt;/a&gt; to scroll the viewport after the view is updated.</source>
          <target state="translated">여부 &lt;code&gt;ngView&lt;/code&gt; 는 호출해야 &lt;a href=&quot;../../ng/service/%24anchorscroll&quot;&gt;$ anchorScroll을&lt;/a&gt; 보기가 업데이트 된 후 뷰포트를 스크롤 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0799f71a28a8d4e41670e7cf10ec92b54b2fb4f" translate="yes" xml:space="preserve">
          <source>Whether or not to ignore the exception when the request fails or the template is empty</source>
          <target state="translated">요청이 실패하거나 템플릿이 비어있을 때 예외를 무시할지 여부</target>
        </trans-unit>
        <trans-unit id="7a494ff3bb52752d0bc384651bd7d37989465cdc" translate="yes" xml:space="preserve">
          <source>Whether the current state is valid (true), invalid (false), pending (undefined), or skipped (null). Pending is used for unfulfilled &lt;code&gt;$asyncValidators&lt;/code&gt;. Skipped is used by AngularJS when validators do not run because of parse errors and when &lt;code&gt;$asyncValidators&lt;/code&gt; do not run because any of the &lt;code&gt;$validators&lt;/code&gt; failed.</source>
          <target state="translated">현재 상태가 유효한지 (true), 유효하지 않은 (false), 보류중인 (정의되지 않은) 또는 건너 뛴 (null)인지 여부 보류는 &lt;code&gt;$asyncValidators&lt;/code&gt; 사용됩니다 . 구문 분석 오류로 인해 유효성 검사기가 실행 되지 않고 &lt;code&gt;$validators&lt;/code&gt; 중 하나가 실패 하여 $ &lt;code&gt;$asyncValidators&lt;/code&gt; 가 실행되지 않는 경우 AngularJS에서 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="a7d197b14bb22dde26e7930ba72573db4afd74e5" translate="yes" xml:space="preserve">
          <source>Whether the injector should be in strict mode, which disallows argument name annotation inference.</source>
          <target state="translated">인젝터가 엄격 모드에 있어야하는지 여부로 인수 이름 주석 유추를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64739ed39c37793d5116ffd8cf13bce51648999d" translate="yes" xml:space="preserve">
          <source>Whether to generate an error when a rejected promise is not handled.</source>
          <target state="translated">거부 된 약속이 처리되지 않은 경우 오류를 생성할지 여부</target>
        </trans-unit>
        <trans-unit id="04340f702909efe15652bdcae7630aa8d0a6c6a3" translate="yes" xml:space="preserve">
          <source>Which directives support animations?</source>
          <target state="translated">애니메이션을 지원하는 지시문은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="202e1367c10ec97bf55bcb003c4e2b1a5fb4d701" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;ngMessages&lt;/code&gt; will by default only display one error element at a time, the &lt;code&gt;ng-messages-multiple&lt;/code&gt; attribute can be applied to the &lt;code&gt;ngMessages&lt;/code&gt; container element to cause it to display all applicable error messages at once:</source>
          <target state="translated">&lt;code&gt;ngMessages&lt;/code&gt; 는 기본적으로 한 번에 하나의 오류 요소 만 표시 하지만 &lt;code&gt;ng-messages-multiple&lt;/code&gt; 속성을 &lt;code&gt;ngMessages&lt;/code&gt; 컨테이너 요소에 적용하여 적용 가능한 모든 오류 메시지를 한 번에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61c2bda7d6957ce6223a10bb226a52513d7256a" translate="yes" xml:space="preserve">
          <source>While a plural category may match many numbers (for example, in en-US locale, &quot;other&quot; can match any number that is not 1), an explicit number rule can only match one number. For example, the explicit number rule for &quot;3&quot; matches the number 3. There are examples of plural categories and explicit number rules throughout the rest of this documentation.</source>
          <target state="translated">복수 범주가 많은 숫자와 일치 할 수 있지만 (예 : en-US 로케일에서 &quot;other&quot;는 1이 아닌 숫자와 일치 할 수 있음) 명시 적 숫자 규칙은 하나의 숫자 만 일치 할 수 있습니다. 예를 들어, &quot;3&quot;의 명시 적 숫자 규칙은 숫자 3과 일치합니다.이 문서의 나머지 부분에는 복수 범주 및 명시 적 숫자 규칙의 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f1a4c7640c97be8f83de892ee1d05acd23dd84" translate="yes" xml:space="preserve">
          <source>While it is recommended to register injectables directly with the &lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;module API&lt;/a&gt;, it is also possible to register services, directives etc. by injecting &lt;a href=&quot;../api/auto/service/%24provide&quot;&gt;$provide&lt;/a&gt; or the individual service providers into the config function:</source>
          <target state="translated">&lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;모듈 API로&lt;/a&gt; 직접 인젝터 블을 등록하는 것이 좋지만 &lt;a href=&quot;../api/auto/service/%24provide&quot;&gt;$ provide&lt;/a&gt; 또는 개별 서비스 제공자를 config 함수 에 삽입하여 서비스, 지시문 등을 등록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79ae9ea22fa5db92c007dbd07a4fbcab0aa55fb4" translate="yes" xml:space="preserve">
          <source>While it's possible to bootstrap more than one AngularJS application per page, we don't actively test against this scenario. It's possible that you'll run into problems, especially with complex apps, so caution is advised.</source>
          <target state="translated">페이지 당 둘 이상의 AngularJS 애플리케이션을 부트 스트랩 할 수 있지만이 시나리오에 대해서는 적극적으로 테스트하지 않습니다. 특히 복잡한 앱에서 문제가 발생할 수 있으므로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a82dee00b39d8daed1da5528800a8c7ddbde426f" translate="yes" xml:space="preserve">
          <source>While the constructor-style use is supported, not all of the supporting methods from ES6 promises are available yet.</source>
          <target state="translated">생성자 스타일 사용이 지원되지만 ES6 약속의 모든 지원 방법을 아직 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6cf978fc045daec3f25c0b99dc31760cd612ada9" translate="yes" xml:space="preserve">
          <source>While the example above is simple, it will not scale to large applications. Instead we recommend that you break your application to multiple modules like this:</source>
          <target state="translated">위의 예는 간단하지만 큰 응용 프로그램으로 확장되지는 않습니다. 대신 다음과 같이 응용 프로그램을 여러 모듈로 나누는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc6d8b80151efa65b509365d35de859e6d9b813c" translate="yes" xml:space="preserve">
          <source>While this may seem obvious it can be very difficult to call an individual function on a typical project. The reason is that the developers often mix concerns resulting in a piece of code which does everything. It makes an XHR request, it sorts the response data, and then it manipulates the DOM.</source>
          <target state="translated">이것이 명백해 보일 수 있지만 일반적인 프로젝트에서 개별 함수를 호출하는 것은 매우 어려울 수 있습니다. 그 이유는 개발자가 종종 우려 사항을 혼합하여 모든 것을 수행하는 코드를 생성하기 때문입니다. XHR 요청을 만들고 응답 데이터를 정렬 한 다음 DOM을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="5d61d9a0a6e161682e0342ed06bfaa12eee85ebc" translate="yes" xml:space="preserve">
          <source>Why Dependency Injection?</source>
          <target state="translated">왜 의존성 주입인가?</target>
        </trans-unit>
        <trans-unit id="669ff9e2a6793d3b75b94d0260040d47b3cbc679" translate="yes" xml:space="preserve">
          <source>Why is !important used?</source>
          <target state="translated">왜 중요한가 사용됩니까?</target>
        </trans-unit>
        <trans-unit id="4616c58d9adc2d069251d8014e9dc1d4fb26a27f" translate="yes" xml:space="preserve">
          <source>Why mixing interpolation and expressions is bad practice:</source>
          <target state="translated">보간과 표현식을 혼합하는 것이 좋지 않은 이유 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
