<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="8039a41e04b2332bb9a1e006d40250afbf96b442" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2019 Facebook, Inc. and its affiliates.</source>
          <target state="translated">&amp;copy; 2019 Facebook, Inc. 및 그 계열사.</target>
        </trans-unit>
        <trans-unit id="8733204266bf9ef9d139b9cd40bbd88f570127e5" translate="yes" xml:space="preserve">
          <source>(default: &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt;)</source>
          <target state="translated">(기본값 : &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e44ebb5582c56abe12f2669212eb5c60e8d4853b" translate="yes" xml:space="preserve">
          <source>* Module factory function must return a function</source>
          <target state="translated">* 모듈 팩토리 함수는 함수를 반환해야합니다</target>
        </trans-unit>
        <trans-unit id="11a99659b9799607d24f99d1703d405ff90c24fb" translate="yes" xml:space="preserve">
          <source>. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="translated">. 겹치지 않도록 충돌하는 플러그인 중 하나의 키 구성을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="af6ed7ba3a77d9c9041d1f9f34a1c12b90a41d5b" translate="yes" xml:space="preserve">
          <source>.not</source>
          <target state="translated">.not</target>
        </trans-unit>
        <trans-unit id="37f06d3dd43811fb4a3a366255d459cfd648f809" translate="yes" xml:space="preserve">
          <source>.rejects</source>
          <target state="translated">.rejects</target>
        </trans-unit>
        <trans-unit id="3a41b0fffb37be03170b7fc364408f5627fb6783" translate="yes" xml:space="preserve">
          <source>.resolves</source>
          <target state="translated">.resolves</target>
        </trans-unit>
        <trans-unit id="676b70f0ba2473d03d5c38bd58a4c33f141c1881" translate="yes" xml:space="preserve">
          <source>.toBe()</source>
          <target state="translated">.toBe()</target>
        </trans-unit>
        <trans-unit id="32a2cc64ae6a3e2a930d047916b812fe4b5d0e88" translate="yes" xml:space="preserve">
          <source>.toBeCloseTo()</source>
          <target state="translated">.toBeCloseTo()</target>
        </trans-unit>
        <trans-unit id="99ce778367e3457801132fbd52692b493aa35f2b" translate="yes" xml:space="preserve">
          <source>.toBeDefined()</source>
          <target state="translated">.toBeDefined()</target>
        </trans-unit>
        <trans-unit id="9b3929ba1aa6dd0ddf943ca0e147dbc91d13488d" translate="yes" xml:space="preserve">
          <source>.toBeFalsy()</source>
          <target state="translated">.toBeFalsy()</target>
        </trans-unit>
        <trans-unit id="8d1c7e785d4737e92e5db59d84e589ec79a15f1a" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThan()</source>
          <target state="translated">.toBeGreaterThan()</target>
        </trans-unit>
        <trans-unit id="f276b89d8cc696f904c15a937aa2c4f57049c9d8" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThanOrEqual()</source>
          <target state="translated">.toBeGreaterThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="6bff9db7ccc5307cb1baba71f20f8dcb5eca7313" translate="yes" xml:space="preserve">
          <source>.toBeInstanceOf()</source>
          <target state="translated">.toBeInstanceOf()</target>
        </trans-unit>
        <trans-unit id="647d1cf6ca2e0af2106268548794474115aea36d" translate="yes" xml:space="preserve">
          <source>.toBeLessThan()</source>
          <target state="translated">.toBeLessThan()</target>
        </trans-unit>
        <trans-unit id="ea2494b392db9dcab4645d97c83fd9a2182286e4" translate="yes" xml:space="preserve">
          <source>.toBeLessThanOrEqual()</source>
          <target state="translated">.toBeLessThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="720a4c5d8244f39f9f666e702c0e3852b57afea2" translate="yes" xml:space="preserve">
          <source>.toBeNaN()</source>
          <target state="translated">.toBeNaN()</target>
        </trans-unit>
        <trans-unit id="f0c9793c8f304879d82d7089132a47ef6cfb8593" translate="yes" xml:space="preserve">
          <source>.toBeNull()</source>
          <target state="translated">.toBeNull()</target>
        </trans-unit>
        <trans-unit id="077ff246559a6d00501b8fa5b20b80ff03301608" translate="yes" xml:space="preserve">
          <source>.toBeTruthy()</source>
          <target state="translated">.toBeTruthy()</target>
        </trans-unit>
        <trans-unit id="98663990dec7535feda7d7a24ff1693d1049c82f" translate="yes" xml:space="preserve">
          <source>.toBeUndefined()</source>
          <target state="translated">.toBeUndefined()</target>
        </trans-unit>
        <trans-unit id="7d1504d2c8e2ced7a503f0d02d0ca0a94cd67568" translate="yes" xml:space="preserve">
          <source>.toContain()</source>
          <target state="translated">.toContain()</target>
        </trans-unit>
        <trans-unit id="4bcc79e6f40ce4c5625a5d71c2dbc2a433e04c9c" translate="yes" xml:space="preserve">
          <source>.toContainEqual()</source>
          <target state="translated">.toContainEqual()</target>
        </trans-unit>
        <trans-unit id="26decec7a3cac6d27508b590d0ba65718d5b2de4" translate="yes" xml:space="preserve">
          <source>.toEqual()</source>
          <target state="translated">.toEqual()</target>
        </trans-unit>
        <trans-unit id="4e3793133f260880cc150fb12b6d7f1c053f3550" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalled()</source>
          <target state="translated">.toHaveBeenCalled()</target>
        </trans-unit>
        <trans-unit id="00772fdde0f479a0db9548a093488dcfd5588cc9" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledTimes()</source>
          <target state="translated">.toHaveBeenCalledTimes()</target>
        </trans-unit>
        <trans-unit id="1dfa8f19daae4c3dc83cbec00ad04f332c9915ae" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledWith()</source>
          <target state="translated">.toHaveBeenCalledWith()</target>
        </trans-unit>
        <trans-unit id="5959332ef495a103a4ccdc29a0e15aa7a7565d05" translate="yes" xml:space="preserve">
          <source>.toHaveBeenLastCalledWith()</source>
          <target state="translated">.toHaveBeenLastCalledWith()</target>
        </trans-unit>
        <trans-unit id="a3a97daff76f81f78afb83c331fc23947a78f45c" translate="yes" xml:space="preserve">
          <source>.toHaveBeenNthCalledWith()</source>
          <target state="translated">.toHaveBeenNthCalledWith()</target>
        </trans-unit>
        <trans-unit id="0c161a4b9f0d771ccd327f65278e09178b507795" translate="yes" xml:space="preserve">
          <source>.toHaveLastReturnedWith()</source>
          <target state="translated">.toHaveLastReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a0443d967f32f1308634aa976c0d469385693824" translate="yes" xml:space="preserve">
          <source>.toHaveLength()</source>
          <target state="translated">.toHaveLength()</target>
        </trans-unit>
        <trans-unit id="794f45b9cd4158e59c5c292424191e68bf89e18e" translate="yes" xml:space="preserve">
          <source>.toHaveNthReturnedWith()</source>
          <target state="translated">.toHaveNthReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a6dd5320db9ee9d51d1c8e22c168ba712935f3bb" translate="yes" xml:space="preserve">
          <source>.toHaveProperty()</source>
          <target state="translated">.toHaveProperty()</target>
        </trans-unit>
        <trans-unit id="44f8374b7809b36963550595e06fff53b46f64bb" translate="yes" xml:space="preserve">
          <source>.toHaveReturned()</source>
          <target state="translated">.toHaveReturned()</target>
        </trans-unit>
        <trans-unit id="e3c3d3edd9ad715908bf398891fb02d0c3c4932a" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedTimes()</source>
          <target state="translated">.toHaveReturnedTimes()</target>
        </trans-unit>
        <trans-unit id="a5111ab06a437a3308c64674fc8fd62826ee0969" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedWith()</source>
          <target state="translated">.toHaveReturnedWith()</target>
        </trans-unit>
        <trans-unit id="2e70316fe3608fd8ec3c03f9f87028c2c8363a05" translate="yes" xml:space="preserve">
          <source>.toMatch()</source>
          <target state="translated">.toMatch()</target>
        </trans-unit>
        <trans-unit id="73905b27654bb05043f04e3456080771951db1fd" translate="yes" xml:space="preserve">
          <source>.toMatchInlineSnapshot()</source>
          <target state="translated">.toMatchInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dd215f94d457250f89ee5c13cffb1d58a988815c" translate="yes" xml:space="preserve">
          <source>.toMatchObject()</source>
          <target state="translated">.toMatchObject()</target>
        </trans-unit>
        <trans-unit id="7f8b4f8d30db6de4b405874a76c6a2f72c9f3142" translate="yes" xml:space="preserve">
          <source>.toMatchSnapshot()</source>
          <target state="translated">.toMatchSnapshot()</target>
        </trans-unit>
        <trans-unit id="67a75a5640e37db5bf286c0733cf73807148ddcc" translate="yes" xml:space="preserve">
          <source>.toStrictEqual()</source>
          <target state="translated">.toStrictEqual()</target>
        </trans-unit>
        <trans-unit id="daf6eadfb4ea82a0e7b370d4eb7e4e557cfec7c3" translate="yes" xml:space="preserve">
          <source>.toThrow()</source>
          <target state="translated">.toThrow()</target>
        </trans-unit>
        <trans-unit id="821616a911f93e7076cfbb743c648b0dc07240e2" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingInlineSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dfc790de4e060a8cb2c6a3f3d9107f894635d8e4" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingSnapshot()</target>
        </trans-unit>
        <trans-unit id="d02f00544c5410b45100d8c26dc869d32c374dae" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;describe.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">1. &lt;code&gt;describe.each(table)(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad05971b070fbc37cf9c07f4fcefdbfe80d469c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;test.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">1. &lt;code&gt;test.each(table)(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ce2deb0fd00df7e1bc70232ca6e95f15b442ea2" translate="yes" xml:space="preserve">
          <source>1. Treat snapshots as code</source>
          <target state="translated">1. 스냅 샷을 코드로 취급</target>
        </trans-unit>
        <trans-unit id="fa3a6811ab29a636472dbcf19ebed735d5088990" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;describe.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">2. &lt;code&gt;describe.each`table`(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15d60d82552a2ba8086d2f9a363a55553cd0161d" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;test.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">2. &lt;code&gt;test.each`table`(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0759e7d1939c65b0a51804dcf5e0e9eff89e699a" translate="yes" xml:space="preserve">
          <source>2. Tests should be deterministic</source>
          <target state="translated">2. 테스트는 결정 론적이어야한다</target>
        </trans-unit>
        <trans-unit id="4054a23d3f0fea28f4ad5c16a5e2746a51ebdac4" translate="yes" xml:space="preserve">
          <source>3. Use descriptive snapshot names</source>
          <target state="translated">설명적인 스냅 샷 이름 사용</target>
        </trans-unit>
        <trans-unit id="63d3cdecff2c457d98abdf63eb1eed93ccea97ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/&quot;&gt;How to test Express.js with Jest and Supertest&lt;/a&gt; by Albert Gao (&lt;a href=&quot;https://twitter.com/albertgao&quot;&gt;@albertgao&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/&quot;&gt;&lt;/a&gt;Albert Gao의 @ Jest 및 Supertest 로 Express.js를 테스트하는 방법 ( &lt;a href=&quot;https://twitter.com/albertgao&quot;&gt;@albertgao&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4df494206c7fb512291d9c26b280d086c8f68221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/&quot;&gt;Testing Vue.js components with Jest&lt;/a&gt; by Alex Jover Morales (&lt;a href=&quot;https://twitter.com/alexjoverm&quot;&gt;@alexjoverm&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/&quot;&gt;&lt;/a&gt;Alex Jover Morales ( &lt;a href=&quot;https://twitter.com/alexjoverm&quot;&gt;@alexjoverm&lt;/a&gt; )의 Jest 로 Vue.js 구성 요소 테스트</target>
        </trans-unit>
        <trans-unit id="e56b908cf5de025f16168813fe23530da4086bf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://engineering.talentpair.com/running-angularjs-tests-with-jest-49d0cc9c6d26&quot;&gt;Running AngularJS Tests with Jest&lt;/a&gt; by Ben Brandt (&lt;a href=&quot;https://twitter.com/benjaminbrandt&quot;&gt;@benjaminbrandt&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://engineering.talentpair.com/running-angularjs-tests-with-jest-49d0cc9c6d26&quot;&gt;&lt;/a&gt;Ben Brandt의 Jest 로 AngularJS 테스트 실행 ( &lt;a href=&quot;https://twitter.com/benjaminbrandt&quot;&gt;@benjaminbrandt&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a5396961ac6b2c5f21f3d0317ec9f09404d9af19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/jest-community&quot;&gt;jest-community&lt;/a&gt; is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jest-community&quot;&gt;jest-community&lt;/a&gt; 는 Jest 관리자 및 공동 작업자가 선별 한 고품질 Jest 추가를위한 새로운 GitHub 조직입니다. 그것은 이미 우리가 가장 좋아하는 프로젝트 중 일부를 특징으로합니다.</target>
        </trans-unit>
        <trans-unit id="b99bce60cd49efb888fea268162f85d4db8fc8b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;Jest DynamoDB&lt;/a&gt; provides all required configuration to run your tests using DynamoDB.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;Jest DynamoDB&lt;/a&gt; 는 DynamoDB를 사용하여 테스트를 실행하는 데 필요한 모든 구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b359adbc76ca4d01768ec6507a7cd0a41449b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;Jest MongoDB&lt;/a&gt; provides all required configuration to run your tests using MongoDB.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;Jest MongoDB&lt;/a&gt; 는 MongoDB를 사용하여 테스트를 실행하는 데 필요한 모든 구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bb9813ff97e2bfab1d3620d9cd0c674d6c319235" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Jest Puppeteer&lt;/a&gt; provides all required configuration to run your tests using Puppeteer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Jest Puppeteer&lt;/a&gt; 는 Puppeteer를 사용하여 테스트를 실행하는 데 필요한 모든 구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1e5d6a58c8bec76b77a3d04abb1b2a26fc4087e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@kentaromiura_the_js_guy/jest-for-all-episode-1-vue-js-d616bccbe186#.d573vrce2&quot;&gt;Jest for all: Episode 1 &amp;mdash; Vue.js&lt;/a&gt; by Cristian Carlesso (&lt;a href=&quot;https://twitter.com/kentaromiura&quot;&gt;@kentaromiura&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@kentaromiura_the_js_guy/jest-for-all-episode-1-vue-js-d616bccbe186#.d573vrce2&quot;&gt;모두를위한 농담 : Episode 1 &amp;mdash; Vue.js&lt;/a&gt; (Cristian Carlesso) ( &lt;a href=&quot;https://twitter.com/kentaromiura&quot;&gt;@kentaromiura&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fd5742738a051dfb6af1d4fff2bcc31ff0ec9ba9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251&quot;&gt;Testing an AngularJS app with Jest&lt;/a&gt; by Matthieu Lux (&lt;a href=&quot;https://twitter.com/Swiip&quot;&gt;@Swiip&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251&quot;&gt;&lt;/a&gt;Matthieu Lux ( &lt;a href=&quot;https://twitter.com/Swiip&quot;&gt;@Swiip&lt;/a&gt; )의 Jest 로 AngularJS 앱 테스트</target>
        </trans-unit>
        <trans-unit id="8a8c0a5d3a823c18229e23ca4494e3567d0bcdc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redux.js.org/recipes/writing-tests&quot;&gt;Writing Tests&lt;/a&gt; by Redux docs</source>
          <target state="translated">&lt;a href=&quot;https://redux.js.org/recipes/writing-tests&quot;&gt;&lt;/a&gt;Redux 문서 작성 테스트</target>
        </trans-unit>
        <trans-unit id="55111a72c4fd1cefa5bb8c3683ca9b7e0a70243d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest&quot;&gt;How to Test React and MobX with Jest&lt;/a&gt; by Will Stern (&lt;a href=&quot;https://twitter.com/willsterndev&quot;&gt;@willsterndev&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest&quot;&gt;&lt;/a&gt;Will Stern의 Jest 로 React 및 MobX를 테스트하는 방법 ( &lt;a href=&quot;https://twitter.com/willsterndev&quot;&gt;@willsterndev&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4cb86efcd4fb0536b2d852e06deaf03e53e7a7f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/docs/unit-testing/&quot;&gt;Unit Testing&lt;/a&gt; by GatsbyJS docs</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/docs/unit-testing/&quot;&gt;&lt;/a&gt;GatsbyJS 문서에 의한 단위 테스트</target>
        </trans-unit>
        <trans-unit id="d81eac7c1a1ce0cc4e092235c95a04493ca09f53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.xfive.co/blog/testing-angular-faster-jest/&quot;&gt;Testing Angular faster with Jest&lt;/a&gt; by Michał Pierzchała (&lt;a href=&quot;https://twitter.com/thymikee&quot;&gt;@thymikee&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://www.xfive.co/blog/testing-angular-faster-jest/&quot;&gt;&lt;/a&gt;Michał Pierzchała ( &lt;a href=&quot;https://twitter.com/thymikee&quot;&gt;@thymikee&lt;/a&gt; )의 Jest 로 더 빠른 각도 테스트</target>
        </trans-unit>
        <trans-unit id="f07fb064a1ca3650efef1c76fcbb075693e99c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;troubleshooting&quot;&gt;Troubleshoot&lt;/a&gt; problems with Jest.</source>
          <target state="translated">&lt;a href=&quot;troubleshooting&quot;&gt;&lt;/a&gt;Jest 관련 문제를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="443213bdc808a3fc65945784503fb0ee5e83725f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tutorial-react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;tutorial-react-native&quot;&gt;React Native&lt;/a&gt; components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of &lt;a href=&quot;https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts&quot;&gt;snapshotting CLI output&lt;/a&gt; in the Jest repo.</source>
          <target state="translated">&lt;a href=&quot;tutorial-react&quot;&gt;리 액트&lt;/a&gt; 및 리 &lt;a href=&quot;tutorial-react-native&quot;&gt;액트 네이티브&lt;/a&gt; 구성 요소는 스냅 샷 테스트를위한 좋은 사용 사례입니다. 그러나 스냅 샷은 직렬화 가능한 값을 캡처 할 수 있으며 목표가 출력이 올바른지 테스트 할 때마다 사용해야합니다. Jest 저장소에는 Jest 자체의 출력, Jest 어설 션 라이브러리의 출력 및 Jest 코드베이스의 다양한 부분에서 로그 메시지를 테스트하는 많은 예제가 포함되어 있습니다. Jest 저장소에서 &lt;a href=&quot;https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts&quot;&gt;CLI 출력 스냅 샷&lt;/a&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35a5ed3d96a7d19aaa272ea4066717b8d7f08ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%#&lt;/code&gt; - Index of the test case.</source>
          <target state="translated">&lt;code&gt;%#&lt;/code&gt; -테스트 케이스의 인덱스</target>
        </trans-unit>
        <trans-unit id="99439ec715d56673a87763600a5604708e1c38d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%%&lt;/code&gt; - single percent sign ('%'). This does not consume an argument.</source>
          <target state="translated">&lt;code&gt;%%&lt;/code&gt; -단일 퍼센트 부호 ( '%'). 이것은 인수를 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be58a859ecea37f16b1baf755a833c937911e03a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;- Number.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; 숫자.</target>
        </trans-unit>
        <trans-unit id="0210f4fcea5c1914a2ac951e9e76cb6796c46080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f&lt;/code&gt; - Floating point value.</source>
          <target state="translated">&lt;code&gt;%f&lt;/code&gt; 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="55ee086a73fac1a68641f364d883a401f6667b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%i&lt;/code&gt; - Integer.</source>
          <target state="translated">&lt;code&gt;%i&lt;/code&gt; 정수</target>
        </trans-unit>
        <trans-unit id="e01cf6855d89e736222379d96cb8f8c24d6b9544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%j&lt;/code&gt; - JSON.</source>
          <target state="translated">&lt;code&gt;%j&lt;/code&gt; -JSON.</target>
        </trans-unit>
        <trans-unit id="bab6bb51afc0fd48dceefb2aac9b600984e09b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%o&lt;/code&gt; - Object.</source>
          <target state="translated">&lt;code&gt;%o&lt;/code&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="3ae24f8fcf878ada51ee4c476c8d990172aa5ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;pretty-format&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;pretty-format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e26914b39d77aae13dc19308b1d95ba59e4ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;- String.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; 문자열.</target>
        </trans-unit>
        <trans-unit id="6549287d9dfc46e5e451bf23de875efc1b0450ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;''&lt;/code&gt; if matcher was not called with a promise modifier</source>
          <target state="translated">&lt;code&gt;''&lt;/code&gt; 약속 수정자를 사용하여 매처를 호출하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="1d41bf2fd44861b9c5446bf7dcb05135d69e1d25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'incomplete'&lt;/code&gt; - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.</source>
          <target state="translated">&lt;code&gt;'incomplete'&lt;/code&gt; -통화가 아직 완료되지 않았 음을 나타냅니다. 이는 모의 함수 자체 또는 모의 함수에서 호출 한 결과를 테스트하는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3fe7dd9e456ce9a56ae609395aa81b172994f38f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'rejects'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.rejects&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'rejects'&lt;/code&gt; matcher가 promise &lt;code&gt;.rejects&lt;/code&gt; 수정 자로 호출 된 경우 '거부'</target>
        </trans-unit>
        <trans-unit id="e00498ab57db7b93c2f28b7b12b8f7e1c69000f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'resolves'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.resolves&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'resolves'&lt;/code&gt; 정규가 약속 호출 된 경우 &lt;code&gt;.resolves&lt;/code&gt; 의 수정</target>
        </trans-unit>
        <trans-unit id="adefff17f597de4d74805fd1199cf58fdab871d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'return'&lt;/code&gt; - Indicates that the call completed by returning normally.</source>
          <target state="translated">&lt;code&gt;'return'&lt;/code&gt; return'-정상적으로 리턴하여 호출이 완료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="076c5e0b99835c5f259fd2816ec766e57cb2d86e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'throw'&lt;/code&gt; - Indicates that the call completed by throwing a value.</source>
          <target state="translated">&lt;code&gt;'throw'&lt;/code&gt; - 값을 던져서 호출이 완료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95e4e052d6f73f13eb9f5bf76796d91d0771e5d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.mock&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;.mock&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="3243a3eefd59ed3b1ef0411f8d2f9ef7ab6b869c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aab89721f62c7711b7a39834e73ed2a7fa36b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.toBeNull()&lt;/code&gt; is the same as &lt;code&gt;.toBe(null)&lt;/code&gt; but the error messages are a bit nicer. So use &lt;code&gt;.toBeNull()&lt;/code&gt; when you want to check that something is null.</source>
          <target state="translated">&lt;code&gt;.toBeNull()&lt;/code&gt; 은 &lt;code&gt;.toBe(null)&lt;/code&gt; 과 동일 하지만 오류 메시지가 조금 더 좋습니다. 따라서 무언가가 null인지 확인 하려면 &lt;code&gt;.toBeNull()&lt;/code&gt; 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="104f305e00b892ddcf1d06c035b10b5490d792af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="f7ca0bd8979a7f74cc25cbae3dbe74989087d213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always&lt;/code&gt;: always send a notification.</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; : 항상 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8c6c44f3653f92b2c1c2a5de58ace2813f45e746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="022d50ac602b48aff9f8d8e67b52ebc38346cad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;automock&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;automock&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="0783465e37770f804a3fa338742cb29285642410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bail&lt;/code&gt; [number | boolean]</source>
          <target state="translated">&lt;code&gt;bail&lt;/code&gt; [번호 | 부울]</target>
        </trans-unit>
        <trans-unit id="5edc8e7748215afb6eeb00b3979bb3727afd5bb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; can handle asynchronous code in the same ways that &lt;a href=&quot;asynchronous&quot;&gt;tests can handle asynchronous code&lt;/a&gt; - they can either take a &lt;code&gt;done&lt;/code&gt; parameter or return a promise. For example, if &lt;code&gt;initializeCityDatabase()&lt;/code&gt; returned a promise that resolved when the database was initialized, we would want to return that promise:</source>
          <target state="translated">&lt;code&gt;beforeEach&lt;/code&gt; 와 &lt;code&gt;afterEach&lt;/code&gt; 는 &lt;a href=&quot;asynchronous&quot;&gt;테스트&lt;/a&gt; 에서 비동기 코드를 처리 할 수있는 것과 같은 방식으로 비동기 코드를 처리 할 수 있습니다. &lt;code&gt;done&lt;/code&gt; 매개 변수를 사용하거나 약속을 반환 할 수 있습니다 . 예를 들어, &lt;code&gt;initializeCityDatabase()&lt;/code&gt; 가 데이터베이스가 초기화 될 때 해결 된 약속을 리턴 한 경우 해당 약속을 리턴하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1aa76bca50406a98255ef02e9f43968260d65f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;browser&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;browser&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="5c365dba5039284274be41ec97d6931d406d1c7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; (clears filter patterns)</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; (필터 패턴을 지 웁니다)</target>
        </trans-unit>
        <trans-unit id="3a96c151e6639e8670e9bdbe30a8b6c06780e8a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheDirectory&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;cacheDirectory&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="7b5729d52a372a388e905516712336cc35653473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change&lt;/code&gt;: send a notification when the status changed.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; : 상태가 변경되면 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1e923e514d0d8eba3a5d4f42d5c2bb45b0c5de03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clearMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;clearMocks&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="363b6e4c7928db931e518577b11324769a502b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverage&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;collectCoverage&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="77d5f07893a1fda7fc63a1840bbc82b25e18b917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverageFrom&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;collectCoverageFrom&lt;/code&gt; [배열]</target>
        </trans-unit>
        <trans-unit id="22dfb0112951b3b9a5c84109d6afdb9cd84b9777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageDirectory&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;coverageDirectory&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="90eaa41d832548eff8171bf51ba277dd76c6cade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="aecb7be43881b3eeda0756f75c31493d74e428a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; seems to not have any effect.</source>
          <target state="translated">&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; 는 아무런 영향을 미치지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e15415f908cbcc6f834bd96ab5ea0dd1791a0e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageReporters&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;coverageReporters&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="dc39b0fdbc72c893cbb45f06a4c77dc964c9da51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageThreshold&lt;/code&gt; [object]</source>
          <target state="translated">&lt;code&gt;coverageThreshold&lt;/code&gt; [개체]</target>
        </trans-unit>
        <trans-unit id="afc66e291a919f7f83c445c247998df66d9ff548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dependencyExtractor&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;dependencyExtractor&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="578ea51611cafa4df7fdc64d59c1dcb405fe8410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe(name, fn)&lt;/code&gt; creates a block that groups together several related tests. For example, if you have a &lt;code&gt;myBeverage&lt;/code&gt; object that is supposed to be delicious but not sour, you could test it with:</source>
          <target state="translated">&lt;code&gt;describe(name, fn)&lt;/code&gt; 은 여러 관련 테스트를 그룹화하는 블록을 만듭니다. 예를 들어 맛있지 만 신맛이 &lt;code&gt;myBeverage&lt;/code&gt; 하는 myBeverage 객체 가있는 경우 다음을 사용하여 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a747ebf25a9f2fa370e23024faca41ba1a337dab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.each&lt;/code&gt; 는 두 가지 API로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f9a624922279c16d34d13a44532e2a44816d8022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.only.each&lt;/code&gt; 는 두 가지 API와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be072a39475c0433ea29c8a3f3e03e51b6441308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.skip.each&lt;/code&gt; 는 두 가지 API와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77bc66969f1fd3507a08fc8554e866f921a0340f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;displayName&lt;/code&gt; [string, object]</source>
          <target state="translated">&lt;code&gt;displayName&lt;/code&gt; [문자열, 객체]</target>
        </trans-unit>
        <trans-unit id="99ae6ab4c9dd50d862bc15af0f07ad924c3ea872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errorOnDeprecated&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;errorOnDeprecated&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="16d7cc8c63e72f5826c1d66754d6907d67dd5b1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.any(constructor)&lt;/code&gt; matches anything that was created with the given constructor. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a number:</source>
          <target state="translated">&lt;code&gt;expect.any(constructor)&lt;/code&gt; 는 주어진 생성자로 생성 된 것과 일치합니다. 리터럴 값 대신 &lt;code&gt;toEqual&lt;/code&gt; 또는 &lt;code&gt;toBeCalledWith&lt;/code&gt; 안에서 사용할 수 있습니다 . 예를 들어, 모의 함수가 숫자로 호출되는지 확인하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="7b048d4335638b4d1ce30d9e4cea456559c9b724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.anything()&lt;/code&gt; matches anything but &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a non-null argument:</source>
          <target state="translated">&lt;code&gt;expect.anything()&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 이외의 항목과 일치 합니다. 리터럴 값 대신 &lt;code&gt;toEqual&lt;/code&gt; 또는 &lt;code&gt;toBeCalledWith&lt;/code&gt; 안에서 사용할 수 있습니다 . 예를 들어, 널이 아닌 인수로 모의 함수가 호출되는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d07e62eaf69f9b58e4a6fd2e376c27adf3aa7352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.arrayContaining(array)&lt;/code&gt; matches a received array which contains all of the elements in the expected array. That is, the expected array is a &lt;strong&gt;subset&lt;/strong&gt; of the received array. Therefore, it matches a received array which contains elements that are &lt;strong&gt;not&lt;/strong&gt; in the expected array.</source>
          <target state="translated">&lt;code&gt;expect.arrayContaining(array)&lt;/code&gt; 는 예상 배열의 모든 요소를 ​​포함하는 수신 배열과 일치합니다. 즉, 예상되는 배열은 수신 된 배열 의 &lt;strong&gt;하위 집합&lt;/strong&gt; 입니다. 따라서 예상 된 배열에 &lt;strong&gt;없는&lt;/strong&gt; 요소를 포함하는 수신 된 배열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9ad1cdf0d05ab1b5153ed2dc2199661f84a10214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.assertions(number)&lt;/code&gt; verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="translated">&lt;code&gt;expect.assertions(number)&lt;/code&gt; 는 테스트 중에 특정 개수의 어설 션이 호출되는지 확인합니다. 콜백의 어설 션이 실제로 호출되었는지 확인하기 위해 비동기 코드를 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0e7c7a571b63f72abaf51ebbecf601d2e3857d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.extend&lt;/code&gt; also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called &lt;code&gt;toBeDivisibleByExternalValue&lt;/code&gt;, where the divisible number is going to be pulled from an external source.</source>
          <target state="translated">&lt;code&gt;expect.extend&lt;/code&gt; 는 비동기 매처도 지원합니다. 비동기 매처는 약속을 반환하므로 반환 된 값을 기다려야합니다. 예시적인 matcher를 사용하여 사용법을 설명해 봅시다. 우리는 &lt;code&gt;toBeDivisibleByExternalValue&lt;/code&gt; 라는 매처를 구현할 것인데 , 여기서 divisible 숫자는 외부 소스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e5b19b7b55164bf0bc4a0774f7d5a9823dfb8d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.hasAssertions()&lt;/code&gt; verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="translated">&lt;code&gt;expect.hasAssertions()&lt;/code&gt; 는 테스트 중에 하나 이상의 어설 션이 호출되는지 확인합니다. 콜백의 어설 션이 실제로 호출되었는지 확인하기 위해 비동기 코드를 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="14ec136e4c871d2955ba2a5ffdb1ec1f46d7ec62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.arrayContaining(array)&lt;/code&gt; matches a received array which does not contain all of the elements in the expected array. That is, the expected array &lt;strong&gt;is not a subset&lt;/strong&gt; of the received array.</source>
          <target state="translated">&lt;code&gt;expect.not.arrayContaining(array)&lt;/code&gt; 는 예상 배열의 모든 요소를 ​​포함하지 않는 수신 배열과 일치합니다. 즉, 예상되는 배열 &lt;strong&gt;은&lt;/strong&gt; 수신 된 배열 &lt;strong&gt;의 하위 집합이 아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6547e93ef4972ca16b59d2de583bdf5f8e164aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.objectContaining(object)&lt;/code&gt; matches any received object that does not recursively match the expected properties. That is, the expected object &lt;strong&gt;is not a subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">&lt;code&gt;expect.not.objectContaining(object)&lt;/code&gt; 는 예상 속성과 재귀 적으로 일치하지 않는 수신 된 개체와 일치합니다. 즉, 예상 개체 &lt;strong&gt;가&lt;/strong&gt; 수신 된 개체 &lt;strong&gt;의 하위 집합이 아닙니다&lt;/strong&gt; . 따라서 예상 된 오브젝트에 &lt;strong&gt;없는&lt;/strong&gt; 특성을 포함하는 수신 된 오브젝트와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="e1a42e0113413fc40756feea32923e172a36b6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringContaining(string)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not contain the exact expected string.</source>
          <target state="translated">&lt;code&gt;expect.not.stringContaining(string)&lt;/code&gt; 은 수신 한 값이 문자열이 아니거나 정확한 예상 문자열을 포함하지 않는 문자열 인 경우 수신 된 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ce80cb6e4909d7c37e766e9b73b0bb99a177ade6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression.</source>
          <target state="translated">&lt;code&gt;expect.not.stringMatching(string | regexp)&lt;/code&gt; 는 수신 한 값이 문자열이 아니거나 예상 문자열 또는 정규식과 일치하지 않는 문자열 인 경우 수신 된 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="875e89312fa291d9bbe18c260d1ae180219d97dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.objectContaining(object)&lt;/code&gt; matches any received object that recursively matches the expected properties. That is, the expected object is a &lt;strong&gt;subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that &lt;strong&gt;are present&lt;/strong&gt; in the expected object.</source>
          <target state="translated">&lt;code&gt;expect.objectContaining(object)&lt;/code&gt; 는 예상 속성과 재귀 적으로 일치하는 수신 된 개체와 일치합니다. 즉, 예상 개체는 수신 된 개체 의 &lt;strong&gt;하위 집합&lt;/strong&gt; 입니다. 따라서, 수신 특성을 포함하는 객체와 일치 &lt;strong&gt;존재&lt;/strong&gt; 예상 객체를.</target>
        </trans-unit>
        <trans-unit id="873bd2740b6f065fa8199240ea0887a8832c981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringContaining(string)&lt;/code&gt; matches the received value if it is a string that contains the exact expected string.</source>
          <target state="translated">&lt;code&gt;expect.stringContaining(string)&lt;/code&gt; 은 정확한 예상 문자열을 포함하는 문자열 인 경우 수신 된 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5b225d15ea2692d7f596ad71d130a9431391d603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is a string that matches the expected string or regular expression.</source>
          <target state="translated">&lt;code&gt;expect.stringMatching(string | regexp)&lt;/code&gt; 는 예상 문자열 또는 정규식과 일치하는 문자열 인 경우 수신 된 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9601c02013ee7ce5f87da30784a1f36318a5dbff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extraGlobals&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;extraGlobals&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="5f0eae8733557670105e5264b5a44c22eff4ea60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure-change&lt;/code&gt;: send a notification when tests fail or once when it passes.</source>
          <target state="translated">&lt;code&gt;failure-change&lt;/code&gt; : 테스트가 실패하거나 통과 할 때 한 번 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="731d19bd21f0367438f616985a2ff9bb56ea0ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure&lt;/code&gt;: send a notification when tests fail.</source>
          <target state="translated">&lt;code&gt;failure&lt;/code&gt; : 테스트가 실패하면 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3447be7228fe480161197c25ed455c836a34b766" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findRepos&lt;/code&gt; returns a promise that resolves to a set of repositories contained in the specified path.</source>
          <target state="translated">&lt;code&gt;findRepos&lt;/code&gt; 는 지정된 경로에 포함 된 저장소 세트로 해석되는 약속을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d9914d2c07c082d0ed34f77e91705dbe4bbc7ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; : &lt;code&gt;Function&lt;/code&gt; 시험의 제품군이 실행 된 것으로,이 함수 인수로 각 행의 매개 변수를 수신 할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="298953e98c7eb6b4e3d57c99810d04acf9d73464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the test data object.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; : &lt;code&gt;Function&lt;/code&gt; 시험의 제품군이 실행 된 것으로,이 테스트 데이터 객체를받을 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a6f031349e7b8aa21079964750e0087a33dee28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; : 실행할 테스트 &lt;code&gt;Function&lt;/code&gt; , 각 행의 매개 변수를 함수 인수로 수신하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="27cbe17bb99201c9dc1c9f5c72dd39428e462a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the test data object.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; : &lt;code&gt;Function&lt;/code&gt; 테스트가 실행 된 것으로,이 테스트 데이터 객체를받을 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2604eaf97f1d7be032bcf96b602a694fcf53fdf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceCoverageMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;forceCoverageMatch&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a16227a95685b1c6861bbb5288faab8f371516cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getChangedFilesForRoots&lt;/code&gt; returns a promise that resolves to an object with the changed files and repos.</source>
          <target state="translated">&lt;code&gt;getChangedFilesForRoots&lt;/code&gt; 는 변경된 파일과 저장소를 사용하여 객체로 확인되는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df6948e0922a81f820a7782be1ef9bc1512a6b41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalConfig&lt;/code&gt;: A representation of Jest's current global configuration</source>
          <target state="translated">&lt;code&gt;globalConfig&lt;/code&gt; : Jest의 현재 글로벌 구성 표현</target>
        </trans-unit>
        <trans-unit id="0ff896286fbcbc481378aeb8259b08bea7f02d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalSetup&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;globalSetup&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="fadaa8f683b3b302e2e7f420e35e198d8dd3816e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalTeardown&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;globalTeardown&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="231b0edd70628d81723e0ee3029c6b4ff4d9110c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globals&lt;/code&gt; [object]</source>
          <target state="translated">&lt;code&gt;globals&lt;/code&gt; [개체]</target>
        </trans-unit>
        <trans-unit id="b098b2d9da9708ff9da0d38f84a27a261ab078ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasDeprecationWarnings&lt;/code&gt;, a boolean indicating whether the submitted configuration has deprecation warnings,</source>
          <target state="translated">&lt;code&gt;hasDeprecationWarnings&lt;/code&gt; , 제출 된 구성에 폐기 경고가 있는지 여부를 나타내는 부울,</target>
        </trans-unit>
        <trans-unit id="db064ee6440350f7fb0be817c2c86fd657c31ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; (updates non-matching snapshots interactively)</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; (일치하지 않는 스냅 샷을 대화식으로 업데이트)</target>
        </trans-unit>
        <trans-unit id="7667493d35310459ba4d865785385e0fa44f0893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isValid&lt;/code&gt;, a boolean indicating whether the configuration is correct or not.</source>
          <target state="translated">&lt;code&gt;isValid&lt;/code&gt; , 구성이 올바른지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="63029f3c42dcfdbd97e5adf642c885fad142d9ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.isolateModules(fn)&lt;/code&gt; goes a step further than &lt;code&gt;jest.resetModules()&lt;/code&gt; and creates a sandbox registry for the modules that are loaded inside the callback function. This is useful to isolate specific modules for every test so that local module state doesn't conflict between tests.</source>
          <target state="translated">&lt;code&gt;jest.isolateModules(fn)&lt;/code&gt; 은 &lt;code&gt;jest.resetModules()&lt;/code&gt; 보다 한 단계 더 나아가 콜백 함수 내에로드 된 모듈에 대한 샌드 박스 레지스트리를 만듭니다. 로컬 모듈 상태가 테스트간에 충돌하지 않도록 모든 테스트에 대해 특정 모듈을 분리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d068ec96dd088b722efa247006c3a09b717017e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; takes a &lt;strong&gt;module factory&lt;/strong&gt; argument. A module factory is a function that returns the mock.</source>
          <target state="translated">&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; 는 &lt;strong&gt;모듈 팩토리&lt;/strong&gt; 인수를 사용합니다. 모듈 팩토리는 모의를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="90135d2aaad054e086325b1d57dde7c03baf6197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: Modifies the plugin key.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; : 플러그인 키를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="e3e41eef750008fd3d9034f9f24ad5c5b838e31f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxConcurrency&lt;/code&gt; [number]</source>
          <target state="translated">&lt;code&gt;maxConcurrency&lt;/code&gt; [번호]</target>
        </trans-unit>
        <trans-unit id="e71100c6b326e78ca130e91a087d319bbd82f524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockImplementation&lt;/code&gt; can also be used to mock class constructors:</source>
          <target state="translated">&lt;code&gt;mockImplementation&lt;/code&gt; 을 사용하여 클래스 생성자를 조롱 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5ac877b649f4b1baf1b0db360ca8a145e29d584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleDirectories&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleDirectories&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a817d22cd4c1efa6fa7dba67c371451f4f6a3e40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleFileExtensions&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleFileExtensions&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d4dbb493ef5de10d974140f3a1a68b88e828b841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleNameMapper&lt;/code&gt; [object&amp;lt;string, string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleNameMapper&lt;/code&gt; [개체 &amp;lt;문자열, 문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9c30cf8163e2afdc999bcd7e41dcbb5851bb1e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;modulePathIgnorePatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="8d5f993e08e79688971f5c75776fe7729160b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePaths&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;modulePaths&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d3482e861b97dc8c4ad438b0fde5c9836aa35e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test block.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : &lt;code&gt;String&lt;/code&gt; 테스트 블록의 제목을.</target>
        </trans-unit>
        <trans-unit id="6c07e542178b2102b5826b97ac09964d210344a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test plan.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : &lt;code&gt;String&lt;/code&gt; 테스트 계획의 제목을.</target>
        </trans-unit>
        <trans-unit id="6decfba5457add1abca3f7eefd904378908c40d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the suite title from the tagged template expressions.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : &lt;code&gt;String&lt;/code&gt; 테스트 스위트의 제목, 사용 &lt;code&gt;$variable&lt;/code&gt; 태그가 달린 템플릿 표현식에서 스위트 타이틀로 분사 테스트 데이터를.</target>
        </trans-unit>
        <trans-unit id="8efc7da2c3955c0b1cbac2ceaa166cfe2e82166b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : &lt;code&gt;String&lt;/code&gt; 테스트 스위트의 제목을.</target>
        </trans-unit>
        <trans-unit id="6c1df03cf669a34600d3198e548795a6077ea6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the test title from the tagged template expressions.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 테스트 제목 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;$variable&lt;/code&gt; 을 사용 하여 태그가 지정된 템플릿 표현식에서 테스트 데이터에 테스트 데이터를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="a7ed76fb5c443ad0c959e448b56418dc71e556c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;notify&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="6684ce050bf906e6380898754ff7da6938b703c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notifyMode&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;notifyMode&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="6bd057db2f09c38e1e5b40068f877b8183233331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; (test filename pattern)</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; (테스트 파일 이름 패턴)</target>
        </trans-unit>
        <trans-unit id="4e0c00c34cdc9a83d325ba92d761bc183ce4449f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preset&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;preset&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="7f06be9be723c01ad4d3dbe06ff030523f7706bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prettierPath&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;prettierPath&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="af4505df26dc3d3a9cb7331fc60b4a4af4b244e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects: Array&amp;lt;config: ProjectConfig, testPaths: Array&amp;lt;string&amp;gt;&lt;/code&gt;: Includes all the test paths that Jest is watching.</source>
          <target state="translated">&lt;code&gt;projects: Array&amp;lt;config: ProjectConfig, testPaths: Array&amp;lt;string&amp;gt;&lt;/code&gt; : Jest가보고있는 모든 테스트 경로를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7e98a5e7e066d6b8bfb3e0e2aa91fa1576bb9d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects&lt;/code&gt; [array&amp;lt;string | ProjectConfig&amp;gt;]</source>
          <target state="translated">&lt;code&gt;projects&lt;/code&gt; [배열 &amp;lt;문자열 | ProjectConfig&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="5b3c05f3ce8e21d04bb61eb33e6e4c93ba2018c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prompt&lt;/code&gt;: Allows user to customize the text in the plugin prompt.</source>
          <target state="translated">&lt;code&gt;prompt&lt;/code&gt; : 사용자가 플러그인 프롬프트에서 텍스트를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="306725cc0ea4676fa203b49def3e6bf0647bc9e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; (quits)</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; (quits)</target>
        </trans-unit>
        <trans-unit id="21cf61c19fe87ba0d4595c865ab1260b42f36bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt; ships with a Jest preset, so the &lt;code&gt;jest.preset&lt;/code&gt; field of your &lt;code&gt;package.json&lt;/code&gt; should point to &lt;code&gt;react-native&lt;/code&gt;. The preset is a node environment that mimics the environment of a React Native app. Because it doesn't load any DOM or browser APIs, it greatly improves Jest's startup time.</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; 는 Jest 사전 설정과 함께 제공되므로 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;jest.preset&lt;/code&gt; 필드는 &lt;code&gt;react-native&lt;/code&gt; 를 가리켜 야합니다 . 사전 설정은 React Native 앱의 환경을 모방 한 노드 환경입니다. DOM 또는 브라우저 API를로드하지 않기 때문에 Jest의 시작 시간이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8b23880a197c5f759c183cce18fb93d6fa1266" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reporters&lt;/code&gt; [array&amp;lt;moduleName | [moduleName, options]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;reporters&lt;/code&gt; [array &amp;lt;moduleName | [모듈 이름, 옵션]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="453d841d74b238a64faf3df95c585d289aa91e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;resetMocks&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="1ac59f04d9734d7de733a2f890c1829d2243af0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetModules&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;resetModules&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="d82390a2391bf5fe68298d3c71d952e9f3396ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolver&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;resolver&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="95d7428212c791b1c98fa85a623f2916661a109d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restoreMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;restoreMocks&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="116364b62ec3e96c831f81af2e20649d42921165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDir&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="b69cb276d844fde73a287c56443b24c85290f772" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roots&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;roots&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="b31ac4f04b533e37944cd96caa5c49c10dc74438" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runner&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;runner&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="06b042371a36ef0f59de8c40ae970a1ae12fe9cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialize&lt;/code&gt; is a function that serializes a value using existing plugins.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 는 기존 플러그인을 사용하여 값을 직렬화하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1f7906f5769192dc093bd74f15955d14c8f44353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFiles&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;setupFiles&lt;/code&gt; [배열]</target>
        </trans-unit>
        <trans-unit id="ad182506adf7a1eda3a2fe924a5d6b3ce10e38db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; [배열]</target>
        </trans-unit>
        <trans-unit id="6822a7af0f792c1be02fee0e6557b5f9aa6aa50d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotResolver&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;snapshotResolver&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="020e33ceb836b81269226d47390ae8d910dd3d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotSerializers&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;snapshotSerializers&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="8ba6dc074f7173c4e5c921c96d6172ca341c31c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success-change&lt;/code&gt;: send a notification when tests pass or once when it fails.</source>
          <target state="translated">&lt;code&gt;success-change&lt;/code&gt; : 테스트 통과 또는 실패시 한 번 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b6809288cd383ca526de3a95e82dc40029d2ea62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;: send a notification when tests pass.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; : 테스트 통과시 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="cf4992aa1211cf11eace0fd6194105fe6e748c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (test name pattern)</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; (테스트 이름 패턴)</target>
        </trans-unit>
        <trans-unit id="2c76e7cef2f994e9bc4b2ffa8fc15c6a863909e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; : 각 행 의 &lt;code&gt;fn&lt;/code&gt; 에 전달되는 인수가있는 &lt;code&gt;Array&lt;/code&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="317ad841253c3821eea1c4c55994b13ecd8b83d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the test &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; : 각 행에 대해 테스트 &lt;code&gt;fn&lt;/code&gt; 에 전달되는 인수가있는 &lt;code&gt;Array&lt;/code&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="78df167d8e2f5e6ab08bd9f9210c72a24c886744" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Tagged Template Literal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; : &lt;code&gt;Tagged Template Literal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2da762274f49442e7234edf6edec01553d27cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.each&lt;/code&gt; 는 두 가지 API로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee264ff7856e51845623e3380548e788bd1f445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.only.each&lt;/code&gt; 는 두 가지 API로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3170d96d60bef9c8c8d61879742230e8abe3b3cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.skip.each&lt;/code&gt; 는 두 가지 API로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="221510c066b929b735e5b28457b54416069c92c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironment&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="b44ab06de94eab7f0f3caa84b84945368e2009db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironmentOptions&lt;/code&gt; [Object]</source>
          <target state="translated">&lt;code&gt;testEnvironmentOptions&lt;/code&gt; [개체]</target>
        </trans-unit>
        <trans-unit id="90d7ac195113b99da222c32b46f9f8233407fc14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testMatch&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d243b3891f943423546e59235dcdd8d976817d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testPathIgnorePatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="2ff12f0b18e5c1f64dc7329625443fae51cefdfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testRegex&lt;/code&gt; [문자열 | 배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="17522f05ab6d628a3f251e9b900e451c21411a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testResultsProcessor&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testResultsProcessor&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="b5b73f8cad03992f278bb6a0f26575821f4b0243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRunner&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testRunner&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="3d21b02e2144b96e6faf94901f49db32825d01c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testSequencer&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testSequencer&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="749944ba3e96affa2798b2be0c8f9bdc7c202c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testURL&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testURL&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="5c6c63d8dee4860bbe8b897df46edc678e1919d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timers&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;timers&lt;/code&gt; [문자열]</target>
        </trans-unit>
        <trans-unit id="4a070639a8870b012e0b8c57d45e65d109ab4512" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBe&lt;/code&gt; uses &lt;code&gt;Object.is&lt;/code&gt; to test exact equality. If you want to check the value of an object, use &lt;code&gt;toEqual&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;toBe&lt;/code&gt; 는 &lt;code&gt;Object.is&lt;/code&gt; 를 사용 하여 정확한 동등성을 테스트합니다. 객체의 값을 확인하려면 &lt;code&gt;toEqual&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d6b12ce5ef3f1a643ddde1103fc34b4841b2288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeDefined&lt;/code&gt; is the opposite of &lt;code&gt;toBeUndefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeDefined&lt;/code&gt; 는 toBeUndefined 와 반대입니다 &lt;code&gt;toBeUndefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="889cb4e9583e9ce69de99a59a883724a6a884c9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeFalsy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as false</source>
          <target state="translated">&lt;code&gt;toBeFalsy&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 문이 false로 취급 하는 모든 항목 과 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="4c5324f092772853a6ea4dd06b013577b9f5e80b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeNull&lt;/code&gt; matches only &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeNull&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 과만 일치</target>
        </trans-unit>
        <trans-unit id="3405b1dad40d610da009d8481e79e69e967627b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeTruthy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as true</source>
          <target state="translated">&lt;code&gt;toBeTruthy&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 문이 true로 취급 하는 모든 항목 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="5f24f9d6f2d8651c7998359500de6605bc512b83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeUndefined&lt;/code&gt; matches only &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeUndefined&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 와만 일치</target>
        </trans-unit>
        <trans-unit id="388131813185919d7c4b9b7ce2e366b3f5c34296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toEqual&lt;/code&gt; recursively checks every field of an object or array.</source>
          <target state="translated">&lt;code&gt;toEqual&lt;/code&gt; 은 객체 또는 배열의 모든 필드를 재귀 적으로 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0f97095c42ff3460af22106bcfc6894981843e89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; [object&amp;lt;string, pathToTransformer | [pathToTransformer, object]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; [객체 &amp;lt;문자열, pathToTransformer | [pathToTransformer, 객체]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="b32e2b6dc461e4c5c6a8c96613f67aca04ca902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transformIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;transformIgnorePatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="530e289551d0cb4aa78691c9e846cb8a050d78b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; (updates all non-matching snapshots)</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; (일치하지 않는 모든 스냅 샷 업데이트)</target>
        </trans-unit>
        <trans-unit id="8d05fea48435f8bb30fa51c665fb5ad81d02bcfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmockedModulePathPatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;unmockedModulePathPatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="022b56004e7d1552105c625dc749cbbcb0d70f49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateConfigAndRun&lt;/code&gt;: Allows you to trigger a test run while the interactive plugin is running.</source>
          <target state="translated">&lt;code&gt;updateConfigAndRun&lt;/code&gt; : 대화식 플러그인이 실행되는 동안 테스트 실행을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7555c9da609a937d25697703fb3b49efefa9685b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; [부울]</target>
        </trans-unit>
        <trans-unit id="add45525d19083f684e544eb3205026fe6f9e169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;w&lt;/code&gt; (displays watch mode usage / available actions)</source>
          <target state="translated">&lt;code&gt;w&lt;/code&gt; (감시 모드 사용 / 사용 가능한 조치 표시)</target>
        </trans-unit>
        <trans-unit id="df63f3efa68ef5278ebaa0d9bd8fe291d6f1adce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;watchPathIgnorePatterns&lt;/code&gt; [배열 &amp;lt;문자열&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a95c27dc635388fdb16992516dd7331adc390021" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPlugins&lt;/code&gt; [array&amp;lt;string | [string, Object]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;watchPlugins&lt;/code&gt; [배열 &amp;lt;문자열 | [문자열, 개체]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="b49a0c0fce1f34eeb9dd0214fd85644975b89abf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note It is recommended to use &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead. The &lt;code&gt;jest.mock&lt;/code&gt; API's second argument is a module factory instead of the expected exported module object.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; 대신 사용하는 것이 좋습니다 . &lt;code&gt;jest.mock&lt;/code&gt; 의 API의 두 번째 인수는 대신 예상되는 수출 모듈 오브젝트의 모듈 공장입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe6c8d77331269086ec95d5b210111e1b5ebb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that using &lt;code&gt;'&amp;lt;rootDir&amp;gt;'&lt;/code&gt; as a string token in any other path-based config settings will refer back to this value. So, for example, if you want your &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; config entry to point at the &lt;code&gt;env-setup.js&lt;/code&gt; file at the root of your project, you could set its value to &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/env-setup.js&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;사용주의 &lt;code&gt;'&amp;lt;rootDir&amp;gt;'&lt;/code&gt; 다른 경로 기반 구성 설정에서 토큰 문자열로하는 것은이 값을 다시 참조합니다. 예를 들어, &lt;a href=&quot;#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; &lt;/a&gt; 구성 항목이 프로젝트 루트의 &lt;code&gt;env-setup.js&lt;/code&gt; 파일 을 가리 키도록 하려면 해당 값을 &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/env-setup.js&quot;]&lt;/code&gt; 로 설정할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3245e4c0c525edd55a1fcdd702374cc73c464f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;jest.fn(implementation)&lt;/code&gt; is a shorthand for &lt;code&gt;jest.fn().mockImplementation(implementation)&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;jest.fn(implementation)&lt;/code&gt; 은 &lt;code&gt;jest.fn().mockImplementation(implementation)&lt;/code&gt; 의 약어입니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b80413aed034e693fba82c8e6ba876def35e50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; is deprecated in favor of &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; 는 찬성되지 않습니다 &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3469d99eb365107c2b5a8486b65ceb080d7309e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;testRegex&lt;/code&gt; will try to detect test files using the &lt;strong&gt;absolute file path&lt;/strong&gt; therefore having a folder with name that match it will run all the files as tests&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;testRegex&lt;/code&gt; 는 &lt;strong&gt;절대 파일 경로를&lt;/strong&gt; 사용하여 테스트 파일을 감지하려고 하므로 일치하는 이름의 폴더가 있으면 모든 파일을 테스트로 실행합니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3dea36c338e1ec0685907e97bd1e080d581b098" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 프로젝트에 구성된 전역 설정 모듈 (멀티 프로젝트 러너 사용)은이 프로젝트에서 하나 이상의 테스트를 실행할 때만 트리거됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfa556e4ca5fc57d212e06cf6bbf0fe286b5fbdd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 프로젝트 (멀티 프로젝트 러너 사용)에 구성된 글로벌 분해 모듈은이 프로젝트에서 하나 이상의 테스트를 실행할 때만 트리거됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d02c6dd644e67a3e18203bbf480809bbd1604476" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Any global variables that are defined through &lt;code&gt;globalSetup&lt;/code&gt; can only be read in &lt;code&gt;globalTeardown&lt;/code&gt;. You cannot retrieve globals defined here in your test suites.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;globalSetup&lt;/code&gt; 을 통해 정의 된 모든 글로벌 변수 는 &lt;code&gt;globalTeardown&lt;/code&gt; 에서만 읽을 수 있습니다 . 테스트 스위트에서 여기에 정의 된 글로벌을 검색 할 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d72424c7302fd6031f30bf655f1399a19b49aca1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;jest.spyOn&lt;/code&gt; also calls the &lt;strong&gt;spied&lt;/strong&gt; method. This is different behavior from most other test libraries. If you want to overwrite the original function, you can use &lt;code&gt;jest.spyOn(object, methodName).mockImplementation(() =&amp;gt; customImplementation)&lt;/code&gt; or &lt;code&gt;object[methodName] = jest.fn(() =&amp;gt; customImplementation);&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 기본적으로 &lt;code&gt;jest.spyOn&lt;/code&gt; 는 또한 호출 &lt;strong&gt;스파이 행위&lt;/strong&gt; 방법을. 이것은 대부분의 다른 테스트 라이브러리와 다른 동작입니다. 원래 함수를 덮어 &lt;code&gt;jest.spyOn(object, methodName).mockImplementation(() =&amp;gt; customImplementation)&lt;/code&gt; 려면 jest.spyOn (object, methodName) .mockImplementation (() =&amp;gt; customImplementation) 또는 &lt;code&gt;object[methodName] = jest.fn(() =&amp;gt; customImplementation);&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff92012e564f8eaffa118d20c50c70351da45fb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;roots&lt;/code&gt; has a single entry &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; but there are cases where you may want to have multiple roots within one project, for example &lt;code&gt;roots: [&quot;&amp;lt;rootDir&amp;gt;/src/&quot;, &quot;&amp;lt;rootDir&amp;gt;/tests/&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 기본적으로 &lt;code&gt;roots&lt;/code&gt; 는 단일 항목 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 을 갖지만 하나의 프로젝트 내에 여러 루트를 가질 수있는 경우가 있습니다 (예 &lt;code&gt;roots: [&quot;&amp;lt;rootDir&amp;gt;/src/&quot;, &quot;&amp;lt;rootDir&amp;gt;/tests/&quot;]&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="654f3a05466fc139fdbd676423da234eaeeb606b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: CLI options take precedence over values from the &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : CLI 옵션은 &lt;a href=&quot;configuration&quot;&gt;구성의&lt;/a&gt; 값보다 우선합니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc547a1465a2bedec561a4ee7304735175d4563a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Core modules, like &lt;code&gt;fs&lt;/code&gt;, are not mocked by default. They can be mocked explicitly, like &lt;code&gt;jest.mock('fs')&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;fs&lt;/code&gt; 와 같은 핵심 모듈 은 기본적으로 조롱되지 않습니다. &lt;code&gt;jest.mock('fs')&lt;/code&gt; 와 같이 명시 적으로 조롱 할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f88fb518a69761332477b8752972bb36e3b77eb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you are upgrading your react-native application and previously used the &lt;code&gt;jest-react-native&lt;/code&gt; preset, remove the dependency from your &lt;code&gt;package.json&lt;/code&gt; file and change the preset to &lt;code&gt;react-native&lt;/code&gt; instead.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : react-native 애플리케이션을 업그레이드하고 이전에 &lt;code&gt;jest-react-native&lt;/code&gt; 사전 설정을 사용한 경우 &lt;code&gt;package.json&lt;/code&gt; 파일 에서 종속성을 제거하고 대신 사전 설정을 &lt;code&gt;react-native&lt;/code&gt; 로 변경하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0830714d92959a808d52247893384954d5e59fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you provide module name without boundaries &lt;code&gt;^$&lt;/code&gt; it may cause hard to spot errors. E.g. &lt;code&gt;relay&lt;/code&gt; will replace all modules which contain &lt;code&gt;relay&lt;/code&gt; as a substring in its name: &lt;code&gt;relay&lt;/code&gt;, &lt;code&gt;react-relay&lt;/code&gt; and &lt;code&gt;graphql-relay&lt;/code&gt; will all be pointed to your stub.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;^$&lt;/code&gt; 를 경계없이 모듈 이름을 제공하면 발견하기 어려운 오류가 발생할 수 있습니다. 예를 &lt;code&gt;relay&lt;/code&gt; 가 포함 된 모든 모듈을 대체 할 것이다 &lt;code&gt;relay&lt;/code&gt; : 이름에 문자열 등을 &lt;code&gt;relay&lt;/code&gt; , &lt;code&gt;react-relay&lt;/code&gt; 와 &lt;code&gt;graphql-relay&lt;/code&gt; 모든 그루터기로 지적됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f81422258f7a098cd45faf5ef4bdd43a45a63cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you want to set the timeout for all test files, a good place to do this is in &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 모든 테스트 파일의 시간 종료를 설정하려면 &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; 에이를 수행하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f4dc9d7861274ab2e62663a272189579222ed51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Jest comes with JSDOM@11 by default. Due to JSDOM 12 and newer dropping support for Node 6, Jest is unable to upgrade for the time being. However, you can install a custom &lt;code&gt;testEnvironment&lt;/code&gt; with whichever version of JSDOM you want. E.g. &lt;a href=&quot;https://www.npmjs.com/package/jest-environment-jsdom-thirteen&quot;&gt;jest-environment-jsdom-thirteen&lt;/a&gt;, which has JSDOM@13.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Jest는 기본적으로 JSDOM @ 11과 함께 제공됩니다. JSDOM 12와 Node 6에 대한 최신 삭제 지원으로 인해 Jest는 당분간 업그레이드 할 수 없습니다. 그러나 원하는 버전의 JSDOM 으로 사용자 정의 &lt;code&gt;testEnvironment&lt;/code&gt; 를 설치할 수 있습니다 . 예 : &lt;a href=&quot;https://www.npmjs.com/package/jest-environment-jsdom-thirteen&quot;&gt;jest-environment-jsdom-thirteen&lt;/a&gt; 은 JSDOM @ 13입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18cfaa133eaa4a08198b5a6bdaede6aa76594392" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Node modules are automatically mocked when you have a manual mock in place (e.g.: &lt;code&gt;__mocks__/lodash.js&lt;/code&gt;). More info &lt;a href=&quot;manual-mocks#mocking-node-modules&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 수동 모의가 있으면 노드 모듈이 자동으로 조롱됩니다 (예 : &lt;code&gt;__mocks__/lodash.js&lt;/code&gt; ). 자세한 내용은 &lt;a href=&quot;manual-mocks#mocking-node-modules&quot;&gt;여기를 참조하십시오&lt;/a&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7b37680e518c9562d1b20b238b957e0975b25f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Setting this option overwrites the default values. Add &lt;code&gt;&quot;text&quot;&lt;/code&gt; or &lt;code&gt;&quot;text-summary&quot;&lt;/code&gt; to see a coverage summary in the console output.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 옵션을 설정하면 기본값을 덮어 씁니다. 추가 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;text-summary&quot;&lt;/code&gt; 콘솔 출력의 범위 요약을 볼 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd5d7a04d9f60617951367c692c674f878b4d3ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : TestEnvironment는 샌드 박스입니다. 각 테스트 스위트는 자체 TestEnvironment에서 설정 / 해제를 트리거합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c18c919f8dac5a6c8256d9066dc763fe50b700dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The &lt;code&gt;runner&lt;/code&gt; property value can omit the &lt;code&gt;jest-runner-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;runner&lt;/code&gt; 특성 값은 패키지 이름 의 &lt;code&gt;jest-runner-&lt;/code&gt; 접 두부를 생략 할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcf7dcc966f94fef3966960384230930aced5aa8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 기본 정규 표현식 일치는 소규모 실행에서는 잘 작동하지만 여러 패턴이 있거나 많은 테스트에 대해 제공되는 경우 속도가 느려집니다. 이 옵션은 정규식 일치 논리를 대체하고 Jest가 특정 테스트 파일을 필터링하는 데 걸리는 시간을 최적화합니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfa9163fcbea16af564621dc70234283c02d3dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default timeout interval is 5 seconds if this method is not called.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 메서드를 호출하지 않으면 기본 시간 초과 간격은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e63787225224750cba830a505303efd48b28af5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 정규식은 전체 이름과 일치합니다.이 이름은 테스트 이름과 모든 주변 설명 블록의 조합입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c2b5593cd2040bc5dc88584b808f0f16c4ca911" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The same caveat concerning transformation of &lt;code&gt;node_modules&lt;/code&gt; as for &lt;code&gt;globalSetup&lt;/code&gt; applies to &lt;code&gt;globalTeardown&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;주 : 변환에 관한 동일한주의 &lt;code&gt;node_modules&lt;/code&gt; 을 위한로서 &lt;code&gt;globalSetup&lt;/code&gt; 가 적용 &lt;code&gt;globalTeardown&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9de8c744892d1e80ade401b930bb5ff3026cf2c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The values in the &lt;code&gt;watchPlugins&lt;/code&gt; property value can omit the &lt;code&gt;jest-watch-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;watchPlugins&lt;/code&gt; 특성 값의 값은 패키지 이름 의 jest &lt;code&gt;jest-watch-&lt;/code&gt; watch- 접 두부를 생략 할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f5ef76a1f1ec3f0291cffbabb3da084f7d88dec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This option requires &lt;code&gt;collectCoverage&lt;/code&gt; to be set to true or Jest to be invoked with &lt;code&gt;--coverage&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 옵션을 사용하려면 &lt;code&gt;collectCoverage&lt;/code&gt; 를 true로 설정하거나 --coverage 로 Jest를 호출해야 &lt;code&gt;--coverage&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="47d1171d233bfb1c984686159fc340c7de69fc8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: When using multi project runner, it's recommended to add a &lt;code&gt;displayName&lt;/code&gt; for each project. This will show the &lt;code&gt;displayName&lt;/code&gt; of a project next to its tests.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 다중 프로젝트 러너를 사용하는 경우 각 프로젝트에 &lt;code&gt;displayName&lt;/code&gt; 을 추가하는 것이 좋습니다 . 테스트 옆에 프로젝트 의 &lt;code&gt;displayName&lt;/code&gt; 이 표시됩니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="238890f1d64dab554fbd8e7a47a71c12a5527b7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While &lt;code&gt;rootDir&lt;/code&gt; is mostly used as a token to be re-used in other configuration options, &lt;code&gt;roots&lt;/code&gt; is used by the internals of Jest to locate &lt;strong&gt;test files and source files&lt;/strong&gt;. This applies also when searching for manual mocks for modules from &lt;code&gt;node_modules&lt;/code&gt; (&lt;code&gt;__mocks__&lt;/code&gt; will need to live in one of the &lt;code&gt;roots&lt;/code&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;rootDir&lt;/code&gt; 은 주로 다른 구성 옵션에서 재사용 할 토큰으로 사용되지만 Jest 내부에서는 &lt;strong&gt;테스트 파일 및 소스 파일&lt;/strong&gt; 을 찾기 위해 &lt;code&gt;roots&lt;/code&gt; 를 사용 &lt;strong&gt;합니다&lt;/strong&gt; . 이는 &lt;code&gt;node_modules&lt;/code&gt; 에서 모듈에 대한 수동 모의를 검색 할 때도 적용됩니다 ( &lt;code&gt;__mocks__&lt;/code&gt; 는 &lt;code&gt;roots&lt;/code&gt; 중 하나에 있어야합니다 ).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad471e5c15682503858f775c8abc45c5311d043" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While code transformation is applied to the linked setup-file, Jest will &lt;strong&gt;not&lt;/strong&gt; transform any code in &lt;code&gt;node_modules&lt;/code&gt;. This is due to the need to load the actual transformers (e.g. &lt;code&gt;babel&lt;/code&gt; or &lt;code&gt;typescript&lt;/code&gt;) to perform transformation.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 코드 변환이 연결된 설정 파일에 적용되는 동안 Jest는 &lt;code&gt;node_modules&lt;/code&gt; 의 코드를 변환하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 이는 변환 을 수행하기 위해 실제 변압기 (예 : &lt;code&gt;babel&lt;/code&gt; 또는 &lt;code&gt;typescript&lt;/code&gt; )를 로드해야하기 때문 입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="418af2dac0b05fa2cb9f81b3f930b355f006be8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: a transformer is only run once per file unless the file has changed. During development of a transformer it can be useful to run Jest with &lt;code&gt;--no-cache&lt;/code&gt; to frequently &lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;delete Jest's cache&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 파일이 변경되지 않으면 변환기는 파일 당 한 번만 실행됩니다. 변압기를 개발하는 동안 &lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;Jest의 캐시&lt;/a&gt; 를 자주 삭제 하기 위해 &lt;code&gt;--no-cache&lt;/code&gt; 와 함께 Jest를 실행하는 것이 유용 할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="482df035eced9bdb0040d455527831161176059c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using babel-jest with additional code preprocessors, you have to explicitly define babel-jest as a transformer for your JavaScript code to map &lt;code&gt;.js&lt;/code&gt; files to the babel-jest module.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 추가 코드 프리 프로세서와 함께 babel-jest를 사용하는 경우 &lt;code&gt;.js&lt;/code&gt; 파일을 babel-jest 모듈 에 맵핑 하려면 babel-jest를 JavaScript 코드의 변환기로 명시 적으로 정의해야 합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="987bdba952341368e9fdda0bef0beeff5ba6fefd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using the &lt;code&gt;babel-jest&lt;/code&gt; transformer and want to use an additional code preprocessor, keep in mind that when &quot;transform&quot; is overwritten in any way the &lt;code&gt;babel-jest&lt;/code&gt; is not loaded automatically anymore. If you want to use it to compile JavaScript code it has to be explicitly defined. See &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;babel-jest plugin&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;babel-jest&lt;/code&gt; 변환기를 사용 중이고 추가 코드 전처리기를 사용하려는 경우 &quot;transform&quot;을 덮어 쓰면 &lt;code&gt;babel-jest&lt;/code&gt; 가 더 이상 자동으로로드되지 않습니다. JavaScript 코드를 컴파일하는 데 사용하려면 명시 적으로 정의해야합니다. 참조 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;바벨 - 농담 플러그인을&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f0ca3af28debded1b6575b80dc6e1d40989ed7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOff&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;disableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOff&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 메소드는 이전에 &lt;code&gt;autoMockOff&lt;/code&gt; 라고 했습니다 . &lt;code&gt;babel-jest&lt;/code&gt; 를 사용하면 &lt;code&gt;disableAutomock&lt;/code&gt; 호출 이 자동으로 코드 블록의 맨 위로 들어갑니다. 이 동작을 명시 적으로 피 하려면 &lt;code&gt;autoMockOff&lt;/code&gt; 를 사용하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db84e7f21a1dc5ea39ab8f33265d09f707ee968c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOn&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;enableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOn&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 메소드는 이전에 &lt;code&gt;autoMockOn&lt;/code&gt; 이라고 했습니다 . &lt;code&gt;babel-jest&lt;/code&gt; 를 사용하면 &lt;code&gt;enableAutomock&lt;/code&gt; 호출 이 자동으로 코드 블록의 맨 위로 들어갑니다. 이 동작을 명시 적으로 피 하려면 &lt;code&gt;autoMockOn&lt;/code&gt; 을 사용하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7299bad6f178500fdc51abcc8e1569c344960ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This means when you are using &lt;code&gt;test.each&lt;/code&gt; you cannot set the table asynchronously within a &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;beforeAll&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이것은 &lt;code&gt;test.each&lt;/code&gt; 를 사용할 때 &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;beforeAll&lt;/code&gt; 내에서 테이블을 비동기 적으로 설정할 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="241f4f76ffa23db053fa98e7e031ed5504849944" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. &lt;code&gt;[1, 2, 3] -&amp;gt; [[1], [2], [3]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; 프리미티브의 1D 배열을 전달하면 내부적으로 테이블에 매핑됩니다 (예 : &lt;code&gt;[1, 2, 3] -&amp;gt; [[1], [2], [3]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4754ed111a2e95c412ef07bc2c997fbd065c98bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: If you supply a test callback function then the &lt;code&gt;test.todo&lt;/code&gt; will throw an error. If you have already implemented the test and it is broken and you do not want it to run, then use &lt;code&gt;test.skip&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 테스트 콜백 함수를 제공하면 &lt;code&gt;test.todo&lt;/code&gt; 에서 오류가 발생합니다. 이미 테스트를 구현했지만 테스트가 중단되어 실행하지 않으려면 &lt;code&gt;test.skip&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="729bd471822307d2a8eeaa5067f5939172676b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In TypeScript, when using &lt;code&gt;@types/jest&lt;/code&gt; for example, you can declare the new &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher like this:</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : TypeScript에서 &lt;code&gt;@types/jest&lt;/code&gt; jest를 사용할 때 다음과 같이 새 &lt;code&gt;toBeWithinRange&lt;/code&gt; 매처를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a47e6352c36ff3c98347b31a0de45d69527492e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note: Arrow functions won't work&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;참고 : 화살표 기능이 작동하지 않습니다&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bce92dff88fcb38cb2ef321db1576b644934c39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And you're good to go!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그리고 당신은 잘 지내요!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f47b7739e2f44e81da3d675dbe29d4cd4cfbea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Babel 6 support&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;바벨 6 지원&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d549a077eab38cced620afe6afdb993c9ceab815" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Making your Babel config jest-aware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Babel 설정을 이해하기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3c3de6e563d40a11c1426be3aa604177c1e48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If the key for your plugin already exists as a default key, your plugin will override that key.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 플러그인 키가 기본 키로 이미 존재하면 플러그인이 해당 키를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="77fe3aedc23c7d8702924c934dd835e094300fe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you do call &lt;code&gt;updateConfigAndRun&lt;/code&gt;, your &lt;code&gt;run&lt;/code&gt; method should not resolve to a truthy value, as that would trigger a double-run.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 전화를 할 경우 &lt;code&gt;updateConfigAndRun&lt;/code&gt; 를 , 당신의 &lt;code&gt;run&lt;/code&gt; 즉 이중 실행을 트리거하는 것처럼 방법은하는 truthy 값으로 해석해서는 안된다.</target>
        </trans-unit>
        <trans-unit id="e2f90b799d6842bd0a0a8b24f41ee816215aadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The ideal configuration for Babel will depend on your project.&lt;/strong&gt; See &lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel's docs&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;Babel의 이상적인 구성은 프로젝트에 따라 다릅니다. &lt;/strong&gt;자세한 내용은 &lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel의 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce668cf7d663ed9bc164df218d8d07075d83d288" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Importing a module in a setup file (as specified by &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt;) will prevent mocking for the module in question, as well as all the modules that it imports.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; 에 지정된대로 설정 파일에서 모듈을 가져 오면 해당 모듈과 가져 오는 모든 모듈에 대한 모의가 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="6e782c9c810486eccfdccdb83eabb6b178a1382e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You just successfully wrote your first test using Jest!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Jest를 사용하여 첫 번째 테스트를 성공적으로 작성했습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b0bb22c03cbc1ff18563b0958776167824861c6" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with an &lt;code&gt;expand&lt;/code&gt; option. When Jest is called with the &lt;code&gt;--expand&lt;/code&gt; flag, &lt;code&gt;this.expand&lt;/code&gt; can be used to determine if Jest is expected to show full diffs and errors.</source>
          <target state="translated">이 매처를 알리는 부울이 &lt;code&gt;expand&lt;/code&gt; 옵션 으로 호출되었습니다 . Jest가 &lt;code&gt;--expand&lt;/code&gt; 플래그 와 함께 호출되면 &lt;code&gt;this.expand&lt;/code&gt; 를 사용하여 Jest가 전체 diff 및 오류를 표시 할 것으로 예상되는지 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="012dbb44ad2f6ca0c20c7b97c1ddcb94d414c9f2" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with the negated &lt;code&gt;.not&lt;/code&gt; modifier allowing you to display a clear and correct matcher hint (see example code).</source>
          <target state="translated">이 matcher를 알기위한 boolean은 negated &lt;code&gt;.not&lt;/code&gt; 수정 자 와 함께 호출되어 명확하고 정확한 matcher 힌트를 표시 할 수 있습니다 (예제 코드 참조).</target>
        </trans-unit>
        <trans-unit id="af490ebca4384b8349fd5f9297146f2aec7a3fc0" translate="yes" xml:space="preserve">
          <source>A glob pattern relative to</source>
          <target state="translated">에 대한 glob 패턴</target>
        </trans-unit>
        <trans-unit id="a5b7d8c7a67b8a17e4270a68f699bf890194473c" translate="yes" xml:space="preserve">
          <source>A limitation with the factory parameter is that, since calls to &lt;code&gt;jest.mock()&lt;/code&gt; are hoisted to the top of the file, it's not possible to first define a variable and then use it in the factory. An exception is made for variables that start with the word 'mock'. It's up to you to guarantee that they will be initialized on time! For example, the following will throw an out-of-scope error due to the use of 'fake' instead of 'mock' in the variable declaration:</source>
          <target state="translated">팩토리 매개 변수의 제한 사항은 &lt;code&gt;jest.mock()&lt;/code&gt; 대한 호출 이 파일 맨 위에 들어 있기 때문에 변수를 먼저 정의한 다음 팩토리에서 사용할 수 없다는 것입니다. 단어 'mock'으로 시작하는 변수는 예외입니다. 그들이 제 시간에 초기화되도록 보장하는 것은 당신에게 달려 있습니다! 예를 들어 다음은 변수 선언에서 'mock'대신 'fake'를 사용하여 범위를 벗어난 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b38da5fb413d73285571b89440d31882e9fc2da6" translate="yes" xml:space="preserve">
          <source>A list of paths to directories that Jest should use to search for files in.</source>
          <target state="translated">Jest가 파일을 검색 할 때 사용해야하는 디렉토리의 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cfcb41fe8954fc025d854be9b9598a2ec86464ce" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment immediately before executing the test code itself.</source>
          <target state="translated">테스트 환경을 구성하거나 설정하기 위해 일부 코드를 실행하는 모듈의 경로 목록입니다. 각 setupFile은 테스트 파일 당 한 번씩 실행됩니다. 모든 테스트는 자체 환경에서 실행되므로 이러한 스크립트는 테스트 코드 자체를 실행하기 직전에 테스트 환경에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e1bd291245533c3461bfdd8ed955a870554cea" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing framework before each test. Since &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment.</source>
          <target state="translated">각 테스트 전에 테스트 프레임 워크를 구성하거나 설정하기 위해 일부 코드를 실행하는 모듈에 대한 경로 목록입니다. 이후 &lt;a href=&quot;#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; 의&lt;/a&gt; 테스트 프레임 워크 실행되기 전에 환경이 스크립트 파일 선물 당신에게 테스트 프레임 워크가 환경에 설치 한 직후 일부 코드를 실행하는 기회를에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="418f7a1fe2ae7327be6076c7526644e5f6102913" translate="yes" xml:space="preserve">
          <source>A list of paths to snapshot serializer modules Jest should use for snapshot testing.</source>
          <target state="translated">Jest가 스냅 샷 테스트에 사용해야하는 스냅 샷 직렬 변환기 모듈의 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5a46db07aaab9152f5a9b72c5970e6d46fe37d14" translate="yes" xml:space="preserve">
          <source>A list of reporter names that Jest uses when writing coverage reports. Any &lt;a href=&quot;https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib&quot;&gt;istanbul reporter&lt;/a&gt; can be used.</source>
          <target state="translated">Jest가 범위 보고서를 작성할 때 사용하는 기자 이름 목록입니다. 모든 &lt;a href=&quot;https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib&quot;&gt;이스탄불 리포터를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10fd310121e376e1ef1248ca973cafa088db8588" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to module names that allow to stub out resources, like images or styles with a single module.</source>
          <target state="translated">정규식에서 모듈 이름으로의 맵으로 단일 모듈로 이미지 나 스타일과 같은 리소스를 스텁 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7d829b1f4fd705d3b5320bfde131a522e2ecc3" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files. For example, if you wanted to be able to use a new language feature in your modules or tests that isn't yet supported by node, you might plug in one of many compilers that compile a future version of JavaScript to a current one. Example: see the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;examples/typescript&lt;/a&gt; example or the &lt;a href=&quot;webpack&quot;&gt;webpack tutorial&lt;/a&gt;.</source>
          <target state="translated">정규식에서 변압기까지의 경로에 대한 맵입니다. 변환기는 소스 파일 변환을위한 동기 기능을 제공하는 모듈입니다. 예를 들어, 모듈에서 아직 새로운 언어 기능을 사용하거나 노드에서 지원하지 않는 테스트를 사용하려는 경우, 향후 버전의 JavaScript를 현재 버전으로 컴파일하는 많은 컴파일러 중 하나를 플러그인 할 수 있습니다. 예 : &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;예제 / 타입 스크립트&lt;/a&gt; 예제 또는 &lt;a href=&quot;webpack&quot;&gt;웹팩 튜토리얼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29ea19c50da9069cc4d49aa47baff8528c53ac76" translate="yes" xml:space="preserve">
          <source>A new object will be created each time the mock constructor function is called during tests. To spy on method calls in all of these objects, we populate &lt;code&gt;playSoundFile&lt;/code&gt; with another mock function, and store a reference to that same mock function in our test file, so it's available during tests.</source>
          <target state="translated">테스트 중에 모의 생성자 함수가 호출 될 때마다 새로운 객체가 생성됩니다. 이러한 모든 객체에서 메소드 호출을 감시하기 위해 &lt;code&gt;playSoundFile&lt;/code&gt; 을 다른 모의 함수로 채우고 테스트 파일에 동일한 모의 함수에 대한 참조를 저장하므로 테스트 중에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="160f997798a9fad1ea7cbbac49992e492f385217" translate="yes" xml:space="preserve">
          <source>A number limiting the number of tests that are allowed to run at the same time when using &lt;code&gt;test.concurrent&lt;/code&gt;. Any test above this limit will be queued and executed once a slot is released.</source>
          <target state="translated">&lt;code&gt;test.concurrent&lt;/code&gt; 를 사용할 때 동시에 실행할 수있는 테스트 수를 제한하는 숫자입니다 . 이 제한을 초과하는 모든 테스트는 슬롯이 해제되면 대기하고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="36dc2aec80d27ca5f391ce3fab1f19651dbe2e41" translate="yes" xml:space="preserve">
          <source>A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a &lt;code&gt;jest-preset.json&lt;/code&gt; or &lt;code&gt;jest-preset.js&lt;/code&gt; file at the root.</source>
          <target state="translated">Jest 구성의 기본으로 사용되는 사전 설정입니다. 사전 설정은 루트에 &lt;code&gt;jest-preset.js&lt;/code&gt; &lt;code&gt;jest-preset.json&lt;/code&gt; 또는 jest-preset.js 파일 이있는 npm 모듈을 가리켜 야 합니다.</target>
        </trans-unit>
        <trans-unit id="371782ecc77ce4aff2f7102c108e974456414ab4" translate="yes" xml:space="preserve">
          <source>A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">테스트를 실행하기 전에 모든 테스트 경로와 일치하는 정규 표현식 패턴 문자열입니다. Windows에서는 &lt;code&gt;/&lt;/code&gt; 를 경로 구분 기호로 사용하거나 이스케이프 &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="771c72cf637d4dc2b4dcc0ad878cbe45a19120be" translate="yes" xml:space="preserve">
          <source>A set of global variables that need to be available in all test environments.</source>
          <target state="translated">모든 테스트 환경에서 사용할 수있는 전역 변수 세트입니다.</target>
        </trans-unit>
        <trans-unit id="fb9f21925e50fbc4c20514cc0b67d91ec78b66ca" translate="yes" xml:space="preserve">
          <source>A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js&quot;&gt;example test&lt;/a&gt; for a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js&quot;&gt;Link component&lt;/a&gt;:</source>
          <target state="translated">React 구성 요소를 테스트 할 때 비슷한 접근 방식을 취할 수 있습니다. 전체 앱을 빌드해야하는 그래픽 UI를 렌더링하는 대신 테스트 렌더러를 사용하여 React 트리의 직렬화 가능 값을 빠르게 생성 할 수 있습니다. &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js&quot;&gt;Link 컴포넌트에&lt;/a&gt; 대한 다음 &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js&quot;&gt;예제 테스트&lt;/a&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f3f3cc749a42e125fb041eeb2151de773021c2b" translate="yes" xml:space="preserve">
          <source>A string allowing you to display a clear and correct matcher hint:</source>
          <target state="translated">명확하고 올바른 매처 힌트를 표시 할 수있는 문자열 :</target>
        </trans-unit>
        <trans-unit id="4b045dcedc246b83978bc16fd0119acaf1bb3450" translate="yes" xml:space="preserve">
          <source>A typical snapshot test case for a mobile app renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.</source>
          <target state="translated">모바일 앱의 일반적인 스냅 샷 테스트 사례는 UI 구성 요소를 렌더링하고 스냅 샷을 작성한 다음 테스트와 함께 저장된 참조 스냅 샷 파일과 비교합니다. 두 스냅 샷이 일치하지 않으면 테스트가 실패합니다. 변경이 예상치 않거나 참조 스냅 샷이 새 버전의 UI 구성 요소로 업데이트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="94a27227dfd567fa1e14aded42955e64a1211e71" translate="yes" xml:space="preserve">
          <source>A webpack example</source>
          <target state="translated">웹팩 예제</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="4a8b7c1d861ff3818c82461eaba792c636764ff9" translate="yes" xml:space="preserve">
          <source>Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself &amp;ndash; the only difference is that the implementation will also be executed when the mock is called.</source>
          <target state="translated">모의 구현으로 사용해야하는 기능을 허용합니다. 모의 자체는 여전히 들어오는 모든 호출과 그 자체에서 오는 인스턴스를 기록합니다. 유일한 차이점은 모의가 호출 될 때 구현도 실행된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="179d3db7494b4a55ec9382c56b083999dab4097c" translate="yes" xml:space="preserve">
          <source>Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.</source>
          <target state="translated">모의 함수를 한 번 호출하기 위해 모의 구현으로 사용될 함수를 승인합니다. 여러 함수 호출이 다른 결과를 생성하도록 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e5417eb3ede5aa3146561fc2e7f28ecffcd802" translate="yes" xml:space="preserve">
          <source>Accepts a string to use in test result output in place of &quot;jest.fn()&quot; to indicate which mock function is being referenced.</source>
          <target state="translated">&quot;jest.fn ()&quot;대신 테스트 결과 출력에 사용할 문자열을 허용하여 참조중인 모의 함수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5deee23f2f4af004e724d36935577b403688324b" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more &lt;code&gt;mockReturnValueOnce&lt;/code&gt; values to use, calls will return a value specified by &lt;code&gt;mockReturnValue&lt;/code&gt;.</source>
          <target state="translated">모의 함수에 대한 한 번의 호출에 대해 리턴 될 값을 승인합니다. 모의 함수에 대한 연속적인 호출이 다른 값을 반환하도록 연결될 수 있습니다. 사용할 &lt;code&gt;mockReturnValueOnce&lt;/code&gt; 값 이 더 이상 없으면 호출은 &lt;code&gt;mockReturnValue&lt;/code&gt; 로 지정된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2e03d6231e5e5d597041e1a89580d10a7c89d6" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned whenever the mock function is called.</source>
          <target state="translated">mock 함수가 호출 될 때마다 리턴되는 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="627fd999fe60eb1e9fa61ee59d201b42906b203a" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results.</source>
          <target state="translated">테스트 결과에 대한 알림을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="56b26cac2f5cd92c194eaf6b35f2ccfb8b632ce9" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.</source>
          <target state="translated">테스트 결과에 대한 알림을 활성화합니다. JavaScript 테스트 이외의 것에 집중하기를 원하지 않는 경우에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b2b4d9faf83e823777e17d32c35a1ca5f152a2f8" translate="yes" xml:space="preserve">
          <source>Add the following section to your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 에 다음 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3a19c94e2b8b3963d8f7c38fd24982dd6310852" translate="yes" xml:space="preserve">
          <source>Additional Configuration</source>
          <target state="translated">추가 구성</target>
        </trans-unit>
        <trans-unit id="7d97a763f6b6d3194d818e5f34a2dd68b20b1a98" translate="yes" xml:space="preserve">
          <source>Additionally, custom reporters can be configured by passing an &lt;code&gt;options&lt;/code&gt; object as a second argument:</source>
          <target state="translated">또한 &lt;code&gt;options&lt;/code&gt; 개체를 두 번째 인수로 전달하여 사용자 지정 기자를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93f5d5d810fd868ec5f1446605cf43a303b38e7d" translate="yes" xml:space="preserve">
          <source>Additionally, you can substitute captured regex groups using numbered backreferences.</source>
          <target state="translated">또한 번호가 매겨진 역 참조를 사용하여 캡처 된 정규식 그룹을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a12f0e8115380c12166066c9e4f273d00f4c44d6" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;location&lt;/code&gt; field to test results. Useful if you want to report the location of a test in a reporter.</source>
          <target state="translated">테스트 할 &lt;code&gt;location&lt;/code&gt; 필드를 추가합니다 . 리포터에서 테스트 위치를보고하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7a3d37ab930375cdcd79b34d3b10e75da31c499" translate="yes" xml:space="preserve">
          <source>Advance Timers by Time</source>
          <target state="translated">시간별 사전 ​​타이머</target>
        </trans-unit>
        <trans-unit id="af9ddf57a7d50c5e6b5eff43535f9164538d33dc" translate="yes" xml:space="preserve">
          <source>Advances all timers by the needed milliseconds so that only the next timeouts/intervals will run.</source>
          <target state="translated">다음 시간 초과 / 간격 만 실행되도록 필요한 시간 (밀리 초)만큼 모든 타이머를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="cf6e685581823cbf41e050cfa3d4d3efe68f3736" translate="yes" xml:space="preserve">
          <source>After this method is called, all &lt;code&gt;require()&lt;/code&gt;s will return the real versions of each module (rather than a mocked version).</source>
          <target state="translated">이 메소드가 호출 된 후 모든 &lt;code&gt;require()&lt;/code&gt; 는 모의 버전이 아닌 각 모듈의 실제 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42e4edac6675eabca400c0935453060c87c093dd" translate="yes" xml:space="preserve">
          <source>Again, we create a test file in the &lt;code&gt;__tests__/&lt;/code&gt; folder:</source>
          <target state="translated">다시 한 번 &lt;code&gt;__tests__/&lt;/code&gt; 폴더 에 테스트 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3539642d3664ec2813c705bf1656fa80d215afd0" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-b&lt;/code&gt;. Exit the test suite immediately upon &lt;code&gt;n&lt;/code&gt; number of failing test suite. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">별명 : &lt;code&gt;-b&lt;/code&gt; . &lt;code&gt;n&lt;/code&gt; 개의 실패한 테스트 스위트가 있으면 테스트 스위트를 즉시 종료하십시오 . 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f545c267035a3769cec67deb4d85dbdea5ed4279" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-c&lt;/code&gt;. The path to a Jest config file specifying how to find and execute tests. If no &lt;code&gt;rootDir&lt;/code&gt; is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.</source>
          <target state="translated">별명 : &lt;code&gt;-c&lt;/code&gt; . 테스트를 찾고 실행하는 방법을 지정하는 Jest 구성 파일의 경로입니다. 구성에 &lt;code&gt;rootDir&lt;/code&gt; 이 설정되어 있지 않으면 구성 파일을 포함하는 디렉토리는 프로젝트의 rootDir로 간주됩니다. 이것은 Jest가 구성으로 사용할 JSON 인코딩 값일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5168880339d67b2e370e60c0c6ab283939bd91e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-e&lt;/code&gt;. Use this flag to show full diffs and errors instead of a patch.</source>
          <target state="translated">별명 : &lt;code&gt;-e&lt;/code&gt; . 패치 대신 전체 diffs 및 오류를 표시하려면이 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99493a7a51fd254391a3ebbc240c428c0990c61c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-i&lt;/code&gt;. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.</source>
          <target state="translated">별명 : &lt;code&gt;-i&lt;/code&gt; . 테스트를 실행하는 하위 프로세스의 작업자 풀을 작성하지 않고 현재 프로세스에서 모든 테스트를 순차적으로 실행하십시오. 디버깅에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2552460fa09d12f47cce10ce54895c78e5d11fe6" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-o&lt;/code&gt;. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).</source>
          <target state="translated">별명 : &lt;code&gt;-o&lt;/code&gt; . 현재 저장소에서 변경된 파일을 기반으로 실행할 테스트를 식별하려고 시도합니다. 현재 git / hg 저장소에서 테스트를 실행 중이고 정적 종속성 그래프가 필요한 경우에만 작동합니다 (예 : 동적 요구 사항 없음).</target>
        </trans-unit>
        <trans-unit id="8a0722768635f39bb520a598cac25b8461c84a1e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-t&lt;/code&gt;. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like &lt;code&gt;&quot;GET /api/posts with auth&quot;&lt;/code&gt;, then you can use &lt;code&gt;jest -t=auth&lt;/code&gt;.</source>
          <target state="translated">별명 : &lt;code&gt;-t&lt;/code&gt; . 정규식과 일치하는 이름의 테스트 만 실행하십시오. 예를 들어, &lt;code&gt;&quot;GET /api/posts with auth&quot;&lt;/code&gt; 같은 이름을 가진 권한 부여 관련 테스트 만 실행하려는 경우 &lt;code&gt;jest -t=auth&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efa1a34b400f2f90695824c1275bc4ed1fcfc281" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-u&lt;/code&gt;. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with &lt;code&gt;--testNamePattern&lt;/code&gt; to re-record snapshots.</source>
          <target state="translated">별명 : &lt;code&gt;-u&lt;/code&gt; . 이 테스트 실행 중 실패한 모든 스냅 샷을 다시 기록하려면이 플래그를 사용하십시오. 테스트 스위트 패턴 또는 &lt;code&gt;--testNamePattern&lt;/code&gt; 과 함께 사용하여 스냅 샷을 다시 기록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ecc088a9387041c13956d514f3c30314c61256c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-v&lt;/code&gt;. Print the version and exit.</source>
          <target state="translated">별명 : &lt;code&gt;-v&lt;/code&gt; . 버전을 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="9514d4a998cf0be55fdd8c1f8b3ab17496d0b427" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-w&lt;/code&gt;. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.</source>
          <target state="translated">별명 : &lt;code&gt;-w&lt;/code&gt; . 워커 풀이 테스트를 실행하기 위해 생성 할 최대 워커 수를 지정합니다. 단일 실행 모드에서는 기본적으로 머신에서 사용 가능한 코어 수에서 메인 스레드에 대한 코어를 뺀 것입니다. 감시 모드에서는 Jest가 눈에 거슬리지 않고 컴퓨터가 정지되지 않도록 시스템에서 사용 가능한 코어의 절반으로 기본 설정됩니다. CI와 같은 리소스 제한 환경에서는이를 조정하는 것이 유용 할 수 있지만 대부분의 사용 사례에는 기본값이 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="f293634d4b71e268b9315270803e95d567d5c055" translate="yes" xml:space="preserve">
          <source>All mock functions have this special &lt;code&gt;.mock&lt;/code&gt; property, which is where data about how the function has been called and what the function returned is kept. The &lt;code&gt;.mock&lt;/code&gt; property also tracks the value of &lt;code&gt;this&lt;/code&gt; for each call, so it is possible to inspect this as well:</source>
          <target state="translated">모든 모의 함수에는이 특수한 &lt;code&gt;.mock&lt;/code&gt; 속성 이 있습니다.이 속성에는 함수 호출 방법 및 반환 된 함수에 대한 데이터가 있습니다. &lt;code&gt;.mock&lt;/code&gt; 의 속성은 트랙의 값 &lt;code&gt;this&lt;/code&gt; 그것뿐만 아니라이 검사 할 수 있도록, 각 통화를 :</target>
        </trans-unit>
        <trans-unit id="d200710c4a1cb0a5518adeb855b420c9df2492c3" translate="yes" xml:space="preserve">
          <source>All you need in a test file is the &lt;code&gt;test&lt;/code&gt; method which runs a test. For example, let's say there's a function &lt;code&gt;inchesOfRain()&lt;/code&gt; that should be zero. Your whole test could be:</source>
          <target state="translated">테스트 파일에는 &lt;code&gt;test&lt;/code&gt; 를 실행하는 테스트 방법 만 있으면 됩니다. 예를 들어, &lt;code&gt;inchesOfRain()&lt;/code&gt; 함수 가 0이어야 한다고 가정 해 봅시다 . 전체 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c6cdf6ad0cf9e05d26b92de733df230ae967936" translate="yes" xml:space="preserve">
          <source>Allows for a label to be printed along side a test while it is running. This becomes more useful in multiproject repositories where there can be many jest configuration files. This visually tells which project a test belongs to. Here are sample valid values.</source>
          <target state="translated">테스트가 진행되는 동안 테스트와 함께 레이블을 인쇄 할 수 있습니다. 이것은 많은 jest 구성 파일이있을 수있는 다중 프로젝트 저장소에서 더 유용합니다. 테스트가 속한 프로젝트를 시각적으로 알려줍니다. 유효한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac2d2b88484d26d6b0274df05b58474c9355339d" translate="yes" xml:space="preserve">
          <source>Allows the test suite to pass when no files are found.</source>
          <target state="translated">파일이 없을 때 테스트 스위트가 통과 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3ee11433796f7928eadda086f2e6317eba0f644e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting.html&quot;&gt;watchman troubleshooting&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting.html&quot;&gt;경비원 문제 해결&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ded90d6a8a58f29b63088540765e42efe71e66" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastCalledWith(arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.lastCalledWith(arg1, arg2, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72068b84899b93d08efebb5fbde5f86a2871fab0" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastReturnedWith(value)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.lastReturnedWith(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="099a9c56b2ffb0e433746f2d5a063a53bf87848e" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthCalledWith(nthCall, arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.nthCalledWith(nthCall, arg1, arg2, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e71518680860b6335bd23e9b151d1d48ae804594" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthReturnedWith(nthCall, value)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.nthReturnedWith(nthCall, value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a976e7b6194d79232f8dd968730fcf8fa8de0bd4" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.runTimersToTime()&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.runTimersToTime()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="395cc025e9320dbca3e418277a47146fbe85a545" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalled()&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toBeCalled()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1b36b77a3b08255bd86abb689d07b9d3cda7cd8" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledTimes(number)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toBeCalledTimes(number)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab40e2a7cc91a41899b406bbf45e995ae8a0ccb3" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledWith()&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toBeCalledWith()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f135f1b735c2c08a602b278941f22ef918f12f6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturn()&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toReturn()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc7e9d708812efa106b415eb4de6b5bc6cf9f969" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnTimes(number)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toReturnTimes(number)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba2bf1dae2731b6f4c302617ced0c81f8cbe1e1d" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnWith(value)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래 : &lt;code&gt;.toReturnWith(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05408f6b685f91d674e7459a4e02a520c37b9ff6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toThrowError(error?)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에 : &lt;code&gt;.toThrowError(error?)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c1feacec240ab724aed9abf11d8481d5be016bb" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;fdescribe(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에서 &lt;code&gt;fdescribe(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aa5b0deb73cbf5bf4609fd6f9f31b133a58ef15" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에서 : &lt;code&gt;it(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f02580bb5866da485a9c58917275f794f170733" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;it.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에는 &lt;code&gt;it.each(table)(name, fn)&lt;/code&gt; 및 &lt;code&gt;it.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86566af6d287f431b2f25caf18aaacdb4fe0fed9" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;xdescribe(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에 &lt;code&gt;xdescribe(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f49a6ff10db6d3abd0202c575a4990526242f321" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;fdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;fdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에 &lt;code&gt;fdescribe.each(table)(name, fn)&lt;/code&gt; 및 &lt;code&gt;fdescribe.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df617fb63c786231166be551a69c544fb3bc875f" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt; or &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에는 &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt; 또는 &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3a927b33c56953bae3577b5390aba2c2c4cb3bc" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;fit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.only.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;fit.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에는 &lt;code&gt;it.only.each(table)(name, fn)&lt;/code&gt; , &lt;code&gt;fit.each(table)(name, fn)&lt;/code&gt; , &lt;code&gt;it.only.each`table`(name, fn)&lt;/code&gt; 및 &lt;code&gt;fit.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7b5764e499cb8d78c16305a6528c4899aa522b4" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip(name, fn)&lt;/code&gt; or &lt;code&gt;xit(name, fn)&lt;/code&gt; or &lt;code&gt;xtest(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별명 아래 : &lt;code&gt;it.skip(name, fn)&lt;/code&gt; 또는 &lt;code&gt;xit(name, fn)&lt;/code&gt; 또는 &lt;code&gt;xtest(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ae7b77488478baa85c14484c98a4586556a4adf" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xtest.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.skip.each`table`(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;xtest.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별칭 아래에는 &lt;code&gt;it.skip.each(table)(name, fn)&lt;/code&gt; , &lt;code&gt;xit.each(table)(name, fn)&lt;/code&gt; , &lt;code&gt;xtest.each(table)(name, fn)&lt;/code&gt; , &lt;code&gt;it.skip.each`table`(name, fn)&lt;/code&gt; , &lt;code&gt;xit.each`table`(name, fn)&lt;/code&gt; 및 &lt;code&gt;xtest.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebaf7711efc2429bdcc957d7601bf8b98792f7e8" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;xdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;xdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">또한 별명 아래 : &lt;code&gt;xdescribe.each(table)(name, fn)&lt;/code&gt; 및 &lt;code&gt;xdescribe.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09523aba51788d839f21a8368cdbeff7d157bb04" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;async/await&lt;/code&gt; 을 &lt;code&gt;.rejects&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="287ce7bb7699bc441de5c565dd6f0ff136cd6f02" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.resolves&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;async/await&lt;/code&gt; 를 &lt;code&gt;.resolves&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="683a48469ae34941c2dfe3c02609cb488fc9cf6e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; in your tests. To write an async test, use the &lt;code&gt;async&lt;/code&gt; keyword in front of the function passed to &lt;code&gt;test&lt;/code&gt;. For example, the same &lt;code&gt;fetchData&lt;/code&gt; scenario can be tested with:</source>
          <target state="translated">또는 테스트에서 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 를 사용할 수 있습니다 . 비동기 테스트를 작성하기 위해 사용하는 &lt;code&gt;async&lt;/code&gt; 전달 함수의 앞에 키워드를 &lt;code&gt;test&lt;/code&gt; . 예를 들어, 동일한 &lt;code&gt;fetchData&lt;/code&gt; 시나리오를 다음과 같이 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e70e3500483b9c230e96ed71d6eb2850d7817875" translate="yes" xml:space="preserve">
          <source>Although Jest may be considered a React-specific test runner, in fact it is a universal testing platform, with the ability to adapt to any JavaScript library or framework. In this section we'd like to link to community posts and articles about integrating Jest into other popular JS libraries.</source>
          <target state="translated">Jest는 React 전용 테스트 러너로 간주 될 수 있지만 실제로는 모든 JavaScript 라이브러리 또는 프레임 워크에 적응할 수있는 범용 테스트 플랫폼입니다. 이 섹션에서는 Jest를 다른 인기있는 JS 라이브러리에 통합하는 방법에 대한 커뮤니티 게시물 및 기사에 링크하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7f675838f49f79bd87cbdc6aa6c10ac099c8d1a7" translate="yes" xml:space="preserve">
          <source>Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.</source>
          <target state="translated">스냅 샷 파일을 수동으로 작성할 수는 있지만 일반적으로 접근 할 수는 없습니다. 스냅 샷은 처음에 코드를 설계하기위한 지침을 제공하기보다는 테스트 대상 모듈의 출력이 변경되는지 여부를 파악하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="aebd1363c6cc98b159d0cd54a133b3010fd2af74" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;.toBe&lt;/code&gt; matcher &lt;strong&gt;checks&lt;/strong&gt; referential identity, it &lt;strong&gt;reports&lt;/strong&gt; a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, to assert whether or not elements are the same instance:</source>
          <target state="translated">있지만 &lt;code&gt;.toBe&lt;/code&gt; 의 정규의 &lt;strong&gt;검사&lt;/strong&gt; 참조 정체성, 그것을 &lt;strong&gt;보고&lt;/strong&gt; 어설 션이 실패 할 경우 값의 깊은 비교. 속성 간의 차이가 테스트 실패 이유를 이해하는 데 도움이되지 않는 경우 (특히 보고서가 큰 경우) &lt;code&gt;expect&lt;/code&gt; 함수 로 비교를 이동할 수 있습니다. 예를 들어 요소가 동일한 인스턴스인지 여부를 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5588d7b29731ae809c64e5bdc946641ff8cdc8da" translate="yes" xml:space="preserve">
          <source>Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.</source>
          <target state="translated">항상 스냅 샷에 설명적인 테스트 및 / 또는 스냅 샷 이름을 사용하도록 노력하십시오. 최상의 이름은 예상 스냅 샷 내용을 나타냅니다. 이를 통해 검토자는 검토 중에 스냅 샷을 쉽게 확인할 수 있으며 업데이트 전에 오래된 스냅 샷이 올바른 동작인지 여부를 누구나 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf3cd7d4822e4172301955fdbd34bbf3ead80369" translate="yes" xml:space="preserve">
          <source>An Async Example</source>
          <target state="translated">비동기 예제</target>
        </trans-unit>
        <trans-unit id="6b45a17cec3531985bca09a2f51e8258c6a164d8" translate="yes" xml:space="preserve">
          <source>An ES6 Class Example</source>
          <target state="translated">ES6 클래스 예</target>
        </trans-unit>
        <trans-unit id="9503b02977c75b74fc98515eaf543859ba4a5b20" translate="yes" xml:space="preserve">
          <source>An alternative API to setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, &lt;code&gt;modulePaths&lt;/code&gt; is an array of absolute paths to additional locations to search when resolving modules. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/app/&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NODE_PATH&lt;/code&gt; env 변수 를 설정하는 대체 API 인 &lt;code&gt;modulePaths&lt;/code&gt; 는 모듈을 분석 할 때 검색 할 추가 위치에 대한 절대 경로의 배열입니다. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용 하여 프로젝트의 루트 디렉토리 경로를 포함하십시오. 예 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/app/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c18c5e14d9b27331affd203c3ba0a5ea7a448a7c" translate="yes" xml:space="preserve">
          <source>An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.</source>
          <target state="translated">이 모의 함수에 대한 모든 호출의 호출 인수를 포함하는 배열입니다. 배열의 각 항목은 호출 중에 전달 된 인수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a46ce930eedbd7ddf653339853dcb9a903d0d421" translate="yes" xml:space="preserve">
          <source>An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a &lt;code&gt;type&lt;/code&gt; property, and a &lt;code&gt;value&lt;/code&gt; property. &lt;code&gt;type&lt;/code&gt; will be one of the following:</source>
          <target state="translated">이 모의 함수에 대한 모든 호출의 결과를 포함하는 배열입니다. 이 배열의 각 항목은 &lt;code&gt;type&lt;/code&gt; 속성과 &lt;code&gt;value&lt;/code&gt; 속성을 포함하는 객체 입니다. &lt;code&gt;type&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="31d55820d20196b774de801007398d7381eb5e21" translate="yes" xml:space="preserve">
          <source>An array of &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;glob patterns&lt;/a&gt; indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.</source>
          <target state="translated">적용 범위 정보를 수집해야하는 파일 세트를 나타내는 &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;glob 패턴&lt;/a&gt; 배열입니다 . 파일이 지정된 glob 패턴과 일치하면이 파일에 대한 테스트가없고 테스트 스위트에 필요하지 않더라도 적용 범위 정보가 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3bdf241dff3305fbf27dbe0b111fd6f3b0eab9" translate="yes" xml:space="preserve">
          <source>An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.</source>
          <target state="translated">감시 모드에서 테스트를 다시 실행하기 전에 모든 소스 파일 경로와 일치하는 RegExp 패턴 배열입니다. 파일 경로가 패턴 중 하나와 일치하면 업데이트 될 때 테스트 재실행이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e893f728a32633130f596bfb0591acef847120" translate="yes" xml:space="preserve">
          <source>An array of directory names to be searched recursively up from the requiring module's location. Setting this option will &lt;em&gt;override&lt;/em&gt; the default, if you wish to still search &lt;code&gt;node_modules&lt;/code&gt; for packages include it along with any other options: &lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;]&lt;/code&gt;</source>
          <target state="translated">필요한 모듈 위치에서 재귀 적으로 검색 할 디렉토리 이름 배열입니다. 이 옵션을 설정하면 패키지에 대한 &lt;code&gt;node_modules&lt;/code&gt; 를 계속 검색하려는 경우 &lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;]&lt;/code&gt; 와 같은 다른 옵션과 함께 패키지를 포함 하려는 경우 기본값 을 &lt;em&gt;무시&lt;/em&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="504281b83c6e81672ff2b065f899819937fcacff" translate="yes" xml:space="preserve">
          <source>An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.</source>
          <target state="translated">모듈이 사용하는 파일 확장자 배열. 파일 확장자를 지정하지 않고 모듈이 필요한 경우 Jest가 왼쪽에서 오른쪽으로 찾는 확장자입니다.</target>
        </trans-unit>
        <trans-unit id="b68561e3089004cad3aab8c72147f145d5ad00d9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.</source>
          <target state="translated">테스트를 실행하기 전에 모든 파일 경로와 일치하는 정규 표현식 패턴 문자열의 배열입니다. 파일 경로가 패턴 중 하나와 일치하면 적용 범위 정보를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="87abc2e394f90095864df40d50a17bb32b006523" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be &lt;code&gt;require()&lt;/code&gt;-able in the test environment.</source>
          <target state="translated">해당 경로가 모듈 로더에 '보이는'것으로 간주되기 전에 모든 모듈 경로와 일치하는 정규 표현식 패턴 문자열 배열입니다. 주어진 모듈의 경로가 패턴과 일치 하면 테스트 환경에서 &lt;code&gt;require()&lt;/code&gt; 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f96ebc6e5bdb81dd85cf0fb671eb2514e1041de9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.</source>
          <target state="translated">모듈 로더가 모든 모듈에 대해 일치하는 정규 표현식 패턴 문자열 배열은 모듈 로더가 자동으로 모의 객체를 반환합니다. 모듈의 경로가이 목록의 패턴과 일치하면 모듈 로더에 의해 자동으로 조롱되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af6404a872edd8e55e2e1adae4ddcdf7e2a10352" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all source file paths before transformation. If the test path matches any of the patterns, it will not be transformed.</source>
          <target state="translated">변환하기 전에 모든 소스 파일 경로와 일치하는 정규 표현식 패턴 문자열의 배열입니다. 테스트 경로가 패턴과 일치하면 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95938a1191b9cbb1d990900f10c57777a2e1ed42" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.</source>
          <target state="translated">테스트를 실행하기 전에 모든 테스트 경로와 일치하는 정규 표현식 패턴 문자열의 배열입니다. 테스트 경로가 패턴 중 하나와 일치하면 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="462ad2f4a8409549d0f759cb0132577334a47d4c" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that is tested against all tests paths before executing the test. Contrary to &lt;code&gt;--testPathPattern&lt;/code&gt;, it will only run those test with a path that does not match with the provided regexp expressions.</source>
          <target state="translated">테스트를 실행하기 전에 모든 테스트 경로에 대해 테스트되는 정규 표현식 패턴 문자열의 배열입니다. &lt;code&gt;--testPathPattern&lt;/code&gt; 과 달리 제공된 정규 표현식과 일치하지 않는 경로로만 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1ada50d1e8326b688b4e15a2802d96af20f6a4b7" translate="yes" xml:space="preserve">
          <source>An array that contains all the object instances that have been instantiated from this mock function using &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 를 사용하여이 모의 함수에서 인스턴스화 된 모든 객체 인스턴스를 포함하는 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="7c5d2ee3d8eaab26feb4c41b55794ee099a28cca" translate="yes" xml:space="preserve">
          <source>An example of such function can be found in our default &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts&quot;&gt;jasmine2 test runner package&lt;/a&gt;.</source>
          <target state="translated">이러한 기능의 예는 기본 &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts&quot;&gt;jasmine2 테스트 러너 패키지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="607f0bc7049c328734f7e81696dd602383afb610" translate="yes" xml:space="preserve">
          <source>And More</source>
          <target state="translated">그리고 더</target>
        </trans-unit>
        <trans-unit id="8e09ac014c181587ec460524c0658c52a8de5d93" translate="yes" xml:space="preserve">
          <source>And finally, we have to handle the webpack &lt;code&gt;alias&lt;/code&gt;. For that we can make use of the &lt;code&gt;moduleNameMapper&lt;/code&gt; option again.</source>
          <target state="translated">마지막으로 webpack &lt;code&gt;alias&lt;/code&gt; 를 처리해야합니다 . 이를 위해 &lt;code&gt;moduleNameMapper&lt;/code&gt; 옵션을 다시 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dbc245e76c3e8b9a776e2d6e639bb997d2acd75" translate="yes" xml:space="preserve">
          <source>And it will generate the following snapshot:</source>
          <target state="translated">그리고 다음과 같은 스냅 샷을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6b3a68e32529c05dce55087b82076e0dc6576f89" translate="yes" xml:space="preserve">
          <source>And the mock files themselves:</source>
          <target state="translated">그리고 모의 파일 자체 :</target>
        </trans-unit>
        <trans-unit id="8e09000e5c2a6bef346596ec2e0dec0fbf7495a6" translate="yes" xml:space="preserve">
          <source>Angular</source>
          <target state="translated">Angular</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="742a5629f9bbfed1143d85bb3d0a7ea7fc795192" translate="yes" xml:space="preserve">
          <source>Another alternative to expediting test execution time on Continuous Integration Servers such as Travis-CI is to set the max worker pool to ~&lt;em&gt;4&lt;/em&gt;. Specifically on Travis-CI, this can reduce test execution time in half. Note: The Travis CI &lt;em&gt;free&lt;/em&gt; plan available for open source projects only includes 2 CPU cores.</source>
          <target state="translated">Travis-CI와 같은 Continuous Integration Server에서 테스트 실행 시간을 단축하는 또 다른 대안은 max worker pool을 ~ &lt;em&gt;4&lt;/em&gt; 로 설정하는 것 입니다. 특히 Travis-CI에서는 테스트 실행 시간을 절반으로 줄일 수 있습니다. 참고 : 오픈 소스 프로젝트에 사용 가능한 Travis CI &lt;em&gt;무료&lt;/em&gt; 요금제는 2 개의 CPU 코어 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5d396fa096245e4ff526d431e1fdc7511c337853" translate="yes" xml:space="preserve">
          <source>Another class of functions that is often considered difficult to test is code that directly manipulates the DOM. Let's see how we can test the following snippet of jQuery code that listens to a click event, fetches some data asynchronously and sets the content of a span.</source>
          <target state="translated">종종 테스트하기 어려운 것으로 간주되는 또 다른 클래스는 DOM을 직접 조작하는 코드입니다. click 이벤트를 수신하고 일부 데이터를 비동기 적으로 가져오고 범위의 내용을 설정하는 다음 jQuery 코드 스 니펫을 테스트하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="893f79ed3ff3f37c6371db618f971f7d16027030" translate="yes" xml:space="preserve">
          <source>Another possibility is use &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt;. When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via setTimeout() or setInterval(), and would be executed during this time frame, will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue that should be run within msToRun milliseconds.</source>
          <target state="translated">또 다른 가능성은 &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt; 입니다. 이 API가 호출되면 모든 타이머는 &lt;code&gt;msToRun&lt;/code&gt; 밀리 초 단위 로 진행됩니다 . setTimeout () 또는 setInterval ()을 통해 대기하고이 시간 동안 실행되는 모든 보류중인 &quot;매크로 작업&quot;이 실행됩니다. 또한 해당 매크로 작업이 동일한 시간 프레임 내에서 실행될 새 매크로 작업을 예약하는 경우 msToRun 밀리 초 내에 실행되어야하는 대기열에 매크로 작업이 더 이상 남아 있지 않을 때까지 해당 매크로 작업이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3836d5626c7fcd443d2b13b3c90a168aeac159" translate="yes" xml:space="preserve">
          <source>Another test we might want to write for this module is one that asserts that the callback is called after 1 second. To do this, we're going to use Jest's timer control APIs to fast-forward time right in the middle of the test:</source>
          <target state="translated">이 모듈에 대해 작성하려는 또 다른 테스트는 1 초 후에 콜백이 호출되도록하는 것입니다. 이를 위해 Jest의 타이머 제어 API를 사용하여 테스트 도중에 시간을 빨리 감습니다.</target>
        </trans-unit>
        <trans-unit id="4a103c34b8de331bd76f45b2403f7aed399db936" translate="yes" xml:space="preserve">
          <source>Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with it's value set to an empty string. If the pragma is not present, it will not be present in the object.</source>
          <target state="translated">테스트 파일의 모든 docblock pragma는 환경 생성자로 전달되어 테스트 별 구성에 사용될 수 있습니다. pragma에 값이 없으면 값이 빈 문자열로 설정된 객체에 존재합니다. pragma가 없으면 개체에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62674adc2fd45e062316f5e05f5f083ea662d480" translate="yes" xml:space="preserve">
          <source>Any given value that is not a matcher will be checked exactly and saved to the snapshot:</source>
          <target state="translated">매 처가 아닌 모든 주어진 값이 정확하게 검사되고 스냅 샷에 저장됩니다 :</target>
        </trans-unit>
        <trans-unit id="5c5b7ea7bd8c1a3b846217990f58a7237946847e" translate="yes" xml:space="preserve">
          <source>Any key not used by built-in functionality can be claimed, as you would expect. Try to avoid using keys that are difficult to obtain on various keyboards (e.g. &lt;code&gt;&amp;eacute;&lt;/code&gt;, &lt;code&gt;&amp;euro;&lt;/code&gt;), or not visible by default (e.g. many Mac keyboards do not have visual hints for characters such as &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, etc.)</source>
          <target state="translated">내장 기능에서 사용하지 않는 모든 키를 예상 할 수 있습니다. 다양한 키보드 (예 : &lt;code&gt;&amp;eacute;&lt;/code&gt; , &lt;code&gt;&amp;euro;&lt;/code&gt; )에서 얻 거나 기본적으로 보이지 않는 키 (예 : 많은 Mac 키보드에는 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 등의 문자에 대한 시각적 힌트가 없음)를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="4565f29db31ebc3ed2837a5c66dc7f7115c60784" translate="yes" xml:space="preserve">
          <source>Are snapshots written automatically on Continuous Integration (CI) systems?</source>
          <target state="translated">CI (Continuous Integration) 시스템에서 스냅 샷이 자동으로 작성됩니까?</target>
        </trans-unit>
        <trans-unit id="1f735920f6b1287b080ec6ef4f28c968da24737c" translate="yes" xml:space="preserve">
          <source>Arguments can also be mixed:</source>
          <target state="translated">인수를 혼합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5eb7315732ba1dd9aa54c5447ef8251ac1f1a72" translate="yes" xml:space="preserve">
          <source>Array sparseness is checked. e.g. &lt;code&gt;[, 1]&lt;/code&gt; does not match &lt;code&gt;[undefined, 1]&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="translated">배열 스패시 시스가 점검됩니다. 예를 들어 &lt;code&gt;.toStrictEqual&lt;/code&gt; 을 사용할 때 &lt;code&gt;[, 1]&lt;/code&gt; 은 &lt;code&gt;[undefined, 1]&lt;/code&gt; 과 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b3bc07f8fe3ae265bc1c65271265c09fffe2ede6" translate="yes" xml:space="preserve">
          <source>Arrays and iterables</source>
          <target state="translated">배열과 이터 러블</target>
        </trans-unit>
        <trans-unit id="74911a9974788ee31baf4332aa46469914fc0018" translate="yes" xml:space="preserve">
          <source>As a secondary option, an object with the properties &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; can be passed. This allows for a custom configuration of the background color of the displayName. &lt;code&gt;displayName&lt;/code&gt; defaults to white when its value is a string. Jest uses &lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;chalk&lt;/a&gt; to provide the color. As such, all of the valid options for colors supported by chalk are also supported by jest.</source>
          <target state="translated">보조 옵션으로 속성 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;color&lt;/code&gt; 가진 객체를 전달할 수 있습니다. 이를 통해 displayName의 배경색을 사용자 정의 할 수 있습니다. 값이 문자열 인 경우 &lt;code&gt;displayName&lt;/code&gt; 의 기본값은 흰색입니다. Jest는 &lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;분필&lt;/a&gt; 을 사용하여 색상을 제공합니다. 따라서 분필이 지원하는 색상에 대한 모든 유효한 옵션도 jest에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce4c489a4e9ecd6d0287803d6407ac937c080c8" translate="yes" xml:space="preserve">
          <source>As an example to show why this is the case, imagine we wrote a test like so:</source>
          <target state="translated">이것이 왜 그런지 보여주는 예로써, 다음과 같이 테스트를했다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="5bff98a0df6c56f2756da9281d0404c838a0e295" translate="yes" xml:space="preserve">
          <source>As mentioned previously, Jest uses &lt;a href=&quot;https://yarnpkg.com/en/package/pretty-format&quot;&gt;&lt;code&gt;pretty-format&lt;/code&gt;&lt;/a&gt; to make snapshots human-readable, but you may find it useful to introduce additional tools, like &lt;a href=&quot;https://yarnpkg.com/en/package/eslint-plugin-jest&quot;&gt;&lt;code&gt;eslint-plugin-jest&lt;/code&gt;&lt;/a&gt; with its &lt;a href=&quot;https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md&quot;&gt;&lt;code&gt;no-large-snapshots&lt;/code&gt;&lt;/a&gt; option, or &lt;a href=&quot;https://yarnpkg.com/en/package/snapshot-diff&quot;&gt;&lt;code&gt;snapshot-diff&lt;/code&gt;&lt;/a&gt; with its component snapshot comparison feature, to promote committing short, focused assertions.</source>
          <target state="translated">앞에서 언급했듯이 Jest는 &lt;a href=&quot;https://yarnpkg.com/en/package/pretty-format&quot;&gt; &lt;code&gt;pretty-format&lt;/code&gt; &lt;/a&gt; 을 사용하여 스냅 샷을 사람이 읽을 수있게 만들지 만 &lt;a href=&quot;https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md&quot;&gt; &lt;code&gt;no-large-snapshots&lt;/code&gt; &lt;/a&gt; 옵션 이 없는 &lt;a href=&quot;https://yarnpkg.com/en/package/eslint-plugin-jest&quot;&gt; &lt;code&gt;eslint-plugin-jest&lt;/code&gt; &lt;/a&gt; 또는 구성 요소 스냅 샷이있는 &lt;a href=&quot;https://yarnpkg.com/en/package/snapshot-diff&quot;&gt; &lt;code&gt;snapshot-diff&lt;/code&gt; &lt;/a&gt; 와 같은 추가 도구를 소개하는 것이 유용 할 수 있습니다. 짧고 집중적 인 주장을 촉진하기위한 비교 기능.</target>
        </trans-unit>
        <trans-unit id="2edb0f24d18bfcbc00e0c78839a1fdf035ed9311" translate="yes" xml:space="preserve">
          <source>Ask questions and find answers from other Jest users like you. &lt;a href=&quot;http://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; is a Discord chat where a lot of Jest discussion happens. Check out the &lt;a href=&quot;https://discord.gg/MWRhKCj&quot;&gt;#jest&lt;/a&gt; channel.</source>
          <target state="translated">귀하와 같은 다른 Jest 사용자로부터 질문을하고 답변을 찾으십시오. &lt;a href=&quot;http://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; 는 많은 Jest 토론이 발생하는 Discord 채팅입니다. &lt;a href=&quot;https://discord.gg/MWRhKCj&quot;&gt;#jest&lt;/a&gt; 채널을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddc2d7716879ffcf62253d1d725243538c0235af" translate="yes" xml:space="preserve">
          <source>Async Matchers</source>
          <target state="translated">비동기 매처</target>
        </trans-unit>
        <trans-unit id="f56a660f0dad726695b31dda5b8891615117ac6d" translate="yes" xml:space="preserve">
          <source>Async/Await</source>
          <target state="translated">Async/Await</target>
        </trans-unit>
        <trans-unit id="e27221756365cd045960f2e94d5cb617a09fd66c" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt; applications.</source>
          <target state="translated">Facebook에서는 Jest를 사용하여 &lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt; 애플리케이션 을 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="395b841bd250360a8d39d43d0cc9468e6a191ff3" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; applications.</source>
          <target state="translated">Facebook에서는 Jest를 사용하여 &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 애플리케이션 을 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="f6cdaf4152db0f4f16342bd19654aceac0ca1e3e" translate="yes" xml:space="preserve">
          <source>Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use &lt;code&gt;--forceExit&lt;/code&gt; in order for Jest to exit to potentially track down the reason. This implies &lt;code&gt;--runInBand&lt;/code&gt;, making tests run serially. Implemented using &lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt;&lt;code&gt;async_hooks&lt;/code&gt;&lt;/a&gt;, so it only works in Node 8 and newer. This option has a significant performance penalty and should only be used for debugging.</source>
          <target state="translated">Jest가 깨끗하게 종료되지 않도록 열린 핸들을 수집하여 인쇄하십시오. Jest가 종료되어 이유를 추적 할 수 있도록 &lt;code&gt;--forceExit&lt;/code&gt; 를 사용해야하는 경우에 이것을 사용하십시오 . 이것은 &lt;code&gt;--runInBand&lt;/code&gt; 를 의미 하며 테스트를 순차적으로 실행합니다. &lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt; &lt;code&gt;async_hooks&lt;/code&gt; 를&lt;/a&gt; 사용하여 구현 되었으므로 노드 8 이상에서만 작동합니다. 이 옵션은 성능이 크게 저하되므로 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f6dc28e5599c9cab49b9e2c317821c7dd774121" translate="yes" xml:space="preserve">
          <source>Authorized configuration keys</source>
          <target state="translated">인증 된 구성 키</target>
        </trans-unit>
        <trans-unit id="116210a421ba183e44c078b53f193cdc6fb43a87" translate="yes" xml:space="preserve">
          <source>Automatic mock</source>
          <target state="translated">자동 모의</target>
        </trans-unit>
        <trans-unit id="0219bef967d8f707c8e0246d4db056aae02a5ccf" translate="yes" xml:space="preserve">
          <source>Automatically clear mock calls and instances before every test. Equivalent to calling &lt;code&gt;jest.clearAllMocks()&lt;/code&gt; before each test. This does not remove any mock implementation that may have been provided.</source>
          <target state="translated">모든 테스트 전에 모의 호출 및 인스턴스를 자동으로 지 웁니다. 각 테스트 전에 &lt;code&gt;jest.clearAllMocks()&lt;/code&gt; 를 호출하는 것과 같습니다 . 제공된 모의 구현을 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1087f99cc0f32ae4b69ceb38fb06f0ea54c89a40" translate="yes" xml:space="preserve">
          <source>Automatically reset mock state before every test. Equivalent to calling &lt;code&gt;jest.resetAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.</source>
          <target state="translated">매 테스트 전에 모의 상태를 자동으로 재설정합니다. 각 테스트 전에 &lt;code&gt;jest.resetAllMocks()&lt;/code&gt; 를 호출하는 것과 같습니다 . 이것은 가짜 구현이 제거 된 모의로 이어지지 만 초기 구현은 복원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4c3e6aeec9cba44ed3be7bda907111f3172875" translate="yes" xml:space="preserve">
          <source>Automatically restore mock state before every test. Equivalent to calling &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.</source>
          <target state="translated">매 테스트 전에 모의 상태를 자동으로 복원합니다. 각 테스트 전에 &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; 를 호출하는 것과 같습니다 . 이것은 가짜 구현을 제거하고 초기 구현을 복원하는 모의로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="2c6957f4f82498b87545ed7a33f9f93969bbb3e6" translate="yes" xml:space="preserve">
          <source>Based on the &lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-262366820&quot;&gt;findings&lt;/a&gt;, one way to mitigate this issue and improve the speed by up to 50% is to run tests sequentially.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-262366820&quot;&gt;결과를&lt;/a&gt; 바탕 으로이 문제를 완화하고 속도를 최대 50 % 향상시키는 한 가지 방법은 테스트를 순차적으로 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="50f2f862e91add8b90e4a6da877a14f5e16eb9dc" translate="yes" xml:space="preserve">
          <source>Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:</source>
          <target state="translated">Jest는 프로젝트를 기반으로 몇 가지 질문을하고 각 옵션에 대한 간단한 설명과 함께 기본 구성 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fc6bfef866c16d00ea780b8f331139cb8d28b83d" translate="yes" xml:space="preserve">
          <source>Be sure to return the assertion&amp;mdash;if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; is resolved and then() has a chance to execute the callback.</source>
          <target state="translated">어설 션을 반환해야합니다.이 &lt;code&gt;return&lt;/code&gt; 문 을 생략하면 &lt;code&gt;fetchData&lt;/code&gt; 에서 반환 된 약속 이 해결 된 다음 테스트가 완료 되어 콜백을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3f556e536c0e7e0056301601d7417c65940d6ae" translate="yes" xml:space="preserve">
          <source>Be sure to return the promise - if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; resolves and then() has a chance to execute the callback.</source>
          <target state="translated">약속을 반환하십시오-이 &lt;code&gt;return&lt;/code&gt; 문 을 생략하면 &lt;code&gt;fetchData&lt;/code&gt; 에서 반환 된 약속이 해결되고 then ()이 콜백을 실행할 수 있기 전에 테스트가 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f9fd1717377fe3279d351011475ce90a698762e" translate="yes" xml:space="preserve">
          <source>Because we don't want to go to the network in our test, we are going to create a manual mock for our &lt;code&gt;request.js&lt;/code&gt; module in the &lt;code&gt;__mocks__&lt;/code&gt; folder (the folder is case-sensitive, &lt;code&gt;__MOCKS__&lt;/code&gt; will not work). It could look something like this:</source>
          <target state="translated">테스트에서 네트워크에 가고 싶지 않기 때문에 &lt;code&gt;__mocks__&lt;/code&gt; 폴더 에 &lt;code&gt;request.js&lt;/code&gt; 모듈에 대한 수동 모의를 만들 것입니다 (폴더는 대소 문자를 구분하며 &lt;code&gt;__MOCKS__&lt;/code&gt; 는 작동하지 않습니다). 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64753a59b275da395d2c1dc8b7dcb455fad7c963" translate="yes" xml:space="preserve">
          <source>Below are the hooks available in Jest.</source>
          <target state="translated">아래는 Jest에서 사용 가능한 후크입니다.</target>
        </trans-unit>
        <trans-unit id="36de90e22d47f94d755a4b1bb70aaddc1bb47593" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="a1f0fcd3b8d03992c8b96556ac49a857175afecc" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockClear&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="translated">조심하십시오 &lt;code&gt;mockClear&lt;/code&gt; 가 대체 할 것이다 &lt;code&gt;mockFn.mock&lt;/code&gt; 뿐 아니라 &lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; 을&lt;/a&gt; . 따라서 오래된 데이터에 액세스하지 않도록 &lt;code&gt;mockFn.mock&lt;/code&gt; 을 임시 또는 다른 변수에 할당 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="931ccb5668e93107bc30b0d906bbc9a8b26f7c56" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockFn.mockRestore&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;. Thus you have to take care of restoration yourself when manually assigning &lt;code&gt;jest.fn()&lt;/code&gt;.</source>
          <target state="translated">조심하십시오 &lt;code&gt;mockFn.mockRestore&lt;/code&gt; 이 모의가 작성된 시점에만 작동 &lt;code&gt;jest.spyOn&lt;/code&gt; . 따라서 &lt;code&gt;jest.fn()&lt;/code&gt; 수동으로 할당 할 때는 직접 복원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4b002ef5dff177f13b0153d72646356c1a85e431" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockReset&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="translated">조심하십시오 &lt;code&gt;mockReset&lt;/code&gt; 가 대체 할 것이다 &lt;code&gt;mockFn.mock&lt;/code&gt; 뿐 아니라 &lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; 을&lt;/a&gt; . 따라서 오래된 데이터에 액세스하지 않도록 &lt;code&gt;mockFn.mock&lt;/code&gt; 을 임시 또는 다른 변수에 할당 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bfb7bb160ae4e03b6bfacba742441ea7d2e578df" translate="yes" xml:space="preserve">
          <source>Browse the docs</source>
          <target state="translated">문서 찾아보기</target>
        </trans-unit>
        <trans-unit id="276a88c140a6bf7107571e0e3473c859f70d5592" translate="yes" xml:space="preserve">
          <source>Building your constructor function mock using &lt;code&gt;jest.fn().mockImplementation()&lt;/code&gt; makes mocks appear more complicated than they really are. This section shows how you can create your own mocks to illustrate how mocking works.</source>
          <target state="translated">&lt;code&gt;jest.fn().mockImplementation()&lt;/code&gt; 을 사용하여 생성자 함수 모의 객체를 빌드 하면 모의 객체가 실제보다 더 복잡해 보입니다. 이 섹션에서는 모의 작동 방식을 설명하기 위해 자신 만의 모의 객체를 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="72789db809aebd98e3793977340fa23a403dd9b2" translate="yes" xml:space="preserve">
          <source>By adding a &lt;code&gt;@jest-environment&lt;/code&gt; docblock at the top of the file, you can specify another environment to be used for all tests in that file:</source>
          <target state="translated">파일 맨 위에 &lt;code&gt;@jest-environment&lt;/code&gt; docblock을 추가하여 해당 파일의 모든 테스트에 사용할 다른 환경을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64a054e0008020bcca517ad251114bdd878bd10" translate="yes" xml:space="preserve">
          <source>By default the jest-react-native preset only processes the project's own source files and react-native. If you have npm dependencies that have to be transformed you can customize this configuration option by whitelisting modules other than react-native:</source>
          <target state="translated">기본적으로 jest-react-native 사전 설정은 프로젝트 자체 소스 파일과 반응 네이티브 만 처리합니다. 변환해야하는 npm 종속성이있는 경우 react-native 이외의 모듈을 화이트리스트에 추가하여이 구성 옵션을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24192876f804f24abf879b9436d1771d8dea9d51" translate="yes" xml:space="preserve">
          <source>By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after &lt;code&gt;n&lt;/code&gt; failures. Setting bail to &lt;code&gt;true&lt;/code&gt; is the same as setting bail to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">기본적으로 Jest는 모든 테스트를 실행하고 완료시 콘솔에 모든 오류를 생성합니다. bail config 옵션은 여기서 Jest가 &lt;code&gt;n&lt;/code&gt; 개의 실패 후 테스트 실행을 중지하도록 사용할 수 있습니다 . 보석금을 &lt;code&gt;true&lt;/code&gt; 로 설정하는 것은 보석금을 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1c18e033ac397507497b08aca298046458436f1b" translate="yes" xml:space="preserve">
          <source>By default, Jest tests complete once they reach the end of their execution. That means this test will &lt;em&gt;not&lt;/em&gt; work as intended:</source>
          <target state="translated">기본적으로 Jest 테스트는 실행이 끝나면 완료됩니다. 이는이 테스트가 의도 한대로 작동 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="84e08a56bb6409c96440829d4111b8fe08c3fc8c" translate="yes" xml:space="preserve">
          <source>By default, each test file gets its own independent module registry. Enabling &lt;code&gt;resetModules&lt;/code&gt; goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that local module state doesn't conflict between tests. This can be done programmatically using &lt;a href=&quot;jest-object#jestresetmodules&quot;&gt;&lt;code&gt;jest.resetModules()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 각 테스트 파일에는 자체 독립 모듈 레지스트리가 있습니다. &lt;code&gt;resetModules&lt;/code&gt; 활성화 하면 개별 테스트를 실행하기 전에 한 단계 더 나아가 모듈 레지스트리를 재설정합니다. 로컬 모듈 상태가 테스트간에 충돌하지 않도록 모든 테스트에 대해 모듈을 분리하는 데 유용합니다. 이것은 &lt;a href=&quot;jest-object#jestresetmodules&quot;&gt; &lt;code&gt;jest.resetModules()&lt;/code&gt; &lt;/a&gt; 사용하여 프로그래밍 방식으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd069e07b719971ba572ee8dd0ce8e0d70313aa8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks apply to every test in a file. You can also group tests together using a &lt;code&gt;describe&lt;/code&gt; block. When they are inside a &lt;code&gt;describe&lt;/code&gt; block, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks only apply to the tests within that &lt;code&gt;describe&lt;/code&gt; block.</source>
          <target state="translated">기본적으로 &lt;code&gt;before&lt;/code&gt; 및 &lt;code&gt;after&lt;/code&gt; 블록은 파일의 모든 테스트에 적용됩니다. &lt;code&gt;describe&lt;/code&gt; 블록을 사용하여 테스트를 그룹화 할 수도 있습니다 . &lt;code&gt;describe&lt;/code&gt; 블록 내에있는 경우 &lt;code&gt;before&lt;/code&gt; 및 &lt;code&gt;after&lt;/code&gt; 블록은 해당 &lt;code&gt;describe&lt;/code&gt; 블록 내의 테스트에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ff6b50d4d2916e059b4da78398d7f7528e06bc4" translate="yes" xml:space="preserve">
          <source>By now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.</source>
          <target state="translated">지금까지 Jest가 애플리케이션을 테스트하는 데 어떻게 도움이되는지 잘 알고 있어야합니다. 더 배우고 싶다면 여기에 확인하고 싶은 관련 자료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ee7b41c21d659b9270bc90149ebea235b5681e" translate="yes" xml:space="preserve">
          <source>Bypassing module mocks</source>
          <target state="translated">모듈 모의 우회</target>
        </trans-unit>
        <trans-unit id="90c44908e93edab5744658b1f65e26d8c711f11b" translate="yes" xml:space="preserve">
          <source>Caching Issues</source>
          <target state="translated">캐싱 문제</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="29ebbaf2a884d1472efa612e0a99881e086b0d45" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; with the module factory parameter</source>
          <target state="translated">모듈 팩토리 파라미터로 &lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; 호출</target>
        </trans-unit>
        <trans-unit id="d6fb7b5fdc1cb7e80c6697d89dc59adbcb936cfd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;jest.mock('./sound-player')&lt;/code&gt; returns a useful &quot;automatic mock&quot; you can use to spy on calls to the class constructor and all of its methods. It replaces the ES6 class with a mock constructor, and replaces all of its methods with &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt; that always return &lt;code&gt;undefined&lt;/code&gt;. Method calls are saved in &lt;code&gt;theAutomaticMock.mock.instances[index].methodName.mock.calls&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;jest.mock('./sound-player')&lt;/code&gt; 유용한 &quot;자동 모의&quot;당신은 클래스 생성자를 호출하고 모든 메소드 감시하는 데 사용할 수를 반환합니다. ES6 클래스를 모의 생성자로 대체하고 모든 메소드 를 항상 &lt;code&gt;undefined&lt;/code&gt; 를 반환하는 &lt;a href=&quot;mock-functions&quot;&gt;모의 함수로&lt;/a&gt; 대체합니다 . 메소드 호출은 &lt;code&gt;theAutomaticMock.mock.instances[index].methodName.mock.calls&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f20ec8cdd6ae393d85748c5307b9a180fdb961ea" translate="yes" xml:space="preserve">
          <source>Calls to jest.mock are hoisted to the top of the code. You can specify a mock later, e.g. in &lt;code&gt;beforeAll()&lt;/code&gt;, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; (or &lt;code&gt;mockImplementationOnce()&lt;/code&gt;) on the existing mock instead of using the factory parameter. This also allows you to change the mock between tests, if needed:</source>
          <target state="translated">jest.mock에 대한 호출은 코드 상단으로 들어갑니다. 팩토리 매개 변수를 사용하는 대신 기존 모의에서 &lt;code&gt;mockImplementation()&lt;/code&gt; (또는 &lt;code&gt;mockImplementationOnce()&lt;/code&gt; )을 호출하여 나중에 모의를 지정할 수 있습니다 &lt;code&gt;beforeAll()&lt;/code&gt; 예 : beforeAll () ). 또한 필요한 경우 테스트간에 모의를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b5e900f807b38adaa6e9c85b7fbbbdc6e0face" translate="yes" xml:space="preserve">
          <source>Camelcase &amp;amp; dashed args support</source>
          <target state="translated">낙타 및 파선 args 지원</target>
        </trans-unit>
        <trans-unit id="5ceb09d577f5f6169012cae86d6ed0c20f9308f0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;React Tree Snapshot Testing&lt;/a&gt; for more information on snapshot testing.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;스냅 샷 테스트에&lt;/a&gt; 대한 자세한 정보는 React Tree Snapshot Testing 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8ad42e0821d727215f4c5c74225fda2de21bcbc" translate="yes" xml:space="preserve">
          <source>Check out the section on &lt;a href=&quot;snapshot-testing#inline-snapshots&quot;&gt;Inline Snapshots&lt;/a&gt; for more info.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;snapshot-testing#inline-snapshots&quot;&gt;인라인 스냅 샷&lt;/a&gt; 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="834816cb4074428815336a2cb6e1928bb56da7fb" translate="yes" xml:space="preserve">
          <source>Choosing a good key</source>
          <target state="translated">좋은 열쇠를 선택</target>
        </trans-unit>
        <trans-unit id="f282371c2a1af22d1e4a9f0b7e80f6cb76f88540" translate="yes" xml:space="preserve">
          <source>Cleaning up between tests</source>
          <target state="translated">테스트 간 정리</target>
        </trans-unit>
        <trans-unit id="951b5b48e067f46712c0fc43e2f448c71ed835a5" translate="yes" xml:space="preserve">
          <source>Clears the &lt;code&gt;mock.calls&lt;/code&gt; and &lt;code&gt;mock.instances&lt;/code&gt; properties of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;.mockClear()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">모든 모의 &lt;code&gt;mock.calls&lt;/code&gt; 및 &lt;code&gt;mock.instances&lt;/code&gt; 속성을 지 웁니다 . 모든 조롱 된 함수에서 &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;.mockClear()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d6db6e9b2b18300b8b1943a06238aa498f4d0ffe" translate="yes" xml:space="preserve">
          <source>Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.</source>
          <target state="translated">스냅 샷을 커밋하고 정기적 인 코드 검토 프로세스의 일부로 검토하십시오. 즉, 프로젝트에서 다른 유형의 테스트 또는 코드와 마찬가지로 스냅 샷을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="5317e60e1477cd7f5e0cf5cbb3fd4f6fbfd42186" translate="yes" xml:space="preserve">
          <source>Common Matchers</source>
          <target state="translated">공통 매처</target>
        </trans-unit>
        <trans-unit id="39af2b26c9ee2c162295a79a46bf64f2dcb740b9" translate="yes" xml:space="preserve">
          <source>Community projects under one organisation are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.</source>
          <target state="translated">한 조직의 커뮤니티 프로젝트는 Jest가 새로운 아이디어 / 기술과 접근법을 실험 할 수있는 좋은 방법입니다. 커뮤니티의 기여를 장려하고 더 빠른 속도로 독립적으로 기여를 게시하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac62a488978924e46345706e5701acf535027b1" translate="yes" xml:space="preserve">
          <source>Compatibility issues</source>
          <target state="translated">호환성 문제</target>
        </trans-unit>
        <trans-unit id="647a61b7661823bee3e0fb318ccb983ea06af198" translate="yes" xml:space="preserve">
          <source>Complete example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="7338817b3b4ee94bffc83800ba5beb8a9de91061" translate="yes" xml:space="preserve">
          <source>Config: //</source>
          <target state="translated">구성 : //</target>
        </trans-unit>
        <trans-unit id="419b3ad350c5399b2d30683f98566248a0ccc3a0" translate="yes" xml:space="preserve">
          <source>Config: automock</source>
          <target state="translated">구성 : automock</target>
        </trans-unit>
        <trans-unit id="627e8b1a128fd33accae1330833eabb2bdca8973" translate="yes" xml:space="preserve">
          <source>Config: bail</source>
          <target state="translated">구성 : 보석금</target>
        </trans-unit>
        <trans-unit id="bc5d64a5311bb274fd46a79262ecb43ee3a1e121" translate="yes" xml:space="preserve">
          <source>Config: browser</source>
          <target state="translated">구성 : 브라우저</target>
        </trans-unit>
        <trans-unit id="4367a209c83015f162fc0ca638a3e053c9041bdb" translate="yes" xml:space="preserve">
          <source>Config: cacheDirectory</source>
          <target state="translated">구성 : cacheDirectory</target>
        </trans-unit>
        <trans-unit id="cf5e892834611f65829eeac25c2d08106d23b5a7" translate="yes" xml:space="preserve">
          <source>Config: clearMocks</source>
          <target state="translated">구성 : clearMocks</target>
        </trans-unit>
        <trans-unit id="501c70b5aa067226067f0b907eb78a61fccc193d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverage</source>
          <target state="translated">구성 : collectCoverage</target>
        </trans-unit>
        <trans-unit id="b208010efbcc655b8d5fcea13db6ce8d2238cf7d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverageFrom</source>
          <target state="translated">구성 : collectCoverageFrom</target>
        </trans-unit>
        <trans-unit id="bdf43098f46df2169bb90995abc4f207c9f4654b" translate="yes" xml:space="preserve">
          <source>Config: coverageDirectory</source>
          <target state="translated">구성 : coverageDirectory</target>
        </trans-unit>
        <trans-unit id="e61dfeddb711754aa3eea86892ddac143c1cf750" translate="yes" xml:space="preserve">
          <source>Config: coveragePathIgnorePatterns</source>
          <target state="translated">구성 : coveragePathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="4dc823be9ce961ce58c7a5bd2c3ede521ec9b22c" translate="yes" xml:space="preserve">
          <source>Config: coverageReporters</source>
          <target state="translated">구성 : coverageReporters</target>
        </trans-unit>
        <trans-unit id="731365c9b4185412e26d012a648d84274b7ee783" translate="yes" xml:space="preserve">
          <source>Config: coverageThreshold</source>
          <target state="translated">구성 : coverageThreshold</target>
        </trans-unit>
        <trans-unit id="6ddb77352d47cc2ab7211c5bb66e8ea1cf8dbedb" translate="yes" xml:space="preserve">
          <source>Config: dependencyExtractor</source>
          <target state="translated">구성 : dependencyExtractor</target>
        </trans-unit>
        <trans-unit id="410a11c871d9b9ac5d1c84224af14915bc5687c9" translate="yes" xml:space="preserve">
          <source>Config: displayName</source>
          <target state="translated">구성 : displayName</target>
        </trans-unit>
        <trans-unit id="27317b3ce2dc1add449b8f662db64de41a9e9ae6" translate="yes" xml:space="preserve">
          <source>Config: errorOnDeprecated</source>
          <target state="translated">구성 : errorOnDeprecated</target>
        </trans-unit>
        <trans-unit id="fecda0afbc8d772eae7fac9e4ba0b8b1d10e359f" translate="yes" xml:space="preserve">
          <source>Config: extraGlobals</source>
          <target state="translated">구성 : extraGlobals</target>
        </trans-unit>
        <trans-unit id="b25f9152c510580dbb37bfa8b225c9b83eec07f3" translate="yes" xml:space="preserve">
          <source>Config: forceCoverageMatch</source>
          <target state="translated">구성 : forceCoverageMatch</target>
        </trans-unit>
        <trans-unit id="79761896d6c24e1a388783f8ad0d4cf62e966150" translate="yes" xml:space="preserve">
          <source>Config: globalSetup</source>
          <target state="translated">구성 : globalSetup</target>
        </trans-unit>
        <trans-unit id="92db96d317bc0181d4c70c0a736f44496f34c5f0" translate="yes" xml:space="preserve">
          <source>Config: globalTeardown</source>
          <target state="translated">구성 : globalTeardown</target>
        </trans-unit>
        <trans-unit id="bf2c2049305c4a3db421bc76e052ff49dd5e09c4" translate="yes" xml:space="preserve">
          <source>Config: globals</source>
          <target state="translated">구성 : 전역</target>
        </trans-unit>
        <trans-unit id="d67799f97ad1d1ba5dbde5c2bbea2d9e7a64e588" translate="yes" xml:space="preserve">
          <source>Config: maxConcurrency</source>
          <target state="translated">구성 : maxConcurrency</target>
        </trans-unit>
        <trans-unit id="ba41029a807595561e6313c2154c8d63b551b08f" translate="yes" xml:space="preserve">
          <source>Config: moduleDirectories</source>
          <target state="translated">구성 : moduleDirectories</target>
        </trans-unit>
        <trans-unit id="0c69621f31253439feae40f7edb9f987c54a7c60" translate="yes" xml:space="preserve">
          <source>Config: moduleFileExtensions</source>
          <target state="translated">구성 : moduleFileExtensions</target>
        </trans-unit>
        <trans-unit id="e56cc759b41f3e82ba32926a92966a3f498e6902" translate="yes" xml:space="preserve">
          <source>Config: moduleNameMapper</source>
          <target state="translated">구성 : moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="20a45c51d17976a84164108ba1570ebaa713c2d0" translate="yes" xml:space="preserve">
          <source>Config: modulePathIgnorePatterns</source>
          <target state="translated">구성 : modulePathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="c8dfc9221f178a7e9e50e483363057b29737331d" translate="yes" xml:space="preserve">
          <source>Config: modulePaths</source>
          <target state="translated">구성 : modulePaths</target>
        </trans-unit>
        <trans-unit id="443a851b039bcd2776957b32886e287fea1ec06b" translate="yes" xml:space="preserve">
          <source>Config: notify</source>
          <target state="translated">구성 : 알림</target>
        </trans-unit>
        <trans-unit id="17139aeb93d058b72a2aa76ec6bb221cf0bef770" translate="yes" xml:space="preserve">
          <source>Config: notifyMode</source>
          <target state="translated">구성 : notifyMode</target>
        </trans-unit>
        <trans-unit id="3caeb9058b4e79e45f4cf9706757269977d12773" translate="yes" xml:space="preserve">
          <source>Config: preset</source>
          <target state="translated">구성 : 사전 설정</target>
        </trans-unit>
        <trans-unit id="ba5eee9d73aa692050786b2b5d012b9c6430da5f" translate="yes" xml:space="preserve">
          <source>Config: prettierPath</source>
          <target state="translated">구성 : prettierPath</target>
        </trans-unit>
        <trans-unit id="de718240490d094a4aca3e67beb56ce24d859f0e" translate="yes" xml:space="preserve">
          <source>Config: projects</source>
          <target state="translated">구성 : 프로젝트</target>
        </trans-unit>
        <trans-unit id="a12a5c71edd2c879af4190d0ca91fb1c41ed4691" translate="yes" xml:space="preserve">
          <source>Config: reporters</source>
          <target state="translated">구성 : 기자</target>
        </trans-unit>
        <trans-unit id="05d3f1dda15c90c8537c0ebaae99cc9b6dab6d2c" translate="yes" xml:space="preserve">
          <source>Config: resetMocks</source>
          <target state="translated">구성 : resetMocks</target>
        </trans-unit>
        <trans-unit id="00ce92b9cce0a2fc0cfaa6bdc87fca0a67673a92" translate="yes" xml:space="preserve">
          <source>Config: resetModules</source>
          <target state="translated">구성 : resetModules</target>
        </trans-unit>
        <trans-unit id="7e342a2f1f10e2ce5223aeb58621bcfcaee80280" translate="yes" xml:space="preserve">
          <source>Config: resolver</source>
          <target state="translated">구성 : 리졸버</target>
        </trans-unit>
        <trans-unit id="4d0db5ef6ee172dca67b2ec98bd9764765247d45" translate="yes" xml:space="preserve">
          <source>Config: restoreMocks</source>
          <target state="translated">구성 : restoreMocks</target>
        </trans-unit>
        <trans-unit id="dbda260933b77348b0de3d059fb6eaafcfe9ed04" translate="yes" xml:space="preserve">
          <source>Config: rootDir</source>
          <target state="translated">구성 : rootDir</target>
        </trans-unit>
        <trans-unit id="a486beac88a05f5107d2963397c9a097a8b9c53d" translate="yes" xml:space="preserve">
          <source>Config: roots</source>
          <target state="translated">구성 : 루트</target>
        </trans-unit>
        <trans-unit id="15087b6a38a2044fac1d8bca8ed5b732e85be8e9" translate="yes" xml:space="preserve">
          <source>Config: runner</source>
          <target state="translated">구성 : 러너</target>
        </trans-unit>
        <trans-unit id="69d7cd6c10e8ee3f4e5933ab036c264a961a3c6f" translate="yes" xml:space="preserve">
          <source>Config: setupFiles</source>
          <target state="translated">구성 : setupFiles</target>
        </trans-unit>
        <trans-unit id="2b099bf0ed7f0b70b104f43a494c8a3601d6db3b" translate="yes" xml:space="preserve">
          <source>Config: setupFilesAfterEnv</source>
          <target state="translated">구성 : setupFilesAfterEnv</target>
        </trans-unit>
        <trans-unit id="39fceff3400dd04baa7d8cf445ca60d91c4b565d" translate="yes" xml:space="preserve">
          <source>Config: snapshotResolver</source>
          <target state="translated">구성 : snapshotResolver</target>
        </trans-unit>
        <trans-unit id="926aa02967cb62919ed24d142e8ab790e7e88f40" translate="yes" xml:space="preserve">
          <source>Config: snapshotSerializers</source>
          <target state="translated">구성 : snapshotSerializers</target>
        </trans-unit>
        <trans-unit id="2719c66aea5faa9e87f1dada70059a3cfbc1c722" translate="yes" xml:space="preserve">
          <source>Config: testEnvironment</source>
          <target state="translated">구성 : testEnvironment</target>
        </trans-unit>
        <trans-unit id="85e3d1362b32367666c7ee4106cc8a8c49ef9c56" translate="yes" xml:space="preserve">
          <source>Config: testEnvironmentOptions</source>
          <target state="translated">구성 : testEnvironmentOptions</target>
        </trans-unit>
        <trans-unit id="a067ac9bbff1c40f63b3c4571746aeb1f2c51ef3" translate="yes" xml:space="preserve">
          <source>Config: testMatch</source>
          <target state="translated">구성 : testMatch</target>
        </trans-unit>
        <trans-unit id="6b64c3b85bea8af5d02fcd06f985923761f20605" translate="yes" xml:space="preserve">
          <source>Config: testPathIgnorePatterns</source>
          <target state="translated">구성 : testPathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="1b4324c80d83474910e2f7ba12475a97f71b780b" translate="yes" xml:space="preserve">
          <source>Config: testRegex</source>
          <target state="translated">구성 : testRegex</target>
        </trans-unit>
        <trans-unit id="f3b1317ed93a2645076cae324fc69ab7bd2043de" translate="yes" xml:space="preserve">
          <source>Config: testResultsProcessor</source>
          <target state="translated">구성 : testResultsProcessor</target>
        </trans-unit>
        <trans-unit id="ebce535e49ba2d6e77c3ace6f1d4b4d227eb1005" translate="yes" xml:space="preserve">
          <source>Config: testRunner</source>
          <target state="translated">구성 : testRunner</target>
        </trans-unit>
        <trans-unit id="14f361d3abf65818229de4fd0fd2b800c7132faa" translate="yes" xml:space="preserve">
          <source>Config: testSequencer</source>
          <target state="translated">구성 : testSequencer</target>
        </trans-unit>
        <trans-unit id="a9dcaf483df4a5ad04db7728ded6a4a42efa7cc9" translate="yes" xml:space="preserve">
          <source>Config: testURL</source>
          <target state="translated">구성 : testURL</target>
        </trans-unit>
        <trans-unit id="d6decdd2c51010466998366161fed9615c71ed2e" translate="yes" xml:space="preserve">
          <source>Config: timers</source>
          <target state="translated">구성 : 타이머</target>
        </trans-unit>
        <trans-unit id="710dedba7705ede1b50331e3f82d3159bd25781c" translate="yes" xml:space="preserve">
          <source>Config: transform</source>
          <target state="translated">구성 : 변환</target>
        </trans-unit>
        <trans-unit id="567cb22f9c7af2b996f4d744bf2d3e97d8f52294" translate="yes" xml:space="preserve">
          <source>Config: transformIgnorePatterns</source>
          <target state="translated">구성 : transformIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="7c7d6430c4ac8b493a953f1b57daa83c4cf0b4fc" translate="yes" xml:space="preserve">
          <source>Config: unmockedModulePathPatterns</source>
          <target state="translated">구성 : unmockedModulePathPatterns</target>
        </trans-unit>
        <trans-unit id="1a9f98c1a91d2c94b70a6840de75ff48ff87cde9" translate="yes" xml:space="preserve">
          <source>Config: verbose</source>
          <target state="translated">구성 : 상세</target>
        </trans-unit>
        <trans-unit id="cc12f6eb1650abf575ed9f60726c3d8f9776c168" translate="yes" xml:space="preserve">
          <source>Config: watchPathIgnorePatterns</source>
          <target state="translated">구성 : watchPathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="6264b4990f0b105e5e1586412f25673503f78b81" translate="yes" xml:space="preserve">
          <source>Config: watchPlugins</source>
          <target state="translated">구성 : watchPlugins</target>
        </trans-unit>
        <trans-unit id="d0540e863b75a1e450632fdfba93847f16e57dfe" translate="yes" xml:space="preserve">
          <source>Configure Babel to target your current version of Node by creating a &lt;code&gt;babel.config.js&lt;/code&gt; file in the root of your project:</source>
          <target state="translated">프로젝트 루트에 &lt;code&gt;babel.config.js&lt;/code&gt; 파일 을 작성하여 현재 버전의 Node를 대상으로 Babel을 구성 하십시오.</target>
        </trans-unit>
        <trans-unit id="732bdf3d9ce078bf71b612048a4595a4eb70bdff" translate="yes" xml:space="preserve">
          <source>Configure DynamoDB client</source>
          <target state="translated">DynamoDB 클라이언트 구성</target>
        </trans-unit>
        <trans-unit id="aa8f1ca94d78bf9bcf623acecc179502fe36fdf4" translate="yes" xml:space="preserve">
          <source>Configuring Jest</source>
          <target state="translated">Jest 구성</target>
        </trans-unit>
        <trans-unit id="d69b5f49a85c3bbccb1893393cd0decc9db7f396" translate="yes" xml:space="preserve">
          <source>Configuring Jest to find our files</source>
          <target state="translated">파일을 찾도록 Jest 구성</target>
        </trans-unit>
        <trans-unit id="f73284b346579e5b9427a96d62cdd35e3340d4d0" translate="yes" xml:space="preserve">
          <source>Consider the following illustrative test file and output:</source>
          <target state="translated">다음 예시 테스트 파일 및 출력을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="195e9ca7f58f10ad0afe5f1b4587aa7d074cc2bd" translate="yes" xml:space="preserve">
          <source>Consider writing a test case for this &lt;code&gt;createUser&lt;/code&gt; function:</source>
          <target state="translated">이 &lt;code&gt;createUser&lt;/code&gt; 함수에 대한 테스트 케이스 작성을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f7c7b509517031ce2942935f6e6675726c02dcb" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;jest-dynamodb-config.js&lt;/code&gt; and define DynamoDB tables</source>
          <target state="translated">&lt;code&gt;jest-dynamodb-config.js&lt;/code&gt; 생성 및 DynamoDB 테이블 정의</target>
        </trans-unit>
        <trans-unit id="f072285a90744179b098528df836611fec0f6e77" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; by saving a mock implementation in the &lt;code&gt;__mocks__&lt;/code&gt; folder. This allows you to specify the implementation, and it can be used across test files.</source>
          <target state="translated">&lt;code&gt;__mocks__&lt;/code&gt; 폴더 에 모의 구현을 저장 하여 &lt;a href=&quot;manual-mocks&quot;&gt;수동 모의&lt;/a&gt; 를 작성하십시오 . 이를 통해 구현을 지정할 수 있으며 테스트 파일에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7576c0fd5d12ef5fcd87f993a9d142bd20852f" translate="yes" xml:space="preserve">
          <source>Creates a mock function similar to &lt;code&gt;jest.fn&lt;/code&gt; but also tracks calls to &lt;code&gt;object[methodName]&lt;/code&gt;. Returns a Jest mock function.</source>
          <target state="translated">&lt;code&gt;jest.fn&lt;/code&gt; 과 유사한 모의 함수를 작성 하지만 &lt;code&gt;object[methodName]&lt;/code&gt; 호출도 추적합니다 . Jest 모의 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6af3b0b9c2d9efcee182c5badbf215b13de90d9" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;a href=&quot;mock-functions&quot;&gt;mock function&lt;/a&gt;. The new function has no formal parameters and when called will return &lt;code&gt;undefined&lt;/code&gt;. This functionality also applies to &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="translated">새로운 &lt;a href=&quot;mock-functions&quot;&gt;모의 함수를&lt;/a&gt; 만듭니다 . 새 함수에는 공식 매개 변수가 없으며 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다. 이 기능은 &lt;code&gt;async&lt;/code&gt; 기능에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff88930a91ab80f14f3aebb7fde98a563da17ce4" translate="yes" xml:space="preserve">
          <source>Creates a new deeply cloned object. The object keys are maintained and their values are mocked.</source>
          <target state="translated">완전히 복제 된 객체를 새로 만듭니다. 객체 키가 유지되고 해당 값이 조롱됩니다.</target>
        </trans-unit>
        <trans-unit id="499339901a2a6910de0fa6f2ee66c02b0aa8ec88" translate="yes" xml:space="preserve">
          <source>Creates a new empty array, ignoring the original.</source>
          <target state="translated">원본을 무시하고 빈 배열을 새로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a5763b0dca9136215f4c1bd25d66fda4d413f5fa" translate="yes" xml:space="preserve">
          <source>Creates a new property with the same primitive value as the original property.</source>
          <target state="translated">원래 속성과 동일한 기본 값을 사용하여 새 속성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14a2d117a3682ce4e9ee56f51a4dddf39a8c9887" translate="yes" xml:space="preserve">
          <source>Creates new class. The interface of the original class is maintained, all of the class member functions and properties will be mocked.</source>
          <target state="translated">새로운 수업을 만듭니다. 원래 클래스의 인터페이스가 유지되고 모든 클래스 멤버 함수 및 속성이 조롱됩니다.</target>
        </trans-unit>
        <trans-unit id="c51941f39ba45e54075e0925fb6911178a577498" translate="yes" xml:space="preserve">
          <source>Custom Matchers</source>
          <target state="translated">커스텀 매처</target>
        </trans-unit>
        <trans-unit id="54f825aa31c7f89df216a075a2e0407f6b8d69f3" translate="yes" xml:space="preserve">
          <source>Custom Matchers API</source>
          <target state="translated">커스텀 매처 API</target>
        </trans-unit>
        <trans-unit id="119759fa773122549b207e8a3a246d10ce0d12df" translate="yes" xml:space="preserve">
          <source>Custom example without jest-puppeteer preset</source>
          <target state="translated">농담 인형 사전 설정이없는 사용자 정의 예</target>
        </trans-unit>
        <trans-unit id="d21fbbb8afbf0a16c827d47836dcb1856cc7708e" translate="yes" xml:space="preserve">
          <source>Custom reporter modules must define a class that takes a &lt;code&gt;GlobalConfig&lt;/code&gt; and reporter options as constructor arguments:</source>
          <target state="translated">사용자 정의 리포터 모듈은 &lt;code&gt;GlobalConfig&lt;/code&gt; 및 리포터 옵션을 생성자 인수로 사용하는 클래스를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="714a39b633fc18946fa5b07fb026f29bf56da631" translate="yes" xml:space="preserve">
          <source>Custom reporters can also force Jest to exit with non-0 code by returning an Error from &lt;code&gt;getLastError()&lt;/code&gt; methods</source>
          <target state="translated">사용자 지정 기자는 &lt;code&gt;getLastError()&lt;/code&gt; 메소드 에서 Error를 반환하여 Jest가 0이 아닌 코드로 종료되도록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59764a788a550e0bcc7c2f3f06d2271ee9028a6a" translate="yes" xml:space="preserve">
          <source>Custom snapshot matchers</source>
          <target state="translated">맞춤 스냅 샷 매처</target>
        </trans-unit>
        <trans-unit id="efb96a7111f5d3ea6a3fe4177d7f8a2f59a345b0" translate="yes" xml:space="preserve">
          <source>Custom transformers</source>
          <target state="translated">맞춤형 변압기</target>
        </trans-unit>
        <trans-unit id="796036624d60e8855428745a98834ec3d84c8f41" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can add hooks to Jest events. These hooks can be added either with or without having an interactive key in the watch mode menu.</source>
          <target state="translated">사용자 정의 시계 플러그인은 Jest 이벤트에 후크를 추가 할 수 있습니다. 이 후크는 시계 모드 메뉴에서 대화식 키를 사용하거나 사용하지 않고 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="215e1af622d5b72a6cc168c70f4702a398bb2716" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can also add or override functionality to the watch menu by specifying a key/prompt pair in &lt;code&gt;getUsageInfo&lt;/code&gt; method and a &lt;code&gt;run&lt;/code&gt; method for the execution of the key.</source>
          <target state="translated">사용자 정의 시계 플러그인은 &lt;code&gt;getUsageInfo&lt;/code&gt; 메소드 에서 키 / 프롬프트 쌍 과 키 실행을위한 &lt;code&gt;run&lt;/code&gt; 메소드를 지정하여 시계 메뉴에 기능을 추가하거나 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="translated">DOM 조작</target>
        </trans-unit>
        <trans-unit id="7d47c567751d80a763336c3531e448b81a834be1" translate="yes" xml:space="preserve">
          <source>DOM Testing</source>
          <target state="translated">DOM 테스트</target>
        </trans-unit>
        <trans-unit id="47d19ef23ccb3630dfbdcf2345caac51860dc04a" translate="yes" xml:space="preserve">
          <source>Debugging in VS Code</source>
          <target state="translated">VS 코드에서 디버깅</target>
        </trans-unit>
        <trans-unit id="97b21e655f77156f74590b9394f284ad276659df" translate="yes" xml:space="preserve">
          <source>Debugging in WebStorm</source>
          <target state="translated">WebStorm에서 디버깅</target>
        </trans-unit>
        <trans-unit id="df8d2a884ab0f628a1f7f94392af6e76fa7a2fc7" translate="yes" xml:space="preserve">
          <source>Default timeout of a test in milliseconds. Default value: 5000.</source>
          <target state="translated">테스트의 기본 시간 초과 (밀리 초) 기본값 : 5000</target>
        </trans-unit>
        <trans-unit id="ec5aab0a956d1bf4178fda692ccbf9f96c049d2f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;/tmp/&amp;lt;path&amp;gt;&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;/tmp/&amp;lt;path&amp;gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92bb4405a1bd1698f8e13de63202bbb029fb7e5b" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jest-runner&quot;&lt;/code&gt;</source>
          <target state="translated">기본 : &lt;code&gt;&quot;jest-runner&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47384bd44c204995dd251a440e0f2874c419f943" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jsdom&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;jsdom&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="819cc760e16ea72f302b36952c68bdc74e37fbc0" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'prettier'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'prettier'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2e64757bbec7711d7708d7a5ad878780438205" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3569cdb24d4e3738060acfc3ad2efff4bb497560" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c3230c6cb67eb67fb80df55aa548813d92e446d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;5&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07d90156b27c53ecc56aef155a22882f9031bbda" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;@jest/test-sequencer&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;@jest/test-sequencer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ec10196844ffb76ab5d5c304aacc13ac2e3cef9" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;&quot;]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc5e027fc76915df0b4b1aa4ee05ea7cf2a7e108" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;/node_modules/&quot;]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[&quot;/node_modules/&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90a0fee6fa4afd6073a2bb2c2c33627e5932f689" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;, &quot;node&quot;]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;, &quot;node&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96347c64af1e884636cd5cac216f125cf26bfaac" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;, &quot;clover&quot;]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;, &quot;clover&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52bfa7d4e9de2ac8aff5837eee8067bcdd2d8d03" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;node_modules&quot;]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[&quot;node_modules&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d48cfe315fd247262c98a909a60e72fe1adb7bd" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;['']&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;['']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ffa1281e650e63433a7c2437e7f3068376e6c83" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b2f403a7a8a0196ba2b1e131b436bad9608f06" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;failure-change&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;failure-change&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="614188609a5c964071cad1f8bd6a9a468d7e820f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32578e58095a4c9dc16bbe18810864be9eb55e61" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;http://localhost&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;http://localhost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb7e8f5d26d527a1551f7fbe8540cdd2756856f1" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;jasmine2&lt;/code&gt;</source>
          <target state="translated">기본 : &lt;code&gt;jasmine2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72af77c264a4ee8b4a40880a27db11fcd236d73d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e59e0f6f5986d77c33cddbccdfb1f46b1dcfe17a" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;real&lt;/code&gt;</source>
          <target state="translated">기본 : &lt;code&gt;real&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="440b4c5aa1e906e434fd52447e734719e939c93d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7da6b7c92470df3b7f4b4cef35bf9321c6095a8" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5a66f14241f019bfa4af9e9837d93ce753bdfcf" translate="yes" xml:space="preserve">
          <source>Default: The root of the directory containing your Jest config file&lt;em&gt;or&lt;/em&gt; the &lt;code&gt;package.json&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt; if no &lt;code&gt;package.json&lt;/code&gt; is found</source>
          <target state="translated">기본 : 당신의 농담 설정 파일이 들어있는 디렉토리의 루트 &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;package.json&lt;/code&gt; &lt;em&gt;또는 &lt;/em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pwd&quot;&gt; &lt;code&gt;pwd&lt;/code&gt; &lt;/a&gt; 어떤 경우 &lt;code&gt;package.json&lt;/code&gt; 가 발견되지</target>
        </trans-unit>
        <trans-unit id="428819bf9e83cebda50efafb08cd2534c1583949" translate="yes" xml:space="preserve">
          <source>Defaults</source>
          <target state="translated">Defaults</target>
        </trans-unit>
        <trans-unit id="708e979a86993e441e280091f83d90e49fb6e0fb" translate="yes" xml:space="preserve">
          <source>Defining Tests</source>
          <target state="translated">테스트 정의</target>
        </trans-unit>
        <trans-unit id="8fa37ce3402b9fdda8c547faa8f8a629231c38fc" translate="yes" xml:space="preserve">
          <source>Deletes the Jest cache directory and then exits without running tests. Will delete &lt;code&gt;cacheDirectory&lt;/code&gt; if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling &lt;code&gt;jest --showConfig&lt;/code&gt;. &lt;em&gt;Note: clearing the cache will reduce performance.&lt;/em&gt;</source>
          <target state="translated">Jest 캐시 디렉토리를 삭제 한 다음 테스트를 실행하지 않고 종료합니다. 삭제 &lt;code&gt;cacheDirectory&lt;/code&gt; 옵션이 통과, 또는 농담의 기본 캐시 디렉토리됩니다. 기본 캐시 디렉토리는 &lt;code&gt;jest --showConfig&lt;/code&gt; 를 호출하여 찾을 수 있습니다 . &lt;em&gt;참고 : 캐시를 지우면 성능이 저하됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d9c3f11c071444f893ad63c8b10640d8dec604b" translate="yes" xml:space="preserve">
          <source>Determines if the given function is a mocked function.</source>
          <target state="translated">주어진 함수가 모의 함수인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="25fde793067d8261eed4bccfb3fd238dad8d6983" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;.toEqual&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.toEqual&lt;/code&gt; 과의 차이점 :</target>
        </trans-unit>
        <trans-unit id="cc8abd105b53147a8d0383ba5b505ee49226316a" translate="yes" xml:space="preserve">
          <source>Disable warnings all together (should be done in your jest setup file):</source>
          <target state="translated">경고를 함께 비활성화하십시오 (jest 설정 파일에서 수행해야 함).</target>
        </trans-unit>
        <trans-unit id="ae71b8a8ed202bbaa7e42b1a5bdeb06c2525518d" translate="yes" xml:space="preserve">
          <source>Disables automatic mocking in the module loader.</source>
          <target state="translated">모듈 로더에서 자동 조롱을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="55e34bb12f80749a80b5838e96b2c150faa45ac0" translate="yes" xml:space="preserve">
          <source>Disables stack trace in test results output.</source>
          <target state="translated">테스트 결과 출력에서 ​​스택 추적을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1e98b783a42cdc4f4a03ffd64649c5f26f6c011b" translate="yes" xml:space="preserve">
          <source>Display individual test results with the test suite hierarchy.</source>
          <target state="translated">테스트 스위트 계층으로 개별 테스트 결과를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d8f3f815fbd922415c3aa6adb4aa4e59a5e04a90" translate="yes" xml:space="preserve">
          <source>Divert all output to stderr.</source>
          <target state="translated">모든 출력을 stderr로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="aaf393e4923d7954d9bc2a84e51b45079ca53939" translate="yes" xml:space="preserve">
          <source>Does code coverage work with snapshot testing?</source>
          <target state="translated">코드 적용 범위는 스냅 샷 테스트와 함께 작동합니까?</target>
        </trans-unit>
        <trans-unit id="94fbd6d73ceaf62001f4cf5b3fc9c82f322ebedc" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockclear&quot;&gt;&lt;code&gt;mockFn.mockClear()&lt;/code&gt;&lt;/a&gt; does, and also removes any mocked return values or implementations.</source>
          <target state="translated">&lt;a href=&quot;#mockfnmockclear&quot;&gt; &lt;code&gt;mockFn.mockClear()&lt;/code&gt; &lt;/a&gt; 가 수행하는 모든 작업을 수행하고 모의 반환 값 또는 구현을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7789e80d5d03d9a660831975a1ab1fb586436891" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockreset&quot;&gt;&lt;code&gt;mockFn.mockReset()&lt;/code&gt;&lt;/a&gt; does, and also restores the original (non-mocked) implementation.</source>
          <target state="translated">&lt;a href=&quot;#mockfnmockreset&quot;&gt; &lt;code&gt;mockFn.mockReset()&lt;/code&gt; &lt;/a&gt; 이 수행하는 모든 작업을 수행 하고 원본 (비 조롱) 구현을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d8613a53b523abbac39b8070515f3ee0abf3b4d2" translate="yes" xml:space="preserve">
          <source>Does snapshot testing only work with React components?</source>
          <target state="translated">스냅 샷 테스트는 React 구성 요소에서만 작동합니까?</target>
        </trans-unit>
        <trans-unit id="6bef91ef2504e85917d6489193a8b3d0184f65a1" translate="yes" xml:space="preserve">
          <source>Does snapshot testing replace unit testing?</source>
          <target state="translated">스냅 샷 테스트가 단위 테스트를 대체합니까?</target>
        </trans-unit>
        <trans-unit id="7c3003258c19842b6d44deed813b6a58f22ceeab" translate="yes" xml:space="preserve">
          <source>Don't forget to install the &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;babel-preset-jest&lt;/code&gt; packages for this example to work.</source>
          <target state="translated">이 예제가 작동 하려면 &lt;code&gt;@babel/core&lt;/code&gt; 및 &lt;code&gt;babel-preset-jest&lt;/code&gt; 패키지 를 설치하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b50dcc8f4ef764e131e9874eeed3d12dbbb7ac84" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;.toBe&lt;/code&gt; with floating-point numbers. For example, due to rounding, in JavaScript &lt;code&gt;0.2 + 0.1&lt;/code&gt; is not strictly equal to &lt;code&gt;0.3&lt;/code&gt;. If you have floating point numbers, try &lt;code&gt;.toBeCloseTo&lt;/code&gt; instead.</source>
          <target state="translated">부동 소수점 숫자와 함께 &lt;code&gt;.toBe&lt;/code&gt; 를 사용하지 마십시오 . 예를 들어, 반올림으로 인해 JavaScript &lt;code&gt;0.2 + 0.1&lt;/code&gt; 은 엄격하게 &lt;code&gt;0.3&lt;/code&gt; 과 같지 않습니다 . 부동 소수점 숫자가 &lt;code&gt;.toBeCloseTo&lt;/code&gt; 대신 .toBeCloseTo 를 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="846c9004ef1bbb7bfccc704a3c8972b52308d069" translate="yes" xml:space="preserve">
          <source>ES6 Class Mocks</source>
          <target state="translated">ES6 학급</target>
        </trans-unit>
        <trans-unit id="c2e2d49f8d0560f741ac8577a93b663178bd7029" translate="yes" xml:space="preserve">
          <source>ES6 classes are constructor functions with some syntactic sugar. Therefore, any mock for an ES6 class must be a function or an actual ES6 class (which is, again, another function). So you can mock them using &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt;.</source>
          <target state="translated">ES6 클래스는 일부 구문 설탕을 가진 생성자 함수입니다. 따라서 ES6 클래스의 모의는 함수 또는 실제 ES6 클래스 (다시 함수) 여야합니다. 따라서 &lt;a href=&quot;mock-functions&quot;&gt;mock 함수를&lt;/a&gt; 사용하여 그것들을 조롱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a979ca27d4f6a8704957153c1cfba9c7ff2928a" translate="yes" xml:space="preserve">
          <source>Enables automatic mocking in the module loader.</source>
          <target state="translated">모듈 로더에서 자동 조롱을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a54bd6397692c956d8a24ca7382912f74c27ec19" translate="yes" xml:space="preserve">
          <source>Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.</source>
          <target state="translated">스냅 샷의 초점을 짧고 짧게 유지하고 이러한 스타일 규칙을 적용하는 도구를 사용하여 스냅 샷을 읽을 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6c6165137242ac2de05a56584d9eb719723b240e" translate="yes" xml:space="preserve">
          <source>Ensures that a value matches the most recent snapshot.</source>
          <target state="translated">값이 가장 최근 스냅 샷과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="9d818071488cd0fd15915face926b0ea26228d9d" translate="yes" xml:space="preserve">
          <source>Enzyme</source>
          <target state="translated">Enzyme</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="6e250d15915a7dec07d85e3c69b7afec141c65b4" translate="yes" xml:space="preserve">
          <source>Errors can be handled using the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test:</source>
          <target state="translated">&lt;code&gt;.catch&lt;/code&gt; 메소드를 사용하여 오류를 처리 할 수 ​​있습니다 . 특정 수의 어설 션이 호출되는지 확인하려면 &lt;code&gt;expect.assertions&lt;/code&gt; 를 추가하십시오 . 그렇지 않으면 이행 된 약속은 테스트에 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbc0f94d2d9aec32c6363119390d09ce3e2d82c5" translate="yes" xml:space="preserve">
          <source>Even though the call to &lt;code&gt;test&lt;/code&gt; will return right away, the test doesn't complete until the promise resolves as well.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 요청이 즉시 반환 되더라도 약속이 해결 될 때까지 테스트가 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="181adc1fd91d7f613b0b29c21d874c50ec7c2a70" translate="yes" xml:space="preserve">
          <source>Every remaining file combined has less than 50% coverage (&lt;code&gt;global&lt;/code&gt;).</source>
          <target state="translated">결합 된 모든 파일의 범위는 50 % 미만입니다 ( &lt;code&gt;global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cb707350932674779ac756d02c39f235519b003b" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;jest.setup.js&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;jest.setup.js&lt;/code&gt; 파일 예</target>
        </trans-unit>
        <trans-unit id="aaf7849f7d6f11a7ab97ade4dda544885008f4d9" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; array in a jest.config.js:</source>
          <target state="translated">&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; 배열 예 :</target>
        </trans-unit>
        <trans-unit id="edbaf433fef36ac3533442306ff42b392e258bb9" translate="yes" xml:space="preserve">
          <source>Example in a test:</source>
          <target state="translated">테스트의 예 :</target>
        </trans-unit>
        <trans-unit id="3724b80ab87b149dfc415f2947aa5d33aebb6cf1" translate="yes" xml:space="preserve">
          <source>Example reporter:</source>
          <target state="translated">기자 예 :</target>
        </trans-unit>
        <trans-unit id="2dc6113b2c0f485941bfab51b94f31a114ec2df2" translate="yes" xml:space="preserve">
          <source>Example serializer module:</source>
          <target state="translated">시리얼 라이저 모듈 예 :</target>
        </trans-unit>
        <trans-unit id="d9c6a3e7251096dba7461d173198c7d8db714d67" translate="yes" xml:space="preserve">
          <source>Example snapshot resolver module:</source>
          <target state="translated">스냅 샷 해결 모듈 예 :</target>
        </trans-unit>
        <trans-unit id="07f064f0c6b85d5dffb3101177b89f9992c1c9c7" translate="yes" xml:space="preserve">
          <source>Example test:</source>
          <target state="translated">테스트 예 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="e7ff0674cdf6ffae58fcf1d17cf527103ca0f99c" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/bower_components/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/bower_components/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="be81be2dc796bfe648c0ffaec826677af8dbaae5" translate="yes" xml:space="preserve">
          <source>Examples of dependencies that might be considered &quot;implementation details&quot; are things ranging from language built-ins (e.g. Array.prototype methods) to highly common utility methods (e.g. underscore/lo-dash, array utilities etc) and entire libraries like React.js.</source>
          <target state="translated">&quot;구현 세부 사항&quot;으로 간주 될 수있는 종속성의 예는 언어 내장 (예 : Array.prototype 메서드)에서 매우 일반적인 유틸리티 메서드 (예 : 밑줄 / lo-dash, 배열 유틸리티 등) 및 React.js와 같은 전체 라이브러리에 이르는 것들입니다. .</target>
        </trans-unit>
        <trans-unit id="8555073aa38480ab4d24bc6e10b3c3a6d435c74a" translate="yes" xml:space="preserve">
          <source>Examples of such compilers include:</source>
          <target state="translated">이러한 컴파일러의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="416308f6796b161308eac10d19357bbbc2a72314" translate="yes" xml:space="preserve">
          <source>Examples of watch plugins include:</source>
          <target state="translated">시계 플러그인의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="1313d360bb16a7b6138236da32b21f4e7ed7a7ba" translate="yes" xml:space="preserve">
          <source>Executes only the macro task queue (i.e. all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; and &lt;code&gt;setImmediate()&lt;/code&gt;).</source>
          <target state="translated">매크로 작업 대기열 만 실행합니다 (예 : &lt;code&gt;setTimeout()&lt;/code&gt; 또는 &lt;code&gt;setInterval()&lt;/code&gt; 및 &lt;code&gt;setImmediate()&lt;/code&gt; 의해 대기중인 모든 작업 ).</target>
        </trans-unit>
        <trans-unit id="3eb459b18680d2e43398c41cf444b3d8402f2523" translate="yes" xml:space="preserve">
          <source>Executes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; up to this point). If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call.</source>
          <target state="translated">현재 보류중인 매크로 작업 만 실행합니다 (즉, 현재까지 &lt;code&gt;setTimeout()&lt;/code&gt; 또는 &lt;code&gt;setInterval()&lt;/code&gt; 의해 대기 된 작업 만 ). 현재 보류중인 매크로 작업 중 하나라도 새 매크로 작업을 예약하면이 호출로 해당 새 작업이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c4f4acc11d792baa1caf501e7e5f8ba241c5044" translate="yes" xml:space="preserve">
          <source>Exhausts all tasks queued by &lt;code&gt;setImmediate()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setImmediate()&lt;/code&gt; 의해 대기중인 모든 작업을 소진 합니다.</target>
        </trans-unit>
        <trans-unit id="c4db7db82b90f39ee739e36a7b63a98bed58ed23" translate="yes" xml:space="preserve">
          <source>Exhausts both the &lt;strong&gt;macro&lt;/strong&gt;-task queue (i.e., all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setInterval()&lt;/code&gt;, and &lt;code&gt;setImmediate()&lt;/code&gt;) and the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="translated">배기 가스 모두 &lt;strong&gt;매크로&lt;/strong&gt; -task 큐 (즉, 모든에 의해 대기 작업 &lt;code&gt;setTimeout()&lt;/code&gt; , &lt;code&gt;setInterval()&lt;/code&gt; , 및 &lt;code&gt;setImmediate()&lt;/code&gt; )와 &lt;strong&gt;마이크로&lt;/strong&gt; -task 큐 (일반적으로 통해 노드 인터페이스 &lt;code&gt;process.nextTick&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f8147ef3f4371ae39d61271bddec0259649620d" translate="yes" xml:space="preserve">
          <source>Exhausts the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="translated">배기 &lt;strong&gt;마이크로&lt;/strong&gt; -task 큐 (일반적으로 인터페이스를 통해 노드 &lt;code&gt;process.nextTick&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="5ace91ad2cbf9bda63ef9585bd51f774c05c729c" translate="yes" xml:space="preserve">
          <source>Explicitly supplies the mock object that the module system should return for the specified module.</source>
          <target state="translated">모듈 시스템이 지정된 모듈에 대해 반환해야하는 모의 객체를 명시 적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bad5808b4c7ea92e7c146eae0b94df7ca7d7179a" translate="yes" xml:space="preserve">
          <source>Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.</source>
          <target state="translated">JavaScript 값을 사람이 읽을 수있는 문자열로 변환하는 함수를 내 보냅니다. 기본 제공되는 모든 내장 JavaScript 유형을 지원하고 사용자 정의 플러그인을 통해 애플리케이션 별 유형을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa5941d8206e78d8b9ca13243802ebceaeaed32" translate="yes" xml:space="preserve">
          <source>Express.js</source>
          <target state="translated">Express.js</target>
        </trans-unit>
        <trans-unit id="c7794e96c54b2b405e2be63ffda3e89b9afeb2a1" translate="yes" xml:space="preserve">
          <source>Failed snapshots can also be updated interactively in watch mode:</source>
          <target state="translated">실패한 스냅 샷은 시계 모드에서 대화식으로 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e41c8da6c1bdd48b470d7efc6bf68d044e506f33" translate="yes" xml:space="preserve">
          <source>Finally tests would look as follows:</source>
          <target state="translated">마지막으로 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04d6a7dc26ea6d1316b486419821aae0420ac220" translate="yes" xml:space="preserve">
          <source>Finally we can close the puppeteer instance and clean-up the file</source>
          <target state="translated">마지막으로 꼭두각시 인스턴스를 닫고 파일을 정리할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="97e7714725872b9c1984e5322d6f02dd30da60a2" translate="yes" xml:space="preserve">
          <source>Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:</source>
          <target state="translated">마지막으로, 모의 함수가 어떻게 호출되었는지를 덜 요구하기 위해 몇 가지 사용자 정의 매처 함수를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="83ea460e76f8e03e89080e3127909c8138d82a71" translate="yes" xml:space="preserve">
          <source>Finally, run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;npm run test&lt;/code&gt; and Jest will print this message:</source>
          <target state="translated">마지막으로 &lt;code&gt;yarn test&lt;/code&gt; 또는 &lt;code&gt;npm run test&lt;/code&gt; 하면 Jest가 다음 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bf4e9242ce7c9aedcbc07728e61f3c9ca615c3c8" translate="yes" xml:space="preserve">
          <source>Finally, set &lt;code&gt;jest.config.js&lt;/code&gt; to read from these files. (The &lt;code&gt;jest-puppeteer&lt;/code&gt; preset does something like this under the hood.)</source>
          <target state="translated">마지막으로, &lt;code&gt;jest.config.js&lt;/code&gt; 가이 파일에서 읽도록 설정 하십시오. ( &lt;code&gt;jest-puppeteer&lt;/code&gt; 프리셋은 후드 아래에서 이와 같은 작업을 수행합니다.)</target>
        </trans-unit>
        <trans-unit id="5ab0f38c4058b80ab0f4c885e3986fc16770c677" translate="yes" xml:space="preserve">
          <source>Finally, we need an environment which supports dynamic importing. Please see &lt;a href=&quot;getting-started#using-babel&quot;&gt;Using Babel&lt;/a&gt; for the initial setup. Then add the plugin &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-dynamic-import-node&quot;&gt;babel-plugin-dynamic-import-node&lt;/a&gt;, or an equivalent, to your Babel config to enable dynamic importing in Node.</source>
          <target state="translated">마지막으로 동적 가져 오기를 지원하는 환경이 필요합니다. 초기 설정은 &lt;a href=&quot;getting-started#using-babel&quot;&gt;Babel 사용을&lt;/a&gt; 참조하십시오 . 그런 다음 플러그인 &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-dynamic-import-node&quot;&gt;babel-plugin-dynamic-import-node&lt;/a&gt; 또는 이와 동등한 플러그인 을 Babel 구성에 추가하여 노드에서 동적 가져 오기를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="7c40bfe3ca4ca3e6970c1ba2f427bc5cf0ac97e5" translate="yes" xml:space="preserve">
          <source>Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with &lt;code&gt;--coverage&lt;/code&gt; to include a test coverage for the source files, no duplicate &lt;code&gt;--collectCoverageFrom&lt;/code&gt; arguments needed.</source>
          <target state="translated">공백으로 구분 된 소스 파일 목록을 인수로 전달한 테스트를 찾아서 실행하십시오. 사전 커미트 후크 통합에 필요한 최소한의 테스트를 실행하는 데 유용합니다. 소스 파일에 대한 테스트 범위를 포함하기 위해 &lt;code&gt;--coverage&lt;/code&gt; 와 함께 사용할 수 있으며 중복 &lt;code&gt;--collectCoverageFrom&lt;/code&gt; 인수가 필요 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6383d1303f59cd8ac9d056a3ec5b8a0155117bc7" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt; 설치 하십시오</target>
        </trans-unit>
        <trans-unit id="bc88fb87447ec13c40c34c214ea754c225ddc5c9" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-mongodb&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;@shelf/jest-mongodb&lt;/code&gt; 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="fee562eadcf9ddab28fe2316718a764478b89680" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;jest-puppeteer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;jest-puppeteer&lt;/code&gt; 를 먼저 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="558ef585a8582382dd2312c86147f35d19fd7f2a" translate="yes" xml:space="preserve">
          <source>First row of variable name column headings separated with &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">변수 이름 열 표제의 첫 번째 행은 &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49166127081da4be02dce4127fa195a83c32997f" translate="yes" xml:space="preserve">
          <source>First, enable Babel support in Jest as documented in the &lt;a href=&quot;getting-started#using-babel&quot;&gt;Getting Started&lt;/a&gt; guide.</source>
          <target state="translated">먼저 &lt;a href=&quot;getting-started#using-babel&quot;&gt;시작&lt;/a&gt; 안내서에 설명 된대로 Jest에서 Babel 지원을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="df4fc028d306fad456b0b3c8d93f171ca540a302" translate="yes" xml:space="preserve">
          <source>First, you write a test, calling &lt;code&gt;.toMatchInlineSnapshot()&lt;/code&gt; with no arguments:</source>
          <target state="translated">먼저 인수없이 &lt;code&gt;.toMatchInlineSnapshot()&lt;/code&gt; 을 호출하여 테스트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="f28e9e3ebcc459ad6465344f6b958b9cb52a1efe" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://twitter.com/fbjest&quot;&gt;Jest Twitter account&lt;/a&gt; and &lt;a href=&quot;https://jestjs.io/blog/&quot;&gt;blog&lt;/a&gt; to find out what's happening in the world of Jest.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/fbjest&quot;&gt;Jest Twitter 계정&lt;/a&gt; 및 &lt;a href=&quot;https://jestjs.io/blog/&quot;&gt;블로그&lt;/a&gt; 를 따라 Jest 세계에서 무슨 일이 일어나고 있는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="ee2c453348c56f383fc00c98d57438686b82791f" translate="yes" xml:space="preserve">
          <source>For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">매처의 전체 목록은 &lt;a href=&quot;expect&quot;&gt;참조 문서를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="710d3ddee3d05ae5ac4aab2c9b427bcb07986d80" translate="yes" xml:space="preserve">
          <source>For additional Jest matchers maintained by the Jest Community check out &lt;a href=&quot;https://github.com/jest-community/jest-extended&quot;&gt;&lt;code&gt;jest-extended&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Jest Community가 유지 관리하는 추가 Jest 매처는 &lt;a href=&quot;https://github.com/jest-community/jest-extended&quot;&gt; &lt;code&gt;jest-extended&lt;/code&gt; &lt;/a&gt; exttended를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3b2aa71d87b57fd9d29b8331034a72dff8b8da9" translate="yes" xml:space="preserve">
          <source>For an example of how to use Jest with Webpack with React, Redux, and Node, you can view one &lt;a href=&quot;https://github.com/jenniferabowd/jest_react_redux_node_webpack_complex_example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">React, Redux 및 Node와 함께 Webpack과 함께 Jest를 사용하는 방법에 대한 예는 &lt;a href=&quot;https://github.com/jenniferabowd/jest_react_redux_node_webpack_complex_example&quot;&gt;여기에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff533ca8de12b70302d788874c5ec33c12f132e5" translate="yes" xml:space="preserve">
          <source>For an individual test file, an added module precedes any modules from &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration, which precede the default snapshot serializers for built-in JavaScript types and for React elements. The last module added is the first module tested.</source>
          <target state="translated">개별 테스트 파일의 경우 추가 된 모듈이 &lt;code&gt;snapshotSerializers&lt;/code&gt; 구성의 모든 모듈보다 우선 하며 내장 JavaScript 유형 및 React 요소의 기본 스냅 샷 시리얼 라이저보다 우선합니다. 마지막으로 추가 된 모듈은 테스트 된 첫 번째 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="3c20f94a38a3d142e50b602bce344f49a6c0fbbf" translate="yes" xml:space="preserve">
          <source>For cases where we have methods that are typically chained (and thus always need to return &lt;code&gt;this&lt;/code&gt;), we have a sugary API to simplify this in the form of a &lt;code&gt;.mockReturnThis()&lt;/code&gt; function that also sits on all mocks:</source>
          <target state="translated">우리가 일반적으로 체인 (따라서 항상 반환해야하는 방법이 경우에 &lt;code&gt;this&lt;/code&gt; ), 우리는의 형태로이 문제를 단순화하는 달콤한 API가 &lt;code&gt;.mockReturnThis()&lt;/code&gt; 모든 모의 객체에 앉아 있다는 기능 :</target>
        </trans-unit>
        <trans-unit id="4dcf53a0abd5dceefdabe8547430b633eb5fc312" translate="yes" xml:space="preserve">
          <source>For environments with variable CPUs available, you can use percentage based configuration: &lt;code&gt;--maxWorkers=50%&lt;/code&gt;</source>
          <target state="translated">가변 CPU를 사용할 수있는 환경의 경우 백분율 기반 구성을 사용할 수 있습니다. &lt;code&gt;--maxWorkers=50%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cc1fa8955d4aa67143d0f4f14e4334b7f680c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;.toEqual&lt;/code&gt; and &lt;code&gt;.toBe&lt;/code&gt; behave differently in this test suite, so all the tests pass:</source>
          <target state="translated">예를 들어, 이 테스트 스위트에서 &lt;code&gt;.toEqual&lt;/code&gt; 및 &lt;code&gt;.toBe&lt;/code&gt; 는 다르게 작동하므로 모든 테스트가 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="593913af50b6363a01b6e27cb17d3a8f783e3f15" translate="yes" xml:space="preserve">
          <source>For example, Jest ships with several plug-ins to &lt;code&gt;jasmine&lt;/code&gt; that work by monkey-patching the jasmine API. If you wanted to add even more jasmine plugins to the mix (or if you wanted some custom, project-wide matchers for example), you could do so in these modules.</source>
          <target state="translated">예를 들어, 여러 플러그인을 농담 배송 &lt;code&gt;jasmine&lt;/code&gt; 그 자스민 API를 원숭이 - 패치에 의해 작동합니다. 더 많은 재스민 플러그인을 믹스에 추가하고 싶거나 (예를 들어, 프로젝트 전체의 사용자 정의 매칭기를 원한다면)이 모듈에서 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c97147f311fbef2d76543271148af18e8f65cb90" translate="yes" xml:space="preserve">
          <source>For example, compare:</source>
          <target state="translated">예를 들어, 다음을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="99b9f410a3e63e11e11d728aa4b998dca59892fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;getAllFlavors()&lt;/code&gt; returns an array of flavors and you want to be sure that &lt;code&gt;lime&lt;/code&gt; is in there, you can write:</source>
          <target state="translated">예를 들어, &lt;code&gt;getAllFlavors()&lt;/code&gt; 가 풍미 배열을 리턴하고 &lt;code&gt;lime&lt;/code&gt; 이 있는지 확인하려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12258129998b33cad901597baea7bc212492df25" translate="yes" xml:space="preserve">
          <source>For example, if both &lt;code&gt;initializeCityDatabase&lt;/code&gt; and &lt;code&gt;clearCityDatabase&lt;/code&gt; returned promises, and the city database could be reused between tests, we could change our test code to:</source>
          <target state="translated">예를 들어 &lt;code&gt;initializeCityDatabase&lt;/code&gt; 와 &lt;code&gt;clearCityDatabase&lt;/code&gt; 가 모두 약속을 반환하고 도시 데이터베이스를 테스트간에 재사용 할 수있는 경우 테스트 코드를 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047e33c60bee55f41c10a3ae41e4a59ed4c6ef04" translate="yes" xml:space="preserve">
          <source>For example, if you have a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js&quot;&gt;Clock&lt;/a&gt; component that uses &lt;code&gt;Date.now()&lt;/code&gt;, the snapshot generated from this component will be different every time the test case is run. In this case we can &lt;a href=&quot;mock-functions&quot;&gt;mock the Date.now() method&lt;/a&gt; to return a consistent value every time the test is run:</source>
          <target state="translated">예를 들어 &lt;code&gt;Date.now()&lt;/code&gt; 를 사용 하는 &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js&quot;&gt;Clock&lt;/a&gt; 구성 요소가있는 경우 테스트 사례가 실행될 때마다이 구성 요소에서 생성 된 스냅 샷이 달라집니다. 이 경우 &lt;a href=&quot;mock-functions&quot;&gt;Date.now () 메서드&lt;/a&gt; 를 모의 하여 테스트가 실행될 때마다 일관된 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c52624003569af07b46970b0fc720da677fe0f5" translate="yes" xml:space="preserve">
          <source>For example, if you have tests in source files named with &lt;code&gt;.t.js&lt;/code&gt; extension as following:</source>
          <target state="translated">예를 들어 확장자 가 &lt;code&gt;.t.js&lt;/code&gt; 인 소스 파일에서 다음과 같이 테스트 한 경우 :</target>
        </trans-unit>
        <trans-unit id="43ce97754ad0ae68a81e69708826f13c59f1a71e" translate="yes" xml:space="preserve">
          <source>For example, if your code depends on a third party native video component called &lt;code&gt;react-native-video&lt;/code&gt; you might want to stub it out with a manual mock like this:</source>
          <target state="translated">예를 들어 코드가 &lt;code&gt;react-native-video&lt;/code&gt; 라는 타사 기본 비디오 구성 요소에 의존하는 경우 다음 과 같은 수동 모형으로 스텁을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594cf95e63a36ce4ead65bcac2606fb4793f5b72" translate="yes" xml:space="preserve">
          <source>For example, if your tests call &lt;code&gt;Math&lt;/code&gt; often, you can pass it by setting &lt;code&gt;extraGlobals&lt;/code&gt;.</source>
          <target state="translated">예를 들어 테스트에서 &lt;code&gt;Math&lt;/code&gt; 를 자주 호출하는 경우 &lt;code&gt;extraGlobals&lt;/code&gt; 를 설정하여 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1f5a22319beabdfbabd11912aaeb825ac6e178" translate="yes" xml:space="preserve">
          <source>For example, let's say &lt;code&gt;fetchBeverageList()&lt;/code&gt; returns a promise that is supposed to resolve to a list that has &lt;code&gt;lemon&lt;/code&gt; in it. You can test this with:</source>
          <target state="translated">예를 들어, &lt;code&gt;fetchBeverageList()&lt;/code&gt; 는 &lt;code&gt;lemon&lt;/code&gt; 된 목록으로 확인되는 약속을 반환 한다고 가정 해 보겠습니다 . 다음과 같이 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91bf2dd9d08b2408d6850dcb0015666facf63d27" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;drinkFlavor&lt;/code&gt; is coded like this:</source>
          <target state="translated">예를 들어 &lt;code&gt;drinkFlavor&lt;/code&gt; 가 다음과 같이 코딩 되었다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="1756cef91c9a3477b1322242e385d60cc54ab610" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;fetchData&lt;/code&gt;, instead of using a callback, returns a promise that is supposed to resolve to the string &lt;code&gt;'peanut butter'&lt;/code&gt;. We could test it with:</source>
          <target state="translated">예를 들어, 콜백을 사용하는 대신 &lt;code&gt;fetchData&lt;/code&gt; 가 문자열 &lt;code&gt;'peanut butter'&lt;/code&gt; 로 해석 될 가능성을 리턴한다고 가정 해 봅시다 . 우리는 그것을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8f15af66e6a6e677b2e452f62fe482a06d1fa9e2" translate="yes" xml:space="preserve">
          <source>For example, let's say that several tests interact with a database of cities. You have a method &lt;code&gt;initializeCityDatabase()&lt;/code&gt; that must be called before each of these tests, and a method &lt;code&gt;clearCityDatabase()&lt;/code&gt; that must be called after each of these tests. You can do this with:</source>
          <target state="translated">예를 들어 여러 테스트가 도시 데이터베이스와 상호 작용한다고 가정 해 봅시다. 당신은 방법이 &lt;code&gt;initializeCityDatabase()&lt;/code&gt; 이 각 시험 전에 호출해야하며, 방법 &lt;code&gt;clearCityDatabase()&lt;/code&gt; 이 시험의 각 후에 호출해야합니다. 당신은 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ce6dbac819240657572137dc7fbd2f85952399df" translate="yes" xml:space="preserve">
          <source>For example, let's say that we expect an &lt;code&gt;onPress&lt;/code&gt; function to be called with an &lt;code&gt;Event&lt;/code&gt; object, and all we need to verify is that the event has &lt;code&gt;event.x&lt;/code&gt; and &lt;code&gt;event.y&lt;/code&gt; properties. We can do that with:</source>
          <target state="translated">예를 들어, &lt;code&gt;onPress&lt;/code&gt; 함수가 &lt;code&gt;Event&lt;/code&gt; 객체 와 함께 호출 될 것으로 예상 하고 이벤트에 &lt;code&gt;event.x&lt;/code&gt; 및 &lt;code&gt;event.y&lt;/code&gt; 속성 이 있는지 확인하기 만하면 됩니다. 우리는 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="874efdb115adcb599b6389e915c72466eb139681" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a few functions that all deal with state. &lt;code&gt;prepareState&lt;/code&gt; calls a callback with a state object, &lt;code&gt;validateState&lt;/code&gt; runs on that state object, and &lt;code&gt;waitOnState&lt;/code&gt; returns a promise that waits until all &lt;code&gt;prepareState&lt;/code&gt; callbacks complete. We can test this with:</source>
          <target state="translated">예를 들어, 상태를 다루는 몇 가지 함수가 있다고 가정 해 봅시다. &lt;code&gt;prepareState&lt;/code&gt; 는 상태 객체와 콜백이 호출 &lt;code&gt;validateState&lt;/code&gt; 는 그 상태 개체에서 실행되고 &lt;code&gt;waitOnState&lt;/code&gt; 는 모든 때까지 대기하는 약속 반환 &lt;code&gt;prepareState&lt;/code&gt; 이 완료 콜백을. 우리는 이것을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6b90133a1da2bd721be03a9878aced8ee87402d1" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a function &lt;code&gt;doAsync&lt;/code&gt; that receives two callbacks &lt;code&gt;callback1&lt;/code&gt; and &lt;code&gt;callback2&lt;/code&gt;, it will asynchronously call both of them in an unknown order. We can test this with:</source>
          <target state="translated">예를 들어, 두 개의 콜백 &lt;code&gt;callback1&lt;/code&gt; 과 &lt;code&gt;callback2&lt;/code&gt; 를 수신 하는 &lt;code&gt;doAsync&lt;/code&gt; 함수가 있다고 가정 하면 두 개의 콜백을 알 수없는 순서로 비동기 적으로 호출합니다. 우리는 이것을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bbbbc61e2c5d99dfb2d92614d0dd1192b0d88661" translate="yes" xml:space="preserve">
          <source>For example, let's say that you can register a beverage with a &lt;code&gt;register&lt;/code&gt; function, and &lt;code&gt;applyToAll(f)&lt;/code&gt; should apply the function &lt;code&gt;f&lt;/code&gt; to all registered beverages. To make sure this works, you could write:</source>
          <target state="translated">예를 들어, &lt;code&gt;register&lt;/code&gt; 기능을 사용 하여 음료를 등록 할 수 있으며 &lt;code&gt;applyToAll(f)&lt;/code&gt; 는 등록 된 모든 음료에 기능 &lt;code&gt;f&lt;/code&gt; 를 적용해야한다고 가정합니다 . 이것이 작동하는지 확인하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="931d136a254e4d07f405b22f0ffa92a1088a08ec" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a &lt;code&gt;fetchData(callback)&lt;/code&gt; function that fetches some data and calls &lt;code&gt;callback(data)&lt;/code&gt; when it is complete. You want to test that this returned data is the string &lt;code&gt;'peanut butter'&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 일부 데이터를 가져오고 &lt;code&gt;callback(data)&lt;/code&gt; 이 완료되면 호출 하는 &lt;code&gt;fetchData(callback)&lt;/code&gt; 함수가 있다고 가정 합니다. 이 리턴 된 데이터가 문자열 &lt;code&gt;'peanut butter'&lt;/code&gt; 인지 테스트하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="40273c01c92ebe97ba2ea977841c404bf2c262a8" translate="yes" xml:space="preserve">
          <source>For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:</source>
          <target state="translated">예를 들어 도시 데이터베이스뿐만 아니라 음식 데이터베이스도 있다고 가정 해 봅시다. 테스트마다 다른 설정을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a8741fbad45210a09db8ad6539e976d1dec113" translate="yes" xml:space="preserve">
          <source>For example, let's say you had these tests:</source>
          <target state="translated">예를 들어 다음과 같은 테스트가 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="144429e39562897fbccf4b94d4f8adfc39339a49" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkAll(drink, flavour)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to all available beverages. You might want to check that &lt;code&gt;drink&lt;/code&gt; gets called for &lt;code&gt;'lemon'&lt;/code&gt;, but not for &lt;code&gt;'octopus'&lt;/code&gt;, because &lt;code&gt;'octopus'&lt;/code&gt; flavour is really weird and why would anything be octopus-flavoured? You can do that with this test suite:</source>
          <target state="translated">예를 들어, &lt;code&gt;drink&lt;/code&gt; 기능을 사용하여 사용 가능한 모든 음료에 적용 하는 &lt;code&gt;drinkAll(drink, flavour)&lt;/code&gt; 기능이 있다고 가정합니다 . &lt;code&gt;'octopus'&lt;/code&gt; 맛이 정말 이상하고 왜 문어 맛이 나기 때문에 &lt;code&gt;drink&lt;/code&gt; 가 &lt;code&gt;'lemon'&lt;/code&gt; 을 요구하지만 &lt;code&gt;'octopus'&lt;/code&gt; 가 아닌지 확인하고 싶을 수도 있습니다 . 이 테스트 스위트를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5e0f3cd06a5bf9c4dca1f40534b4b77ff28e3e" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to array of passed beverages. You might want to check that drink function was called exact number of times. You can do that with this test suite:</source>
          <target state="translated">예를 들어, 당신이 있다고 가정 해 봅시다 &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; 소요 기능 &lt;code&gt;drink&lt;/code&gt; 기능과 전달 된 음료의 배열에 적용합니다. 음료 기능이 정확한 횟수인지 확인하고 싶을 수도 있습니다. 이 테스트 스위트를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a18e498dc37e770eebf9088b5657094b5df58eb" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkFlavor&lt;/code&gt; function that throws whenever the flavor is &lt;code&gt;'octopus'&lt;/code&gt;, and is coded like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;drinkFlavor&lt;/code&gt; 이 &lt;code&gt;'octopus'&lt;/code&gt; 이고 다음과 같이 코딩 되는 drinkFlavor 함수 가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="ec0e394a329140aa320ffab5691064eca7211fef" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="translated">예를 들어, &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모의 &lt;code&gt;drink&lt;/code&gt; 가 있다고 가정 해 봅시다 . 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="96cb3fce436e959ed4ff1a604e78cbd23c2e2492" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns the name of the beverage that was consumed. You can write:</source>
          <target state="translated">예를 들어, 소비 된 음료의 이름을 반환 하는 모의 &lt;code&gt;drink&lt;/code&gt; 있다고 가정합니다. 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="fc0ef20a9a16b71f44a801db2115dcf4ceaa7ed0" translate="yes" xml:space="preserve">
          <source>For example, the following would create a global &lt;code&gt;__DEV__&lt;/code&gt; variable set to &lt;code&gt;true&lt;/code&gt; in all test environments:</source>
          <target state="translated">예를 들어, 다음은 모든 테스트 환경에서 전역 &lt;code&gt;__DEV__&lt;/code&gt; 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="071b4caddeb027fae4504867a5d3ff914e164bce" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise rejects with reason &lt;code&gt;'octopus'&lt;/code&gt;:</source>
          <target state="translated">예를 들어,이 코드는 약속이 &lt;code&gt;'octopus'&lt;/code&gt; 이유와 함께 거부되는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="5f2a13885f18e36be7159ff50e29caef2aee6935" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise resolves and that the resulting value is &lt;code&gt;'lemon'&lt;/code&gt;:</source>
          <target state="translated">예를 들어,이 코드는 약속이 해결되고 결과 값이 &lt;code&gt;'lemon'&lt;/code&gt; 인지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="bcd7db6ccfa8b4522705daf177fc8fdd66902a9e" translate="yes" xml:space="preserve">
          <source>For example, this code will validate some properties of the &lt;code&gt;can&lt;/code&gt; object:</source>
          <target state="translated">예를 들어이 코드는 &lt;code&gt;can&lt;/code&gt; 객체 의 일부 속성을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="21990133d4e4885c717a863643a6c3db329fd8fc" translate="yes" xml:space="preserve">
          <source>For example, this preset &lt;code&gt;foo-bar/jest-preset.js&lt;/code&gt; will be configured as follows:</source>
          <target state="translated">예를 들어,이 사전 설정 &lt;code&gt;foo-bar/jest-preset.js&lt;/code&gt; 는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="75730b175681e09d4947af40aa96097263db660e" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:</source>
          <target state="translated">예를 들어, 다음 구성을 사용하면 분기, 라인 및 함수 적용 범위가 80 % 미만이거나 10 개의 발견되지 않은 명령문이 있으면 jest가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="21691166486d6f854fcdbed969ad08f56c5be3d3" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration:</source>
          <target state="translated">예를 들어 다음 구성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d8bc1522a1c4b58ae364d57035e63c01139aac7" translate="yes" xml:space="preserve">
          <source>For example, you might not know what exactly &lt;code&gt;essayOnTheBestFlavor()&lt;/code&gt; returns, but you know it's a really long string, and the substring &lt;code&gt;grapefruit&lt;/code&gt; should be in there somewhere. You can test this with:</source>
          <target state="translated">예를 들어, 정확히 &lt;code&gt;essayOnTheBestFlavor()&lt;/code&gt; 가 무엇을 반환하는지 알 수는 없지만 실제로는 긴 문자열이며 하위 문자열 &lt;code&gt;grapefruit&lt;/code&gt; 이 어딘가에 있어야 함을 알고 있습니다. 다음과 같이 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff56bde239ab874f2e956a43f1424bb53acc1ac4" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called three times, returning &lt;code&gt;'result1'&lt;/code&gt;, throwing an error, and then returning &lt;code&gt;'result2'&lt;/code&gt;, would have a &lt;code&gt;mock.results&lt;/code&gt; array that looks like this:</source>
          <target state="translated">예를 들어 , 세 번 호출 된 ' 모의 함수 &lt;code&gt;f&lt;/code&gt; &lt;code&gt;'result1'&lt;/code&gt; 을 리턴하고 오류를 던진 후 리턴합니다. &lt;code&gt;'result2'&lt;/code&gt; 다음과 같은 &lt;code&gt;mock.results&lt;/code&gt; 배열을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d872a792c7892418e5f9ff3ed51e783257317905" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called twice, with the arguments &lt;code&gt;f('arg1', 'arg2')&lt;/code&gt;, and then with the arguments &lt;code&gt;f('arg3', 'arg4')&lt;/code&gt;, would have a &lt;code&gt;mock.calls&lt;/code&gt; array that looks like this:</source>
          <target state="translated">예를 들어 , &lt;code&gt;f('arg1', 'arg2')&lt;/code&gt; 인수와 함께 &lt;code&gt;f('arg3', 'arg4')&lt;/code&gt; 인수와 함께 두 번 호출 된 모의 함수 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;mock.calls&lt;/code&gt; 배열을 갖습니다. 이것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="f1cd0da2a66dfee53a78bdc3fd98cf8483f85a33" translate="yes" xml:space="preserve">
          <source>For example: A mock function that has been instantiated twice would have the following &lt;code&gt;mock.instances&lt;/code&gt; array:</source>
          <target state="translated">예를 들어 : 두 번 인스턴스화 된 모의 함수는 다음과 같습니다. &lt;code&gt;mock.instances&lt;/code&gt; 배열을 .</target>
        </trans-unit>
        <trans-unit id="83c176f04f272523170bec5099eee267107d1f94" translate="yes" xml:space="preserve">
          <source>For floating point equality, use &lt;code&gt;toBeCloseTo&lt;/code&gt; instead of &lt;code&gt;toEqual&lt;/code&gt;, because you don't want a test to depend on a tiny rounding error.</source>
          <target state="translated">부동 소수점 동등성을 위해 &lt;code&gt;toBeCloseTo&lt;/code&gt; 를 사용 하십시오. 대신 &lt;code&gt;toEqual&lt;/code&gt; 당신이 테스트가 작은 반올림 오류에 의존하지 않기 때문에.</target>
        </trans-unit>
        <trans-unit id="c045e0e7243305deaa4aee87493fdfd39783b37b" translate="yes" xml:space="preserve">
          <source>For stability and safety reasons, only part of the global configuration keys can be updated with &lt;code&gt;updateConfigAndRun&lt;/code&gt;. The current white list is as follows:</source>
          <target state="translated">안정성 및 안전상의 이유로 글로벌 구성 키의 일부만 &lt;code&gt;updateConfigAndRun&lt;/code&gt; . 현재 화이트리스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f66fb40c58c7f7d3b21d1398dcbcf990f95330c9" translate="yes" xml:space="preserve">
          <source>For the contrived example, the mock might look like this:</source>
          <target state="translated">고안된 예에서 모의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cf5108e3716a31ac868c82b64f26462d0db96cf" translate="yes" xml:space="preserve">
          <source>For the full list of methods and argument types see &lt;code&gt;Reporter&lt;/code&gt; interface in &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts&quot;&gt;packages/jest-reporters/src/types.ts&lt;/a&gt;</source>
          <target state="translated">메소드 및 인수 유형의 전체 목록은 다음의 &lt;code&gt;Reporter&lt;/code&gt; 인터페이스를 참조하십시오 .&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts&quot;&gt; packages / jest-reporters / src / types.ts의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f2c50f795c83753fddbef63571049b5a7a72e84b" translate="yes" xml:space="preserve">
          <source>For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:</source>
          <target state="translated">이 경우 Jest를 통해 모든 속성에 비대칭 매처를 제공 할 수 있습니다. 이러한 매처는 스냅 샷을 작성하거나 테스트하기 전에 확인한 다음 수신 된 값 대신 스냅 샷 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="51b7572af95fd60bcf8235bd8bc18e747afefdc9" translate="yes" xml:space="preserve">
          <source>Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up. &lt;em&gt;Note: This feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use &lt;code&gt;--detectOpenHandles&lt;/code&gt; to help track it down.&lt;/em&gt;</source>
          <target state="translated">모든 테스트가 완료된 후 Jest를 강제 종료하십시오. 테스트 코드로 설정된 리소스를 적절히 정리할 수 없을 때 유용합니다. &lt;em&gt;참고 :이 기능은 이스케이프 해치입니다. Jest가 테스트 실행이 끝날 때 종료되지 않으면 외부 리소스가 계속 보류 중이거나 타이머가 코드에서 여전히 보류 중임을 의미합니다. Jest가 깨끗하게 종료 될 수 있도록 각 테스트 후 외부 리소스를 분리하는 것이 좋습니다. 당신이 사용할 수있는 &lt;code&gt;--detectOpenHandles&lt;/code&gt; 를 하여 추적 할 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2a8a4fbef38bbbe48000abe9f4946c616769cb5" translate="yes" xml:space="preserve">
          <source>Forces test results output highlighting even if stdout is not a TTY.</source>
          <target state="translated">stdout이 TTY가 아닌 경우에도 테스트 결과 출력 강조 표시를 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="73a47003cfd2a3396a2450eecc7022eb5baf66b2" translate="yes" xml:space="preserve">
          <source>Framework Guides</source>
          <target state="translated">프레임 워크 가이드</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="79e9687ea7f127fc79ca8e5c0f48f0aeee5eb4b5" translate="yes" xml:space="preserve">
          <source>From here you can choose to update that snapshot or skip to the next:</source>
          <target state="translated">여기에서 해당 스냅 샷을 업데이트하거나 다음으로 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61384321378d81043daaf7aa5004f9649b760e53" translate="yes" xml:space="preserve">
          <source>GatsbyJS</source>
          <target state="translated">GatsbyJS</target>
        </trans-unit>
        <trans-unit id="75fabb5a96311113ca298de2d0ecaaa2aae1996e" translate="yes" xml:space="preserve">
          <source>General Advice</source>
          <target state="translated">일반적인 조언</target>
        </trans-unit>
        <trans-unit id="98ffaf821b2d9a8192a641c430a1e7c2be181a98" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file</source>
          <target state="translated">기본 구성 파일 생성</target>
        </trans-unit>
        <trans-unit id="4eff11ad6cc06e2f1ac1a723dc83bfd6e1768cde" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a &lt;code&gt;jest.config.js&lt;/code&gt; file with a short description for each option.</source>
          <target state="translated">기본 구성 파일을 생성하십시오. 프로젝트에 따라 Jest는 각 옵션에 대한 간단한 설명과 함께 &lt;code&gt;jest.config.js&lt;/code&gt; 파일 을 생성하는 데 도움이되는 몇 가지 질문을합니다 .</target>
        </trans-unit>
        <trans-unit id="f2c15ec8813d8414ee1697eec1942000cc70d8ec" translate="yes" xml:space="preserve">
          <source>Generate unique test titles by positionally injecting parameters with &lt;a href=&quot;https://nodejs.org/api/util.html#util_util_format_format_args&quot;&gt;&lt;code&gt;printf&lt;/code&gt; formatting&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/api/util.html#util_util_format_format_args&quot;&gt; &lt;code&gt;printf&lt;/code&gt; 형식으로&lt;/a&gt; 매개 변수를 위치 적으로 주입하여 고유 한 테스트 제목을 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e54dc9738cd540bb6ba39267578b63bf772cd9d8" translate="yes" xml:space="preserve">
          <source>Generating code coverage for test files using Puppeteer is currently not possible if your test uses &lt;code&gt;page.$eval&lt;/code&gt;, &lt;code&gt;page.$$eval&lt;/code&gt; or &lt;code&gt;page.evaluate&lt;/code&gt; as the passed function is executed outside of Jest's scope. Check out &lt;a href=&quot;https://github.com/facebook/jest/issues/7962#issuecomment-495272339&quot;&gt;issue #7962&lt;/a&gt; on GitHub for a workaround.</source>
          <target state="translated">전달 된 함수가 Jest의 범위 밖에서 실행될 때 &lt;code&gt;page.$eval&lt;/code&gt; , &lt;code&gt;page.$$eval&lt;/code&gt; 또는 &lt;code&gt;page.evaluate&lt;/code&gt; 를 사용하는 경우 Puppeteer를 사용하여 테스트 파일의 코드 적용 범위를 생성 할 수 없습니다 . 해결 방법은 GitHub의 &lt;a href=&quot;https://github.com/facebook/jest/issues/7962#issuecomment-495272339&quot;&gt;# 7962 문제를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd13d25dc262c99d9c8684b86741b04a10d005f" translate="yes" xml:space="preserve">
          <source>Get a deeper insight into testing a working React Native app example by reading the following series: &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-1-snapshots-come-into-play/&quot;&gt;Part 1: Jest &amp;ndash; Snapshot come into play&lt;/a&gt; and &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-2-redux-snapshots-for-your-actions-and-reducers/&quot;&gt;Part 2: Jest &amp;ndash; Redux Snapshots for your Actions and Reducers&lt;/a&gt;.</source>
          <target state="translated">다음 시리즈를 읽고 작동하는 React Native 앱 예제를 테스트하는 데 대한 심층적 인 통찰력을 얻으십시오. &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-1-snapshots-come-into-play/&quot;&gt;1 부 : Jest &amp;ndash; 스냅 샷이 작동&lt;/a&gt; 하고 &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-2-redux-snapshots-for-your-actions-and-reducers/&quot;&gt;2 부 : Jest &amp;ndash; 액션 및 리듀서를위한 Redux 스냅 샷&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="799d464814c35b3c4f2bd970cbd9a5bc23b78618" translate="yes" xml:space="preserve">
          <source>Gets called at the end of every test run. It has the test results as an argument.</source>
          <target state="translated">모든 테스트 실행이 끝날 때 호출됩니다. 테스트 결과를 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df67fe80f33086b3ebe3ae445504840168a6c71b" translate="yes" xml:space="preserve">
          <source>Gets called whenever there is a change in the file system</source>
          <target state="translated">파일 시스템이 변경 될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0521fc5aa1b1f1dced820bdf16633c65d66fda68" translate="yes" xml:space="preserve">
          <source>Given the name of a module, use the automatic mocking system to generate a mocked version of the module for you.</source>
          <target state="translated">모듈 이름이 주어지면 자동 조롱 시스템을 사용하여 모의 모듈 버전을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3f827c66e7e04723ed3fa1ab0945dff3f10b9b83" translate="yes" xml:space="preserve">
          <source>Globals</source>
          <target state="translated">Globals</target>
        </trans-unit>
        <trans-unit id="66e11c5171519fb11b18776bac2f49b3ef8097c8" translate="yes" xml:space="preserve">
          <source>Go ahead and accept the changes by running the above command. You may also use the equivalent single-character &lt;code&gt;-u&lt;/code&gt; flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.</source>
          <target state="translated">위 명령을 실행하여 변경 사항을 적용하십시오. 동등한 단일 문자 &lt;code&gt;-u&lt;/code&gt; 를 사용할 수도 있습니다. 플래그를 사용하여 스냅 샷을 다시 생성 . 이렇게하면 실패한 모든 스냅 샷 테스트에 대한 스냅 샷 아티팩트가 다시 생성됩니다. 의도하지 않은 버그로 인해 추가로 실패한 스냅 샷 테스트가있는 경우 버그가있는 동작의 스냅 샷을 기록하지 않도록 스냅 샷을 다시 생성하기 전에 버그를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="9492d9787956a33e31c7c7ed4f3132bf12917883" translate="yes" xml:space="preserve">
          <source>Guides: Introduction</source>
          <target state="translated">가이드 : 소개</target>
        </trans-unit>
        <trans-unit id="3a1cb6486159f8fb716bc26925fc1b77ba78c39a" translate="yes" xml:space="preserve">
          <source>Handling Static Assets</source>
          <target state="translated">정적 자산 처리</target>
        </trans-unit>
        <trans-unit id="4c8c7c374697b9a0908767f6b8abbf4ca28b782b" translate="yes" xml:space="preserve">
          <source>Help:</source>
          <target state="translated">Help:</target>
        </trans-unit>
        <trans-unit id="8590c3106f1d77bf4a9ae5f0686ed9ef3f06f737" translate="yes" xml:space="preserve">
          <source>Here is a brief overview:</source>
          <target state="translated">간략한 개요는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b82314997735c45eace267e10004814f476844b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterAll&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after all tests run.</source>
          <target state="translated">여기에 &lt;code&gt;afterAll&lt;/code&gt; 보장 &lt;code&gt;cleanUpDatabase&lt;/code&gt; 이 모든 검사를 실행 한 후라고합니다.</target>
        </trans-unit>
        <trans-unit id="f53ee15f468af76ea014ce3192ad96c9f2769b46" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterEach&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after each test runs.</source>
          <target state="translated">여기에 &lt;code&gt;afterEach&lt;/code&gt; 는 보장 &lt;code&gt;cleanUpDatabase&lt;/code&gt; 는 각 테스트가 실행 된 이후라고합니다.</target>
        </trans-unit>
        <trans-unit id="6f2c6ca85b8f247386b644a9b9448050fb98ba8b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeAll&lt;/code&gt; ensures that the database is set up before tests run. If setup was synchronous, you could do this without &lt;code&gt;beforeAll&lt;/code&gt;. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.</source>
          <target state="translated">여기서 &lt;code&gt;beforeAll&lt;/code&gt; 은 테스트가 실행되기 전에 데이터베이스가 설정되도록합니다. 설정이 동기화 된 경우 &lt;code&gt;beforeAll&lt;/code&gt; 없이이 작업을 수행 할 수 있습니다. 열쇠는 Jest가 약속이 해결되기를 기다릴 것이므로 비동기 설정도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c986af0e0e93ca9be7580639b72afacb632a1fd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeEach&lt;/code&gt; ensures that the database is reset for each test.</source>
          <target state="translated">여기서 &lt;code&gt;beforeEach&lt;/code&gt; 는 각 테스트마다 데이터베이스가 재설정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="a11a344028eaa93e6dbdbf6a41de62398cbc4d4f" translate="yes" xml:space="preserve">
          <source>Here we enable fake timers by calling &lt;code&gt;jest.useFakeTimers();&lt;/code&gt;. This mocks out setTimeout and other timer functions with mock functions. If running multiple tests inside of one file or describe block, &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; can be called before each test manually or with a setup function such as &lt;code&gt;beforeEach&lt;/code&gt;. Not doing so will result in the internal usage counter not being reset.</source>
          <target state="translated">여기에서 &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; 를 호출하여 가짜 타이머를 활성화합니다 . . 이것은 setTimeout과 다른 타이머 기능을 모의 기능으로 조롱합니다. 하나의 파일 내에서 여러 테스트를 실행하거나 &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; 블록을 설명하는 경우 jest.useFakeTimers (); 각 테스트 전에 수동으로 호출하거나 &lt;code&gt;beforeEach&lt;/code&gt; 와 같은 설정 기능을 사용하여 호출 할 수 있습니다 . 그렇지 않으면 내부 사용 카운터가 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3296e4a9a937d655fc487d89d44cc0a7f825b550" translate="yes" xml:space="preserve">
          <source>Here's a complete test file which uses the module factory parameter to &lt;code&gt;jest.mock&lt;/code&gt;:</source>
          <target state="translated">다음은 모듈 팩토리 매개 변수를 &lt;code&gt;jest.mock&lt;/code&gt; 에 사용하는 완전한 테스트 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="d23bc1c8fad4267f600ff0f8ca654e743fe48303" translate="yes" xml:space="preserve">
          <source>Here's a contrived example where we have a module that provides a summary of all the files in a given directory. In this case we use the core (built in) &lt;code&gt;fs&lt;/code&gt; module.</source>
          <target state="translated">다음은 주어진 디렉토리에있는 모든 파일의 요약을 제공하는 모듈이있는 고안된 예입니다. 이 경우 코어 (내장) &lt;code&gt;fs&lt;/code&gt; 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa0ef58a95e5aba79279e07fb2a779d1b19111a2" translate="yes" xml:space="preserve">
          <source>Here's a snapshot matcher that trims a string to store for a given length, &lt;code&gt;.toMatchTrimmedSnapshot(length)&lt;/code&gt;:</source>
          <target state="translated">주어진 길이 &lt;code&gt;.toMatchTrimmedSnapshot(length)&lt;/code&gt; 동안 저장할 문자열을 자르는 스냅 샷 매처는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="50ca12756b3286d1c69b00aa0dfabdef931475e9" translate="yes" xml:space="preserve">
          <source>Here's an example of the GlobalSetup script</source>
          <target state="translated">다음은 GlobalSetup 스크립트의 예입니다</target>
        </trans-unit>
        <trans-unit id="b0a016b4fe86ae49e4048497e86b5fd1a869d608" translate="yes" xml:space="preserve">
          <source>Here's how to run Jest on files matching &lt;code&gt;my-test&lt;/code&gt;, using &lt;code&gt;config.json&lt;/code&gt; as a configuration file and display a native OS notification after the run:</source>
          <target state="translated">&lt;code&gt;config.json&lt;/code&gt; 을 구성 파일로 사용하고 &lt;code&gt;my-test&lt;/code&gt; 와 일치하는 파일에서 Jest를 실행 하고 실행 후 기본 OS 알림을 표시하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa62494bb2468633777100c6526141484e1a9ce8" translate="yes" xml:space="preserve">
          <source>Here's the code of &lt;a href=&quot;https://github.com/xfumihiro/jest-puppeteer-example&quot;&gt;full working example&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;https://github.com/xfumihiro/jest-puppeteer-example&quot;&gt;전체 예제&lt;/a&gt; 의 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="60b880c8aa5a70aa5b6710448f8f53b517ba3960" translate="yes" xml:space="preserve">
          <source>Hooking into Jest</source>
          <target state="translated">Jest에 후킹</target>
        </trans-unit>
        <trans-unit id="53fb52372b98a249bee2e92c10585f1138a3a8d1" translate="yes" xml:space="preserve">
          <source>How do I resolve conflicts within snapshot files?</source>
          <target state="translated">스냅 샷 파일 내에서 충돌을 어떻게 해결합니까?</target>
        </trans-unit>
        <trans-unit id="139e29398f2627a8696250a9f26ea0f35d4fe9da" translate="yes" xml:space="preserve">
          <source>However, if you ran that test you would find that the &lt;code&gt;createUser&lt;/code&gt; function would fail, throwing the error: &lt;code&gt;TypeError: response.text is not a function&lt;/code&gt;. This is because the &lt;code&gt;Response&lt;/code&gt; class you've imported from &lt;code&gt;node-fetch&lt;/code&gt; has been mocked (due to the &lt;code&gt;jest.mock&lt;/code&gt; call at the top of the test file) so it no longer behaves the way it should.</source>
          <target state="translated">그러나 해당 테스트를 실행하면 &lt;code&gt;createUser&lt;/code&gt; 함수가 실패하고 다음 오류가 발생합니다. &lt;code&gt;TypeError: response.text is not a function&lt;/code&gt; . 때문이다 &lt;code&gt;Response&lt;/code&gt; 당신이에서 가져온 클래스 &lt;code&gt;node-fetch&lt;/code&gt; (인해를 조롱하고있다 &lt;code&gt;jest.mock&lt;/code&gt; 의 더 이상은해야하는 방식으로 동작하도록 테스트 파일의 맨 위에있는 호출).</target>
        </trans-unit>
        <trans-unit id="40a65fb527f26996f958a4c7a7636697c68a57ae" translate="yes" xml:space="preserve">
          <source>However, there are some &lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-typescript.html#caveats&quot;&gt;caveats&lt;/a&gt; to using TypeScript with Babel. Because TypeScript support in Babel is transpilation, Jest will not type-check your tests as they are run. If you want that, you can use &lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest&lt;/a&gt;.</source>
          <target state="translated">그러나 Babel과 함께 TypeScript를 사용하는 경우 몇 가지 &lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-typescript.html#caveats&quot;&gt;주의 사항&lt;/a&gt; 이 있습니다 . Babel의 TypeScript 지원은 코드 변환이므로 Jest는 테스트를 실행할 때 형식을 확인하지 않습니다. 원하는 경우 &lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf42de47519a8be85813abc9dbcf79a2336fd084" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the end of the describe block.</source>
          <target state="translated">&lt;code&gt;afterAll&lt;/code&gt; 이 &lt;code&gt;describe&lt;/code&gt; 블록 안에 있으면 describe 블록의 끝에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="36d6e89fb8810e2839bb626d3834bcbc4b498e76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it only runs after the tests that are inside this describe block.</source>
          <target state="translated">경우 &lt;code&gt;afterEach&lt;/code&gt; 은 A가 내부에 &lt;code&gt;describe&lt;/code&gt; 블록, 만이 내부에있는 검사 블록을 설명 후에 실행.</target>
        </trans-unit>
        <trans-unit id="06fd5213f105f4db8f2c74d9197183295af8cfef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the beginning of the describe block.</source>
          <target state="translated">&lt;code&gt;beforeAll&lt;/code&gt; 이 &lt;code&gt;describe&lt;/code&gt; 블록 안에 있으면 describe 블록의 시작 부분에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d48344c733bdd18ab3274d53de4f2dd945448596" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs for each test in the describe block.</source>
          <target state="translated">&lt;code&gt;beforeEach&lt;/code&gt; 가 &lt;code&gt;describe&lt;/code&gt; 블록 안에 있으면 describe 블록의 각 테스트에 대해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="29c26c494506944de906e943951a2399f7620cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done()&lt;/code&gt; is never called, the test will fail, which is what you want to happen.</source>
          <target state="translated">경우 &lt;code&gt;done()&lt;/code&gt; 호출되지 않습니다, 검사 오류가 발생하는 것이되는, 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5d1981223ccef65cb683fc43fc578f449a3eee3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;moduleNameMapper&lt;/code&gt; cannot fulfill your requirements, you can use Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that &lt;code&gt;require('logo.jpg');&lt;/code&gt; returns &lt;code&gt;'logo'&lt;/code&gt;) can be written as:</source>
          <target state="translated">&lt;code&gt;moduleNameMapper&lt;/code&gt; 가 요구 사항을 충족 할 수없는 경우 Jest의 &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 구성 옵션을 사용하여 자산 변환 방법을 지정할 수 있습니다. 예를 들어, 파일의 기본 이름을 리턴하는 변환기 (예 : &lt;code&gt;require('logo.jpg');&lt;/code&gt; &lt;code&gt;'logo'&lt;/code&gt; 리턴 )는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df09d1e5934f36cd1398174cf6c7629249a09bf" translate="yes" xml:space="preserve">
          <source>If a promise doesn't resolve at all, this error might be thrown:</source>
          <target state="translated">약속이 전혀 해결되지 않으면이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e31564de21c2565396696cb413016ff78b9a87fd" translate="yes" xml:space="preserve">
          <source>If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that &lt;code&gt;test&lt;/code&gt; command to a &lt;code&gt;test.only&lt;/code&gt;:</source>
          <target state="translated">테스트에 실패한 경우 가장 먼저 확인해야 할 사항 중 하나는 테스트가 유일한 테스트 일 때 테스트에 실패했는지 여부입니다. Jest로 하나의 테스트 만 실행하려면 해당 &lt;code&gt;test&lt;/code&gt; 명령을 &lt;code&gt;test.only&lt;/code&gt; 로 임시 변경 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1368241bb9b6a677c253777f28e276302847afe6" translate="yes" xml:space="preserve">
          <source>If custom reporters are specified, the default Jest reporters will be overridden. To keep default reporters, &lt;code&gt;default&lt;/code&gt; can be passed as a module name.</source>
          <target state="translated">사용자 정의 리포터를 지정하면 기본 Jest 리포터가 재정의됩니다. 기본 기자를 유지하기 위해 &lt;code&gt;default&lt;/code&gt; 모듈 이름으로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d35c3c8f0f049c2d367440e4fa528eaf56ee5ab8" translate="yes" xml:space="preserve">
          <source>If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, use &lt;code&gt;equals&lt;/code&gt; method of &lt;code&gt;Buffer&lt;/code&gt; class to assert whether or not buffers contain the same content:</source>
          <target state="translated">속성 간의 차이가 테스트 실패 원인을 이해하는 데 도움이되지 않는 경우 (특히 보고서가 큰 경우) &lt;code&gt;expect&lt;/code&gt; 함수 로 비교를 이동할 수 있습니다. 예를 들어, &lt;code&gt;Buffer&lt;/code&gt; 클래스 의 &lt;code&gt;equals&lt;/code&gt; 메소드를 사용 하여 버퍼에 동일한 내용이 들어 있는지 여부를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8531076ffab17b1e6a3078dd99ca2b637f2d89a8" translate="yes" xml:space="preserve">
          <source>If globs or paths are specified alongside &lt;code&gt;global&lt;/code&gt;, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, error is returned.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 또는 나란히 glob 또는 경로를 지정 하면 일치하는 경로에 대한 적용 범위 데이터가 전체 적용 범위에서 차감되고 임계 값이 독립적으로 적용됩니다. 글로브에 대한 임계 값은 글로브와 일치하는 모든 파일에 적용됩니다. path로 지정된 파일을 찾을 수 없으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="72a21f6979cdac3c1b9ad4e08a0c6637f2d4dfa2" translate="yes" xml:space="preserve">
          <source>If some code uses a method which JSDOM (the DOM implementation used by Jest) hasn't implemented yet, testing it is not easily possible. This is e.g. the case with &lt;code&gt;window.matchMedia()&lt;/code&gt;. Jest returns &lt;code&gt;TypeError: window.matchMedia is not a function&lt;/code&gt; and doesn't properly execute the test.</source>
          <target state="translated">일부 코드에서 JSDOM (Jest에서 사용하는 DOM 구현)이 아직 구현하지 않은 방법을 사용하는 경우 쉽게 테스트 할 수 없습니다. 예를 들어 &lt;code&gt;window.matchMedia()&lt;/code&gt; 의 경우입니다 . Jest는 &lt;code&gt;TypeError: window.matchMedia is not a function&lt;/code&gt; 반환합니다 . window.matchMedia는 함수 가 아니며 테스트를 제대로 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17517ca3e186444904834c38de35490f5610cc1b" translate="yes" xml:space="preserve">
          <source>If the module you are mocking is a Node module (e.g.: &lt;code&gt;lodash&lt;/code&gt;), the mock should be placed in the &lt;code&gt;__mocks__&lt;/code&gt; directory adjacent to &lt;code&gt;node_modules&lt;/code&gt; (unless you configured &lt;a href=&quot;configuration#roots-arraystring&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; to point to a folder other than the project root) and will be &lt;strong&gt;automatically&lt;/strong&gt; mocked. There's no need to explicitly call &lt;code&gt;jest.mock('module_name')&lt;/code&gt;.</source>
          <target state="translated">모의 &lt;code&gt;lodash&lt;/code&gt; 모듈이 노드 모듈 인 경우 (예 : lodash ) 모의는 프로젝트 루트 이외의 폴더를 가리 키도록 &lt;a href=&quot;configuration#roots-arraystring&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt; 를 구성하지 않은 경우 &lt;code&gt;node_modules&lt;/code&gt; 옆 의 &lt;code&gt;__mocks__&lt;/code&gt; 디렉토리에 배치해야 하며 &lt;strong&gt;자동으로&lt;/strong&gt; 조롱됩니다. &lt;code&gt;jest.mock('module_name')&lt;/code&gt; 을 명시 적으로 호출 할 필요는 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="829141299a9251eaf1ce7f20d372e903be5b7bd4" translate="yes" xml:space="preserve">
          <source>If the user provided a custom configuration, it will be passed as an argument to the plugin constructor.</source>
          <target state="translated">사용자가 사용자 정의 구성을 제공 한 경우, 플러그인 생성자에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0c525e5e5ddd2de8c8d823c3e142628ec07ed1" translate="yes" xml:space="preserve">
          <source>If you add a snapshot serializer in individual test files instead of to adding it to &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;snapshotSerializers&lt;/code&gt; 구성 에 추가하는 대신 개별 테스트 파일에 스냅 샷 시리얼 라이저를 추가하는 경우 :</target>
        </trans-unit>
        <trans-unit id="30fd956763850c31b9ce0b4521be9bc8f3c1c8bb" translate="yes" xml:space="preserve">
          <source>If you are interested in learning more about how Jest works, what the architecture behind the framework is, and how Jest is split up into individual reusable packages, check out this video:</source>
          <target state="translated">Jest의 작동 방식, 프레임 워크 뒤의 아키텍처 및 Jest가 재사용 가능한 개별 패키지로 분리되는 방법에 대한 자세한 내용을 보려면 다음 비디오를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="18026771171516f84ca810200b4fd3d6a03c8bac" translate="yes" xml:space="preserve">
          <source>If you are new to React, we recommend using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;. It is ready to use and &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests#docsNav&quot;&gt;ships with Jest&lt;/a&gt;! You will only need to add &lt;code&gt;react-test-renderer&lt;/code&gt; for rendering snapshots.</source>
          <target state="translated">React를 처음 사용하는 경우 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React App 작성을&lt;/a&gt; 사용하는 것이 좋습니다 . &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests#docsNav&quot;&gt;Jest와 함께&lt;/a&gt; 사용할 준비가되었습니다 . 스냅 샷 &lt;code&gt;react-test-renderer&lt;/code&gt; 위해 react-test-renderer 만 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a18016808e001b4a11dfaa241f7321f12becaa6" translate="yes" xml:space="preserve">
          <source>If you are seeing coverage output such as...</source>
          <target state="translated">다음과 같은 커버리지 출력이 표시되는 경우 ...</target>
        </trans-unit>
        <trans-unit id="3538d9b6ba0bfe52daac18493de01cba0271f06a" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;AVA&lt;/a&gt;, &lt;a href=&quot;https://github.com/chaijs/chai&quot;&gt;Chai&lt;/a&gt;, &lt;a href=&quot;https://github.com/Automattic/expect.js&quot;&gt;Expect.js (by Automattic)&lt;/a&gt;, &lt;a href=&quot;https://github.com/jasmine/jasmine&quot;&gt;Jasmine&lt;/a&gt;, &lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;Mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/thlorenz/proxyquire&quot;&gt;proxyquire&lt;/a&gt;, &lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;Should.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/substack/tape&quot;&gt;Tape&lt;/a&gt; you can use the third-party &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;jest-codemods&lt;/a&gt; to do most of the dirty migration work. It runs a code transformation on your codebase using &lt;a href=&quot;https://github.com/facebook/jscodeshift&quot;&gt;jscodeshift&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;AVA&lt;/a&gt; , &lt;a href=&quot;https://github.com/chaijs/chai&quot;&gt;차이 티&lt;/a&gt; , &lt;a href=&quot;https://github.com/Automattic/expect.js&quot;&gt;(오토매틱으로) Expect.js&lt;/a&gt; , &lt;a href=&quot;https://github.com/jasmine/jasmine&quot;&gt;재스민&lt;/a&gt; , &lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;모카&lt;/a&gt; , &lt;a href=&quot;https://github.com/thlorenz/proxyquire&quot;&gt;proxyquire&lt;/a&gt; , &lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;Should.js&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/substack/tape&quot;&gt;테이프를&lt;/a&gt; 당신은 타사 사용할 수 있습니다 &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;농담-codemods을&lt;/a&gt; 더러운 마이그레이션 대부분의 작업을 할 수 있습니다. &lt;a href=&quot;https://github.com/facebook/jscodeshift&quot;&gt;jscodeshift를&lt;/a&gt; 사용하여 코드베이스에서 코드 변환을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="16afeeb67bb4f44c59d6fb688fc49403f7d400f9" translate="yes" xml:space="preserve">
          <source>If you are using AVA, Expect.js (by Automattic), Jasmine, Mocha, proxyquire, Should.js or Tape you can automatically migrate with Jest Codemods (see below).</source>
          <target state="translated">AVA, Expect.js (Automattic 별), Jasmine, Mocha, proxyquire, should.js 또는 Tape를 사용하는 경우 Jest Codemods (아래 참조)를 사용하여 자동으로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d950d3cb77c0e4d69b966651442d248b368ac31b" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, in the Jest run/debug configuration specify the path to the &lt;code&gt;react-scripts&lt;/code&gt; package in the Jest package field and add &lt;code&gt;--env=jsdom&lt;/code&gt; to the Jest options field.</source>
          <target state="translated">Facebook의 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt; &lt;code&gt;create-react-app&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 Jest 실행 / 디버그 구성 에서 Jest 패키지 필드에 &lt;code&gt;react-scripts&lt;/code&gt; 패키지 경로를 지정하고 &lt;code&gt;--env=jsdom&lt;/code&gt; 을 Jest 옵션 필드에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="04856c5821d9738bc23d4d6c7e49ea0d12a4e919" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, you can debug your Jest tests with the following configuration:</source>
          <target state="translated">Facebook의 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt; &lt;code&gt;create-react-app&lt;/code&gt; 를&lt;/a&gt; 사용하는 경우 다음 구성으로 Jest 테스트를 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="616d051e539968c48db9eb4e4947c7fe6ae3168c" translate="yes" xml:space="preserve">
          <source>If you are using Jasmine, or a Jasmine like API (for example &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt;), Jest should be mostly compatible, which makes it less complicated to migrate to.</source>
          <target state="translated">Jasmine 또는 API와 같은 Jasmine (예 : &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt; )을 사용하는 경우 Jest는 대부분 호환되므로 마이그레이션이 덜 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="6a321ef2867f26ae4a6883b3f6fd1258c705b7b4" translate="yes" xml:space="preserve">
          <source>If you define an ES6 class using the same filename as the mocked class in the &lt;code&gt;__mocks__&lt;/code&gt; folder, it will serve as the mock. This class will be used in place of the real class. This allows you to inject a test implementation for the class, but does not provide a way to spy on calls.</source>
          <target state="translated">&lt;code&gt;__mocks__&lt;/code&gt; 폴더 의 mocked 클래스와 동일한 파일 이름을 사용하여 ES6 클래스를 정의 하면 mock 역할을합니다. 이 클래스는 실제 클래스 대신 사용됩니다. 이를 통해 클래스에 대한 테스트 구현을 삽입 할 수 있지만 호출을 감시하는 방법은 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bed89a7be5b28b2da511d62933b8c9202a0453c7" translate="yes" xml:space="preserve">
          <source>If you don't need to replace the implementation of the class, this is the easiest option to set up. For example:</source>
          <target state="translated">클래스 구현을 교체 할 필요가없는 경우 가장 쉬운 설정 옵션입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="785c7b2fc6591165ae39c3fd7d429eea3e2c5ec8" translate="yes" xml:space="preserve">
          <source>If you end up mocking the same modules over and over it is recommended to define these mocks in a separate file and add it to the list of &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">동일한 모듈을 계속해서 모의하면 이러한 모의 파일을 별도의 파일로 정의하고 &lt;code&gt;setupFiles&lt;/code&gt; 목록에 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b5a9582bd8b87124ac313d453b396a39ddd21d21" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test.</source>
          <target state="translated">약속이 거부 될 것으로 예상되면 &lt;code&gt;.catch&lt;/code&gt; 메소드를 사용하십시오 . 특정 수의 어설 션이 호출되는지 확인하려면 &lt;code&gt;expect.assertions&lt;/code&gt; 를 추가하십시오 . 그렇지 않으면 이행 된 약속은 테스트에 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d508e058fa7773fc13858ed4af2eb2bbf552b483" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.rejects&lt;/code&gt; matcher. It works analogically to the &lt;code&gt;.resolves&lt;/code&gt; matcher. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">약속이 거부 될 것으로 예상되면 &lt;code&gt;.rejects&lt;/code&gt; 매처를 사용하십시오 . &lt;code&gt;.resolves&lt;/code&gt; 매처와 유사하게 작동합니다 . 약속이 이행되면 테스트는 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9919159eb0a5f34daf61334b02158349c4deb0ab" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;prettier&lt;/code&gt; installed in a location where Jest can't find it, you can tell Jest how to find it using the &lt;a href=&quot;configuration#prettierpath-string&quot;&gt;&lt;code&gt;&quot;prettierPath&quot;&lt;/code&gt;&lt;/a&gt; configuration property.</source>
          <target state="translated">당신이 경우 &lt;code&gt;prettier&lt;/code&gt; 농담이 그것을 찾을 수없는 위치에 설치, 당신은 사용하여 찾는 방법을 농담을 말할 수있다 &lt;a href=&quot;configuration#prettierpath-string&quot;&gt; &lt;code&gt;&quot;prettierPath&quot;&lt;/code&gt; &lt;/a&gt; 구성 속성을.</target>
        </trans-unit>
        <trans-unit id="5de2f8ea3278a9069dce525e3076d8f4531a1efb" translate="yes" xml:space="preserve">
          <source>If you have JavaScript files that are transformed by Babel, you can &lt;a href=&quot;getting-started#using-babel&quot;&gt;enable support for Babel&lt;/a&gt; by installing the &lt;code&gt;babel-jest&lt;/code&gt; plugin. Non-Babel JavaScript transformations can be handled with Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option.</source>
          <target state="translated">Babel에서 변환 한 JavaScript 파일이있는 경우 &lt;code&gt;babel-jest&lt;/code&gt; 플러그인 을 설치하여 &lt;a href=&quot;getting-started#using-babel&quot;&gt;Babel&lt;/a&gt; 을 지원할 수 있습니다 . Babel 이외의 JavaScript 변환은 Jest의 &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 구성 옵션을 사용 하여 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="7136dd51cf9e180f2a48ca203c9c72141190f47b" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenLastCalledWith&lt;/code&gt; to test what arguments it was last called with. For example, let's say you have a &lt;code&gt;applyToAllFlavors(f)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the last flavor it operates on is &lt;code&gt;'mango'&lt;/code&gt;. You can write:</source>
          <target state="translated">모의 함수가있는 경우 &lt;code&gt;.toHaveBeenLastCalledWith&lt;/code&gt; 를 사용 하여 마지막으로 호출 된 인수를 테스트 할 수 있습니다 . 예를 들어, &lt;code&gt;f&lt;/code&gt; 를 여러 가지 풍미에 적용 하는 &lt;code&gt;applyToAllFlavors(f)&lt;/code&gt; 함수가 있고, 호출 할 때 그것이 작동하는 마지막 풍미가 &lt;code&gt;'mango'&lt;/code&gt; 인지 확인하고 싶다고 가정 해 봅시다 . 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="0977c600c362140ee0f11a85d4e0e7f13e18104f" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenNthCalledWith&lt;/code&gt; to test what arguments it was nth called with. For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is &lt;code&gt;'lemon'&lt;/code&gt; and the second one is &lt;code&gt;'octopus'&lt;/code&gt;. You can write:</source>
          <target state="translated">모의 함수가있는 경우 &lt;code&gt;.toHaveBeenNthCalledWith&lt;/code&gt; 를 사용 하여 n 번째로 호출 된 인수를 테스트 할 수 있습니다 . 예를 들어, 여러 가지 풍미에 &lt;code&gt;f&lt;/code&gt; 를 적용 하는 &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; 함수가 있고, 호출 할 때 첫 번째 풍미가 &lt;code&gt;'lemon'&lt;/code&gt; 이고 두 번째는 &lt;code&gt;'octopus'&lt;/code&gt; 입니다. 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="993b27fa75c6ccc43f546084c9a5ed3da7f9f9a6" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveReturned&lt;/code&gt; to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="translated">mock 함수가있는 경우 &lt;code&gt;.toHaveReturned&lt;/code&gt; 를 사용 하여 mock 함수가 한 번 이상 성공적으로 리턴 (즉, 오류가 발생하지 않음)했는지 테스트 할 수 있습니다 . 예를 들어, &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모의 &lt;code&gt;drink&lt;/code&gt; 가 있다고 가정 해 봅시다 . 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="420b4fbe707501e81837408c0339f7b83dccab03" translate="yes" xml:space="preserve">
          <source>If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with &lt;code&gt;beforeEach&lt;/code&gt;. If you're not sure whether some shared state is being modified, you can also try a &lt;code&gt;beforeEach&lt;/code&gt; that logs data.</source>
          <target state="translated">더 큰 제품군의 일부로 실행될 때 종종 실패하는 테스트가 있지만 단독으로 실행할 때 실패하지 않는 경우 다른 테스트의 무언가 가이 테스트를 방해하는 것이 좋습니다. &lt;code&gt;beforeEach&lt;/code&gt; 로 일부 공유 상태를 지우면이 문제를 해결할 수 있습니다 . 일부 공유 상태가 수정되고 있는지 확실하지 않은 경우 데이터를 기록 하는 &lt;code&gt;beforeEach&lt;/code&gt; 를 시도 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74bc00736b265df97dcccbb952c16a808f51eb48" translate="yes" xml:space="preserve">
          <source>If you have an existing application you'll need to install a few packages to make everything work well together. We are using the &lt;code&gt;babel-jest&lt;/code&gt; package and the &lt;code&gt;react&lt;/code&gt; babel preset to transform our code inside of the test environment. Also see &lt;a href=&quot;getting-started#using-babel&quot;&gt;using babel&lt;/a&gt;.</source>
          <target state="translated">기존 애플리케이션이있는 경우 모든 것이 제대로 작동하도록 몇 가지 패키지를 설치해야합니다. 우리는 &lt;code&gt;babel-jest&lt;/code&gt; 패키지와 &lt;code&gt;react&lt;/code&gt; babel 프리셋을 사용하여 테스트 환경 내부에서 코드를 변환합니다. &lt;a href=&quot;getting-started#using-babel&quot;&gt;babel 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79990aa85d408f8fcea8c54e5341cb382a83ed88" translate="yes" xml:space="preserve">
          <source>If you have some work you need to do repeatedly for many tests, you can use &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt;.</source>
          <target state="translated">많은 테스트를 위해 반복적으로 수행해야 할 작업이 있으면 &lt;code&gt;beforeEach&lt;/code&gt; 및 &lt;code&gt;afterEach&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="756f402753805d9101cb2dc7198988431ec9ee20" translate="yes" xml:space="preserve">
          <source>If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (&lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;send a PR here&lt;/a&gt;) or if you would like to transfer your project to the jest-community org reachout to one of the owners of the org.</source>
          <target state="translated">공유 할만한 멋진 소식이 있으면 언제든지 문의 해주세요. 우리는 굉장한 농담 목록으로 프로젝트를 공유하고 싶 거나 ( &lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;여기에 PR을 보내십시오&lt;/a&gt; ) 프로젝트를 jest-community org에 연락하여 조직의 소유자 중 한 명에게 전달하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="9d7ae11f48e4c50b3df992e0eb7601afc5a6361a" translate="yes" xml:space="preserve">
          <source>If you know how to test something, &lt;code&gt;.not&lt;/code&gt; lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</source>
          <target state="translated">무언가를 테스트하는 방법을 알고 있다면 &lt;code&gt;.not&lt;/code&gt; 을 사용하면 반대의 테스트를 할 수 있습니다. 예를 들어,이 코드는 최고의 La Croix 맛이 코코넛이 아닌지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="55dbb4d3f311b3d4eb68e5741b0d897b72ccb8b5" translate="yes" xml:space="preserve">
          <source>If you like &lt;a href=&quot;http://chaijs.com/&quot;&gt;chai&lt;/a&gt;, you can upgrade to Jest and continue using chai. However, we recommend trying out Jest's assertions and their failure messages. Jest Codemods can migrate from chai (see below).</source>
          <target state="translated">&lt;a href=&quot;http://chaijs.com/&quot;&gt;chai&lt;/a&gt; 를 좋아한다면 Jest로 업그레이드하고 chai를 계속 사용할 수 있습니다. 그러나 Jest의 주장과 실패 메시지를 시험해 보는 것이 좋습니다. Jest Codemod는 chai에서 마이그레이션 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="64089c71545ac9398fafdb10bbce2181a2f6a753" translate="yes" xml:space="preserve">
          <source>If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using babel:</source>
          <target state="translated">고급 기능이 필요한 경우 자체 변압기를 구축 할 수도 있습니다. 다음은 babel-jest를 사용하는 대신 babel을 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="27cd566d23f6580c1572508d5f198d62212efb88" translate="yes" xml:space="preserve">
          <source>If you need to restrict your test-runner to only run in serial rather then being executed in parallel your class should have the property &lt;code&gt;isSerial&lt;/code&gt; to be set as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">테스트 실행기가 직렬로만 실행되는 대신 병렬로 실행되도록 제한해야하는 경우 클래스가 &lt;code&gt;isSerial&lt;/code&gt; 특성 을 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="352ca1b438b9b40e3f1f12e8c905d0575ee8ebf8" translate="yes" xml:space="preserve">
          <source>If you only need to run some setup code once, before any tests run, use &lt;code&gt;beforeAll&lt;/code&gt; instead.</source>
          <target state="translated">테스트를 실행하기 전에 설정 코드를 한 번만 실행 &lt;code&gt;beforeAll&lt;/code&gt; 경우 beforeAll을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a4cf1bd9be869094293df92f2ed1d79a4685bb2" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;npm test&lt;/code&gt;, you can still use the command line arguments by inserting a &lt;code&gt;--&lt;/code&gt; between &lt;code&gt;npm test&lt;/code&gt; and the Jest arguments.</source>
          <target state="translated">&lt;code&gt;npm test&lt;/code&gt; 를 통해 Jest를 실행하는 경우 &lt;code&gt;npm test&lt;/code&gt; 와 Jest 인수 사이 에 &lt;code&gt;--&lt;/code&gt; 를 삽입하여 명령 줄 인수를 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="786fc89b89e2b8432cf8d374c70aa7b7814df7b6" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;yarn test&lt;/code&gt;, you can pass the command line arguments directly as Jest arguments.</source>
          <target state="translated">&lt;code&gt;yarn test&lt;/code&gt; 를 통해 Jest를 실행하는 경우 명령 행 인수를 Jest 인수로 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e9b34c839f0bb4065cf0cbfa5620da9d41b2be8" translate="yes" xml:space="preserve">
          <source>If you use dynamic imports (&lt;code&gt;import('some-file.js').then(module =&amp;gt; ...)&lt;/code&gt;), you need to enable the &lt;code&gt;dynamic-import-node&lt;/code&gt; plugin.</source>
          <target state="translated">동적 가져 오기 ( &lt;code&gt;import('some-file.js').then(module =&amp;gt; ...)&lt;/code&gt; )를 사용하는 경우 &lt;code&gt;dynamic-import-node&lt;/code&gt; 플러그인 을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e9000a1baf94a23c5eda0e8f5bba72955e96ff9" translate="yes" xml:space="preserve">
          <source>If you want a path to be &lt;a href=&quot;#rootdir-string&quot;&gt;relative to the root directory of your project&lt;/a&gt;, please include &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; inside a path's string, like &lt;code&gt;&quot;&amp;lt;rootDir&amp;gt;/a-configs-folder&quot;&lt;/code&gt;.</source>
          <target state="translated">경로가 &lt;a href=&quot;#rootdir-string&quot;&gt;프로젝트의 루트 디렉토리를 기준으로하려면 &lt;/a&gt; &lt;code&gt;&quot;&amp;lt;rootDir&amp;gt;/a-configs-folder&quot;&lt;/code&gt; 와 같이 경로의 문자열 안에 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="554f70a642fd6f52b957f8ae2bf6f9d1be578ea3" translate="yes" xml:space="preserve">
          <source>If you want to inspect the cache, use &lt;code&gt;--showConfig&lt;/code&gt; and look at the &lt;code&gt;cacheDirectory&lt;/code&gt; value. If you need to clear the cache, use &lt;code&gt;--clearCache&lt;/code&gt;.</source>
          <target state="translated">캐시를 검사하려면 &lt;code&gt;--showConfig&lt;/code&gt; 를 사용 하고 &lt;code&gt;cacheDirectory&lt;/code&gt; 값을 확인하십시오. 캐시를 지우려면 &lt;code&gt;--clearCache&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fda82da214d4a1bfae2a873dff3fffc4c9acd8c" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup after every test instead of after all tests, use &lt;code&gt;afterEach&lt;/code&gt; instead.</source>
          <target state="translated">모든 테스트 후가 아닌 모든 테스트 후에 정리를 실행하려면 &lt;code&gt;afterEach&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e29fce9e0a98c7b27c220dc5f9e52e9dea70cc71" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup just once, after all of the tests run, use &lt;code&gt;afterAll&lt;/code&gt; instead.</source>
          <target state="translated">모든 테스트를 실행 한 후 정리를 한 번만 실행하려면 &lt;code&gt;afterAll&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="985cfb18842dcab5a2061f5fd939e231c11a1190" translate="yes" xml:space="preserve">
          <source>If you want to run something before every test instead of before any test runs, use &lt;code&gt;beforeEach&lt;/code&gt; instead.</source>
          <target state="translated">테스트를 실행하기 전에 모든 테스트 전에 무언가를 실행하려면 &lt;code&gt;beforeEach&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c7d4d719f894e809c49dafe7d06515e3345af1" translate="yes" xml:space="preserve">
          <source>If you want to test that a particular function throws an error when it's called, use &lt;code&gt;toThrow&lt;/code&gt;.</source>
          <target state="translated">특정 함수가 호출 될 때 오류가 발생하는지 테스트하려면 &lt;code&gt;toThrow&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa479dc2989b39264cd671e2e1b01fc3bc865c73" translate="yes" xml:space="preserve">
          <source>If you'd like to assert, and manipulate your rendered components you can use &lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt;, &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, or React's &lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;TestUtils&lt;/a&gt;. The following two examples use react-testing-library and Enzyme.</source>
          <target state="translated">렌더링 된 구성 요소를 주장하고 조작하려면 &lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt; , &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt; 또는 React의 &lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;TestUtils를 사용할 수&lt;/a&gt; 있습니다. 다음 두 예제는 react-testing-library 및 Enzyme을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e5abb36c3cf78ade7ac7c3e61eaa1bf15a7a6cf" translate="yes" xml:space="preserve">
          <source>If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:</source>
          <target state="translated">babel을 지원하는 변환기를 빌드하려면 babel-jest를 사용하여 하나를 작성하고 사용자 정의 구성 옵션을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe8837a1b877e57fa5d26c99f5f76765b57c8f1" translate="yes" xml:space="preserve">
          <source>If you'd like to learn more about running &lt;code&gt;jest&lt;/code&gt; through the command line, take a look at the &lt;a href=&quot;cli&quot;&gt;Jest CLI Options&lt;/a&gt; page.</source>
          <target state="translated">명령 행을 통해 &lt;code&gt;jest&lt;/code&gt; 를 실행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;cli&quot;&gt;Jest CLI 옵션&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b70976c9786f6bb152f5a17847893b3ea57a99e" translate="yes" xml:space="preserve">
          <source>If you'd like to limit which snapshot test cases get re-generated, you can pass an additional &lt;code&gt;--testNamePattern&lt;/code&gt; flag to re-record snapshots only for those tests that match the pattern.</source>
          <target state="translated">다시 생성되는 스냅 샷 테스트 사례를 제한하려면 추가 &lt;code&gt;--testNamePattern&lt;/code&gt; 플래그를 전달 하여 패턴과 일치하는 테스트에 대해서만 스냅 샷을 다시 기록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="493e22a5ff7ebb1b0bac76ca20348fbec098ff61" translate="yes" xml:space="preserve">
          <source>If you'd like to provide additional configuration for every test file, the &lt;a href=&quot;configuration#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt; configuration option&lt;/a&gt; can be used to specify setup scripts.</source>
          <target state="translated">모든 테스트 파일에 추가 구성을 제공하려면 &lt;a href=&quot;configuration#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; 구성 옵션&lt;/a&gt; 을 사용하여 설정 스크립트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="904d7d5dbe5dfb9936b463c8afc5fd6ef73f873b" translate="yes" xml:space="preserve">
          <source>If you'd like to test timers, like &lt;code&gt;setTimeout&lt;/code&gt;, take a look at the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;setTimeout&lt;/code&gt; 과 같은 타이머를 테스트 하려면 &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; 설명서를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="41daa174187a45b7973b50bb5da3fd6d898d179a" translate="yes" xml:space="preserve">
          <source>If you'd like to try out Jest with an existing codebase, there are a number of ways to convert to Jest:</source>
          <target state="translated">기존 코드베이스로 Jest를 사용 해보고 싶다면 Jest로 변환하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="829c5ae35e9a8ea6d6ab4a39e712800c72de37bf" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES module imports&lt;/a&gt; then you'll normally be inclined to put your &lt;code&gt;import&lt;/code&gt; statements at the top of the test file. But often you need to instruct Jest to use a mock before modules use it. For this reason, Jest will automatically hoist &lt;code&gt;jest.mock&lt;/code&gt; calls to the top of the module (before any imports). To learn more about this and see it in action, see &lt;a href=&quot;https://github.com/kentcdodds/how-jest-mocking-works&quot;&gt;this repo&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES 모듈 가져 오기&lt;/a&gt; 를 사용하는 경우 일반적으로 &lt;code&gt;import&lt;/code&gt; 문을 테스트 파일 맨 위에 놓는 경향이 있습니다. 그러나 종종 모듈을 사용하기 전에 모의를 사용하도록 Jest에 지시해야합니다. 이러한 이유로 Jest는 &lt;code&gt;jest.mock&lt;/code&gt; 호출을 모듈 상단으로 가져옵니다 (가져 오기 전). 이것에 대해 더 배우고 실제로 그것을 보려면, &lt;a href=&quot;https://github.com/kentcdodds/how-jest-mocking-works&quot;&gt;이 저장소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d61bfdc856da28f2e5fd6d45fca8df20622b57a" translate="yes" xml:space="preserve">
          <source>If your code uses promises, there is a more straightforward way to handle asynchronous tests. Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">코드에서 약속을 사용하는 경우 비동기 테스트를 처리하는보다 간단한 방법이 있습니다. 테스트에서 약속을 반환하면 Jest는 해당 약속이 해결 될 때까지 기다립니다. 약속이 거부되면 테스트는 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ccb7cf87b9a1da1c03f262e7f2f52beaa2385481" translate="yes" xml:space="preserve">
          <source>If your test is long running, you may want to consider to increase the timeout by calling &lt;code&gt;jest.setTimeout&lt;/code&gt;</source>
          <target state="translated">테스트가 오래 실행되는 경우 &lt;code&gt;jest.setTimeout&lt;/code&gt; 을 호출하여 시간 초과를 늘리는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83f3aae12099b7ddfe3f20a402b497229b2307ab" translate="yes" xml:space="preserve">
          <source>Import the mock and the mock method shared by all instances:</source>
          <target state="translated">모든 인스턴스가 공유하는 mock 및 mock 메소드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="14b1c9735c1b7f4127af7d7ab27db5831ecb658c" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are six falsy values: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt;. Everything else is truthy.</source>
          <target state="translated">JavaScript에는 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 의 6 가지 잘못된 값이 있습니다 . 다른 모든 것은 진실입니다.</target>
        </trans-unit>
        <trans-unit id="8c4ae4f10df6814e92150ee1c7d3a629a5d7abd0" translate="yes" xml:space="preserve">
          <source>In depth: Understanding mock constructor functions</source>
          <target state="translated">심도 : 모의 생성자 함수 이해</target>
        </trans-unit>
        <trans-unit id="4abc59ae50f9e935393cdb945f05ee449764bb87" translate="yes" xml:space="preserve">
          <source>In order to do this you can run tests in the same thread using &lt;a href=&quot;cli#--runinband&quot;&gt;&lt;code&gt;--runInBand&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이를 위해 &lt;a href=&quot;cli#--runinband&quot;&gt; &lt;code&gt;--runInBand&lt;/code&gt; 를&lt;/a&gt; 사용하여 동일한 스레드에서 테스트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="996bbd139f692ff1674caffb9c1a201da9541db8" translate="yes" xml:space="preserve">
          <source>In order to mock a constructor function, the module factory must return a constructor function. In other words, the module factory must be a function that returns a function - a higher-order function (HOF).</source>
          <target state="translated">생성자 함수를 조롱하려면 모듈 팩토리가 생성자 함수를 리턴해야합니다. 다시 말해, 모듈 팩토리는 고차 함수 (HOF) 인 함수를 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="644861976bcc490e61ef690742a524fc490ebdcc" translate="yes" xml:space="preserve">
          <source>In order to track calls to the constructor, replace the function returned by the HOF with a Jest mock function. Create it with &lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt;&lt;code&gt;jest.fn()&lt;/code&gt;&lt;/a&gt;, and then specify its implementation with &lt;code&gt;mockImplementation()&lt;/code&gt;.</source>
          <target state="translated">생성자에 대한 호출을 추적하려면 HOF가 리턴 한 함수를 Jest 모의 함수로 바꾸십시오. &lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt; &lt;code&gt;jest.fn()&lt;/code&gt; &lt;/a&gt; 생성 한 다음 &lt;code&gt;mockImplementation()&lt;/code&gt; 구현을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="00fe50509a9a46b66c2c06f2fc7d147da1de4215" translate="yes" xml:space="preserve">
          <source>In other cases you may want to mock a native module that isn't a React component. The same technique can be applied. We recommend inspecting the native module's source code and logging the module when running a react native app on a real device and then modeling a manual mock after the real module.</source>
          <target state="translated">다른 경우에는 React 컴포넌트가 아닌 기본 모듈을 조롱하고 싶을 수도 있습니다. 동일한 기술을 적용 할 수 있습니다. 실제 장치에서 반응 네이티브 앱을 실행 한 다음 실제 모듈 다음에 수동 모형을 모델링 할 때 기본 모듈의 소스 코드를 검사하고 모듈을 로깅하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9102da2371047bd722d0b515b5551f478299aa99" translate="yes" xml:space="preserve">
          <source>In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides &lt;code&gt;beforeAll&lt;/code&gt; and &lt;code&gt;afterAll&lt;/code&gt; to handle this situation.</source>
          <target state="translated">경우에 따라 파일 시작 부분에 한 번만 설정하면됩니다. 설정이 비동기 인 경우 특히 귀찮을 수 있으므로 인라인으로 수행 할 수 없습니다. Jest는 &lt;code&gt;beforeAll&lt;/code&gt; 과 &lt;code&gt;afterAll&lt;/code&gt; 을 제공 하여이 상황을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a0b6c9124da9d2f164e70d048eada927d7685f3e" translate="yes" xml:space="preserve">
          <source>In tests you sometimes need to distinguish between &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.</source>
          <target state="translated">테스트에서 때로는 &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 를 구별해야 하지만 때로는 다르게 취급하지 않으려는 경우가 있습니다. Jest에는 원하는 것을 명시 적으로 알려주는 도우미가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c9ae4862f96e5c36ede5f6a99e2b3637ee320d7" translate="yes" xml:space="preserve">
          <source>In that case, Jest will print this output:</source>
          <target state="translated">이 경우 Jest는 다음 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5e505a4fa07187d3e2baaecd5d93fb006995c7f2" translate="yes" xml:space="preserve">
          <source>In the WebStorm menu &lt;code&gt;Run&lt;/code&gt; select &lt;code&gt;Edit Configurations...&lt;/code&gt;. Then click &lt;code&gt;+&lt;/code&gt; and select &lt;code&gt;Jest&lt;/code&gt;. Optionally specify the Jest configuration file, additional options, and environment variables. Save the configuration, put the breakpoints in the code, then click the green debug icon to start debugging.</source>
          <target state="translated">WebStorm 메뉴 &lt;code&gt;Run&lt;/code&gt; 에서 &lt;code&gt;Edit Configurations...&lt;/code&gt; 선택 하십시오 . 그런 다음 &lt;code&gt;+&lt;/code&gt; 를 클릭 하고 &lt;code&gt;Jest&lt;/code&gt; 를 선택하십시오 . 선택적으로 Jest 구성 파일, 추가 옵션 및 환경 변수를 지정하십시오. 구성을 저장하고 중단 점을 코드에 넣은 다음 녹색 디버그 아이콘을 클릭하여 디버깅을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7d0bc725310d5e7375a0939302ec84996aaee195" translate="yes" xml:space="preserve">
          <source>In the above implementation we expect the &lt;code&gt;request.js&lt;/code&gt; module to return a promise. We chain a call to &lt;code&gt;then&lt;/code&gt; to receive the user name.</source>
          <target state="translated">위의 구현에서 &lt;code&gt;request.js&lt;/code&gt; 모듈이 약속을 반환 할 것으로 예상합니다 . 우리는 할 수있는 호출 체인 &lt;code&gt;then&lt;/code&gt; 사용자 이름을 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="570678fe1ed00ace674c0422a21ff689d587c77f" translate="yes" xml:space="preserve">
          <source>In these cases, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are effectively syntactic sugar for the same logic as the promises example uses.</source>
          <target state="translated">이 경우 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 는 약속 예제에서 사용하는 것과 동일한 논리에 대한 효과적인 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="3642d4f1c233bd882101f40614b17fbab7b0347a" translate="yes" xml:space="preserve">
          <source>In these rare scenarios you can use this API to manually fill the slot in the module system's mock-module registry.</source>
          <target state="translated">이 드문 시나리오에서는이 API를 사용하여 모듈 시스템의 모의 모듈 레지스트리에서 슬롯을 수동으로 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b652f7f89176ede040fc45adab5e36634e53950" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;toBe&lt;/code&gt; is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things.</source>
          <target state="translated">이 경우 &lt;code&gt;toBe&lt;/code&gt; 는 매처 함수입니다. 다른 것들을 테스트하는 데 도움을주기 위해 아래에 문서화 된 다양한 매칭 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="182fda0d71d0e8cdad09e61c342e4da86b15010a" translate="yes" xml:space="preserve">
          <source>In this case, mocking &lt;code&gt;matchMedia&lt;/code&gt; in the test file should solve the issue:</source>
          <target state="translated">이 경우 테스트 파일에서 &lt;code&gt;matchMedia&lt;/code&gt; 를 조롱 하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3f7577284c9c32a0e3ee6553d857ff29f2f2e7" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;expect(2 + 2)&lt;/code&gt; returns an &quot;expectation&quot; object. You typically won't do much with these expectation objects except call matchers on them. In this code, &lt;code&gt;.toBe(4)&lt;/code&gt; is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.</source>
          <target state="translated">이 코드에서 &lt;code&gt;expect(2 + 2)&lt;/code&gt; 는 &quot;expectation&quot;객체를 반환합니다. 일반적으로 콜 매처를 제외하고 이러한 기대 오브젝트로 많은 작업을 수행하지 않습니다. 이 코드에서 &lt;code&gt;.toBe(4)&lt;/code&gt; 는 매처입니다. Jest가 실행되면 모든 실패한 매처를 추적하여 멋진 오류 메시지를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcf71eeb459fb4f43d233569cc094471a4a5833" translate="yes" xml:space="preserve">
          <source>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them.</source>
          <target state="translated">테스트 파일에서 Jest는 이러한 각 메소드와 오브젝트를 글로벌 환경에 넣습니다. 사용하기 위해 아무것도 요구하거나 가져 오지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="0e834252f464672f1c1dbeae76506145773ea65a" translate="yes" xml:space="preserve">
          <source>Indicates that test coverage information should be collected and reported in the output. This option is also aliased by &lt;code&gt;--collectCoverage&lt;/code&gt;.</source>
          <target state="translated">테스트 범위 정보가 출력에서 ​​수집 및보고되어야 함을 나타냅니다. 이 옵션은 &lt;code&gt;--collectCoverage&lt;/code&gt; 에 의해 별칭이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1284d31f44064613a87f5368a4ace1fc81c96bbe" translate="yes" xml:space="preserve">
          <source>Indicates that the module system should never return a mocked version of the specified module from &lt;code&gt;require()&lt;/code&gt; (e.g. that it should always return the real module).</source>
          <target state="translated">모듈 시스템이 &lt;code&gt;require()&lt;/code&gt; 에서 지정된 모듈의 모의 버전을 반환해서는 안됨을 나타냅니다 (예 : 항상 실제 모듈을 반환해야 함).</target>
        </trans-unit>
        <trans-unit id="525344995f960a29bbb0a0780b82869722611218" translate="yes" xml:space="preserve">
          <source>Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.</source>
          <target state="translated">실행 중에 각 개별 테스트를보고해야하는지 여부를 나타냅니다. 실행 후에도 모든 오류가 여전히 맨 아래에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae4810b9c6deb3cfc560d1b8be11be54439818a5" translate="yes" xml:space="preserve">
          <source>Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.</source>
          <target state="translated">테스트를 실행하는 동안 적용 범위 정보를 수집해야하는지 여부를 나타냅니다. 이로 인해 실행 콜렉션이 모두 포함 된 모든 실행 파일에 적용되므로 테스트 속도가 크게 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2ffcf9de303be59af5e2e722fc87828180290e8" translate="yes" xml:space="preserve">
          <source>Injecting a test implementation is helpful, but you will probably also want to test whether the class constructor and methods are called with the correct parameters.</source>
          <target state="translated">테스트 구현을 주입하면 도움이되지만 클래스 생성자와 메서드가 올바른 매개 변수로 호출되는지 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16df8c50d3d5dd63ff045ec5082a89d1d9864d9" translate="yes" xml:space="preserve">
          <source>Inline Snapshots</source>
          <target state="translated">인라인 스냅 샷</target>
        </trans-unit>
        <trans-unit id="db4c16bd16f6d824e3ae08925279ff7d80be7fa7" translate="yes" xml:space="preserve">
          <source>Inline snapshots are powered by &lt;a href=&quot;https://prettier.io&quot;&gt;Prettier&lt;/a&gt;. To use inline snapshots you must have &lt;code&gt;prettier&lt;/code&gt; installed in your project. Your Prettier configuration will be respected when writing to test files.</source>
          <target state="translated">인라인 스냅 샷은 &lt;a href=&quot;https://prettier.io&quot;&gt;Prettier에&lt;/a&gt; 의해 구동됩니다 . 인라인 스냅 샷을 사용하려면 프로젝트에 &lt;code&gt;prettier&lt;/code&gt; 설치되어 있어야합니다 . 테스트 파일에 쓸 때 Prettier 구성이 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="8634b51371ce9727d167fddae91a84b3084a1895" translate="yes" xml:space="preserve">
          <source>Inline snapshots behave identically to external snapshots (&lt;code&gt;.snap&lt;/code&gt; files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.</source>
          <target state="translated">인라인 스냅 샷 은 스냅 샷 값이 소스 코드에 자동으로 다시 쓰여지는 것을 제외하고 외부 스냅 샷 ( &lt;code&gt;.snap&lt;/code&gt; 파일) 과 동일하게 작동합니다 . 즉, 올바른 값을 기록하기 위해 외부 파일로 전환하지 않고도 자동 생성 된 스냅 샷의 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e94217fdf7438c2ec9d5e4178c873dbfe79b8612" translate="yes" xml:space="preserve">
          <source>Install Jest using &lt;a href=&quot;https://yarnpkg.com/en/package/jest&quot;&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://yarnpkg.com/en/package/jest&quot;&gt; &lt;code&gt;yarn&lt;/code&gt; &lt;/a&gt; 사용하여 Jest를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="6092d383d1cc73be163afe7eb2ce1f7872844a2a" translate="yes" xml:space="preserve">
          <source>Instead of literal property values in the expected object, you can use matchers, &lt;code&gt;expect.anything()&lt;/code&gt;, and so on.</source>
          <target state="translated">예상 개체의 리터럴 속성 값 대신 matcher, &lt;code&gt;expect.anything()&lt;/code&gt; 등을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="9cc2a78e6bbcf2a24971feabf0515729dc411624" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;.toBeCloseTo&lt;/code&gt;. Use &lt;code&gt;numDigits&lt;/code&gt; to control how many digits after the decimal point to check. For example, if you want to be sure that &lt;code&gt;0.2 + 0.1&lt;/code&gt; is equal to &lt;code&gt;0.3&lt;/code&gt; with a precision of 5 decimal digits, you can use this test:</source>
          <target state="translated">대신 &lt;code&gt;.toBeCloseTo&lt;/code&gt; 를 사용 하십시오 . &lt;code&gt;numDigits&lt;/code&gt; 를 사용 하여 확인할 소수점 이하 자릿수를 제어하십시오. 예를 들어, 소수점 이하 5 자리의 정밀도로 &lt;code&gt;0.2 + 0.1&lt;/code&gt; 이 &lt;code&gt;0.3&lt;/code&gt; 과 같은지 확인 하려면이 테스트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4c0946e29e0677ed77927a5a5b8175e597a81b" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use fake versions of the standard timer functions (&lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;, &lt;code&gt;nextTick&lt;/code&gt;, &lt;code&gt;setImmediate&lt;/code&gt; and &lt;code&gt;clearImmediate&lt;/code&gt;).</source>
          <target state="translated">Jest에게 표준 타이머 함수의 가짜 버전 ( &lt;code&gt;setTimeout&lt;/code&gt; , &lt;code&gt;setInterval&lt;/code&gt; , &lt;code&gt;clearTimeout&lt;/code&gt; , &lt;code&gt;clearInterval&lt;/code&gt; , &lt;code&gt;nextTick&lt;/code&gt; , &lt;code&gt;setImmediate&lt;/code&gt; 및 &lt;code&gt;clearImmediate&lt;/code&gt; )을 사용 하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="53f0e89b734a053251bf9ba130c561bca653f2ca" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use the real versions of the standard timer functions.</source>
          <target state="translated">Jest에게 실제 버전의 표준 타이머 기능을 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="580b09d323b391c56988f3afd1aa0348c802898c" translate="yes" xml:space="preserve">
          <source>Interactive Snapshot Mode</source>
          <target state="translated">대화식 스냅 샷 모드</target>
        </trans-unit>
        <trans-unit id="02513dac2749bb0bea9a23e68783f2f1b43824b8" translate="yes" xml:space="preserve">
          <source>Is it possible to apply test-driven development principles with snapshot testing?</source>
          <target state="translated">스냅 샷 테스트로 테스트 중심 개발 원칙을 적용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9055c96fbca9c47e000ff8c108ec23e99fdd71fc" translate="yes" xml:space="preserve">
          <source>It fails because in JavaScript, &lt;code&gt;0.2 + 0.1&lt;/code&gt; is actually &lt;code&gt;0.30000000000000004&lt;/code&gt;. Sorry.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;0.2 + 0.1&lt;/code&gt; 이 실제로 &lt;code&gt;0.30000000000000004&lt;/code&gt; 이므로 실패합니다 . 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="7f735d98c06c220d11d75c5397c9c1b8e52c4d4d" translate="yes" xml:space="preserve">
          <source>It is possible to override this setting in individual tests by explicitly calling &lt;code&gt;jest.mock()&lt;/code&gt; at the top of the test file.</source>
          <target state="translated">테스트 파일 맨 위에서 &lt;code&gt;jest.mock()&lt;/code&gt; 을 명시 적으로 호출하여 개별 테스트에서이 설정을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7f0fe9fa2e98d6b45b7e85870b6bebb4244c0e" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expect.arrayContaining&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="6fa06d234ccf0592e6a7833abb4b44564a10ce20" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.objectContaining&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expect.objectContaining&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="6c45932d1b92f754d3092dcfc07a259652cb482f" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringContaining&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expect.stringContaining&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="56fdb83f46a304e9e8a0b0082332d015e93ccfd5" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringMatching&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expect.stringMatching&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="32d71d3a81131ff51abfd443e0210b69c77cfc06" translate="yes" xml:space="preserve">
          <source>It's also worth noting that &lt;code&gt;setupFiles&lt;/code&gt; will execute &lt;em&gt;before&lt;/em&gt;&lt;a href=&quot;#setupfilesafterenv-array&quot;&gt;&lt;code&gt;setupFilesAfterEnv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;setupFiles&lt;/code&gt; 가 &lt;a href=&quot;#setupfilesafterenv-array&quot;&gt; &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 전에&lt;/em&gt; 실행 된다는 점도 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e57c75a59ba04722961a96e662337fe62d32cd4" translate="yes" xml:space="preserve">
          <source>It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.</source>
          <target state="translated">코드가 비동기 적으로 실행되는 것은 JavaScript에서 일반적입니다. 비동기 적으로 실행되는 코드가있는 경우 Jest는 다른 테스트로 넘어 가기 전에 테스트중인 코드가 완료된시기를 알아야합니다. Jest는 여러 가지 방법으로이를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e568a9bbdb9a0508a3a3ef0e439e109837c0942f" translate="yes" xml:space="preserve">
          <source>It's easier to understand this with an example. Let's say you have a method &lt;code&gt;bestLaCroixFlavor()&lt;/code&gt; which is supposed to return the string &lt;code&gt;'grapefruit'&lt;/code&gt;. Here's how you would test that:</source>
          <target state="translated">예를 들어 이것을 이해하는 것이 더 쉽습니다. 문자열 &lt;code&gt;'grapefruit'&lt;/code&gt; 를 반환하는 &lt;code&gt;bestLaCroixFlavor()&lt;/code&gt; 메소드가 있다고 가정 해 봅시다 . 테스트하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="667bf8c3b168c667f3639da763c2b5c80fb59070" translate="yes" xml:space="preserve">
          <source>It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.</source>
          <target state="translated">버그가 도입 된 후 스냅 샷 테스트가 실패하면 쉽게 알 수 있습니다. 이 경우 문제를 해결하고 스냅 샷 테스트가 다시 통과하는지 확인하십시오. 이제 의도적 인 구현 변경으로 인해 스냅 샷 테스트가 실패한 경우에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="4f48cbea09ae54f44848cf5913f3a8fd18dc1890" translate="yes" xml:space="preserve">
          <source>Jest 24 dropped support for Babel 6. We highly recommend you to upgrade to Babel 7, which is actively maintained. However, if you cannot upgrade to Babel 7, either keep using Jest 23 or upgrade to Jest 24 with &lt;code&gt;babel-jest&lt;/code&gt; locked at version 23, like in the example below:</source>
          <target state="translated">Jest 24는 Babel 6에 대한 지원을 중단했습니다. 적극적으로 유지 관리되는 Babel 7로 업그레이드하는 것이 좋습니다. 그러나 Babel 7로 업그레이드 할 수없는 경우 아래 예와 같이 Jest 23을 계속 사용하거나 버전 23에서 &lt;code&gt;babel-jest&lt;/code&gt; 가 잠긴 상태에서 Jest 24로 업그레이드 하십시오.</target>
        </trans-unit>
        <trans-unit id="3c37bbcc2dc087e83d511674c69f117488f9a448" translate="yes" xml:space="preserve">
          <source>Jest CLI Options</source>
          <target state="translated">Jest CLI 옵션</target>
        </trans-unit>
        <trans-unit id="7b0763aa90e25f9dc7844da6152ce6f3059ffcb2" translate="yes" xml:space="preserve">
          <source>Jest Community</source>
          <target state="translated">농담 커뮤니티</target>
        </trans-unit>
        <trans-unit id="ea58238fa3c595c1ac8d7fc4a688da21db96450d" translate="yes" xml:space="preserve">
          <source>Jest Platform</source>
          <target state="translated">농담 플랫폼</target>
        </trans-unit>
        <trans-unit id="b4848b4fe1132599637029a65960f94eb8531822" translate="yes" xml:space="preserve">
          <source>Jest adds the &lt;code&gt;inlineSnapshot&lt;/code&gt; string argument to the matcher in the test file (instead of an external &lt;code&gt;.snap&lt;/code&gt; file) the first time that the test runs.</source>
          <target state="translated">Jest는 테스트를 &lt;code&gt;inlineSnapshot&lt;/code&gt; 때 inlineSnapshot 문자열 인수를 테스트 파일 (외부 &lt;code&gt;.snap&lt;/code&gt; 파일 대신)의 매처에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7a0d7242dfd96ba5446eb996644a2e93256965b7" translate="yes" xml:space="preserve">
          <source>Jest allows third-party plugins to override some of its built-in feature keys, but not all. Specifically, the following keys are &lt;strong&gt;not overwritable&lt;/strong&gt; :</source>
          <target state="translated">Jest를 사용하면 타사 플러그인이 내장 기능 키 중 일부를 무시할 수 있지만 전부는 아닙니다. 특히 다음 키는 &lt;strong&gt;덮어 쓸&lt;/strong&gt; 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3db4e21502b1cf82fe4554f5a22adc84d4239482" translate="yes" xml:space="preserve">
          <source>Jest allows you to mock out whole modules in your tests, which can be useful for testing if your code is calling functions from that module correctly. However, sometimes you may want to use parts of a mocked module in your &lt;em&gt;test file&lt;/em&gt;, in which case you want to access the original implementation, rather than a mocked version.</source>
          <target state="translated">Jest를 사용하면 테스트에서 전체 모듈을 모방하여 코드가 해당 모듈에서 함수를 올바르게 호출하는지 테스트하는 데 유용 할 수 있습니다. 그러나 때로는 &lt;em&gt;테스트 파일&lt;/em&gt; 에서 조롱 모듈의 일부를 사용하려고 할 수도 있습니다 .이 경우 조롱 버전이 아닌 원래 구현에 액세스하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a926667eb8c4ae03b1d94701be16eb503a21b695" translate="yes" xml:space="preserve">
          <source>Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem raking that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.</source>
          <target state="translated">Jest는 테스트를 실행하는 동안 발생해야하는 파일 시스템 긁힘을 완화하기 위해 종속성 트리를 한 번 (사전) 스캔하고 캐시합니다. 이 구성 옵션을 사용하면 Jest가 디스크에서 데이터를 캐시하는 위치를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7217bf7214933a525b967deb724c6b9162cbf15e" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack &lt;em&gt;does&lt;/em&gt; offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.</source>
          <target state="translated">Jest는 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;웹팩&lt;/a&gt; 을 사용 하여 자산, 스타일 및 컴파일을 관리 하는 프로젝트에서 사용할 수 있습니다 . 웹팩 &lt;em&gt;은&lt;/em&gt; 다른 툴에 비해 몇 가지 고유 한 문제를 제공합니다. 애플리케이션과 직접 통합되어 스타일 시트, 이미지 및 글꼴과 같은 자산을 관리하고 광범위한 자바 스크립트 컴파일 언어 및 툴 에코 시스템을 관리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="03f07f770f308cce4d6d71cf7a65755091125d70" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the &lt;a href=&quot;webpack&quot;&gt;webpack guide&lt;/a&gt; to get started.</source>
          <target state="translated">Jest는 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;웹팩&lt;/a&gt; 을 사용 하여 자산, 스타일 및 컴파일을 관리 하는 프로젝트에서 사용할 수 있습니다 . webpack은 다른 도구보다 고유 한 문제를 제공합니다. 시작 하려면 &lt;a href=&quot;webpack&quot;&gt;웹팩 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e1f86ef9ac3ba9a1094e45789f0246c03864424" translate="yes" xml:space="preserve">
          <source>Jest can be used to mock ES6 classes that are imported into files you want to test.</source>
          <target state="translated">Jest를 사용하여 테스트하려는 파일로 가져온 ES6 클래스를 조롱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf92262b3a746cb5cadf84ee52757121913d4bb5" translate="yes" xml:space="preserve">
          <source>Jest configuration:</source>
          <target state="translated">농담 구성 :</target>
        </trans-unit>
        <trans-unit id="d3875a4b049058d09ee11ad3b9257c6fc76e7609" translate="yes" xml:space="preserve">
          <source>Jest executes all describe handlers in a test file &lt;em&gt;before&lt;/em&gt; it executes any of the actual tests. This is another reason to do setup and teardown inside &lt;code&gt;before*&lt;/code&gt; and &lt;code&gt;after*&lt;/code&gt; handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.</source>
          <target state="translated">Jest 는 실제 테스트를 실행 &lt;em&gt;하기 전에&lt;/em&gt; 테스트 파일에서 모든 설명 핸들러를 실행합니다. 이것이 describe 블록이 아닌 &lt;code&gt;before*&lt;/code&gt; 및 &lt;code&gt;after*&lt;/code&gt; 핸들러 내부에서 설정 및 해제를 수행하는 또 다른 이유 입니다. describe 블록이 완료되면 기본적으로 Jest는 수집 단계에서 발생한 순서대로 모든 테스트를 순차적으로 실행하여 각 테스트가 완료되기를 기다렸다가 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="0de3feadb801fdfceabb49f311df02bb3d2e6317" translate="yes" xml:space="preserve">
          <source>Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the &lt;code&gt;toMatchSnapshot&lt;/code&gt; matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.</source>
          <target state="translated">Jest는 성능을 고려하여 다시 작성되었으며 스냅 샷 테스트도 예외는 아닙니다. 스냅 샷은 텍스트 파일 내에 저장되므로이 테스트 방법은 빠르고 안정적입니다. Jest는 &lt;code&gt;toMatchSnapshot&lt;/code&gt; 매처 를 호출하는 각 테스트 파일에 대해 새 파일을 생성합니다 . 스냅 샷의 크기는 매우 작습니다. 참고로 Jest 코드베이스 자체의 모든 스냅 샷 파일의 크기는 300KB 미만입니다.</target>
        </trans-unit>
        <trans-unit id="d3cecfbd4eff60247088ea6ea3e4cdcc4eadc368" translate="yes" xml:space="preserve">
          <source>Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See &lt;a href=&quot;tutorial-react-native#snapshot-test&quot;&gt;snapshot test tutorial&lt;/a&gt; for more information.</source>
          <target state="translated">Jest에는 기본 제공 JavaScript 유형, HTML 요소 (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) 및 React 요소에 대한 기본 직렬 변환기가 있습니다. 자세한 정보는 &lt;a href=&quot;tutorial-react-native#snapshot-test&quot;&gt;스냅 샷 테스트 학습서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8f3b08f9e746db06cf8a8d8eb1728a20518b9e" translate="yes" xml:space="preserve">
          <source>Jest hooks can be attached by implementing the &lt;code&gt;apply&lt;/code&gt; method. This method receives a &lt;code&gt;jestHooks&lt;/code&gt; argument that allows the plugin to hook into specific parts of the lifecycle of a test run.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 메소드 를 구현하여 Jest 후크를 연결할 수 있습니다 . 이 메소드는 플러그인이 테스트 실행 라이프 사이클의 특정 부분에 연결되도록 하는 &lt;code&gt;jestHooks&lt;/code&gt; 인수를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="78961166274ac390b7c628a0f785ac9679ec16ba" translate="yes" xml:space="preserve">
          <source>Jest supports TypeScript, via Babel. First make sure you followed the instructions on &lt;a href=&quot;#using-babel&quot;&gt;using Babel&lt;/a&gt; above. Next install the &lt;code&gt;@babel/preset-typescript&lt;/code&gt; via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">Jest는 Babel을 통해 TypeScript를 지원합니다. 먼저 위의 &lt;a href=&quot;#using-babel&quot;&gt;Babel 사용&lt;/a&gt; 지침을 따르십시오 . 다음으로 &lt;code&gt;yarn&lt;/code&gt; 을 통해 &lt;code&gt;@babel/preset-typescript&lt;/code&gt; 를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="df084822eb105d3a7a4cf3edd0cec8b8b50c092a" translate="yes" xml:space="preserve">
          <source>Jest supports both camelcase and dashed arg formats. The following examples will have equal result:</source>
          <target state="translated">Jest는 camelcase 및 대시 arg 형식을 모두 지원합니다. 다음 예제는 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a26bd9497d9f62beebdda3158cf8b5bcd46589c3" translate="yes" xml:space="preserve">
          <source>Jest takes advantage of new features added to Node 6. We recommend that you upgrade to the latest stable release of Node. The minimum supported version is &lt;code&gt;v6.0.0&lt;/code&gt;. Versions &lt;code&gt;0.x.x&lt;/code&gt; and &lt;code&gt;4.x.x&lt;/code&gt; are not supported because the &lt;code&gt;jsdom&lt;/code&gt; version used in Jest doesn't support Node 4. However, if you need to run Jest on Node 4, you can use the &lt;code&gt;testEnvironment&lt;/code&gt; config to use a &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;custom environment&lt;/a&gt; that supports Node 4, such as &lt;a href=&quot;https://yarnpkg.com/en/package/jest-environment-node&quot;&gt;&lt;code&gt;jest-environment-node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Jest는 Node 6에 추가 된 새로운 기능을 활용합니다. 최신 안정 버전의 Node로 업그레이드하는 것이 좋습니다. 지원되는 최소 버전은 &lt;code&gt;v6.0.0&lt;/code&gt; 입니다. Jest에서 사용되는 &lt;code&gt;jsdom&lt;/code&gt; 버전은 노드 4를 지원하지 않기 때문에 버전 &lt;code&gt;0.x.x&lt;/code&gt; 및 &lt;code&gt;4.x.x&lt;/code&gt; 는 지원 되지 않습니다. 그러나 노드 4에서 Jest를 실행해야하는 경우 &lt;code&gt;testEnvironment&lt;/code&gt; 구성을 사용하여 지원 하는 &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;사용자 정의 환경&lt;/a&gt; 을 사용할 수 있습니다 노드 (4), 같은 &lt;a href=&quot;https://yarnpkg.com/en/package/jest-environment-node&quot;&gt; &lt;code&gt;jest-environment-node&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="768460f31b776efe5a80d1b9f906e146b73387b9" translate="yes" xml:space="preserve">
          <source>Jest uses &quot;matchers&quot; to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the &lt;a href=&quot;expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; API doc&lt;/a&gt;.</source>
          <target state="translated">Jest는 &quot;매칭 기&quot;를 사용하여 다양한 방법으로 값을 테스트 할 수 있습니다. 이 문서는 일반적으로 사용되는 일부 matcher를 소개합니다. 전체 목록은 &lt;a href=&quot;expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; API doc을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c82af62e3c4f58c048febf072e373b55ced751b5" translate="yes" xml:space="preserve">
          <source>Jest will fail if:</source>
          <target state="translated">다음과 같은 경우 Jest가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="67e59a98c5fb0793e5a8bd46b25470fc7acc51f4" translate="yes" xml:space="preserve">
          <source>Jest will set &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; to &lt;code&gt;'test'&lt;/code&gt; if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.</source>
          <target state="translated">Jest는 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 가 다른 것으로 설정되어 있지 않으면 &lt;code&gt;'test'&lt;/code&gt; 로 설정합니다. 구성에서이를 사용하여 Jest에 필요한 컴파일 만 조건부로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d5c3a199ac87496dc718d131f247923a5cf3ff" translate="yes" xml:space="preserve">
          <source>Jest's configuration can be defined in the &lt;code&gt;package.json&lt;/code&gt; file of your project, or through a &lt;code&gt;jest.config.js&lt;/code&gt; file or through the &lt;code&gt;--config &amp;lt;path/to/js|json&amp;gt;&lt;/code&gt; option. If you'd like to use your &lt;code&gt;package.json&lt;/code&gt; to store Jest's config, the &quot;jest&quot; key should be used on the top level so Jest will know how to find your settings:</source>
          <target state="translated">Jest 구성은 프로젝트 의 &lt;code&gt;package.json&lt;/code&gt; 파일 또는 &lt;code&gt;jest.config.js&lt;/code&gt; 파일 또는 &lt;code&gt;--config &amp;lt;path/to/js|json&amp;gt;&lt;/code&gt; 옵션을 통해 정의 할 수 있습니다 . &lt;code&gt;package.json&lt;/code&gt; 을 사용하여 Jest의 구성을 저장하려면 &quot;jest&quot;키를 최상위 레벨에서 사용해야 Jest가 설정을 찾는 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e22c112121645c276dc7120c07fdacec26f44c5" translate="yes" xml:space="preserve">
          <source>Join the community</source>
          <target state="translated">커뮤니티 가입</target>
        </trans-unit>
        <trans-unit id="ab922b1d7b4717c074a882c0cc8961b6bee80d98" translate="yes" xml:space="preserve">
          <source>Keeping track of usage (spying on the mock)</source>
          <target state="translated">사용량 추적 (모의 스파이)</target>
        </trans-unit>
        <trans-unit id="2aeb4bdd1784b8385939c2b4d4425b6e4b8d7dce" translate="yes" xml:space="preserve">
          <source>Keys with &lt;code&gt;undefined&lt;/code&gt; properties are checked. e.g. &lt;code&gt;{a: undefined, b: 2}&lt;/code&gt; does not match &lt;code&gt;{b: 2}&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="translated">속성이 &lt;code&gt;undefined&lt;/code&gt; 키 가 확인됩니다. 예 &lt;code&gt;{a: undefined, b: 2}&lt;/code&gt; &lt;code&gt;.toStrictEqual&lt;/code&gt; 을 사용할 때 {a : undefined, b : 2} 가 &lt;code&gt;{b: 2}&lt;/code&gt; 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ee55816ee3b1b4f1a6f30044867a661ab9181c42" translate="yes" xml:space="preserve">
          <source>Lastly, it may occasionally be useful in some tests to be able to clear all of the pending timers. For this, we have &lt;code&gt;jest.clearAllTimers()&lt;/code&gt;.</source>
          <target state="translated">마지막으로, 일부 테스트에서는 보류중인 타이머를 모두 지울 수있는 경우가 있습니다. 이를 위해 &lt;code&gt;jest.clearAllTimers()&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a524bb87c02c371357d8cd4517ffca34064b2ab0" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;, &lt;a href=&quot;mock-functions&quot;&gt;Mock Functions&lt;/a&gt;, and more in our in-depth guides.</source>
          <target state="translated">자세한 가이드에서 &lt;a href=&quot;snapshot-testing&quot;&gt;스냅 샷 테스팅&lt;/a&gt; , &lt;a href=&quot;mock-functions&quot;&gt;모의 함수&lt;/a&gt; 등에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="4713da2c87e8066c2601dd3ebce0a9e9a2b367bd" translate="yes" xml:space="preserve">
          <source>Learn by example</source>
          <target state="translated">예를 들어 배우십시오</target>
        </trans-unit>
        <trans-unit id="a73e45c2d9e4a09fc058543b28381a8d5615a8a2" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;configuration&quot;&gt;configure Jest&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;configuration&quot;&gt;Jest 구성&lt;/a&gt; 방법에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2e7bb758fec5bace28a605b54e391a12fa494eb2" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a Link component that renders hyperlinks:</source>
          <target state="translated">하이퍼 링크를 렌더링하는 링크 구성 요소에 대한 &lt;a href=&quot;snapshot-testing&quot;&gt;스냅 샷 테스트&lt;/a&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="482beae4bfaae3f9fde0514bd3872927745e83f4" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a small intro component with a few views and text components and some styles:</source>
          <target state="translated">몇 가지 뷰와 텍스트 구성 요소 및 일부 스타일을 사용하여 작은 인트로 구성 요소에 대한 &lt;a href=&quot;snapshot-testing&quot;&gt;스냅 샷 테스트&lt;/a&gt; 를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a993458f25570cd03bfa9e9bce6047cea0775b62" translate="yes" xml:space="preserve">
          <source>Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a &lt;code&gt;sum.js&lt;/code&gt; file:</source>
          <target state="translated">두 개의 숫자를 더하는 가설 함수에 대한 테스트를 작성하여 시작해 봅시다. 먼저 &lt;code&gt;sum.js&lt;/code&gt; 파일을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="fcc8a6e48c03e9796bf746a0a520bcf38352c6b3" translate="yes" xml:space="preserve">
          <source>Let's imagine we're testing an implementation of a function &lt;code&gt;forEach&lt;/code&gt;, which invokes a callback for each item in a supplied array.</source>
          <target state="translated">제공된 배열의 각 항목에 대한 콜백을 호출하는 &lt;code&gt;forEach&lt;/code&gt; 함수의 구현을 테스트한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="062d6ba16b7346d8afbaec636d17b749060ac2a7" translate="yes" xml:space="preserve">
          <source>Let's implement a checkbox which swaps between two labels:</source>
          <target state="translated">두 레이블 사이를 교환하는 확인란을 구현해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c06fbcda1135b4a2d62c84a73f8043d399406587" translate="yes" xml:space="preserve">
          <source>Let's implement a module that fetches user data from an API and returns the user name.</source>
          <target state="translated">API에서 사용자 데이터를 가져오고 사용자 이름을 반환하는 모듈을 구현해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dd426a8b3b04464a96cf78d5aa5692208e8f3496" translate="yes" xml:space="preserve">
          <source>Let's rewrite the test from above using Enzyme instead of react-testing-library. We use Enzyme's &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow renderer&lt;/a&gt; in this example.</source>
          <target state="translated">react-testing-library 대신 Enzyme을 사용하여 위에서 테스트를 다시 작성해 봅시다. 이 예제 에서는 Enzyme의 &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;얕은 렌더러&lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="157e685f0b5acabc2a4f6b50f0c1c98f974a8a3d" translate="yes" xml:space="preserve">
          <source>Let's start with a common sort of webpack config file and translate it to a Jest setup.</source>
          <target state="translated">일반적인 종류의 webpack 설정 파일로 시작하여 Jest 설정으로 변환 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3fd38479f084ecddacb918704233c6136d1f9d08" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test runner.</source>
          <target state="translated">사용자 정의 테스트 러너를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd0feff82f64a29645a993d706fca6c82a94899c" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test sequencer. Please refer to the documentation of the corresponding configuration property for details.</source>
          <target state="translated">사용자 정의 테스트 시퀀서를 지정할 수 있습니다. 자세한 내용은 해당 구성 속성의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3dbc9fff53cb18c46d1dbe0926adbfb61c34df0" translate="yes" xml:space="preserve">
          <source>Lists all tests as JSON that Jest will run given the arguments, and exits. This can be used together with &lt;code&gt;--findRelatedTests&lt;/code&gt; to know which tests Jest will run.</source>
          <target state="translated">인수가 주어진 Jest가 실행할 JSON으로 모든 테스트를 나열하고 종료합니다. 이것은 &lt;code&gt;--findRelatedTests&lt;/code&gt; 와 함께 사용하여 Jest가 실행할 테스트를 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cf968e7663782a1b2d3370cf3fab9d47ef5ec45" translate="yes" xml:space="preserve">
          <source>Logs the heap usage after every test. Useful to debug memory leaks. Use together with &lt;code&gt;--runInBand&lt;/code&gt; and &lt;code&gt;--expose-gc&lt;/code&gt; in node.</source>
          <target state="translated">모든 테스트 후 힙 사용량을 기록합니다. 메모리 누수를 디버깅하는 데 유용합니다. 노드에서 &lt;code&gt;--runInBand&lt;/code&gt; 및 &lt;code&gt;--expose-gc&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3062ee96f10ceb01351b8c1d96e5d36b30dca2e3" translate="yes" xml:space="preserve">
          <source>Look at the full &lt;a href=&quot;api&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="translated">전체 &lt;a href=&quot;api&quot;&gt;API 참조를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8e7713a214ac3e151ee1f95eb5b5953bf52353" translate="yes" xml:space="preserve">
          <source>Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.</source>
          <target state="translated">더 이상 사용되지 않는 API를 호출하면 유용한 오류 메시지가 표시됩니다. 업그레이드 프로세스를 완화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ff5c0e44a12b2c154dbab6ad20eb02b2ebda36df" translate="yes" xml:space="preserve">
          <source>Make sure you are not using the &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; plugin. Jest wraps Istanbul, and therefore also tells Istanbul what files to instrument with coverage collection. When using &lt;code&gt;babel-plugin-istanbul&lt;/code&gt;, every file that is processed by Babel will have coverage collection code, hence it is not being ignored by &lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-plugin-istanbul&lt;/code&gt; 플러그인을 사용하고 있지 않은지 확인하십시오 . Jest는 이스탄불을 감 쌉니다. 또한 이스탄불에 커버리지 수집으로 계측 할 파일을 알려줍니다. &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; 을 사용 하는 경우 Babel에서 처리하는 모든 파일은 적용 범위 콜렉션 코드를 가지므로 &lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; 에서는이를 무시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2601b2eb4063a28fa7ddf679595552390f7aaaad" translate="yes" xml:space="preserve">
          <source>Manual Mocks</source>
          <target state="translated">수동 대합</target>
        </trans-unit>
        <trans-unit id="a515a8ca23977a705cfa165109739d0a5188aab8" translate="yes" xml:space="preserve">
          <source>Manual mock</source>
          <target state="translated">수동 모의</target>
        </trans-unit>
        <trans-unit id="24649abe70370a7c2be875cc1bb049c1d2c3120f" translate="yes" xml:space="preserve">
          <source>Manual mock that is another ES6 class</source>
          <target state="translated">다른 ES6 클래스 인 수동 모의</target>
        </trans-unit>
        <trans-unit id="44695745ffcdd878a86f104986c6a105e40ebd17" translate="yes" xml:space="preserve">
          <source>Manual mocks are defined by writing a module in a &lt;code&gt;__mocks__/&lt;/code&gt; subdirectory immediately adjacent to the module. For example, to mock a module called &lt;code&gt;user&lt;/code&gt; in the &lt;code&gt;models&lt;/code&gt; directory, create a file called &lt;code&gt;user.js&lt;/code&gt; and put it in the &lt;code&gt;models/__mocks__&lt;/code&gt; directory. Note that the &lt;code&gt;__mocks__&lt;/code&gt; folder is case-sensitive, so naming the directory &lt;code&gt;__MOCKS__&lt;/code&gt; will break on some systems.</source>
          <target state="translated">수동 모의는 모듈 바로 옆 의 &lt;code&gt;__mocks__/&lt;/code&gt; 서브 디렉토리에 모듈을 작성하여 정의됩니다 . 예를 들어, &lt;code&gt;models&lt;/code&gt; 디렉토리 에서 &lt;code&gt;user&lt;/code&gt; 라는 모듈을 모의 하려면 &lt;code&gt;user.js&lt;/code&gt; 라는 파일을 작성 하여 &lt;code&gt;models/__mocks__&lt;/code&gt; 디렉토리 에 넣으십시오 . 있습니다 &lt;code&gt;__mocks__&lt;/code&gt; 의 폴더가 너무 디렉토리 이름, 대소 문자를 구분 &lt;code&gt;__MOCKS__&lt;/code&gt; 일부 시스템 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="e6043328f6dbc68531364ede4b70721943facae0" translate="yes" xml:space="preserve">
          <source>Manual mocks are used to stub out functionality with mock data. For example, instead of accessing a remote resource like a website or a database, you might want to create a manual mock that allows you to use fake data. This ensures your tests will be fast and not flaky.</source>
          <target state="translated">수동 모형은 모형 데이터로 기능을 제거하는 데 사용됩니다. 예를 들어 웹 사이트 나 데이터베이스와 같은 원격 리소스에 액세스하는 대신 가짜 데이터를 사용할 수있는 수동 모의를 만들 수 있습니다. 이렇게하면 테스트가 빠르고 벗겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d4d90d06bd9381fe57041c5e2c6fa49629ba38e" translate="yes" xml:space="preserve">
          <source>Matchers are called with the argument passed to &lt;code&gt;expect(x)&lt;/code&gt; followed by the arguments passed to &lt;code&gt;.yourMatcher(y, z)&lt;/code&gt;:</source>
          <target state="translated">matcher는 &lt;code&gt;expect(x)&lt;/code&gt; 전달 된 인수와 &lt;code&gt;.yourMatcher(y, z)&lt;/code&gt; 전달 된 인수와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fdeb71c3b04a33085ca1c966123a1422dbbb545" translate="yes" xml:space="preserve">
          <source>Matchers should return an object (or a Promise of an object) with two keys. &lt;code&gt;pass&lt;/code&gt; indicates whether there was a match or not, and &lt;code&gt;message&lt;/code&gt; provides a function with no arguments that returns an error message in case of failure. Thus, when &lt;code&gt;pass&lt;/code&gt; is false, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).yourMatcher()&lt;/code&gt; fails. And when &lt;code&gt;pass&lt;/code&gt; is true, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).not.yourMatcher()&lt;/code&gt; fails.</source>
          <target state="translated">매처는 두 개의 키를 사용하여 객체 (또는 객체의 약속)를 반환해야합니다. &lt;code&gt;pass&lt;/code&gt; 는 일치 여부 를 나타내며 &lt;code&gt;message&lt;/code&gt; 는 실패시 오류 메시지를 반환하는 인수없이 함수를 제공합니다. 경우에 따라서, &lt;code&gt;pass&lt;/code&gt; 거짓, &lt;code&gt;message&lt;/code&gt; 때의 에러 메시지를 반환한다 &lt;code&gt;expect(x).yourMatcher()&lt;/code&gt; 실패한다. 그리고 &lt;code&gt;pass&lt;/code&gt; 이 참이면 &lt;code&gt;message&lt;/code&gt; 는 &lt;code&gt;expect(x).not.yourMatcher()&lt;/code&gt; 가 실패한 경우에 대한 오류 메시지를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="da4dc8d5f890d2faf608d0adbf35adbe19f4f359" translate="yes" xml:space="preserve">
          <source>Migrate your existing tests to Jest by following our &lt;a href=&quot;migration-guide&quot;&gt;migration guide&lt;/a&gt;.</source>
          <target state="translated">마이그레이션 &lt;a href=&quot;migration-guide&quot;&gt;안내서&lt;/a&gt; 에 따라 기존 테스트를 Jest로 마이그레이션하십시오 .</target>
        </trans-unit>
        <trans-unit id="72ad73c448eb21acf03af42f65ee23278b00d994" translate="yes" xml:space="preserve">
          <source>Migrating to Jest</source>
          <target state="translated">Jest로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="ce71db8c75c86bd1436468173cd4e8202c9dfc44" translate="yes" xml:space="preserve">
          <source>MobX</source>
          <target state="translated">MobX</target>
        </trans-unit>
        <trans-unit id="c599c38fbea82d50bf4f02778d2c491e8ffb771d" translate="yes" xml:space="preserve">
          <source>Mock Functions</source>
          <target state="translated">모의 함수</target>
        </trans-unit>
        <trans-unit id="82d8638dc8b42629227f73d549ec402ed6ea4163" translate="yes" xml:space="preserve">
          <source>Mock Implementations</source>
          <target state="translated">모의 구현</target>
        </trans-unit>
        <trans-unit id="9b383e089384d87712726a0bf225e81090b828eb" translate="yes" xml:space="preserve">
          <source>Mock Modules</source>
          <target state="translated">모의 모듈</target>
        </trans-unit>
        <trans-unit id="dd63f222517c40ccfb13bebc813ecec5f6f4c387" translate="yes" xml:space="preserve">
          <source>Mock Names</source>
          <target state="translated">모의 이름</target>
        </trans-unit>
        <trans-unit id="ac64e00246b5445d75034bf18799b106ce0e9c67" translate="yes" xml:space="preserve">
          <source>Mock Return Values</source>
          <target state="translated">모의 반환 값</target>
        </trans-unit>
        <trans-unit id="c3f17e11dc3d6f235c6b3173d2753715c699dccd" translate="yes" xml:space="preserve">
          <source>Mock functions</source>
          <target state="translated">모의 기능</target>
        </trans-unit>
        <trans-unit id="16d7de714d1a0043e564d48599b0d8b9aadf62a1" translate="yes" xml:space="preserve">
          <source>Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with &lt;code&gt;new&lt;/code&gt;, and allowing test-time configuration of return values.</source>
          <target state="translated">모의 함수를 사용하면 함수의 실제 구현을 지우고 함수에 대한 호출 (및 해당 호출에 전달 된 매개 변수)을 캡처하고 &lt;code&gt;new&lt;/code&gt; 로 인스턴스화 할 때 생성자 함수의 인스턴스를 캡처 하고 테스트 시간 구성을 허용하여 코드 간 링크를 테스트 할 수 있습니다. 반환 값.</target>
        </trans-unit>
        <trans-unit id="4b436dfff5ba750a15d49f994af79b7a7a9443b9" translate="yes" xml:space="preserve">
          <source>Mock functions are also known as &quot;spies&quot;, because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with &lt;code&gt;jest.fn()&lt;/code&gt;. If no implementation is given, the mock function will return &lt;code&gt;undefined&lt;/code&gt; when invoked.</source>
          <target state="translated">모의 함수는 &quot;스파이&quot;라고도합니다. 출력을 테스트하는 대신 다른 코드에서 간접적으로 호출하는 함수의 동작을 감시 할 수 있기 때문입니다. &lt;code&gt;jest.fn()&lt;/code&gt; 사용하여 모의 함수를 만들 수 있습니다 . 구현이 제공되지 않으면, mock 함수는 호출 될 때 &lt;code&gt;undefined&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4971c2547d472a78138b8f9d6790ae4e902b5810" translate="yes" xml:space="preserve">
          <source>Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.</source>
          <target state="translated">모의 함수는 함수 연속 전달 스타일을 사용하는 코드에서도 매우 효과적입니다. 이 스타일로 작성된 코드는 사용하기 전에 테스트에 직접 값을 주입하기 위해 서있는 실제 구성 요소의 동작을 재현하는 복잡한 스텁이 필요하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="277426c27099c2bbe1295ec0d37f76535f67bd0f" translate="yes" xml:space="preserve">
          <source>Mock functions can also be used to inject test values into your code during a test:</source>
          <target state="translated">테스트 중에 Mock 함수를 사용하여 코드에 테스트 값을 삽입 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73fe7175c7ae1faf0611e3806c81041ff30671f" translate="yes" xml:space="preserve">
          <source>Mock native modules using jest.mock</source>
          <target state="translated">jest.mock을 사용하여 모의 네이티브 모듈</target>
        </trans-unit>
        <trans-unit id="2082c50c18e1f58690e6d14e16bfce63f4a55ed8" translate="yes" xml:space="preserve">
          <source>Mock timers</source>
          <target state="translated">모의 타이머</target>
        </trans-unit>
        <trans-unit id="e88bc2968cce370e084a967f2ffbedcdd7a9ef95" translate="yes" xml:space="preserve">
          <source>Mock using module factory parameter</source>
          <target state="translated">모듈 팩토리 파라미터를 사용하여 모의</target>
        </trans-unit>
        <trans-unit id="6de59347c925a26a9ab2dde60fa904ce3606c161" translate="yes" xml:space="preserve">
          <source>Mocking CSS Modules</source>
          <target state="translated">CSS 모듈 모의</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">조롱 모듈</target>
        </trans-unit>
        <trans-unit id="8aca8ac03ce33b333f2207760098a53514b273da" translate="yes" xml:space="preserve">
          <source>Mocking Node modules</source>
          <target state="translated">모의 노드 모듈</target>
        </trans-unit>
        <trans-unit id="00105b8c8ed55ecc038db2f39993e7f1167058b7" translate="yes" xml:space="preserve">
          <source>Mocking methods which are not implemented in JSDOM</source>
          <target state="translated">JSDOM에서 구현되지 않은 모의 메소드</target>
        </trans-unit>
        <trans-unit id="ce8e30f89b00eb10d649edd097cb8226f41cc84f" translate="yes" xml:space="preserve">
          <source>Mocking user modules</source>
          <target state="translated">모의 사용자 모듈</target>
        </trans-unit>
        <trans-unit id="632801c55fe3abd89004fbdb78494e86beec94a0" translate="yes" xml:space="preserve">
          <source>Mocks a module with an auto-mocked version when it is being required. &lt;code&gt;factory&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; are optional. For example:</source>
          <target state="translated">필요할 때 자동 조롱 된 버전으로 모듈을 모킹합니다. &lt;code&gt;factory&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 은 선택 사항입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="009c795e3111448694cc3dc957f4b70c8f03b727" translate="yes" xml:space="preserve">
          <source>Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.</source>
          <target state="translated">JavaScript 값의 기본 유형을 식별하는 모듈입니다. 인수로 전달 된 값의 유형으로 문자열을 반환하는 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7be53179917b8757ad3b5f547e48374b67d70e70" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;Worker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="translated">작업 병렬화에 사용되는 모듈. Node.js 모듈의 경로를 사용 하는 클래스 &lt;code&gt;Worker&lt;/code&gt; 를 내보내고 모듈의 내 보낸 메서드를 마치 클래스 메서드 인 것처럼 호출하여 지정된 메서드가 분기 된 프로세스에서 실행을 마치면 해결되는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5123a0149608b8f62ab410c929a918587d7bbf79" translate="yes" xml:space="preserve">
          <source>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</source>
          <target state="translated">별칭에 매핑 된 모듈은 자동 모의 활성화 여부에 관계없이 기본적으로 모의 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="400881ff44dd95e53d5b70de2d221304a209dd8b" translate="yes" xml:space="preserve">
          <source>Modules that are mocked with &lt;code&gt;jest.mock&lt;/code&gt; are mocked only for the file that calls &lt;code&gt;jest.mock&lt;/code&gt;. Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.</source>
          <target state="translated">함께 조롱하는 모듈 &lt;code&gt;jest.mock&lt;/code&gt; 은 단지 호출하는 파일을 조롱하는 &lt;code&gt;jest.mock&lt;/code&gt; 을 . 모듈을 가져 오는 다른 파일은 모듈을 조롱하는 테스트 파일 이후에 실행 되더라도 원래 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bb101179b6d768145f738342dfe298b98e4b70e0" translate="yes" xml:space="preserve">
          <source>More Resources</source>
          <target state="translated">더 많은 자료</target>
        </trans-unit>
        <trans-unit id="4b7a524aa43cd2033804e07ac0567266d5069451" translate="yes" xml:space="preserve">
          <source>More information can be found at &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fde45e0d5214ab7d193c97e2773574aa18d36ca8" translate="yes" xml:space="preserve">
          <source>More information on Node debugging can be found &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">노드 디버깅에 대한 자세한 내용은 &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25a40503253892e6560d8d5c69a4720093cc2ba6" translate="yes" xml:space="preserve">
          <source>More information on how snapshot testing works and why we built it can be found on the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;release blog post&lt;/a&gt;. We recommend reading &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;this blog post&lt;/a&gt; to get a good sense of when you should use snapshot testing. We also recommend watching this &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;egghead video&lt;/a&gt; on Snapshot Testing with Jest.</source>
          <target state="translated">스냅 샷 테스트의 작동 방식과 구축 이유에 대한 자세한 내용은 &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;릴리스 블로그 게시물&lt;/a&gt; 에서 확인할 수 있습니다 . 스냅 샷 테스트를 언제 사용해야하는지 잘 이해하려면 &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;이 블로그 게시물&lt;/a&gt; 을 읽는 것이 좋습니다 . 또한 Jest의 Snapshot Testing 에서이 &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;에그 헤드 비디오&lt;/a&gt; 를 시청하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f58721cb66c8644aaf7f808a07bb173fa203cd2" translate="yes" xml:space="preserve">
          <source>Most commonly this is being caused by conflicting Promise implementations. Consider replacing the global promise implementation with your own, for example &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; and/or consolidate the used Promise libraries to a single one.</source>
          <target state="translated">가장 일반적으로 충돌하는 Promise 구현으로 인해 발생합니다. 글로벌 약속 구현을 자신의 것으로 대체하십시오 &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; 예 : global.Promise = jest.requireActual ( 'promise'); 사용 된 Promise 라이브러리를 단일 라이브러리로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="d5fa9ec15923cf5a4447d89705061f4895a3a460" translate="yes" xml:space="preserve">
          <source>Most likely your glob patterns are not matching any files. Refer to the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; documentation to ensure your globs are compatible.</source>
          <target state="translated">글로브 패턴이 파일과 일치하지 않을 가능성이 높습니다. 글로브가 호환되는지 확인 하려면 &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;마이크로 매치&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b70aff9a2e6d1a508cc94211f970a06aadb07a7f" translate="yes" xml:space="preserve">
          <source>Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.</source>
          <target state="translated">대부분의 실제 예는 실제로 종속 구성 요소에서 모의 ​​함수를 잡고 구성하는 것과 관련이 있지만 기술은 동일합니다. 이 경우 직접 테스트되지 않은 함수 내부에서 논리를 구현하려는 유혹을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="1743857a25bf614f38c27b820f8398e3eb15e127" translate="yes" xml:space="preserve">
          <source>Most ways of comparing numbers have matcher equivalents.</source>
          <target state="translated">숫자를 비교하는 대부분의 방법에는 일치하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d9d7323ef86fe85fd1d7687235aac297bdcdee" translate="yes" xml:space="preserve">
          <source>Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.</source>
          <target state="translated">다음으로 스타일 시트 및 이미지와 같은 자산 파일을 정상적으로 처리하도록 Jest를 구성하겠습니다. 일반적으로 이러한 파일은 테스트에 특히 유용하지 않으므로 안전하게 조롱 할 수 있습니다. 그러나 CSS 모듈을 사용하는 경우 className 조회를 위해 프록시를 조롱하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0cd213a32f05bcc17b41830bc252640d32af3383" translate="yes" xml:space="preserve">
          <source>No default</source>
          <target state="translated">기본값 없음</target>
        </trans-unit>
        <trans-unit id="069541cf8be1f0d43b5c179ab178c1af971111c3" translate="yes" xml:space="preserve">
          <source>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing &lt;code&gt;--updateSnapshot&lt;/code&gt;. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.</source>
          <target state="translated">아니요, Jest 20부터 Jest가 &lt;code&gt;--updateSnapshot&lt;/code&gt; 을 명시 적으로 전달하지 않고 CI 시스템에서 실행될 때 Jest의 스냅 샷이 자동으로 작성되지 않습니다 . 모든 스냅 샷은 CI에서 실행되는 코드의 일부일 것으로 예상되며 새 스냅 샷은 자동으로 전달되므로 CI 시스템에서 테스트 실행을 통과해서는 안됩니다. 항상 모든 스냅 샷을 커밋하고 버전 관리를 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2c8a846eddb8681ebf180cd4b3a87cddb1fe5a15" translate="yes" xml:space="preserve">
          <source>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</source>
          <target state="translated">이러한 형식 중 어느 것도 특히 다른 형식보다 우수하지 않으며 코드베이스 또는 단일 파일에서 혼합하여 사용할 수 있습니다. 그것은 당신이 느끼는 스타일에 따라 테스트가 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="593dc274bf37fc96d1260b84eb4792e03219586d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;column&lt;/code&gt; is 0-indexed while &lt;code&gt;line&lt;/code&gt; is not.</source>
          <target state="translated">참고 &lt;code&gt;column&lt;/code&gt; 동안 0 인덱스입니다 &lt;code&gt;line&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="7fbb94ab3f435207f3668ea824069ffb13ba8524" translate="yes" xml:space="preserve">
          <source>Note that the mock can't be an arrow function because calling &lt;code&gt;new&lt;/code&gt; on an arrow function is not allowed in JavaScript. So this won't work:</source>
          <target state="translated">JavaScript에서는 화살표 함수에서 &lt;code&gt;new&lt;/code&gt; 를 호출 할 수 없으므로 mock은 화살표 함수가 될 수 없습니다 . 그래서 이것은 작동하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="35e09d6f70cb52a597a44fb09de97ecc2bafcf55" translate="yes" xml:space="preserve">
          <source>Note that the top-level &lt;code&gt;beforeEach&lt;/code&gt; is executed before the &lt;code&gt;beforeEach&lt;/code&gt; inside the &lt;code&gt;describe&lt;/code&gt; block. It may help to illustrate the order of execution of all hooks.</source>
          <target state="translated">최상위 레벨 &lt;code&gt;beforeEach&lt;/code&gt; 는 &lt;code&gt;describe&lt;/code&gt; 블록 내에서 &lt;code&gt;beforeEach&lt;/code&gt; 이전에 실행 됩니다. 모든 후크의 실행 순서를 설명하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5317a3a7e7d23a56315a8874c449817c31ad8a0c" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">여기에 객체 또는 배열과 같은 전역 참조 값을 지정하고 일부 코드가 테스트를 실행하는 동안 해당 값을 변경하면 해당 테스트는 다른 테스트 파일에 대한 테스트 실행 동안 유지 &lt;em&gt;되지 않습니다&lt;/em&gt; . 또한 &lt;code&gt;globals&lt;/code&gt; 객체는 json 직렬화 가능해야하므로 전역 함수를 지정하는 데 사용할 수 없습니다. 이를 위해서는 &lt;code&gt;setupFiles&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="edc786612e42a25f8f3750696a48a69840f36cd3" translate="yes" xml:space="preserve">
          <source>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to &lt;a href=&quot;asynchronous#promises&quot;&gt;tell Jest to wait&lt;/a&gt; by returning the unwrapped assertion.</source>
          <target state="translated">약속을 테스트하고 있기 때문에 테스트는 여전히 비동기 적입니다. 따라서 래핑되지 않은 어설 션을 반환하여 &lt;a href=&quot;asynchronous#promises&quot;&gt;Jest에게 기다리도록 지시&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9794622b767437b0ecae517257f9db04f7adf32d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your &lt;code&gt;package.json&lt;/code&gt; is located unless you specify a custom &lt;code&gt;rootDir&lt;/code&gt; option in your configuration.</source>
          <target state="translated">참고 : &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 은 프로젝트의 루트로 Jest로 대체되는 특수 토큰입니다. 구성에 사용자 정의 &lt;code&gt;rootDir&lt;/code&gt; 옵션 을 지정하지 않으면 대부분의 경우 &lt;code&gt;package.json&lt;/code&gt; 이 있는 폴더가 됩니다.</target>
        </trans-unit>
        <trans-unit id="628dafac3ccff711682a19552f96e64d7e9e0c0e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;.toEqual&lt;/code&gt; won't perform a &lt;em&gt;deep equality&lt;/em&gt; check for two errors. Only the &lt;code&gt;message&lt;/code&gt; property of an Error is considered for equality. It is recommended to use the &lt;code&gt;.toThrow&lt;/code&gt; matcher for testing against errors.</source>
          <target state="translated">참고 : &lt;code&gt;.toEqual&lt;/code&gt; 은 두 가지 오류에 대해 &lt;em&gt;심도 평등&lt;/em&gt; 검사를 수행하지 않습니다 . Error 의 &lt;code&gt;message&lt;/code&gt; 속성 만 동일한 것으로 간주됩니다. 오류 테스트를 위해 &lt;code&gt;.toThrow&lt;/code&gt; 매처 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7613acf3a264c0259c7e5490495960bb2558a069" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;babel-jest&lt;/code&gt; is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the &lt;code&gt;transform&lt;/code&gt; configuration option:</source>
          <target state="translated">참고 : &lt;code&gt;babel-jest&lt;/code&gt; 는 Jest를 설치할 때 자동으로 설치되며 프로젝트에 babel 구성이있는 경우 파일을 자동으로 변환합니다. 이 동작을 피하기 위해 &lt;code&gt;transform&lt;/code&gt; 구성 옵션을 명시 적으로 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1bf41dd30024dc8f6a9cf73cdb3281441a7c127" translate="yes" xml:space="preserve">
          <source>Note: For more complex webpack configurations, you may also want to investigate projects such as: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;.</source>
          <target state="translated">참고 :보다 복잡한 웹팩 구성의 경우 &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt; 와 같은 프로젝트를 조사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5ee4f891332fe29d99fc8b7113be07b4978e5d9" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;strong&gt;promise is returned&lt;/strong&gt; from &lt;code&gt;test&lt;/code&gt;, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you &lt;strong&gt;provide an argument to the test function&lt;/strong&gt;, usually called &lt;code&gt;done&lt;/code&gt;. This could be handy when you want to test callbacks. See how to test async code &lt;a href=&quot;asynchronous#callbacks&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;test&lt;/code&gt; 에서 &lt;strong&gt;약속이 반환&lt;/strong&gt; 되면 Jest는 테스트가 완료되기 전에 약속이 해결 될 때까지 기다립니다. Jest는 일반적으로 &lt;code&gt;done&lt;/code&gt; 이라고 &lt;strong&gt;하는 테스트 함수에 인수를 제공하면&lt;/strong&gt; 대기합니다 . 콜백을 테스트 할 때 유용 할 수 있습니다. &lt;a href=&quot;asynchronous#callbacks&quot;&gt;여기에서&lt;/a&gt; 비동기 코드를 테스트하는 방법을 참조 하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2c9e685037a098f7ab5cab7e553edaf0c09711f" translate="yes" xml:space="preserve">
          <source>Note: In order to mock properly, Jest needs &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; to be in the same scope as the &lt;code&gt;require/import&lt;/code&gt; statement.</source>
          <target state="translated">참고 : Jest가 제대로 조롱하려면 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 이 &lt;code&gt;require/import&lt;/code&gt; 문과 같은 범위에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9fc7ec9481edc4a64cc4cee9fd0a5b4e7d421cf5" translate="yes" xml:space="preserve">
          <source>Note: Jest caches files to speed up test execution. If you updated .babelrc and Jest is still not working, try running Jest with &lt;code&gt;--no-cache&lt;/code&gt;.</source>
          <target state="translated">참고 : Jest는 파일을 캐시하여 테스트 실행 속도를 높입니다. .babelrc를 업데이트했는데 Jest가 여전히 작동하지 않으면 &lt;code&gt;--no-cache&lt;/code&gt; 로 Jest를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="18499d47a5d29c4202e6b0823b51b2cc1f3a7091" translate="yes" xml:space="preserve">
          <source>Note: Jest documentation uses &lt;code&gt;yarn&lt;/code&gt; commands, but &lt;code&gt;npm&lt;/code&gt; will also work. You can compare &lt;code&gt;yarn&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands in the &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn docs, here&lt;/a&gt;.</source>
          <target state="translated">참고 : Jest 문서는 &lt;code&gt;yarn&lt;/code&gt; 명령을 사용 하지만 &lt;code&gt;npm&lt;/code&gt; 도 작동합니다. &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;얀 문서&lt;/a&gt; 에서 &lt;code&gt;yarn&lt;/code&gt; 및 &lt;code&gt;npm&lt;/code&gt; 명령을 비교할 수 있습니다 ( 여기) .</target>
        </trans-unit>
        <trans-unit id="5cff4d7445c3ba40f87a1439f00a6eba64d370e9" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example it's &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with page prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="translated">참고 : 스냅 샷은 렌더링하는 데이터에 직접 범위가 지정됩니다.이 예에서는 페이지 소품이 전달 된 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소입니다. 이것은 다른 파일 에 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소에 소품 (Say, &lt;code&gt;App.js&lt;/code&gt; ) 이 누락 되어도 테스트에서 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소 의 사용법을 알지 못하고 범위가 지정되어 있기 때문에 테스트를 통과한다는 것을 의미합니다 &lt;code&gt;Link.react.js&lt;/code&gt; 에만 있습니다. 또한 다른 스냅 샷 테스트에서 다른 소품으로 동일한 구성 요소를 렌더링하면 테스트가 서로를 알지 못하므로 첫 번째 구성 요소에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f87616f2342dfb53f7c81b06d94dec773c92c7" translate="yes" xml:space="preserve">
          <source>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</source>
          <target state="translated">참고 : 함수에서 코드를 래핑해야합니다. 그렇지 않으면 오류가 발생하지 않고 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6eb20dc9b8a75cec38d02e8f54a09a224da2b36c" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="translated">참고 : &lt;code&gt;--runInBand&lt;/code&gt; cli 옵션은 Jest가 개별 테스트를위한 프로세스를 생성하지 않고 동일한 프로세스에서 테스트를 실행하도록합니다. 일반적으로 Jest는 여러 프로세스에서 테스트 실행을 병렬화하지만 많은 프로세스를 동시에 디버깅하기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="84a5108cffe44c788bf001c5788a68bdfb2e0028" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as options is the jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. (request, options).</source>
          <target state="translated">참고 : 옵션으로 전달 된 defaultResolver는 사용자 정의 솔루션을 작성할 때 유용한 jest 기본 리졸버입니다. 예를 들어 (요청, 옵션)과 같은 사용자 지정 인수와 동일한 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="63519bb0bd54e1b894cccdf4f3af7852ef618bb7" translate="yes" xml:space="preserve">
          <source>Note: the nth argument must be positive integer starting from 1.</source>
          <target state="translated">참고 : n 번째 인수는 1부터 시작하는 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dc782aff0e671f43d928b262fb2a1ad60df35d44" translate="yes" xml:space="preserve">
          <source>Notice that Proxy is enabled in Node 6 by default. If you are not on Node 6 yet, make sure you invoke Jest using &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt;.</source>
          <target state="translated">프록시는 기본적으로 노드 6에서 활성화되어 있습니다. 아직 Node 6에 있지 않은 경우 &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt; 를 사용하여 Jest를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="97d92ee85a42081babf70348e9395eeb01e66cc8" translate="yes" xml:space="preserve">
          <source>Now imagine an implementation of &lt;code&gt;request.js&lt;/code&gt; that goes to the network and fetches some user data:</source>
          <target state="translated">이제 네트워크로 가서 일부 사용자 데이터를 가져 오는 &lt;code&gt;request.js&lt;/code&gt; 의 구현을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="bb60cb13af7d9fd41f600f4cb00d4bff107937d6" translate="yes" xml:space="preserve">
          <source>Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:</source>
          <target state="translated">이제 React의 테스트 렌더러 및 Jest의 스냅 샷 기능을 사용하여 컴포넌트와 상호 작용하고 렌더링 된 출력을 캡처하고 스냅 샷 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ce0f103deaf5dc6dbc56bf66214617663420f57" translate="yes" xml:space="preserve">
          <source>Now let's write a test for our async functionality.</source>
          <target state="translated">이제 비동기 기능에 대한 테스트를 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4759fbb62123d73c1226706f0f4d34666a8582b0" translate="yes" xml:space="preserve">
          <source>Now that Jest knows how to process our files, we need to tell it how to &lt;em&gt;find&lt;/em&gt; them. For webpack's &lt;code&gt;modulesDirectories&lt;/code&gt;, and &lt;code&gt;extensions&lt;/code&gt; options there are direct analogs in Jest's &lt;code&gt;moduleDirectories&lt;/code&gt; and &lt;code&gt;moduleFileExtensions&lt;/code&gt; options.</source>
          <target state="translated">Jest는 파일을 처리하는 방법을 알고 있으므로 파일을 &lt;em&gt;찾는&lt;/em&gt; 방법을 알려야 합니다. webpack의 &lt;code&gt;modulesDirectories&lt;/code&gt; 및 &lt;code&gt;extensions&lt;/code&gt; 옵션의 경우 Jest의 &lt;code&gt;moduleDirectories&lt;/code&gt; 및 &lt;code&gt;moduleFileExtensions&lt;/code&gt; 옵션 에 직접 아날로그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a5de53298548d7d54ae3ca8e892f7df5aa2243" translate="yes" xml:space="preserve">
          <source>Now we write our test. Note that we need to explicitly tell that we want to mock the &lt;code&gt;fs&lt;/code&gt; module because it&amp;rsquo;s a core Node module:</source>
          <target state="translated">이제 테스트를 작성합니다. 우리는 &lt;code&gt;fs&lt;/code&gt; 모듈이 핵심 노드 모듈이기 때문에 fs 모듈 을 조롱하고 싶다고 명시 적으로 말해야합니다 .</target>
        </trans-unit>
        <trans-unit id="46a5c027241fe1614d4396220914efc2314503e5" translate="yes" xml:space="preserve">
          <source>Now, every time the snapshot test case runs, &lt;code&gt;Date.now()&lt;/code&gt; will return &lt;code&gt;1482363367071&lt;/code&gt; consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.</source>
          <target state="translated">이제 스냅 샷 테스트 사례가 실행될 때마다 &lt;code&gt;Date.now()&lt;/code&gt; 는 &lt;code&gt;1482363367071&lt;/code&gt; 을 일관되게 반환 합니다. 그러면 테스트 실행시기에 관계없이이 구성 요소에 대해 동일한 스냅 샷이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e6490929905f7bc8af5ccef9bf48f8668b1460" translate="yes" xml:space="preserve">
          <source>Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the &lt;code&gt;jest.mock(...)&lt;/code&gt; function to automatically mock the axios module.</source>
          <target state="translated">이제 API에 실제로 &lt;code&gt;jest.mock(...)&lt;/code&gt; 방법을 테스트하여 느리고 취약한 테스트를 만들기 위해 jest.mock (...) 함수를 사용하여 자동으로 Axios 모듈을 조롱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="8d3eb6284bfb714ab8ca96c009bf8ad9c4fc7252" translate="yes" xml:space="preserve">
          <source>Object types are checked to be equal. e.g. A class instance with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will not equal a literal object with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">객체 유형이 같은지 확인합니다. 필드 예 클래스 인스턴스 및 &lt;code&gt;b&lt;/code&gt; 필드 오브젝트 리터럴 동일하지 않을 및 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2176a8ab6b1e30ac16f60c568568a437d540248" translate="yes" xml:space="preserve">
          <source>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</source>
          <target state="translated">스냅 샷하려는 객체에 생성되는 필드 (예 : ID 및 날짜)가 종종 있습니다. 이러한 객체의 스냅 샷을 만들려고하면 실행 시마다 스냅 샷이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6ffecdf0087875891dd611103daecc4d8bcf8763" translate="yes" xml:space="preserve">
          <source>Often this is useful when you want to clean up a mock's usage data between two assertions.</source>
          <target state="translated">두 어설 션간에 모의 사용 데이터를 정리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79cd3f6e68b0a9656087292d49bbeda556ae6d96" translate="yes" xml:space="preserve">
          <source>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.</source>
          <target state="translated">종종 테스트를 작성하는 동안 테스트를 실행하기 전에 수행해야하는 설정 작업이 있고 테스트를 실행 한 후에 수행해야하는 마무리 작업이 있습니다. Jest는이를 처리하는 도우미 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f3d546a97573ddf0fe581d729e6b000ed006545" translate="yes" xml:space="preserve">
          <source>Oftentimes, you'll want to set this to &lt;code&gt;'src'&lt;/code&gt; or &lt;code&gt;'lib'&lt;/code&gt;, corresponding to where in your repository the code is stored.</source>
          <target state="translated">종종 저장소에서 코드가 저장된 위치에 해당하는 &lt;code&gt;'src'&lt;/code&gt; 또는 &lt;code&gt;'lib'&lt;/code&gt; 로 설정하려고 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c12f3f3ee865af90cac56dabeb84091b38861136" translate="yes" xml:space="preserve">
          <source>On occasion there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="translated">때로는 자동으로 생성 된 모의 모듈 시스템이 테스트 요구에 적합하지 않은 경우가 있습니다. 일반적으로 이러한 상황에서는 해당 모듈에 더 적합한 &lt;a href=&quot;manual-mocks&quot;&gt;수동 모형&lt;/a&gt; 을 작성해야합니다 . 그러나 매우 드문 경우이지만 수동 모의조차도 귀하의 목적에 적합하지 않으며 테스트 내부에 모의를 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="eef0b229d34fbb64b6540632318f3fdbaa2280e6" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.</source>
          <target state="translated">모듈을 조롱하면 테스트 할 대상 데이터를 반환하는 &lt;code&gt;.get&lt;/code&gt; 에 대한 &lt;code&gt;mockResolvedValue&lt;/code&gt; 를 제공 할 수 있습니다 . 실제로 axios.get ( '/ users.json')이 가짜 응답을 반환하기를 원한다고 말하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fd8cdd8b9b5a8885d7339d6a566088a20fe3d5" translate="yes" xml:space="preserve">
          <source>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</source>
          <target state="translated">대화 형 스냅 샷 모드로 들어가면 Jest는 실패한 스냅 샷을 한 번에 하나씩 테스트하여 실패한 출력을 검토 할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ffee35fa0cdfd66f92f9f207350deb369bb338b" translate="yes" xml:space="preserve">
          <source>Once you're finished, Jest will give you a summary before returning back to watch mode:</source>
          <target state="translated">완료되면 Jest가 시계 모드로 돌아 가기 전에 요약 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04e3f29cab1cd3970d5e34742e1c9209c2a454b6" translate="yes" xml:space="preserve">
          <source>Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you &lt;a href=&quot;asynchronous&quot;&gt;test asynchronous code&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 매처에 대해 배운 후에는 Jest에서 &lt;a href=&quot;asynchronous&quot;&gt;비동기 코드&lt;/a&gt; 를 테스트 할 수있는 방법을 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="911829cb001fba297a8440e3959d077dc4ad2675" translate="yes" xml:space="preserve">
          <source>One example when this is useful is when you want to mock a module differently within the same file:</source>
          <target state="translated">이것이 유용한 경우의 예는 동일한 파일 내에서 모듈을 다르게 조롱하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="44d433b060d5be5e5cb29585b03e7a39cbe16040" translate="yes" xml:space="preserve">
          <source>One of the files matching the &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob has less than 90% statement coverage.</source>
          <target state="translated">&lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob와 일치하는 파일 중 하나의 명령문 적용 범위는 90 % 미만입니다.</target>
        </trans-unit>
        <trans-unit id="33de0273fb385ef534431d972ca028ab9fae9e00" translate="yes" xml:space="preserve">
          <source>One or more subsequent rows of data supplied as template literal expressions using &lt;code&gt;${value}&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;${value}&lt;/code&gt; 구문을 사용하여 템플리트 리터럴 표현식으로 제공된 하나 이상의 후속 데이터 행 .</target>
        </trans-unit>
        <trans-unit id="cfce43d345326fcdf5172027f076645beb3b6bbb" translate="yes" xml:space="preserve">
          <source>One such situation can arise if we intentionally change the address the Link component in our example is pointing to.</source>
          <target state="translated">예제에서 링크 구성 요소가 가리키는 주소를 의도적으로 변경하면 이러한 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3971f2be369ec67c710b4572f1ea126ad557a5" translate="yes" xml:space="preserve">
          <source>One-Time Setup</source>
          <target state="translated">일회성 설정</target>
        </trans-unit>
        <trans-unit id="883b26a66c75d25a769cffa672f3388d833b2cc4" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run in that test file, since it is run with &lt;code&gt;test.only&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;test.only&lt;/code&gt; 로 실행되므로 &quot;비가 내리고 있습니다&quot;테스트 만 해당 테스트 파일에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="00991593a9f4d31e6c4dd6dbb447ea1e1f468c00" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run, since the other test is run with &lt;code&gt;test.skip&lt;/code&gt;.</source>
          <target state="translated">다른 테스트는 &lt;code&gt;test.skip&lt;/code&gt; 으로 실행되므로 &quot;비가 내리고 있습니다&quot;테스트 만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="749db9a1ae125917392d1a5146e4c6d00c14a9d3" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide &lt;code&gt;steps&lt;/code&gt;, so it will run &lt;code&gt;steps&lt;/code&gt; amount of next timeouts/intervals.</source>
          <target state="translated">선택적으로 &lt;code&gt;steps&lt;/code&gt; 를 제공 할 수 있으므로 다음 시간 초과 / 간격 &lt;code&gt;steps&lt;/code&gt; 를 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="920bdedd844899cd5664de8cfd74adb5d459a38e" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">선택적으로 중단 전에 대기 시간을 지정 하기위한 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)를 제공 할 수 있습니다 . &lt;em&gt;참고 : 기본 시간 제한은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4bf57bdba6d591e8cfd0266e8b8c0a594cbd7d55" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait for each row before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">선택적으로 중단하기 전에 각 행을 기다리는 시간을 지정 하기위한 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)를 제공 할 수 있습니다 . &lt;em&gt;참고 : 기본 시간 제한은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="5c52bc127f7b5826340dcf7c16bf51e0c271179b" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="371316f168eab595bc4ea7391514a4fa0fe1808f" translate="yes" xml:space="preserve">
          <source>Or if you'd like to create your own manual mock, you can do something like this:</source>
          <target state="translated">또는 자신의 수동 모의를 만들고 싶다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e431292d05ab6b8e395a562d7c86a6ac7fe933b" translate="yes" xml:space="preserve">
          <source>Or through JavaScript:</source>
          <target state="translated">또는 JavaScript를 통해 :</target>
        </trans-unit>
        <trans-unit id="49a0778a7a6879004009864ebf95b81c7e7732d5" translate="yes" xml:space="preserve">
          <source>Order of execution of describe and test blocks</source>
          <target state="translated">설명 및 테스트 블록의 실행 순서</target>
        </trans-unit>
        <trans-unit id="e9a3dd308dd30f061fa22d50cb21bc2220dcf9c9" translate="yes" xml:space="preserve">
          <source>Our mocked class will need to provide any member functions (&lt;code&gt;playSoundFile&lt;/code&gt; in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.</source>
          <target state="translated">우리의 조롱 된 클래스는 테스트 중에 호출 될 멤버 함수 ( 예 : &lt;code&gt;playSoundFile&lt;/code&gt; ) 를 제공해야 합니다. 그렇지 않으면 존재하지 않는 함수를 호출하면 오류가 발생합니다. 그러나 우리는 아마도 메소드가 예상 매개 변수로 호출되도록하기 위해 해당 메소드에 대한 호출을 감시하려고 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfc5a5b4ca8f80ee77043098ef9ffc04d559ec8c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;debugger;&lt;/code&gt; statement in any of your tests, and then, in your project's directory, run:</source>
          <target state="translated">장소 &lt;code&gt;debugger;&lt;/code&gt; 테스트 중 하나에 명령문을 작성한 다음 프로젝트 디렉토리에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2d313b13f95b5bdfa47176161df9d9aac0aea191" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the resulting configuration must be JSON-serializable.</source>
          <target state="translated">결과 구성은 JSON 직렬화 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="af206380956fb62af6fa59d92f109cd9641063d0" translate="yes" xml:space="preserve">
          <source>Please note that if you use arrow functions in your classes, they will &lt;em&gt;not&lt;/em&gt; be part of the mock. The reason for that is that arrow functions are not present on the object's prototype, they are merely properties holding a reference to a function.</source>
          <target state="translated">수업에서 화살표 기능을 사용 하면 모의 기능에 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그 이유는 화살표 함수가 객체의 프로토 타입에 존재하지 않고 단지 함수에 대한 참조를 보유한 속성 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="15c438f6772aa6520819506e7fbe99852dd87fd5" translate="yes" xml:space="preserve">
          <source>Plugins can be customized via your Jest configuration.</source>
          <target state="translated">플러그인은 Jest 구성을 통해 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e78b672f965eb7c8293baebd2be38d992a6655" translate="yes" xml:space="preserve">
          <source>Preset configuration</source>
          <target state="translated">사전 설정 구성</target>
        </trans-unit>
        <trans-unit id="bfb26311747a6131c77f1e75e89e1da90925579c" translate="yes" xml:space="preserve">
          <source>Presets may also be relative filesystem paths.</source>
          <target state="translated">사전 설정은 상대 파일 시스템 경로 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33521f1e271c7d1369654933da9149112fe4281c" translate="yes" xml:space="preserve">
          <source>Prevent tests from printing messages through the console.</source>
          <target state="translated">테스트가 콘솔을 통해 메시지를 인쇄하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="0507f30be4f8c196c99ce7be2cba62397164f331" translate="yes" xml:space="preserve">
          <source>Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use &lt;code&gt;test.concurrent&lt;/code&gt;.</source>
          <target state="translated">Jest가 지정된 양보다 많은 테스트를 동시에 실행하지 못하게합니다. &lt;code&gt;test.concurrent&lt;/code&gt; 를 사용하는 테스트에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="7719ba43ff57b175fbd95f647e624ca1e3e38f9d" translate="yes" xml:space="preserve">
          <source>Print debugging info about your Jest config.</source>
          <target state="translated">Jest 구성에 대한 디버깅 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="169d23ffa6beb8bf0a8b932fddc3a716b615997f" translate="yes" xml:space="preserve">
          <source>Print your Jest config and then exits.</source>
          <target state="translated">Jest 구성을 인쇄 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a45ae5d1d90ee0d31bb43f56d9dee1beb6b5a14a" translate="yes" xml:space="preserve">
          <source>Prints the test results in JSON. This mode will send all other test output and user messages to stderr.</source>
          <target state="translated">테스트 결과를 JSON으로 인쇄합니다. 이 모드는 다른 모든 테스트 출력 및 사용자 메시지를 stderr로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="d3f60bcc6f5c4f59593f0501aca5c6e1a0e647d3" translate="yes" xml:space="preserve">
          <source>Property Matchers</source>
          <target state="translated">속성 매처</target>
        </trans-unit>
        <trans-unit id="b305ac456a0fe1de47f68c0f2dcb4be5edf55137" translate="yes" xml:space="preserve">
          <source>React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:</source>
          <target state="translated">React 16은 요소 유형을 확인하는 방법으로 인해 이러한 경고를 트리거하며, 모의 모듈은 이러한 확인에 실패합니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="695d1116170755340f94ec3beb1f24f668859e58" translate="yes" xml:space="preserve">
          <source>Recommended config names:</source>
          <target state="translated">권장 구성 이름 :</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="84641ce3545468aef6d9992e246ecc28023bd7fa" translate="yes" xml:space="preserve">
          <source>Removes any pending timers from the timer system.</source>
          <target state="translated">타이머 시스템에서 보류중인 타이머를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="571be88936b979291213a8fc1300d3eb34583940" translate="yes" xml:space="preserve">
          <source>Render as a custom element. DOM &quot;custom elements&quot; aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.</source>
          <target state="translated">사용자 정의 요소로 렌더링하십시오. DOM &quot;custom elements&quot;는 아무것도 확인되지 않으며 경고를 발생시키지 않아야합니다. 그것들은 소문자이며 이름에 대시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="456b6bb3ce6f2e6632c5f1e8d9ca1d06e7f178b9" translate="yes" xml:space="preserve">
          <source>Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:</source>
          <target state="translated">텍스트로 렌더링하십시오. 이런 식으로 소품이 스냅 샷의 모의 컴포넌트로 전달되는 것을 볼 수는 없지만 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1e70132872e75d10f3ccbb11c8b73d9f202669fd" translate="yes" xml:space="preserve">
          <source>Rendered snapshot:</source>
          <target state="translated">렌더링 된 스냅 샷 :</target>
        </trans-unit>
        <trans-unit id="3cd1c22168650ecd82a31a115bed21a42399c269" translate="yes" xml:space="preserve">
          <source>Repeating Setup For Many Tests</source>
          <target state="translated">많은 테스트를위한 설정 반복</target>
        </trans-unit>
        <trans-unit id="5add9c1dfb47ec8100a0659f89d63ed952ac6c86" translate="yes" xml:space="preserve">
          <source>Replacing the mock using &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt;&lt;code&gt;mockImplementation()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt;&lt;code&gt;mockImplementationOnce()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt; &lt;code&gt;mockImplementation()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt; &lt;code&gt;mockImplementationOnce()&lt;/code&gt; &lt;/a&gt; 사용하여 mock 교체</target>
        </trans-unit>
        <trans-unit id="19baff0fd9598875b3df0c02954246d178653887" translate="yes" xml:space="preserve">
          <source>Resets all information stored in the &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt; arrays.</source>
          <target state="translated">&lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt; 배열에 저장된 모든 정보를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c4baf164f97d04496389992c7c5da13fbb245ae" translate="yes" xml:space="preserve">
          <source>Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.</source>
          <target state="translated">필요한 모든 모듈의 캐시 인 모듈 레지스트리를 재설정합니다. 이는 로컬 상태가 테스트간에 충돌 할 수있는 모듈을 격리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ee7cc0bddf7c5a4ef8549ea7c38c8d601b2255d" translate="yes" xml:space="preserve">
          <source>Resets the state of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt;&lt;code&gt;.mockReset()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">모든 모의 상태를 재설정합니다. 모든 조롱 된 함수에서 &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt; &lt;code&gt;.mockReset()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="46554c07d0e0360541685d38d9047e14f0a0601e" translate="yes" xml:space="preserve">
          <source>Respect Browserify's &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt; in &lt;code&gt;package.json&lt;/code&gt; when resolving modules. Some modules export different versions based on whether they are operating in Node or a browser.</source>
          <target state="translated">모듈을 확인할 때 &lt;code&gt;package.json&lt;/code&gt; 에서 Browserify의 &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt; &lt;code&gt;&quot;browser&quot;&lt;/code&gt; 필드&lt;/a&gt; 를 존중하십시오 . 일부 모듈은 노드에서 작동하는지 브라우저에서 작동하는지에 따라 다른 버전을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="27aceef5796ab8d68aed06c602f37330d5a900d4" translate="yes" xml:space="preserve">
          <source>Restores all mocks back to their original value. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt;&lt;code&gt;.mockRestore()&lt;/code&gt;&lt;/a&gt; on every mocked function. Beware that &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;; other mocks will require you to manually restore them.</source>
          <target state="translated">모든 모형을 원래 값으로 복원합니다. 모든 조롱 된 함수에서 &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt; &lt;code&gt;.mockRestore()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 . 그주의 &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; 모의가 작성된 시점에만 작동 &lt;code&gt;jest.spyOn&lt;/code&gt; ; 다른 모형은 수동으로 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ddb9b055cad613e29453fa554de9f36c7d6c8dd" translate="yes" xml:space="preserve">
          <source>Retry with &lt;a href=&quot;cli#--cache&quot;&gt;&lt;code&gt;--no-cache&lt;/code&gt;&lt;/a&gt;. Jest caches transformed module files to speed up test execution. If you are using your own custom transformer, consider adding a &lt;code&gt;getCacheKey&lt;/code&gt; function to it: &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#--cache&quot;&gt; &lt;code&gt;--no-cache&lt;/code&gt; 로&lt;/a&gt; 다시 시도하십시오 . Jest는 변환 된 모듈 파일을 캐시하여 테스트 실행 속도를 높입니다. 고유 한 사용자 정의 변환기를 사용하는 경우 &lt;code&gt;getCacheKey&lt;/code&gt; 함수를 추가 하십시오 (예 : &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="156ec26504d2692465a0d8ff00489f7b36d9fa41" translate="yes" xml:space="preserve">
          <source>Returns a boolean (or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for handling asynchronous operations) to specify if a test should be run or not.</source>
          <target state="translated">테스트 실행 여부를 지정 하는 부울 (또는 비동기 작업 처리를위한 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; )을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d66ba4a66cb6cf526e2e08e5bcc4265e970107d" translate="yes" xml:space="preserve">
          <source>Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.</source>
          <target state="translated">모듈의 정상적인 필요 여부에 대한 모든 검사를 무시하고 실제 모듈 대신 모의 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9da978b2f0e20c11e4aa75b10631e43a25e02ab4" translate="yes" xml:space="preserve">
          <source>Returns a new, unused &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;. Optionally takes a mock implementation.</source>
          <target state="translated">사용되지 않은 새로운 &lt;a href=&quot;mock-function-api&quot;&gt;mock 함수를&lt;/a&gt; 반환 합니다 . 선택적으로 모의 구현을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a1acf18173b267510a46851d55a523216adab36c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;jest&lt;/code&gt; object for chaining.</source>
          <target state="translated">체이닝을위한 &lt;code&gt;jest&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d08519e49635fb031179ab7f05284949daef9383" translate="yes" xml:space="preserve">
          <source>Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.</source>
          <target state="translated">모듈이 모의 구현을 받아야하는지 여부에 대한 모든 검사를 무시하고 모의 대신 실제 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2add96bbc9e9900cf433a5f2ebe6d67cb4660cf1" translate="yes" xml:space="preserve">
          <source>Returns the mock name string set by calling &lt;code&gt;mockFn.mockName(value)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mockFn.mockName(value)&lt;/code&gt; 을 호출하여 설정된 모의 이름 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd9336539157509732381e95d2e9b2f4ceef9877" translate="yes" xml:space="preserve">
          <source>Returns the number of fake timers still left to run.</source>
          <target state="translated">여전히 실행중인 가짜 타이머 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="641d1b198a65bb1bd4728078175e361d73f060b6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;yarn test&lt;/code&gt; to run tests with Jest.</source>
          <target state="translated">&lt;code&gt;yarn test&lt;/code&gt; 를 실행하여 Jest로 테스트 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7306d688c7598b3d294777df07da99e3d93d653c" translate="yes" xml:space="preserve">
          <source>Run All Timers</source>
          <target state="translated">모든 타이머 실행</target>
        </trans-unit>
        <trans-unit id="30ad8b68bab570303d35cefd0d73cf6056dbfc2d" translate="yes" xml:space="preserve">
          <source>Run Pending Timers</source>
          <target state="translated">보류 타이머 실행</target>
        </trans-unit>
        <trans-unit id="c89b3947b20f77096b75ca74d8fccf7526f1872b" translate="yes" xml:space="preserve">
          <source>Run all tests (default):</source>
          <target state="translated">모든 테스트를 실행하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="02b363bdd7980fccab5552af0568d148195655d4" translate="yes" xml:space="preserve">
          <source>Run all tests affected by file changes in the last commit made. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">마지막 커밋에서 파일 변경의 영향을받는 모든 테스트를 실행하십시오. &lt;code&gt;--onlyChanged&lt;/code&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcaa420e9fe3c70be68c6d8ee7d82ab5720e907" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with a pattern or filename:</source>
          <target state="translated">패턴 또는 파일 이름으로 지정된 테스트 만 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="92d791c05598e8218af4368bc378173046cea720" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with their exact paths.</source>
          <target state="translated">정확한 경로로 지정된 테스트 만 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="23686a3a58e4a1259f35510a9d0252c4f6745f24" translate="yes" xml:space="preserve">
          <source>Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt;&lt;code&gt;projects&lt;/code&gt;&lt;/a&gt; configuration option. Note that if configuration files are found in the specified paths, &lt;em&gt;all&lt;/em&gt; projects specified within those configuration files will be run.</source>
          <target state="translated">지정된 경로에있는 하나 이상의 프로젝트에서 테스트를 실행하십시오. 경로 globs도 필요합니다. 이 옵션은 &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt; &lt;code&gt;projects&lt;/code&gt; &lt;/a&gt; 구성 옵션에 해당하는 CLI 입니다. 지정된 경로에 구성 파일이 있으면 해당 구성 파일 내에 지정된 &lt;em&gt;모든&lt;/em&gt; 프로젝트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ddd0d105f6204c8e90c3adf874ea7bc2b26987" translate="yes" xml:space="preserve">
          <source>Run tests related to &lt;code&gt;path/to/fileA.js&lt;/code&gt; and &lt;code&gt;path/to/fileB.js&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;path/to/fileA.js&lt;/code&gt; 및 &lt;code&gt;path/to/fileB.js&lt;/code&gt; 와 관련된 테스트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2de5d0d69fc805a58b350e937e2690429d2970e2" translate="yes" xml:space="preserve">
          <source>Run tests related to changed files based on hg/git (uncommitted files):</source>
          <target state="translated">hg / git (커밋되지 않은 파일)를 기반으로 변경된 파일과 관련된 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a44ae954d1ab8ef98e8adfe8b4785726ef8e4670" translate="yes" xml:space="preserve">
          <source>Run tests that match this spec name (match against the name in &lt;code&gt;describe&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;, basically).</source>
          <target state="translated">이 스펙 이름과 일치하는 테스트를 실행하십시오 ( 기본적으로 &lt;code&gt;describe&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 의 이름과 일치 ).</target>
        </trans-unit>
        <trans-unit id="3250ade6678b3bc2a1ae0933ebec438d66c4c65a" translate="yes" xml:space="preserve">
          <source>Run tests with specified reporters. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Reporter options&lt;/a&gt; are not available via CLI. Example with multiple reporters:</source>
          <target state="translated">지정된 기자와 함께 테스트를 실행하십시오. CLI를 통해 &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;리포터 옵션&lt;/a&gt; 을 사용할 수 없습니다. 여러 기자가있는 예 :</target>
        </trans-unit>
        <trans-unit id="1e9d71147bb217981f158928624c5b13a6be2ead" translate="yes" xml:space="preserve">
          <source>Run watch mode:</source>
          <target state="translated">시계 모드 실행 :</target>
        </trans-unit>
        <trans-unit id="6317e775f03f11757290b5bce78a11c48721ccd6" translate="yes" xml:space="preserve">
          <source>Running from command line</source>
          <target state="translated">명령 줄에서 실행</target>
        </trans-unit>
        <trans-unit id="3d642ff91fd7ebdca37f4b2895153e438af4b378" translate="yes" xml:space="preserve">
          <source>Running from the command line</source>
          <target state="translated">명령 줄에서 실행</target>
        </trans-unit>
        <trans-unit id="437a88c377620b15b1bd26b6489ffe7cf9e58772" translate="yes" xml:space="preserve">
          <source>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">이 파일의 모든 테스트가 완료된 후 기능을 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 계속 진행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="50450676d930383c48d2ec3efefa163347c39da6" translate="yes" xml:space="preserve">
          <source>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">이 파일의 각 테스트가 완료된 후 기능을 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 계속 진행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="44b753442cff11f6ed337230a6a654b466728c0d" translate="yes" xml:space="preserve">
          <source>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</source>
          <target state="translated">이 파일의 테스트가 실행되기 전에 함수를 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 테스트를 실행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="57284652d7931aab5ea782fa00d26cf2b4c59502" translate="yes" xml:space="preserve">
          <source>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</source>
          <target state="translated">이 파일의 각 테스트가 실행되기 전에 기능을 실행합니다. 함수가 약속을 반환하거나 생성기 인 경우 Jest는 테스트를 실행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="8886a35ac5b619bcc55c828058cdaa29e97376a1" translate="yes" xml:space="preserve">
          <source>Runs failed tests n-times until they pass or until the max number of retries is exhausted. This only works with &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt;!</source>
          <target state="translated">실패한 테스트를 통과 할 때까지 또는 최대 재시도 횟수가 끝날 때까지 n 번 실패한 테스트를 실행합니다. 이것은 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt; 에서만 작동합니다 !</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
