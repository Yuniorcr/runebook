<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="q">
    <body>
      <group id="q">
        <trans-unit id="f0981f1324a7c67a6d8e261ad6608dee5ae431a3" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2017 Kristopher Michael Kowal</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2017 Kristopher Michael Kowal</target>
        </trans-unit>
        <trans-unit id="47c94724aa92750cfd8f557bf2484c29260f72d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; returns a promise, which will become resolved with the same fulfillment value or rejection reason as &lt;code&gt;promise&lt;/code&gt;. However, if &lt;code&gt;callback&lt;/code&gt; returns a promise, the resolution of the returned promise will be delayed until the promise returned from &lt;code&gt;callback&lt;/code&gt; is finished. Furthermore, if the returned promise rejects, that rejection will be passed down the chain instead of the previous result.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 같은 성취 값 또는 거부 이유 해결 될 것입니다 약속, 반환 &lt;code&gt;promise&lt;/code&gt; . 그러나, &lt;code&gt;callback&lt;/code&gt; 약속을 반환에서 반환 약속 할 때까지 반환 약속의 해상도가 지연 될 &lt;code&gt;callback&lt;/code&gt; 완료됩니다. 또한 반환 된 약속이 거부되면 해당 거부는 이전 결과 대신 체인으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9e255e440478d966ef66bd07a0d3f82cca6ed20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;makeNodeResolver()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;makeNodeResolver()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="9d7d1abc096fefcb950638f2a44550fc3d76142f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(value)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;notify(value)&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="43e4032a7c51a1aef78351b37f12b8a6abbafe4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;promise&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;promise&lt;/code&gt; 재산</target>
        </trans-unit>
        <trans-unit id="9002548e37f987a07036927f332519aeed75bea5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reject(reason)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;reject(reason)&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="d9ec58771c2d55ed24df135dfeca968af1cddd8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve(value)&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;resolve(value)&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="228842e8684d06b61fdbb531b50d1865755241e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;Q.nsend&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;Q.nsend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b5d0f804b538f7886b440ac8e8865def7aa705d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.fail&lt;/code&gt; (for non-ES5 browsers)</source>
          <target state="translated">&lt;em&gt;별명 : &lt;/em&gt; &lt;code&gt;promise.fail&lt;/code&gt; (ES5 이외의 브라우저 용)</target>
        </trans-unit>
        <trans-unit id="2118449aa2a3bda191f7a26ce83eefb29454a841" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.fin&lt;/code&gt; (for non-ES5 browsers)</source>
          <target state="translated">&lt;em&gt;별명 : &lt;/em&gt; &lt;code&gt;promise.fin&lt;/code&gt; (ES5 이외의 브라우저 용)</target>
        </trans-unit>
        <trans-unit id="edfe6bc410ab1b3a0acc4435d6a21fe2e5fe9b07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.send&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;Alias:&lt;/em&gt;&lt;code&gt;promise.send&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f7076e434da58268bca551d18ff2736f04dbf61" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alias&lt;/em&gt;: &lt;code&gt;Q.denodeify&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;별명&lt;/em&gt; : &lt;code&gt;Q.denodeify&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d3962fdfa3dbe8bde2a4417e8f88935beabeb63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated Alias&lt;/em&gt;: &lt;code&gt;Q.nmapply&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;더 이상 사용되지 않는 별칭&lt;/em&gt; : &lt;code&gt;Q.nmapply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db96878e56374a9ebdefa960f6ec863036138e90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated Alias&lt;/em&gt;: &lt;code&gt;Q.nmcall&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;더 이상 사용되지 않는 별칭&lt;/em&gt; : &lt;code&gt;Q.nmcall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f84fcdb12cce76069ceb62581a6a0c0f88dfb8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated:&lt;/em&gt;&lt;code&gt;promise.observeEstimate&lt;/code&gt; or a similar interface is due to replace this method in version 2. Progress does not compose well. &lt;a href=&quot;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&quot;&gt;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;더 이상 사용되지 않음 : &lt;/em&gt; &lt;code&gt;promise.observeEstimate&lt;/code&gt; 또는 이와 유사한 인터페이스는 버전 2에서이 방법을 대체 할 예정입니다. 진행률이 제대로 구성되지 않습니다. &lt;a href=&quot;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&quot;&gt;https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ba06898cc9f24bd326cb6c5201c4d462c0857bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experimental Alias&lt;/em&gt;: &lt;code&gt;promise.mapply&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;실험적 별칭&lt;/em&gt; : &lt;code&gt;promise.mapply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7914a9c5bdbf06c996e490a2801a150d0bf14874" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Experimental Alias&lt;/em&gt;: &lt;code&gt;promise.mcall&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;실험 별칭&lt;/em&gt; : &lt;code&gt;promise.mcall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f419c6734901c9ba6632fe76d2fbc802a9b0437d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Introduced in version 1.1.0 (November 2014)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;버전 1.1.0에서 도입 (2014 년 11 월)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14ca715bb1f30393c961e3d1ccb89277911e98f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;No Static Counterpart&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;정적 대응 물 없음&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a414d0df4a72cd1169cdbd51cdcd526c8a6745d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Alias:&lt;/em&gt;&lt;code&gt;Q.try&lt;/code&gt; (ES5 browsers only)</source>
          <target state="translated">&lt;em&gt;정적 별명 : &lt;/em&gt; &lt;code&gt;Q.try&lt;/code&gt; (ES5 브라우저 전용)</target>
        </trans-unit>
        <trans-unit id="3e29674d2681d615252c778a6b6c5a9b611162b3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The Golden Rule of &lt;code&gt;done&lt;/code&gt; vs. &lt;code&gt;then&lt;/code&gt; usage is: either &lt;code&gt;return&lt;/code&gt; your promise to someone else, or if the chain ends with you, call &lt;code&gt;done&lt;/code&gt; to terminate it. Terminating with &lt;code&gt;catch&lt;/code&gt; is not sufficient because the catch handler may itself throw an error.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;의 황금률 &lt;code&gt;done&lt;/code&gt; 대는 &lt;code&gt;then&lt;/code&gt; 사용법은 다음 중 하나를 &lt;code&gt;return&lt;/code&gt; 다른 사람에게 당신의 약속을, 또는 당신과 함께 체인의 끝, 호출이있는 경우 &lt;code&gt;done&lt;/code&gt; 을 종료 할 수 있습니다. catch 핸들러 자체에서 오류가 발생할 수 있으므로 &lt;code&gt;catch&lt;/code&gt; 로 종료하는 것만으로는 충분하지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba6b98fa9f88a673e8952daf8ef9d6dfd171413d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This functionality is experimental.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 기능은 실험적입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="630214b5d545b217b93c5bae4d74868ba4f6edd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;note&lt;/strong&gt;: In the latest github, this method is called Q.Promise, but if you are using the npm package version 0.9.7 or below, the method is called Q.promise (lowercase vs uppercase p).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 최신 github에서는이 방법을 Q.Promise라고하지만 npm 패키지 버전 0.9.7 이하를 사용하는 경우이 방법을 Q.promise (소문자 대 대문자 p)라고합니다.</target>
        </trans-unit>
        <trans-unit id="360fde535483e090afa91e4f8bcbdf00421e7a52" translate="yes" xml:space="preserve">
          <source>A settable property that lets you turn on long stack trace support. If turned on, &quot;stack jumps&quot; will be tracked across asynchronous promise operations, so that if an uncaught error is thrown by &lt;code&gt;done&lt;/code&gt; or a rejection reason's &lt;code&gt;stack&lt;/code&gt; property is inspected in a rejection callback, a long stack trace is produced.</source>
          <target state="translated">긴 스택 추적 지원을 설정할 수있는 설정 가능한 속성입니다. 켜져있는 경우, &quot;스택은 점프&quot;, 비동기 약속 작업을 통해 추적 할 수 그래서 캐치되지 않는 오류가 발생하는 경우 &lt;code&gt;done&lt;/code&gt; 또는 거부 사유의 &lt;code&gt;stack&lt;/code&gt; 속성이 거부 콜백에서 검사되고, 긴 스택 추적이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7d5d1de342dd19dac409116a1790776a3c96bc" translate="yes" xml:space="preserve">
          <source>A settable property that will intercept any uncaught errors that would otherwise be thrown in the next tick of the event loop, usually as a result of &lt;code&gt;done&lt;/code&gt;. Can be useful for getting the full stack trace of an error in browsers, which is not usually possible with &lt;code&gt;window.onerror&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;done&lt;/code&gt; 의 결과로 이벤트 루프의 다음 틱에서 발생하는 잡히지 않은 오류를 가로채는 설정 가능한 특성입니다 . 브라우저에서 오류의 전체 스택 추적을 얻는 데 유용 할 수 있습니다 . 일반적으로 &lt;code&gt;window.onerror&lt;/code&gt; 로는 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="cc164fcfb8a39667ad143fc8a656a4c1a9bc4df1" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(function () { return value; })&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(function () { return value; })&lt;/code&gt; 와 동등한 sugar 메서드 입니다.</target>
        </trans-unit>
        <trans-unit id="8f9e7fe97f002fa8b6eae38edd5277d4beffbd97" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(function () { throw reason; })&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(function () { throw reason; })&lt;/code&gt; 과 동등한 sugar 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="9e0ddce10f1069e658b3bfcee13483384e1381b3" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(undefined, onRejected)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise.then(undefined, onRejected)&lt;/code&gt; 와 동등한 설탕 방법 .</target>
        </trans-unit>
        <trans-unit id="c91134fdc4cd8b26846af66ab5e62f37ef68fa35" translate="yes" xml:space="preserve">
          <source>A sugar method, equivalent to &lt;code&gt;promise.then(undefined, undefined, onProgress)&lt;/code&gt;. The &lt;code&gt;onProgress&lt;/code&gt; handler receives values that were sent to this promise either from the &lt;code&gt;notify&lt;/code&gt; method of the corresponding deferred, or from the promise that this promise became by virtue of being returned from a handler.</source>
          <target state="translated">&lt;code&gt;promise.then(undefined, undefined, onProgress)&lt;/code&gt; 와 동등한 sugar 메서드 입니다. &lt;code&gt;onProgress&lt;/code&gt; 핸들러로부터 어느 약속에 송신 된 값은 수신 &lt;code&gt;notify&lt;/code&gt; 이 지연 대응하는 방법, 또는 이러한 약속 핸들러로부터 반환되는 덕분에 약속 된 것으로부터.</target>
        </trans-unit>
        <trans-unit id="fb15cb0ae41ac3c447a303c95d175aaf01577b70" translate="yes" xml:space="preserve">
          <source>Attaches a handler that will observe the value of the promise when it becomes fulfilled, returning a promise for that same value, perhaps deferred but not replaced by the promise returned by the &lt;code&gt;onFulfilled&lt;/code&gt; handler.</source>
          <target state="translated">첨부합니다이 성취된다 때 같은 값, 아마도 연기 만에 의해 반환 약속에 의해 대체되지 않습니다에 대한 약속을 반환 약속의 값을 관찰하는 핸들러 &lt;code&gt;onFulfilled&lt;/code&gt; 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="286b1a5cc64d77383fc9aef74dda8bc27ead7742" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;notify&lt;/code&gt; with a value causes &lt;code&gt;promise&lt;/code&gt; to be notified of progress with that value. That is, any &lt;code&gt;onProgress&lt;/code&gt; handlers registered with &lt;code&gt;promise&lt;/code&gt; or promises derived from &lt;code&gt;promise&lt;/code&gt; will be called with the progress value.</source>
          <target state="translated">값을 사용하여 &lt;code&gt;notify&lt;/code&gt; 을 호출 하면 해당 값의 진행 상황을 &lt;code&gt;promise&lt;/code&gt; 할 수 있습니다. 즉, 어떤 &lt;code&gt;onProgress&lt;/code&gt; 에 등록 된 핸들러 &lt;code&gt;promise&lt;/code&gt; 또는에서 파생 된 약속 &lt;code&gt;promise&lt;/code&gt; 진행 값으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c4f3ddc374fc41ceadf05240b53010c4536134a0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reject&lt;/code&gt; with a reason causes &lt;code&gt;promise&lt;/code&gt; to be rejected with that reason.</source>
          <target state="translated">이유가있는 &lt;code&gt;reject&lt;/code&gt; 를 호출 하면 해당 이유로 &lt;code&gt;promise&lt;/code&gt; 이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5425c48a55640821fe47530cf201775e1ef8ff" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a fulfilled promise causes &lt;code&gt;promise&lt;/code&gt; to be fulfilled with the passed promise's fulfillment value.</source>
          <target state="translated">호출 &lt;code&gt;resolve&lt;/code&gt; 이행 된 약속 원인과 &lt;code&gt;promise&lt;/code&gt; 전달 된 약속의 성취 값으로 성취 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="813a4a7641c9b6bd9bbdc971a738d65fb5e45d55" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a non-promise value causes &lt;code&gt;promise&lt;/code&gt; to be fulfilled with that value.</source>
          <target state="translated">약속되지 않은 값으로 &lt;code&gt;resolve&lt;/code&gt; 를 호출 하면 해당 값으로 &lt;code&gt;promise&lt;/code&gt; 이 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="7011bdd155303903e358ec08c68cd3a6d93575fc" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a pending promise causes &lt;code&gt;promise&lt;/code&gt; to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).</source>
          <target state="translated">계류중인 약속으로 &lt;code&gt;resolve&lt;/code&gt; 를 부름 으로써, 약속 된 &lt;code&gt;promise&lt;/code&gt; 을 기다리게되어 약속 한 이행 가치로 이행되거나 거절 사유로 거부됩니다 (또는 통과 된 약속이있는 경우 영원히 계류 상태를 유지함).</target>
        </trans-unit>
        <trans-unit id="6acc2e709ed1c95cfc1a249306618feb62d7ecda" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;resolve&lt;/code&gt; with a rejected promise causes &lt;code&gt;promise&lt;/code&gt; to be rejected with the passed promise's rejection reason.</source>
          <target state="translated">호출 &lt;code&gt;resolve&lt;/code&gt; 거부 약속 원인과 &lt;code&gt;promise&lt;/code&gt; 전달 된 약속의 거부 사유로 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e270f7316cd8465770c808a872e50d981955d54" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style function with the given array of arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">주어진 인수 배열을 사용하여 Node.js 스타일 함수를 호출하고, Node.js 함수가 결과를 다시 호출하면 충족되거나, 오류가 발생하여 다시 호출되면 (또는 동 기적으로 throw) 약속을 반환합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="30912d3497e790cf1cb567d187ab2a29c5c0a405" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style function with the given variadic arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">주어진 가변 인수를 사용하여 Node.js 스타일 함수를 호출하고, Node.js 함수가 결과를 다시 호출하면 충족되거나, 오류가 발생하여 다시 호출되면 (또는 동 기적으로 throw) 거부되는 약속을 반환합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ea81644f23eac4e3da8f7f52fea4fc9b35e1c8f0" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style method with the given arguments array, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">주어진 arguments 배열을 사용하여 Node.js 스타일의 메소드를 호출하여 메소드가 결과로 다시 호출하면 충족되거나 약속이 오류로 다시 호출되면 거부되는 약속을 반환합니다 (또는 동기식으로 throw). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b7515f9aab2d0076fc370a8befe0541a8ab1b175" translate="yes" xml:space="preserve">
          <source>Calls a Node.js-style method with the given variadic arguments, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</source>
          <target state="translated">주어진 variadic 인수를 사용하여 Node.js 스타일의 메소드를 호출하여 메소드가 결과로 다시 호출하면 충족되거나 오류로 다시 호출되면 거부되거나 (또는 ​​동기식으로 throw) 약속을 리턴합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a810371fa4c94a6ce7ad4af13115b6cafd48de09" translate="yes" xml:space="preserve">
          <source>Care should be taken not to introduce control-flow hazards and security holes when forwarding messages to promises. The functions above, particularly &lt;code&gt;then&lt;/code&gt;, are carefully crafted to prevent a poorly crafted or malicious promise from breaking the invariants like not applying callbacks multiple times or in the same turn of the event loop.</source>
          <target state="translated">메시지를 약속으로 전달할 때 제어 흐름 위험 및 보안 허점이 발생하지 않도록주의해야합니다. 특히, 위의 기능을 &lt;code&gt;then&lt;/code&gt; , 조심스럽게 콜백을 여러 번 적용되지처럼 또는 이벤트 루프의 턴의 불변을 깨는에서 잘못 조작되거나 악의적 인 약속을 방지하기 위해 만들어진 있습니다.</target>
        </trans-unit>
        <trans-unit id="79db3d64d910483618c2a0f35c05edf9799c43ef" translate="yes" xml:space="preserve">
          <source>Core Promise</source>
          <target state="translated">핵심 약속</target>
        </trans-unit>
        <trans-unit id="caa6108533eba773194abce34b359c7a9b0238a6" translate="yes" xml:space="preserve">
          <source>Core Promise Methods</source>
          <target state="translated">핵심 약속 방법</target>
        </trans-unit>
        <trans-unit id="2fba880dc7d33f80254834d185041f3f7d80b24f" translate="yes" xml:space="preserve">
          <source>Creates a new version of &lt;code&gt;func&lt;/code&gt; that accepts any combination of promise and non-promise values, converting them to their fulfillment values before calling the original &lt;code&gt;func&lt;/code&gt;. The returned version also always returns a promise: if &lt;code&gt;func&lt;/code&gt; does a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt;, then &lt;code&gt;Q.promised(func)&lt;/code&gt; will return fulfilled or rejected promise, respectively.</source>
          <target state="translated">약속 및 비 약속 값의 모든 조합을 허용하고 원래 &lt;code&gt;func&lt;/code&gt; 를 호출하기 전에 이행 값으로 변환 하는 새 버전의 &lt;code&gt;func&lt;/code&gt; 을 만듭니다 . 반환 된 버전은 항상 약속을 반환합니다. &lt;code&gt;func&lt;/code&gt; 가 &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 를 수행하면 &lt;code&gt;Q.promised(func)&lt;/code&gt; 는 각각 이행 또는 거부 된 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c38227424efde920d83633b331700c062c735e6" translate="yes" xml:space="preserve">
          <source>Creates a promise-returning function from a Node.js-style function, optionally binding it with the given variadic arguments. An example:</source>
          <target state="translated">Node.js 스타일 함수에서 약속 반환 함수를 작성하고 선택적으로 지정된 가변 인수와 바인딩합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="73898e6817218495671980abb0510aa5f928f5c4" translate="yes" xml:space="preserve">
          <source>Creates a promise-returning function from a Node.js-style method, optionally binding it with the given variadic arguments. An example:</source>
          <target state="translated">Node.js 스타일의 메소드에서 약속 반환 함수를 작성하고, 선택적으로 지정된 가변 인수와 바인딩합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="20457947466b5a4446435b2cd8859b4fabfb0a71" translate="yes" xml:space="preserve">
          <source>Custom Messaging</source>
          <target state="translated">맞춤 메시징</target>
        </trans-unit>
        <trans-unit id="75fa48c8c7a2cb4f89ad8c76224f011589ab9f64" translate="yes" xml:space="preserve">
          <source>Custom Messaging API (Advanced)</source>
          <target state="translated">맞춤 메시징 API (고급)</target>
        </trans-unit>
        <trans-unit id="4b4df21f5e0c20682e7715d55ffa3b7308180032" translate="yes" xml:space="preserve">
          <source>Deferreds are cool because they separate the promise part from the resolver part. So:</source>
          <target state="translated">지연된 부분은 약속 부분을 리졸버 부분과 분리하기 때문에 시원합니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="e727dc9f8b51e23ab82e57412e76770fce6e8db5" translate="yes" xml:space="preserve">
          <source>Error Handling and Tracking</source>
          <target state="translated">오류 처리 및 추적</target>
        </trans-unit>
        <trans-unit id="a7458ec3892a2bebe00f22cd004670aea656d9b9" translate="yes" xml:space="preserve">
          <source>Exceptions thrown by &lt;code&gt;done&lt;/code&gt; will have long stack traces, if &lt;code&gt;Q.longStackSupport&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Q.onerror&lt;/code&gt; is set, exceptions will be delivered there instead of thrown in a future turn.</source>
          <target state="translated">&lt;code&gt;Q.longStackSupport&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 &lt;code&gt;done&lt;/code&gt; 에 의해 예외가 발생 하면 스택 추적이 길어 집니다 . 경우 &lt;code&gt;Q.onerror&lt;/code&gt; 이 설정되어, 예외가 전달 대신 미래 차례로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="3d8a4d046ac6da809fb06221161eeb7ead75fe7b" translate="yes" xml:space="preserve">
          <source>Gets an array of reasons belonging to rejected promises that currently have not been handled, i.e. no &lt;code&gt;onRejected&lt;/code&gt; callbacks have been called for them, they haven't been chained off of, etc. Generally these represent potentially-&quot;lost&quot; errors, so this array should be empty except possibly at times when you are passing a rejected promise around asynchronously so that someone can handle the rejection later.</source>
          <target state="translated">현재 처리되지 않은 거부 된 약속에 속하는 여러 가지 이유를 가져옵니다. 즉 &lt;code&gt;onRejected&lt;/code&gt; 콜백이 호출되지 않았거나 연결되지 않았습니다. 일반적으로 이러한 오류는 잠재적으로 &quot;손실 된&quot;오류를 나타내 므로이 배열 누군가가 거부를 나중에 처리 할 수 ​​있도록 거부 된 약속을 비동기 적으로 전달할 때를 제외하고는 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e38e1618908cfeefc0e5e089fa149954e44b2b83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is a function, assumes it's a Node.js-style callback, and calls it as either &lt;code&gt;callback(rejectionReason)&lt;/code&gt; when/if &lt;code&gt;promise&lt;/code&gt; becomes rejected, or as &lt;code&gt;callback(null, fulfillmentValue)&lt;/code&gt; when/if &lt;code&gt;promise&lt;/code&gt; becomes fulfilled. If &lt;code&gt;callback&lt;/code&gt; is not a function, simply returns &lt;code&gt;promise&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 함수이며, 그것은 Node.js를 스타일의 콜백의 가정 및 중로 호출하는 &lt;code&gt;callback(rejectionReason)&lt;/code&gt; 경우 / &lt;code&gt;promise&lt;/code&gt; 거부된다, 또는 &lt;code&gt;callback(null, fulfillmentValue)&lt;/code&gt; 경우 / &lt;code&gt;promise&lt;/code&gt; 성취된다. &lt;code&gt;callback&lt;/code&gt; 이 함수가 아닌 경우 간단히 &lt;code&gt;promise&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d870c0bb953c968f7f6f954238c49781793205a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;resolver&lt;/code&gt; throws an exception, the returned promise will be rejected with that thrown exception as the rejection reason.</source>
          <target state="translated">경우 &lt;code&gt;resolver&lt;/code&gt; 예외가 발생, 반환 약속은 거부 사유로 그 예외를 throw 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e800167077bfcca263f0edfc7b87d23872cdb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a Q promise, returns the promise.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 Q 약속 인 경우 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3463f13b311cd838c032d85d849d7d3b447f2dea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a promise from another library it is coerced into a Q promise (where possible).</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 다른 라이브러리의 약속 인 경우 Q 약속 (가능한 경우)으로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="f6647050a594ab7d676c6f7d488ca83cd8876d0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is not a promise, returns a promise that is fulfilled with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 약속이 아닌 경우 value 로 이행되는 약속을 반환 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02f5bfe583e29dae0f1bfe10ee899b8a530dbe5b" translate="yes" xml:space="preserve">
          <source>If the static version of &lt;code&gt;Q.delay&lt;/code&gt; is passed only a single argument, it returns a promise that will be fulfilled with &lt;code&gt;undefined&lt;/code&gt; after at least &lt;code&gt;ms&lt;/code&gt; milliseconds have passed. (If it's called with two arguments, it uses the usual static-counterpart translation, i.e. &lt;code&gt;Q.delay(value, ms)&lt;/code&gt; is equivalent to &lt;code&gt;Q(value).delay(ms)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;Q.delay&lt;/code&gt; 의 정적 버전에 단일 인수 만 전달되면 최소한 &lt;code&gt;ms&lt;/code&gt; 밀리 초가 지난 후에 &lt;code&gt;undefined&lt;/code&gt; 로 이행 될 가능성을 리턴합니다 . (두 개의 인수로 호출되면 일반적인 정적 카운터 변환을 사용합니다. 즉 &lt;code&gt;Q.delay(value, ms)&lt;/code&gt; 는 &lt;code&gt;Q(value).delay(ms)&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="add3eb1e5208d60fe31c3687c61b5f403b45c7ee" translate="yes" xml:space="preserve">
          <source>In all cases where a promise is resolved (i.e. either fulfilled or rejected), the resolution is permanent and cannot be reset. Attempting to call &lt;code&gt;resolve&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, or &lt;code&gt;notify&lt;/code&gt; if &lt;code&gt;promise&lt;/code&gt; is already resolved will be a no-op.</source>
          <target state="translated">약속이 해결 된 모든 경우 (즉, 이행 또는 거부) 해결은 영구적이며 재설정 할 수 없습니다. &lt;code&gt;promise&lt;/code&gt; 가 이미 해결 되었는지 &lt;code&gt;resolve&lt;/code&gt; , &lt;code&gt;reject&lt;/code&gt; 또는 &lt;code&gt;notify&lt;/code&gt; 을 호출하려고 시도 하면 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b1f77e2a8190c99f6bc8adc65c47d9eba56075b" translate="yes" xml:space="preserve">
          <source>In its static form, it is aliased as &lt;code&gt;Q.try&lt;/code&gt;, since it has semantics similar to a &lt;code&gt;try&lt;/code&gt; block (but handling both synchronous exceptions and asynchronous rejections). This allows code like</source>
          <target state="translated">정적 형식에서는 &lt;code&gt;try&lt;/code&gt; 블록 과 유사한 의미 를 &lt;code&gt;Q.try&lt;/code&gt; 때문에 동 기적 예외와 비동기 거부를 모두 처리하므로 Q.try 로 별칭이 지정됩니다 . 이것은 다음과 같은 코드를 허용합니다</target>
        </trans-unit>
        <trans-unit id="0e3f6c6c47261e255742e05dc9d19d1aacf67ca1" translate="yes" xml:space="preserve">
          <source>Interfacing with Node.js Callbacks</source>
          <target state="translated">Node.js 콜백과 인터페이스</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="6bb3f3a74ab5d643aef7bd0c90e11c56b3838c4d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;then&lt;/code&gt;, but &quot;spreads&quot; the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls &lt;code&gt;onRejected&lt;/code&gt; with the first rejected promise's rejection reason.</source>
          <target state="translated">마찬가지로 &lt;code&gt;then&lt;/code&gt; ,하지만 &quot;스프레드&quot;가변 인자 이행 핸들러에 배열입니다. 배열의 약속 중 하나라도 거부되면 대신 거부 된 첫 번째 약속의 거부 사유로 &lt;code&gt;onRejected&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6834ebe5b4c4edb612e9ee32bf8b353cd01491ac" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;finally&lt;/code&gt; clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 절 과 마찬가지로 약속의 이행 또는 거부를 관찰 할 수 있지만 최종 값을 수정하지 않고도 수행 할 수 있습니다. 이는 데이터베이스 연결 종료, 서버 종료 또는 오브젝트에서 불필요한 키 삭제와 같은 작업 성공 여부에 관계없이 자원을 수집하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d6aa98cb2cb7bd2f69117491e4e8f5f13e91c37" translate="yes" xml:space="preserve">
          <source>Most promise methods have &quot;static&quot; counterparts on the main &lt;code&gt;Q&lt;/code&gt; object, which will accept either a promise or a non-promise, and in the latter case create a fulfilled promise first. For example, &lt;code&gt;Q.when(5, onFulfilled)&lt;/code&gt; is equivalent to &lt;code&gt;Q(5).then(onFulfilled)&lt;/code&gt;. All others have static counterparts that are named the same as the promise method.</source>
          <target state="translated">대부분의 promise 메소드에는 기본 &lt;code&gt;Q&lt;/code&gt; 오브젝트 에 &quot;정적&quot;대응이 있으며 , 이는 약속 또는 약속이 아님을 승인하고 후자의 경우 먼저 이행 된 약속을 작성합니다. 예를 들어 &lt;code&gt;Q.when(5, onFulfilled)&lt;/code&gt; 는 &lt;code&gt;Q(5).then(onFulfilled)&lt;/code&gt; . 다른 모든 것에는 promise 메소드와 동일한 이름의 정적 대응 물이 있습니다.</target>
        </trans-unit>
        <trans-unit id="13fb576ea389ec07587f2efe71056e870f3606ab" translate="yes" xml:space="preserve">
          <source>Much like &lt;code&gt;then&lt;/code&gt;, but with different behavior around unhandled rejection. If there is an unhandled rejection, either because &lt;code&gt;promise&lt;/code&gt; is rejected and no &lt;code&gt;onRejected&lt;/code&gt; callback was provided, or because &lt;code&gt;onFulfilled&lt;/code&gt; or &lt;code&gt;onRejected&lt;/code&gt; threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a future turn of the event loop.</source>
          <target state="translated">같은 많은 &lt;code&gt;then&lt;/code&gt; ,하지만 처리되지 않은 거부 주위에 다른 행동. &lt;code&gt;promise&lt;/code&gt; 이 거부되고 &lt;code&gt;onRejected&lt;/code&gt; 콜백이 제공 되지 않았 거나 &lt;code&gt;onFulfilled&lt;/code&gt; 또는 &lt;code&gt;onRejected&lt;/code&gt; 가 오류를 던지거나 거부 된 약속을 반환 했기 때문에 처리되지 않은 거부 가 발생하면 이후의 이벤트 루프 전환시 거부 이유가 예외로 처리됩니다. .</target>
        </trans-unit>
        <trans-unit id="69f80067dcce936df962961121dbfe23a9e48842" translate="yes" xml:space="preserve">
          <source>Note that if a Node.js-style API calls back with more than one non-error parameter (e.g. &lt;a href=&quot;http://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback&quot;&gt;&lt;code&gt;child_process.execFile&lt;/code&gt;&lt;/a&gt;), Q packages these into an array as the promise's fulfillment value when doing the translation.</source>
          <target state="translated">Node.js 스타일 API가 둘 이상의 오류가 아닌 매개 변수 (예 : &lt;a href=&quot;http://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback&quot;&gt; &lt;code&gt;child_process.execFile&lt;/code&gt; &lt;/a&gt; )로 콜백하는 경우 Q는 변환을 수행 할 때이를 약속 이행 값으로 배열로 패키지합니다.</target>
        </trans-unit>
        <trans-unit id="96aaccd957a283b851a22d1d19be6b95869ff337" translate="yes" xml:space="preserve">
          <source>Note that if you have a &lt;em&gt;method&lt;/em&gt; that uses the Node.js callback pattern, as opposed to just a &lt;em&gt;function&lt;/em&gt;, you will need to bind its &lt;code&gt;this&lt;/code&gt; value before passing it to &lt;code&gt;nfbind&lt;/code&gt;, like so:</source>
          <target state="translated">당신이있는 경우주의 &lt;em&gt;방법&lt;/em&gt; Node.js를 콜백 패턴을 사용, 단지 반대 &lt;em&gt;기능&lt;/em&gt; , 당신은 그것의 결합해야합니다 &lt;code&gt;this&lt;/code&gt; 그것을 전달하기 전에 값을 &lt;code&gt;nfbind&lt;/code&gt; 과 같이 :</target>
        </trans-unit>
        <trans-unit id="81a18822d86a6015f99c23268915b7a5af8b24d2" translate="yes" xml:space="preserve">
          <source>Note that this example only works because &lt;code&gt;FS.readFile&lt;/code&gt; is a &lt;em&gt;function&lt;/em&gt; exported from a module, not a &lt;em&gt;method&lt;/em&gt; on an object. For methods, e.g. &lt;code&gt;redisClient.get&lt;/code&gt;, you must bind the method to an instance before passing it to &lt;code&gt;Q.nfapply&lt;/code&gt; (or, generally, as an argument to any function call):</source>
          <target state="translated">이 예제 는 &lt;code&gt;FS.readFile&lt;/code&gt; 이 객체 의 &lt;em&gt;메소드가&lt;/em&gt; 아니라 모듈에서 내 보낸 &lt;em&gt;함수&lt;/em&gt; 이기 때문에 작동 합니다. &lt;code&gt;redisClient.get&lt;/code&gt; 와 같은 메소드의 경우, 메소드를 &lt;code&gt;Q.nfapply&lt;/code&gt; (또는 일반적으로 함수 호출에 대한 인수)로 전달하기 전에 메소드를 인스턴스에 바인드해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6db6293c0d5001e6f96b2d11dfe8c9cdd298f3f" translate="yes" xml:space="preserve">
          <source>Note that this will result in the same return value/thrown exception translation as explained above for &lt;code&gt;fbind&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;fbind&lt;/code&gt; 에 대해 위에서 설명한 것과 동일한 반환 값 / throw 예외 변환을 초래 합니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="985ba7e7f893aa9f3723657bbeebc63e206d0629" translate="yes" xml:space="preserve">
          <source>Promise Creation</source>
          <target state="translated">약속 창조</target>
        </trans-unit>
        <trans-unit id="f7dac5dee122443b910400ee35793e2eca25c396" translate="yes" xml:space="preserve">
          <source>Promise Methods</source>
          <target state="translated">약속 방법</target>
        </trans-unit>
        <trans-unit id="f1d46e5761361fc66ff5ba7db05edb32598e6da3" translate="yes" xml:space="preserve">
          <source>Promise-for-Array</source>
          <target state="translated">Promise-for-Array</target>
        </trans-unit>
        <trans-unit id="c8ab2ca63d38aed84bff8299bffa6e85932741ad" translate="yes" xml:space="preserve">
          <source>Promise-for-Array Methods</source>
          <target state="translated">배열을위한 약속 방법</target>
        </trans-unit>
        <trans-unit id="ed29a3b76c93c87ac007e026b2969daa083ade34" translate="yes" xml:space="preserve">
          <source>Promise-for-Function</source>
          <target state="translated">Promise-for-Function</target>
        </trans-unit>
        <trans-unit id="6a0f6c01a0201f474dcba6fe03b353f09247a4df" translate="yes" xml:space="preserve">
          <source>Promise-for-Function Methods</source>
          <target state="translated">기능 약속 방법</target>
        </trans-unit>
        <trans-unit id="1d74958f915b9a8d09ad81f764c3e3ad5c8f3e75" translate="yes" xml:space="preserve">
          <source>Promise-for-Object</source>
          <target state="translated">Promise-for-Object</target>
        </trans-unit>
        <trans-unit id="c05db34be2fd0069344eeabde7ac2039cb5bb813" translate="yes" xml:space="preserve">
          <source>Promise-for-Object Methods</source>
          <target state="translated">객체에 대한 약속 방법</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="c564adc0672165d0247a601f040788fb7f7cc8cd" translate="yes" xml:space="preserve">
          <source>Q object</source>
          <target state="translated">Q 객체</target>
        </trans-unit>
        <trans-unit id="eb4c479556196d662563ac704263f35f8b48f245" translate="yes" xml:space="preserve">
          <source>Q provides a number of functions for interfacing with Node.js style &lt;code&gt;(err, result)&lt;/code&gt; callback APIs.</source>
          <target state="translated">Q는 Node.js 스타일 &lt;code&gt;(err, result)&lt;/code&gt; 콜백 API 와 인터페이스하기위한 여러 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba55744b39630d1585977c7fa135ac1654beef6" translate="yes" xml:space="preserve">
          <source>Q()</source>
          <target state="translated">Q()</target>
        </trans-unit>
        <trans-unit id="11ebf3d51b7d3cb4a808730bc74db97b03f5b0ca" translate="yes" xml:space="preserve">
          <source>Q(value)</source>
          <target state="translated">Q(value)</target>
        </trans-unit>
        <trans-unit id="882e9b9f3692eb8dea0e2c3fe21be3ff2e02e787" translate="yes" xml:space="preserve">
          <source>Q.Promise()</source>
          <target state="translated">Q.Promise()</target>
        </trans-unit>
        <trans-unit id="9ac23459bf64c4b05451ebf2ca588dfac36875a0" translate="yes" xml:space="preserve">
          <source>Q.Promise(resolver)</source>
          <target state="translated">Q.Promise(resolver)</target>
        </trans-unit>
        <trans-unit id="0954da9e4575d1d71de230a8796f79dc6b629ad2" translate="yes" xml:space="preserve">
          <source>Q.async()</source>
          <target state="translated">Q.async()</target>
        </trans-unit>
        <trans-unit id="28a5183740e005625501d3f8c933834f080b1115" translate="yes" xml:space="preserve">
          <source>Q.async(generatorFunction)</source>
          <target state="translated">Q.async(generatorFunction)</target>
        </trans-unit>
        <trans-unit id="da1dd7ad69401ce1b8380cd36799985b78a61256" translate="yes" xml:space="preserve">
          <source>Q.defer()</source>
          <target state="translated">Q.defer()</target>
        </trans-unit>
        <trans-unit id="f2492beb7cfbb6ace0a70545c4779ad96a6d6a42" translate="yes" xml:space="preserve">
          <source>Q.delay()</source>
          <target state="translated">Q.delay()</target>
        </trans-unit>
        <trans-unit id="879a7909385aaa69995f5ed0959b15930bd7259c" translate="yes" xml:space="preserve">
          <source>Q.delay(ms)</source>
          <target state="translated">Q.delay(ms)</target>
        </trans-unit>
        <trans-unit id="0bd5a326633d7bb4e6ce000d400eabafd43bda84" translate="yes" xml:space="preserve">
          <source>Q.getUnhandledReasons()</source>
          <target state="translated">Q.getUnhandledReasons()</target>
        </trans-unit>
        <trans-unit id="9866b21660ebdec962d906ff4f56405f3e32f300" translate="yes" xml:space="preserve">
          <source>Q.isPromise()</source>
          <target state="translated">Q.isPromise()</target>
        </trans-unit>
        <trans-unit id="4b735857b55ce96cf90b310ceb2e6797edc45ec4" translate="yes" xml:space="preserve">
          <source>Q.isPromise(value)</source>
          <target state="translated">Q.isPromise(value)</target>
        </trans-unit>
        <trans-unit id="55c3dcb3c0feaf08a68e0811ed963f531c793ebe" translate="yes" xml:space="preserve">
          <source>Q.isPromiseAlike()</source>
          <target state="translated">Q.isPromiseAlike()</target>
        </trans-unit>
        <trans-unit id="24f2d105d4ebf6c8dae5ec4ae15ac280019ee153" translate="yes" xml:space="preserve">
          <source>Q.isPromiseAlike(value)</source>
          <target state="translated">Q.isPromiseAlike(value)</target>
        </trans-unit>
        <trans-unit id="c2fb27cb639a68751537ed4014a0f2c9e4039b07" translate="yes" xml:space="preserve">
          <source>Q.longStackSupport</source>
          <target state="translated">Q.longStackSupport</target>
        </trans-unit>
        <trans-unit id="9ba21e8771c43e0c5b3ff64bb59d136f97fe290e" translate="yes" xml:space="preserve">
          <source>Q.nbind()</source>
          <target state="translated">Q.nbind()</target>
        </trans-unit>
        <trans-unit id="73aa048f6834dacdf4ccad16feaf700f6b42f3f5" translate="yes" xml:space="preserve">
          <source>Q.nbind(nodeMethod, thisArg, ...args)</source>
          <target state="translated">Q.nbind (nodeMethod, thisArg, ... args)</target>
        </trans-unit>
        <trans-unit id="743f41ca1df2fea22e9a577892626be3e16e5351" translate="yes" xml:space="preserve">
          <source>Q.nfapply()</source>
          <target state="translated">Q.nfapply()</target>
        </trans-unit>
        <trans-unit id="f234d437a215f6f703e63dc30682a678611fec89" translate="yes" xml:space="preserve">
          <source>Q.nfapply(nodeFunc, args)</source>
          <target state="translated">Q.nfapply (nodeFunc, 인수)</target>
        </trans-unit>
        <trans-unit id="0c1e82892deb61b7b860618d939f3d7091d242dc" translate="yes" xml:space="preserve">
          <source>Q.nfbind()</source>
          <target state="translated">Q.nfbind()</target>
        </trans-unit>
        <trans-unit id="0c45f18ec104f210c6b7116e40f7a806c1448447" translate="yes" xml:space="preserve">
          <source>Q.nfbind(nodeFunc, ...args)</source>
          <target state="translated">Q.nfbind (nodeFunc, ... args)</target>
        </trans-unit>
        <trans-unit id="c0a71ed8061857043b8a7b5d527b49307a73f9ad" translate="yes" xml:space="preserve">
          <source>Q.nfcall()</source>
          <target state="translated">Q.nfcall()</target>
        </trans-unit>
        <trans-unit id="490ef403baa03ccba3767a8588b6ff026a3920b0" translate="yes" xml:space="preserve">
          <source>Q.nfcall(func, ...args)</source>
          <target state="translated">Q.nfcall (func, ... args)</target>
        </trans-unit>
        <trans-unit id="e6e27d72f79eb51ae254b36d719ce33a7bf80a2a" translate="yes" xml:space="preserve">
          <source>Q.ninvoke(object, methodName, ...args)</source>
          <target state="translated">Q.ninvoke (객체, methodName, ... args)</target>
        </trans-unit>
        <trans-unit id="2d263471f26606370fbf2b9b51ff4a7984c0e597" translate="yes" xml:space="preserve">
          <source>Q.npost()</source>
          <target state="translated">Q.npost()</target>
        </trans-unit>
        <trans-unit id="f65d84570e85d3d2ad4a08371d02f4f6d729fb37" translate="yes" xml:space="preserve">
          <source>Q.npost(object, methodName, args)</source>
          <target state="translated">Q.npost (객체, 메소드 이름, 인수)</target>
        </trans-unit>
        <trans-unit id="636ae9916f42d07e87429073f308d52770a407af" translate="yes" xml:space="preserve">
          <source>Q.nsend()</source>
          <target state="translated">Q.nsend()</target>
        </trans-unit>
        <trans-unit id="c9714f6688c88106b1f05b60931fb43548eb44c9" translate="yes" xml:space="preserve">
          <source>Q.onerror</source>
          <target state="translated">Q.onerror</target>
        </trans-unit>
        <trans-unit id="16e6cc497544e2eb96cd75c7a7315f971579a9f3" translate="yes" xml:space="preserve">
          <source>Q.promised()</source>
          <target state="translated">Q.promised()</target>
        </trans-unit>
        <trans-unit id="b5af761b8969966f90d181b2b65ae641e3c0f9b9" translate="yes" xml:space="preserve">
          <source>Q.promised(func)</source>
          <target state="translated">Q.promised(func)</target>
        </trans-unit>
        <trans-unit id="00271436e145204dc99905a90c22e8d13dac2424" translate="yes" xml:space="preserve">
          <source>Q.reject()</source>
          <target state="translated">Q.reject()</target>
        </trans-unit>
        <trans-unit id="670d58a9aad977eca252eb777e966c7ed825fc1c" translate="yes" xml:space="preserve">
          <source>Q.reject(reason)</source>
          <target state="translated">Q.reject(reason)</target>
        </trans-unit>
        <trans-unit id="fbed2787ebf6c6a97f008c1188a6640fd4f584f5" translate="yes" xml:space="preserve">
          <source>Q.resetUnhandledRejections()</source>
          <target state="translated">Q.resetUnhandledRejections()</target>
        </trans-unit>
        <trans-unit id="60050db89bc695ad23268569789c31dce5615f30" translate="yes" xml:space="preserve">
          <source>Q.spawn()</source>
          <target state="translated">Q.spawn()</target>
        </trans-unit>
        <trans-unit id="d5a10c950d3c8298f22f64a67519ee0ad7b5a250" translate="yes" xml:space="preserve">
          <source>Q.spawn(generatorFunction)</source>
          <target state="translated">Q.spawn(generatorFunction)</target>
        </trans-unit>
        <trans-unit id="ebe579f01595c1801ef833889f7a340c46ac5509" translate="yes" xml:space="preserve">
          <source>Q.stopUnhandledRejectionTracking()</source>
          <target state="translated">Q.stopUnhandledRejectionTracking()</target>
        </trans-unit>
        <trans-unit id="33b74d4d2f5b0f0333df3173df500e7c71ccd205" translate="yes" xml:space="preserve">
          <source>Q.try()</source>
          <target state="translated">Q.try()</target>
        </trans-unit>
        <trans-unit id="8c380d0d1ec98a3914061b4960fe7bbff101c28c" translate="yes" xml:space="preserve">
          <source>Resets Q's internal tracking of unhandled rejections, but keeps unhandled rejection tracking on. This method is exposed mainly for testing and diagnostic purposes, where you may have accumulated some unhandled rejections but want to re-start with a clean slate.</source>
          <target state="translated">처리되지 않은 거부에 대한 Q의 내부 추적을 재설정하지만 처리되지 않은 거부 추적은 유지합니다. 이 방법은 주로 테스트 및 진단 목적으로 노출되며 처리되지 않은 거부가 누적되었지만 깨끗한 슬레이트로 다시 시작하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1f6bd0c6782da5037bf1018e122daf7cb635ea7e" translate="yes" xml:space="preserve">
          <source>Returns a &quot;deferred&quot; object with a:</source>
          <target state="translated">다음과 같은 &quot;지연된&quot;객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b6b7cdc79f9deb6a3bd5f887df8ef0f6b3285bd" translate="yes" xml:space="preserve">
          <source>Returns a &quot;state snapshot&quot; object, which will be in one of three forms:</source>
          <target state="translated">&quot;상태 스냅 샷&quot;객체를 반환합니다.이 객체는 다음 세 가지 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1bf5b4c519699a61bcf3f6f21005b68935f02138" translate="yes" xml:space="preserve">
          <source>Returns a function suitable for passing to a Node.js API. That is, it has a signature &lt;code&gt;(err, result)&lt;/code&gt; and will reject &lt;code&gt;deferred.promise&lt;/code&gt; with &lt;code&gt;err&lt;/code&gt; if &lt;code&gt;err&lt;/code&gt; is given, or fulfill it with &lt;code&gt;result&lt;/code&gt; if that is given.</source>
          <target state="translated">Node.js API에 전달하기에 적합한 함수를 리턴합니다. 즉 서명 갖는다 &lt;code&gt;(err, result)&lt;/code&gt; 및 거부 &lt;code&gt;deferred.promise&lt;/code&gt; 와 &lt;code&gt;err&lt;/code&gt; 경우 &lt;code&gt;err&lt;/code&gt; 주어, 또는 그것을 수행 &lt;code&gt;result&lt;/code&gt; 해당 주어지면.</target>
        </trans-unit>
        <trans-unit id="e747d88e6199a0b1d79671b8e080502aeb1211ae" translate="yes" xml:space="preserve">
          <source>Returns a new function that calls a function asynchronously with the given variadic arguments, and returns a promise. Notably, any synchronous return values or thrown exceptions are transformed, respectively, into fulfillment values or rejection reasons for the promise returned by this new function.</source>
          <target state="translated">지정된 가변 인수를 사용하여 함수를 비동기식으로 호출하고 promise를 반환하는 새 함수를 반환합니다. 특히, 동기 리턴 값 또는 예외는 각각이 새로운 함수에 의해 리턴 된 약속에 대한 이행 값 또는 거부 이유로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5983ce0ac83174b5716d73e16b5bb6aa91e0d311" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array of the property names of an object. Essentially equivalent to</source>
          <target state="translated">객체의 속성 이름 배열에 대한 약속을 반환합니다. 본질적으로</target>
        </trans-unit>
        <trans-unit id="c65bd90cb68c31c693d15905092abe0176f14227" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling a function, with the given array of arguments. Essentially equivalent to</source>
          <target state="translated">주어진 인수 배열을 사용하여 함수를 호출 한 결과에 대한 약속을 반환합니다. 본질적으로</target>
        </trans-unit>
        <trans-unit id="d4790f371165b929370d52a3f3a73fecfc53035a" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling a function, with the given variadic arguments. Has the same return value/thrown exception translation as explained above for &lt;code&gt;fbind&lt;/code&gt;.</source>
          <target state="translated">주어진 가변 인수를 사용하여 함수를 호출 한 결과에 대한 약속을 반환합니다. &lt;code&gt;fbind&lt;/code&gt; 에 대해 위에서 설명한 것과 동일한 반환 값 / throw 예외 변환이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d51d66c0a571661a75fe96cb963112aba7327a" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is &lt;code&gt;this&lt;/code&gt; in the function, just like a synchronous method call. Essentially equivalent to</source>
          <target state="translated">주어진 인수 배열로 객체의 명명 된 메소드를 호출 한 결과에 대한 약속을 반환합니다. 객체 자체는 동기 메서드 호출과 마찬가지로 함수에서 &lt;code&gt;this&lt;/code&gt; 입니다. 본질적으로</target>
        </trans-unit>
        <trans-unit id="a90c007c0c35faf384030c2f7dd1e50f4a010227" translate="yes" xml:space="preserve">
          <source>Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is &lt;code&gt;this&lt;/code&gt; in the function, just like a synchronous method call.</source>
          <target state="translated">주어진 가변 인수를 사용하여 객체의 명명 된 메서드를 호출 한 결과에 대한 약속을 반환합니다. 객체 자체는 동기 메서드 호출과 마찬가지로 함수에서 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c48232f587ed7ad0d385891e35b261cbaa9a5c1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.</source>
          <target state="translated">각 약속의 이행 값이 포함 된 배열로 이행되거나 첫 번째 거부 약속과 동일한 거부 사유로 거부 된 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0022238e74976d00e82acaa8a274cb6c392e64e0" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.</source>
          <target state="translated">약속 상태 스냅 샷 배열로 이행 된 약속을 반환하지만 원래의 모든 약속이 확정 된 후에 만, 즉 이행 또는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="97db047eaca017371e1e76ef3177deea98068b52" translate="yes" xml:space="preserve">
          <source>Returns a promise that is rejected with &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 에서 거부 된 약속을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0daf6de4a47a33bfbd591eb02625358dd75dff9f" translate="yes" xml:space="preserve">
          <source>Returns a promise that will have the same result as &lt;code&gt;promise&lt;/code&gt;, but will only be fulfilled after at least &lt;code&gt;ms&lt;/code&gt; milliseconds have passed. If &lt;code&gt;promise&lt;/code&gt; is rejected, the resulting promise will be rejected immediately.</source>
          <target state="translated">같은 결과를해야합니다 약속 반환 &lt;code&gt;promise&lt;/code&gt; ,하지만 적어도 후에 성취 될 것이다 &lt;code&gt;ms&lt;/code&gt; (밀리 초)이 통과한다. 경우 &lt;code&gt;promise&lt;/code&gt; 거부, 결과 약속은 즉시 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="eb58b3c4289b05a010dec7098dd3415ff2e098fe" translate="yes" xml:space="preserve">
          <source>Returns a promise that will have the same result as &lt;code&gt;promise&lt;/code&gt;, except that if &lt;code&gt;promise&lt;/code&gt; is not fulfilled or rejected before &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise will be rejected with an &lt;code&gt;Error&lt;/code&gt; with the given &lt;code&gt;message&lt;/code&gt;. If &lt;code&gt;message&lt;/code&gt; is not supplied, the message will be &lt;code&gt;&quot;Timed out after &quot; + ms + &quot; ms&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;promise&lt;/code&gt; 이 &lt;code&gt;ms&lt;/code&gt; 밀리 초 전에 완료되거나 거부되지 않으면 반환 된 약속이 지정된 &lt;code&gt;message&lt;/code&gt; 의 &lt;code&gt;Error&lt;/code&gt; 와 함께 거부 된다는 점을 제외하고는 &lt;code&gt;promise&lt;/code&gt; 과 동일한 결과를 갖는 약속을 반환 합니다 . 경우 &lt;code&gt;message&lt;/code&gt; 제공되지 않으면 메시지가됩니다 &lt;code&gt;&quot;Timed out after &quot; + ms + &quot; ms&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d15d66a64b918e09fa184d65145361d365119dd" translate="yes" xml:space="preserve">
          <source>Returns a promise to get the named property of an object. Essentially equivalent to</source>
          <target state="translated">객체의 명명 된 속성을 얻는 약속을 반환합니다. 본질적으로</target>
        </trans-unit>
        <trans-unit id="9adfe33c327736b089c7d2a364b68a8d64ae0dbf" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주어진 약속이 이행 된 상태인지 여부를 리턴합니다. 비 확정 버전에서 정적 버전을 사용하면 결과는 항상 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64c65a525a7dbcb351cdf4333b7322e7608ee527" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">주어진 약속이 보류 상태에 있는지 여부를 반환합니다. 비 확정 버전에서 정적 버전을 사용하면 결과는 항상 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92d3ca70546718ee6e890398be5378777a129658" translate="yes" xml:space="preserve">
          <source>Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">주어진 약속이 거부 된 상태인지 여부를 반환합니다. 비 확정 버전에서 정적 버전을 사용하면 결과는 항상 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba86bb02211418bc983b6ce2c35e95ac19ab4605" translate="yes" xml:space="preserve">
          <source>Returns whether the given value is a Q promise.</source>
          <target state="translated">주어진 값이 Q 약속인지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68ef929f0eba73a555b1ac5226e0f5c0c1e90154" translate="yes" xml:space="preserve">
          <source>Returns whether the given value is a promise (i.e. it's an object with a &lt;code&gt;then&lt;/code&gt; function).</source>
          <target state="translated">주어진 값이 약속인지 여부를 리턴합니다 (즉, &lt;code&gt;then&lt;/code&gt; 함수 가있는 오브젝트 임).</target>
        </trans-unit>
        <trans-unit id="88fd4e439ddcf95e2f7937761348b973d2b2f3fa" translate="yes" xml:space="preserve">
          <source>Sends an arbitrary message to a promise, with the given array of arguments.</source>
          <target state="translated">주어진 인수 배열을 사용하여 약속에 임의의 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="603aff8440ff59673505e95f9cd4bed2c77a8e2a" translate="yes" xml:space="preserve">
          <source>Several of these are usually used in their static form, and thus listed here as such. Nevertheless, they also exist on each Q promise, in case you somehow have a promise for a Node.js-style function or for an object with Node.js-style methods.</source>
          <target state="translated">이들 중 몇 개는 일반적으로 정적 형식으로 사용되므로 여기에 나열되어 있습니다. 그럼에도 불구하고 Node.js 스타일 함수 또는 Node.js 스타일 메소드가있는 객체에 대한 약속이있는 경우 각 Q 약속에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="5e2542f83068d64d5e8755b069131c1444cd541b" translate="yes" xml:space="preserve">
          <source>Some methods are named the same as JavaScript reserved words, like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt;. This helps show the very clear parallel between standard synchronous language constructs and asynchronous promise operations. However, such use of words as property names is only supported as of the ECMAScript 5 edition of the JavaScript language, which isn't implemented in certain older browsers like IE8, Safari 5, Android 2.2, or PhantomJS 1.8. If you're targeting those browsers, and aren't using a language like CoffeeScript that takes care of this for you, use their aliases instead, or escape them like &lt;code&gt;Q[&quot;try&quot;](...)&lt;/code&gt; or &lt;code&gt;promise[&quot;catch&quot;](...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;finally&lt;/code&gt; 와 같은 일부 메소드는 JavaScript 예약어와 동일하게 이름이 지정 됩니다. 이것은 표준 동기 언어 구조와 비동기 약속 연산 사이의 매우 명확한 병렬성을 보여줍니다. 그러나 속성 이름으로 단어를 사용하는 것은 JavaScript 언어의 ECMAScript 5 버전에서만 지원되며 IE8, Safari 5, Android 2.2 또는 PhantomJS 1.8과 같은 특정 이전 브라우저에서는 구현되지 않습니다. 해당 브라우저를 대상으로하고 있는데이를 처리하는 CoffeeScript와 같은 언어를 사용하지 않는 경우 대신 별칭을 사용하거나 &lt;code&gt;Q[&quot;try&quot;](...)&lt;/code&gt; 또는 &lt;code&gt;promise[&quot;catch&quot;](...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe8265d31c1eb002f8a5beaa04cd7992e8fec565" translate="yes" xml:space="preserve">
          <source>State Inspection</source>
          <target state="translated">상태 점검</target>
        </trans-unit>
        <trans-unit id="d2cae58d2aadc3a254ead471a3388630dd330a43" translate="yes" xml:space="preserve">
          <source>State Inspection Methods</source>
          <target state="translated">상태 검사 방법</target>
        </trans-unit>
        <trans-unit id="9d6d276e3a747e7c1e8d386c17de0ea65fb9ea73" translate="yes" xml:space="preserve">
          <source>Synchronously calls &lt;code&gt;resolver(resolve, reject, notify)&lt;/code&gt; and returns a promise whose state is controlled by the functions passed to &lt;code&gt;resolver&lt;/code&gt;. This is an alternative promise-creation API that has the same power as the deferred concept, but without introducing another conceptual entity.</source>
          <target state="translated">동 기적으로 호출 &lt;code&gt;resolver(resolve, reject, notify)&lt;/code&gt; 반환 그 상태로 전달 된 기능에 의해 제어되는 약속 &lt;code&gt;resolver&lt;/code&gt; . 이는 다른 개념 엔티티를 도입하지 않고 지연된 개념과 동일한 권한을 가진 대체 약속 작성 API입니다.</target>
        </trans-unit>
        <trans-unit id="5138b0b95faef656f8475291af8ee7602c47f01a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Q&lt;/code&gt; promise constructor establishes the basic API for performing operations on objects: &quot;get&quot;, &quot;put&quot;, &quot;del&quot;, &quot;post&quot;, &quot;apply&quot;, and &quot;keys&quot;. This set of &quot;operators&quot; can be extended by creating promises that respond to messages with other operator names, and by sending corresponding messages to those promises.</source>
          <target state="translated">&lt;code&gt;Q&lt;/code&gt; 의 , &quot;델&quot;, &quot;게시물&quot; &quot;넣어&quot; &quot;GET&quot;, &quot;적용&quot;및 &quot;키&quot;약속 생성자는 객체에 대한 작업을 수행하기위한 기본 API를 설정합니다. 이 &quot;연산자&quot;세트는 다른 운영자 이름으로 메시지에 응답하는 약속을 작성하고 해당 약속에 해당 메시지를 보내서 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1847a01ac55630b4b20e4c4f43e66c92da807144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods control the state of the &lt;code&gt;promise&lt;/code&gt; property, which you can hand out to others while keeping the authority to modify its state to yourself. The &lt;code&gt;notify&lt;/code&gt; method is for progress notification, and the &lt;code&gt;makeNodeResolver&lt;/code&gt; method is for interfacing with Node.js (see below).</source>
          <target state="translated">&lt;code&gt;resolve&lt;/code&gt; 및 &lt;code&gt;reject&lt;/code&gt; 방법이의 상태를 제어 &lt;code&gt;promise&lt;/code&gt; 자신의 상태를 수정할 수있는 권한을 유지하면서 당신은 다른 사람에게 나눠 줄 수있는 속성을. &lt;code&gt;notify&lt;/code&gt; 방법은 진행 통지이며 &lt;code&gt;makeNodeResolver&lt;/code&gt; 에 있어서 Node.js를 (아래 참조)와 인터페이싱한다.</target>
        </trans-unit>
        <trans-unit id="7f0ff16f4ad2b2d2481fca6ad296d4b8b4a6c769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;then&lt;/code&gt; method from the &lt;a href=&quot;http://promises-aplus.github.com/promises-spec/&quot;&gt;Promises/A+ specification&lt;/a&gt;, with an additional progress handler.</source>
          <target state="translated">추가 진행 처리기 가 포함 된 &lt;a href=&quot;http://promises-aplus.github.com/promises-spec/&quot;&gt;Promises / A + 사양&lt;/a&gt; 의 &lt;code&gt;then&lt;/code&gt; 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="d3457508f40bcbc1f796ff61e05a2ed206574bd5" translate="yes" xml:space="preserve">
          <source>The better strategy for methods would be to use &lt;code&gt;Q.nbind&lt;/code&gt;, as shown below.</source>
          <target state="translated">방법에 대한 더 나은 전략은 아래에 표시된 것처럼 &lt;code&gt;Q.nbind&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="eb418a497047c89804571a36c1d1b7e6f4b77732" translate="yes" xml:space="preserve">
          <source>The better strategy for methods would be to use &lt;code&gt;Q.npost&lt;/code&gt;, as shown below.</source>
          <target state="translated">방법에 대한 더 나은 전략은 아래와 같이 &lt;code&gt;Q.npost&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="41655a54c78b92067b5dab99b966942bcb07d6f3" translate="yes" xml:space="preserve">
          <source>The same warning about functions vs. methods applies for &lt;code&gt;nfcall&lt;/code&gt; as it does for &lt;code&gt;nfapply&lt;/code&gt;. In this case, the better strategy would be to use &lt;code&gt;Q.ninvoke&lt;/code&gt;.</source>
          <target state="translated">방법 대 기능에 대한 동일한 경고가 적용 &lt;code&gt;nfcall&lt;/code&gt; 이의 경우와 같이 &lt;code&gt;nfapply&lt;/code&gt; . 이 경우 더 나은 전략은 &lt;code&gt;Q.ninvoke&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f5b2974b679580a4410845f580024f2878ce6671" translate="yes" xml:space="preserve">
          <source>The state snapshots will be in the same form as those retrieved via &lt;a href=&quot;#promiseinspect&quot;&gt;&lt;code&gt;promise.inspect&lt;/code&gt;&lt;/a&gt;, i.e. either &lt;code&gt;{ state: &quot;fulfilled&quot;, value: v }&lt;/code&gt; or &lt;code&gt;{ state: &quot;rejected&quot;, reason: r }&lt;/code&gt;.</source>
          <target state="translated">상태 스냅 샷은 &lt;a href=&quot;#promiseinspect&quot;&gt; &lt;code&gt;promise.inspect&lt;/code&gt; &lt;/a&gt; 를 통해 검색된 것과 동일한 형식입니다 ( 예 &lt;code&gt;{ state: &quot;fulfilled&quot;, value: v }&lt;/code&gt; 또는 &lt;code&gt;{ state: &quot;rejected&quot;, reason: r }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cfd32e0efc3b8c3fdbb3068c66c59b3ea630cee" translate="yes" xml:space="preserve">
          <source>This can be useful for creating functions that accept either promises or non-promise values, and for ensuring that the function always returns a promise even in the face of unintentional thrown exceptions.</source>
          <target state="translated">이는 약속 또는 약속이 아닌 값을 허용하는 함수를 작성하고 의도하지 않은 예외 상황에서도 함수가 항상 약속을 리턴하도록하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f5bf5e47f3de995cddb6ce7012b6dac7752cca" translate="yes" xml:space="preserve">
          <source>This immediately runs a generator function, and forwards any uncaught errors to &lt;code&gt;Q.onerror&lt;/code&gt;. An uncaught error is deemed to occur if the function returns a rejected promise. Note that this automatically occurs if the generator function throws an error, e.g. by &lt;code&gt;yield&lt;/code&gt;ing on a promise that becomes rejected without surrounding that code with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">이것은 즉시 생성기 기능을 실행하고 포착되지 않은 오류를 &lt;code&gt;Q.onerror&lt;/code&gt; 로 전달합니다 . 함수가 거부 된 약속을 반환하면 잡히지 않은 오류가 발생한 것으로 간주됩니다. 주 발전기 기능에 의해 오류, 예를 던졌습니다 경우이 자동으로 발생 &lt;code&gt;yield&lt;/code&gt; A를 그 코드 주변없이 거부하게되는 약속을 보내고 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b0035faccac5d31823e7b8f9471ab2567c5b543" translate="yes" xml:space="preserve">
          <source>This is a convenient way to insert a delay into a promise chain, or even simply to get a nicer syntax for &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">이것은 약속 체인에 지연을 삽입하거나 &lt;code&gt;setTimeout&lt;/code&gt; 에 대한 더 좋은 구문을 얻는 편리한 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="d7604c57af26baec990f4a086808bf4136848896" translate="yes" xml:space="preserve">
          <source>This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support &lt;code&gt;yield&lt;/code&gt;. See &lt;a href=&quot;https://github.com/kriskowal/q/tree/v1/examples/async-generators&quot;&gt;the generators example&lt;/a&gt; for further information.</source>
          <target state="translated">생성기 함수를 지연된 함수로 변환하기위한 실험 도구입니다. 이것은 &lt;code&gt;yield&lt;/code&gt; 을 지원하는 엔진의 중첩 콜백을 줄일 수있는 가능성을 가지고 있습니다. 자세한 정보 &lt;a href=&quot;https://github.com/kriskowal/q/tree/v1/examples/async-generators&quot;&gt;는 생성기 예제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b95b44864ccfaaed5a35e0535f4f8c3a34b1821" translate="yes" xml:space="preserve">
          <source>This is especially useful in conjunction with &lt;code&gt;all&lt;/code&gt;, for example:</source>
          <target state="translated">예를 들어 &lt;code&gt;all&lt;/code&gt; 과 함께 사용 하면 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="32fcca162135cbde7a932dd83c691e00ba2d31f1" translate="yes" xml:space="preserve">
          <source>This method is especially useful in its static form for wrapping functions to ensure that they are always asynchronous, and that any thrown exceptions (intentional or accidental) are appropriately transformed into a returned rejected promise. For example:</source>
          <target state="translated">이 메소드는 함수가 항상 비동기식이며, 예외 (의도적이거나 우발적)가 예외가 리턴 된 거부 된 약속으로 적절히 변환되도록하기 위해 함수를 랩핑하는 정적 형식으로 특히 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="078b7a22c80d4b52b31a45a5be24ee13a153f9d1" translate="yes" xml:space="preserve">
          <source>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all finish, regardless of success or failure. For example:</source>
          <target state="translated">이 방법은 많은 오퍼레이션을 동시에 실행하고 성공 또는 실패에 관계없이 모든 작업이 완료 될 때 알림을 받기 위해 약속 배열에서 정적 형식으로 자주 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bca04acd5b32f09aaabaeadd82401f6a9d10205a" translate="yes" xml:space="preserve">
          <source>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all succeed. For example:</source>
          <target state="translated">이 메소드는 많은 오퍼레이션을 동시에 실행하고 모두 성공했을 때 알림을 받기 위해 약속 배열에서 정적 형식으로 자주 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9a0f1ffc43ccbe82153a50b9f1aac4fbf891920" translate="yes" xml:space="preserve">
          <source>This method is useful for creating dual promise/callback APIs, i.e. APIs that return promises but also accept Node.js-style callbacks. For example:</source>
          <target state="translated">이 방법은 이중 약속 / 콜백 API, 즉 약속을 반환하지만 Node.js 스타일의 콜백을 허용하는 API를 만드는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60502da155455484d77f5a0328f9ea0b9393ceef" translate="yes" xml:space="preserve">
          <source>This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions thrown in &lt;code&gt;then&lt;/code&gt; callbacks are consumed and transformed into rejections, exceptions at the end of the chain are easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the event loop, so that it won't be caught, it causes an &lt;code&gt;onerror&lt;/code&gt; event on the browser &lt;code&gt;window&lt;/code&gt;, or an &lt;code&gt;uncaughtException&lt;/code&gt; event on Node.js's &lt;code&gt;process&lt;/code&gt; object.</source>
          <target state="translated">이 방법은 다른 곳에서는 전달되지 않는 약속 체인을 종료하는 데 사용해야합니다. 예외가 발생 &lt;code&gt;then&lt;/code&gt; 콜백이 소비되어 거부로 변환되므로 체인 끝의 예외는 실수로 조용히 무시하기 쉽습니다. 이벤트 루프의 다음 차례에 예외가 발생하도록 잡아서 포착되지 않도록 브라우저 &lt;code&gt;window&lt;/code&gt; 에서 &lt;code&gt;onerror&lt;/code&gt; 이벤트를 발생 시키거나 Node.js의 &lt;code&gt;process&lt;/code&gt; 오브젝트 에서 &lt;code&gt;uncaughtException&lt;/code&gt; 이벤트를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="042d4b4dd699dc89c4160022cbcff2282982df14" translate="yes" xml:space="preserve">
          <source>Turns off unhandled rejection tracking, which provides a slight efficiency boost if you don't find that debug information helpful. It also prevents Q from printing any unhandled rejection reasons upon process exit in Node.js.</source>
          <target state="translated">처리되지 않은 거부 추적을 해제하여 디버그 정보가 도움이되지 않으면 약간의 효율성 향상을 제공합니다. 또한 Node.js에서 프로세스 종료시 Q가 처리되지 않은 거부 이유를 인쇄하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">유틸리티 방법</target>
        </trans-unit>
        <trans-unit id="09347fef1e383dddcf741804bf4e99f85d0e1502" translate="yes" xml:space="preserve">
          <source>You can give the promise to any number of consumers and all of them will observe the resolution independently. Because the capability of observing a promise is separated from the capability of resolving the promise, none of the recipients of the promise have the ability to &quot;trick&quot; other recipients with misinformation (or indeed interfere with them in any way).</source>
          <target state="translated">여러 소비자에게 약속을 할 수 있으며 모든 소비자는 독립적으로 해결책을 준수 할 것입니다. 약속을 관찰하는 능력은 약속을 해결하는 능력과 분리되어 있기 때문에, 약속을받는 사람 중 누구도 잘못된 정보로 다른 수령인을 속여서 (또는 실제로 어떤 방식 으로든 방해 할 수있는) 능력이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dad4dba1d1723fcad6e15603dbb57d9eb8c1d47" translate="yes" xml:space="preserve">
          <source>You can give the resolver to any number of producers and whoever resolves the promise first wins. Furthermore, none of the producers can observe that they lost unless you give them the promise part too.</source>
          <target state="translated">당신은 리졸버를 원하는 수의 생산자에게 줄 수 있으며 약속을 먼저 ​​해결 한 사람은 먼저 이깁니다. 또한 약속 한 부분도주지 않으면 생산자가 잃어버린 것을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b552347e9ea988c3bfb5a98430abefe4890a0612" translate="yes" xml:space="preserve">
          <source>deferred.makeNodeResolver()</source>
          <target state="translated">deferred.makeNodeResolver()</target>
        </trans-unit>
        <trans-unit id="f3dd025a8d4a054c822920f0ba5de808ffb543dc" translate="yes" xml:space="preserve">
          <source>deferred.notify()</source>
          <target state="translated">deferred.notify()</target>
        </trans-unit>
        <trans-unit id="7ae5f295d0eb41704b39bc5842bf2ce85f03ed37" translate="yes" xml:space="preserve">
          <source>deferred.notify(value)</source>
          <target state="translated">deferred.notify(value)</target>
        </trans-unit>
        <trans-unit id="51aff75a8bb3dba096f7ef45bfa25d57989b7308" translate="yes" xml:space="preserve">
          <source>deferred.reject()</source>
          <target state="translated">deferred.reject()</target>
        </trans-unit>
        <trans-unit id="2e1baf2b707a8a04db342470b867446047254723" translate="yes" xml:space="preserve">
          <source>deferred.reject(reason)</source>
          <target state="translated">deferred.reject(reason)</target>
        </trans-unit>
        <trans-unit id="cfb0f049b85a87aa2cde9c0157e6b08e14268cc9" translate="yes" xml:space="preserve">
          <source>deferred.resolve()</source>
          <target state="translated">deferred.resolve()</target>
        </trans-unit>
        <trans-unit id="befc66d1724d1825fe5f08090872429281f20402" translate="yes" xml:space="preserve">
          <source>deferred.resolve(value)</source>
          <target state="translated">deferred.resolve(value)</target>
        </trans-unit>
        <trans-unit id="52ea1a94dca9d9de516850ab44fd61bf7075fe94" translate="yes" xml:space="preserve">
          <source>promise.all()</source>
          <target state="translated">promise.all()</target>
        </trans-unit>
        <trans-unit id="4fdc5ffdfdf55894a8d09d6b2a7e9b6c34e132b7" translate="yes" xml:space="preserve">
          <source>promise.allSettled()</source>
          <target state="translated">promise.allSettled()</target>
        </trans-unit>
        <trans-unit id="1cc9a0db4c7fcd3384610224407ec2777e3dc602" translate="yes" xml:space="preserve">
          <source>promise.catch(onRejected)</source>
          <target state="translated">promise.catch(onRejected)</target>
        </trans-unit>
        <trans-unit id="146243766c3634deef7a297881b6b5208185f561" translate="yes" xml:space="preserve">
          <source>promise.delay()</source>
          <target state="translated">promise.delay()</target>
        </trans-unit>
        <trans-unit id="2a7412d9f5c9daf01d777e686a98f1abf1afcb5e" translate="yes" xml:space="preserve">
          <source>promise.delay(ms)</source>
          <target state="translated">promise.delay(ms)</target>
        </trans-unit>
        <trans-unit id="d2996b2db982c1ad9f988c0174e1a83f557d7eaf" translate="yes" xml:space="preserve">
          <source>promise.dispatch()</source>
          <target state="translated">promise.dispatch()</target>
        </trans-unit>
        <trans-unit id="ec7d2c18116eb168623d0d1e51d8b4073c39880a" translate="yes" xml:space="preserve">
          <source>promise.dispatch(operator, args)</source>
          <target state="translated">promise.dispatch (연산자, 인수)</target>
        </trans-unit>
        <trans-unit id="9a0cf288f13aeb03b856717b03bc373c5cd15a31" translate="yes" xml:space="preserve">
          <source>promise.done()</source>
          <target state="translated">promise.done()</target>
        </trans-unit>
        <trans-unit id="312ee94b5f936b9eddb2048065a56320cc827899" translate="yes" xml:space="preserve">
          <source>promise.done(onFulfilled, onRejected, onProgress)</source>
          <target state="translated">promise.done (onFulfilled, onRejected, onProgress)</target>
        </trans-unit>
        <trans-unit id="b765f0e53eb8734fdd8c3c46e0acd5a399b5e8b4" translate="yes" xml:space="preserve">
          <source>promise.fail()</source>
          <target state="translated">promise.fail()</target>
        </trans-unit>
        <trans-unit id="2363fed5cbbc9268dfb81147ff068794f88df559" translate="yes" xml:space="preserve">
          <source>promise.fapply()</source>
          <target state="translated">promise.fapply()</target>
        </trans-unit>
        <trans-unit id="b85320cfc4cf64d95bb6874a1fd4a2b1783807ba" translate="yes" xml:space="preserve">
          <source>promise.fapply(args)</source>
          <target state="translated">promise.fapply(args)</target>
        </trans-unit>
        <trans-unit id="3c0ed4209942fbdd63be60406b99f472d48c7453" translate="yes" xml:space="preserve">
          <source>promise.fbind()</source>
          <target state="translated">promise.fbind()</target>
        </trans-unit>
        <trans-unit id="8d41630b9a8617df4c09bc487678779d3dec126d" translate="yes" xml:space="preserve">
          <source>promise.fbind(...args) &lt;em&gt;(deprecated)&lt;/em&gt;</source>
          <target state="translated">promise.fbind (... args) &lt;em&gt;(더 이상 사용되지 않음)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b85ab74c3e71c8c2b12b03c568275bdea12ebd2" translate="yes" xml:space="preserve">
          <source>promise.fcall(...args)</source>
          <target state="translated">promise.fcall(...args)</target>
        </trans-unit>
        <trans-unit id="d548d47776ef0cec99c45a44dc83c8ff07312015" translate="yes" xml:space="preserve">
          <source>promise.finally()</source>
          <target state="translated">promise.finally()</target>
        </trans-unit>
        <trans-unit id="bf49254f5d29c37f6040f64d1f26ea16c52e33c1" translate="yes" xml:space="preserve">
          <source>promise.finally(callback)</source>
          <target state="translated">promise.finally(callback)</target>
        </trans-unit>
        <trans-unit id="9e8022ac49bf93c0e5087b717dc46244945f8b0f" translate="yes" xml:space="preserve">
          <source>promise.get()</source>
          <target state="translated">promise.get()</target>
        </trans-unit>
        <trans-unit id="e15313100014b0645e13cd1c2a1feb57293c2912" translate="yes" xml:space="preserve">
          <source>promise.get(propertyName)</source>
          <target state="translated">promise.get(propertyName)</target>
        </trans-unit>
        <trans-unit id="9cb4b7ca15eb28baba089f11ef9448dafe88a806" translate="yes" xml:space="preserve">
          <source>promise.inspect()</source>
          <target state="translated">promise.inspect()</target>
        </trans-unit>
        <trans-unit id="1724d9e876338209189774c3e48e44a586f5e9ea" translate="yes" xml:space="preserve">
          <source>promise.invoke(methodName, ...args)</source>
          <target state="translated">promise.invoke (methodName, ... args)</target>
        </trans-unit>
        <trans-unit id="7c09faaa6df9377a9b5147c742b14f023a77e5ef" translate="yes" xml:space="preserve">
          <source>promise.isFulfilled()</source>
          <target state="translated">promise.isFulfilled()</target>
        </trans-unit>
        <trans-unit id="48e45bc731c06c99933188a40132b98dbd4b2674" translate="yes" xml:space="preserve">
          <source>promise.isPending()</source>
          <target state="translated">promise.isPending()</target>
        </trans-unit>
        <trans-unit id="471ff3f638b345b3050c54d32a015e7c52999bc7" translate="yes" xml:space="preserve">
          <source>promise.isRejected()</source>
          <target state="translated">promise.isRejected()</target>
        </trans-unit>
        <trans-unit id="29b1f857bf941f5bd9601ee101ee3edbb84c93f9" translate="yes" xml:space="preserve">
          <source>promise.keys()</source>
          <target state="translated">promise.keys()</target>
        </trans-unit>
        <trans-unit id="6ff256e4c6bec7b11d1b7e22762b682f91ea6e04" translate="yes" xml:space="preserve">
          <source>promise.nodeify()</source>
          <target state="translated">promise.nodeify()</target>
        </trans-unit>
        <trans-unit id="324a86e90f88eead1d976e8f00169816845c2162" translate="yes" xml:space="preserve">
          <source>promise.nodeify(callback)</source>
          <target state="translated">promise.nodeify(callback)</target>
        </trans-unit>
        <trans-unit id="0b79ada9209b9b82f998371b35df0bf5021b6ce8" translate="yes" xml:space="preserve">
          <source>promise.post()</source>
          <target state="translated">promise.post()</target>
        </trans-unit>
        <trans-unit id="a5086c648ff9e298e5764b192d029d865bf7e670" translate="yes" xml:space="preserve">
          <source>promise.post(methodName, args)</source>
          <target state="translated">promise.post (methodName, 인수)</target>
        </trans-unit>
        <trans-unit id="ecd8a93afeec7d91e2a744aa4b43c753d91e7863" translate="yes" xml:space="preserve">
          <source>promise.progress()</source>
          <target state="translated">promise.progress()</target>
        </trans-unit>
        <trans-unit id="aea845ef3439bec565fe51d8a1ac31942fa2aee4" translate="yes" xml:space="preserve">
          <source>promise.progress(onProgress)</source>
          <target state="translated">promise.progress(onProgress)</target>
        </trans-unit>
        <trans-unit id="b7a4297677bab31d0523909b8cd795efae143235" translate="yes" xml:space="preserve">
          <source>promise.send()</source>
          <target state="translated">promise.send()</target>
        </trans-unit>
        <trans-unit id="9bcd0bee9c1133c14f5afc59526295381468b471" translate="yes" xml:space="preserve">
          <source>promise.spread()</source>
          <target state="translated">promise.spread()</target>
        </trans-unit>
        <trans-unit id="5528e00f9e67324699fc92867a4cb208e85e2463" translate="yes" xml:space="preserve">
          <source>promise.spread(onFulfilled, onRejected)</source>
          <target state="translated">promise.spread (onFulfilled, onRejected)</target>
        </trans-unit>
        <trans-unit id="8d746bb714f5af94ff4fc66460e9e0b111f7844b" translate="yes" xml:space="preserve">
          <source>promise.tap()</source>
          <target state="translated">promise.tap()</target>
        </trans-unit>
        <trans-unit id="6a924580a7854f76a65fe49fb9ae46524ef52433" translate="yes" xml:space="preserve">
          <source>promise.tap(onFulfilled)</source>
          <target state="translated">promise.tap(onFulfilled)</target>
        </trans-unit>
        <trans-unit id="c0c5e160b8d6524eb2d96121be26c1682dbae995" translate="yes" xml:space="preserve">
          <source>promise.then()</source>
          <target state="translated">promise.then()</target>
        </trans-unit>
        <trans-unit id="98a9c3255c84b1e429307707ba63fb94c5b81167" translate="yes" xml:space="preserve">
          <source>promise.then(onFulfilled, onRejected, onProgress)</source>
          <target state="translated">promise.then (onFulfilled, onRejected, onProgress)</target>
        </trans-unit>
        <trans-unit id="4161af8ef4b10a5328cd7a2fbe1f1e372a894d12" translate="yes" xml:space="preserve">
          <source>promise.thenReject()</source>
          <target state="translated">promise.thenReject()</target>
        </trans-unit>
        <trans-unit id="44ff3f45d91e2d292bdf05e92b2f04d17c120608" translate="yes" xml:space="preserve">
          <source>promise.thenReject(reason)</source>
          <target state="translated">promise.thenReject(reason)</target>
        </trans-unit>
        <trans-unit id="f9eb06abcde059740519a949eea5966dc008ef34" translate="yes" xml:space="preserve">
          <source>promise.thenResolve()</source>
          <target state="translated">promise.thenResolve()</target>
        </trans-unit>
        <trans-unit id="afa9f132a365f033bef3aa97051878a982f6f652" translate="yes" xml:space="preserve">
          <source>promise.thenResolve(value)</source>
          <target state="translated">promise.thenResolve(value)</target>
        </trans-unit>
        <trans-unit id="dbb049ee1d870010daf461c74a9cf3cd24b4eda9" translate="yes" xml:space="preserve">
          <source>promise.timeout()</source>
          <target state="translated">promise.timeout()</target>
        </trans-unit>
        <trans-unit id="bc0257d2fcba197a8698b89285a1891d2eb7247d" translate="yes" xml:space="preserve">
          <source>promise.timeout(ms, message)</source>
          <target state="translated">promise.timeout (ms, 메시지)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
