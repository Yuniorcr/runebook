<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">이 함수는 기존 이터레이터에서 새 네이버 이터레이터를 만듭니다. 이웃은 현재 &lt;em&gt;iter가&lt;/em&gt; 가리키는 위치에 상대적으로 계산되며 , 경계는 이웃 반복기의 모양을 정의하며 모드 인수는 경계 처리 모드입니다.</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">이 함수는 반환 된 배열을 초기화 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그 사용을 할 수 &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt; 대신. 배열 값을 설정하는 함수보다 약간 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">이 함수는 반환 된 배열을 초기화 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그 사용을 할 수 &lt;code&gt;zeros_like&lt;/code&gt; 또는 &lt;code&gt;ones_like&lt;/code&gt; 대신. 배열 값을 설정하는 함수보다 약간 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">이 함수는 입력 내용을 확인하지 않고 유형이 MaskType 만됩니다. 특히이 함수는 마스크에 유연한 dtype이있는 경우 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">이 기능은 블록이 고정 그리드에 놓 이도록 강제하지 않습니다. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; 는 다음 형식의 배열로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">이 기능은 어느 방향 으로든 손실없이 왕복하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">이 기능은 브로드 캐스트 규칙을 캡슐화합니다. &lt;em&gt;MIT의&lt;/em&gt; 컨테이너는 이미 필요가 방송 될하는 모든 배열에 대한 반복자를 포함해야합니다. 돌아 왔을 때,이 반복자는 각각의 반복이 방송을 달성하도록 조정될 것이다. 오류가 발생하면 음수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">이 함수는 NaN이 &quot;정상&quot;숫자 인 것처럼 NaN 비교를 처리합니다. 즉, 두 개체의 NaN이 같은 위치에 있으면 어설 션이 발생하지 않습니다. 이는 NaN의 IEEE 표준과 달리 NaN은 다른 것과 비교하여 False를 반환해야한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 randint를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">이 기능은 매우주의해서 사용해야합니다. 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">이 함수는 tobytes의 호환성 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">이 함수는 tobytes의 호환성 별칭입니다. 이름에도 불구하고 문자열이 아닌 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;mask_rowcols&lt;/code&gt; 와 &lt;code&gt;axis&lt;/code&gt; 0 같다.</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;mask_rowcols&lt;/code&gt; 와 &lt;code&gt;axis&lt;/code&gt; (1)과 동일.</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 으로, &lt;code&gt;condition&lt;/code&gt; = (X! = 값).</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; 값).</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 으로, &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; = 값).</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X &amp;lt;값).</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X &amp;lt;= 값).</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X == 값). 부동 소수점 배열의 경우 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">이 기능에 대한 바로 가기입니다 &lt;code&gt;masked_where&lt;/code&gt; 과 &lt;code&gt;condition&lt;/code&gt; = ~ (np.isfinite의 (a)). 기존 마스크는 보존됩니다. NaN 또는 infs가 의미가있는 (즉, 부동 소수점 유형) dtype을 가진 배열에만 적용되지만 array_like 객체는 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">이 함수는 &lt;code&gt;ord&lt;/code&gt; 매개 변수 의 값에 따라 8 개의 서로 다른 행렬 규범 중 하나 또는 무한한 수의 벡터 규범 중 하나를 반환 할 수 있습니다 (아래 설명 참조) .</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">이 함수는 &lt;code&gt;p&lt;/code&gt; 값에 따라 7 가지 표준 중 하나를 사용하여 조건 번호를 반환 할 수 있습니다 (아래 매개 변수 참조).</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; 인수 에 따라 마스킹 된 값이 같거나 (기본값) 같지 &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 점을 제외하고 allclose 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 &quot;compressed&quot;메서드를 호출하는 것과 같습니다 . 자세한 내용 은 &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">이 함수는 keepdims = True 인 튜플 축 인수와 재정렬 가능한 ufunc에 해당합니다. ufunc에 대한 튜플 축 인수는 버전 1.7.0부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">이 기능은 EXTERNAL_LOOP 모드에서만 사용되도록 고안되었으며 해당 모드가 활성화되어 있지 않으면 잘못된 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 복소수 인수에 대해 정의되지 않았습니다. 소위 복잡한 값의 인수에는 &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">이 함수는 정수와 함께 작동하도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">이 기능은 아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 보폭 점검으로 인한 변경으로 인해 동일한 배열에 대한 반환 값이 NumPy&amp;gt; = 1.10.0 버전과 이전 버전에서 다를 수 있습니다. 배열이 포트란 연속인지 만 확인하려면 &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 객체 배열에만 적합합니다. 부동 소수점의 경우 대신 &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; 으로&lt;/a&gt; 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">이 기능은 대칭이지만 거의 연관되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 기능의 상당 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt; 참조 고려 마스크 값을 얻어 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; 를&lt;/a&gt; 세부 사항.</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">이 함수는 마스크 된 값을 고려한 &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 참고 것을 &lt;code&gt;strict&lt;/code&gt; 하고 &lt;code&gt;out&lt;/code&gt; 방법 버전과 다른 위치에 있습니다. 해당 메소드와의 호환성을 유지하려면 선택적 인수를 키워드로만 처리하는 것이 좋습니다. 어떤 시점에서는 필수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 기능의 상당 &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt; 참조 고려 마스크 값을 얻어 &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt; 세부 사항.</target>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">이 함수는 주어진 dtype으로 최대 배열을 가져 오는 데 적합한 채우기 값을 계산하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">이 기능은 둘 이상의 배열을 변환 할 수있는 공통 유형을 결정하는 데 유용합니다. itemize 정보가 전달되지 않으므로 유연하지 않은 배열 유형에만 작동합니다. &lt;em&gt;mintype의&lt;/em&gt; 인수는 최소 허용 형 나타내고, &lt;em&gt;OP는&lt;/em&gt; 배열로 변환 될 객체를 나타낸다. 반환 값은 &lt;em&gt;op에&lt;/em&gt; 있어야 하는 데이터 형식을 나타내는 열거 된 형식 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">이 함수는 컴파일 된 코드 (아마 ctypes를 통해)에 전달하기 위해 올바른 플래그를 가진 배열이 반환되도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">이 함수는 위의 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 와 매우 유사 하지만 , &lt;code&gt;identity&lt;/code&gt; 가 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 로 전달 될 때 ufunc에 대한 임의의 ID를 정의하기 위해 추가 &lt;em&gt;identity_value&lt;/em&gt; 인수 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">이 함수는 위의 PyUFunc_FromFuncAndData와 매우 유사하지만 &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;일반화 된 범용 함수&lt;/a&gt; 를 정의하기 위한 추가 &lt;em&gt;서명&lt;/em&gt; 인수가 있습니다 . 요소 별 작업을 중심으로 ufunc가 작성되는 방식과 유사하게 gufuncs는 하위 배열 별 하위 작업 을 중심으로 작동하며 하위 배열을 정의하는 &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;시그니처&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">이 기능은 최대 3 차원 배열에 가장 적합합니다. 예를 들어 높이 (첫 번째 축), 너비 (두 번째 축) 및 r / g / b 채널 (세 번째 축)이있는 픽셀 데이터의 경우. &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 기능 은보다 일반적인 스택 및 연결 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">이 기능은 최대 3 차원 배열에 가장 적합합니다. 예를 들어 높이 (첫 번째 축), 너비 (두 번째 축) 및 r / g / b 채널 (세 번째 축)이있는 픽셀 데이터의 경우. &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;block&lt;/code&gt; 기능 은보다 일반적인 스택 및 연결 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">이 함수는 반복자가 다중 인덱스를 추적하고 축이 역순으로 반복되는 것을 방지하기 위해 &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt; 를 사용한 경우에만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">이 함수는 C-API를 사용할 모듈의 초기화 섹션에서 호출해야합니다. 함수 포인터 테이블이 저장된 모듈을 가져오고 올바른 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;func(a, axis)&lt;/code&gt; 두 가지 인수를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">이 기능은 다차원 배열의 첫 번째 축을 따라 배열을 섞습니다. 하위 배열의 순서는 변경되지만 내용은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">이 기능을보다 정밀 제공 &lt;code&gt;exp(x) - 1&lt;/code&gt; 작은 값 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">이 기능은 시스템 엔트로피 풀에서 읽으므로 샘플을 재현 할 수 없습니다. 특히, 않습니다 &lt;em&gt;하지&lt;/em&gt; BitGenerator의 사용을하고, 그래서 &lt;code&gt;seed&lt;/code&gt; 및 설정 &lt;code&gt;state&lt;/code&gt; 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">이 함수는 열거 된 &lt;em&gt;typenum&lt;/em&gt; , 최소 깊이 &lt;em&gt;min_depth&lt;/em&gt; 및 최대 깊이 &lt;em&gt;max_depth에&lt;/em&gt; 의해 주어진 (유연하지 않은) 유형의 중첩 시퀀스 또는 배열 인터페이스 내보내기 객체 &lt;em&gt;op&lt;/em&gt; 에서 (C 스타일) 연속적이고 동작하는 함수 배열을 &lt;em&gt;반환&lt;/em&gt; 합니다. 요구 사항 이 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 로 설정되고 유형 인수의 type_num 멤버 가 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 설정된 PyArray_FromAny 에 대한 호출 과 &lt;em&gt;같습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">이 함수는 공통 마스크 조작에 사용될 수있는 모든 항목 False와 함께 부울 ndarray를 리턴합니다. 복합 dtype을 지정하면 각 필드의 유형이 부울 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">이 함수는 &lt;code&gt;x&lt;/code&gt; 의 데이터 절대 값 (양의 크기)을 반환합니다 . 복소 값은, 사용하는 처리되지 않은 &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 복잡한 데이터의 절대 값을 찾을 것이다.</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">이 함수는 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">이 함수는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">이 함수는 1 차원 배열을 받아 들여야합니다. 지정된 축을 따라 1 차원 &lt;code&gt;arr&lt;/code&gt; 조각에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;arr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">이 함수 는 NULL이 아닌 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 . 하나를 얻는 가장 쉬운 방법은 &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; 을&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">이 함수는 indexing 키워드 인수를 통해 두 가지 색인 규칙을 모두 지원합니다. 'ij'문자열을 제공하면 행렬 색인이 포함 된 meshgrid가 반환되고 'xy'가 데카르트 색인이 포함 된 meshgrid가 반환됩니다. 길이 M과 N의 입력을 가진 2 차원의 경우, 출력은 'xy'인덱싱의 경우 모양 (N, M) 및 'ij'인덱싱의 경우 (M, N) 모양입니다. 길이 M, N 및 P의 입력이있는 3 차원 경우 출력은 'xy'인덱싱의 경우 (N, M, P) 모양이고 'ij'인덱싱의 경우 (M, N, P) 모양입니다. 차이점은 다음 코드 스 니펫으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">이 기능은 나열된 모든 축에 대해 반 공백을 바꿉니다 (기본값은 모두). 참고로 &lt;code&gt;y[0]&lt;/code&gt; 에만 성분 인 나이키 스트 &lt;code&gt;len(x)&lt;/code&gt; 짝수이다.</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">이 함수는 N 1-D 시퀀스를 가져 와서 각각 N 차원의 N 출력을 반환하여 모양이 1 차원을 제외한 모든 차원에서 1이되고 비 단위 모양 값이있는 차원이 모든 N 차원을 순환합니다.</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">이 함수는 이전에 &quot;브로드 캐스트 된&quot;다중 반복자 객체를 가져와 브로드 캐스트 된 결과에서 가장 작은 &quot;보폭&quot;이있는 차원을 찾은 다음 해당 반복자를 효과적으로 반복하여 해당 반복자에 대해 반복하지 않도록 모든 반복자를 조정합니다. 해당 차원의 길이 -1). &lt;em&gt;mit-&lt;/em&gt; &amp;gt; nd가 0이 아니면 대응하는 차원이 리턴되고 -1이 리턴됩니다. 이 함수는 입력을 올바르게 브로드 캐스트 한 후 루틴의 스 트레이딩 된 1 차원 버전을 내부 루프로 호출하는 ufunc와 같은 루틴을 구성하는 데 유용합니다. 이 1-d 버전은 일반적으로 속도에 최적화되어 있기 때문에 큰 보폭이 필요하지 않은 축에 대해 루프를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">이 함수는 내장 파이썬 &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='left'&lt;/code&gt; ) 및 &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='right'&lt;/code&gt; ) 함수 와 동일한 알고리즘을 사용 하며 &lt;code&gt;v&lt;/code&gt; 인수로 도 벡터화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">이 함수는 복소수를 부동 소수점 이하로 강등 시키거나 부울 값으로 강등하지 않지만 스칼라 값이 양수이면 부호있는 정수를 부호없는 정수로 강등시킵니다.</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">이 함수는 MaskedArray 입력의 마스킹을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 ma.array와 같은 &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt; 서브 클래스에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">이 함수 는 유연한 배열을 처리한다는 점을 제외하고 &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 과 유사하게 작동 합니다. &lt;em&gt;mintype의&lt;/em&gt; 인수는 itemsize 멤버를 가질 수 있고, &lt;em&gt;outtype의&lt;/em&gt; 인수는 큰 그러나 아마 더 큰는 개체에 따라 같은 적어도 itemsize 회원해야합니다 &lt;em&gt;영업 이익&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt; 를 통해 얻을 수 있지만 내부적으로이 버전은 인덱스를 구성하지 않고 간단한 슬라이싱을 사용하는 훨씬 빠른 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">이 범용 1-d 코어 함수는 &lt;em&gt;func&lt;/em&gt; 가 하나의 인수를 취하는 입력 객체의 메소드를 나타내는 문자열 이라고 가정합니다 . 첫 번째 인수 &lt;em&gt;인수는&lt;/em&gt; 그 함수 호출, 두 번째 인자 인 방법 &lt;em&gt;인수가&lt;/em&gt; 함수에 전달 된 인자이다. 함수의 출력은 &lt;em&gt;args&lt;/em&gt; 의 세 번째 항목에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">이 범용 1-d 코어 함수는 &lt;em&gt;func&lt;/em&gt; 가 입력 객체의 메서드를 나타내는 문자열 이라고 가정 합니다. 루프가 반복 될 때마다 Python 객체가 배열에서 추출되고 &lt;em&gt;func&lt;/em&gt; 메소드가 호출되어 결과를 출력 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">이 기하학적 특성은 생성 된 데이터 포인트를 플롯하여 2 차원에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">이것은 &lt;code&gt;nop&lt;/code&gt; 데이터 포인터에 대한 포인터를 돌려줍니다 . 경우 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 는&lt;/a&gt; 반복자의 현재 데이터 항목에 각 데이터 포인터 포인트를 지정되지 않았습니다. 내부 반복이 지정되지 않은 경우 내부 루프의 첫 번째 데이터 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">이는 반복되는 오브젝트에 대한 &lt;code&gt;nop&lt;/code&gt; 데이터 유형 Descrs에 대한 포인터를 제공합니다 . 결과는 &lt;code&gt;iter&lt;/code&gt; 를 가리 키 므로 호출자는 Descrs에 대한 참조를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">반복되는 &lt;code&gt;nop&lt;/code&gt; 피연산자 PyObject에 대한 포인터를 제공합니다 . 결과는 &lt;code&gt;iter&lt;/code&gt; 를 가리 키 므로 호출자는 PyObject에 대한 참조를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">추적중인 인덱스에 대한 포인터를 반환하거나, 추적중인 인덱스가 없으면 NULL을 반환합니다. 구성 중에 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 플래그 중 하나 가 지정된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">그러면 NpyIter_GetOperandArray 배열의 i 번째 객체에 대한 뷰인 새로운 ndarray 뷰에 대한 참조가 제공 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; , 치수 및 보폭은 내부 최적화 된 반복 패턴과 일치합니다. 이 뷰의 C 순서 반복은 반복자의 반복 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">이 그룹은 시간이 걸리지 만 Python C-API 호출을 사용하지 않는 코드를 호출하는 데 사용됩니다. 따라서 계산 중에 GIL을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">이 그룹은 Python GIL이 릴리스 된 후 다시 획득하는 데 사용됩니다. 예를 들어, 이전 호출을 사용하여 GIL이 릴리스 된 다음 코드의 일부 경로 (아마 다른 서브 루틴의 경로)에 Python C-API를 사용해야한다고 가정하면 이러한 매크로는 GIL을 얻는 데 유용합니다. 이 매크로는 본질적으로 이전 세 가지의 역순을 달성 한 다음 (LOCK 상태를 저장 한 상태로 확보) 저장된 상태로 다시 릴리스합니다.</target>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">이 인터페이스는 배열의 각 항목이 동일한 &quot;유형&quot;을 갖는다는 의미에서 동종 배열을 설명합니다. 이 유형은 매우 단순하거나 매우 임의적이고 복잡한 C 형 구조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt; 인스턴스로, 파이썬 내장 반복자 객체와 유사하게 작동하지만 하위 클래스는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">이것은 어레이 데이터의 빠른 저장을위한 편리한 기능입니다. 엔디안 및 정밀도에 대한 정보가 손실되므로이 방법은 엔디안이 다른 시스템간에 데이터를 아카이브하거나 데이터를 전송하려는 파일에는 적합하지 않습니다. 이러한 문제 중 일부는 속도와 파일 크기를 희생하면서 데이터를 텍스트 파일로 출력하여 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 Matlab에서 코드를 포팅하는 사용자를위한 편리한 기능이며 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; 을 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하는데, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 Matlab에서 코드를 포팅하는 사용자를위한 편리한 기능이며 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; 을 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하는데, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">이것은 편리한 레거시 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">이것은 함수에 주어진 출력 배열을위한 기본 변환기입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 있다 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; , 다음 &lt;em&gt;* 주소는&lt;/em&gt; 것입니다 &lt;code&gt;NULL&lt;/code&gt; 하지만 호출이 성공합니다. 경우 &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj가&lt;/em&gt; ) 다음 TRUE 인 것이 반환된다 &lt;em&gt;* 어드레스&lt;/em&gt; 의 참조 카운트를 증가없이.</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 C99 copysign에 해당하는 함수입니다. y와 같은 부호를 가진 x를 리턴하십시오. inf와 nan을 포함한 모든 가치에 적용됩니다. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 다음에 C99에 해당하는 함수입니다. x에서 y의 방향으로 다음 표현 가능한 부동 소수점 값을 반환합니다. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 Fortran 내장 함수와 동등한 기능입니다. x와 x에서 표현할 수있는 다음 부동 소수점 값 사이의 거리를 반환합니다 (예 : spacing (1) == eps). nan의 간격과 +/- inf return nan. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 현재 반복자 다중 인덱스를 가져 오기위한 함수 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 반복 루프에 대한 함수 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">각 피연산자에 대한 플래그 목록입니다. 최소한 &lt;code&gt;readonly&lt;/code&gt; , &lt;code&gt;readwrite&lt;/code&gt; 또는 &lt;code&gt;writeonly&lt;/code&gt; 중 하나를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">이것은 매크로이며 C99 isfinite와 같습니다. 단정도, 배정도 및 확장 정밀도에 적용되며 0이 아닌 값을 반환하면 x는 NaN도 무한대도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">이것은 매크로이며 C99 isinf와 같습니다. 단정도, 배정도 및 확장 정밀도에 적용되며 0이 아닌 값을 반환하면 x는 무한대 (양수 및 음수)입니다.</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">이것은 매크로이며 C99 isnan과 같습니다. 단정도, 배정도 및 확장 정밀도에 대해 작동하며 0이 아닌 값을 반환하면 x는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">이것은 매크로이며 C99 부호와 같습니다. 단정도, 배정도 및 확장 정밀도에 대해 작동하며 0이 아닌 값을 반환하면 x에 부호 비트가 설정되어 있습니다 (숫자가 음수 임).</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">이것은 진폭이 가변적 인 두 어레이를 비교하는 비교적 강력한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">이것은 어레이를 빠르게 구축하는 간단한 방법입니다. 두 가지 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">이것은 사용자가 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 에서 특정 플래그를 요구 하고 다른 배열로 복사해야 했기 때문에이 배열이 사본을 나타내는 경우 설정되는 특수 플래그입니다 (그리고 사용자는 이러한 상황에서이 플래그를 설정하도록 요청했습니다) . 그런 다음 기본 속성은 &quot;misbehaved&quot;배열 (read_only로 설정 됨)을 가리 킵니다. : c : func`PyArray_ResolveWritebackIfCopy`는 내용을&amp;ldquo;misbehaved&amp;rdquo;배열로 다시 복사하고 (필요한 경우 캐스팅)&amp;ldquo;misbehaved&amp;rdquo;배열을 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; 로&lt;/a&gt; 재설정합니다 . 은 &quot;추문&quot;배열이 아닌 경우 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 다음으로 시작하는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 이&lt;/a&gt; 때문에 오류를 반환 것 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; 이&lt;/a&gt; 불가능했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">이것은 매우 유연한 기능입니다. &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; 이&lt;/a&gt; 사용하는 &lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; &lt;/a&gt; 같은 이름이 세 가지 기능에서 동일하게 작동합니다 내부적으로 그렇게 키워드.</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;cPickle.dump&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;cPickle.dumps&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">이것은 PyArray_CanCastTypeTo (PyArray_MinScalarType (arr), totype, cast)의 결과와 거의 동일하지만 uint 값 집합이 같은 수의 유형에 대한 int 값의 하위 집합이 아니기 때문에 발생하는 특수한 경우도 처리합니다. 비트.</target>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">복식 복식 복식의 추가에 특화된 펑크의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">이것은 LAPACK 루틴 &lt;code&gt;dgeqrf&lt;/code&gt; , &lt;code&gt;zgeqrf&lt;/code&gt; , &lt;code&gt;dorgqr&lt;/code&gt; 및 &lt;code&gt;zungqr&lt;/code&gt; 에 대한 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">이것은 N 차원 배열을 쉽게 반복 할 수있는 반복자 객체입니다. ndarray의 flat 속성에서 반환 된 객체입니다. 또한 N- 차원 배열을 반복하기 위해 구현 내부에서 광범위하게 사용됩니다. tp_as_mapping 인터페이스는 반복자 객체를 색인화 (1-d 색인화 사용) 할 수 있도록 구현되며 tp_methods 테이블을 통해 몇 가지 메소드가 구현됩니다. 이 객체는 다음 메소드를 구현하며 파이썬에서 반복자가 사용될 수있는 곳이라면 어디에서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">이것은 N 차원 이웃을 쉽게 반복 할 수있는 반복자 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">이터레이터에 대한 불투명 포인터 유형입니다. 컨텐츠에 대한 액세스는 반복자 API를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">이것은 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP에 대해 정의됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">이것은 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;UBYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;USHORT&lt;/strong&gt; , &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;UINT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;ULONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;ULONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP&lt;/strong&gt; , &lt;strong&gt;UINTP에&lt;/strong&gt; 대해 모두 정의되어 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">이것은 다른 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt; 의 cPickle하지만로드 NumPy와 바이너리 .npy 형식을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 의 다음 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각을 튜플 인덱스로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이는 다음 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이는 다음 &lt;code&gt;ndindex&lt;/code&gt; 및 &lt;code&gt;s_&lt;/code&gt; 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; . &lt;code&gt;condition&lt;/code&gt; 이 부울 인 경우 &lt;code&gt;np.extract&lt;/code&gt; 는 &lt;code&gt;arr[condition]&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">이것은 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; 와 동일합니다 . 자세한 내용 은 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">이는 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; 과 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 합니다. 자세한 내용 은 extras.compress_rowcols 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 1D 모양의 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N)&lt;/code&gt; 으로 재구성 된 후 첫 번째 축을 따라 연결하는 것과 같습니다 . &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">이는 1D 모양의 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N)&lt;/code&gt; 으로 재구성 된 후 첫 번째 축을 따라 연결하는 것과 같습니다 . &lt;code&gt;vsplit&lt;/code&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 첫 번째 축을 따라 연결되는 1 차원 배열을 제외하고 두 번째 축을 따라 연결하는 것과 같습니다. &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 첫 번째 축을 따라 연결되는 1 차원 배열을 제외하고 두 번째 축을 따라 연결하는 것과 같습니다. &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 2 차원 형상 배열 &lt;code&gt;(M,N)&lt;/code&gt; 이 &lt;code&gt;(M,N,1)&lt;/code&gt; 로 재 형성 되고 1 차원 형상 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N,1)&lt;/code&gt; . &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">이것은 2 차원 형상 배열 &lt;code&gt;(M,N)&lt;/code&gt; 이 &lt;code&gt;(M,N,1)&lt;/code&gt; 로 재 형성 되고 1 차원 형상 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N,1)&lt;/code&gt; . &lt;code&gt;dsplit&lt;/code&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">이것은 np.nonzero (np.ravel (a)) [0]과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">이것은 &lt;code&gt;density&lt;/code&gt; 인수 와 동일 하지만 너비가 다른 빈 너비에 대해 잘못된 결과를 생성합니다. 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">이것은 ptr 멤버까지 파이썬의 버퍼 객체 구조와 같습니다. 32 비트 플랫폼에서 ( &lt;em&gt;즉&lt;/em&gt; , &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; 인 경우 ) len 멤버는 버퍼 오브젝트의 동등한 멤버와도 일치합니다. 일반적인 단일 세그먼트 메모리 청크를 나타내는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">이것은 출력 배열을위한 것이며, &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; 플래그를 설정해야합니다. 경우 &lt;code&gt;op[i]&lt;/code&gt; NULL 인 최종 방송 치수 새로운 배열 및 반복기의 반복 순서와 일치하는 레이아웃을 생성한다.</target>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">이것은 일반 정사각형 배열의 고유 값과 고유 벡터를 계산 하는 &lt;code&gt;_geev&lt;/code&gt; LAPACK 루틴을 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">이것은 문서 &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; 와 같은 입력 매개 변수 스펙을 통해 표시됩니다 . 예를 들어 입력 배열에 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; 을 부여하면 크기가 각각 MxM 인 N 행렬의 &quot;스택&quot;으로 해석됩니다. 예를 들어, 결정자가 &lt;code&gt;det : (...)&lt;/code&gt; 가지고 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 경우 det (a) .shape == (N,) 모양의 배열을 반환합니다 . 이는 고차원 배열에서 선형 대수 연산을 일반화합니다. 다차원 배열의 마지막 1 차원 또는 2 차원은 각 연산에 ​​적합하게 벡터 또는 행렬로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">이것은 SVN 저장소에있는 소스 디렉토리로 작업하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">이것은 모든 파이썬 객체에 필요합니다. 이 구성 레퍼런스 카운트 부재 ((최소) &lt;code&gt;ob_refcnt&lt;/code&gt; ) 및 typeobject (포인터 &lt;code&gt;ob_type&lt;/code&gt; ). (파이썬이 특수 옵션으로 컴파일 된 경우 다른 요소도 존재할 수 있습니다. 자세한 내용은 파이썬 소스 트리에서 Include / object.h를 참조하십시오). ob_type 멤버는 Python 타입 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">이진 작업에 다른 도메인의 Poly 개체가 전달되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 기본값 이 &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt; 실제로 중요하지 않습니다 . 자세한 내용은 &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 실제로 다른 기본 동작으로 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 입니다. 자세한 내용은 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">이것은 &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; 이며, 일반적으로 발생하기 때문에 유용합니다. 특히, 배열은 모양 (1 차원 배열로 이루어진 열 벡터)에 1을 포스트 보류 한 상태에서 최소 2 차원으로 업그레이드 한 후 마지막 축을 따라 쌓입니다.</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">이 유사하다 &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 당신이 가진 데이터 형 기술자 지정 제외 (...) &lt;em&gt;type_num&lt;/em&gt; 및 &lt;em&gt;itemsize을&lt;/em&gt; 여기서 &lt;em&gt;type_num의&lt;/em&gt; 내장 명령 (또는 사용자 정의) 유형에 해당합니다. 유형이 항상 같은 수의 바이트를 갖는 경우 itemsize는 무시됩니다. 그렇지 않으면 itemsize는이 배열의 특정 크기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 엔드 포인트가 직접 지정되었습니다. 각 출력 샘플은 이전의 일정한 배수입니다.</target>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; 의 해당 조건을 만족하는 &lt;code&gt;x&lt;/code&gt; 의 요소에 대해 함수가 평가된다는 점을 제외하면 선택 또는 선택과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">이는 순 현재 가치 0.0을 제공하는 &quot;평균&quot;주기적으로 복합 수익률입니다. 자세한 설명은 아래 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">이것은 umath.frompyfunc (function, nin, nout)에 의해 생성 된 동적 ufunc에 의해 사용되는 1 차원 핵심 함수입니다. 이 경우 &lt;em&gt;func&lt;/em&gt; 은 정의가 있는 &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt; 구조에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">이것은 C 라이브러리 함수 fmod의 NumPy 구현이며 나머지는 피제수 &lt;code&gt;x1&lt;/code&gt; 과 동일한 부호를 갖습니다 . Matlab (TM) &lt;code&gt;rem&lt;/code&gt; 함수와 동일하며 Python 모듈러스 연산자 &lt;code&gt;x1 % x2&lt;/code&gt; 와 혼동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">이것은 입력 및 / 또는 출력 배열이 잘못 정렬되거나 기본 1-D 루프가 기대하는 것과 잘못된 데이터 유형 (바이트 스왑 포함)이 될 때마다 상황을 처리하는 코드입니다. 또한 배열은 비 연속적인 것으로 가정합니다. 이 코드는 내부 1D 루프가 수정되어 입력에서 사전 처리가 수행되고 사후 처리가 bufsize 청크 (출력이 bufsize가 사용자 설정 가능)로 수행되는 것을 제외하고는 strided-loop와 매우 유사하게 작동합니다. 매개 변수). 기본 1D 계산 루프는 복사해야하는 데이터에 대해 호출됩니다 (필요한 경우). 이 경우 설정 코드와 루프 코드는 다음을 처리해야하기 때문에 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">이것이 주요 배열 작성 기능입니다. 대부분의 새로운 어레이는이 유연한 기능으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">중첩 된 시퀀스 또는 배열 인터페이스를 노출하는 객체 &lt;em&gt;op&lt;/em&gt; 에서 배열을 얻는 데 사용되는 주요 함수 입니다. 매개 변수를 사용하면 필요한 &lt;em&gt;dtype&lt;/em&gt; , 최소 ( &lt;em&gt;min_depth&lt;/em&gt; ) 및 최대 ( &lt;em&gt;max_depth&lt;/em&gt; ) 차원의 허용 가능한 수 및 배열에 대한 기타 &lt;em&gt;요구 사항&lt;/em&gt; 을 &lt;em&gt;지정할&lt;/em&gt; 수 있습니다. 이 함수 는 dtype 인수에 &lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔칩니다.&lt;/strong&gt; 이는 원하는 데이터 유형 (필수 바이트 순서 포함)을 나타내는 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 여야 합니다. &lt;em&gt;DTYPE의&lt;/em&gt; 인자 일 수있다 &lt;code&gt;NULL&lt;/code&gt; 데이터 타입 (및 바이트 순서)이 허용되는 것을 나타낸다. 하지 않는 한 &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;이 &lt;code&gt;flags&lt;/code&gt; 에 있으면이 호출은 데이터 유형을 객체에서 안전하게 얻을 수없는 경우 오류를 생성합니다. 당신이 사용하려는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 에 대한 &lt;em&gt;DTYPE&lt;/em&gt; 와 배열이 다음 사용 notswapped되어 있는지 확인 &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; 을&lt;/a&gt; . 깊이 매개 변수 중 하나의 값이 0이면 매개 변수가 무시됩니다. &lt;em&gt;요구 사항&lt;/em&gt; 인수 를 얻기 위해 다음 배열 플래그를 추가 할 수 있습니다 ( &lt;em&gt;예 :&lt;/em&gt; | 사용) . 코드는 일반적으로 처리 할 수있는 경우 ( &lt;em&gt;예를 들어,&lt;/em&gt; 스트라이드, 바이트 교환, 또는 정렬되지 않은 배열)를 &lt;em&gt;요구&lt;/em&gt; 하는 경우, 또한 0이 될 수 &lt;em&gt;연산&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;는 이미 배열이 아니거나 배열 인터페이스를 노출하지 않으면 새 배열이 만들어지고 시퀀스 프로토콜을 사용하여 &lt;em&gt;op&lt;/em&gt; 에서 채워집니다 . 새 배열은 플래그 멤버로 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 를 갖 습니다 . &lt;em&gt;컨텍스트&lt;/em&gt; 인자는에 전달 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 방법 &lt;em&gt;OP&lt;/em&gt; 어레이 그렇게 구성되는 경우에만 사용된다. 거의 항상이 매개 변수는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; 의 마스크 배열 버전입니다 . 자세한 내용은 &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; 의 마스크 배열 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt; 함수에 해당하는 마스크 입니다. 새 어레이는 &lt;code&gt;x&lt;/code&gt; 의 반복 된 사본으로 채워집니다 (데이터가 메모리에 저장된 순서대로). 경우 &lt;code&gt;x&lt;/code&gt; 마스크, 새로운 배열은 마스크되고, 새로운 마스크는 이전의 반복 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; 가&lt;/a&gt; 반환 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; 가&lt;/a&gt; 반환 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; 가&lt;/a&gt; ndarray을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; 가&lt;/a&gt; ndarray을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">이는 하위 수준 부동 소수점 섹션에 설명 된 npy_nextafter 및 npy_nextafterf와 같은 반 정밀도 부동 소수점과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">이는 하위 수준 부동 소수점 섹션에 설명 된 npy_spacing 및 npy_spacingf와 같은 반 정밀도 부동 소수점과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">이것은 다음과 같은 다항식입니다.</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">이것은 가장 간단한 경우입니다. ufunc는 기본 1-D 루프를 정확히 한 번 호출하여 실행됩니다. 이것은 입력과 출력 모두에 대해 올바른 유형 (바이트 순서 포함)의 데이터를 정렬하고 모든 배열에 균일 한 보폭 (연속, 0-D 또는 1-D)이있는 경우에만 가능합니다. 이 경우 전체 배열에 대한 계산을 계산하기 위해 1D 계산 루프가 한 번 호출됩니다. 하드웨어 오류 플래그는 전체 계산이 완료된 후에 만 ​​확인됩니다.</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">이것은 반복자를 파이썬에 노출시키는 유형입니다. 현재 Python으로 작성된 반복자의 값에 액세스 할 수있는 API가 노출되어 있지 않습니다. 반복자가 Python으로 작성된 경우 Python에서 반복자를 사용해야합니다. 이러한 API는 향후 버전에서 생성 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">예를 들어 누적 루프를 설정하는 데 유용합니다. 반복자는 누적 축을 포함한 모든 차원으로 생성되어 출력이 올바르게 생성 될 수 있습니다. 그런 다음 누적 축을 제거하고 계산을 중첩 방식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">이는 패키지에 하위 패키지를 추가하기 위해 setup.py 스크립트에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">이는 인덱스 및 데이터 배열에서 지정된 축을 따라 일치하는 일치하는 1d 슬라이스를 반복하며 후자를 사용하여 후자를 찾습니다. 이 슬라이스는 길이가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">이는 인덱스 및 데이터 배열에서 지정된 축을 따라 일치하는 일치하는 1d 슬라이스를 반복하며 전자를 사용하여 값을 후자에 배치합니다. 이 슬라이스는 길이가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">이 반복자는 &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; &lt;/a&gt; 에서 반복적으로 배열의 요소를 하나씩 반환합니다 . &lt;code&gt;flatiter&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 단지 &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 값을 리턴합니다 . &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 은 ABI 수준에서 이전 버전과 호환되지 않을 때마다 변경됩니다. 그러나 C-API에 있기 때문에 현재 헤더에 정의 된 값과이 함수의 출력을 비교하면 C-API가 변경되었는지 테스트하여 C를 사용하는 확장 모듈을 다시 컴파일해야합니다. -API. 이것은 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 함수에서 자동으로 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">이것은 단지 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 값을 리턴합니다 . &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 은 API가 변경 될 때마다 변경됩니다 (예 : 함수 추가). 변경된 값이 항상 재 컴파일을 요구하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">이 매크로는 + inf로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">이 매크로는 -1.0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">이 매크로는 -inf로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">이 매크로는 1.0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 NaN (숫자가 아님)으로 정의되며 부호 비트가 설정되지 않은 ( '긍정적 인'NaN) 보장됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">이 매크로는 NaN 값으로 정의되며 부호 비트가 설정되지 않도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 긍정적 인 정보로 정의됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 음의 0으로 정의됩니다 (즉, 부호 비트가 설정되어 있음). 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">이 매크로는 음의 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">이 매크로는 양의 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 양의 0으로 정의됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">이것은 어떤 방식으로 피연산자 축을 일치시키고 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 로 제거하여 수동으로 처리를 처리 할 때 사용할 수 있습니다 . 축을 제거하기 전에이 기능을 호출하면 수동 처리를위한 보폭을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">이 멤버를 사용하면 배열 객체가 약한 참조를 가질 수 있습니다 (weakref 모듈 사용).</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">이 멤버는이 배열과 관련된 다른 Python 객체에 대한 포인터를 보유하는 데 사용됩니다. 두 가지 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">이 멤버는 인덱스로 표시된 ndarray의 요소를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">이 방법은 원시 기본 의사 난수 생성기를 직접 노출합니다. 모든 값은 PRNG에 의해 생성 된 비트 수에 관계없이 부호없는 64 비트 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">이 메소드는 ValueError 예외를 발생시키는 것 외에는 아무 것도 수행하지 않습니다. 마스크 된 어레이는 데이터를 소유하지 않으므로 안전하게 크기를 조정할 수 없습니다. 대신 &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">이 메소드는 시스템이 내부적으로 &lt;em&gt;obj&lt;/em&gt; 에서 새 배열을 할당 할 때마다 호출됩니다 . 여기서 &lt;em&gt;obj&lt;/em&gt; 는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 (하위 유형)입니다 . 구성 후 (예를 들어 2 차원 행렬을 보장하기 위해) &lt;em&gt;자체&lt;/em&gt; 속성을 변경 하거나 &quot;부모&quot;에서 메타 정보를 업데이트 하는 데 사용할 수 있습니다 . 서브 클래스는 아무것도하지 않는이 메소드의 기본 구현을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">이 방법은 안전하게 구현하기 어렵고 향후 NumPy 릴리스에서 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">이 방법은 이전 버전과의 호환성을 위해서만 사용하십시오 : 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">이 메소드는 버전 번호를 찾을 때까지 문자열 변수 version, __version__ 및 &amp;lt;packagename&amp;gt; _version에 대해 __version__.py, &amp;lt;packagename&amp;gt; _version.py, version.py 및 __svn_version__.py라는 파일을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; 네임 스페이스의 모든 함수가 포함되어 있으며 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt; 을 반환하는 다음 대체 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Chebyshev 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Hermite 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 HermiteE 시리즈를 처리하는 데 유용한 여러 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Laguerre 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Legendre 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 다항식 시리즈를 처리하는 데 유용한 여러 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에 있습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">이 모듈은 오류 및 경고 객체를 제공합니다. 다항식 기본 클래스; &lt;code&gt;polynomial&lt;/code&gt; 과 &lt;code&gt;chebyshev&lt;/code&gt; 모듈 모두에 사용되는 일부 루틴 .</target>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Chebyshev 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Hermite 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Laguerre 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Legendre 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 선형 다항식 &lt;code&gt;off + scl*x&lt;/code&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">주문 매개 변수에 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 지정된 경우에만 반복자에 영향을줍니다 . 기본적으로 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 을 사용하면 반복자는 음수 보폭을 갖는 축을 반전시켜 메모리가 순방향으로 이동합니다. 이 단계는 비활성화됩니다. 축의 기본 메모리 순서를 사용하지만 축을 반전시키지 않으려면이 플래그를 사용하십시오. 예를 들어 이것은 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">이 선택적 매개 변수는 원하는 백분위 수가 두 데이터 포인트 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 사이에있을 때 사용할 보간 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">이 선택적 매개 변수는 원하는 Quantile이 두 데이터 포인트 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 사이에있을 때 사용할 보간 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 NumPy와 독립적으로 개발되었으며 버전 1.17.0에 통합되었습니다. 원래 저장소는 &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">이 페이지에서는 다른 C 확장에서 numpy 배열의 내용에 액세스하기위한 numpy 특정 API에 대해 설명합니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt; 은 모든 확장 모듈이 사용할 수 있도록 유사한 표준 API를 Python 2.6 및 3.0에 도입했습니다. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt; 의 버퍼 배열 지원은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API를 사용합니다 . &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy 튜토리얼을&lt;/a&gt; 참조하십시오 . Cython은 여기에 설명 된 배열 인터페이스를 사용하여 이전 버전과 호환되는 구현이 있으므로 2.6 이전의 Python 버전에서 버퍼 프로토콜을 지원하는 코드를 작성하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">이 페이지는 이터레이터의 API를 설명합니다. 반복자의 이름은 &lt;code&gt;NpyIter&lt;/code&gt; 이고 함수의 이름은 &lt;code&gt;NpyIter_*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">이 포인터는 반복 루프 전에 캐싱 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 포인터는 반복 루프 전에 캐싱 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다. 이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 프로퍼티는이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 허수 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성은이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 실제 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">필요한 경우 데이터 영역에 대한 공간을 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">이 참조 설명서는 NumPy에 포함 된 기능, 모듈 및 객체를 설명하고 해당 기능 및 기능에 대해 설명합니다. NumPy 사용 방법을 배우려면 NumPy 사용 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;설명서&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 차원과 모양 (n, n,&amp;hellip;, n)을 가진 배열 &lt;code&gt;a&lt;/code&gt; 의 주 대각선에 접근하는데 사용될 수있는 인덱스 튜플을 반환합니다 . 들면 &lt;code&gt;a.ndim = 2&lt;/code&gt; 이 들어 보통 대각선 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 이 액세스 인덱스들의 집합 인 &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; 에 대해 &lt;code&gt;i = [0..n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">배열의 기본 개체를 반환합니다. 대부분의 경우 이는 어레이가 가리키는 메모리를 소유 한 객체를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">이 루틴은 일반적인 &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 가없는 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">이 체계에서는 스트림 ID를 재사용하지 않아야합니다. 병렬 프로세스간에 조정이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">이 섹션에서는 기본 범용 함수 계산 루프가 세 가지 다른 종류의 실행 각각에 대해 설정되고 실행되는 방법을 설명합니다. 컴파일 중에 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 정의 되면 오브젝트 배열이 포함되지 않는 한 루프를 호출하기 전에 Python GIL (Global Interpreter Lock)이 해제됩니다. 필요한 경우 오류 조건을 처리하기 위해 다시 확보됩니다. 하드웨어 오류 플래그는 1-D 루프가 완료된 후에 만 ​​확인됩니다.</target>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">이것은 다음과 혼동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">이것은 단순히 위의 생성 된 코드의 3 행과 4 행에서 &lt;code&gt;arg1&lt;/code&gt; 과 &lt;code&gt;arg2&lt;/code&gt; 의 정의 와 19 행과 20 행에서 지정 을 전환하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">이 단일 모듈은 단일 위치에서 numpy 테스트에 대한 모든 공통 기능을 제공하므로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;테스트 스크립트&lt;/a&gt; 가이를 가져 와서 바로 작동 할 수 있습니다. 배경은 &lt;a href=&quot;testing#testing-guidelines&quot;&gt;테스트 지침을&lt;/a&gt; 참조하십시오</target>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">이 구조는 모양 및 / 또는 보폭 정보가 해석 될 때 매우 유용합니다. 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">이 스타일을 사용 하면 데이터 유형 객체 의 &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt; 속성을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">이 스타일은 모든 메모리가 배열 인터페이스 설명에 의해 설명되는 것으로 가정 되므로 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 생성자 에서 &lt;em&gt;정렬&lt;/em&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 스타일에는 2 개의 필수 키와 3 개의 선택적 키가 있습니다. &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;형식의&lt;/em&gt; 키가 필요합니다. 각각의 값은 필드 이름과 필드 형식을 가진 길이가 같은 목록입니다. 필드 이름은 문자열이어야하며 필드 형식은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 생성자가 허용하는 모든 개체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">이 ndarray 서브 클래스는 서브 클래스로 제대로 맞지 않기 때문에 일부 작업과 불쾌한 상호 작용을합니다. 이 서브 클래스를 사용하는 대안은 &lt;code&gt;mmap&lt;/code&gt; 객체를 직접 만든 다음 ndarray .__ new__로 직접 ndarray를 만들어 'buffer ='매개 변수로 생성 된 객체를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">이 템플릿 변환기는 모든 &lt;strong&gt;기능&lt;/strong&gt; 과 &lt;strong&gt;서브 루틴을&lt;/strong&gt; 복제합니다&lt;strong&gt;&lt;/strong&gt;'&amp;lt;&amp;hellip;&amp;gt;'의 규칙에 따라 이름이 '&amp;lt;&amp;hellip;&amp;gt;'인 파일의 블록. '&amp;lt;&amp;hellip;&amp;gt;'에서 쉼표로 구분 된 단어의 수는 블록이 반복되는 횟수를 결정합니다. 이 단어들은 반복 규칙 '&amp;lt;&amp;hellip;&amp;gt;'이 각 블록에서 대체되어야하는 것을 나타냅니다. 블록의 모든 반복 규칙에는 블록을 반복해야하는 횟수를 나타내는 동일한 수의 쉼표로 구분 된 단어가 포함되어야합니다. 반복 규칙의 단어에 쉼표, 왼쪽 화살표 또는 오른쪽 화살표가 필요한 경우 백 슬래시 ''를 앞에 추가하십시오. 반복 규칙의 단어가 '\ &amp;lt;index&amp;gt;'와 일치하면 동일한 반복 사양에서 &amp;lt;index&amp;gt; 번째 단어로 바뀝니다. 반복 규칙에는 이름과 짧은 두 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">이 유형은 브로드 캐스트 개념을 캡슐화하는 반복자를 제공합니다. 그것은 허용</target>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">이 사용법은 다른 dict-based 건설 방법과 모호하기 때문에 권장하지 않습니다. 'names'라는 필드와 'formats'라는 필드가 있으면 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">이 버전은 ASCII 문자열 (실제로 latin1)을 utf8로 인코딩 된 문자열로 대체하므로 유니 코드 필드 이름으로 구조화 된 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">가능한 경우 새로운 뷰 객체가됩니다. 그렇지 않으면 사본이됩니다. 반환 된 배열 의 &lt;em&gt;메모리 레이아웃&lt;/em&gt; (C 또는 Fortran-contiguous)이 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">그러면 foo.ini 파일이 package_dir / lib 디렉토리에 설치되고 foo.ini 파일이 foo.ini.in에서 생성됩니다. 여기서 각 &lt;code&gt;@version@&lt;/code&gt; 은 &lt;code&gt;subst_dict['version']&lt;/code&gt; 로 바뀝니다 . 사전에는 추가 접두사 대체 규칙이 자동으로 추가되는데, 여기에는 설치 접두사가 들어 있습니다 (setup.py에서 쉽게 얻을 수 없기 때문에). npy-pkg-config 파일은 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 함수 에서 반환 된 경로를 사용하여 numpy에 사용 된 것과 동일한 위치에 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">이는 표준 설치 및 전체 빌드에서 모두 작동합니다. 즉, &lt;code&gt;@prefix@&lt;/code&gt; 는 전체 빌드 의 소스 디렉토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">이것들은 정확한 부동 소수점 비교에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">낮은 수준의 작업에서 실제로 우수한 성능을 원하는 사람은 C에서 제공하는 반복 API를 직접 사용하는 것이 좋습니다. 그러나 C 또는 C ++에 익숙하지 않은 사람에게는 Cython은 합리적인 성능 균형을 유지하는 좋은 중간 지점입니다. 에 대한 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 객체 사이 썬의 내부 루프를 제공하면서, 방송, DTYPE 변환 및 버퍼링의 반복자 돌봐셔서이 의미합니다.</target>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">스레딩 지원</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">세 가지 일반적인 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">[-5, 0)의 난수로 구성된 3x2 배열 :</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">어떤 SVD 값 이하의 임계 값은 0으로 간주됩니다. 경우 &lt;code&gt;tol&lt;/code&gt; 없음없고, &lt;code&gt;S&lt;/code&gt; 는 에 대한 특이 값을 갖는 배열 &lt;code&gt;M&lt;/code&gt; 및 &lt;code&gt;eps&lt;/code&gt; 의 데이터 유형에 대한 엡실론 값 &lt;code&gt;S&lt;/code&gt; 후 &lt;code&gt;tol&lt;/code&gt; 로 설정 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">주사위를 20 번 던지십시오 :</target>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">배열을 바둑판 식으로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">타일 ​​배열</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">시간 범위 (절대)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">시간 범위 (상대)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">날짜 / 시간을 표시 할 때 사용할 시간대 정보. 'UTC'이면 UTC 시간을 나타 내기 위해 Z로 끝납니다. 'local'인 경우 먼저 현지 시간대로 변환하고 접미사 +-#### 시간대 오프셋으로 변환하십시오. tzinfo 오브젝트 인 경우 'local'과 동일하게 수행하지만 지정된 시간대를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">Timsort는 이미 또는 거의 정렬 된 데이터의 성능을 향상시키기 위해 추가되었습니다. 임의의 데이터에서 timsort는 mergesort와 거의 동일합니다. 이 옵션은 안정적인 정렬에 사용되는 반면, 퀵 정렬은 선택하지 않은 경우 여전히 기본 정렬입니다. timsort에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt를&lt;/a&gt; 참조하십시오 . 'mergesort'및 'stable'은 정수 데이터 유형의 기수 정렬에 맵핑됩니다. 기수 정렬은 O (n log n) 대신 O (n) 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">팁 &amp;amp; 트릭</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">제목 대소 문자는 대문자로 시작하고 나머지 대소 문자는 모두 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt; 의 문자열 표현으로 인쇄 된 제목입니다 .</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">이 함수를 Cython-ize하기 위해 내부 루프 (y [&amp;hellip;] + = x * x)를 float64 dtype에 특화된 Cython 코드로 바꿉니다. 'external_loop'플래그를 활성화하면 내부 루프에 제공되는 배열은 항상 1 차원이되므로 확인이 거의 필요 없습니다.</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">위의 기본 슬라이싱과 유사한 동작을 달성하기 위해 브로드 캐스트를 사용할 수 있습니다. &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 기능 은이 방송에 도움이 될 수 있습니다. 이것은 예제를 통해 가장 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">NumPy에는 특정 요일 만 유효한 상황에서 날짜 시간을 사용할 수 있도록 &quot;버스 데이&quot;(업무 일) 기능 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">1.e20에 가까운 모든 값이 유효하지 않은 마스크 배열을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">두 번째 요소가 유효하지 않은 배열을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">스칼라 데이터의 유형을 설명하기 위해 NumPy에는 다양한 정수, 부동 소수점 숫자 &lt;em&gt;등을&lt;/em&gt; 위한 &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;내장 스칼라 유형&lt;/a&gt; 이 여러 개 있습니다. 배열에서 추출 된 항목 ( &lt;em&gt;예 :&lt;/em&gt; 인덱싱)은 유형이 배열의 데이터 유형과 연관된 스칼라 유형 인 Python 객체입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">버퍼링 감소를 수행하려면 설정 중에 또 다른 조정이 필요합니다. 일반적으로 반복자 구성은 읽을 수있는 배열의 첫 번째 데이터 버퍼를 버퍼로 복사합니다. 모든 축소 피연산자를 읽을 수 있으므로 버퍼로 읽을 수 있습니다. 불행하게도,이 버퍼링 조작이 완료된 후 피연산자의 초기화는 반복이 시작되는 버퍼에 반영되지 않으며 가비지 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">방송을 활성화하고 제어하려면 줄임표를 사용하십시오. 기본 NumPy 스타일 방송은 &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; 와 같이 각 항의 왼쪽에 줄임표를 추가하여 수행됩니다 . 첫 번째 축과 마지막 축을 따라 추적하려면 &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; 을 수행하거나 가장 왼쪽이 아닌 가장 왼쪽에 인덱스가있는 행렬 행렬 곱을 수행하면됩니다. &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">이와 같이 많은 유사한 단위 테스트를 용이하게하기 위해 C 및 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 매크로와 Python 상속을 포함한 일부 고급 프로그래밍 기술이 사용 됩니다. 이 문서의 목적은 &lt;code&gt;numpy.i&lt;/code&gt; 타입 맵이 예상대로 작동 하는지 확인하는 데 사용되는 테스트 인프라를 설명하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">지정된 datetime64 날짜 범위에 유효한 일 수를 찾으려면 &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">두 개 이상의 배열의 합집합을 찾으려면 functools.reduce를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">차원이 아닌 요소별로 색인을 그룹화하려면 0이 아닌 각 요소에 대한 행을 리턴하는 &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">차원이 아닌 요소별로 색인을 그룹화하려면 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">둘 이상의 배열을 교차하려면 functools.reduce를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">반복자를 이전 반복기와 비슷하게 만들려면 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">필요한 빌드 옵션을 타사에서 사용할 수 있도록 &lt;code&gt;npy-pkg-config&lt;/code&gt; 구현 된 &lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt; -pkg-config 메커니즘을 사용할 수 있습니다 . 이 메커니즘은 모든 옵션이 포함 된 .ini 파일을 기반으로합니다. .ini 파일은 pkg-config unix 유틸리티에서 사용되는 .pc 파일과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">기본 옵션을 되돌리려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">오해의 가능성을 줄이려면 다음과 같은 &quot;남용&quot;이 명목상 지원 되더라도 &lt;code&gt;choices&lt;/code&gt; 은 단일 배열, 즉 가장 바깥 쪽의 시퀀스 형 컨테이너가 목록 또는 튜플이어야한다고 생각해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">유효한 항목 만 검색하기 위해 마스크의 역을 인덱스로 사용할 수 있습니다. 마스크의 역은 &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt; 함수 또는 &lt;code&gt;~&lt;/code&gt; 연산자 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">교차 된 값과 함께 입력 배열에 공통적 인 값의 인덱스를 반환하려면</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">SciPy의 전체 테스트 스위트를 실행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">a와 b 사이에 N 개의 균일 한 간격의 부동 소수점 숫자를 샘플링하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">테스트를 건너 뛰려면 &lt;code&gt;skipif&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">네 개의 연속 값의 누계를 계산하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">datetime64 값을 테스트하여 유효한 날짜인지 확인하려면 &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">마스크 된 어레이의 모든 마스크 된 항목을 마스크 해제하려면 (마스크가 하드 마스크가 아닌 경우) 가장 간단한 해결 방법은 상수 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 를 마스크 에 지정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">하나 또는 여러 개의 특정 항목을 마스크 해제하려면 하나 또는 여러 개의 새 유효한 값을 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">NPY_NO_DEPRECATED_API 메커니즘을 사용하려면 #NumPy 헤더를 포함하기 전에 #NumPy의 대상 API 버전으로 # 정의해야합니다. 1.7에 대해 코드가 깨끗하다는 것을 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">자체 확장에서 핵심 수학 라이브러리를 사용하려면 setup.py에서 npymath 컴파일 및 링크 옵션을 확장에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">선택적으로 제자리에 교체 된 바이트 단위 배열을 반환하여 로우 엔디안 및 빅 엔디안 데이터 표현간에 전환합니다.</target>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">배열 요소의 복잡한 부분에 대한 머신 엡실론의 공차.</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isclose&lt;/code&gt; 에 전달 된 공차 매개 변수</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">공분산 행렬에서 특이 값을 확인할 때의 공차. cov는 확인 전에 두 배로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">배열 요소가 소비 한 총 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">전체 repr이 아닌 요약을 트리거하는 총 배열 요소 수 (기본값 1000).</target>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">전체 repr이 아닌 요약을 트리거하는 총 배열 요소 수입니다. 기본값은 &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">방송 된 결과의 총 크기.</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">행렬의 흔적 :</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 추적 &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">색인 또는 다중 색인 추적</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">색인 또는 다중 색인 추적은 요소마다 다른 색인 값이 필요하기 때문에 외부 루프 사용과 호환되지 않습니다. 이 플래그를 결합하려고하면 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 객체에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">절대 값이 &lt;code&gt;tol&lt;/code&gt; 보다 작거나 같은 후행 (즉, 최상위) 요소 (기본값은 0)가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">계수의 후행 0이 평가에 사용되므로 효율성이 문제가되는 경우 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">마스킹 된 배열을 유연한 유형 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">전환 통지</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">슬라이스 객체를 첫 번째 축을 따라 연결하도록 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">슬라이스 객체를 첫 번째 축을 따라 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">슬라이스 객체를 두 번째 축을 따라 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">전치 유사 조작</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">1 차원 배열을 전치하면 원래 배열의 변경되지 않은 뷰가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">트랜스 포지션 및 순열, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">0으로 나누기위한 치료.</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">부동 소수점 오버 플로우 처리</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">부동 소수점 언더 플로 처리.</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">유효하지 않은 부동 소수점 연산 처리</target>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; 를&lt;/a&gt; 트리거 하고 쓰기를 위해 배열 피연산자가 플래그 지정되어 복사 될 때 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 가 호출 될 때 사본의 데이터가 &lt;code&gt;op[i]&lt;/code&gt; 다시 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">삼각법 역 코사인, 요소 별.</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">삼각법 역 탄젠트, 요소 별.</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">요소 별 삼각 사인.</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">1 차원 배열 또는 시퀀스에서 선행 및 / 또는 후행 0을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">다른 곳에서 자기 자신을 나누십시오.</target>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">&lt;code&gt;m.dtype.type&lt;/code&gt; 이 MaskType 이면 True 이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; 이 스칼라 유형 이면 True이고 , 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 존재 하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 마스크 된 값을 갖는 MaskedArray 인 경우 True , 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">간단한 포트란 77 코드를 성공적으로 컴파일 할 수 있었기 때문에 포트란 77 컴파일러를 사용할 수 있으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">Fortran 90 컴파일러를 사용할 수있는 경우 True입니다 (단순한 Fortran 90 코드를 성공적으로 컴파일 할 수 있었기 때문에)</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">바이트 순서 문자 ( &lt;code&gt;NPY_LITTLE&lt;/code&gt; , &lt;code&gt;NPY_BIG&lt;/code&gt; , &lt;code&gt;NPY_NATIVE&lt;/code&gt; , &lt;code&gt;NPY_IGNORE&lt;/code&gt; )가 고유 바이트 순서의 스펙과 같거나 동등한 경우 참 입니다. 따라서 리틀 엔디안 머신에서 &lt;code&gt;NPY_LITTLE&lt;/code&gt; 및 &lt;code&gt;NPY_NATIVE&lt;/code&gt; 는 빅 엔디안 머신에서 동일하지 않은 경우에 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">캐스팅 규칙에 따라 캐스팅이 발생할 수 있으면 true입니다.</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">다른 사람이 자기와 같은 계급이라면 참</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">계수가 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">도메인이 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">창이 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">두 배열의 모양과 요소가 동일한 경우 True이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">사실 여기서 &lt;code&gt;x&lt;/code&gt; NaN를, 그렇지 않은 경우는 false입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">사실 여기서 &lt;code&gt;x&lt;/code&gt; NAT, 그렇지 않은 경우는 false입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 양의 무한대, 음의 무한대 또는 NaN이 아닌 경우 True ; 그렇지 않으면 거짓. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">TRUE 여기서 &lt;code&gt;x&lt;/code&gt; 는 양 또는 음의 무한대, 그렇지 않은 경우는 false. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">s 값을 50으로 자르면 음모가 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">시리즈를 길이 &lt;code&gt;size&lt;/code&gt; 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">주어진 정도로 시리즈를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">배열의 진실 값 ( &lt;code&gt;bool&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">진실 가치 테스트</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">배열의 진리 값 테스트는 &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt; 호출 하며, 배열의 요소 수가 1보다 크면 이러한 배열의 실제 값이 모호하기 때문에 오류가 발생합니다. 사용 &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt; 대신 이런 경우에 무엇을 의미하는지에 대해 명확하게합니다. 요소의 수가 0이면 배열은 &lt;code&gt;False&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">패키지의 버전 문자열을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">ufunc에 대한 튜플 축 인수는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">배열 차원의 튜플.</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">배열을 탐색 할 때 각 차원에서 단계별로 이동할 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">각 차원의 요소가 배열 크기 인 튜플. 각 항목은 정수입니다 (Python int 또는 long). 이 정수는 플랫폼 &quot;int&quot;또는 &quot;long&quot;이 보유 할 수있는 것보다 클 수 있습니다 (Python int는 C long 임). 이것을 적절히 처리하기 위해서는이 속성을 사용하는 것은 코드에 달려 있습니다. 오버플로가 가능한 경우 오류를 발생 시키거나 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 을 셰이프의 C 유형으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">두 그룹, 당뇨병 아동 (25 명)과 당뇨병이없는 사람 (25 명). 공복 혈당을 측정하였고, 사례 군의 평균값은 86.1, 대조군의 평균값은 82.2였다. 표준 편차는 각각 2.09와 2.49입니다. 이러한 데이터는 부모 당뇨병 상태가 자녀의 혈당 수준에 영향을 미치지 않는다는 귀무 가설과 일치합니까? 데이터에서 F 통계량을 계산하면 값이 36.01입니다.</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">파이의 역수의 두 배 (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">2 개에서 4 개의 샘플 배열</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">N (3, 6.25)의 샘플 2 개씩 배열 :</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">샘플의 2x4 매트릭스</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">2 차원 배열 :</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">2 차원 배열은 정확히 같은 방식으로 테스트됩니다. 위의 설명이 적용되지만 &lt;code&gt;Matrix&lt;/code&gt; 가 &lt;code&gt;Vector&lt;/code&gt; 로 대체되었습니다 . 3 차원 테스트의 경우 &lt;code&gt;Vector&lt;/code&gt; 대신 &lt;code&gt;Tensor&lt;/code&gt; 를 사용하십시오 . 4 차원 테스트의 경우 &lt;code&gt;SuperTensor&lt;/code&gt; 를 &lt;code&gt;Vector&lt;/code&gt; 로 대체 하십시오 . 전체 내부 배열 테스트의 경우 &lt;code&gt;Flat&lt;/code&gt; 을 &lt;code&gt;Vector&lt;/code&gt; 로 대체하십시오 . 다음 설명에 대해서는 &lt;code&gt;Vector&lt;/code&gt; 테스트 를 참조 하지만 &lt;code&gt;Matrix&lt;/code&gt; , &lt;code&gt;Tensor&lt;/code&gt; 및 &lt;code&gt;SuperTensor&lt;/code&gt; 테스트 에도 동일한 정보가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">타입 설명 예제</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">유형에는 관련 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">유형에 첨부 된 크기 정보가 없으며 크기를 조정할 수 있습니다. 유연한 dtype에서만 호출해야합니다. 배열에 연결된 유형은 항상 크기가 조정되므로이 매크로의 배열 형식은 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">유형은 유연하거나 사용자 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">부울 배열의 경우 유형이 유지되므로 연속 요소가 동일 하면 결과에 &lt;code&gt;False&lt;/code&gt; 가 포함 되고 요소가 다르면 &lt;code&gt;True&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">데이터 유형 (정수, 부동 소수점, Python 객체 등)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 의 DTYPE가 기본값으로 지정되지 않은 &lt;code&gt;a&lt;/code&gt; 하지 않는 한, &lt;code&gt;a&lt;/code&gt; 덜 기본 플랫폼 정수보다 정밀도 정수 DTYPE 있습니다. 이 경우 기본 플랫폼 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">반환 된 배열의 유형과 요소가 곱해지는 누산기의 유형입니다. 경우 &lt;em&gt;DTYPE은&lt;/em&gt; 의 DTYPE가 기본값으로 지정되지 않은 &lt;code&gt;a&lt;/code&gt; 하지 않는 한, &lt;code&gt;a&lt;/code&gt; 덜 기본 플랫폼 정수보다 정밀도 정수 DTYPE 있습니다. 이 경우 기본 플랫폼 정수가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">반환 된보기의 유형 (예 : ndarray 또는 행렬) 다시, 기본값 없음은 유형 보존을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">NumPy의 타입 프로모션은 C ++과 같은 언어의 규칙과 비슷하지만 약간의 차이가 있습니다. 스칼라와 배열을 모두 사용하는 경우 배열 유형이 우선하며 스칼라의 실제 값이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">제공되는 유형 :</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">유형은 부울 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">유형은 부호있는 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">유형은 문자열 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">유형은 사용자 정의 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Type은 표준 Python 스칼라 (bool, int, float 또는 complex) 중 하나에 해당하는 열거 된 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">유형은 부호없는 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">유형은 복잡한 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">유형은 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">유형은 정수, 부동 소수점 또는 복합 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">유형은 모든 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">유형은 객체 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">유형은 가변 배열 유형 중 하나 ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; )를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">하나의 입력 인수를 사용하고 하나의 출력을 리턴하여 함수를 호출하여 각 계산을 얻는 ufunc에 대한 유형별 핵심 1 차원 함수입니다. 이 함수는 &lt;code&gt;func&lt;/code&gt; 에 전달됩니다 . 문자는 지원되는 데이터 유형 ( &lt;code&gt;e&lt;/code&gt; - 반, &lt;code&gt;f&lt;/code&gt; -float, &lt;code&gt;d&lt;/code&gt; -double, &lt;code&gt;g&lt;/code&gt; -long double, &lt;code&gt;F&lt;/code&gt; -cfloat, &lt;code&gt;D&lt;/code&gt; -cdouble, &lt;code&gt;G&lt;/code&gt; -clongdouble)의 dtypechar에 해당합니다. &lt;em&gt;func&lt;/em&gt; 인수 는 동일한 서명을 지원해야합니다. _As_X_X 변형은 하나의 데이터 유형의 ndarray를 가정하지만 다른 데이터 유형을 취하는 기본 함수를 사용하도록 값을 캐스트합니다. 따라서 &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;데이터 유형 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 의 ndarray를 사용&lt;/a&gt; 하지만 double을 가져오고 double을 리턴하는 C 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">두 개의 입력 인수를 사용하고 하나의 출력을 리턴하여 함수를 호출하여 각 계산을 얻는 ufunc에 대한 유형별 핵심 1 차원 함수입니다. 호출 할 기본 함수는 &lt;em&gt;func&lt;/em&gt; 로 전달됩니다 . 문자는 범용 함수가 지원하는 특정 데이터 유형의 dtypechar에 해당합니다. &lt;code&gt;func&lt;/code&gt; 인수 는 해당 서명을 지원해야합니다. &lt;code&gt;_As_XX_X&lt;/code&gt; 의 변종은 하나 개의 데이터 유형의 ndarrays을 가정하지만 다른 데이터 형식을 취하는 기본 기능을 사용하려면 루프의 각 반복에 값을 캐스팅.</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">형식 지정자 문자열은 dtypes로 변환 가능하므로 dtypes 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">타입 문자열</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;code&gt;float64&lt;/code&gt; 입니다 . 부동 소수점 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;code&gt;float64&lt;/code&gt; 입니다 . 부정확 한 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">표준 편차 계산에 사용할 유형입니다. 정수 유형의 배열의 경우 기본값은 float64이고, float 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우 기본값은 &lt;code&gt;float32&lt;/code&gt; 입니다 . 부동 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">배열이 캐스트되는 유형 코드 또는 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">복잡한 부동 소수점 유형에 대한 유형 맵 변환도 자동으로 지원되지 않습니다. 이는 Python과 NumPy가 C로 작성 되었기 때문에 기본 복합 유형이 없습니다. Python과 NumPy 는 복잡한 변수에 대해 고유 한 (구조적으로 동등한) &lt;code&gt;struct&lt;/code&gt; 정의를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">유형 맵은 유형 또는 유형 및 이름별로 하나 이상의 함수 인수 목록에서 제외됩니다. 이러한 목록을 &lt;em&gt;서명&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;numpy.i&lt;/code&gt; 로 정의 된 많은 유형 맵 중 하나가 위에서 사용 되었으며 서명 &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; 있습니다. 인수 이름은 &lt;code&gt;double*&lt;/code&gt; 인수가 한 차원의 입력 배열이고 &lt;code&gt;int&lt;/code&gt; 가 해당 차원의 크기를 나타냄을 의미합니다. 이것은 정확히 &lt;code&gt;rms&lt;/code&gt; 프로토 타입 의 패턴입니다 .</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 이있는 유형</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">일반적으로 경험적 테스트에서 대부분의 경우 최적의 경로를 반환하는 '욕심쟁이'알고리즘이 적용됩니다. 경우에 따라 '최적'은 더 비싸고 철저한 검색을 통해 최상의 경로를 반환합니다. 반복 계산의 경우 최적 경로를 한 번 계산하고 해당 경로를 인수로 제공하여 해당 경로를 재사용하는 것이 좋습니다. 아래에 예가 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">일반적으로 배열 메타 데이터의 새로운 버전이지만 동일한 데이터 버퍼는 데이터 버퍼에 대한 새로운 '보기'입니다. 다른 ndarray 객체가 있지만 동일한 데이터 버퍼를 사용합니다. 그렇기 때문에 데이터 버퍼의 새롭고 독립적 인 복사본을 만들려면 .copy () 메서드를 사용하여 복사본을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">일반적으로이 값은 모든 ufunc가 선택적인&amp;ldquo;out&amp;rdquo;인수를 사용하기 때문에 예상했던 것보다 하나 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">일반적으로 출력의 모든 코어 치수의 크기는 입력 배열에서 동일한 레이블이있는 코어 치수의 크기에 의해 결정됩니다. 이것은 필수 사항이 아니며 출력에서 ​​레이블이 처음으로 나타나는 시그니처를 정의 할 수 있지만 이러한 함수를 호출 할 때 일부 예방 조치를 취해야합니다. 예를 들어 , 서명 &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; 를 갖는 &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; 함수 는 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 차원 벡터 의 배열이 주어지면 그들 사이의 모든 고유 쌍별 유클리드 거리를 계산합니다. 따라서 출력 치수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; 같아야합니다.그러나 올바른 크기의 출력 배열을 전달하는 것은 호출자의 책임입니다. 전달 된 입력 또는 출력 배열에서 출력의 코어 치수 크기를 결정할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U) (더 이상 사용되지 않음)로 WRITEBACKIFCOPY로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">업데이트 / U</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY는 &lt;code&gt;False&lt;/code&gt; 로만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL을 사용하려면 스키마 문자열 ( &lt;code&gt;http://&lt;/code&gt; )을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufuncs를 사용하면 특정 배열의 입력이 동일한 클래스의 출력을 유도한다는 점에서 다른 배열과 유사한 클래스를 인터페이스를 통해 원활하게 전달할 수 있습니다. 이것이 작동하는 메커니즘은 다음과 같습니다. 입력 중 ndarrays 아닌 상기 정의하면 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; 의&lt;/a&gt; 방법을, 다음으로 큰 클래스 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 특성 (전달 모든 출력 어레이를 제외한) 모든 출력의 유형을 결정한다. 입력 배열 의 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 메소드는 입력으로 ufunc에서 ndarray를 반환하여 호출됩니다. &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 에는 두 가지 호출 스타일이 있습니다.기능 지원. 첫 번째는 ndarray를 첫 번째 인수로 사용하고&amp;ldquo;context&amp;rdquo;의 튜플을 두 번째 인수로 사용합니다. 컨텍스트는 (ufunc, arguments, output argument number)입니다. 시도한 첫 번째 전화입니다. TypeError가 발생하면 첫 번째 인수로 ndarray 만 사용하여 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs에는 멋진 인덱싱을 사용하여 작업을 수행 할 수있는 다섯 번째 방법도 있습니다. 팬시 색인 작성이 사용되는 차원에는 버퍼링이 사용되지 않으므로, 팬시 색인은 항목을 두 번 이상 나열 할 수 있으며 해당 항목에 대한 이전 조작의 결과에 대해 조작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs : 배열 의 &lt;code&gt;ALIGNED&lt;/code&gt; 플래그가 False이면 ufuncs는 평가 전에 배열을 버퍼링 / 캐스트합니다. 이것은 ufunc 내부 루프가 원시 요소에 직접 액세스하기 때문에 필요합니다. 요소가 실제로 정렬되지 않으면 일부 아치에서 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">크기가 조정되지 않은 유연한 데이터 형식 개체에는이 특성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">단항 연산 :</target>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">언더 플로 : 결과가 0에 가까워 일부 정밀도가 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; 를&lt;/a&gt; 취소하고 주파수가 0 인 용어를 배열의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">유니 코드 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; 의&lt;/a&gt; 고정 길이 시퀀스 )</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">유니 코드 문자열</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">유니폼 ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">입력 배열의 고유 한 정렬 조합.</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">단위 변환</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">단일 배열. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원은 입력 &lt;code&gt;a&lt;/code&gt; 와 크기가 같습니다 . 마지막 두 차원의 크기는 &lt;code&gt;full_matrices&lt;/code&gt; 값에 따라 다릅니다 . &lt;code&gt;compute_uv&lt;/code&gt; 가 True 인 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">범용 함수</target>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">범용 기능</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">범용 함수 ( &lt;code&gt;ufunc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">범용 함수 (ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">범용 함수는 호출 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">범용 함수는 하드웨어의 특수 부동 소수점 상태 레지스터를 트립 할 수 있습니다 (예 : 0으로 나누기). 플랫폼에서 사용 가능한 경우 이러한 레지스터는 계산 중에 정기적으로 확인됩니다. 오류 처리는 스레드별로 제어되며 기능을 사용하여 구성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">NumPy의 범용 함수는 혼합 유형 서명을 가질 수있을만큼 유연합니다. 따라서 예를 들어 부동 소수점 및 정수 값으로 작동하는 범용 함수를 정의 할 수 있습니다. 예제는 &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">위와 같은 레이블이없는 테스트는 기본 &lt;code&gt;scipy.test()&lt;/code&gt; 실행에서 실행됩니다. 테스트에 느린 레이블을 지정하고 전체 &lt;code&gt;scipy.test(label='full')&lt;/code&gt; 실행을 위해 예약 하려면 데코레이터로 레이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">&lt;code&gt;refcheck&lt;/code&gt; 이 거짓이 아닌 한 :</target>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt; (그러나 같은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt; ) Nyquist 주파수 성분은 긍정적 인 것으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt; 와 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; 는&lt;/a&gt; 입력이 이미 행렬 또는 ndarray 경우 복사를하지 않는다. 상당 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; 는&lt;/a&gt; 입력이 이미 행렬 또는 ndarray 경우 복사를하지 않는다. 상당 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Chebyshev 계열의 차이는 Chebyshev 계열 (결과를 기본 집합에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 빼기가 단순히 &quot;구성 요소 별&quot;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Hermite 계열의 차이점은 Hermite 계열 (결과를 기본 집합에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 빼기가 단순히 &quot;구성 요소 별&quot;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Laguerre 계열의 차이는 Laguerre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 빼기는 단순히&amp;ldquo;구성 요소 별&amp;rdquo;입니다 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Legendre 시리즈의 차이점은 Legendre 시리즈 (결과를 기본 세트에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 빼기가 단순히 &quot;구성 요소 별&quot;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Chebyshev 계열의 합은 Chebyshev 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 단순히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Hermite 계열의 합은 Hermite 계열 (결과를 기본 집합에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 간단히 &quot;구성 요소 별&quot; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리, 두 개의 Laguerre 계열의 합은 Laguerre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 간단히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Legendre 계열의 합은 Legendre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 간단히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">내장 된 &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; &lt;/a&gt; 와 달리 위의 방정식은 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에서 대칭이 아니며 &lt;code&gt;b&lt;/code&gt; 는 참조 값 이라고 가정 하므로 &lt;code&gt;isclose(a, b)&lt;/code&gt; 는 &lt;code&gt;isclose(b, a)&lt;/code&gt; 다를 수 있습니다 . 또한, atol의 기본값은 0이 아니며 0에 가까운 것으로 간주해야하는 작은 값을 결정하는 데 사용됩니다. 기본값은 주문 통일의 예상 값에 적합합니다. 예상 값이 1보다 상당히 작 으면 오 탐지가 발생할 수 있습니다. 사용 사례에 따라 &lt;code&gt;atol&lt;/code&gt; 을 신중하게 선택해야합니다. 에 대한 값이 0 &lt;code&gt;atol&lt;/code&gt; 발생합니다 &lt;code&gt;False&lt;/code&gt; 중 하나의 경우 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 가 0입니다.</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">유리 함수 달리 &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; ,이 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 는&lt;/a&gt; 형상 매개 변수의 요소들이 별도의 인수로서 전달 될 수있다. 예를 들어, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 은 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">유리 함수 달리 &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; ,이 메소드 &lt;code&gt;ndarray&lt;/code&gt; 는 형상 매개 변수의 요소들이 별도의 인수로서 전달 될 수있다. 예를 들어, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 은 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">표준 numpy 비교 연산자와 달리 &lt;code&gt;char&lt;/code&gt; 모듈 의 연산자 는 비교를 수행하기 전에 후행 공백 문자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">항목 마스킹 해제</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;hardmask&lt;/code&gt; 속성 으로 표시된 것처럼 마스크 된 배열에 &lt;em&gt;하드&lt;/em&gt; 마스크 가있는 경우 직접 할당으로 항목을 마스크 해제하면 자동으로 실패 합니다. 이 기능은 마스크 덮어 쓰기를 방지하기 위해 도입되었습니다. 배열에 하드 마스크가있는 항목을 강제로 마스크 해제하려면 할당 전에 &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 마스크를 먼저 부드럽게해야합니다 . &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 로 다시 강화할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">동일한 이름을 공유하는 수정되지 않은 코어 치수는 크기가 같아야합니다. 각 차원 이름은 일반적으로 기본 함수 구현에서 한 수준의 루핑에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">uint8 배열의 요소를 이진 값 출력 배열로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">부호없는 정수 :</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">부호없는 버전의 정수는 정수 이름 앞에 'u'를 붙여서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">1.15 릴리스까지 NumPy는 &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;노즈&lt;/a&gt; 테스트 프레임 워크를 사용했으며 &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;이제는 pytest&lt;/a&gt; 프레임 워크를 사용합니다 . 이전 numpy 프레임 워크를 사용하는 다운 스트림 프로젝트를 지원하기 위해 이전 프레임 워크는 계속 유지되지만 NumPy에 대한 모든 테스트는 pytest를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">값 사이의 델타를 2 * pi 보완으로 변경하여 줄 바꿈을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">주어진 축을 따라 절대 점보다 큰 절대 점프 를 2 * pi 보수 로 변경하여 라디안 위상 &lt;code&gt;p&lt;/code&gt; 의 &lt;code&gt;discont&lt;/code&gt; 을 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">1d 배열에 대한 일반적인 상관 관계 정의를 사용하는 PyArray_Correlate 버전이 업데이트되었습니다. &lt;em&gt;op1&lt;/em&gt; 에 시프트 된 버전의 &lt;em&gt;op2&lt;/em&gt; 를 곱하고 결과를 합산하여 각 출력 지점에서 상관 관계가 계산됩니다 . 시프트의 결과로 정의 된 &lt;em&gt;op1&lt;/em&gt; 및 &lt;em&gt;op2&lt;/em&gt; 범위를 벗어난 필요한 값 은 0으로 해석됩니다. 모드는 리턴 할 시프트 수를 결정합니다. 0-0 값을 가정 할 필요가없는 시프트 만 리턴합니다. 1- &lt;em&gt;op1&lt;/em&gt; 과 동일한 크기의 객체를 반환합니다 . 2-가능한 모든 시프트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">출력 간격의 상한. 생성 된 모든 값은 높지 않습니다. 기본값은 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">상한은 &lt;code&gt;left&lt;/code&gt; 보다 커야합니다 .</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">상위 또는 하위 삼각 콜레 요인 . 경우 매트릭스 오브젝트를 돌려줍니다 &lt;code&gt;a&lt;/code&gt; 매트릭스 개체입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">배열의 위쪽 삼각형.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 의&lt;/a&gt; 별칭 이므로 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 자세한 내용은 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">이 경우 대신 &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; 또는 nulp (부동 소수점 값 수) 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">이 동작이 의도적 인 경우 &lt;code&gt;atleast1d&lt;/code&gt; 를 명시 적으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.rec.fromrecords&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">&lt;code&gt;axes&lt;/code&gt; 키워드 인수를 사용할 때 텐서의 전치를 반전 하려면 &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">인덱스 배열을 사용하여 일련의 선택 항목에서 새 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">부울 인덱싱을 사용하여 짝수까지 더하는 모든 행을 선택하십시오. 동시에 0과 2 열은 고급 정수 인덱스로 선택해야합니다. &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">frompyfunc을 사용하여 파이썬 함수 &lt;code&gt;oct&lt;/code&gt; 에 브로드 캐스트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">정수 사용 ()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">소스 생성 기능 내부에서이를 사용하여 설정 분배 인스턴스가 초기화되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">내부 버퍼 사용</target>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">두 개의 미리 정의 된 인스턴스를 사용하여 하나 &lt;code&gt;index_exp&lt;/code&gt; 또는 &lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 직접 사용하는 대신 &lt;code&gt;IndexExpression&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 키워드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 크워 그를 사용하여 &lt;code&gt;high&lt;/code&gt; 간격의 엔드 포인트 포함 또는 제외를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">사용 &lt;code&gt;order&lt;/code&gt; 구조화 된 배열을 정렬 할 때 사용하는 필드를 지정하는 키워드 :</target>
        </trans-unit>
        <trans-unit id="25cbadfbabe4aec8c49a2fe4ad5d41f89ab2957d" translate="yes" xml:space="preserve">
          <source>Use the indices of the non-zero elements as an index array to extract these elements:</source>
          <target state="translated">0이 아닌 요소의 인덱스를 인덱스 배열로 사용하여 다음 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6f1513bb6f3e4a98050539792c7f3cbaf760a6" translate="yes" xml:space="preserve">
          <source>Used as-is.</source>
          <target state="translated">있는 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="86d25879dd6e8e65f51cfd2c9e310da0aa3fb93c" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. Normal return value is 0. A -1 is returned if an error occurs.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 카운트를 감소시킵니다 . 정상 반환 값은 0입니다. 오류가 발생하면 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12676328e0f8258da10db691bf737e9cd286a726" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 횟수를 증가시킵니다 . 오류가 발생하면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a13b41ea5661dcbc4d05b7183bc9d474dd67bb8" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1500692edf9e6d67bd590cb2e6428fecab9820c" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array. Returns a copy of the array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 . 배열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="054ce70cbf81d2356ba6ae20aa8fb864ef13bf9e" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="df1278433c263cdbbd69170e679d3f52bb78e816" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;constant&amp;rsquo;. The values to set the padded values for each axis.</source>
          <target state="translated">'일정한'에서 사용됩니다. 각 축에 대해 채워진 값을 설정하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="465b8fcd19cd5e2ed77adff74f2ff5a3fc18db79" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;linear_ramp&amp;rsquo;. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</source>
          <target state="translated">'linear_ramp'에서 사용됩니다. linear_ramp의 끝 값에 사용되며 패딩 배열의 가장자리를 형성하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="d71d6f65b16e9b35cb9fcf9b7569838936b2caa2" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;maximum&amp;rsquo;, &amp;lsquo;mean&amp;rsquo;, &amp;lsquo;median&amp;rsquo;, and &amp;lsquo;minimum&amp;rsquo;. Number of values at edge of each axis used to calculate the statistic value.</source>
          <target state="translated">'최대 값', '평균값', '중간 값'및 '최소값'에 사용됩니다. 통계 값을 계산하는 데 사용되는 각 축의 가장자리에있는 값의 수입니다.</target>
        </trans-unit>
        <trans-unit id="4325f42e7e418215aac0a73c897c39904b4d0a1e" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;reflect&amp;rsquo;, and &amp;lsquo;symmetric&amp;rsquo;. The &amp;lsquo;even&amp;rsquo; style is the default with an unaltered reflection around the edge value. For the &amp;lsquo;odd&amp;rsquo; style, the extended part of the array is created by subtracting the reflected values from two times the edge value.</source>
          <target state="translated">'반사'및 '대칭'에 사용됩니다. '짝수'스타일은 가장자리 값을 기준으로 변경되지 않은 반사의 기본값입니다. 'odd'스타일의 경우 가장자리 값의 두 배에서 반사 된 값을 빼서 배열의 확장 부분을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1b7f1793a4a4b44dd1933f922f757d629d3be5a3" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">loop-&amp;gt; obj가 true가 아닌 경우 ( &lt;em&gt;즉,&lt;/em&gt; 이것은 OBJECT 배열 루프가 아님) Python GIL을 해제하기 위해 범용 함수 코드에서 사용됩니다 . 변수 선언 영역에서 &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="10031fc1a49c2cbba6bbb424956b8667cda6fefa" translate="yes" xml:space="preserve">
          <source>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&amp;gt;obj was not true).</source>
          <target state="translated">일반 함수 코드에서 사용되어 파이썬 GIL이 릴리스 된 경우 (loop-&amp;gt; obj가 true가 아니기 때문에) 다시 획득합니다.</target>
        </trans-unit>
        <trans-unit id="c23b41a6c14497a2fa2fb894918e5ebdff35b118" translate="yes" xml:space="preserve">
          <source>Used to construct the convolution operator.</source>
          <target state="translated">컨볼 루션 연산자를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c64c33615821368bc9743122d8a6c96ff848fe" translate="yes" xml:space="preserve">
          <source>Used to fill the array with data.</source>
          <target state="translated">배열을 데이터로 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b06029f962bdaa60d205631cac84f36f3e29d6f" translate="yes" xml:space="preserve">
          <source>Useful functions in &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 에서 유용한 기능</target>
        </trans-unit>
        <trans-unit id="7dc863346a17f843606dc78b7fd5eaa70c18759a" translate="yes" xml:space="preserve">
          <source>Useful math constants</source>
          <target state="translated">유용한 수학 상수</target>
        </trans-unit>
        <trans-unit id="d7e7cae700d3c37685c439282d2378cb79df959c" translate="yes" xml:space="preserve">
          <source>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</source>
          <target state="translated">이 매크로의 BEGIN 형식을 사용하여 릴리스 된 상황에서 GIL을 다시 얻는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d580b2c9b4825f08cb2691c40cd94404df444f3e" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop. Equivalent to</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 에 루프 실행 중에 Python 인터프리터가 필요할 수있는 임의의 Python 객체가 포함되지 않은 경우에만 GIL을 해제하는 데 유용합니다 . 에 해당</target>
        </trans-unit>
        <trans-unit id="2978535fda1f10395442e618746112da0bb87d3a" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;loop_size&lt;/em&gt; exceeds a minimum threshold, currently set to 500. Should be matched with a &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt;&lt;code&gt;NPY_END_THREADS&lt;/code&gt;&lt;/a&gt; to regain the GIL.</source>
          <target state="translated">&lt;em&gt;loop_size&lt;/em&gt; 가 현재 500으로 설정된 최소 임계 값을 초과하는 경우에만 GIL을 해제하는 데 유용합니다 . GIL을 다시 얻으려면 &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt; &lt;code&gt;NPY_END_THREADS&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2637443926c71ce03a091c2e95bf9b5610348992" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; as a first string argument creates a matrix.</source>
          <target state="translated">'r'또는 'c'를 첫 번째 문자열 인수로 사용하면 행렬이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="65fcf8542af4dfa98c8e336c7ebb663b2e96f530" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; one can quickly construct index arrays that will index the cross product. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; returns the array &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; one을 사용 하면 교차 곱을 인덱싱 할 인덱스 배열을 빠르게 구성 할 수 있습니다. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; 는 배열 &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32ece8fbb6c1ed850bf1c3c8fb0f4d5a7300c2c0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with **kwds, the arrays are saved with the keyword names.</source>
          <target state="translated">** kwds와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 키워드 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c36d4099fe15bc91bbfe91acb74cd64e75d6b3f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with *args, the arrays are saved with default names.</source>
          <target state="translated">* args와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 기본 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d4ecb91f09183edc4f23a5cc314556ac8c1af3c8" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">유연한 &lt;code&gt;dtype&lt;/code&gt; 사용 .</target>
        </trans-unit>
        <trans-unit id="cfac66afdbdc20a411f9f9f200f87cdcbe870cdd" translate="yes" xml:space="preserve">
          <source>Using a view to convert an array to a recarray:</source>
          <target state="translated">뷰를 사용하여 배열을 recarray로 변환 :</target>
        </trans-unit>
        <trans-unit id="a4fb72e0c5f0602466b0b452237f4e23496663cc" translate="yes" xml:space="preserve">
          <source>Using an External Loop</source>
          <target state="translated">외부 루프 사용</target>
        </trans-unit>
        <trans-unit id="f210f428b873c49c7b2b57aa15cfa3164fde53af" translate="yes" xml:space="preserve">
          <source>Using an instance of &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, and upon exiting it is reset to what it was before.</source>
          <target state="translated">컨텍스트 관리자로 &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하면 해당 컨텍스트의 명령문이 알려진 오류 처리 동작으로 실행될 수 있습니다. 컨텍스트에 들어가면 오류 처리는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; 로&lt;/a&gt; 설정 되며 종료시 이전 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7af0c7a348040b3b4ff1744a0608d17163c9138e" translate="yes" xml:space="preserve">
          <source>Using array-protocol type strings:</source>
          <target state="translated">배열 프로토콜 유형 문자열 사용 :</target>
        </trans-unit>
        <trans-unit id="fd7054fa064ad2611d4b7d00df8240d7735e3c37" translate="yes" xml:space="preserve">
          <source>Using array-scalar type:</source>
          <target state="translated">배열 스칼라 타입 사용하기 :</target>
        </trans-unit>
        <trans-unit id="03a2b430abf28e746816ea1cff1b193db00a94c9" translate="yes" xml:space="preserve">
          <source>Using comma-separated field formats. The shape is (2,3):</source>
          <target state="translated">쉼표로 구분 된 필드 형식 사용 모양은 (2,3)입니다.</target>
        </trans-unit>
        <trans-unit id="e282c417933d97d3a53a56d481d1f405a74c7c0d" translate="yes" xml:space="preserve">
          <source>Using complex sequences:</source>
          <target state="translated">복잡한 시퀀스 사용하기 :</target>
        </trans-unit>
        <trans-unit id="26e522c98bd807e94f2ab9fc3a1975ce203f287e" translate="yes" xml:space="preserve">
          <source>Using dictionaries. Two fields named &amp;lsquo;gender&amp;rsquo; and &amp;lsquo;age&amp;rsquo;:</source>
          <target state="translated">사전 사용. '성별'과 '나이'라는 두 필드 :</target>
        </trans-unit>
        <trans-unit id="af330b02f13d207e5fac3c22b8c9bdbaab36afee" translate="yes" xml:space="preserve">
          <source>Using dtype = None</source>
          <target state="translated">dtype = None 사용</target>
        </trans-unit>
        <trans-unit id="8d2131672fafcfdf449f29b29350743e40c17d69" translate="yes" xml:space="preserve">
          <source>Using months for the unit:</source>
          <target state="translated">단위에 개월 사용 :</target>
        </trans-unit>
        <trans-unit id="2f696379652fe6905a66fc5fd2b9273fa2471296" translate="yes" xml:space="preserve">
          <source>Using numpy.i</source>
          <target state="translated">numpy.i 사용</target>
        </trans-unit>
        <trans-unit id="e8111da9fdc8286f7fa1decedd3c62fdfaa40d28" translate="yes" xml:space="preserve">
          <source>Using numpy.ma</source>
          <target state="translated">numpy.ma 사용</target>
        </trans-unit>
        <trans-unit id="03252764a2ca129ee8f53a1ebcd3c94ffd3382b7" translate="yes" xml:space="preserve">
          <source>Using poly1d objects:</source>
          <target state="translated">poly1d 객체 사용 :</target>
        </trans-unit>
        <trans-unit id="79eb3bbcb08c7d6704be86d77b0727b917270b3d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute matrix norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 행렬 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="9e684f49459c0d5aba4c5f2579aeb17add74610d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute vector norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 벡터 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="b9ba36c2f053a06ac3abc3a930f4a1d05aada052" translate="yes" xml:space="preserve">
          <source>Using the Convenience Classes</source>
          <target state="translated">편의 클래스 사용</target>
        </trans-unit>
        <trans-unit id="1bd2966f639ab87086919a9a710a3ff850eadf79" translate="yes" xml:space="preserve">
          <source>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In &lt;em&gt;implicit&lt;/em&gt; mode &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; computes these values.</source>
          <target state="translated">아인슈타인 합산 규칙을 ​​사용하면 많은 일반적인 다차원 선형 대수 배열 연산을 간단한 방식으로 표현할 수 있습니다. 에서는 &lt;em&gt;암시&lt;/em&gt; 모드 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 는&lt;/a&gt; 이 값을 계산한다.</target>
        </trans-unit>
        <trans-unit id="75da2a462c666654f41a122b8cf7201ccca6f453" translate="yes" xml:space="preserve">
          <source>Using the casting rules</source>
          <target state="translated">캐스팅 규칙 사용</target>
        </trans-unit>
        <trans-unit id="0e2a18ad6df592872579dd4bbee44818b7034db3" translate="yes" xml:space="preserve">
          <source>Using these #defines you can use the C-API in multiple files for a single extension module. In each file you must define &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to some name that will hold the C-API (&lt;em&gt;e.g.&lt;/em&gt; myextension_ARRAY_API). This must be done &lt;strong&gt;before&lt;/strong&gt; including the numpy/arrayobject.h file. In the module initialization routine you call &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;. In addition, in the files that do not have the module initialization sub_routine define &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; prior to including numpy/arrayobject.h.</source>
          <target state="translated">이러한 #defines를 사용하면 단일 확장 모듈에 대해 여러 파일에서 C-API를 사용할 수 있습니다. 각 파일에서 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 C-API를 보유 할 이름으로 정의해야합니다 ( &lt;em&gt;예 :&lt;/em&gt; myextension_ARRAY_API). numpy / arrayobject.h 파일을 포함시키기 &lt;strong&gt;전에&lt;/strong&gt; 수행해야 합니다. 모듈 초기화 루틴에서 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 . 또한, 모듈 초기화 sub_routine이없는 파일에 정의 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; NumPy와 / arrayobject.h 포함하기 전에.</target>
        </trans-unit>
        <trans-unit id="315900bdae1d95768693f5caf49a459c0e9247e8" translate="yes" xml:space="preserve">
          <source>Using this result to index &lt;code&gt;a&lt;/code&gt; is equivalent to using the mask directly:</source>
          <target state="translated">이 결과를 사용하여 &lt;code&gt;a&lt;/code&gt; 를 색인화 하는 것은 마스크를 직접 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1e207983fdf75c13618b12af3dac2cc9b09a86a" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;), will be about</source>
          <target state="translated">이 체계를 사용하면, 유도하는 스트림의 수를 알면 충돌 확률의 상한을 추정 할 수 있습니다. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; 는 기본적으로&lt;/a&gt; 시드와 스폰 트리 경로의 입력을 128 비트 풀로 해시합니다. 비수 적으로 추정 된 풀에 충돌이있을 확률은 약 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81f2b8dfbfc71c96c12b186f5770d7cbd6cb20f2" translate="yes" xml:space="preserve">
          <source>Using tuples. &lt;code&gt;int&lt;/code&gt; is a fixed type, 3 the field&amp;rsquo;s shape. &lt;code&gt;void&lt;/code&gt; is a flexible type, here of size 10:</source>
          <target state="translated">튜플 사용. &lt;code&gt;int&lt;/code&gt; 는 고정 된 유형이며, 3 필드의 모양입니다. &lt;code&gt;void&lt;/code&gt; 는 크기 10의 유연한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ef8b4345a7cc12338d15d1fb67d9e4a4feb23426" translate="yes" xml:space="preserve">
          <source>Usually denoted</source>
          <target state="translated">일반적으로 표시</target>
        </trans-unit>
        <trans-unit id="a5abc30aa6f2b926c1472fe22071db5adb16a0bc" translate="yes" xml:space="preserve">
          <source>Usually, however, adding the &lt;code&gt;tests/&lt;/code&gt; directory to the python path isn&amp;rsquo;t desirable. Instead it would better to invoke the test straight from the module &lt;code&gt;xxx&lt;/code&gt;. To this end, simply place the following lines at the end of your package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; file:</source>
          <target state="translated">그러나 일반적으로 python 경로에 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 추가하는 것은 바람직하지 않습니다. 대신 &lt;code&gt;xxx&lt;/code&gt; 모듈에서 직접 테스트를 호출하는 것이 좋습니다 . 이를 위해 패키지의 &lt;code&gt;__init__.py&lt;/code&gt; 파일 끝에 다음 줄을 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="6be23322b56766a1db9b8621387497e594f16d2d" translate="yes" xml:space="preserve">
          <source>Utility classes and functions for the polynomial modules.</source>
          <target state="translated">다항식 모듈의 유틸리티 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="3522db33c6e586ed6f52f3af3bea08c2509cdaed" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed.</source>
          <target state="translated">마스크 된 배열에 유효하지 않은 항목이 없음을 나타내는 값입니다. 마스크가 필요하지 않은 경우 계산 속도를 높이기 위해 &lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9ec234c1eee91fedfeaba35509216217fe21cd" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;operands&lt;/code&gt; at current iteration. Normally, this is a tuple of array scalars, but if the flag &lt;code&gt;external_loop&lt;/code&gt; is used, it is a tuple of one dimensional arrays.</source>
          <target state="translated">현재 반복에서 &lt;code&gt;operands&lt;/code&gt; 값입니다 . 일반적으로 이것은 배열 스칼라의 튜플이지만 &lt;code&gt;external_loop&lt;/code&gt; 플래그 를 사용하면 1 차원 배열의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d866e0938fcfdf12b88042317593d4295facb33c" translate="yes" xml:space="preserve">
          <source>Value to be placed in field.</source>
          <target state="translated">필드에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4ba37300f6a7d1d653bfd085d1c3e62828c53205" translate="yes" xml:space="preserve">
          <source>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</source>
          <target state="translated">NaN 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 NaN 값이 0.0으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="73822c64a61d90da64aca29978cabf65524aa150" translate="yes" xml:space="preserve">
          <source>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</source>
          <target state="translated">음의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 음의 무한대 값이 매우 작은 (또는 음수) 숫자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f4796b06e4cb3d07bcdfe89591ec37b878b0609f" translate="yes" xml:space="preserve">
          <source>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</source>
          <target state="translated">양의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 양의 무한대 값이 매우 큰 숫자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f7cccdf775f458dbd65351fa14dd9eb110134681" translate="yes" xml:space="preserve">
          <source>Value to be written on the diagonal, its type must be compatible with that of the array a.</source>
          <target state="translated">대각선에 쓰여질 값, 그 타입은 배열의 타입과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="715dcdd8f6ff522d4658e491027e9aae31a8b5e6" translate="yes" xml:space="preserve">
          <source>Value to format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3e32ccc4b0ab4e1f0dc806d286fb59b6c443d6" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt;, default is &lt;code&gt;fp[-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt; 대해 반환 할 값 입니다. 기본값은 &lt;code&gt;fp[-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26d4865cbe90216e1386cb06fe27a2a8a2fdea6f" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt;, default is &lt;code&gt;fp[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt; 대해 리턴 할 값 , 기본값은 &lt;code&gt;fp[0]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7a5e0e3824dade99c632ba9171e408c2ecc5e00" translate="yes" xml:space="preserve">
          <source>Value used for fixing invalid data. Default is None, in which case the &lt;code&gt;a.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">유효하지 않은 데이터를 수정하는 데 사용되는 값입니다. 기본값은 없음이며,이 경우 &lt;code&gt;a.fill_value&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ddc9b73f581b3343b0affbf7e4377d672439b1" translate="yes" xml:space="preserve">
          <source>Value used internally for the masked values. If &lt;code&gt;fill_value&lt;/code&gt; is not None, it supersedes &lt;code&gt;endwith&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값에 내부적으로 사용되는 값입니다. &lt;code&gt;fill_value&lt;/code&gt; 가 None이 아닌 경우 &lt;code&gt;endwith&lt;/code&gt; 로 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="328663db0b3aba67f0d82903937cd9193c3e207c" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</source>
          <target state="translated">필요한 경우 마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 데이터 유형을 기반으로하는 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac07a9705ce80720af8585478b1d81e8b7b8b456" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="86e71cf73f1d7bc170999262699205370f1f93e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;MaskedArray.fill_value&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 기본값은 None이며,이 경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19866b65a013a0eb3c733fc479da8433fc02a5f3" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of maximum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0a58c6eeb18776376a78bc0a9866ce44b1ad27" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of minimum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 minimum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="752e711d9ae184609f9efa220ffeb98e2623ff23" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;code&gt;minimum_fill_value&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 &lt;code&gt;minimum_fill_value&lt;/code&gt; 출력을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94b3fde97e6b1196d461cd6d1087f12e6dea54b2" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of maximum_fill_value().</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value ()의 출력을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eddd55b4550fcb347a1d6bf73a696e1497719104" translate="yes" xml:space="preserve">
          <source>Values are appended to a copy of this array.</source>
          <target state="translated">이 배열의 사본에 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24421420351a973d79bcca3d2ef0e453017e616f" translate="yes" xml:space="preserve">
          <source>Values are generated within the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (in other words, the interval including &lt;code&gt;start&lt;/code&gt; but excluding &lt;code&gt;stop&lt;/code&gt;). For integer arguments the function is equivalent to the Python built-in &lt;code&gt;range&lt;/code&gt; function, but returns an ndarray rather than a list.</source>
          <target state="translated">반 개방 간격 &lt;code&gt;[start, stop)&lt;/code&gt; 내에서 값이 생성됩니다 (즉, &lt;code&gt;start&lt;/code&gt; 를 포함 하지만 &lt;code&gt;stop&lt;/code&gt; 을 제외한 간격 ). 정수 인수의 경우 함수는 Python 내장 &lt;code&gt;range&lt;/code&gt; 함수와 동일하지만 목록이 아닌 ndarray를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="38b38aff8e14ce007107a5b62d7837a43399e916" translate="yes" xml:space="preserve">
          <source>Values at which the weight function will be computed.</source>
          <target state="translated">가중치 함수가 계산 될 값입니다.</target>
        </trans-unit>
        <trans-unit id="8afc1edfb8d26a9a4bac7610a9a2ed43bc17c240" translate="yes" xml:space="preserve">
          <source>Values from which to choose. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt; need to be broadcastable to some shape.</source>
          <target state="translated">선택할 값입니다. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;condition&lt;/code&gt; 은 어떤 형태로도 방송 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="55fd9fa348e62e91b8d05086f74314a1ab640581" translate="yes" xml:space="preserve">
          <source>Values in &lt;code&gt;i&lt;/code&gt; of less than 0 are treated as 0 (which yields an empty string).</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 보다 작은 i 의 값은 0으로 처리됩니다 (빈 문자열이 생성됨).</target>
        </trans-unit>
        <trans-unit id="c0da0f066601a2a9367e697b89519e6b0c50e33e" translate="yes" xml:space="preserve">
          <source>Values to change the sign of.</source>
          <target state="translated">부호를 변경할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4158750ed1844d81234e02100fb4f6a0ce246137" translate="yes" xml:space="preserve">
          <source>Values to find the next representable value of.</source>
          <target state="translated">다음으로 표현 가능한 값을 찾는 값입니다.</target>
        </trans-unit>
        <trans-unit id="beb9a9be5bcba10dec2aa7359c7898f16a9d7ca8" translate="yes" xml:space="preserve">
          <source>Values to find the spacing of.</source>
          <target state="translated">간격을 찾을 값입니다.</target>
        </trans-unit>
        <trans-unit id="3b61fff151ba4cdc5d10abd1dbdd04d94f432686" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값으로 삽입 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19b54e21994fdcbd2ab01d7104b74c970245cfe1" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;arr&lt;/code&gt;. If the type of &lt;code&gt;values&lt;/code&gt; is different from that of &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; is converted to the type of &lt;code&gt;arr&lt;/code&gt;. &lt;code&gt;values&lt;/code&gt; should be shaped so that &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; is legal.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 삽입 할 값 입니다. &lt;code&gt;values&lt;/code&gt; 의 유형이 &lt;code&gt;arr&lt;/code&gt; 과 다른 경우 &lt;code&gt;values&lt;/code&gt; 은 &lt;code&gt;arr&lt;/code&gt; 유형으로 변환됩니다 . &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; 이 유효 하도록 &lt;code&gt;values&lt;/code&gt; 을 형성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="817bf23706b268004f4bf56ee98317c1ad7d150d" translate="yes" xml:space="preserve">
          <source>Values to place in &lt;code&gt;a&lt;/code&gt; at target indices. If &lt;code&gt;v&lt;/code&gt; is shorter than &lt;code&gt;ind&lt;/code&gt; it will be repeated as necessary.</source>
          <target state="translated">값에 배치 대상 인덱스에서. 경우 &lt;code&gt;v&lt;/code&gt; 보다 짧은 &lt;code&gt;ind&lt;/code&gt; 은 필요에 따라 반복됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9be9f0fa346eb48800661efe4c9cdccf0a4d68a" translate="yes" xml:space="preserve">
          <source>Values to place in self._data copy at target indices.</source>
          <target state="translated">대상 인덱스에서 self._data 사본에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="81f73f98efd45554f2765f8a372cd020b7023051" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &amp;ldquo;a&amp;rdquo; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &amp;ldquo;a&amp;rdquo; except along axis.</source>
          <target state="translated">차이를 수행하기 전에 축을 따라 &quot;a&quot;를 추가하거나 추가 할 값입니다. 스칼라 값은 축 방향으로 길이가 1이고 다른 모든 축을 따라 입력 배열의 모양으로 배열로 확장됩니다. 그렇지 않으면 치수와 모양이 축을 제외하고&amp;ldquo;a&amp;rdquo;와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="462c5daaa1bebf27712ab1f9e6dff7991b7d4f2b" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;mask&lt;/code&gt; is True. If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it will be repeated.</source>
          <target state="translated">값에 넣어 곳 &lt;code&gt;mask&lt;/code&gt; True입니다. 경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25e7a819f368d39546137552cf420f108ade4ace" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt;. Only the first N elements are used, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;. If &lt;code&gt;vals&lt;/code&gt; is smaller than N, it will be repeated, and if elements of &lt;code&gt;a&lt;/code&gt; are to be masked, this sequence must be non-empty.</source>
          <target state="translated">값에 넣어 . 첫 번째 N 요소 만 사용되며 여기서 N은 &lt;code&gt;mask&lt;/code&gt; 의 True 값 수입니다 . 경우 &lt;code&gt;vals&lt;/code&gt; N보다 작은 경우는 반복 될 것이고, 요소 경우 &lt;code&gt;a&lt;/code&gt; 마스킹되어야하고,이 시퀀스는 비어 있어야한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bd6b681e5d46e176fd602e7f740408a4b90a97" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix for powers.</source>
          <target state="translated">힘을위한 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="6401e380553d40526975bfbedfb18608ca5c00ad" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="ae6e82d94a52ea695163be06dc24993156d990a5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Hermite series.</source>
          <target state="translated">Hermite 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="a2d6130252c264087c83a0456898053f5cce8c9b" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Legendre series.</source>
          <target state="translated">Legendre 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="5d2bf93649140d94c435a78c84579d541c1303f5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of given degree.</source>
          <target state="translated">주어진 정도의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="315c420145ba2a2de3ef508e657b666b667d7db9" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix. If &lt;code&gt;increasing&lt;/code&gt; is False, the first column is &lt;code&gt;x^(N-1)&lt;/code&gt;, the second &lt;code&gt;x^(N-2)&lt;/code&gt; and so forth. If &lt;code&gt;increasing&lt;/code&gt; is True, the columns are &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt;.</source>
          <target state="translated">밴더 몬드 매트릭스. 경우 &lt;code&gt;increasing&lt;/code&gt; 거짓이고, 첫 번째 열은 &lt;code&gt;x^(N-1)&lt;/code&gt; , 제 &lt;code&gt;x^(N-2)&lt;/code&gt; 등. 경우 &lt;code&gt;increasing&lt;/code&gt; 참이고, 열은 &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7476851367ab64af3bc4c81c52e5e1e6857c25" translate="yes" xml:space="preserve">
          <source>Variables in Numpy which control and describe alignment</source>
          <target state="translated">정렬을 제어하고 설명하는 Numpy의 변수</target>
        </trans-unit>
        <trans-unit id="2a1f6fba473be39ef3c80a51eed0db143c77f764" translate="yes" xml:space="preserve">
          <source>Variance while not ignoring NaNs</source>
          <target state="translated">NaN을 무시하지 않는 동안의 차이</target>
        </trans-unit>
        <trans-unit id="407b9055a29b3862ad6596884f933fb2e3b90801" translate="yes" xml:space="preserve">
          <source>Various windows</source>
          <target state="translated">다양한 창</target>
        </trans-unit>
        <trans-unit id="690a0d6330a132cb4527e3e44d7a2347c9a06b3a" translate="yes" xml:space="preserve">
          <source>Vector cross product(s).</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="28cb052426ac62f08e613cbe9ac7789542c3593f" translate="yes" xml:space="preserve">
          <source>Vector cross-product.</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="0fe94b620577959abe98d342c3396c44b95bc9ac" translate="yes" xml:space="preserve">
          <source>Vector inner and outer products, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;numpy.inner&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;numpy.outer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">벡터 내부 및 외부 제품, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;numpy.inner&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;numpy.outer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc155524d5d2ad1522cc08f2291c52dc38dcecf1" translate="yes" xml:space="preserve">
          <source>Vector inner products:</source>
          <target state="translated">벡터 내부 제품 :</target>
        </trans-unit>
        <trans-unit id="7b8a7176d65340f9da0fa7937d046de8633e6685" translate="yes" xml:space="preserve">
          <source>Vector outer product:</source>
          <target state="translated">벡터 외부 제품 :</target>
        </trans-unit>
        <trans-unit id="acae4c791d04e4455a560ff6e41306cbb57dcf51" translate="yes" xml:space="preserve">
          <source>Vector(s) with the singular values, within each vector sorted in descending order. The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">내림차순으로 정렬 된 각 벡터 내에서 특이 값을 가진 벡터입니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원은 입력 &lt;code&gt;a&lt;/code&gt; 와 크기가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5acfbe842fd0541792480526462188b04dde53" translate="yes" xml:space="preserve">
          <source>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</source>
          <target state="translated">벡터, 벡터는 스칼라 내부 곱을 반환하지만 인수가 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6ec9d2e3c00c48eca40b4ca66a3c4d474b90630" translate="yes" xml:space="preserve">
          <source>Vectorized function.</source>
          <target state="translated">벡터화 기능.</target>
        </trans-unit>
        <trans-unit id="7bfe5238ce1d36e9bfcb089f4f57728d117a113e" translate="yes" xml:space="preserve">
          <source>Verify the mean and the variance:</source>
          <target state="translated">평균과 분산을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="51eea7cbb443c92981917f3f8bfdb384f15a6153" translate="yes" xml:space="preserve">
          <source>Version of this function that preserves the shape of ar1.</source>
          <target state="translated">ar1의 모양을 유지하는이 함수의 버전.</target>
        </trans-unit>
        <trans-unit id="224aeb6086ba7022d83156756ac873c6ff737642" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 달리이 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a21f850c092874207e85425f1992b2d1d4a0daef" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 달리이 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ba00ebd75f3175e23b4f09615b45ef3560ac5818" translate="yes" xml:space="preserve">
          <source>View based and advanced indexing is mixed. In this case the view based indexing defines a collection of subarrays that are combined by the advanced indexing. For example, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; is created by vertically stacking the subarrays &lt;code&gt;arr[1, :]&lt;/code&gt;, &lt;code&gt;arr[2,:]&lt;/code&gt;, and &lt;code&gt;arr[3, :]&lt;/code&gt;.</source>
          <target state="translated">뷰 기반 및 고급 인덱싱이 혼합되어 있습니다. 이 경우 뷰 기반 인덱싱은 고급 인덱싱에 의해 결합 된 하위 배열의 모음을 정의합니다. 예를 들어, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; 는 하위 배열 &lt;code&gt;arr[1, :]&lt;/code&gt; , &lt;code&gt;arr[2,:]&lt;/code&gt; 및 &lt;code&gt;arr[3, :]&lt;/code&gt; 을 세로로 쌓아서 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b2ca30abe686b95f053f55957fa5266ab07dca0a" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least three dimensions.</source>
          <target state="translated">입력을 3 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="45fb889525ea027b940786067638d779d675de17" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least two dimensions.</source>
          <target state="translated">입력 값을 2 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="6e4fbf98b4a2f11308bf6ec449635485ea8cdb89" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased by one.</source>
          <target state="translated">보기 차원의 수는 하나씩 증가. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf2e6fd5608dfcde8e1d428501030442d53386c" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt;, with axes suitably permuted.</source>
          <target state="translated">의보기 축이 적절히 순열과 함께. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="690413363bd8aafde5497bc7e1d13a4d8e5f2372" translate="yes" xml:space="preserve">
          <source>View the array as a record array:</source>
          <target state="translated">배열을 레코드 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="81d42abd80c44b454ac926e28ee7856a84a169a3" translate="yes" xml:space="preserve">
          <source>Viewing array data using a different type and dtype:</source>
          <target state="translated">다른 유형과 dtype을 사용하여 배열 데이터보기 :</target>
        </trans-unit>
        <trans-unit id="59879f373c87da4a2c95c0412230c3555cfc240e" translate="yes" xml:space="preserve">
          <source>Views returned from einsum are now writeable whenever the input array is writeable. For example, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; will now have the same effect as &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; will return a writeable view of the diagonal of a 2D array.</source>
          <target state="translated">입력 배열을 쓸 수있을 때마다 einsum에서 반환 된 뷰를 쓸 수 있습니다. 예를 들어, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; 는 이제 &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 와 동일한 효과를 갖습니다. a) 2D 배열의 대각선에 대한 쓰기 가능한보기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="212733d972db48c77aaab9351402436eae4fd2ff" translate="yes" xml:space="preserve">
          <source>Views share data:</source>
          <target state="translated">조회수는 데이터를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c9d8f3fc365bae8c1e0312cb68b7341a485aec6e" translate="yes" xml:space="preserve">
          <source>Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</source>
          <target state="translated">dtype 크기 (항목 당 바이트 수)를 변경하는 뷰는 일반적으로 슬라이스, 조옮김, 포트 순서 지정 등으로 정의 된 배열에서는 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="3cd2f9e2b1f25c2f5e7b93f7ce911077d7d964a4" translate="yes" xml:space="preserve">
          <source>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery, &amp;ldquo;Numerical Recipes (3rd edition)&amp;rdquo;, Cambridge University Press, 2007, page 795.</source>
          <target state="translated">WH Press, SA Teukolsky, WT Vetterling 및 BP Flannery,&amp;ldquo;Numerical Recipes (3 판)&amp;rdquo;, Cambridge University Press, 2007, 795 페이지.</target>
        </trans-unit>
        <trans-unit id="e9c669c28770b602c0d3307e40af975f3d6ab286" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 425.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986, 425 페이지.</target>
        </trans-unit>
        <trans-unit id="dbd0b2fdf754a4d650097a931842e3ce01d68c23" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 429.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986, 429 페이지.</target>
        </trans-unit>
        <trans-unit id="4d8b44b86ac9762795ccf1eb37bf4871143a380a" translate="yes" xml:space="preserve">
          <source>WRITEABLE (W) the data area can be written to;</source>
          <target state="translated">쓰기 가능 (W) 데이터 영역에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dcab075be566e2b98d550a936f8cae5ce9422f" translate="yes" xml:space="preserve">
          <source>WRITEABLE / W</source>
          <target state="translated">쓰기 가능 / W</target>
        </trans-unit>
        <trans-unit id="73fb58e7589a9ff67f327a9e1cfb0abcae369bb5" translate="yes" xml:space="preserve">
          <source>WRITEABLE can only be set &lt;code&gt;True&lt;/code&gt; if the array owns its own memory or the ultimate owner of the memory exposes a writeable buffer interface or is a string.</source>
          <target state="translated">WRITEABLE은 어레이가 자체 메모리를 소유하거나 메모리의 최종 소유자가 쓰기 가능한 버퍼 인터페이스를 노출하거나 문자열 인 경우 에만 &lt;code&gt;True&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ca2fe3e818dba5a5804a5bb3a831dd89c500d7a" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array.</source>
          <target state="translated">WRITEBACKIFCOPY (X)이 배열은 다른 배열 (.base로 참조)의 복사본입니다. C-API 함수 PyArray_ResolveWritebackIfCopy가 호출되면 기본 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="3b243b9b37eb143e3a1ec8091e9c80e424b7cb17" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY / X</source>
          <target state="translated">WRITEBACKIFCOPY / X</target>
        </trans-unit>
        <trans-unit id="09fcb82609179c1f7885c137f520c527fdcb1905" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">WRITEBACKIFCOPY는 &lt;code&gt;False&lt;/code&gt; 로만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd7081253d772e7a32e41421d2cdf6a9cabced2" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, &amp;ldquo;A Statistical Distribution Function of Wide Applicability&amp;rdquo;, Journal Of Applied Mechanics ASME Paper 1951.</source>
          <target state="translated">Waloddi Weibull,&amp;ldquo;광범위한 응용 성의 통계 분포 함수&amp;rdquo;, 응용 역학 저널 ASME 논문 1951.</target>
        </trans-unit>
        <trans-unit id="db8ff1d3b42b8d1fe40e88e8148de81cccee175c" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, Royal Technical University, Stockholm, 1939 &amp;ldquo;A Statistical Theory Of The Strength Of Materials&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</source>
          <target state="translated">1939 년 스톡홀름 왕립 기술 대학교 Waloddi Weibull,&amp;ldquo;재료의 강도에 관한 통계 이론&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="4754f4fe525f9c37d19fda1322550a0b26e13158" translate="yes" xml:space="preserve">
          <source>Warning class to filter</source>
          <target state="translated">필터링 할 경고 클래스</target>
        </trans-unit>
        <trans-unit id="f88a191846138392ad4758d4ff77a36f017f6d00" translate="yes" xml:space="preserve">
          <source>Warning objects</source>
          <target state="translated">경고 객체</target>
        </trans-unit>
        <trans-unit id="37361059464af82221d16eb1a2018e9694f9cd57" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and is not a datatype description compatible with &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">경고 :이 속성은 &lt;code&gt;__array_interface__&lt;/code&gt; 전용으로 존재하며 np.dtype 과 호환되는 데이터 유형 설명이 &lt;code&gt;np.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67f63aaa6eb093a2b8631aeb7aa1f1f56dd3fc86" translate="yes" xml:space="preserve">
          <source>Warning: This functionality does &lt;strong&gt;not&lt;/strong&gt; consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from &lt;code&gt;a&lt;/code&gt; as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</source>
          <target state="translated">경고 :이 기능은 축을 개별적으로 고려 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 즉 보간 / 외삽 법이 적용되지 않습니다. 그것은 보폭과 축을 무시하고 메모리에 배치 된 &lt;code&gt;a&lt;/code&gt; 에서 가져온 필요한 수의 요소로 반환 배열을 채 웁니다 . (이것은 새로운 모양이 더 작은 경우에 해당됩니다. 더 큰 것은 위를 참조하십시오.) 따라서이 기능은 이미지 또는 각 축이 별개의 개별 엔티티를 나타내는 데이터의 크기를 조정하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="6fcbb55cbf3a317fd9e559a46404d4ffc0901e5d" translate="yes" xml:space="preserve">
          <source>Warns:</source>
          <target state="translated">Warns:</target>
        </trans-unit>
        <trans-unit id="2877e71e929aa29b0e79a512d385261189d70371" translate="yes" xml:space="preserve">
          <source>Wave heights tend to follow a Rayleigh distribution. If the mean wave height is 1 meter, what fraction of waves are likely to be larger than 3 meters?</source>
          <target state="translated">파도 높이는 레일리 분포를 따르는 경향이 있습니다. 평균 파고가 1 미터 인 경우 파동의 3 분의 1보다 큰 파편은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d199611fe572f9a604421aeb87fed868192644af" translate="yes" xml:space="preserve">
          <source>We can begin with a chain dot example. In this case, it is optimal to contract the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; tensors first as represented by the first element of the path &lt;code&gt;(1, 2)&lt;/code&gt;. The resulting tensor is added to the end of the contraction and the remaining contraction &lt;code&gt;(0, 1)&lt;/code&gt; is then completed.</source>
          <target state="translated">우리는 체인 도트 예제로 시작할 수 있습니다. 이 경우 경로의 첫 번째 요소 &lt;code&gt;(1, 2)&lt;/code&gt; 로 표시되는대로 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 텐서를 먼저 수축시키는 것이 가장 좋습니다. 결과 텐서가 수축의 끝에 추가되고 나머지 수축 &lt;code&gt;(0, 1)&lt;/code&gt; 이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="66a6a3c1aa8ab5615ae93578f83c6c2bc137c427" translate="yes" xml:space="preserve">
          <source>We can now compute the mean of the dataset, without taking the invalid data into account:</source>
          <target state="translated">이제 유효하지 않은 데이터를 고려하지 않고 데이터 세트의 평균을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07dfd0de116a4118d2e8d7ab1e0ba4c4055ce110" translate="yes" xml:space="preserve">
          <source>We can replace the maximum values with:</source>
          <target state="translated">최대 값을 다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a512625d0cb7e17ddcfbaaf190c6f0c94959ed" translate="yes" xml:space="preserve">
          <source>We can reset the function to the default:</source>
          <target state="translated">기능을 기본값으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b52b8758d686451191a4e1193e567d392d717d53" translate="yes" xml:space="preserve">
          <source>We can rewrite the line equation as &lt;code&gt;y = Ap&lt;/code&gt;, where &lt;code&gt;A = [[x 1]]&lt;/code&gt; and &lt;code&gt;p = [[m], [c]]&lt;/code&gt;. Now use &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt; to solve for &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">선 방정식을 &lt;code&gt;y = Ap&lt;/code&gt; 로 다시 작성할 수 있습니다 . 여기서 &lt;code&gt;A = [[x 1]]&lt;/code&gt; 및 &lt;code&gt;p = [[m], [c]]&lt;/code&gt; 입니다. 이제 &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;p&lt;/code&gt; 를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcf794d24d8964269b87153ebb1affba96ff631d" translate="yes" xml:space="preserve">
          <source>We can sort either by using sort directly, or argsort and this function</source>
          <target state="translated">sort를 직접 사용하거나 argsort와이 함수를 사용하여 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23502bd41157dbb482cc4d93fe154b6f35759b68" translate="yes" xml:space="preserve">
          <source>We can verify this, approximating the derivative with &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt;:</source>
          <target state="translated">우리는 이것을 &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt; 근사값을 근사화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edbc1babc558648a370766b66d6bf09ff4d2327" translate="yes" xml:space="preserve">
          <source>We chose our default threshold because it is in wide use. Other thresholds are possible. For example, elsewhere in the 2007 edition of &lt;em&gt;Numerical recipes&lt;/em&gt; there is an alternative threshold of &lt;code&gt;S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt;. The authors describe this threshold as being based on &amp;ldquo;expected roundoff error&amp;rdquo; (p 71).</source>
          <target state="translated">기본 임계 값은 널리 사용되므로 기본 임계 값을 선택했습니다. 다른 임계 값도 가능합니다. 예를 들어, 2007 년판 &lt;em&gt;수치 레시피&lt;/em&gt; 의 다른 곳에 는 &lt;code&gt;S.max() * np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt; 의 대체 임계 값이 있습니다 . * np.sqrt (m + n + 1) . 저자는이 임계 값을 &quot;예상 반올림 오류&quot;(p 71)에 기반한 것으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d8ba993fff071da05f22748cefa6f6b8ad24e53b" translate="yes" xml:space="preserve">
          <source>We could have implemented:</source>
          <target state="translated">우리는 다음을 구현할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="59bec2d1c76c534a2fc4afd9318e87ce91e937b9" translate="yes" xml:space="preserve">
          <source>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</source>
          <target state="translated">기본적으로 OS에서 수집 한 엔트로피를 사용하여 128 비트 정수를 사용합니다. 이것은 우리가 numpy에있는 모든 생성기를 초기화하기에 좋은 양의 엔트로피입니다. 일반적으로 32 비트 미만의 작은 시드를 사용하지 않는 것이 좋습니다. 더 큰 상태 공간을 인스턴스화하기 위해 작은 시드 세트 만 사용하면 도달 할 수없는 초기 상태가 있음을 의미합니다. 모든 사람이 그러한 가치를 사용한다면 이것은 약간의 편견을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6c39690106b67e736bf72e53ea7082db75a8ca14" translate="yes" xml:space="preserve">
          <source>We expect the arccos of 1 to be 0, and of -1 to be pi:</source>
          <target state="translated">우리는 1의 arccos가 0이고 -1의 pi가 pi 일 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="44f2a9cfd92075d83d3f564752917c6115d7836b" translate="yes" xml:space="preserve">
          <source>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</source>
          <target state="translated">우리는 arctan 0은 0, 1은 pi / 4가 될 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="60136b35f0997a97a43dcb76040b0f18f3536c81" translate="yes" xml:space="preserve">
          <source>We have 10 degrees of freedom, so is the sample mean within 95% of the recommended value?</source>
          <target state="translated">우리는 10 자유도를 가지고 있으므로 표본 평균이 권장 값의 95 % 이내입니까?</target>
        </trans-unit>
        <trans-unit id="3e23f0ad561893af23edd41efd72f4bd368c5b95" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리는 numpy 함수를 (일반화 된) Ufunc로 다시 구현하려고합니다.이 경우 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메소드 로 대체 될 수 있습니다 . 주요 후보는 &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; 이며, 현재 Ufunc는 아니지만 일반화 된 Ufuncs로 비교적 쉽게 다시 작성할 수 있습니다. &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 와 같은 함수에서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="b3cf3455d01dd7db3c5c070359dd30cf5e39de43" translate="yes" xml:space="preserve">
          <source>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</source>
          <target state="translated">우리는이 동작이 체계적이지 않을 수도 있고, 마스킹 된 데이터가 경우에 따라 작업의 영향을받을 수 있으므로 사용자는이 데이터가 변경되지 않은 상태로 남아 있으면 안된다고 강조해야합니다.</target>
        </trans-unit>
        <trans-unit id="58ff07099c06b392c411860c04ae360c63b97582" translate="yes" xml:space="preserve">
          <source>We only show a few blocks for clarity:</source>
          <target state="translated">명확성을 위해 몇 가지 블록 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="673c3f49f8ee0b4069fb17ea81837a33f48d70f3" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt;&lt;code&gt;isin&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#numpy.in1d&quot;&gt;&lt;code&gt;in1d&lt;/code&gt;&lt;/a&gt; for new code.</source>
          <target state="translated">새 코드 에는 &lt;a href=&quot;#numpy.in1d&quot;&gt; &lt;code&gt;in1d&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt; &lt;code&gt;isin&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7ca33c6b93a76db017c3cdc61675ace9bc2b416c" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt; extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt;.</source>
          <target state="translated">이 형식으로 저장된 파일 에는 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 확장자를 사용하는 것이 좋습니다 . 이것은 결코 요구 사항이 아닙니다. 응용 프로그램은 이러한 파일 형식을 사용하지만 응용 프로그램에 맞는 확장명을 사용할 수 있습니다. 그러나 확실한 대안이 없으면 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="33c0514953dd33becf83ed3bc37cb8f06826d505" translate="yes" xml:space="preserve">
          <source>We then define a new test case class for each supported data type with a short definition such as:</source>
          <target state="translated">그런 다음 지원되는 각 데이터 유형에 대해 새로운 테스트 케이스 클래스를 다음과 같이 짧은 정의로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ad180c1380373588b422b6f9367e1dfa995335a7" translate="yes" xml:space="preserve">
          <source>We use the algorithm published by Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and referenced by Abramowitz and Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</source>
          <target state="translated">Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]에서 공개&lt;/a&gt; 하고 Abramowitz 및 Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; 에서 참조한 알고리즘을 사용합니다. 여기서 기능 도메인은 [0,8] 및 (8, inf)의 두 간격으로 분할되며 Chebyshev 다항식 확장이 사용됩니다. 각 간격. IEEE 산술을 사용하는 도메인 [0,30]의 상대 오류 는 1.4e-16의 rms (n = 30000)로 5.8e-16의 피크를 갖는 것으로 문서화되어 있습니다 &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9afbb264decb0b7e5bd769fa476b27d49621056" translate="yes" xml:space="preserve">
          <source>We will deal with the domain and window when we get to fitting, for the moment we ignore them and run through the basic algebraic and arithmetic operations.</source>
          <target state="translated">우리는 우리가 적합 할 때 도메인과 창을 다룰 것입니다. 우리는 그것들을 무시하고 기본 대수 및 산술 연산을 수행하는 순간입니다.</target>
        </trans-unit>
        <trans-unit id="82a72786c4fe5d6bfb5f753a25b0cbc3ef629d6d" translate="yes" xml:space="preserve">
          <source>We wish to mark the fourth entry as invalid. The easiest is to create a masked array:</source>
          <target state="translated">네 번째 항목을 유효하지 않은 것으로 표시하려고합니다. 가장 쉬운 방법은 마스크 배열을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2678a6cb2f01328bc5e5792424e05e77b5265e7c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll do a simple outer product, placing the dimensions of the first operand before the dimensions of the second operand. The &lt;code&gt;op_axes&lt;/code&gt; parameter needs one list of axes for each operand, and provides a mapping from the iterator&amp;rsquo;s axes to the axes of the operand.</source>
          <target state="translated">첫 번째 피연산자의 치수를 두 번째 피연산자의 치수 앞에 배치하여 간단한 외부 곱을 수행합니다. &lt;code&gt;op_axes&lt;/code&gt; 의 매개 변수는 각 피연산자에 축 하나 개의 목록을 필요로하고, 피연산자의 축에 반복자의 축에서의 매핑을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ced2186a63444cfbd458cebaed4de6214b500394" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show how this works by creating a function &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt;&lt;code&gt;square&lt;/code&gt;&lt;/a&gt; which squares its input. Let&amp;rsquo;s start with a minimal function definition excluding &amp;lsquo;out&amp;rsquo; parameter support.</source>
          <target state="translated">입력을 제곱 하는 함수 &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt; &lt;code&gt;square&lt;/code&gt; &lt;/a&gt; 을 만들어서 이것이 어떻게 작동하는지 보여 드리겠습니다 . 'out'매개 변수 지원을 제외한 최소 함수 정의부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d014927573cadb3b0b374c9809c25adaa8d709f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. The invert or bit-wise NOT of 13 is then:</source>
          <target state="translated">13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시되는 것을 보았습니다 . 13의 반전 또는 비트 NOT은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f5117721c82b02552e432ea3720cde40d7059ad" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite polynomials.</source>
          <target state="translated">은자 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="95800a204e1bbd4903f4870d8343853257206077" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite_e polynomials.</source>
          <target state="translated">Hermite_e 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="5f860b19432a865263496fdce430b1e33571bfe5" translate="yes" xml:space="preserve">
          <source>Weight function of the Laguerre polynomials.</source>
          <target state="translated">Laguerre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="79be08f88c623301ce3bc873b7c9affda9625a90" translate="yes" xml:space="preserve">
          <source>Weight function of the Legendre polynomials.</source>
          <target state="translated">Legendre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="c74e4e7c5caf95682fb65872b5814741f06c7fac" translate="yes" xml:space="preserve">
          <source>Weighted average</source>
          <target state="translated">가중 평균</target>
        </trans-unit>
        <trans-unit id="d8f6b85e664320ad22c47352d13059c9a94e57ff" translate="yes" xml:space="preserve">
          <source>Weighted average.</source>
          <target state="translated">가중 평균.</target>
        </trans-unit>
        <trans-unit id="50616113e0953b16858a840423f52798108ba636" translate="yes" xml:space="preserve">
          <source>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</source>
          <target state="translated">샘플 포인트의 y 좌표에 적용 할 가중치입니다. 가우스 불확실성의 경우 1 / 시그마 (1 / 시그마 ** 2 아님)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7070233023bbad210855f921220f6a37969ec7" translate="yes" xml:space="preserve">
          <source>Weights, array of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가중치는 &lt;code&gt;x&lt;/code&gt; 와 동일한 모양의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="946476c654c11a5e92f8b55850bb98a1263ad96b" translate="yes" xml:space="preserve">
          <source>Weights. If not None the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. 그렇지 않으면 적합치에 대한 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 기여도 에 &lt;code&gt;w[i]&lt;/code&gt; 가중됩니다 . 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="1c25ee55e973a0ac3876804d2f28cc0929f53254" translate="yes" xml:space="preserve">
          <source>Weights. If not None, the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. None이 아닌 경우, 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 적합치에 대한 가중치는 &lt;code&gt;w[i]&lt;/code&gt; 가중됩니다 . 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="890907bf4b6e9a3c2721945116f4521c292ba997" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;이분 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44532eacfd8a477fb8d811692e1a730faf373cda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Cauchy Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Cauchy Distribution.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6b4d0490f5c6c29f7bd660e93014a010601e88" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Gamma Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;감마 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="250b4512032938435df06c099254026086b0b46d" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Hypergeometric Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;고도 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403ee22c6c9f5dfb6128b5015952af83dc7fe1f5" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Laplace Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;라플라스 배포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c85ee5175b40c6661962e1c4dcdc7232b8e5568a" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Logistic Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;물류 유통&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1938577c4f79d7fadb65a22f0b9b9cba0e6904e" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Negative Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;음 이항 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed9cdcffdd5a34db501b8269560f163da34bcfda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Noncentral F-Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;비 중앙 F- 분포.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6786c23a16b57cae22a2a2fe8c5eef583bfac0cc" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Poisson Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;포아송 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1415ce102e6420c0e0f61ef322d348a5f507" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Sinc Function.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Sinc Function.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fef717821661f9806ec19067704e1d37a6e1a47" translate="yes" xml:space="preserve">
          <source>What are the least-squares-best &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;y0&lt;/code&gt; in &lt;code&gt;y = y0 + mx&lt;/code&gt; for the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points and you&amp;rsquo;ll see that it should be y0 = 0, m = 1.) The answer is provided by solving the over-determined matrix equation &lt;code&gt;Ax = b&lt;/code&gt;, where:</source>
          <target state="translated">{(0,1), (1,0), (1,2), (2,1)} 데이터에 대해 &lt;code&gt;y = y0 + mx&lt;/code&gt; 에서 최소 제곱이 가장 좋은 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;y0&lt;/code&gt; 은 무엇입니까? (점을 그래프로 표시하면 y0 = 0, m = 1이어야 함을 알 수 있습니다.) 대답은 과도하게 결정된 행렬 방정식 &lt;code&gt;Ax = b&lt;/code&gt; 를 해결하여 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e9b892da0c44e54a5a3d94ba212b74404ec1950" translate="yes" xml:space="preserve">
          <source>What can be converted to a data-type object is described below:</source>
          <target state="translated">데이터 형식 개체로 변환 할 수있는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f1eadc1a60d1383bbd27a5874b7f7b346ec84b4" translate="yes" xml:space="preserve">
          <source>What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than &amp;lsquo;latin1&amp;rsquo;, &amp;lsquo;ASCII&amp;rsquo;, and &amp;lsquo;bytes&amp;rsquo; are not allowed, as they can corrupt numerical data. Default: &amp;lsquo;ASCII&amp;rsquo;</source>
          <target state="translated">Python 2 문자열을 읽을 때 사용할 인코딩 Python 3에서 객체 배열을 포함하는 npy / npz 파일을 포함하는 Python 2 생성 된 절인 파일을로드 할 때만 유용합니다. 'latin1', 'ASCII'및 'bytes'이외의 값은 숫자 데이터를 손상시킬 수 있으므로 허용되지 않습니다. 기본값 : 'ASCII'</target>
        </trans-unit>
        <trans-unit id="1e1fa581e9e916507b4446a529a092d8e86437db" translate="yes" xml:space="preserve">
          <source>What is a masked array?</source>
          <target state="translated">마스크 배열이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="437c59796bebb67cae1bb453196d12e5dabd418f" translate="yes" xml:space="preserve">
          <source>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</source>
          <target state="translated">비교되는 것은 유형이 아니라 값입니다. 따라서 int (1)과 길이가 1 인 배열은 True로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5c56f4637ad63b06ae7f91c4fda9c76b610d6b" translate="yes" xml:space="preserve">
          <source>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</source>
          <target state="translated">테스트 된 것은 입력 유형이 복잡한 경우가 아니라 입력에 0이 아닌 허수 부분이 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="010a5d0834f679e03164332d6d50425424fc97f8" translate="yes" xml:space="preserve">
          <source>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</source>
          <target state="translated">매월 복리로 지급되는 연간 8.24 %의 이자율로 $ 2500의 1 년 대출 상환 일정은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="59aacf2a72313a7cde0de3da40cb764e30627fa7" translate="yes" xml:space="preserve">
          <source>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</source>
          <target state="translated">10 년 동안 $ 100를 절약 한 후의 미래 가치는 $ 100의 추가 월간 절약입니다. 이자율이 매월 5 % (연간) 복리라고 가정합니까?</target>
        </trans-unit>
        <trans-unit id="68f86a620521000717f405763a7c2c87aeacd919" translate="yes" xml:space="preserve">
          <source>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</source>
          <target state="translated">15 년 동안 연간 7.5 %의 이자율로 20 만 달러의 대출을 상환하는 데 필요한 월별 지불금은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="bd55b3638089456ad2fcd33f8ddb002a9ff2afef" translate="yes" xml:space="preserve">
          <source>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</source>
          <target state="translated">매월 $ 100를 절약 한 10 년 후 총 $ 15692.93이 필요한 투자의 현재 가치 (예 : 초기 투자)는 얼마입니까? 이자율이 매월 5 % (연간) 복리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="80bbcabaec75450b003887ef27bbf523c85b5a9f" translate="yes" xml:space="preserve">
          <source>What is the right way to index multi-dimensional arrays? Before you jump to conclusions about the one and true way to index multi-dimensional arrays, it pays to understand why this is a confusing issue. This section will try to explain in detail how numpy indexing works and why we adopt the convention we do for images, and when it may be appropriate to adopt other conventions.</source>
          <target state="translated">다차원 배열을 인덱싱하는 올바른 방법은 무엇입니까? 다차원 배열을 인덱싱하는 하나의 진정한 방법에 대한 결론으로 ​​넘어 가기 전에 이것이 왜 혼란스러운 문제인지 이해해야합니다. 이 섹션에서는 numpy 인덱싱 작동 방식과 이미지에 대한 규칙을 채택하는 이유 및 다른 규칙을 채택하는 것이 적절한시기에 대해 자세히 설명하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0bd771107f7afe976fc592b463f0e0c3505ed432" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="9f2949fbd884fd2e87977bc6442d7541c249e9bc" translate="yes" xml:space="preserve">
          <source>What’s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="7c1df74199c25c42832661082d6ca6ac9e56b175" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, 2 부 : 다시 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ? wg_abbrev = office-formulaOpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="030c83d2119f52206dbf3733046b420a1749a0e1" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, 2 부 : 다시 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="28b30ef805c7fb044e119b47e7ac08078b5b70cf" translate="yes" xml:space="preserve">
          <source>When &amp;lsquo;decimals&amp;rsquo; is negative, it specifies the number of positions to the left of the decimal point. The real and imaginary parts of complex numbers are rounded separately. Nothing is done if the array is not of float type and &amp;lsquo;decimals&amp;rsquo; is greater than or equal to 0.</source>
          <target state="translated">'소수'가 음수이면 소수점 왼쪽의 위치 수를 지정합니다. 복소수의 실수 부와 허수 부는 따로 반올림됩니다. 배열이 부동 유형이 아니고 '소수'가 0보다 크거나 같으면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f209cff1399437b00b7cd0ee8730d177efc65293" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is specified, the typical inner loop construct is as follows.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 가&lt;/a&gt; 지정되면, 전형적인 내부 루프 구조는 다음이다.</target>
        </trans-unit>
        <trans-unit id="e3bd2b595c2ff9c9cbf3b48defe560bc708bb864" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt; 이 호출 될 때</target>
        </trans-unit>
        <trans-unit id="0d17005044d622bf07127624dd5d1775dbe22cd5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not a valid dtype for a structured array.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 구조화 된 배열에 대한 유효 DTYPE 아니다.</target>
        </trans-unit>
        <trans-unit id="105e60976ea8fbfb90203db8ab4a0a320369170d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A = rfft(a)&lt;/code&gt; and fs is the sampling frequency, &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</source>
          <target state="translated">경우 &lt;code&gt;A = rfft(a)&lt;/code&gt; 및 FS 샘플링 주파수이며, &lt;code&gt;A[0]&lt;/code&gt; 에르 미트 대칭으로 인한 진짜 제로 주파수 용어 0 * FS 함유한다.</target>
        </trans-unit>
        <trans-unit id="fb065328be54e2c3569cb5f58bbc8287bcb1fb7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; is called, the array pointed to by base will be updated with the contents of this array.</source>
          <target state="translated">&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 가 호출 되면 base 가 가리키는 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6087c2287fac970fe48c994c66e9668908c28aae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a = 1&lt;/code&gt;, the Weibull distribution reduces to the exponential distribution.</source>
          <target state="translated">경우 &lt;code&gt;a = 1&lt;/code&gt; ,와 이블 분포는 지수 분포를 감소시킨다.</target>
        </trans-unit>
        <trans-unit id="3234eec63d682a68b39f821bda537d5249018389" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a 2D array, it is factorized as &lt;code&gt;u @ np.diag(s) @ vh
= (u * s) @ vh&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; are 2D unitary arrays and &lt;code&gt;s&lt;/code&gt; is a 1D array of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s singular values. When &lt;code&gt;a&lt;/code&gt; is higher-dimensional, SVD is applied in stacked mode as explained below.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 2 차원 어레이가로 인수 분해된다 &lt;code&gt;u @ np.diag(s) @ vh = (u * s) @ vh&lt;/code&gt; 여기서 &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;vh&lt;/code&gt; 2D 단일 배열하고 &lt;code&gt;s&lt;/code&gt; 의 1 차원 배열 의 특이 값 . &lt;code&gt;a&lt;/code&gt; 가 더 높은 차원 일 때 , SVD는 아래 설명 된 바와 같이 스택 모드로 적용됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40bcbe29998f385e3a1059191be0f61338a8c763" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a structured array, this argument specifies which fields to compare first, second, and so on. This list does not need to include all of the fields.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 구조적 배열 필드 인수 지정이 먼저 제 등과 비교한다. 이 목록은 모든 필드를 포함 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c171b92b4bddf9c8ebd2e75ee317f0b5fe3e94eb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정 될 필요는 없지만, 불특정 필드 여전히에서 사용될 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="78f75090c501ced3a2b9ede8c30345a037a7c202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정되어야하지만, 불특정 필드가 여전히 사용될 것이다 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="2cd3e98c67109375f859806b9beef061a4ef694a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string. Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수있다. 모든 필드를 지정할 필요는 없지만 지정되지 않은 필드는 dtype에 나타난 순서대로 계속 사용되어 관계를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="b2ce72a40e12e2d7dda3e8c60930788493a39d27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 모든 필드가 지정 될 필요가없는 등의 초 먼저 비교한다.</target>
        </trans-unit>
        <trans-unit id="d9212747ec3985b5dbc30be906a85b9cd4a58814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axes&lt;/code&gt; is integer_like, the sequence for evaluation will be: first the -Nth axis in &lt;code&gt;a&lt;/code&gt; and 0th axis in &lt;code&gt;b&lt;/code&gt;, and the -1th axis in &lt;code&gt;a&lt;/code&gt; and Nth axis in &lt;code&gt;b&lt;/code&gt; last.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 처음에 -Nth 축 : integer_like이며, 평가 용 시퀀스 것이다 및 0 차의 축 &lt;code&gt;b&lt;/code&gt; 과의 축 -1th 및 제 N은 축에 &lt;code&gt;b&lt;/code&gt; 마지막. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e5c01c245527cc066079729775f892bf5a93e0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axis&lt;/code&gt; is specified, &lt;code&gt;values&lt;/code&gt; must have the correct shape.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 지정되고, &lt;code&gt;values&lt;/code&gt; 올바른 모양을 가지고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a3f207a74aef7083c1eb02bef5c64216a30b6fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt; contain masked values.</source>
          <target state="translated">때 &lt;code&gt;condition&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 는 마스크 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3581744e88f263225956bbed713e5c867c6bf74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;copy=False&lt;/code&gt; and a copy is made for other reasons, the result is the same as if &lt;code&gt;copy=True&lt;/code&gt;, with some exceptions for &lt;code&gt;A&lt;/code&gt;, see the Notes section. The default order is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">때 &lt;code&gt;copy=False&lt;/code&gt; 및 사본이 다른 이유로 만들어진 것처럼, 결과는 동일 &lt;code&gt;copy=True&lt;/code&gt; , 일부의 예외를 제외하고 , 노트 섹션을 참조하십시오. 기본 순서는 'K'입니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ae66e35c85b2fe34abaa8efd6e58beb3b3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 or when an inappropriate &lt;code&gt;size&lt;/code&gt; (e.g. &lt;code&gt;size=-1&lt;/code&gt;) is given.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 인 경우, 부적절한 &lt;code&gt;size&lt;/code&gt; (예 : &lt;code&gt;size=-1&lt;/code&gt; ) 주어진다.</target>
        </trans-unit>
        <trans-unit id="6647686e555ae4abe6c033723e872acfb1bd3153" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; independent random variables, each with standard normal distributions (mean 0, variance 1), are squared and summed, the resulting distribution is chi-square (see Notes). This distribution is often used in hypothesis testing.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; 표준 정규 분포와 독립된 확률 변수 각 (평균 0, 분산 1)를 제곱하여 합산되며, 결과적인 분포는 (주 참조) 치 정사각형이다. 이 분포는 종종 가설 검정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb0cfba1c0d31cbfd6e3e6d57d32a4b67d07be0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition.</source>
          <target state="translated">때 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; , 값 &lt;code&gt;low&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; , 결과가 공식적으로 정의되지 않은되고 결국 오류가 발생 할 수있다, 즉 불평등 조건을 만족 인수를 통과 할 때 작동하는이 기능에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9aa8b45107567c376fa7741eff97cb12f0255ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;normed&lt;/code&gt; is True, then the returned histogram is the sample density, defined such that the sum over bins of the product &lt;code&gt;bin_value * bin_area&lt;/code&gt; is 1.</source>
          <target state="translated">경우 &lt;code&gt;normed&lt;/code&gt; 참이된다 후 리턴 히스토그램은 제품의 빈들을 통해 합되도록 정의 샘플 밀도이다 &lt;code&gt;bin_value * bin_area&lt;/code&gt; 1이다.</target>
        </trans-unit>
        <trans-unit id="d3c1a253c347320a48abee4b8144700cbe11dedb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;op[i]&lt;/code&gt; is NULL, the requested data type &lt;code&gt;op_dtypes[i]&lt;/code&gt; may be NULL as well, in which case it is automatically generated from the dtypes of the arrays which are flagged as readable. The rules for generating the dtype are the same is for UFuncs. Of special note is handling of byte order in the selected dtype. If there is exactly one input, the input&amp;rsquo;s dtype is used as is. Otherwise, if more than one input dtypes are combined together, the output will be in native byte order.</source>
          <target state="translated">경우 &lt;code&gt;op[i]&lt;/code&gt; NULL 인, 요청 된 데이터 타입 &lt;code&gt;op_dtypes[i]&lt;/code&gt; 그것이 자동적으로 판독하는 플래그 배열의 dtypes로부터 발생되는 경우뿐만 아니라 NULL 일 수있다. dtype을 생성하는 규칙은 UFunc와 동일합니다. 선택된 dtype에서 바이트 순서를 처리하는 것이 특히 중요합니다. 정확히 하나의 입력이 있으면 입력의 dtype이 그대로 사용됩니다. 그렇지 않으면, 둘 이상의 입력 dtype이 함께 결합되면 출력은 기본 바이트 순서가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2b29bdbe08a7c3e8ddf1683de5150728b2dbef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;A&amp;rsquo;, it will preserve the array&amp;rsquo;s &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo; ordering:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'A', 그것은 배열의 'C'또는 'F'순서를 유지한다 :</target>
        </trans-unit>
        <trans-unit id="6b8f346f1161f4e387f8b7fce9c3c4eab735e268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;K&amp;rsquo;, it will preserve orderings that are neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo;, but won&amp;rsquo;t reverse axes:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'K', 그것은 어느 쪽도 'C'나 'F'없는 순서 부를 유지하지만 것입니다하지 않습니다 반대 축 :</target>
        </trans-unit>
        <trans-unit id="08a648e9a0d7c320ff7a951bdd5b53abf89293b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p&lt;/code&gt; cannot be converted to a rank-1 array.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 랭크 1 배열로 변환 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="e45ca1a69513367d482121e776e438a0bc2c1c76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;path&lt;/code&gt; is an URL, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; will return True if it&amp;rsquo;s either stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory, or is a valid remote URL. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; does not discriminate between the two, the file is accessible if it exists in either location.</source>
          <target state="translated">때 &lt;code&gt;path&lt;/code&gt; URL이, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 가 중 하나에 로컬로 저장되어있는 경우 True를 반환합니다 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리, 또는 유효한 원격 URL입니다. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 는이 둘을 구별하지 않으며 파일이 어느 위치에 있는지 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d6d2d2a499c808880c721a0e1b19db64d43932" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;seed&lt;/code&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, a new &lt;code&gt;BitGenerator&lt;/code&gt; and &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; will be instantiated each time. This function does not manage a default global instance.</source>
          <target state="translated">시 &lt;code&gt;seed&lt;/code&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 새로운 &lt;code&gt;BitGenerator&lt;/code&gt; 및 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 마다 인스턴스화됩니다. 이 기능은 기본 전역 인스턴스를 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="548ec80d9148e8694deef2af35ec844cd9f8fe80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;writemasked&lt;/code&gt; flag is used, and this operand is buffered, this changes how data is copied from the buffer into the array. A masked copying routine is used, which only copies the elements in the buffer for which &lt;code&gt;writemasked&lt;/code&gt; returns true from the corresponding element in the ARRAYMASK operand.</source>
          <target state="translated">경우 &lt;code&gt;writemasked&lt;/code&gt; 플래그가 사용되며,이 피연산자는, 데이터가 어레이로 상기 버퍼로 복사하는 방법이 변화를 완충한다. ARRAYMASK 피연산자의 해당 요소에서 &lt;code&gt;writemasked&lt;/code&gt; 가 true를 리턴 하는 버퍼의 요소 만 복사하는 마스크 된 복사 루틴이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e06542a52ac6a1f85d560afb9efd573db44bd48f" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, the result order is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;prototype&lt;/em&gt; is a fortran array, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt; otherwise. When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the result order matches that of &lt;em&gt;prototype&lt;/em&gt;, even when the axes of &lt;em&gt;prototype&lt;/em&gt; aren&amp;rsquo;t in C or Fortran order.</source>
          <target state="translated">되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 이&lt;/a&gt; 결과 순서는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;시제품&lt;/em&gt; 포트란 배열이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; 그렇지. 되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 결과 순서가 일치의 &lt;em&gt;원형&lt;/em&gt; 의 축 때에도 &lt;em&gt;프로토 타입&lt;/em&gt; C 또는 포트란 위해서는 아니다.</target>
        </trans-unit>
        <trans-unit id="ad9397f3e6e3e4c72dcb47695405ed9d0b6444eb" translate="yes" xml:space="preserve">
          <source>When NumPy is built, information about system configuration is recorded, and is made available for extension modules using NumPy&amp;rsquo;s C API. These are mostly defined in &lt;code&gt;numpyconfig.h&lt;/code&gt; (included in &lt;code&gt;ndarrayobject.h&lt;/code&gt;). The public symbols are prefixed by &lt;code&gt;NPY_*&lt;/code&gt;. NumPy also offers some functions for querying information about the platform in use.</source>
          <target state="translated">NumPy가 빌드되면 시스템 구성에 대한 정보가 기록되고 NumPy의 C API를 사용하여 확장 모듈에 사용 가능합니다. 이들은 대부분에 정의되어 &lt;code&gt;numpyconfig.h&lt;/code&gt; (에 포함 &lt;code&gt;ndarrayobject.h&lt;/code&gt; ). 퍼블릭 심볼 앞에는 &lt;code&gt;NPY_*&lt;/code&gt; 가 붙습니다 . NumPy는 사용중인 플랫폼에 대한 정보를 쿼리하기위한 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f9eebd0d248f1a6803fb5b3cabe894035e7a712b" translate="yes" xml:space="preserve">
          <source>When True, trailing zeros are removed from the inputs. When False, the inputs are passed through intact.</source>
          <target state="translated">True이면 입력에서 후행 0이 제거됩니다. False이면 입력이 그대로 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="97a14729b31bf94d828802c225db2f870571e19a" translate="yes" xml:space="preserve">
          <source>When a &lt;em&gt;casting&lt;/em&gt; error occurs during assignment (for example updating a numerical array using a sequence of strings), the array being assigned to may end up in an unpredictable partially updated state. However, if any other error (such as an out of bounds index) occurs, the array will remain unchanged.</source>
          <target state="translated">할당 중 &lt;em&gt;캐스팅&lt;/em&gt; 오류가 발생 하면 (예 : 문자열 시퀀스를 사용하여 숫자 형 배열 업데이트) 할당 된 배열이 예측할 수없는 부분적으로 업데이트 된 상태가 될 수 있습니다. 그러나 범위를 벗어난 인덱스와 같은 다른 오류가 발생하면 배열은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d0060f5095733a108d2028d216426111947fd92" translate="yes" xml:space="preserve">
          <source>When a broadcasting error occurs, the iterator raises an exception which includes the input shapes to help diagnose the problem.</source>
          <target state="translated">브로드 캐스트 오류가 발생하면 반복자가 문제를 진단하는 데 도움이되는 입력 모양을 포함하는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bb6f21e3a640b767ac7aa4f3739c198a4f93da24" translate="yes" xml:space="preserve">
          <source>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</source>
          <target state="translated">memmap으로 인해 파일이 파일 시스템에서 현재 크기를 초과하여 작성되거나 확장되면 새 부품의 내용이 지정되지 않습니다. POSIX 파일 시스템 시맨틱이있는 시스템에서 확장 부분은 0 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="9b87e186d194de6f9d4cd9e098a815eab1dbc5b7" translate="yes" xml:space="preserve">
          <source>When a recording filter is added, matching warnings are stored in the &lt;code&gt;log&lt;/code&gt; attribute as well as in the list returned by &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">기록 필터를 추가하면 일치하는 경고가 &lt;code&gt;log&lt;/code&gt; 속성과 &lt;code&gt;record&lt;/code&gt; 가 반환 한 목록에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba1de10f5ac1f9d67feabe34568ca76340334549" translate="yes" xml:space="preserve">
          <source>When a ufunc is called, many things must be done. The information collected from these setup operations is stored in a loop-object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with PyArray_Broadcast so that the broadcasting can be handled in the same way as it is handled in other sections of code.</source>
          <target state="translated">ufunc가 호출되면 많은 작업을 수행해야합니다. 이러한 설정 작업에서 수집 된 정보는 루프 개체에 저장됩니다. 이 루프 객체는 C 구조입니다 (파이썬 객체가 될 수 있지만 내부에서만 사용되므로 초기화되지는 않습니다). 이 루프 객체는 PyArray_Broadcast와 함께 사용하여 다른 코드 섹션에서 처리되는 것과 같은 방식으로 브로드 캐스트를 처리 할 수있는 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bed1032321553c178be0f4aa76322e048587c74c" translate="yes" xml:space="preserve">
          <source>When a view is desired in as many cases as possible, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; may be preferable.</source>
          <target state="translated">가능한 많은 경우에 관점이 요구되는 경우, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; 이 바람직 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3d973a2064387ee8231885f5fb66b3c4832468fa" translate="yes" xml:space="preserve">
          <source>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is &lt;code&gt;False&lt;/code&gt;) or the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; (if the corresponding entry of the mask is &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">명명 된 필드가없는 마스킹 된 배열의 단일 항목에 액세스 할 때 출력은 스칼라 (마스크의 해당 항목이 &lt;code&gt;False&lt;/code&gt; 인 경우 )이거나 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 특수 값 ( 마스크 의 해당 항목이 &lt;code&gt;True&lt;/code&gt; 인 경우 )입니다.</target>
        </trans-unit>
        <trans-unit id="06a15d5053f26aa57bf4b46b8d10d7192f9bc439" translate="yes" xml:space="preserve">
          <source>When accessing a slice, the output is a masked array whose &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute is a view of the original data, and whose mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</source>
          <target state="translated">슬라이스에 액세스 할 때 출력은 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 속성이 원래 데이터의보기이고 마스크가 마스크가 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (원래 배열에 유효하지 않은 항목이없는 경우) 마스크의 해당 배열의 마스크 된 배열입니다. 마스크. 마스크 수정 내용을 원본으로 전파하려면 뷰가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4d92b7829e88a948fb9eb65ffcf73c11643904a9" translate="yes" xml:space="preserve">
          <source>When added within a context, filters are only added inside the context and will be forgotten when the context is exited.</source>
          <target state="translated">컨텍스트 내에서 추가되면 필터는 컨텍스트 내에서만 추가되며 컨텍스트가 종료 될 때 잊혀집니다.</target>
        </trans-unit>
        <trans-unit id="9541e02340938d50efa6e54249172d0ce37841bb" translate="yes" xml:space="preserve">
          <source>When adding the &amp;lsquo;out&amp;rsquo; parameter, we have to explicitly provide those flags, because if someone passes in an array as &amp;lsquo;out&amp;rsquo;, the iterator will default to &amp;lsquo;readonly&amp;rsquo;, and our inner loop would fail. The reason &amp;lsquo;readonly&amp;rsquo; is the default for input arrays is to prevent confusion about unintentionally triggering a reduction operation. If the default were &amp;lsquo;readwrite&amp;rsquo;, any broadcasting operation would also trigger a reduction, a topic which is covered later in this document.</source>
          <target state="translated">'out'매개 변수를 추가 할 때 누군가가 'out'으로 배열을 전달하면 반복자는 기본적으로 'readonly'로 설정되고 내부 루프가 실패하므로 플래그를 명시 적으로 제공해야합니다. '읽기 전용'이 입력 배열의 기본값 인 이유는 의도하지 않게 축소 작업을 트리거하는 것에 대한 혼동을 방지하기위한 것입니다. 기본값이 '읽기 / 쓰기'인 경우 모든 방송 작업은이 문서의 뒷부분에서 다루는 주제 인 축소를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="4db060a24fc0c2ce0739cc8fe613a0f3bd607af5" translate="yes" xml:space="preserve">
          <source>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; and has to be handled by the caller unless &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; is asked to allocate the result.</source>
          <target state="translated">고급 지수가 나란히 배치되면 조옮김이 필요할 수 있습니다. 필요한 모든 이조에 의해 처리됩니다 &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; 및 않는 호출자에 의해 처리되어야한다 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 이 결과를 할당하도록 요청한다.</target>
        </trans-unit>
        <trans-unit id="d51d0efd85b1005294bf85e6a8973d000ac30965" translate="yes" xml:space="preserve">
          <source>When all weights along axis are zero. See &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt;&lt;code&gt;numpy.ma.average&lt;/code&gt;&lt;/a&gt; for a version robust to this type of error.</source>
          <target state="translated">축을 따라 모든 가중치가 0 일 때. 이 유형의 오류에 강력한 버전 은 &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt; &lt;code&gt;numpy.ma.average&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8f93d8039436724f69d84838e7be89d226d23fc" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">배열 인 경우 각 행은 &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt; 와 같은 D 차원 공간의 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="82d8732b0393645ea59279b9ddb8a309ed548c77" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">array_like 인 경우 각 요소는 단일 좌표의 값 목록입니다 &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt; 예 : histogramgramdd ((X, Y, Z))) .</target>
        </trans-unit>
        <trans-unit id="355be91097240a30b4454a31696bf68a0b258227" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">축이 지정되면 축으로 인덱스 된 하위 배열이 정렬됩니다. 이것은 지정된 축을 배열의 첫 번째 차원으로 만든 다음 하위 순서를 C 순서로 병합하여 수행됩니다. 그런 다음 평평한 하위 배열은 레이블이 지정된 각 요소와 함께 구조화 된 유형으로 간주되며 다른 1D 배열과 동일한 방식으로 처리 할 수있는 구조화 된 유형의 1D 배열로 끝납니다. 결과적으로 평평한 하위 배열이 첫 번째 요소부터 시작하여 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6b69f1e4103645c38ed661fd82fe69ef3f4b8546" translate="yes" xml:space="preserve">
          <source>When an ellipsis (&lt;code&gt;...&lt;/code&gt;) is present but has no size (i.e. replaces zero &lt;code&gt;:&lt;/code&gt;) the result will still always be an array. A view if no advanced index is present, otherwise a copy.</source>
          <target state="translated">줄임표 ( &lt;code&gt;...&lt;/code&gt; )가 있지만 크기가없는 경우 (예 &lt;code&gt;:&lt;/code&gt; 0 :) 결과는 항상 배열입니다. 고급 색인이없는 경우보기, 그렇지 않으면 사본.</target>
        </trans-unit>
        <trans-unit id="3d4c4fe16d2ce5d90f03758ae48eb086b0f73e4f" translate="yes" xml:space="preserve">
          <source>When an input date falls on the weekend or a holiday, &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &amp;lsquo;raise&amp;rsquo;, which simply raises an exception. The rules most typically used are &amp;lsquo;forward&amp;rsquo; and &amp;lsquo;backward&amp;rsquo;.</source>
          <target state="translated">입력 날짜가 주말 또는 공휴일 인 경우 &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; 은&lt;/a&gt; 먼저 규칙을 적용하여 날짜를 유효한 영업일로 롤링 한 다음 오프셋을 적용합니다. 기본 규칙은 '상승'이며, 이는 단순히 예외를 발생시킵니다. 가장 일반적으로 사용되는 규칙은 '전달'및 '뒤로'입니다.</target>
        </trans-unit>
        <trans-unit id="64e5ff0649d57b71884c5f5309f3367e78576ca8" translate="yes" xml:space="preserve">
          <source>When applied to masked arrays, this function drops the mask information if the &lt;code&gt;to_begin&lt;/code&gt; and/or &lt;code&gt;to_end&lt;/code&gt; parameters are used.</source>
          <target state="translated">마스크 배열에 적용될 때이 함수는 &lt;code&gt;to_begin&lt;/code&gt; 및 / 또는 &lt;code&gt;to_end&lt;/code&gt; 매개 변수가 사용되는 경우 마스크 정보를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="f9f55c2f275cd5eebce400c5d632f8721b4b827a" translate="yes" xml:space="preserve">
          <source>When axis is not None, this function does the same thing as &amp;ldquo;fancy&amp;rdquo; indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; is equivalent to &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt;.</source>
          <target state="translated">axis가 None이 아닌 경우,이 함수는 &quot;fancy&quot;인덱싱 (배열을 사용한 어레이 인덱싱)과 동일한 기능을 수행합니다. 그러나 주어진 축을 따라 요소가 필요한 경우 사용하기가 더 쉬울 수 있습니다. &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; 과 같은 호출 은 &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c8d4285d8be1f6c2247d830229aff2863b6c70" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</source>
          <target state="translated">버퍼링이 활성화되면 임시 버퍼의 크기를 제어합니다. 기본값은 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="16e4f331a390aab5d5358796f242e2ca6c555d93" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this allows the size of the inner loop to grow when buffering isn&amp;rsquo;t necessary. This option is best used if you&amp;rsquo;re doing a straight pass through all the data, rather than anything with small cache-friendly arrays of temporary values for each inner loop.</source>
          <target state="translated">버퍼링이 활성화되면 버퍼링이 필요하지 않을 때 내부 루프의 크기가 커질 수 있습니다. 이 옵션은 각 내부 루프에 대해 캐시 친화적 인 임시 값으로 구성된 작은 배열이 아닌 모든 데이터를 직선 통과하는 경우에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b51f6738b373830fc8b3cc055c675ac17c018d38" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this also switches to a special buffering mode which reduces the loop length as necessary to not trample on values being reduced.</source>
          <target state="translated">버퍼링이 활성화되면 감소되는 값을 짓밟 지 않도록 루프 길이를 줄이는 특수 버퍼링 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="41819020a24f8ece45999c2f5c36e5cb1be0993f" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this delays allocation of the buffers until &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; or another reset function is called. This flag exists to avoid wasteful copying of buffer data when making multiple copies of a buffered iterator for multi-threaded iteration.</source>
          <target state="translated">버퍼링이 활성화되면 &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt; 또는 다른 재설정 기능이 호출 될 때까지 버퍼 할당이 지연 됩니다. 이 플래그는 다중 스레드 반복을 위해 버퍼 된 반복기의 여러 사본을 작성할 때 버퍼 데이터의 낭비적인 복사를 피하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="230c13e7258bcd1f717539097a4dd43ccf64c97d" translate="yes" xml:space="preserve">
          <source>When calculating the power of an experiment (power = probability of rejecting the null hypothesis when a specific alternative is true) the non-central F statistic becomes important. When the null hypothesis is true, the F statistic follows a central F distribution. When the null hypothesis is not true, then it follows a non-central F statistic.</source>
          <target state="translated">실험의 검정력을 계산할 때 (검정력 = 특정 대안이 참일 때 귀무 가설을 기각 할 확률) 비 중앙 F 통계량이 중요해집니다. 귀무 가설이 참이면 F 통계량은 중심 F 분포를 따릅니다. 귀무 가설이 참이 아닌 경우 중앙이 아닌 F 통계량을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="67a93e8e91305afaf6fc0532016e5191c667e052" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt;.</source>
          <target state="translated">제로 d 배열 또는 스칼라에서 호출되면 &lt;code&gt;nonzero(a)&lt;/code&gt; 는 &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="05271cb09f7d75c6bfb61cf24594f89c89131399" translate="yes" xml:space="preserve">
          <source>When called with only scalars, &lt;code&gt;np.block&lt;/code&gt; is equivalent to an ndarray call. So &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; is equivalent to &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt;.</source>
          <target state="translated">스칼라로 호출 할 때, &lt;code&gt;np.block&lt;/code&gt; 는 ndarray 호출하는 것과 동일합니다. 따라서 &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; 은 &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3fc5492e5904c93f3605a33709fbb0c2bb0c5b" translate="yes" xml:space="preserve">
          <source>When casting from complex to float or int. To avoid this, one should use &lt;code&gt;a.real.astype(t)&lt;/code&gt;.</source>
          <target state="translated">복합물에서 부동 또는 정수로 캐스팅 할 때. 이를 피하려면 &lt;code&gt;a.real.astype(t)&lt;/code&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3afb0a37a10edd1baec0a1dc8d2095269323f16d" translate="yes" xml:space="preserve">
          <source>When creating a 0-d array from an array scalar use &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; instead of the standard copy from an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">배열 스칼라에서 0-d 배열을 만들 때는 배열 스칼라 의 표준 복사본 대신 &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; 을 사용하십시오. 데이터 유형과 함께 배열 스칼라를 정의하지 않은 경우 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8887c1561ce70af56f037b9ba953356547c232a4" translate="yes" xml:space="preserve">
          <source>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, that corresponds roughly to the boolean &lt;code&gt;False&lt;/code&gt;. Trying to set an element of &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception, as a boolean does not support item assignment.</source>
          <target state="translated">구조화되지 않은 단순한 데이터 유형으로 새 마스크 배열을 작성할 때 마스크는 초기에 특수 값 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; 로&lt;/a&gt; 설정되며, 이는 부울 &lt;code&gt;False&lt;/code&gt; 와 대략 일치 합니다. 부울은 항목 할당을 지원하지 않으므로 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 요소를 설정하려고 하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외 가 발생하여 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="4e6d2af630e30f862a489ba6df45674126eb3cd4" translate="yes" xml:space="preserve">
          <source>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</source>
          <target state="translated">문자열에서 날짜 시간 배열을 만들 때 일반 단위와 함께 날짜 시간 유형을 사용하여 입력에서 단위를 자동으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36a5c7d333e9c484967d9590699c121ae8287b5d" translate="yes" xml:space="preserve">
          <source>When either of the elements is masked, the result is masked as well, but the underlying boolean data are still set, with self and other considered equal if both are masked, and unequal otherwise.</source>
          <target state="translated">요소 중 하나가 마스킹되면 결과도 마스킹되지만 기본 부울 데이터는 여전히 설정되며, 둘 중 하나가 마스킹 된 경우 자체 및 기타가 동일하게 간주되고 그렇지 않으면 동일하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2c15c829ea1146c460c63d87fff55a43784eaa99" translate="yes" xml:space="preserve">
          <source>When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n &amp;lt;=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.</source>
          <target state="translated">랜덤 표본을 사용하여 모집단에서 비율의 표준 오차를 추정 할 때, 정규 분포는 곱 p * n &amp;lt;= 5 (여기서 p = 모집단 비율 추정치, n = 표본 개수)가 아니면 잘 작동합니다. 이항 분포가 대신 사용됩니다. 예를 들어 15 명으로 구성된 샘플은 왼손잡이 4 명, 오른 손잡이 11 명을 보여줍니다. 그런 다음 p = 4/15 = 27 %입니다. 0.27 * 15 = 4이므로이 경우 이항 분포를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b79bfc37b770b9a9d472063cecf571e647616c67" translate="yes" xml:space="preserve">
          <source>When fid is a file object, array contents are directly written to the file, bypassing the file object&amp;rsquo;s &lt;code&gt;write&lt;/code&gt; method. As a result, tofile cannot be used with files objects supporting compression (e.g., GzipFile) or file-like objects that do not support &lt;code&gt;fileno()&lt;/code&gt; (e.g., BytesIO).</source>
          <target state="translated">fid가 파일 객체 인 경우 파일 내용의 &lt;code&gt;write&lt;/code&gt; 메서드를 무시하고 배열 내용이 파일에 직접 기록됩니다 . 결과적으로 tofile은 압축을 지원하는 파일 객체 (예 : GzipFile) 또는 &lt;code&gt;fileno()&lt;/code&gt; 지원하지 않는 파일과 같은 객체 (예 : BytesIO) 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b8650f4614cacd7afc4a45f34e856756be0c8acc" translate="yes" xml:space="preserve">
          <source>When forcing an iteration order, we observed that the external loop option may provide the elements in smaller chunks because the elements can&amp;rsquo;t be visited in the appropriate order with a constant stride. When writing C code, this is generally fine, however in pure Python code this can cause a significant reduction in performance.</source>
          <target state="translated">반복 순서를 강제 할 때, 요소가 일정한 보폭으로 적절한 순서로 방문 될 수 없기 때문에 외부 루프 옵션이 요소를 더 작은 청크로 제공 할 수 있음을 관찰했습니다. C 코드를 작성할 때는 일반적으로 문제가 없지만 순수한 Python 코드에서는 성능이 크게 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63eda21eb7811aeacc325fcf56f657d21ccc05f4" translate="yes" xml:space="preserve">
          <source>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are &lt;em&gt;not&lt;/em&gt; preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</source>
          <target state="translated">연결할 하나 이상의 배열이 MaskedArray 인 경우이 함수는 ndarray 대신 MaskedArray 객체를 반환하지만 입력 마스크는 유지 &lt;em&gt;되지 않습니다&lt;/em&gt; . MaskedArray가 입력으로 예상되는 경우 대신 마스크 배열 모듈에서 ma.concatenate 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eccfc4e1a7be21e04b2017257495e340f746e64f" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is a shorthand for &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt;. Using &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt; directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되는 경우이 함수는 &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt; 의 약어입니다 . 서브 클래스에 대해 올바르게 작동하므로 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 직접 사용 하는 것이 좋습니다. 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8419db09cea322048fba5bff5f136770a8b6713" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되면이 함수는 &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 것과 같습니다 . 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a83dea336fc44b86e10fe7d04631005f6869d53b" translate="yes" xml:space="preserve">
          <source>When opening the saved &lt;code&gt;.npz&lt;/code&gt; file with &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;NpzFile&lt;/code&gt; object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the &lt;code&gt;.files&lt;/code&gt; attribute), and for the arrays themselves.</source>
          <target state="translated">저장된 &lt;code&gt;.npz&lt;/code&gt; 파일을 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;NpzFile&lt;/code&gt; 객체가 반환됩니다. 이것은 배열 목록 ( &lt;code&gt;.files&lt;/code&gt; 속성 사용)과 배열 자체에 대해 쿼리 할 수있는 사전과 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="26e6b9fa52377f35e02d57b8c33d212f74b50ae3" translate="yes" xml:space="preserve">
          <source>When order is &amp;lsquo;A&amp;rsquo; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is an array in neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo; order, and a copy is forced by a change in dtype, then the order of the result is not necessarily &amp;lsquo;C&amp;rsquo; as expected. This is likely a bug.</source>
          <target state="translated">order가 'A'이고 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 가 'C'또는 'F'순서가 아닌 배열이고 dtype의 변경으로 인해 사본이 강제 실행되는 경우 결과 순서가 반드시 'C'인 것은 아닙니다. 이것은 버그 일 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="5be535caa0bb6516144fc1de604b8372d3c9991d" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0))</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0))</target>
        </trans-unit>
        <trans-unit id="9149bcf3649f5259f262c786b3a7a6478a7a8e0f" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0)). Defaults to {&amp;lsquo;end&amp;rsquo;, 0}.</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0)). 기본값은 { 'end', 0}입니다.</target>
        </trans-unit>
        <trans-unit id="6642df63420a359718ac20ea567420cbe3b18377" translate="yes" xml:space="preserve">
          <source>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; which stores the data necessary in an optimized form.</source>
          <target state="translated">특정 주 마스크 및 휴일 중 하나를 선택하여 많은 비즈니스 날짜를 조작하는 데 성능이 중요한 경우, 필요한 데이터를 최적화 된 형식으로 저장 하는 오브젝트 &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd00b76d3636aeca15fb36d92b84ae47d7409ff3" translate="yes" xml:space="preserve">
          <source>When positive infinity and negative infinity are present:</source>
          <target state="translated">양의 무한대와 음의 무한대가 존재할 때 :</target>
        </trans-unit>
        <trans-unit id="57212127eb9536990cda5db105b01bdf8367e735" translate="yes" xml:space="preserve">
          <source>When spaces are used as delimiters, or when no delimiter has been given as input, there should not be any missing data between two fields.</source>
          <target state="translated">공백이 분리 문자로 사용되거나 분리 문자가 입력으로 제공되지 않은 경우 두 필드 사이에 누락 된 데이터가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="2c6d6090a315dc06167791d55632ca0e61a0eb7f" translate="yes" xml:space="preserve">
          <source>When studying hypothesis tests that assume normality, seeing how the tests perform on data from a Cauchy distribution is a good indicator of their sensitivity to a heavy-tailed distribution, since the Cauchy looks very much like a Gaussian distribution, but with heavier tails.</source>
          <target state="translated">정규성을 가정하는 가설 검정을 연구 할 때 Cauchy 분포는 가우시안 분포와 매우 유사하지만 꼬리는 더 무겁기 때문에 Cauchy 분포의 데이터에서 검정이 어떻게 수행되는지는 꼬리 꼬리 분포에 대한 민감도를 나타내는 좋은 지표입니다.</target>
        </trans-unit>
        <trans-unit id="83471109ed39b7eca8654b0b5b56f710df2f0ed6" translate="yes" xml:space="preserve">
          <source>When success (0 return value) is returned, either out_arr is filled with a non-NULL PyArrayObject and the rest of the parameters are untouched, or out_arr is filled with NULL, and the rest of the parameters are filled.</source>
          <target state="translated">성공 (0 반환 값)이 반환되면 out_arr은 NULL이 아닌 PyArrayObject로 채워지고 나머지 매개 변수는 그대로 유지되거나 out_arr는 NULL로 채워지고 나머지 매개 변수는 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c5848cbfcc751d6fb624a1cce409c076b5cc5302" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;external_loop&amp;rdquo; was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.</source>
          <target state="translated">&quot;external_loop&quot;가 구성 중에 사용되지 않았지만 원하는 경우 플래그가 지정된 것처럼 반복자가 동작하도록 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a1da80e9817b29febb418ac2727dd8feb1e9ca57" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;multi_index&amp;rdquo; flag was specified, this removes it, allowing the internal iteration structure to be optimized further.</source>
          <target state="translated">&quot;multi_index&quot;플래그가 지정되면이를 제거하여 내부 반복 구조를 더욱 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea45d329df78eba717c22414db760106850fd424" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is specified an array of appropriate size is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 지정되어 적당한 크기의 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="3fdd0f5189c6dc8a23dfca9586f442b975510baf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is used an array is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 사용되는 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="53c50ce51f38684cf2835cdea8b4002b8bbf92a8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;c_index&lt;/code&gt; or &lt;code&gt;f_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed and &lt;code&gt;has_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="76706b5098ca6b382b941c090b506c3f0587d432" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;multi_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed accessed and &lt;code&gt;has_multi_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_multi_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ac5d59cc3a2303eaecb29429bf707b0c3c3bedde" translate="yes" xml:space="preserve">
          <source>When the DFT is computed for purely real input, the output is Hermitian-symmetric, i.e. the negative frequency terms are just the complex conjugates of the corresponding positive-frequency terms, and the negative-frequency terms are therefore redundant. This function does not compute the negative frequency terms, and the length of the transformed axis of the output is therefore &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">순수 실제 입력에 대해 DFT를 계산할 때 출력은 허미 시안 대칭입니다. 즉, 음의 주파수 항은 해당 양의 주파수 항의 복소수 복소수이므로 음의 주파수 항은 중복됩니다. 이 함수는 음의 주파수 항을 계산하지 않으므로 출력 변환 축의 길이는 &lt;code&gt;n//2 + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3d4a45bb9288ccb26e83539df4a7489dddcf142" translate="yes" xml:space="preserve">
          <source>When the data type of &lt;code&gt;a&lt;/code&gt; is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 데이터 유형 이 longdouble 또는 clongdouble 인 경우 item ()은 정보를 잃지 않는 사용 가능한 Python 스칼라가 없으므로 스칼라 배열 객체를 반환합니다. 무효 배열은 필드가 정의되어 있지 않으면 튜플이 반환되지 않는 한 item ()에 대한 버퍼 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d7c5ae7d2e5fed7aeaee002bc1ee17b1c24ba0a" translate="yes" xml:space="preserve">
          <source>When the dimension of the vector(s) in &lt;code&gt;a&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt; does not equal 2 or 3.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 및 / 또는 &lt;code&gt;b&lt;/code&gt; 의 벡터 치수가 2 또는 3이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="dd1fba0c6bb426cf1f952081182426781d82c79b" translate="yes" xml:space="preserve">
          <source>When the error handling for a floating-point error (one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, or &amp;ldquo;invalid&amp;rdquo;) is set to &amp;lsquo;call&amp;rsquo; or &amp;lsquo;log&amp;rsquo;, the function that is called or the log instance that is written to is returned by &lt;a href=&quot;#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;. This function or log instance has been set with &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 오류 ( &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;또는 &quot;invalid&quot;중 하나)에 대한 오류 처리가 호출 된 함수 또는 로그 인스턴스 인 'call'또는 'log'로 설정된 경우 작성된 것은 &lt;a href=&quot;#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; 에&lt;/a&gt; 의해 리턴됩니다 . 이 함수 또는 로그 인스턴스는 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3a105e739e37e79639871fe00f74a7608f41e18f" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is used, the code needs to know the parameters for doing the inner loop. These functions provide that information.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 가 사용되면 코드는 내부 루프를 수행하기위한 매개 변수를 알아야합니다. 이러한 기능은 해당 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3b33dbd60831369f7fef62a2b038dc2ad278fa8" translate="yes" xml:space="preserve">
          <source>When the flags attribute is retrieved from Python, a special builtin object of this type is constructed. This special type makes it easier to work with the different flags by accessing them as attributes or by accessing them as if the object were a dictionary with the flag names as entries.</source>
          <target state="translated">flags 속성이 Python에서 검색되면이 유형의 특수 내장 객체가 생성됩니다. 이 특수 유형을 사용하면 다른 플래그를 속성으로 액세스하거나 오브젝트가 플래그 이름을 항목으로하는 사전 인 것처럼 액세스하여 다른 플래그로 작업하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6997b127e257f2d9de0f0028a03e8903521c7172" translate="yes" xml:space="preserve">
          <source>When the index consists of as many integer arrays as the array being indexed has dimensions, the indexing is straight forward, but different from slicing.</source>
          <target state="translated">인덱스가 생성되는 배열의 크기만큼 인덱스가 정수 배열로 구성된 경우 인덱스는 간단하지만 슬라이싱과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e3539c51a85d030896869c59fab4a3546a18e92e" translate="yes" xml:space="preserve">
          <source>When the input &lt;code&gt;a&lt;/code&gt; is a time-domain signal and &lt;code&gt;A = fft(a)&lt;/code&gt;, &lt;code&gt;np.abs(A)&lt;/code&gt; is its amplitude spectrum and &lt;code&gt;np.abs(A)**2&lt;/code&gt; is its power spectrum. The phase spectrum is obtained by &lt;code&gt;np.angle(A)&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 가 시간 영역 신호이고 &lt;code&gt;A = fft(a)&lt;/code&gt; 경우 &lt;code&gt;np.abs(A)&lt;/code&gt; 는 진폭 스펙트럼이고 &lt;code&gt;np.abs(A)**2&lt;/code&gt; 는 전력 스펙트럼입니다. 위상 스펙트럼은 &lt;code&gt;np.angle(A)&lt;/code&gt; 의해 얻어진다 .</target>
        </trans-unit>
        <trans-unit id="1367f160bbb5fedd65e0cbb76f7f60e11a8156e2" translate="yes" xml:space="preserve">
          <source>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</source>
          <target state="translated">입력 및 출력 배열이 정렬되고 올바른 유형이지만 스 트래 딩이 균일하지 않은 경우 (비 연속 및 2D 이상) 계산에 두 번째 루핑 구조가 사용됩니다. 이 방법은 입력 및 출력 인수에 대한 모든 반복자를 가장 큰 차원을 제외한 모든 반복에서 반복하도록 변환합니다. 그런 다음 내부 루프는 기본 1D 계산 루프에 의해 처리됩니다. 외부 루프는 변환 된 반복자의 표준 반복자 루프입니다. 하드웨어 오류 플래그는 각 1D 루프가 완료된 후에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="34e3c1c18b6a533eb7d5554f7595a67b84951780" translate="yes" xml:space="preserve">
          <source>When the input is purely real, its transform is Hermitian, i.e., the component at frequency</source>
          <target state="translated">입력이 순전히 실제 인 경우, 변환은 Hermitian, 즉 주파수 성분</target>
        </trans-unit>
        <trans-unit id="52b34b95d5e176ad47f62260446b195804a6cada" translate="yes" xml:space="preserve">
          <source>When the length of 1D &lt;code&gt;weights&lt;/code&gt; is not the same as the shape of &lt;code&gt;a&lt;/code&gt; along axis.</source>
          <target state="translated">1 차원의 길이 때 &lt;code&gt;weights&lt;/code&gt; 의 형태와 동일하지 축을 따라. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1eaf8889fe184a62b6fd5a964889299281ae31" translate="yes" xml:space="preserve">
          <source>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</source>
          <target state="translated">중첩 목록의 깊이가 두 수준이면 구성 요소에서 블록 행렬을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f5bbbcfb6705ce5d9a02195d69308545da2c5f" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">선택적인 키 &lt;em&gt;오프셋&lt;/em&gt; 과 &lt;em&gt;제목&lt;/em&gt; 이 제공되면 해당 값은 각각 &lt;em&gt;이름&lt;/em&gt; 및 &lt;em&gt;형식&lt;/em&gt; 목록 과 동일한 길이의 목록이어야 합니다. &lt;em&gt;옵셋&lt;/em&gt; 값 (한정 바이트 오프셋의 목록 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; 그동안, 각 필드의) &lt;em&gt;타이틀의&lt;/em&gt; 값은 각 필드를위한 타이틀리스트 (인 &lt;code&gt;None&lt;/code&gt; 어떤 타이틀 해당 필드 소망하지 않으면 사용할 수 없다). &lt;em&gt;제목은&lt;/em&gt; 어떤 수 있습니다 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 개체 및 필드에 다른 항목 제목에 의해 키가 및 추가 튜플 구성원으로 제목을 포함 동일한 필드 튜플을 참조 사전 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0c89441828aa0daf46fb0989feeaa96e8f46c4c3" translate="yes" xml:space="preserve">
          <source>When the result of an advanced indexing operation has no elements but an individual index is out of bounds, whether or not an &lt;code&gt;IndexError&lt;/code&gt; is raised is undefined (e.g. &lt;code&gt;x[[], [123]]&lt;/code&gt; with &lt;code&gt;123&lt;/code&gt; being out of bounds).</source>
          <target state="translated">고급 인덱싱 동작의 결과에 요소가 없지만 개별 인덱스가 있는지의 여부, 범위를 벗어나면 &lt;code&gt;IndexError&lt;/code&gt; 상승이 정의된다 (예를 들면 &lt;code&gt;x[[], [123]]&lt;/code&gt; 와 &lt;code&gt;123&lt;/code&gt; 범위 외인 임).</target>
        </trans-unit>
        <trans-unit id="cb9d5c54f477f497096e6733fd299984beb835c4" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;, there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">변수에 이름이 지정되면 (유연한 dtype 또는 &lt;code&gt;names&lt;/code&gt; 포함 ) 파일에 헤더가 없어야합니다 (그렇지 않으면 ValueError 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="1ce6824829e37ca585156c8e8abdeb7e7047b4a6" translate="yes" xml:space="preserve">
          <source>When there is at least one slice (&lt;code&gt;:&lt;/code&gt;), ellipsis (&lt;code&gt;...&lt;/code&gt;) or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; in the index (or the array has more dimensions than there are advanced indexes), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element</source>
          <target state="translated">(가 적어도 하나 개의 조각 인 경우 &lt;code&gt;:&lt;/code&gt; ), 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 인덱스에 (또는 배열이 고급 인덱스가보다 더 많은 차원이), 다음 동작은 더 복잡 할 수 있습니다. 각 고급 색인 요소에 대한 색인 결과를 연결하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fc05435c156ef19015ca040276948a66576f250" translate="yes" xml:space="preserve">
          <source>When there is more than one axis to sum over - and they are not the last (first) axes of &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) - the argument &lt;code&gt;axes&lt;/code&gt; should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</source>
          <target state="translated">합산 할 축이 두 개 이상이고 축이 ( &lt;code&gt;b&lt;/code&gt; ) 의 마지막 (첫 번째) 축이 &lt;code&gt;a&lt;/code&gt; 경우 인수 &lt;code&gt;axes&lt;/code&gt; 동일한 길이의 두 시퀀스로 구성되어야합니다. 두 시퀀스, 두 번째 축 두 번째 등.</target>
        </trans-unit>
        <trans-unit id="aca72761c1059e14a576d5243f55b005214eb5e7" translate="yes" xml:space="preserve">
          <source>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; produces a view (changed in version 1.10.0).</source>
          <target state="translated">피연산자가 하나만 있고 축이 합산되지 않고 출력 매개 변수가 제공되지 않으면 새 배열 대신 피연산자에 대한보기가 리턴됩니다. 따라서 대각선을 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 사용하면 뷰가 생성됩니다 (버전 1.10.0에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="d6560fa9a8a1164ba82db1ff6a46fb84089bde5d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a283e044d3ebfd4430bd993011e5610365921585" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;code&gt;chararray&lt;/code&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="436bc3d73aa6565d86aefabb54c9292e559b97a5" translate="yes" xml:space="preserve">
          <source>When used interactively with an object, &lt;code&gt;np.info(obj)&lt;/code&gt; is equivalent to &lt;code&gt;help(obj)&lt;/code&gt; on the Python prompt or &lt;code&gt;obj?&lt;/code&gt; on the IPython prompt.</source>
          <target state="translated">객체와 대화식으로 사용될 때 &lt;code&gt;np.info(obj)&lt;/code&gt; 는 Python 프롬프트 또는 &lt;code&gt;obj?&lt;/code&gt; 의 &lt;code&gt;help(obj)&lt;/code&gt; 와 동일 합니까? IPython 프롬프트에서.</target>
        </trans-unit>
        <trans-unit id="a8bcdc54785df618c23c01dc97dc1468fe9c49c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;jumped&lt;/code&gt;, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; as it would overlap with &lt;code&gt;blocked_rng[1]&lt;/code&gt;. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with &lt;code&gt;range(10, 20)&lt;/code&gt;, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</source>
          <target state="translated">&lt;code&gt;jumped&lt;/code&gt; 를 사용할 때 이미 사용 된 스트림으로 점프하지 않도록주의해야합니다. 위의 예에서 나중에 &lt;code&gt;blocked_rng[1]&lt;/code&gt; 과 겹치 &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; 나중에 blocking_rng [0] .jumped () 를 사용할 수 없습니다 . 독립 스트림과 마찬가지로 여기서 주요 프로세스가 점프하여 10 개 이상의 스트림을 분리하려면 &lt;code&gt;range(10, 20)&lt;/code&gt; 로 시작해야합니다 . 그렇지 않으면 동일한 스트림을 다시 생성합니다. 반면에 스트림을 신중하게 구성하면 겹치지 않는 스트림이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="724bc629cdbfec6a4e5af9a220d38930424c297d" translate="yes" xml:space="preserve">
          <source>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt;&lt;code&gt;numpy.linspace&lt;/code&gt;&lt;/a&gt; for these cases.</source>
          <target state="translated">정수가 아닌 단계 (예 : 0.1)를 사용하는 경우 결과가 종종 일치하지 않습니다. 이 경우 &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt; &lt;code&gt;numpy.linspace&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27718ed960a95a721b47ff1931021ed4073bbe48" translate="yes" xml:space="preserve">
          <source>When using a string for &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; it is possible to get multiple results.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 문자열을 사용 하면 여러 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4483d4c2e345ca8073aa1a9817270cc3cdb40e82" translate="yes" xml:space="preserve">
          <source>When using a subclass (especially one which manipulates its shape), the default &lt;code&gt;ndarray.__setitem__&lt;/code&gt; behaviour will call &lt;code&gt;__getitem__&lt;/code&gt; for &lt;em&gt;basic&lt;/em&gt; indexing but not for &lt;em&gt;advanced&lt;/em&gt; indexing. For such a subclass it may be preferable to call &lt;code&gt;ndarray.__setitem__&lt;/code&gt; with a &lt;em&gt;base class&lt;/em&gt; ndarray view on the data. This &lt;em&gt;must&lt;/em&gt; be done if the subclasses &lt;code&gt;__getitem__&lt;/code&gt; does not return views.</source>
          <target state="translated">서브 클래스 (특히 모양을 조작하는 서브 클래스)를 사용하는 경우 기본 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 비헤이비어는 &lt;em&gt;기본&lt;/em&gt; 인덱싱에 대해서는 &lt;code&gt;__getitem__&lt;/code&gt; 을 호출 하지만 &lt;em&gt;고급&lt;/em&gt; 인덱싱 에는 사용하지 않습니다 . 이러한 서브 클래스의 경우 , 데이터에 대한 &lt;em&gt;기본 클래스&lt;/em&gt; ndarray보기로 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 을 호출하는 것이 좋습니다 . 이 &lt;em&gt;있어야&lt;/em&gt; 하위 클래스 경우 수행 할 수 &lt;code&gt;__getitem__&lt;/code&gt; 뷰를 반환하지 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc311b69f41b3e0c41508f3b081d2280ad7970ec" translate="yes" xml:space="preserve">
          <source>When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]).</source>
          <target state="translated">uint64 dtype으로 브로드 캐스트를 사용하는 경우 최대 값 (2 ** 64)을 표준 정수 유형으로 나타낼 수 없습니다. 높은 배열 (또는 높은 값이 None 인 경우 low)에는 배열 ([2 ** 64])과 같은 개체 dtype이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c04978427f46ec116ad24550bbf1c67bfbb16f61" translate="yes" xml:space="preserve">
          <source>When using signed integer types the result is the two&amp;rsquo;s complement of the result for the unsigned type:</source>
          <target state="translated">부호있는 정수 유형을 사용할 때 결과는 부호없는 유형에 대한 결과의 2의 보수입니다.</target>
        </trans-unit>
        <trans-unit id="fefd781e401a9acf4994aa658770a54631a31aac" translate="yes" xml:space="preserve">
          <source>When using the iterator in multi-threaded code or in code not holding the Python GIL, care must be taken to only call functions which are safe in that context. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt;&lt;code&gt;NpyIter_Copy&lt;/code&gt;&lt;/a&gt; cannot be safely called without the Python GIL, because it increments Python references. The &lt;code&gt;Reset*&lt;/code&gt; and some other functions may be safely called by passing in the &lt;code&gt;errmsg&lt;/code&gt; parameter as non-NULL, so that the functions will pass back errors through it instead of setting a Python exception.</source>
          <target state="translated">다중 스레드 코드 또는 Python GIL을 포함하지 않는 코드에서 반복자를 사용할 때는 해당 컨텍스트에서 안전한 함수 만 호출하도록주의해야합니다. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt; &lt;code&gt;NpyIter_Copy&lt;/code&gt; &lt;/a&gt; 는 Python GIL이 없으면 파이썬 참조를 증가시키기 때문에 안전하게 호출 할 수 없습니다. &lt;code&gt;Reset*&lt;/code&gt; 및 다른 기능은 안전하게 전달하여 호출 할 수 있습니다 &lt;code&gt;errmsg&lt;/code&gt; 기능이 파이썬 예외를 설정하는 대신 그것을 통해 오류를 다시 전달합니다 그래서, 비 NULL과 같은 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="e0e93c50be29a8db34812f3b063181378aab17d0" translate="yes" xml:space="preserve">
          <source>When working along a given axis, a slice along that axis is returned in &lt;code&gt;output&lt;/code&gt; for each index where &lt;code&gt;condition&lt;/code&gt; evaluates to True. When working on a 1-D array, &lt;a href=&quot;#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 축을 따라 작업 할 때 &lt;code&gt;condition&lt;/code&gt; 을 참으로 평가하는 각 인덱스에 대해 해당 축을 따라 슬라이스가 &lt;code&gt;output&lt;/code&gt; 으로 반환됩니다 . 1 차원 배열에서 작업 할 때 &lt;a href=&quot;#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7c565731670a0f048fc0a67ffb9fb36e062b00" translate="yes" xml:space="preserve">
          <source>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt;, mandating a few conventions so that it is possible to do this.</source>
          <target state="translated">struct dtype과 같은 다른 dtype으로 구성된 더 복잡한 dtype으로 작업 할 때 dtype을 조작하는 내부 루프를 만들려면 추가 데이터가 필요합니다. NumPy는 struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 를 통해이&lt;/a&gt; 아이디어를 지원하며 ,이를 수행 할 수 있도록 몇 가지 규칙을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="aaa9ed3a1aa18ac3b534d99cdc2037422344dc84" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;%apply&lt;/code&gt; directive, as is usually necessary to use &lt;code&gt;numpy.i&lt;/code&gt;, it will remain in effect until you tell &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; that it shouldn&amp;rsquo;t be. If the arguments to the functions or methods that you are wrapping have common names, such as &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt;, these typemaps may get applied in situations you do not expect or want. Therefore, it is always a good idea to add a &lt;code&gt;%clear&lt;/code&gt; directive after you are done with a specific typemap:</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;%apply&lt;/code&gt; 등의 사용에 일반적으로 필요하다, 지시 &lt;code&gt;numpy.i&lt;/code&gt; 당신이 말할 때까지 효력이 유지됩니다 &lt;a href=&quot;http://www.swig.org&quot;&gt;꿀꺽 꿀꺽를&lt;/a&gt; 가되어서는 안된다는. 랩핑하는 함수 또는 메소드에 대한 인수에 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 와 같은 공통 이름 이있는 경우 이러한 유형 맵은 예상하지 않거나 원하지 않는 상황에 적용될 수 있습니다. 따라서 특정 유형 맵을 사용한 후에 는 항상 &lt;code&gt;%clear&lt;/code&gt; 지시문 을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="89f82c7a5bbe0891c1df2aa46cbdf990d1794aa1" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; != PyArray_GetNDArrayCVersion, the extension has to be recompiled (ABI incompatibility).</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; ! = PyArray_GetNDArrayCVersion 일 때마다 확장을 다시 컴파일해야합니다 (ABI 비 호환성).</target>
        </trans-unit>
        <trans-unit id="3e2b99bc93c54f0bc24f4acf841fece1023b07a0" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, it also changes the name of the variable holding the C-API, which defaults to &lt;code&gt;PyArray_API&lt;/code&gt;, to whatever the macro is #defined to.</source>
          <target state="translated">&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 이 #defined 일 때마다 C-API를 보유한 변수의 이름도 변경됩니다 (기본값은 &lt;code&gt;PyArray_API&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="934b37ef17a0c4c0c83c595fef5a62578238ee15" translate="yes" xml:space="preserve">
          <source>Whenever a data-type is required in a NumPy function or method, either a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or something that can be converted to one can be supplied. Such conversions are done by the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">NumPy 함수 또는 메소드에서 데이터 유형이 필요할 때마다 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 오브젝트 또는 변환 할 수있는 것을 제공 할 수 있습니다. 이러한 변환은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 생성자에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="80254bc9efba4102e15f18db7d8295d8697a0360" translate="yes" xml:space="preserve">
          <source>Whenever a writeable operand has fewer elements than the full iteration space, that operand is undergoing a reduction. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object requires that any reduction operand be flagged as read-write, and only allows reductions when &amp;lsquo;reduce_ok&amp;rsquo; is provided as an iterator flag.</source>
          <target state="translated">쓰기 가능한 피연산자가 전체 반복 공간보다 적은 수의 요소를 가질 때마다 해당 피연산자는 축소됩니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 목적은 'reduce_ok'는 반복자 플래그로서 제공되는 경우, 감소 연산만을 판독 - 기록으로 플래그 될가 감소를 허용해야.</target>
        </trans-unit>
        <trans-unit id="090346f0957607fc5beeda4f38e177d1918c4444" translate="yes" xml:space="preserve">
          <source>Where True, yield &lt;code&gt;x&lt;/code&gt;, otherwise yield &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">True이면 &lt;code&gt;x&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;y&lt;/code&gt; 를 산출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b58703967453c474e94cf57585adb3b2a50448ed" translate="yes" xml:space="preserve">
          <source>Where the library can be found.</source>
          <target state="translated">도서관을 찾을 수있는 곳.</target>
        </trans-unit>
        <trans-unit id="54df46f7307aa74c464486f1ea35cde9a77febe6" translate="yes" xml:space="preserve">
          <source>Where to install the npy-pkg config file, relatively to the current package path.</source>
          <target state="translated">현재 패키지 경로에 상대적으로 npy-pkg 구성 파일을 설치할 위치</target>
        </trans-unit>
        <trans-unit id="93d30f1df70c77ec829a136f4d8b2ef0c3b96d94" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt; or not.</source>
          <target state="translated">여부의 &lt;code&gt;arg1&lt;/code&gt; 의 서브 클래스입니다 &lt;code&gt;arg2&lt;/code&gt; 여부.</target>
        </trans-unit>
        <trans-unit id="7ded38313492e3b9340e10eb5e7bd8c5c0bea96c" translate="yes" xml:space="preserve">
          <source>Whether iteration requires access to the Python API, for example if one of the operands is an object array.</source>
          <target state="translated">예를 들어 피연산자 중 하나가 객체 배열 인 경우 반복에 Python API에 대한 액세스가 필요한지 여부</target>
        </trans-unit>
        <trans-unit id="08ba3ba6d86470ddcf5c7c987a831ffff108d8b4" translate="yes" xml:space="preserve">
          <source>Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False. Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked.</source>
          <target state="translated">계산을 위해 마스크 된 데이터가 전파되는지 (True) 또는 0 (False)으로 설정되는지 여부 기본값은 거짓입니다. 마스크를 전파한다는 것은 마스크 된 값이 행이나 열에 나타나면 전체 행이나 열이 마스크 된 것으로 간주됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8637ce438fa1d406f7ec1653600c39aad46d9db8" translate="yes" xml:space="preserve">
          <source>Whether masked values in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equal (True) or not (False). They are considered equal by default.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 마스킹 된 값 이 같은 것으로 간주 되는지 (True) 아닌지 (False). 기본적으로 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6867499c63cb6abaeab85ff30463c9432618d2ee" translate="yes" xml:space="preserve">
          <source>Whether masked values in a or b are considered equal (True) or not (False).</source>
          <target state="translated">a 또는 b에서 마스크 된 값이 동일한 것으로 간주되는지 (True) 아닌지 (False).</target>
        </trans-unit>
        <trans-unit id="288daa4940dd3020af5ede621755e8ef6fcd2c3a" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">결 측값 (있는 경우)을 가장 큰 값 (True) 또는 가장 작은 값 (False)으로 처리할지 여부 배열에 데이터 유형의 동일한 극단에 마스크되지 않은 값이 포함 된 경우 이러한 값의 순서와 마스크 된 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7da3b2e79fc5148bb637715841cccf76fc788e07" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values sorting at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">결 측값 (있는 경우)을 최대 값 (True) 또는 최소값 (False)으로 처리해야하는지 여부 배열에 데이터 유형의 동일한 극단에 정렬 된 마스킹되지 않은 값이 포함 된 경우 이러한 값의 순서와 마스킹 된 값은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec0eb17948661387af03eedbd16c0982b256d2ca" translate="yes" xml:space="preserve">
          <source>Whether or not there are iterations left.</source>
          <target state="translated">반복이 남아 있는지 여부</target>
        </trans-unit>
        <trans-unit id="6c6ce4cbc91d3e04017743bd327936e59b4be559" translate="yes" xml:space="preserve">
          <source>Whether or not to compute &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; in addition to &lt;code&gt;s&lt;/code&gt;. True by default.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 외에 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;vh&lt;/code&gt; 를 계산할지 여부 입니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="34608785e0c8e6698e050294c20a41fc581a7a43" translate="yes" xml:space="preserve">
          <source>Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous arrays are a common form of non-C-contiguity, we allow them to be written directly to disk for efficiency.</source>
          <target state="translated">배열 데이터가 연속적인지 여부. 포트란 연속 배열은 비 C 연속성의 일반적인 형태이므로 효율성을 위해 디스크에 직접 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b87db28e0b29fd77663f2df3cc4a859b46d1b1" translate="yes" xml:space="preserve">
          <source>Whether the array is to interpreted as C-order or Fortran-order.</source>
          <target state="translated">배열이 C 순서 또는 포트란 순서로 해석되는지 여부</target>
        </trans-unit>
        <trans-unit id="944c20a06f71d4591f2972a6198b951c5988e169" translate="yes" xml:space="preserve">
          <source>Whether the buffer is read-only</source>
          <target state="translated">버퍼가 읽기 전용인지 여부</target>
        </trans-unit>
        <trans-unit id="4f5043b4a62f84c7d0a89c1a7427fe7e0a42c45d" translate="yes" xml:space="preserve">
          <source>Whether the iteration over the operands is finished or not.</source>
          <target state="translated">피연산자에 대한 반복이 완료되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="13a09493df9f77aae557913a37ecafb9bbcd240e" translate="yes" xml:space="preserve">
          <source>Whether the mask is shared between masked arrays can be seen from the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt;&lt;code&gt;sharedmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt;&lt;code&gt;unshare_mask&lt;/code&gt;&lt;/a&gt; ensures the mask is not shared. A copy of the mask is only made if it was shared.</source>
          <target state="translated">마스크가 마스크 배열간에 공유되는지 여부는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt; &lt;code&gt;sharedmask&lt;/code&gt; &lt;/a&gt; 속성 에서 확인할 수 있습니다 . &lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt; &lt;code&gt;unshare_mask&lt;/code&gt; &lt;/a&gt; 는 마스크가 공유되지 않도록합니다. 마스크 사본은 공유 된 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="db7611d744e4dcdca549d1fbd74911098f577c62" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to True.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 를 True로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f17f77435a0793df30f7927fd68842a3c16557" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to False.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 를 False로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3e122a9b529992b197b46b09923f9ca3bd360b" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to True.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;code&gt;hardmask&lt;/code&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;hardmask&lt;/code&gt; 를 True로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="01426ffe48ebece03a2678d8f2d6adc220725bf0" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to False.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;code&gt;hardmask&lt;/code&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;hardmask&lt;/code&gt; 를 False로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ee9da79319e6c0e3169d3748cede2f00813142ab" translate="yes" xml:space="preserve">
          <source>Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">출력을 메모리에서 행 메이저 (C 스타일) 또는 열 메이저 (Fortran 스타일) 순서로 저장해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="92d233bcb4830096541e589ec9f4a1ebacbac55b" translate="yes" xml:space="preserve">
          <source>Whether the sample is shuffled when sampling without replacement. Default is True, False provides a speedup.</source>
          <target state="translated">교체하지 않고 샘플링 할 때 샘플이 섞여 있는지 여부 기본값은 True이고 False는 속도 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da175c30578215af592bdb3c0536af196e7c720a" translate="yes" xml:space="preserve">
          <source>Whether the sample is with or without replacement</source>
          <target state="translated">시료가 교체 유무에 관계없이</target>
        </trans-unit>
        <trans-unit id="f7a933f70353e3ad1ecdef0da587770caa9c5376" translate="yes" xml:space="preserve">
          <source>Whether to automatically strip white spaces from the variables.</source>
          <target state="translated">변수에서 공백을 자동으로 제거할지 여부</target>
        </trans-unit>
        <trans-unit id="442a6c8414200886a8391269e4fbd9de7abf0966" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to &lt;code&gt;nomask&lt;/code&gt;.</source>
          <target state="translated">False로 가득 찬 마스크를 &lt;code&gt;nomask&lt;/code&gt; 로 축소할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="4050a74967f8f69856c2fbd0e3e619300a40e0f0" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to nomask</source>
          <target state="translated">마스크로 False로 가득 찬 마스크를 축소할지 여부</target>
        </trans-unit>
        <trans-unit id="c052f30967f49a9b943b88084eb17b8a3c940aea" translate="yes" xml:space="preserve">
          <source>Whether to combine &lt;code&gt;mask&lt;/code&gt; with the mask of the input data, if any (True), or to use only &lt;code&gt;mask&lt;/code&gt; for the output (False). Default is True.</source>
          <target state="translated">마스크를 입력 데이터의 &lt;code&gt;mask&lt;/code&gt; 와 결합하는지 (있는 경우) 또는 출력에 &lt;code&gt;mask&lt;/code&gt; 만 사용하는지 (False). 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="eddff56e50fafc8cb9b530fe24b021eae68e3c92" translate="yes" xml:space="preserve">
          <source>Whether to compare NaN&amp;rsquo;s as equal. If True, NaN&amp;rsquo;s in &lt;code&gt;a&lt;/code&gt; will be considered equal to NaN&amp;rsquo;s in &lt;code&gt;b&lt;/code&gt; in the output array.</source>
          <target state="translated">NaN을 동일한 지 비교할지 여부 참이면에 낸의 &lt;code&gt;a&lt;/code&gt; 에서 낸의 동등한 것으로 간주된다 &lt;code&gt;b&lt;/code&gt; 출력 배열된다.</target>
        </trans-unit>
        <trans-unit id="10fe679c9d66f1cf6761f7d27d834a6040161f28" translate="yes" xml:space="preserve">
          <source>Whether to copy the input data (True), or to use a reference instead. Default is False.</source>
          <target state="translated">입력 데이터를 복사할지 (True) 또는 참조를 대신 사용할지 여부 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="5fe509663979cfcace796559b2e65ed21543a41a" translate="yes" xml:space="preserve">
          <source>Whether to create a copy of &lt;code&gt;x&lt;/code&gt; (True) or to replace values in-place (False). The in-place operation only occurs if casting to an array does not require a copy. Default is True.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사본을 생성할지 (True) 또는 내부 값을 대체할지 (False). 인플레 이스 작업은 어레이로 캐스트 할 때 사본이 필요하지 않은 경우에만 발생합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="cb3a38e23cd94158d3fb92938c528fabce71a1cc" translate="yes" xml:space="preserve">
          <source>Whether to force compression of an empty mask. Default is True.</source>
          <target state="translated">빈 마스크를 강제로 압축할지 여부입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="954b794bdd577e9151cce4c13b30b4547a80cce1" translate="yes" xml:space="preserve">
          <source>Whether to force the output to be a &lt;code&gt;pure&lt;/code&gt; ndarray (False) or to return a subclass of ndarray if appropriate (True, default).</source>
          <target state="translated">출력을 &lt;code&gt;pure&lt;/code&gt; ndarray (False) 로 강제할지 아니면 적절한 경우 ndarray의 서브 클래스를 리턴할지 여부 (True, default).</target>
        </trans-unit>
        <trans-unit id="e3b6a28cf1ae69fa2745e3bf0096fffb2681b0f4" translate="yes" xml:space="preserve">
          <source>Whether to import sub-modules in packages. Default is True.</source>
          <target state="translated">패키지에서 하위 모듈을 가져올 지 여부 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="560758d583a48f61c5f8c924a74ada989d313f2e" translate="yes" xml:space="preserve">
          <source>Whether to raise an AssertionError when a doctest fails. Default is True.</source>
          <target state="translated">doctest가 실패한 경우 AssertionError 발생 여부입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="9da66ee12a4e35260c8d865d944cf7e0c6ffd0fb" translate="yes" xml:space="preserve">
          <source>Whether to re-generate the docstring cache. Default is False.</source>
          <target state="translated">docstring 캐시를 다시 생성할지 여부. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="fe2c4419241a17141e2305c4b8dcba97409a61c9" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;m&lt;/code&gt; (True) or &lt;code&gt;m&lt;/code&gt; itself (False).</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; (True) 또는 &lt;code&gt;m&lt;/code&gt; 자체 (False) 의 사본을 리턴할지 여부</target>
        </trans-unit>
        <trans-unit id="d8e552974363003f8c300f894365cd71e993d9cb" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여부는 사본으로 돌아갑니다 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="037c91325bbf0eb3057c152573c6cd848efe298f" translate="yes" xml:space="preserve">
          <source>Whether to return a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; if possible (True) or a plain &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;. Default is True.</source>
          <target state="translated">여부는의 서브 클래스 반환 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 가능 (참) 경우 또는 일반 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 을&lt;/a&gt; . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="0ae760f9c4f41fa0fbb26a77403a1c22ab55b573" translate="yes" xml:space="preserve">
          <source>Whether to show the sign for positive values.</source>
          <target state="translated">양수 부호를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1b8be26bfc8b0e89327240212310466b2cf75c4c" translate="yes" xml:space="preserve">
          <source>Whether to shrink &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;nomask&lt;/code&gt; if all its values are False.</source>
          <target state="translated">모든 값이 False 인 경우 &lt;code&gt;m&lt;/code&gt; 을 &lt;code&gt;nomask&lt;/code&gt; 로 축소할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="3178cfeee0adef6924aedc74760260f82717be37" translate="yes" xml:space="preserve">
          <source>Whether to shrink the output to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; if all its values are False. Defaults to True.</source>
          <target state="translated">모든 값이 False 인 경우 출력을 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 로 축소할지 여부 입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="d9db91db6f9220d3637c22a670ce2fece1ba8892" translate="yes" xml:space="preserve">
          <source>Whether to store matrix in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행렬을 C- 또는 Fortran-contiguous 순서로 저장할지 여부는 기본값이 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="f47e8ef32095f56286465eeec2aded155a972a62" translate="yes" xml:space="preserve">
          <source>Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">다차원 데이터를 행 메이저 (C 스타일) 또는 열 메이저 (Fortran 스타일) 순서로 메모리에 저장할지 여부</target>
        </trans-unit>
        <trans-unit id="91845ffd71912999afe1ae31aecba568b6c77126" translate="yes" xml:space="preserve">
          <source>Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</source>
          <target state="translated">다차원 데이터를 C- 또는 Fortran-contiguous (행 또는 열) 순서로 메모리에 저장할지 여부</target>
        </trans-unit>
        <trans-unit id="dab7c3794a646540de7acd62a59e0fb24a52ca93" translate="yes" xml:space="preserve">
          <source>Whether to store the result in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">결과를 C- 또는 Fortran-contiguous 순서로 저장할지 여부는 기본값이 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="bfc4130ee9478e47e13d28dd5c7bbedd301de36f" translate="yes" xml:space="preserve">
          <source>Whether to use a copy of &lt;code&gt;a&lt;/code&gt; (True) or to fix &lt;code&gt;a&lt;/code&gt; in place (False). Default is True.</source>
          <target state="translated">여부는 사본 사용하는 (true)를하거나 해결하기 위해 &lt;code&gt;a&lt;/code&gt; 장소 (거짓)에서. 기본값은 True입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aebefd02adf3850b379921c027ca5f73a9e89812" translate="yes" xml:space="preserve">
          <source>Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.</source>
          <target state="translated">하드 마스크 사용 여부 하드 마스크를 사용하면 마스크 된 값을 마스크 해제 할 수 없습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="5e961f550eaad97e3dafff75ba96d8df26719652" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (&amp;lsquo;C&amp;rsquo;) or column-major (&amp;lsquo;FORTRAN&amp;rsquo;) memory representation. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행 메이저 ( 'C') 또는 열 메이저 ( 'FORTRAN') 메모리 표현 사용 여부 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="cc497678cbe7ddcd1c3ae01eed475a06c838ec4e" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행 메이저 (C 스타일) 또는 열 메이저 (Fortran 스타일) 메모리 표현 사용 여부 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="25195d8226c7af7ee557736e882797435cd7c507" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns.</source>
          <target state="translated">읽을 열 (첫 번째 0) 예를 들어, &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; 는 2, 5, 6 번째 열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ef9e92c2b540fbcf01177bb037dde03eb96de271" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.</source>
          <target state="translated">읽을 열 (첫 번째 0) 예를 들어, &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; 는 2, 5, 6 번째 열을 추출합니다. 기본값 인 None은 모든 열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="13f9686c4e3a41f3f30b2ea464209b867b694965" translate="yes" xml:space="preserve">
          <source>Which gives more easily comparable results than using separate bins for each histogram:</source>
          <target state="translated">각 히스토그램에 별도의 빈을 사용하는 것보다 훨씬 쉬운 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1a80f0fc41db0ca1b3afb508f48229204eeb48b" translate="yes" xml:space="preserve">
          <source>Which gives the polynomial &lt;code&gt;p&lt;/code&gt; in Chebyshev form. This works because</source>
          <target state="translated">체비 쇼프 형태 의 다항식 &lt;code&gt;p&lt;/code&gt; 를 제공합니다 . 이것은 작동하기 때문에</target>
        </trans-unit>
        <trans-unit id="559b97a21645e20b96438fa99ddc59b3a9a0af7c" translate="yes" xml:space="preserve">
          <source>While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:</source>
          <target state="translated">대응하는 플래그 세트를 갖는 C- 스타일 및 포트란-스타일 연속 배열은 상기 보폭으로 처리 될 수 있지만, 실제 보폭은 다를 수있다. 이것은 두 가지 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1df1b5a0658c69d8a413e038e320119a5eacba2" translate="yes" xml:space="preserve">
          <source>While the nonzero values can be obtained with &lt;code&gt;a[nonzero(a)]&lt;/code&gt;, it is recommended to use &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; or &lt;code&gt;x[x != 0]&lt;/code&gt; instead, which will correctly handle 0-d arrays.</source>
          <target state="translated">0이 아닌 값은 &lt;code&gt;a[nonzero(a)]&lt;/code&gt; 로 얻을 수 있지만 &lt;code&gt;x[x != 0]&lt;/code&gt; 배열을 올바르게 처리 하는 &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; 또는 x [x! = 0]을 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="95abe15b68efd387eb8c7edc6a4c57dd87ccf623" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re at it, let&amp;rsquo;s also introduce the &amp;lsquo;no_broadcast&amp;rsquo; flag, which will prevent the output from being broadcast. This is important, because we only want one input value for each output. Aggregating more than one input value is a reduction operation which requires special handling. It would already raise an error because reductions must be explicitly enabled in an iterator flag, but the error message that results from disabling broadcasting is much more understandable for end-users. To see how to generalize the square function to a reduction, look at the sum of squares function in the section about Cython.</source>
          <target state="translated">우리가 그 동안, 출력이 방송되는 것을 막는 'no_broadcast'플래그도 소개하겠습니다. 각 출력에 대해 하나의 입력 값만 원하므로 중요합니다. 둘 이상의 입력 값을 집계하는 것은 특별한 처리가 필요한 축소 작업입니다. 반복자 플래그에서 축소를 명시 적으로 활성화해야하기 때문에 이미 오류가 발생하지만 브로드 캐스트 비활성화로 인한 오류 메시지는 최종 사용자에게 훨씬 이해하기 쉽습니다. 제곱 함수를 축소로 일반화하는 방법을 보려면 Cython에 대한 섹션에서 제곱합 함수를보십시오.</target>
        </trans-unit>
        <trans-unit id="fdf453fd16b5200319b11da91be27d0c70481271" translate="yes" xml:space="preserve">
          <source>White spaces are ignored.</source>
          <target state="translated">공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7da3ad366450168b425d91b2ecc5364e5b9f6133" translate="yes" xml:space="preserve">
          <source>Why is There a Second File?</source>
          <target state="translated">왜 두 번째 파일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="a5faa59dd442eb9f9b067a10198b95685727452a" translate="yes" xml:space="preserve">
          <source>Width of string to left-fill elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 왼쪽 채우기 요소에 &lt;code&gt;a&lt;/code&gt; 문자열 너비입니다 .</target>
        </trans-unit>
        <trans-unit id="a87a9df3bc292d00475af99a19cfb5bace676377" translate="yes" xml:space="preserve">
          <source>Wikipedia page: &lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https://en.wikipedia.org/wiki/Trapezoidal_rule&lt;/a&gt;</source>
          <target state="translated">Wikipedia 페이지 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https://en.wikipedia.org/wiki/Trapezoidal_rule&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f57f881086e09b1ae09664bdf831c36a611c6436" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;이항 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06cf28156832f9d8c24f1184dfe95f4c17b24eb4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Cauchy distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;코시 배포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f4dafaf375cb5ca788c45f1e6be90dcf059029c" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Convolution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https://en.wikipedia.org/wiki/Convolution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;컨볼 루션&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https://en.wikipedia.org/wiki/Convolution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aefec7a4eb1a5aecabb180014fe85015da54a986" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Curve fitting&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https://en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;곡선 피팅&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https://en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ceebe5e149c9b6f7b481dab32a8b80c5a5e67177" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Dirichlet distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https://en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Dirichlet distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https://en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c274fb3e94d194d553ba10a5c9ba49ab92ab9ab3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https://en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;지수 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https://en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0748ca7a20f6367685397b634c58b22d1101a55" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;https://en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;지수 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;https://en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450a7618a7ae64b3deba48000f4698be90e329a4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https://en.wikipedia.org/wiki/F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;F- 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https://en.wikipedia.org/wiki/F-&lt;/a&gt; 배포</target>
        </trans-unit>
        <trans-unit id="17b148f03642613eb714110e8ca6f8c433f95ee5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Gamma distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https://en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;감마 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https://en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="607958a0e56c238af4c16a4ba8a36ed9dd6aae60" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;하이퍼 볼릭 기능&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2ed497979708d30048971b5f912f3a976a07c07" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hypergeometric distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https://en.wikipedia.org/wiki/Hypergeometric_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;고도 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https://en.wikipedia.org/wiki/Hypergeometric_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6c41ede2dc056083c46b6379a06aec4ce640792" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse Gaussian distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 가우스 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c81f68efd7be19a13fb16b9d3ede8e0916b2b3ba" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https://en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 쌍곡 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https://en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="788ea2b2b4739c5aba7340cb8614d021cf776477" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https://en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 쌍곡 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https://en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7afed20bd82634dc688b205c679d736b6a3ca9fd" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt;https://en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 쌍곡 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt;https://en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cbf65d4c8a1edb6485c9090716aa502b1cad498" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Laplace distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https://en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;라플라스 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https://en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5dafa467113c3ca3efc06f2332310e05c7a2741" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithm&amp;rdquo;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;대수&amp;rdquo;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c49c2d4eec5ab9e21b7777f19f27c237fceb82c5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithmic distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;대수 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78ccdc5f379af6bc4c7ea04cc13613370465bc4d" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logistic-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;물류 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c3fd20f148f2b77555334569014216015267361" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Negative binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;음 이항 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="785913c64c1118d2e5699ad155c8010ddb5608e2" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;비 중앙 F- 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_F-&lt;/a&gt; 배포</target>
        </trans-unit>
        <trans-unit id="290d1f296088408d1c3d2c95c7a7428e7d2c6df3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral chi-squared distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;비 중앙 카이 제곱 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f54672c52ce6e2a5669a3fc7c140d35832003af5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Normal distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https://en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;일반 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https://en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47b80170417ddd59eaf50cda77d4edfc322816d8" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Pareto distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https://en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Pareto distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https://en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d689426c6cd7a9b7cf6ef5d58b51175bf540f33b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https://en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;포아송 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https://en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8adc5c562751b6b393b3aa2c35d2e2c7be11d14b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson process&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https://en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;포아송 프로세스&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https://en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca57768f5ed62a15abd4e259a3842bfc684623e" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Polynomial interpolation&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https://en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;다항식 보간&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https://en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca489fd77451dbec195b0cb37e2326fd572ee535" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Rayleigh distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Rayleigh 배포판&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56ead22f9041996687e49f69c8aa068b4de6264b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Sinc function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https://en.wikipedia.org/wiki/Sinc_function&lt;/a&gt;</source>
          <target state="translated">위키피디아,&amp;ldquo;Sinc function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https://en.wikipedia.org/wiki/Sinc_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdeeaa545061fb4a54e4c2ef8adfce392d92d540" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Student&amp;rsquo;s t-distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/Student&amp;rsquo;s_t-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;학생의 t- 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/Student's_t-&lt;/a&gt; 분포</target>
        </trans-unit>
        <trans-unit id="890688a22e8725c7cf1acbafe1abacdd0f27f3f0" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Triangular distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;삼각 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d2b813725fc8f5761f54e225edc22f4a2afa8f7" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Two&amp;rsquo;s complement&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https://en.wikipedia.org/wiki/Two&amp;rsquo;s_complement&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;두 가지 보완 요소&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https://en.wikipedia.org/wiki/Two's_complement&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecbb6d74623f82d0937cf4a5246298d1b6f5e329" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Weibull distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https://en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Weibull distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https://en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98885a7cf6a7f9d6ba5424eda905db3584405b75" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Window function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https://en.wikipedia.org/wiki/Window_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;창 기능&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https://en.wikipedia.org/wiki/Window_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49c2c96ddc19c930b5486ff7f81f0ce35e375ba2" translate="yes" xml:space="preserve">
          <source>Will install data-files to the locations:</source>
          <target state="translated">위치에 데이터 파일을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="0c6212fef9bffd0b18c4eb2da8c005e9e5030130" translate="yes" xml:space="preserve">
          <source>Will need to add this in Python exposure</source>
          <target state="translated">파이썬 노출에 이것을 추가해야합니다</target>
        </trans-unit>
        <trans-unit id="77b99d58f8024a3322642cff8a7f3229ae7fe238" translate="yes" xml:space="preserve">
          <source>Window for the returned series. If None the class window is used. The default is None.</source>
          <target state="translated">반환 된 시리즈의 창입니다. 없음 인 경우 클래스 창이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e640f561d38642c76bd680b6e8d0ccf0fad3f32d" translate="yes" xml:space="preserve">
          <source>Window length.</source>
          <target state="translated">창 길이.</target>
        </trans-unit>
        <trans-unit id="42e8204afc5c4121e8aabab0c8c2df383aac93dd" translate="yes" xml:space="preserve">
          <source>Window shape</source>
          <target state="translated">창 모양</target>
        </trans-unit>
        <trans-unit id="ef32d19ad6db1a011986e848a81515a21a4878bf" translate="yes" xml:space="preserve">
          <source>Window to use for the returned series. The default value is the default class domain</source>
          <target state="translated">반환 된 시리즈에 사용할 창입니다. 기본값은 기본 클래스 도메인입니다.</target>
        </trans-unit>
        <trans-unit id="092e83dcd0b17c063ad8bac69729a61bcd90390f" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="26cbe48bc40af2be9b95617385514366c179f8c5" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="e22365565e3904f47ab3840e3c565f4c9730ed9d" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="9ae30d11df20bd6d7701709f6c7a07d9a4c0c35b" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [0, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [0, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="f003de753cd9362865426af3e4947b5f99fe6dc8" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="88febbc72ccac8a306fb0efe81d8a0b92e99d8f9" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="3a11c9632c71bf466541bc0b135a1a92817671b6" translate="yes" xml:space="preserve">
          <source>Windows 98, Python 2.1.1. Idle 0.8</source>
          <target state="translated">Windows 98, Python 2.1.1. 유휴 0.8</target>
        </trans-unit>
        <trans-unit id="838d226af82740a98f0145b002fc6c84c21c7131" translate="yes" xml:space="preserve">
          <source>Windows Me Python 2.3(EE), Idle 1.0, PyCrust 0.7.2 Python 2.1.1 Idle 0.8</source>
          <target state="translated">Windows Me Python 2.3 (EE), 유휴 1.0, PyCrust 0.7.2 Python 2.1.1 유휴 0.8</target>
        </trans-unit>
        <trans-unit id="2d2f4a4fca6daeabadddf9bee05651305943de5c" translate="yes" xml:space="preserve">
          <source>Windows XP, Python 2.3.3</source>
          <target state="translated">윈도우 XP, 파이썬 2.3.3</target>
        </trans-unit>
        <trans-unit id="32efd2d58393af190f568a67689ea6a3e549d28a" translate="yes" xml:space="preserve">
          <source>With a context manager:</source>
          <target state="translated">컨텍스트 관리자를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="f3558ac1d15b5a57abf53ea4474761a5d8cd7257" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the first axis.</source>
          <target state="translated">더 높은 차원의 배열에서 분할은 여전히 ​​첫 번째 축을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ee544b31e6fafc07fbb87de84c67e07d54295002" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the second axis.</source>
          <target state="translated">더 높은 차원의 배열에서 분할은 여전히 ​​두 번째 축을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ab0ad2552c2290da0b4beaf3ab8b39ed880b7892" translate="yes" xml:space="preserve">
          <source>With a list of depth 1, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used as &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">깊이 1 목록을 사용하면 &lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4a6ca14b02d06fe44564f452a8db5dc0b8887f51" translate="yes" xml:space="preserve">
          <source>With a list of depth 2, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">깊이 2의 목록 으로 &lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f9ff7e20abf4e4beec43f72205b5efc96b3cabc" translate="yes" xml:space="preserve">
          <source>With a similar procedure the forward/backward approximations used for boundaries can be derived.</source>
          <target state="translated">유사한 절차를 통해 경계에 사용 된 순방향 / 역방향 근사값을 도출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07af3a8001dd5a2cff9dc94ccf6ded3daafa9ec6" translate="yes" xml:space="preserve">
          <source>With instances:</source>
          <target state="translated">인스턴스의 경우 :</target>
        </trans-unit>
        <trans-unit id="98601db3737fbbb6544e879545b48b394db52bb5" translate="yes" xml:space="preserve">
          <source>With optional &lt;code&gt;start&lt;/code&gt;, test beginning at that position. With optional &lt;code&gt;end&lt;/code&gt;, stop comparing at that position.</source>
          <target state="translated">선택적인 &lt;code&gt;start&lt;/code&gt; 로 해당 위치에서 시작하여 테스트하십시오. 선택적 &lt;code&gt;end&lt;/code&gt; 를 사용하면 해당 위치에서 비교를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="c2d93c630b90cc0cf1d738f44caa66baf4d85928" translate="yes" xml:space="preserve">
          <source>With types:</source>
          <target state="translated">유형으로 :</target>
        </trans-unit>
        <trans-unit id="5297c5a4978350f9e16a1aab9a51984e592036fa" translate="yes" xml:space="preserve">
          <source>Within a compiled Python module, &lt;code&gt;import_array()&lt;/code&gt; should only get called once. This could be in a C/C++ file that you have written and is linked to the module. If this is the case, then none of your interface files should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; or call &lt;code&gt;import_array()&lt;/code&gt;. Or, this initialization call could be in a wrapper file generated by &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; from an interface file that has the &lt;code&gt;%init&lt;/code&gt; block as above. If this is the case, and you have more than one &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file, then only one interface file should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; and call &lt;code&gt;import_array()&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 파이썬 모듈 내에서 &lt;code&gt;import_array()&lt;/code&gt; 는 한 번만 호출되어야합니다. 이것은 작성한 C / C ++ 파일에있을 수 있으며 모듈에 링크되어 있습니다. 이 경우 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 또는 &lt;code&gt;import_array()&lt;/code&gt; 호출하는 인터페이스 파일이 없습니다 . 또는이 초기화 호출은 위와 같이 &lt;code&gt;%init&lt;/code&gt; 블록 이있는 인터페이스 파일에서 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG에&lt;/a&gt; 의해 생성 된 랩퍼 파일에있을 수 있습니다 . 이 경우에 하나 이상의 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일 이있는 경우 하나의 인터페이스 파일 만 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 하고 &lt;code&gt;import_array()&lt;/code&gt; 호출 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42a24f4738db07788648f7de55bbb8493bc76610" translate="yes" xml:space="preserve">
          <source>Within these test methods, &lt;code&gt;assert_()&lt;/code&gt; and related functions are used to test whether a certain assumption is valid. If the assertion fails, the test fails. Note that the Python builtin &lt;code&gt;assert&lt;/code&gt; should not be used, because it is stripped during compilation with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">이 테스트 방법 내에서 &lt;code&gt;assert_()&lt;/code&gt; 및 관련 함수는 특정 가정이 유효한지 테스트하는 데 사용됩니다. 어설 션이 실패하면 테스트가 실패합니다. Python 내장 &lt;code&gt;assert&lt;/code&gt; 는 &lt;code&gt;-O&lt;/code&gt; 로 컴파일하는 동안 제거되므로 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="2729aa84fd8dbce5d8f5065881c86da559d3b68c" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;np.ix_&lt;/code&gt; call or only the diagonal elements would be selected.</source>
          <target state="translated">&lt;code&gt;np.ix_&lt;/code&gt; 호출이 없으면 대각선 요소 만 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="eb6d460982da286faa01241fe0e8688fe713d131" translate="yes" xml:space="preserve">
          <source>Working on the flattened array does not return slices along an axis but selects elements.</source>
          <target state="translated">병합 된 배열에서 작업해도 축을 따라 슬라이스가 반환되지 않지만 요소가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="20669d5d64b568db66a362c01f09d0be2912bdf7" translate="yes" xml:space="preserve">
          <source>Works only with 2-D arrays at the moment.</source>
          <target state="translated">현재 2D 배열에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="10b18b3520a07a5cef88cf768f74798c3a76c969" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;code&gt;cPickle.load&lt;/code&gt; which accepts either a file-like object or a filename.</source>
          <target state="translated">파일과 유사한 객체 또는 파일 이름을 허용하는 &lt;code&gt;cPickle.load&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="9462c7fa9fecb835eb7e04e6564736baefd4da76" translate="yes" xml:space="preserve">
          <source>Wrapper functions to more user-friendly calling of certain math functions whose output data-type is different than the input data-type in certain domains of the input.</source>
          <target state="translated">랩퍼 함수는 출력 데이터 유형이 입력의 특정 도메인에서 입력 데이터 유형과 다른 특정 수학 함수를보다 사용자 친화적으로 호출 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4a3455d09d842fa89e3426820a565b99b12203bd" translate="yes" xml:space="preserve">
          <source>Wraps an index to the valid range if it is out of bounds.</source>
          <target state="translated">범위를 벗어난 경우 인덱스를 유효한 범위로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="7a347606df979a4d48c841a72544818a00c72b80" translate="yes" xml:space="preserve">
          <source>Wraps the numpy array and sets the mask according to context.</source>
          <target state="translated">numpy 배열을 랩핑하고 컨텍스트에 따라 마스크를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e18273e50d37416e99772f5cab31d35dc76b18b6" translate="yes" xml:space="preserve">
          <source>Write any changes in the array to the file on disk.</source>
          <target state="translated">어레이의 변경 사항을 디스크의 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="17ca7c9b94fb6b9ea51995accba9353b9d7605ae" translate="yes" xml:space="preserve">
          <source>Write array to a file as text or binary (default).</source>
          <target state="translated">배열을 텍스트 또는 이진 (기본값)으로 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b0ef5a1f165fa86b8ee546df97daa724c33481fa" translate="yes" xml:space="preserve">
          <source>Write data to memmap array:</source>
          <target state="translated">memmap 배열에 데이터 쓰기 :</target>
        </trans-unit>
        <trans-unit id="39de007639c1cf0174274b49579ea3af01d9afca" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;self&lt;/em&gt; to the file pointer &lt;em&gt;fp&lt;/em&gt; in C-style contiguous fashion. Write the data as binary bytes if &lt;em&gt;sep&lt;/em&gt; is the string &amp;ldquo;&amp;rdquo;or &lt;code&gt;NULL&lt;/code&gt;. Otherwise, write the contents of &lt;em&gt;self&lt;/em&gt; as text using the &lt;em&gt;sep&lt;/em&gt; string as the item separator. Each item will be printed to the file. If the &lt;em&gt;format&lt;/em&gt; string is not &lt;code&gt;NULL&lt;/code&gt; or &amp;ldquo;&amp;rdquo;, then it is a Python print statement format string showing how the items are to be written.</source>
          <target state="translated">C 스타일 연속 방식 으로 &lt;em&gt;자체&lt;/em&gt; 내용을 파일 포인터 &lt;em&gt;fp&lt;/em&gt; 에 씁니다 . &lt;em&gt;sep&lt;/em&gt; 가 문자열&amp;ldquo;&amp;rdquo;또는 &lt;code&gt;NULL&lt;/code&gt; 인 경우 데이터를 이진 바이트로 씁니다 . 그렇지 않으면, &lt;em&gt;sep&lt;/em&gt; 문자열을 항목 구분 기호로 사용하여 &lt;em&gt;self&lt;/em&gt; 의 내용을 텍스트로 작성하십시오 . 각 항목이 파일로 인쇄됩니다. 경우 &lt;em&gt;형식&lt;/em&gt; 문자열이 아닌 &lt;code&gt;NULL&lt;/code&gt; 또는 &quot;&quot;다음은 항목이 기록 될 방법을 보여주는 파이썬 인쇄 문 형식 문자열입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d00c80b2825b910b28f217d40888491f74cea96" translate="yes" xml:space="preserve">
          <source>Writeable returned arrays (since version 1.10.0):</source>
          <target state="translated">쓰기 가능한 반환 배열 (버전 1.10.0부터) :</target>
        </trans-unit>
        <trans-unit id="6ebe08ad44f2f2a207e761b2763be6cc2be06253" translate="yes" xml:space="preserve">
          <source>Writing tests for the &lt;code&gt;numpy.i&lt;/code&gt;&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file is a combinatorial headache. At present, 12 different data types are supported, each with 74 different argument signatures, for a total of 888 typemaps supported &amp;ldquo;out of the box&amp;rdquo;. Each of these typemaps, in turn, might require several unit tests in order to verify expected behavior for both proper and improper inputs. Currently, this results in more than 1,000 individual unit tests executed when &lt;code&gt;make test&lt;/code&gt; is run in the &lt;code&gt;numpy/tools/swig&lt;/code&gt; subdirectory.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일에 대한 테스트 작성 은 조합 두통입니다. 현재, 12 개의 서로 다른 데이터 유형이 지원되며 각각 74 개의 서로 다른 인수 서명이 지원되어 &quot;즉시&quot;지원되는 총 888 개의 유형 맵이 있습니다. 이러한 각 유형 맵에는 올바른 입력과 부적절한 입력 모두에 대해 예상되는 동작을 확인하기 위해 몇 가지 단위 테스트가 필요할 수 있습니다. 현재 &lt;code&gt;numpy/tools/swig&lt;/code&gt; 서브 디렉토리 에서 &lt;code&gt;make test&lt;/code&gt; 를 실행할 때 1,000 개가 넘는 개별 단위 테스트가 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="aecfd6c8b6bdc8850ec5e6c24472a391088658d3" translate="yes" xml:space="preserve">
          <source>Writing typemaps can be a bit nonintuitive. If you have specific questions about writing &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps for NumPy, the developers of &lt;code&gt;numpy.i&lt;/code&gt; do monitor the &lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;Numpy-discussion&lt;/a&gt; and &lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;Swig-user&lt;/a&gt; mail lists.</source>
          <target state="translated">타입 맵 작성은 직관적이지 않을 수 있습니다. NumPy 용 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG 유형&lt;/a&gt; 맵 작성에 대한 특정 질문이있는 경우 &lt;code&gt;numpy.i&lt;/code&gt; 개발자 는 &lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;Numpy-discussion&lt;/a&gt; 및 &lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;Swig-user&lt;/a&gt; 메일 목록을 모니터링 합니다.</target>
        </trans-unit>
        <trans-unit id="67b3075df8e687d02e42240f00e9c97b2d568182" translate="yes" xml:space="preserve">
          <source>Writing your own tests</source>
          <target state="translated">자신 만의 테스트 작성</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3e44498549b3ccfc159cdee6bdb9318868914b00" translate="yes" xml:space="preserve">
          <source>Yet another possibility is to use any of the following functions:</source>
          <target state="translated">또 다른 가능성은 다음 기능 중 하나를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4a5fe8b97704af411fc68344f43f8175b5a17c2" translate="yes" xml:space="preserve">
          <source>You can also put the common two last lines into an extension-local header file as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that file.</source>
          <target state="translated"># 파일을 포함하기 전에 NO_IMPORT_ARRAY가 # 정의되어 있는지 확인하는 한 공통 두 줄을 확장-로컬 헤더 파일에 넣을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5bdd1d6f2605746dfa5444603a80a8e39ed12e" translate="yes" xml:space="preserve">
          <source>You can also start the product with a value other than one:</source>
          <target state="translated">다음 이외의 값으로 제품을 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9238d7ca5ba3e22758c44fc16cfa76bade93b524" translate="yes" xml:space="preserve">
          <source>You can also start the sum with a value other than zero:</source>
          <target state="translated">0 이외의 값으로 합계를 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbae01da7fe0ab4f2d4dfea82533b37281dc1510" translate="yes" xml:space="preserve">
          <source>You can check whether this option was enabled when your NumPy was built by looking at the value of &lt;code&gt;np.ones((10,1),
order='C').flags.f_contiguous&lt;/code&gt;. If this is &lt;code&gt;True&lt;/code&gt;, then your NumPy has relaxed strides checking enabled.</source>
          <target state="translated">&lt;code&gt;np.ones((10,1), order='C').flags.f_contiguous&lt;/code&gt; 의 값을 확인하여 NumPy를 빌드 할 때이 옵션이 활성화되었는지 확인할 수 있습니다 . 이것이 &lt;code&gt;True&lt;/code&gt; 이면 NumPy에서 보폭 점검이 활성화 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f727d609d02021feb25c56ec5c7d4115e505da2" translate="yes" xml:space="preserve">
          <source>You can do all this with &lt;code&gt;slice()&lt;/code&gt; plus a few special objects, but there&amp;rsquo;s a lot to remember and this version is simpler because it uses the standard array indexing syntax.</source>
          <target state="translated">&lt;code&gt;slice()&lt;/code&gt; 와 몇 가지 특수 객체를 사용 하여이 모든 작업을 수행 할 수 있지만 기억해야 할 것이 많으며이 버전은 표준 배열 인덱싱 구문을 사용하기 때문에 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8032e81ac40a6f0f1a73b54a1b7839b994061479" translate="yes" xml:space="preserve">
          <source>You can think of reshaping as first raveling the array (using the given index order), then inserting the elements from the raveled array into the new array using the same kind of index ordering as was used for the raveling.</source>
          <target state="translated">먼저 주어진 인덱스 순서를 사용하여 배열을 래블 링 한 다음 래블 링에 사용 된 것과 동일한 종류의 인덱스 순서를 사용하여 래블 된 배열의 요소를 새 배열에 삽입하는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a1a526e2dfcefc7502bbfe7d5198a1cfd393800" translate="yes" xml:space="preserve">
          <source>You can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:</source>
          <target state="translated">초기 값을 사용하여 빈 슬라이스의 최대 값을 계산하거나 다른 값으로 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d0bef869069e40769f21f1de600d0fc6d747dfa" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;initial&lt;/code&gt; keyword argument to initialize the reduction with a different value, and &lt;code&gt;where&lt;/code&gt; to select specific elements to include:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;initial&lt;/code&gt; , 그리고 다른 값으로 감소를 초기화하는 키워드 인수를 &lt;code&gt;where&lt;/code&gt; 포함하는 특정 요소를 선택합니다 :</target>
        </trans-unit>
        <trans-unit id="91fa0d476f571316eb9194c7c7392edcc2d88959" translate="yes" xml:space="preserve">
          <source>You can use the code in &lt;code&gt;numpy.i&lt;/code&gt; to write your own typemaps. For example, if you had a five-dimensional array as a function argument, you could cut-and-paste the appropriate four-dimensional typemaps into your interface file. The modifications for the fourth dimension would be trivial.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 코드를 사용 하여 고유 한 유형 맵을 작성할 수 있습니다. 예를 들어 함수 인수로 5 차원 배열이있는 경우 적절한 4 차원 유형 맵을 잘라내어 인터페이스 파일에 붙여 넣을 수 있습니다. 네 번째 차원의 수정은 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="98e9f88bd4a89aebe54d98a979717885fd9d0412" translate="yes" xml:space="preserve">
          <source>You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in &lt;code&gt;x[obj] = value&lt;/code&gt; must be (broadcastable) to the same shape as &lt;code&gt;x[obj]&lt;/code&gt;.</source>
          <target state="translated">슬라이싱을 사용하여 배열에 값을 설정할 수 있지만 목록과 달리 배열을 늘릴 수는 없습니다. 값의 크기를 설정한다 &lt;code&gt;x[obj] = value&lt;/code&gt; 과 동일한 형상 (캐스트 가능한)이어야 &lt;code&gt;x[obj]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3568ae4f766e37d7c5effd4c8f672ee7bd5f8ce" translate="yes" xml:space="preserve">
          <source>You should note that, while included in the table for completeness, the &amp;lsquo;S&amp;rsquo;, &amp;lsquo;U&amp;rsquo;, and &amp;lsquo;V&amp;rsquo; types cannot be operated on by ufuncs. Also, note that on a 32-bit system the integer types may have different sizes, resulting in a slightly altered table.</source>
          <target state="translated">완전성을 위해 표에 포함되어 있지만 'S', 'U'및 'V'유형은 ufunc에 의해 조작 될 수 없습니다. 또한 32 비트 시스템에서 정수 유형의 크기가 다를 수 있으므로 테이블이 약간 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f357b2fe6ddb759961311e43e7970103d0b441f0" translate="yes" xml:space="preserve">
          <source>You will also need to add the tests directory in the configuration section of your setup.py:</source>
          <target state="translated">setup.py의 구성 섹션에 tests 디렉토리를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e16810e3242991af56a001ed6a884d632c200f8" translate="yes" xml:space="preserve">
          <source>Zero matrix of given shape, dtype, and order.</source>
          <target state="translated">주어진 모양, dtype 및 순서의 제로 행렬.</target>
        </trans-unit>
        <trans-unit id="e45e696eb3d4f02d39791369c3d3958a76ab90d1" translate="yes" xml:space="preserve">
          <source>Zero matrix.</source>
          <target state="translated">제로 매트릭스.</target>
        </trans-unit>
        <trans-unit id="dc9379a72db3a8937472e62bd1e9326e04e14e35" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 제로 패딩 은 지정된 치수를 따라 입력에 0을 추가하여 수행됩니다. 이것이 일반적인 접근 방법이지만 놀라운 결과를 초래할 수 있습니다. 다른 형태의 제로 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; 를 호출 하기 전에 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="64a64c98f6885c75110c036526d556b9a4c44be0" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 제로 패딩 은 지정된 치수를 따라 입력에 0을 추가하여 수행됩니다. 이것이 일반적인 접근 방법이지만 놀라운 결과를 초래할 수 있습니다. 다른 형태의 제로 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 을 호출 하기 전에 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="517f56a81e423e64373bd116eb0759a041c8ad2f" translate="yes" xml:space="preserve">
          <source>Zeros are returned for slices that are all-NaN or empty.</source>
          <target state="translated">all-NaN이거나 비어있는 슬라이스에 대해서는 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acacd887197bd2babb7be61e73a56d1f99561e0f" translate="yes" xml:space="preserve">
          <source>Zipf, G. K., &amp;ldquo;Selected Studies of the Principle of Relative Frequency in Language,&amp;rdquo; Cambridge, MA: Harvard Univ. Press, 1932.</source>
          <target state="translated">Zipf, GK, &quot;언어의 상대적 주파수 원리에 대한 선택된 연구&quot;, Cambridge, MA : Harvard Univ. 1932 년을 누르십시오.</target>
        </trans-unit>
        <trans-unit id="ed86773f64d57f9b3c7ee4020ed0f191241f3769" translate="yes" xml:space="preserve">
          <source>[ 1678 AD, 2262 AD]</source>
          <target state="translated">[ 1678 AD, 2262 AD]</target>
        </trans-unit>
        <trans-unit id="402b4dc5670a23bc318ab3cb00cdc7fa9f64de7f" translate="yes" xml:space="preserve">
          <source>[ 1969 AD, 1970 AD]</source>
          <target state="translated">[ 1969 AD, 1970 AD]</target>
        </trans-unit>
        <trans-unit id="bd183430653087be5ae12502c45fc000d3da0d92" translate="yes" xml:space="preserve">
          <source>[ 2.9e8 BC, 2.9e8 AD]</source>
          <target state="translated">[ 2.9e8 BC, 2.9e8 AD]</target>
        </trans-unit>
        <trans-unit id="dc7f3e791b46510c11bbde8e0bb893651cf79bee" translate="yes" xml:space="preserve">
          <source>[1.0e15 BC, 1.0e15 AD]</source>
          <target state="translated">[1.0e15 BC, 1.0e15 AD]</target>
        </trans-unit>
        <trans-unit id="06a7557ae8ce0cfbe48cae36c42a5043941673e5" translate="yes" xml:space="preserve">
          <source>[1.7e13 BC, 1.7e13 AD]</source>
          <target state="translated">[1.7e13 BC, 1.7e13 AD]</target>
        </trans-unit>
        <trans-unit id="d122eae6bae0b58d08b1fd88854423fb5b4631e6" translate="yes" xml:space="preserve">
          <source>[1.7e17 BC, 1.7e17 AD]</source>
          <target state="translated">[1.7e17 BC, 1.7e17 AD]</target>
        </trans-unit>
        <trans-unit id="af9678a88e0692bf413856f430540a50579b7921" translate="yes" xml:space="preserve">
          <source>[2.5e16 BC, 2.5e16 AD]</source>
          <target state="translated">[2.5e16 BC, 2.5e16 AD]</target>
        </trans-unit>
        <trans-unit id="fb54cef9abe0ffb09a025ee28bfe888680b86ee0" translate="yes" xml:space="preserve">
          <source>[2.9e11 BC, 2.9e11 AD]</source>
          <target state="translated">[2.9e11 BC, 2.9e11 AD]</target>
        </trans-unit>
        <trans-unit id="9b1e4a9e31badd5faa858bd32af6c4bab33690b0" translate="yes" xml:space="preserve">
          <source>[290301 BC, 294241 AD]</source>
          <target state="translated">[290301 BC, 294241 AD]</target>
        </trans-unit>
        <trans-unit id="2212219fa92d0d55a2e83f844d81d7dc4a36dd7d" translate="yes" xml:space="preserve">
          <source>[7.6e17 BC, 7.6e17 AD]</source>
          <target state="translated">[7.6e17 BC, 7.6e17 AD]</target>
        </trans-unit>
        <trans-unit id="7855213bc11a8db7fc6daa3f131f06c9977a3960" translate="yes" xml:space="preserve">
          <source>[9.2e18 BC, 9.2e18 AD]</source>
          <target state="translated">[9.2e18 BC, 9.2e18 AD]</target>
        </trans-unit>
        <trans-unit id="faf24ac10ab74f225b601311df4355d76763fa97" translate="yes" xml:space="preserve">
          <source>[CT]</source>
          <target state="translated">[CT]</target>
        </trans-unit>
        <trans-unit id="7d2f4bdb1926f2cbbdd65bcf6b74603f5acdf8c8" translate="yes" xml:space="preserve">
          <source>[G]</source>
          <target state="translated">[G]</target>
        </trans-unit>
        <trans-unit id="3d6c6c6111149819e43b6089c9a7b9c8a2431938" translate="yes" xml:space="preserve">
          <source>[NR]</source>
          <target state="translated">[NR]</target>
        </trans-unit>
        <trans-unit id="1b8941d3b1d081473898f4b2e4a8ff850cc6de82" translate="yes" xml:space="preserve">
          <source>[R5cc1f1f25381-1]</source>
          <target state="translated">[R5cc1f1f25381-1]</target>
        </trans-unit>
        <trans-unit id="0c4d5826769047e816879e0f7216ecf388ea499b" translate="yes" xml:space="preserve">
          <source>[Re860718f5533-1]</source>
          <target state="translated">[Re860718f5533-1]</target>
        </trans-unit>
        <trans-unit id="6b6f9491cb308db36a45d25a8dcf1db55932e083" translate="yes" xml:space="preserve">
          <source>[WRW]</source>
          <target state="translated">[WRW]</target>
        </trans-unit>
        <trans-unit id="3897c72013a6887de9a1de9869c3e948fd9696d2" translate="yes" xml:space="preserve">
          <source>__array_data__</source>
          <target state="translated">__array_data__</target>
        </trans-unit>
        <trans-unit id="81f5d0f249cae6e54a5453d7972fcd0943accd0e" translate="yes" xml:space="preserve">
          <source>__array_descr__</source>
          <target state="translated">__array_descr__</target>
        </trans-unit>
        <trans-unit id="c0a201183273449f8bd82be2d062468aa25df323" translate="yes" xml:space="preserve">
          <source>__array_interface__</source>
          <target state="translated">__array_interface__</target>
        </trans-unit>
        <trans-unit id="0a9ff3eb9a1e79e8a4cdf02304244a5327adcb47" translate="yes" xml:space="preserve">
          <source>__array_mask__</source>
          <target state="translated">__array_mask__</target>
        </trans-unit>
        <trans-unit id="ac7e7fcdcffb075d0e09e72d92d910d4b9351cdb" translate="yes" xml:space="preserve">
          <source>__array_offset__</source>
          <target state="translated">__array_offset__</target>
        </trans-unit>
        <trans-unit id="238f299c155456fe6a848580f0ef9d3e6bb2a8de" translate="yes" xml:space="preserve">
          <source>__array_shape__</source>
          <target state="translated">__array_shape__</target>
        </trans-unit>
        <trans-unit id="2f3678a5595fd628d8dfae6d631c1ae1fb6ef8da" translate="yes" xml:space="preserve">
          <source>__array_strides__</source>
          <target state="translated">__array_strides__</target>
        </trans-unit>
        <trans-unit id="aa0ad955aed8601e1764fbffe3d43f4a00fe14f0" translate="yes" xml:space="preserve">
          <source>__array_typestr__</source>
          <target state="translated">__array_typestr__</target>
        </trans-unit>
        <trans-unit id="96401488135b817c2f1747197a83525ae296049e" translate="yes" xml:space="preserve">
          <source>a (fixed) payment, &lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt;&lt;code&gt;pmt&lt;/code&gt;&lt;/a&gt;, paid either</source>
          <target state="translated">A (고정) 지급, &lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt; &lt;code&gt;pmt&lt;/code&gt; &lt;/a&gt; , 중 지급</target>
        </trans-unit>
        <trans-unit id="d5166cddbf23a08b5074c2edc9aec3c68a5f3663" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integer keys.</source>
          <target state="translated">부호없는 624 개의 정수 키로 구성된 1 차원 배열</target>
        </trans-unit>
        <trans-unit id="e95c05fdf3a7626457c027e91f7b377539d00b22" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integers &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">부호없는 정수 &lt;code&gt;keys&lt;/code&gt; 624 개의 1 차원 배열 .</target>
        </trans-unit>
        <trans-unit id="72fdfe6550961319f36cdd5e343cde12faf15445" translate="yes" xml:space="preserve">
          <source>a 1-d view of scalar</source>
          <target state="translated">스칼라의 1 차원 모습</target>
        </trans-unit>
        <trans-unit id="74f70982e8ed106bd95f08838212248bb41b2355" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="8f21ea65027d34d0f525219a53334dc35cb5bbea" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;chararray&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;chararray&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="cb4065b0f0de4de8cc6afb691ce3365727df08a4" translate="yes" xml:space="preserve">
          <source>a Python str or unicode object,</source>
          <target state="translated">파이썬 str 또는 유니 코드 객체</target>
        </trans-unit>
        <trans-unit id="753cc1b7cdb86a0a582f834f17fe8e4f8e20365f" translate="yes" xml:space="preserve">
          <source>a binary string for the data</source>
          <target state="translated">데이터의 이진 문자열</target>
        </trans-unit>
        <trans-unit id="7be660f83fa27f597e95280a8283a2c0611d9749" translate="yes" xml:space="preserve">
          <source>a binary string for the mask.</source>
          <target state="translated">마스크의 이진 문자열</target>
        </trans-unit>
        <trans-unit id="da3d248ac1b46ab9b40ccba358d7b76cb5f95a1a" translate="yes" xml:space="preserve">
          <source>a binary string with the data (or a list if &amp;lsquo;a&amp;rsquo; is an object array)</source>
          <target state="translated">데이터가 포함 된 이진 문자열 (또는 'a'가 객체 배열 인 경우 목록)</target>
        </trans-unit>
        <trans-unit id="165258a094d59f96169a00b9e5b85c293cfac672" translate="yes" xml:space="preserve">
          <source>a flat iterator on the array.</source>
          <target state="translated">배열의 플랫 반복자</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
