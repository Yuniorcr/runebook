<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="566c08ff5cbfc7563b6ec48f86b77d9828806bcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unused&lt;/strong&gt; &amp;ndash; Unused and present for backwards compatibility of the C-API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe8c102c8793c67d6746562319d7cce28d3e604" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212034ee3710f83d787575e7a3119ff8c1718007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;values: array_like (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc38d803fcdf5b4457864347438f926098e055a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;var&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ece35df348f32a862697a3ca07ca318c2719b8c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;version&lt;/strong&gt; (required)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50b66227821134be63cdc8c83fee8ce7c311e86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;weekmask or holidays. The attributes return copies of internal data.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6afa5fd008afa469686c9e7fb95f9ddcee12a5f4" translate="yes" xml:space="preserve">
          <source>= location and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0973e6133866853f9e6256eba9d72c9151694397" translate="yes" xml:space="preserve">
          <source>= scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbae4b50ad6ac0a0e515dead61dcef253fcc6db1" translate="yes" xml:space="preserve">
          <source>= the result of iterating &lt;code&gt;j&lt;/code&gt; over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde6a5f915926c219c9ad1caeba15367682dad41" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;traditional&amp;rdquo; example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654e39aa1416e4a99699a4c806db40cb3e673a19" translate="yes" xml:space="preserve">
          <source>A 1- or 2-d array_like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024da60a5572fbcd0de36246055b7067f7d49cbc" translate="yes" xml:space="preserve">
          <source>A 1-D array, containing the elements of the input, is returned. A copy is made only if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05915b878480d5cbbd9d515ad9e6d4ff95cf41d7" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator for Arrayterator objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94e5e444e4a89c91179830906b14e4b95c7f975" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator over the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080d28fe39f0db76a9a09d5b0de0f2cfd772f02d" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator over the matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f8ab17663e982d06a46c4b01d02b934e42bf4b" translate="yes" xml:space="preserve">
          <source>A 1-D iterator over the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4c8f5af8234daf63ac87fac41bf34728e2a4a8" translate="yes" xml:space="preserve">
          <source>A 1-D or 2-D array containing multiple variables and observations. Each row of &lt;code&gt;m&lt;/code&gt; represents a variable, and each column a single observation of all those variables. Also see &lt;code&gt;rowvar&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebacd166002a0aab793729a826968ad21540978" translate="yes" xml:space="preserve">
          <source>A 1-D or 2-D array containing multiple variables and observations. Each row of &lt;code&gt;x&lt;/code&gt; represents a variable, and each column a single observation of all those variables. Also see &lt;code&gt;rowvar&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0a346ddaabdf9157361bcef554a19793288c12" translate="yes" xml:space="preserve">
          <source>A 2-D example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcf8fe375a813c5bfbdff5bbb67bdacfa9f426d" translate="yes" xml:space="preserve">
          <source>A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6cebe7eb915060fc6496dd11b4201c6171b95b" translate="yes" xml:space="preserve">
          <source>A 2-tuple of ints, iaxis_pad_width[0] represents the number of values padded at the beginning of vector where iaxis_pad_width[1] represents the number of values padded at the end of vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2152806df29fad5ea3c51b85e6a2d449bd3debf7" translate="yes" xml:space="preserve">
          <source>A 2-tuple whose first argument is an integer (a long integer if necessary) that points to the data-area storing the array contents. This pointer must point to the first element of data (in other words any offset is always ignored in this case). The second entry in the tuple is a read-only flag (true means the data area is read-only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93bf653bc1902857eef1ccac3f5d09491253e5b" translate="yes" xml:space="preserve">
          <source>A 3-D example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a85df542f6e0ae1b5dff43196ef149fd4fac69" translate="yes" xml:space="preserve">
          <source>A 3-dimensional array of size 3 x 3 x 3, summed over each of its three axes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549cb93636e34bdf02245b26cee07ee2514370b9" translate="yes" xml:space="preserve">
          <source>A :c:type: &lt;code&gt;PyCObject&lt;/code&gt; whose &lt;code&gt;voidptr&lt;/code&gt; member contains a pointer to a filled &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Memory for the structure is dynamically created and the &lt;code&gt;PyCObject&lt;/code&gt; is also created with an appropriate destructor so the retriever of this attribute simply has to apply &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; to the object returned by this attribute when it is finished. Also, either the data needs to be copied out, or a reference to the object exposing this attribute must be held to ensure the data is not freed. Objects exposing the &lt;code&gt;__array_struct__&lt;/code&gt; interface must also not reallocate their memory if other objects are referencing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11f88290206147b1d2292d3cc2fdf906b6395b9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; iterator can not be constructed directly from Python code by calling the &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e500f693744c615f08a5f51c892405f5d5b306" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; iterator is returned by &lt;code&gt;x.flat&lt;/code&gt; for any array &lt;code&gt;x&lt;/code&gt;. It allows iterating over the array as if it were a 1-D array, either in a for-loop or by calling its &lt;code&gt;next&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d941e878ab7108e7bbf0d91be33cc4179ce09f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, a value that may be used to replace the invalid entries in order to return a standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c0e6b144ca0dcf2ee709917a46a6ccb8b09579" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28900dc17201a4b7d2d4e25e648ec5859c4a33a8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file that includes the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; directives given above will produce wrapper code that looks something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3b0be790d0fdf5f3b2fb4de6fcbf8a68d09af2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macro (&lt;code&gt;%numpy_typemaps&lt;/code&gt;) with three arguments for implementing the 74 argument signatures for the user&amp;rsquo;s choice of (1) C data type, (2) NumPy data type (assuming they match), and (3) dimension type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e1d33a8a4d82642a6d603db2c91670f3c4706f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e74f3240b3d2bc71fd1a27edc06864a12be76b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6baa143c5214b0736e3c20c3d4d2133fd2d5b196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;M&lt;/code&gt; matrix where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1340f5e4772d7953f77838549f8ae4823c3c29fc" translate="yes" xml:space="preserve">
          <source>A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;, which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fa9801a3e658bde1343a6710ebd94019b0e987" translate="yes" xml:space="preserve">
          <source>A BitGenerator should call this method in its constructor with an appropriate &lt;code&gt;n_words&lt;/code&gt; parameter to properly seed itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c89b0af7257bacc92f4242dd8f1ed7de4e6a82" translate="yes" xml:space="preserve">
          <source>A Chebyshev series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5a3fc40b8c00875c7adc6fafc877312612fb23" translate="yes" xml:space="preserve">
          <source>A Common Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f058bb1e26a110b25c03cc8d4fb8973dcf766" translate="yes" xml:space="preserve">
          <source>A Final Note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd3cc1095a7280cde1f0d6c177498d32c136fd7" translate="yes" xml:space="preserve">
          <source>A Laguerre series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f400cf9c7b159d607ff23b034ffd4be1a606224f" translate="yes" xml:space="preserve">
          <source>A Legendre series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99e7b91acb5be86a4e5f503122861650a2ccb0d" translate="yes" xml:space="preserve">
          <source>A MaskedArray is always returned, regardless of the input type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d620fcc0619adea6d0d19bc96c8ee23d44af8093" translate="yes" xml:space="preserve">
          <source>A Python object describing the data-type in more detail (same as the &lt;em&gt;descr&lt;/em&gt; key in &lt;a href=&quot;arrays.interface#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt;). This can be &lt;code&gt;NULL&lt;/code&gt; if &lt;em&gt;typekind&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt; provide enough information. This field is also ignored unless &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; flag is on in &lt;em&gt;flags&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811b8ce90b99eebd82cee1bee20d5f2dc5026de4" translate="yes" xml:space="preserve">
          <source>A SciPy package contains, in addition to its sources, the following files and directories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e40f23352d29ee547ed495acb06d3278d345225" translate="yes" xml:space="preserve">
          <source>A basic format in this context is an optional shape specifier followed by an array-protocol type string. Parenthesis are required on the shape if it has more than one dimension. NumPy allows a modification on the format in that any string that can uniquely identify the type can be used to specify the data-type in a field. The generated data-type fields are named &lt;code&gt;'f0'&lt;/code&gt;, &lt;code&gt;'f1'&lt;/code&gt;, &amp;hellip;, &lt;code&gt;'f&amp;lt;N-1&amp;gt;'&lt;/code&gt; where N (&amp;gt;1) is the number of comma-separated basic formats in the string. If the optional shape specifier is provided, then the data-type for the corresponding field describes a sub-array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33714726200551e610770d7ae55c0ed9c8005e6f" translate="yes" xml:space="preserve">
          <source>A beta value of 14 is probably a good starting point. Note that as beta gets large, the window narrows, and so the number of samples needs to be large enough to sample the increasingly narrow spike, otherwise NaNs will get returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730a2f7351bc145102343cc14dc57118d72de04f" translate="yes" xml:space="preserve">
          <source>A bit-width name for this data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af66384dd9d2d25f2f246ac418a92d8c8bea0503" translate="yes" xml:space="preserve">
          <source>A boolean &lt;a href=&quot;#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; with the same shape as the data, where a &lt;code&gt;True&lt;/code&gt; value indicates that the corresponding element of the data is invalid. The special value &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is also acceptable for arrays without named fields, and indicates that no data is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2805701b39ac42271d949ffde0dd4bf567d116a" translate="yes" xml:space="preserve">
          <source>A boolean array which is broadcasted to match the dimensions of &lt;code&gt;a&lt;/code&gt;, and selects elements to include in the reduction. Note that for ufuncs like &lt;code&gt;minimum&lt;/code&gt; that do not have an identity defined, one has to pass in also &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f98cff3c08f935f8811f83be9572c3de4637c7" translate="yes" xml:space="preserve">
          <source>A boolean array which is broadcasted to match the dimensions of &lt;code&gt;dst&lt;/code&gt;, and selects elements to copy from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; wherever it contains the value True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78a3585487d30435586ed9706d00090c300e7f0" translate="yes" xml:space="preserve">
          <source>A boolean array with the same dimensions as the input. If second argument is not supplied then a boolean array is returned with values True where the corresponding element of the input is positive infinity and values False where the element of the input is not positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcba5627bf9872aa7674aa396e2821a8c076d34" translate="yes" xml:space="preserve">
          <source>A boolean array with the same dimensions as the input. If second argument is not supplied then a numpy boolean array is returned with values True where the corresponding element of the input is negative infinity and values False where the element of the input is not negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afb7663cac315ffc6aa200bd089e46c012435b5" translate="yes" xml:space="preserve">
          <source>A boolean array with the same shape and type as &lt;code&gt;x&lt;/code&gt; to store the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5662229389d9892b11458d25aa4c0db03cbc85bd" translate="yes" xml:space="preserve">
          <source>A boolean array with the same shape as &lt;code&gt;x&lt;/code&gt; to store the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbedd8a20450a12cb3ee54eea4b82356919f525" translate="yes" xml:space="preserve">
          <source>A boolean mask derived from &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff4d8bf8489691629ea13c670df9523f6f8f2b9" translate="yes" xml:space="preserve">
          <source>A business day calendar object containing the specified weekmask and holidays values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a22219906d7788625c49e0079969b8993164ff" translate="yes" xml:space="preserve">
          <source>A business day calendar object that efficiently stores information defining valid days for the busday family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8695c88255f385733f796bbaedd0461b7eef4b10" translate="yes" xml:space="preserve">
          <source>A character code (one of &amp;lsquo;biufcmMOSUV&amp;rsquo;) identifying the general kind of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9816b39af0a9d971aeef29e0be64e9e1da496e15" translate="yes" xml:space="preserve">
          <source>A character code indicating the kind of array (using the array interface typestring notation). A &amp;lsquo;b&amp;rsquo; represents Boolean, a &amp;lsquo;i&amp;rsquo; represents signed integer, a &amp;lsquo;u&amp;rsquo; represents unsigned integer, &amp;lsquo;f&amp;rsquo; represents floating point, &amp;lsquo;c&amp;rsquo; represents complex floating point, &amp;lsquo;S&amp;rsquo; represents 8-bit zero-terminated bytes, &amp;lsquo;U&amp;rsquo; represents 32-bit/character unicode string, and &amp;lsquo;V&amp;rsquo; represents arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640835ce5b60ee0611de8f1a565fb1483f0f6116" translate="yes" xml:space="preserve">
          <source>A character indicating the byte-order of this data-type object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10949fd1b1a46dea97602b78abe6497f1b34bcec" translate="yes" xml:space="preserve">
          <source>A character indicating the byte-order: &amp;lsquo;&amp;gt;&amp;rsquo; (big-endian), &amp;lsquo;&amp;lt;&amp;rsquo; (little- endian), &amp;lsquo;=&amp;rsquo; (native), &amp;lsquo;|&amp;rsquo; (irrelevant, ignore). All builtin data- types have byteorder &amp;lsquo;=&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4cdc18aee1de79b93ad2db60b3cb6c05440fae" translate="yes" xml:space="preserve">
          <source>A character indicating what kind of array is present according to the typestring convention with &amp;lsquo;t&amp;rsquo; -&amp;gt; bitfield, &amp;lsquo;b&amp;rsquo; -&amp;gt; Boolean, &amp;lsquo;i&amp;rsquo; -&amp;gt; signed integer, &amp;lsquo;u&amp;rsquo; -&amp;gt; unsigned integer, &amp;lsquo;f&amp;rsquo; -&amp;gt; floating point, &amp;lsquo;c&amp;rsquo; -&amp;gt; complex floating point, &amp;lsquo;O&amp;rsquo; -&amp;gt; object, &amp;lsquo;S&amp;rsquo; -&amp;gt; (byte-)string, &amp;lsquo;U&amp;rsquo; -&amp;gt; unicode, &amp;lsquo;V&amp;rsquo; -&amp;gt; void.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3c3cf78f0d1936ea320553b4c652bd35ed2232" translate="yes" xml:space="preserve">
          <source>A combination [int, array] or [array, int], where int is the number of bins and array is the bin edges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd60264664d8586a11ad4343a10732839c215699" translate="yes" xml:space="preserve">
          <source>A common case in NumPy functions is to have outputs allocated based on the broadcasting of the input, and additionally have an optional parameter called &amp;lsquo;out&amp;rsquo; where the result will be placed when it is provided. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a convenient idiom that makes it very easy to support this mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e1a45a8be43e8f336307abe5613c812f9c3ff0" translate="yes" xml:space="preserve">
          <source>A common use case for this is filtering for desired element values. For example one may wish to select all entries from an array which are not NaN:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1deb505aba0dee9bc57b64427ffaacea33af840" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;nonzero&lt;/code&gt; is to find the indices of an array, where a condition is True. Given an array &lt;code&gt;a&lt;/code&gt;, the condition &lt;code&gt;a&lt;/code&gt; &amp;gt; 3 is a boolean array and since False is interpreted as 0, ma.nonzero(a &amp;gt; 3) yields the indices of the &lt;code&gt;a&lt;/code&gt; where the condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10789a39601bd0ec3a09e1bcad97963a039079f" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;nonzero&lt;/code&gt; is to find the indices of an array, where a condition is True. Given an array &lt;code&gt;a&lt;/code&gt;, the condition &lt;code&gt;a&lt;/code&gt; &amp;gt; 3 is a boolean array and since False is interpreted as 0, np.nonzero(a &amp;gt; 3) yields the indices of the &lt;code&gt;a&lt;/code&gt; where the condition is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c327d5ba1c1107eecd64cf160d7a3c3b72c1398" translate="yes" xml:space="preserve">
          <source>A complex number or sequence of complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0cfa11c1789a966650ad3c5878d84e46b3ac64" translate="yes" xml:space="preserve">
          <source>A complex- or real-valued matrix whose eigenvalues are to be computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6ecf1ca51aead983c8d0521be2a8d9c2c969cb" translate="yes" xml:space="preserve">
          <source>A complex- or real-valued matrix whose eigenvalues will be computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846e9c828a6dacb3e9b0f03c4bf9ede31aa0b250" translate="yes" xml:space="preserve">
          <source>A compromise to get a good value. For small datasets the Sturges value will usually be chosen, while larger datasets will usually default to FD. Avoids the overly conservative behaviour of FD and Sturges for small and large datasets respectively. Switchover point is usually</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e1ddd8fad2d5da09a556c355d68b360223b6d1" translate="yes" xml:space="preserve">
          <source>A consensus of datetime64 users agreed that this behavior is undesirable and at odds with how datetime64 is usually used (e.g., by &lt;a href=&quot;http://pandas.pydata.org&quot;&gt;pandas&lt;/a&gt;). For most use cases, a timezone naive datetime type is preferred, similar to the &lt;code&gt;datetime.datetime&lt;/code&gt; type in the Python standard library. Accordingly, datetime64 no longer assumes that input is in local time, nor does it print local times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e341e4c13ef8eaa977a5ceb53e0656085e29c24c" translate="yes" xml:space="preserve">
          <source>A convenience class, used to encapsulate &amp;ldquo;natural&amp;rdquo; operations on polynomials so that said operations may take on their customary form in code (see Examples).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151620da811c85a7079865f27be65ea6f5b0587f" translate="yes" xml:space="preserve">
          <source>A convenient alias for None, useful for indexing arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2be79f4ed756589d21e373791f3f50d6d864035" translate="yes" xml:space="preserve">
          <source>A convenient way to execute examples is the &lt;code&gt;%doctest_mode&lt;/code&gt; mode of IPython, which allows for pasting of multi-line examples and preserves indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30abac0c126f9bd71a6c782f2b03c3c3aba2c57f" translate="yes" xml:space="preserve">
          <source>A copy is performed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa36776969d9a57dc8d794768fefaeedefecd72" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; appended to &lt;code&gt;axis&lt;/code&gt;. Note that &lt;a href=&quot;#numpy.ma.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is allocated and filled. If &lt;code&gt;axis&lt;/code&gt; is None, the result is a flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddd8698ec4c36f13446d06850216b55d57301cb" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;a&lt;/code&gt; without the slices along axis for which &lt;code&gt;condition&lt;/code&gt; is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e51e10da4f3fc66565226f8d7532becd87cc778" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; appended to &lt;code&gt;axis&lt;/code&gt;. Note that &lt;a href=&quot;#numpy.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is allocated and filled. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92111473d390efd8adf5b878205e8bc603afc606" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; inserted. Note that &lt;a href=&quot;#numpy.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is returned. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b87c9376fbcb3d0b125161eee5f9adf601f6324" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with the elements specified by &lt;code&gt;obj&lt;/code&gt; removed. Note that &lt;a href=&quot;#numpy.delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; does not occur in-place. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5ec484979c813657ea6e12962cceaa803f005f" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;self&lt;/code&gt; with invalid entries replaced by &lt;em&gt;fill_value&lt;/em&gt; (be it the function argument or the attribute of &lt;code&gt;self&lt;/code&gt;), or &lt;code&gt;self&lt;/code&gt; itself as an ndarray if there are no invalid entries to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20929bf6f0f5783301a154635f1db6c0f7b0847c" translate="yes" xml:space="preserve">
          <source>A copy of the holiday array indicating additional invalid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f8a7d3c63e1b73ba667b3bf1e267f936c633fe" translate="yes" xml:space="preserve">
          <source>A copy of the input array, flattened to one dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da11f2afa7a132e72b7e8d106c881e77fd49d7b" translate="yes" xml:space="preserve">
          <source>A copy of the input data as a list of 1-d arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ec4d1c7d29fce0bbbb2b93588b5082ae76dce1" translate="yes" xml:space="preserve">
          <source>A copy of the matrix, flattened to a &lt;code&gt;(1, N)&lt;/code&gt; matrix where &lt;code&gt;N&lt;/code&gt; is the number of elements in the original matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8ccf8212225ee2362f20a54059f106604c4c8e" translate="yes" xml:space="preserve">
          <source>A copy of the seven-element boolean mask indicating valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48da051f6fb411e5d7f076156cd5a288fde0f19f" translate="yes" xml:space="preserve">
          <source>A copy of the specified element of the array as a suitable Python scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bc1a9690ca89addc6fd0c521d335f7301cabfb" translate="yes" xml:space="preserve">
          <source>A couple examples illustrating how choose broadcasts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c55eeffdc406262a02700dff6759d4344a8e15" translate="yes" xml:space="preserve">
          <source>A ctype scalar, union, array, or struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d35563e75151cc0dbb5c5b566817578403fc0ff" translate="yes" xml:space="preserve">
          <source>A ctypes library object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e5cd9e7ac36feddf15161fea7659065ed8c0ab" translate="yes" xml:space="preserve">
          <source>A custom formatter can be used to display array elements as desired:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f7b6a83ce973c0c5ab9720eba75e9be43c8cc7" translate="yes" xml:space="preserve">
          <source>A data type object (an instance of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; class) describes how the bytes in the fixed-size block of memory corresponding to an array item should be interpreted. It describes the following aspects of the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e711db1425e16cacba4452fb8206715d7336cab" translate="yes" xml:space="preserve">
          <source>A data-type bit-flag that determines if the data-type exhibits object- array like behavior. Each bit in this member is a flag which are named as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a302bf74f669a81b79d991c1f7d62a9555dbdfb" translate="yes" xml:space="preserve">
          <source>A data-type scalar that allows field access as attribute lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4587893c1e5eca1b7c042f70853952070073a28c" translate="yes" xml:space="preserve">
          <source>A deprecated version of &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; which depends upon &lt;code&gt;dealloc&lt;/code&gt; to trigger the writeback. For backwards compatibility, &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at &lt;code&gt;dealloc&lt;/code&gt; but relying on that behavior is deprecated and not supported in PyPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1b833307cee9e3cf72cc77b59a40521d42391e" translate="yes" xml:space="preserve">
          <source>A descriptive example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b24a3f9af87d38cf8835043360961c446d5af3" translate="yes" xml:space="preserve">
          <source>A dictionary mapping column number to a function that will parse the column string into the desired value. E.g., if column 0 is a date string: &lt;code&gt;converters = {0: datestr2num}&lt;/code&gt;. Converters can also be used to provide a default value for missing data (but see also &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;): &lt;code&gt;converters = {3: lambda s: float(s.strip() or 0)}&lt;/code&gt;. Default: None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d48692d200a87a18970c15bc3c417bcace59d3" translate="yes" xml:space="preserve">
          <source>A dictionary of items (3 required and 5 optional). The optional keys in the dictionary have implied defaults if they are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcb7b8d8713e202dcb8ec09b8dbd906a4793948" translate="yes" xml:space="preserve">
          <source>A dictionary of user-defined 1-d vector loops (stored as CObject ptrs) for user-defined types. A loop may be registered by the user for any user-defined type. It is retrieved by type number. User defined type numbers are always larger than &lt;a href=&quot;c-api.dtype#c.NPY_USERDEF&quot;&gt;&lt;code&gt;NPY_USERDEF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ab9ce9d6d7e21b1f408721fe18d109738fb1b3" translate="yes" xml:space="preserve">
          <source>A dictionary that replaces global operands in current frame. Ignored if &lt;code&gt;obj&lt;/code&gt; is not a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0923166d8e51f518b3d2e18daa42e324c64d0629" translate="yes" xml:space="preserve">
          <source>A dictionary that replaces local operands in current frame. Ignored if &lt;code&gt;obj&lt;/code&gt; is not a string or &lt;code&gt;gdict&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06bcc7d3d4264a6d6419702c27d5d128fee3024e" translate="yes" xml:space="preserve">
          <source>A dictionary with keys &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, and &amp;ldquo;invalid&amp;rdquo;, whose values are from the strings &amp;ldquo;ignore&amp;rdquo;, &amp;ldquo;print&amp;rdquo;, &amp;ldquo;log&amp;rdquo;, &amp;ldquo;warn&amp;rdquo;, &amp;ldquo;raise&amp;rdquo;, and &amp;ldquo;call&amp;rdquo;. The keys represent possible floating-point exceptions, and the values define how these exceptions are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274bd217df99031a1f7ca14224d6a8c744cd94fc" translate="yes" xml:space="preserve">
          <source>A dimension index is an integer representing a dimension name. It enumerates the dimension names according to the order of the first occurrence of each name in the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc19580a731f382683601a5487121a4588f3baec" translate="yes" xml:space="preserve">
          <source>A dimension name represents a core dimension in the signature. Different dimensions may share a name, indicating that they are of the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91d306ab0d3f2790363b14c868a1e01c6605ffa" translate="yes" xml:space="preserve">
          <source>A docstring for each ufunc. The first part of the docstring is dynamically generated from the number of outputs, the name, and the number of inputs. The second part of the docstring is provided at creation time and stored with the ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5a9b4e2f08d90c7582c32e33a8dd3a11c7dba2" translate="yes" xml:space="preserve">
          <source>A dtype that looks like &lt;code&gt;ndtype&lt;/code&gt;, the type of all fields is boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e4680768b858ee23cfd8b02898abfaa7246693" translate="yes" xml:space="preserve">
          <source>A few new C-structures were found to be useful in the development of NumPy. These C-structures are used in at least one C-API call and are therefore documented here. The main reason these structures were defined is to make it easy to use the Python ParseTuple C-API to convert from Python objects to a useful C-Object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56136f42370cc828f6f8282f41aa378eb0668e7" translate="yes" xml:space="preserve">
          <source>A field is a view of the array data with a given data-type. The values in the view are determined by the given type and the offset into the current array in bytes. The offset needs to be such that the view dtype fits in the array dtype; for example an array of dtype complex128 has 16-byte elements. If taking a view with a 32-bit integer (4 bytes), the offset needs to be between 0 and 12 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b21d39d7b2c4b29140daef6f51fe2f038fec79" translate="yes" xml:space="preserve">
          <source>A first possibility is to directly invoke the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eca43eca8b478519a1bb5ce29f20eb48d50d699" translate="yes" xml:space="preserve">
          <source>A fixed bit generator using a fixed seed and a fixed series of calls to &amp;lsquo;RandomState&amp;rsquo; methods using the same parameters will always produce the same results up to roundoff error except when the values were incorrect. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; is effectively frozen and will only receive updates that are required by changes in the the internals of Numpy. More substantial changes, including algorithmic improvements, are reserved for &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40f9bd793de063d4623b3a65127edbc7f4365a2" translate="yes" xml:space="preserve">
          <source>A floating point representation of negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70219492bb06ea1bfc1bd486c51c9d74cdc6eec" translate="yes" xml:space="preserve">
          <source>A floating point representation of negative zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f318ecbc4360f30574687fabbb18b17aece0caea" translate="yes" xml:space="preserve">
          <source>A floating point representation of positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7d4260ed1570b946cfe14c53fa847bec8e3bc4" translate="yes" xml:space="preserve">
          <source>A floating point representation of positive zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e0a8192c1f49ed33c6184804ba93dc807b4510" translate="yes" xml:space="preserve">
          <source>A floating-point array of shape &lt;code&gt;size&lt;/code&gt; of drawn samples, or a single sample if &lt;code&gt;size&lt;/code&gt; was not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf2ce103753b74056842789f48f919368a96b81" translate="yes" xml:space="preserve">
          <source>A format used to define default field names, such as &amp;ldquo;f%i&amp;rdquo; or &amp;ldquo;f_%02i&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6953993ce940fc7ebd16cec3633d5689d9d12107" translate="yes" xml:space="preserve">
          <source>A function that reads &lt;code&gt;n_in&lt;/code&gt; items from &lt;code&gt;in&lt;/code&gt;, and writes to &lt;code&gt;out&lt;/code&gt; the read value if it is within the limits pointed to by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;, or the corresponding limit if outside. The memory segments must be contiguous and behaved, and either &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt;, but not both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7808e8deacae88a30b0157c6432f18e2b157f98e" translate="yes" xml:space="preserve">
          <source>A function that takes a pointer &lt;code&gt;in&lt;/code&gt; to an array of &lt;code&gt;n_in&lt;/code&gt; items, a pointer &lt;code&gt;mask&lt;/code&gt; to an array of &lt;code&gt;n_in&lt;/code&gt; boolean values, and a pointer &lt;code&gt;vals&lt;/code&gt; to an array of &lt;code&gt;nv&lt;/code&gt; items. Items from &lt;code&gt;vals&lt;/code&gt; are copied into &lt;code&gt;in&lt;/code&gt; wherever the value in &lt;code&gt;mask&lt;/code&gt; is non-zero, tiling &lt;code&gt;vals&lt;/code&gt; as needed if &lt;code&gt;nv &amp;lt; n_in&lt;/code&gt;. All arrays must be contiguous and behaved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104738b7ba43a478757ba0cfc95cfc1693132d3a" translate="yes" xml:space="preserve">
          <source>A function that takes a pointer &lt;code&gt;src&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, nindarray, nelem)&lt;/code&gt;, a pointer &lt;code&gt;indarray&lt;/code&gt; to a contiguous, behaved segment of &lt;code&gt;m_middle&lt;/code&gt; integer indices, and a pointer &lt;code&gt;dest&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, m_middle, nelem)&lt;/code&gt;. The indices in &lt;code&gt;indarray&lt;/code&gt; are used to index &lt;code&gt;src&lt;/code&gt; along the second dimension, and copy the corresponding chunks of &lt;code&gt;nelem&lt;/code&gt; items into &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;clipmode&lt;/code&gt; (which can take on the values &lt;a href=&quot;c-api.array#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt;) determines how will indices smaller than 0 or larger than &lt;code&gt;nindarray&lt;/code&gt; will be handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb7204cb0f2bbcfcce745946459084676997fbf" translate="yes" xml:space="preserve">
          <source>A function to INCREF all the objects at the location &lt;em&gt;ptr&lt;/em&gt; according to the data-type &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;ptr&lt;/em&gt; is the start of a structured type with an object at any offset, then this will (recursively) increment the reference count of all object-like items in the structured type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2abd32c85efc7a4a45d18f882ea7390dd2a706" translate="yes" xml:space="preserve">
          <source>A function to XDECREF all the object-like items at the location &lt;em&gt;ptr&lt;/em&gt; as recorded in the data-type, &lt;em&gt;dtype&lt;/em&gt;. This works recursively so that if &lt;code&gt;dtype&lt;/code&gt; itself has fields with data-types that contain object-like items, all the object-like fields will be XDECREF &lt;code&gt;'d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ce3a36b4ee5ac8d172d6bf8491bf2eb17ead79" translate="yes" xml:space="preserve">
          <source>A function to determine how scalars of this type should be interpreted. The argument is &lt;code&gt;NULL&lt;/code&gt; or a 0-dimensional array containing the data (if that is needed to determine the kind of scalar). The return value must be of type &lt;a href=&quot;c-api.array#c.NPY_SCALARKIND&quot;&gt;&lt;code&gt;NPY_SCALARKIND&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b27f94e3fb931693e2774cbba4852a8add55e98" translate="yes" xml:space="preserve">
          <source>A function which resolves the types and fills an array with the dtypes for the inputs and outputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa05609e2a63e5f9fc5e98307d1ff0cf96661165" translate="yes" xml:space="preserve">
          <source>A function which returns an inner loop. The &lt;code&gt;legacy&lt;/code&gt; in the name arises because for NumPy 1.6 a better variant had been planned. This variant has not yet come about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b19ae750da9c4f2d084ff0e9fbbfc38d5ca7e9" translate="yes" xml:space="preserve">
          <source>A function whose call signature is similar to that of &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt;. That is, &lt;code&gt;mask_func(x, k)&lt;/code&gt; returns a boolean array, shaped like &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;k&lt;/code&gt; is an optional argument to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995bd7d70930e4a19e95e761b6d0636c4fb0d572" translate="yes" xml:space="preserve">
          <source>A generalization of this function for N-d arrays, that returns normal ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2cd13996513172bdaffb1dca33e4b60945af7a" translate="yes" xml:space="preserve">
          <source>A generalization to N dimensions and other operations. &lt;code&gt;np.multiply.outer(a.ravel(), b.ravel())&lt;/code&gt; is the equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fbcfb35e19c702c00b11ba0147b99881f61dfb" translate="yes" xml:space="preserve">
          <source>A generic data source file (file, http, ftp, &amp;hellip;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e742e0b647aaf1df5f5d3abb685cf9ccd7d61f19" translate="yes" xml:space="preserve">
          <source>A generic ufunc call. The ufunc is passed in as &lt;em&gt;self&lt;/em&gt;, the arguments to the ufunc as &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt;. The &lt;em&gt;mps&lt;/em&gt; argument is an array of &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; pointers whose values are discarded and which receive the converted input arguments as well as the ufunc outputs when success is returned. The user is responsible for managing this array and receives a new reference for each array in &lt;em&gt;mps&lt;/em&gt;. The total number of arrays in &lt;em&gt;mps&lt;/em&gt; is given by &lt;em&gt;self&lt;/em&gt; -&amp;gt;nin + &lt;em&gt;self&lt;/em&gt; -&amp;gt;nout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4625317d56afc2bf8a1ab930c61261029361d6f" translate="yes" xml:space="preserve">
          <source>A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the &lt;code&gt;tofile&lt;/code&gt; method can be read using this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed398eb719e55b17943429f3e4fdb68c14251c9" translate="yes" xml:space="preserve">
          <source>A list containing the data-types for the different columns, e.g. &lt;code&gt;['i4', 'f8', 'i4']&lt;/code&gt;. &lt;code&gt;formats&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; support the new convention of using types directly, i.e. &lt;code&gt;(int, float, int)&lt;/code&gt;. Note that &lt;code&gt;formats&lt;/code&gt; must be a list, not a tuple. Given that &lt;code&gt;formats&lt;/code&gt; is somewhat limited, we recommend specifying &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da31c2d761b650fc657c3090a468a9da54f9de6" translate="yes" xml:space="preserve">
          <source>A list of D arrays describing the bin edges for each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dccfbefc014a73715a7bf33178f7d4dadc963d9" translate="yes" xml:space="preserve">
          <source>A list of dtypes or dtype convertible objects representing arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca05b514dd6531df90ebf63f10153d3470704d68" translate="yes" xml:space="preserve">
          <source>A list of dtypes or dtype convertible objects representing scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f20e94cc1577ba19bd51fd88c7c894abd02ccc" translate="yes" xml:space="preserve">
          <source>A list of names to exclude. This list is appended to the default list [&amp;lsquo;return&amp;rsquo;,&amp;rsquo;file&amp;rsquo;,&amp;rsquo;print&amp;rsquo;]. Excluded names are appended an underscore: for example, &lt;code&gt;file&lt;/code&gt; would become &lt;code&gt;file_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3d5f54a16228377e53581376ffb48f3c30e87c" translate="yes" xml:space="preserve">
          <source>A list of objects that matched the search is displayed, sorted by relevance. All given keywords need to be found in the docstring for it to be returned as a result, but the order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6f052d201d59387579347a7dac2c74e5309ea5" translate="yes" xml:space="preserve">
          <source>A list of slices (start and end indexes) of unmasked indexes in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd652a1229439a6ceff8e2b412bf54484522702c" translate="yes" xml:space="preserve">
          <source>A list of sub-arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335672ba95b65b1f5d901e9f2df4feaada975adc" translate="yes" xml:space="preserve">
          <source>A list of tuples providing a more detailed description of the memory layout for each item in the homogeneous array. Each tuple in the list has two or three elements. Normally, this attribute would be used when &lt;em&gt;typestr&lt;/em&gt; is &lt;code&gt;V[0-9]+&lt;/code&gt;, but this is not a requirement. The only requirement is that the number of bytes represented in the &lt;em&gt;typestr&lt;/em&gt; key is the same as the total number of bytes represented here. The idea is to support descriptions of C-like structs that make up array elements. The elements of each tuple in the list are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b02866cbd2eb2a4a1f900e5689f4807053a09b" translate="yes" xml:space="preserve">
          <source>A list of tuples with indices of axes a generalized ufunc should operate on. For instance, for a signature of &lt;code&gt;(i,j),(j,k)-&amp;gt;(i,k)&lt;/code&gt; appropriate for matrix multiplication, the base elements are two-dimensional matrices and these are taken to be stored in the two last axes of each argument. The corresponding axes keyword would be &lt;code&gt;[(-2, -1), (-2, -1), (-2, -1)]&lt;/code&gt;. For simplicity, for generalized ufuncs that operate on 1-dimensional arrays (vectors), a single integer is accepted instead of a single-element tuple, and for generalized ufuncs for which all outputs are scalars, the output tuples can be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1931f7fd587f1bfa9304b0a2cf9e0e86ad737bc7" translate="yes" xml:space="preserve">
          <source>A list representation of the einsum path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b8f3fc931ed4758e3c5ae0ca5a041861bb3033" translate="yes" xml:space="preserve">
          <source>A list which will be filled with all matched warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589807e2972076a7140185840f86e44874d938aa" translate="yes" xml:space="preserve">
          <source>A loaded die is more likely to land on number 6:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189d9b82b9c6a5ad123dc2d81bd98cbcce5feec7" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned. For consistency with &lt;code&gt;ufunc.__call__&lt;/code&gt;, if given as a keyword, this may be wrapped in a 1-element tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ff2cf37c49042997e4c4edb219d3f048658fab" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that matches the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ecfd958d8205d0b812a91718af7b311a9c11fe" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7739f26a858b347978a4cfbfb1e35e7d5512c0c" translate="yes" xml:space="preserve">
          <source>A location where the result is stored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d772df58997e4959ba59b176b19f2790ec826fd9" translate="yes" xml:space="preserve">
          <source>A loose wrapper for a C-structure that contains the information needed for looping. This is useful if you are trying to understand the ufunc looping code. The &lt;a href=&quot;#c.PyUFuncLoopObject&quot;&gt;&lt;code&gt;PyUFuncLoopObject&lt;/code&gt;&lt;/a&gt; is the associated C-structure. It is defined in the &lt;code&gt;ufuncobject.h&lt;/code&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210bb7c0a2b1abe6f26b2cdaf9e3f00dc43f0623" translate="yes" xml:space="preserve">
          <source>A loose wrapper for the C-structure that contains the information needed for reduce-like methods of ufuncs. This is useful if you are trying to understand the reduce, accumulate, and reduce-at code. The &lt;a href=&quot;#c.PyUFuncReduceObject&quot;&gt;&lt;code&gt;PyUFuncReduceObject&lt;/code&gt;&lt;/a&gt; is the associated C-structure. It is defined in the &lt;code&gt;ufuncobject.h&lt;/code&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1cb19028cca9983f03bd697ebc873a781f7663" translate="yes" xml:space="preserve">
          <source>A macro that expands to platform-dependent code. The &lt;em&gt;ret&lt;/em&gt; variable can be any integer. The &lt;code&gt;UFUNC_FPE_{ERR}&lt;/code&gt; bits are set in &lt;em&gt;ret&lt;/em&gt; according to the status of the corresponding error flags of the floating point processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28b1832d8de539ad6ac78e4879f653172b81a74" translate="yes" xml:space="preserve">
          <source>A macro used internally to check for errors and goto fail if found. This macro requires a fail label in the current code block. The &lt;em&gt;loop&lt;/em&gt; variable must have at least members (obj, errormask, and errorobj). If &lt;em&gt;loop&lt;/em&gt; -&amp;gt;obj is nonzero, then &lt;a href=&quot;https://docs.python.org/dev/c-api/exceptions.html#c.PyErr_Occurred&quot;&gt;&lt;code&gt;PyErr_Occurred&lt;/code&gt;&lt;/a&gt; () is called (meaning the GIL must be held). If &lt;em&gt;loop&lt;/em&gt; -&amp;gt;obj is zero, then if &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errormask is nonzero, &lt;a href=&quot;#c.PyUFunc_checkfperr&quot;&gt;&lt;code&gt;PyUFunc_checkfperr&lt;/code&gt;&lt;/a&gt; is called with arguments &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errormask and &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errobj. If the result of this check of the IEEE floating point registers is true then the code redirects to the fail label which must be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259aa1241531c8a953c8758b1ac4f41805af1a59" translate="yes" xml:space="preserve">
          <source>A macro which calls the auxdata&amp;rsquo;s clone function appropriately, returning a deep copy of the auxiliary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a68e2152dcf816535a4914a7278ab4814568b2a" translate="yes" xml:space="preserve">
          <source>A macro which calls the auxdata&amp;rsquo;s free function appropriately, does nothing if auxdata is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85dcfb9c03f01d4f635e537884d50fe2361f8ef" translate="yes" xml:space="preserve">
          <source>A masked array can also be created by taking a .view(MaskedArray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52d1200442f679dc576dc7bcd38aabdb0e058c3" translate="yes" xml:space="preserve">
          <source>A masked array is the combination of a standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; and a mask. A mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, indicating that no value of the associated array is invalid, or an array of booleans that determines for each element of the associated array whether the value is valid or not. When an element of the mask is &lt;code&gt;False&lt;/code&gt;, the corresponding element of the associated array is valid and is said to be unmasked. When an element of the mask is &lt;code&gt;True&lt;/code&gt;, the corresponding element of the associated array is said to be masked (invalid).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829b7a94e24ea2654187698ce1c61c946cf592a4" translate="yes" xml:space="preserve">
          <source>A masked array with all data masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a446e834e09b8c95fd907735120b99ef29b40b" translate="yes" xml:space="preserve">
          <source>A matrix of floating-point samples drawn from the standard normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc104aa34da923a98391ba0395e7135b414c1163" translate="yes" xml:space="preserve">
          <source>A matrix with orthonormal columns. When mode = &amp;lsquo;complete&amp;rsquo; the result is an orthogonal/unitary matrix depending on whether or not a is real/complex. The determinant may be either +/- 1 in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53664ffd0d1b20158d240bc21a792bcacea3d14" translate="yes" xml:space="preserve">
          <source>A minimum number of bins for the output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7fbf4a6e300b7306d6e3cc9b3d65c15f44b2ab" translate="yes" xml:space="preserve">
          <source>A modified version of the input array, masked depending on the value of the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6344acf4bd2d798723a4d93d8470321a3ff92ae1" translate="yes" xml:space="preserve">
          <source>A more complex index transformation example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e4296234626cc1940c4e26b6217e094308ce0c" translate="yes" xml:space="preserve">
          <source>A more detailed explanation of strides can be found in the &amp;ldquo;ndarray.rst&amp;rdquo; file in the NumPy reference guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b987c0a601229775f934a75a0acce45184bf47bd" translate="yes" xml:space="preserve">
          <source>A multi-dimensional array example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88e9f525efb508388784dc73a582e741fab97e4" translate="yes" xml:space="preserve">
          <source>A multi-dimensional example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc89d991a8bf05772b7ec899a7daed6b0a8b80a" translate="yes" xml:space="preserve">
          <source>A multidimensional example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee4550ab9483136891754f4bdfd6191512d9294" translate="yes" xml:space="preserve">
          <source>A named repeat rule is useful when the same set of repeats must be used several times in a block. It is specified using &amp;lt;rule1=item1, item2, item3,&amp;hellip;, itemN&amp;gt;, where N is the number of times the block should be repeated. On each repeat of the block, the entire expression, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; will be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Once a named repeat specification has been introduced, the same repeat rule may be used &lt;strong&gt;in the current block&lt;/strong&gt; by referring only to the name (i.e. &amp;lt;rule1&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746f3b414823e7887d26584e61a99960d3d3807d" translate="yes" xml:space="preserve">
          <source>A new 1-D array initialized from text data in a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ecc2ebbb56dcaedff4a2139418dee2fb902a28" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;ndarray&lt;/code&gt; holding the non-masked data is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe219505f265baf36bb811d03f81478d040b90cc" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned. The result has the same size as &lt;code&gt;a&lt;/code&gt;, and the same shape as &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;axis&lt;/code&gt; is not None or &lt;code&gt;a&lt;/code&gt; is a 1-d array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd535d99a931f0449184609f6016354bec2044d6" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to out is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8f859ede56ba26f8769de8c565d9f4c768fea6" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case it is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2320a4eb5e6995b9cc3fe7e2f76f7eeadca85d" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which it is returned. The result has the same size as &lt;code&gt;a&lt;/code&gt;, and the same shape as &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;axis&lt;/code&gt; is not None or &lt;code&gt;a&lt;/code&gt; is a 1-d array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bd872e7a7340bee975d5292cdea5f0a94c2302" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is &lt;code&gt;float64&lt;/code&gt; for integers and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f4bbb0d5737e1005ab85a4c1e5ee3d01d76917" translate="yes" xml:space="preserve">
          <source>A new array holding the result, unless &lt;code&gt;out&lt;/code&gt; was specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6c1410a3a526a9aa31e8ca9eb607d4c83ef200" translate="yes" xml:space="preserve">
          <source>A new array holding the result. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, then the output data-type is &lt;code&gt;np.float64&lt;/code&gt;. Otherwise, the data-type of the output is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dcc14742fa5cf966b623d3902bec2fe90f26ac" translate="yes" xml:space="preserve">
          <source>A new boolean or &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8e1d77c9cfe7d14f562328f05b8db6b12c1a26" translate="yes" xml:space="preserve">
          <source>A new boolean or array is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99912ae944b2b57418e1b7da69ce28ca8ba58a1d" translate="yes" xml:space="preserve">
          <source>A new flexible-type &lt;code&gt;ndarray&lt;/code&gt; with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4010ee58838d1694f9ab9f7b5e871db7356a2d" translate="yes" xml:space="preserve">
          <source>A new polynomial representing the derivative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b4e3cf6c3f9c0bf06df2287ee1b7704ec67fba" translate="yes" xml:space="preserve">
          <source>A new series representing the derivative. The domain is the same as the domain of the differentiated series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf292f7f138c1a85853bbdea5d47f21f0f2e96a1" translate="yes" xml:space="preserve">
          <source>A new series representing the integral. The domain is the same as the domain of the integrated series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97518c3847501702c21aaf46fb19e4284c482dc" translate="yes" xml:space="preserve">
          <source>A new view on the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06077e00197e6db37d041fa326fce614e70e4417" translate="yes" xml:space="preserve">
          <source>A nicer way to build up index tuples for arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d18c9a5816a4fd32587ba2ff5efc11cb522f13" translate="yes" xml:space="preserve">
          <source>A non-exhaustive list of these operations, which can be computed by &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;, is shown below along with examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f39be7ee390b50c936131bbc0227261bdd37433" translate="yes" xml:space="preserve">
          <source>A normal &lt;code&gt;argsort&lt;/code&gt; would have yielded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169aa3ac396274c2b6295b469d82a21e30785967" translate="yes" xml:space="preserve">
          <source>A number providing alignment information for this data type. Specifically, it shows how far from the start of a 2-element structure (whose first element is a &lt;code&gt;char&lt;/code&gt; ), the compiler places an item of this type: &lt;code&gt;offsetof(struct {char c; type v;},
v)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8937103f50695ce6653a16bee8c83a4ae6595480" translate="yes" xml:space="preserve">
          <source>A number representing the sign of the determinant. For a real matrix, this is 1, 0, or -1. For a complex matrix, this is a complex number with absolute value 1 (i.e., it is on the unit circle), or else 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0040a43542844366dbc2263885b6af73ee030ad0" translate="yes" xml:space="preserve">
          <source>A number that uniquely identifies the data type. For new data-types, this number is assigned when the data-type is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64bafda3fffa3a2f2c0d4bdf32a98e5edcb1985" translate="yes" xml:space="preserve">
          <source>A number, an array of numbers, or an instance of poly1d, at which to evaluate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed359e325ef3c86354bbb73ec8a423d46aff3b3c" translate="yes" xml:space="preserve">
          <source>A numpy array is homogeneous, and contains elements described by a dtype object. A dtype object can be constructed from different combinations of fundamental numeric types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcfbbb4a0a9c26532564adde93592102c95f15d" translate="yes" xml:space="preserve">
          <source>A one-dimensional masked array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa893bfe0bd95fab46e15f4d3eccd8809a9d3d5" translate="yes" xml:space="preserve">
          <source>A one-dimensional polynomial class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fff8125898e34535342e18def4fd6d7ee1146c9" translate="yes" xml:space="preserve">
          <source>A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are ignored if &lt;code&gt;period&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b807b86bd0a6c46355a0cf3278bb74297eec4a49" translate="yes" xml:space="preserve">
          <source>A pointer &lt;em&gt;to&lt;/em&gt; the first element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bc66c1a086a47763e1dec2c9b34cd3570a6b58" translate="yes" xml:space="preserve">
          <source>A pointer to a data-type descriptor object (see below). The data-type descriptor object is an instance of a new built-in type which allows a generic description of memory. There is a descriptor structure for each data type supported. This descriptor structure contains useful information about the type as well as a pointer to a table of function pointers to implement specific functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52546cb0757bfc5efa9ebae8156141a177cf5a7" translate="yes" xml:space="preserve">
          <source>A pointer to a function that compares two elements of the array, &lt;code&gt;arr&lt;/code&gt;, pointed to by &lt;code&gt;d1&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;. This function requires behaved (aligned and not swapped) arrays. The return value is 1 if * &lt;code&gt;d1&lt;/code&gt; &amp;gt; * &lt;code&gt;d2&lt;/code&gt;, 0 if * &lt;code&gt;d1&lt;/code&gt; == * &lt;code&gt;d2&lt;/code&gt;, and -1 if * &lt;code&gt;d1&lt;/code&gt; &amp;lt; * &lt;code&gt;d2&lt;/code&gt;. The array object &lt;code&gt;arr&lt;/code&gt; is used to retrieve itemsize and field information for flexible arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc83854e537846a552a3275bf092cf2af85d046" translate="yes" xml:space="preserve">
          <source>A pointer to a function that converts the string pointed to by &lt;code&gt;str&lt;/code&gt; to one element of the corresponding type and places it in the memory location pointed to by &lt;code&gt;ip&lt;/code&gt;. After the conversion is completed, &lt;code&gt;*endptr&lt;/code&gt; points to the rest of the string. The last argument &lt;code&gt;arr&lt;/code&gt; is the array into which ip points (needed for variable-size data- types). Returns 0 on success or -1 on failure. Requires a behaved array. This function should be called without holding the Python GIL, and has to grab it for error reporting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6cc8bae9ddadc31f5ed95f0732f27d78c14f32" translate="yes" xml:space="preserve">
          <source>A pointer to a function that fills a contiguous &lt;code&gt;buffer&lt;/code&gt; of the given &lt;code&gt;length&lt;/code&gt; with a single scalar &lt;code&gt;value&lt;/code&gt; whose address is given. The final argument is the array which is needed to get the itemsize for variable-length arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3910c8d96e5d20400e40452efc26010ea9229ece" translate="yes" xml:space="preserve">
          <source>A pointer to a function that fills a contiguous array of given length with data. The first two elements of the array must already be filled- in. From these two values, a delta will be computed and the values from item 3 to the end will be computed by repeatedly adding this computed delta. The data buffer must be well-behaved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431a234d877bed63a4147682817ee948ed7fbada" translate="yes" xml:space="preserve">
          <source>A pointer to a function that multiplies two &lt;code&gt;n&lt;/code&gt; -length sequences together, adds them, and places the result in element pointed to by &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;arr&lt;/code&gt;. The start of the two sequences are pointed to by &lt;code&gt;ip1&lt;/code&gt; and &lt;code&gt;ip2&lt;/code&gt;. To get to the next element in each sequence requires a jump of &lt;code&gt;is1&lt;/code&gt; and &lt;code&gt;is2&lt;/code&gt;&lt;em&gt;bytes&lt;/em&gt;, respectively. This function requires behaved (though not necessarily contiguous) memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae344cd692cc12af2d04f598d731b117bcbfbcf" translate="yes" xml:space="preserve">
          <source>A pointer to a function that retrieves the index of the largest of &lt;code&gt;n&lt;/code&gt; elements in &lt;code&gt;arr&lt;/code&gt; beginning at the element pointed to by &lt;code&gt;data&lt;/code&gt;. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the largest element is returned in &lt;code&gt;max_ind&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ceac65337b54f9dcdd551d1e9b47510e515aabf" translate="yes" xml:space="preserve">
          <source>A pointer to a function that retrieves the index of the smallest of &lt;code&gt;n&lt;/code&gt; elements in &lt;code&gt;arr&lt;/code&gt; beginning at the element pointed to by &lt;code&gt;data&lt;/code&gt;. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the smallest element is returned in &lt;code&gt;min_ind&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3835d7b1621720aec7eaa6814ef86b756b4dbf87" translate="yes" xml:space="preserve">
          <source>A pointer to a function that returns TRUE if the item of &lt;code&gt;arr&lt;/code&gt; pointed to by &lt;code&gt;data&lt;/code&gt; is nonzero. This function can deal with misbehaved arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475aaf0895b62768be3ac2099d9424549dcf7a83" translate="yes" xml:space="preserve">
          <source>A pointer to a function that returns a standard Python object from a single element of the array object &lt;em&gt;arr&lt;/em&gt; pointed to by &lt;em&gt;data&lt;/em&gt;. This function must be able to deal with &amp;ldquo;misbehaved &amp;ldquo;(misaligned and/or swapped) arrays correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3170ee650911ef94b49078fe0ef12bfaed1cd35b" translate="yes" xml:space="preserve">
          <source>A pointer to a function that scans (scanf style) one element of the corresponding type from the file descriptor &lt;code&gt;fd&lt;/code&gt; into the array memory pointed to by &lt;code&gt;ip&lt;/code&gt;. The array is assumed to be behaved. The last argument &lt;code&gt;arr&lt;/code&gt; is the array to be scanned into. Returns number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or EOF if input failure occurs before the first receiving argument was assigned. This function should be called without holding the Python GIL, and has to grab it for error reporting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5345ed457c10e2b6dd319d2a0f575462b52b35a" translate="yes" xml:space="preserve">
          <source>A pointer to a function that sets the Python object &lt;em&gt;item&lt;/em&gt; into the array, &lt;em&gt;arr&lt;/em&gt;, at the position pointed to by &lt;em&gt;data&lt;/em&gt; . This function deals with &amp;ldquo;misbehaved&amp;rdquo; arrays. If successful, a zero is returned, otherwise, a negative one is returned (and a Python error set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d68822ce5e306e8bf5019318abb9ceb0c735d6" translate="yes" xml:space="preserve">
          <source>A pointer to a list of (&lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;) integers which usually represent array shape or array strides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca11ad9efa9f4f1976179ecad73042ba9578700" translate="yes" xml:space="preserve">
          <source>A pointer to a structure containing functions that the type needs to implement internal features. These functions are not the same thing as the universal functions (ufuncs) described later. Their signatures can vary arbitrarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59953b5554f06beb9b2ea5a5bf0b78689b8252f0" translate="yes" xml:space="preserve">
          <source>A pointer to newly created memory of size &lt;em&gt;arr&lt;/em&gt; -&amp;gt;itemsize that holds the representation of 0 for that type. The returned pointer, &lt;em&gt;ret&lt;/em&gt;, &lt;strong&gt;must be freed&lt;/strong&gt; using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; (ret) when it is not needed anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88743a5469baac06308bedb60aa16a9c06a7a1cc" translate="yes" xml:space="preserve">
          <source>A pointer to newly created memory of size &lt;em&gt;arr&lt;/em&gt; -&amp;gt;itemsize that holds the representation of 1 for that type. The returned pointer, &lt;em&gt;ret&lt;/em&gt;, &lt;strong&gt;must be freed&lt;/strong&gt; using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; (ret) when it is not needed anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952d0c514c338d21716f5fd4d68c9399cc12f085" translate="yes" xml:space="preserve">
          <source>A pointer to the current element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee26ff84fca6762d89892232d01d8f2be0bdf6b" translate="yes" xml:space="preserve">
          <source>A pointer to the first element of the array. This pointer can (and normally should) be recast to the data type of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a9a21805ab17dfeac09889fcec479dcf32412f" translate="yes" xml:space="preserve">
          <source>A pointer to the memory area of the array as a Python integer. This memory area may contain data that is not aligned, or not in correct byte-order. The memory area may not even be writeable. The array flags and data-type of this array should be respected when passing this attribute to arbitrary C-code to avoid trouble that can include Python crashing. User Beware! The value of this attribute is exactly the same as &lt;code&gt;self._array_interface_['data'][0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a0ddabcc83c93156f54a9c4e5e12e5440e1811" translate="yes" xml:space="preserve">
          <source>A pointer to the number of bytes to jump to get to the next element in this dimension for each of the input and output arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e72ad73c814139adc82a2dd23d234600ecd52c" translate="yes" xml:space="preserve">
          <source>A pointer to the size of the dimension over which this function is looping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32e8bc9cebeb7ce19737bb101702a66d6ad1687" translate="yes" xml:space="preserve">
          <source>A pointer to the start of the single-segment chunk of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f57ac5d68543b1b89ec36367f4ed4ba98cb9a0b" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying ndarray this iterator was created to represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a905832ada81de251c9fef160b03726a6aa39266" translate="yes" xml:space="preserve">
          <source>A polynomial class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0454333d741ede4c1731a6f584bd036397a70818" translate="yes" xml:space="preserve">
          <source>A possible use of &lt;code&gt;bincount&lt;/code&gt; is to perform sums over variable-size chunks of an array, using the &lt;code&gt;weights&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba8e35dba23bc8041a6e079b6a83f9598e8027c" translate="yes" xml:space="preserve">
          <source>A power series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360614eff4e9b482c7ccb1687741451d3292c036" translate="yes" xml:space="preserve">
          <source>A printable representation of the einsum path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ffb246c9560ea1d618d450ea896e76b209e6bc" translate="yes" xml:space="preserve">
          <source>A python function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821cd21cf38135598cfbfe30d5b97393e8433ef0" translate="yes" xml:space="preserve">
          <source>A rank 1 array already padded with zeros. Padded values are vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52cd7b1f61334c54c920333fad88ab94ddc81b5" translate="yes" xml:space="preserve">
          <source>A readonly view on the original array with the given shape. It is typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b389c5737b120f8a3ba90ec279ff102ef606b7d1" translate="yes" xml:space="preserve">
          <source>A real or complex array with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd53e5dc7f86931b1547c68a8b6d4fe1dd602c8c" translate="yes" xml:space="preserve">
          <source>A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5947a5967a2d439c4597c86e8bee99e04c20ca77" translate="yes" xml:space="preserve">
          <source>A real world example. A company drills wild-cat oil exploration wells, each with an estimated probability of success of 0.1. What is the probability of having one success for each successive well, that is what is the probability of a single success after drilling 5 wells, after 6 wells, etc.?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c74562d8979b3390f8b232c8d1dfde0b8a3f6d" translate="yes" xml:space="preserve">
          <source>A recent addition to &lt;code&gt;numpy.i&lt;/code&gt; are typemaps that permit argout arrays with views into memory that is managed. See the discussion &lt;a href=&quot;http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe89375cc42c612714476798303a241ab8be3adb" translate="yes" xml:space="preserve">
          <source>A reduce-like operation on an array with a data-type that has a range &amp;ldquo;too small&amp;rdquo; to handle the result will silently wrap. One should use &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; to increase the size of the data-type over which reduction takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a7a274041ceccc88ee2a54369682b28d0f8f72" translate="yes" xml:space="preserve">
          <source>A reference to the array that is iterated over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c25cce5015e79149d448b806d435904b953adc" translate="yes" xml:space="preserve">
          <source>A return of True does not necessarily mean that the two arrays share any element. It just means that they &lt;em&gt;might&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17df53d6df96ba2281763f3f5b0b2adebfd2975d" translate="yes" xml:space="preserve">
          <source>A rotated view of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22190750f3f50985b63589eae0fdf601ec030ee6" translate="yes" xml:space="preserve">
          <source>A second possibility is to modify the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; directly, but this usage is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1503f40b41df4c31b9ad3f11d30b5aa1e01767eb" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the two masked array constructors, &lt;a href=&quot;generated/numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.masked_array#numpy.ma.masked_array&quot;&gt;&lt;code&gt;masked_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a12806d879a1f49595c81b483ba154ce122b36b" translate="yes" xml:space="preserve">
          <source>A seed sequence for BitGenerators with no need for seed state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c226a62e6ab2149724331fa10d2fa8de3a8461e2" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;code&gt;SeedSequence&lt;/code&gt; to derive the initial &lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in an implementor of the &lt;a href=&quot;numpy.random.bit_generator.iseedsequence#numpy.random.bit_generator.ISeedSequence&quot;&gt;&lt;code&gt;ISeedSequence&lt;/code&gt;&lt;/a&gt; interface like &lt;code&gt;SeedSequence&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c822346cadbdc847b8cededc6c64abb2064a522" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;code&gt;BitGenerator&lt;/code&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to derive the initial &lt;code&gt;BitGenerator&lt;/code&gt; state. One may also pass in an implementor of the &lt;code&gt;ISeedSequence&lt;/code&gt; interface like &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;. Additionally, when passed a &lt;code&gt;BitGenerator&lt;/code&gt;, it will be wrapped by &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. If passed a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, it will be returned unaltered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297424ddec64c8c13c80221c2b5c2561d8b3dca1" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;code&gt;BitGenerator&lt;/code&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;code&gt;SeedSequence&lt;/code&gt; to derive the initial &lt;code&gt;BitGenerator&lt;/code&gt; state. One may also pass in an implementor of the &lt;code&gt;ISeedSequence&lt;/code&gt; interface like &lt;code&gt;SeedSequence&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57449a616b2733913d6c035b16ff8031a0c0309b" translate="yes" xml:space="preserve">
          <source>A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an &lt;em&gt;N&lt;/em&gt;-dimensional array in a 1-dimensional block. NumPy is flexible, and &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects can accommodate any &lt;em&gt;strided indexing scheme&lt;/em&gt;. In a strided scheme, the N-dimensional index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b71b624e002466d8dce52c6acba138c61b95ef" translate="yes" xml:space="preserve">
          <source>A sequence of arrays describing the monotonically increasing bin edges along each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb659abce8099a5d28b1e3c93c69644abcc5c2a2" translate="yes" xml:space="preserve">
          <source>A sequence of length D, each an optional (lower, upper) tuple giving the outer bin edges to be used if the edges are not given explicitly in &lt;code&gt;bins&lt;/code&gt;. An entry of None in the sequence results in the minimum and maximum values being used for the corresponding dimension. The default, None, is equivalent to passing a tuple of D None values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bbfb50533f2d3f2a4fd7fa0b51f48f0e734f02" translate="yes" xml:space="preserve">
          <source>A sequence of polynomial roots, or a square array or matrix object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ceb930ec244dcfda247cc2f0b11b4fd68f2536" translate="yes" xml:space="preserve">
          <source>A series of the same kind as the calling class and equal to &lt;code&gt;series&lt;/code&gt; when evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5057709f0bb39c2821cc05f21d054a694afcfad5" translate="yes" xml:space="preserve">
          <source>A series that represents the least squares fit to the data and has the domain and window specified in the call. If the coefficients for the unscaled and unshifted basis polynomials are of interest, do &lt;code&gt;new_series.convert().coef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1310a301fbe7183e2ce95e09f01f8a3d3a00c649" translate="yes" xml:space="preserve">
          <source>A series with the coefficient of the &lt;code&gt;deg&lt;/code&gt; term set to one and all others zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34501fdb58052d0c2fa5b147e753287dfd92f3af" translate="yes" xml:space="preserve">
          <source>A set of arrays is called &amp;ldquo;broadcastable&amp;rdquo; to the same shape if the above rules produce a valid result, &lt;em&gt;i.e.&lt;/em&gt;, one of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd60c6042a9c4728d8686f9ccb469161417ae1d" translate="yes" xml:space="preserve">
          <source>A set of ndarrays (or a single ndarray if there is only one dimension) corresponding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c527df312fef559bad352556ab86e1b52514f7" translate="yes" xml:space="preserve">
          <source>A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like &amp;lsquo;1111100&amp;rsquo;; or a string like &amp;ldquo;Mon Tue Wed Thu Fri&amp;rdquo;, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b5c5f4e4e338a83df129a84a05152158bc31fb" translate="yes" xml:space="preserve">
          <source>A short (typically single-character) string that represents a data type in numpy and corresponds to &lt;code&gt;self.typeStr&lt;/code&gt;. For example, if &lt;code&gt;self.typeStr&lt;/code&gt; is &lt;code&gt;&quot;double&quot;&lt;/code&gt;, then &lt;code&gt;self.typeCode&lt;/code&gt; should be &lt;code&gt;&quot;d&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55a234c7e08a3a8270c585bca1826465f16b1d3" translate="yes" xml:space="preserve">
          <source>A short repeat rule looks like &amp;lt;item1, item2, item3, &amp;hellip;, itemN&amp;gt;. The rule specifies that the entire expression, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; should be replaced first with item1, and then with item2, and so forth until N repeats are accomplished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb221c54cae8ae542f146eae648a4dc67ac0bda" translate="yes" xml:space="preserve">
          <source>A short-hand notation for specifying the format of a structured data type is a comma-separated string of basic formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1ddd23d8920cdacf644ae54f8c0e534ba570de" translate="yes" xml:space="preserve">
          <source>A side-effect of transforming a masked array into a flexible &lt;code&gt;ndarray&lt;/code&gt; is that meta information (&lt;code&gt;fill_value&lt;/code&gt;, &amp;hellip;) will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef5bd6e53370c679df60531a5915557eff674e0" translate="yes" xml:space="preserve">
          <source>A signal value guaranteed not to be a valid type enumeration number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f824cc83e3f63719d08123a34f5bfe79a99c6a77" translate="yes" xml:space="preserve">
          <source>A signature is a string describing the input/output dimensions of the elementary function of a ufunc. See section below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c83eae43f6ab6ce5f1574a2b3173c9326b00ba" translate="yes" xml:space="preserve">
          <source>A simple ISO date:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2087f59f2fa38fce8e5fd9aad38ee596ccc3d8af" translate="yes" xml:space="preserve">
          <source>A simple data type containing a 32-bit big-endian integer: (see &lt;a href=&quot;#arrays-dtypes-constructing&quot;&gt;Specifying and constructing data types&lt;/a&gt; for details on construction)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593a67c8ad8a28c370a51733b480fae1403014ec" translate="yes" xml:space="preserve">
          <source>A simple format for saving numpy arrays to disk with the full information about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f34710a7684ff79fd871bcf98300fc810e986e" translate="yes" xml:space="preserve">
          <source>A simple interface to the IEEE error-flag checking support. The &lt;em&gt;errmask&lt;/em&gt; argument is a mask of &lt;code&gt;UFUNC_MASK_{ERR}&lt;/code&gt; bitmasks indicating which errors to check for (and how to check for them). The &lt;em&gt;errobj&lt;/em&gt; must be a Python tuple with two elements: a string containing the name which will be used in any communication of error and either a callable Python object (call-back function) or &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;. The callable object will only be used if &lt;code&gt;UFUNC_ERR_CALL&lt;/code&gt; is set as the desired error checking method. This routine manages the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible hardware is determined a -1 is returned, otherwise a 0 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f651ca7550d656d6c3f3ed82c4b589e375b548" translate="yes" xml:space="preserve">
          <source>A simple linked-list of C-structures containing the information needed to define a 1-d loop for a ufunc for every defined signature of a user-defined data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee5d4bece8f223e1b2634c3eec8ea6c05d6636a" translate="yes" xml:space="preserve">
          <source>A simple module that only uses a single &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file should include the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d93ce0346cd0a5029dbb7dc011a271c7317bfe" translate="yes" xml:space="preserve">
          <source>A simplified interface to broadcasting. This function takes the number of arrays to broadcast and then &lt;em&gt;num&lt;/em&gt; extra ( &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; ) arguments. These arguments are converted to arrays and iterators are created. &lt;a href=&quot;#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; is then called on the resulting multi-iterator object. The resulting, broadcasted mult-iterator object is then returned. A broadcasted operation can then be performed using a single loop and using &lt;a href=&quot;#c.PyArray_MultiIter_NEXT&quot;&gt;&lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt;&lt;/a&gt; (..)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28984f56b20efb716a65187c5ff200fdda38c42b" translate="yes" xml:space="preserve">
          <source>A single axis over which a generalized ufunc should operate. This is a short-cut for ufuncs that operate over a single, shared core dimension, equivalent to passing in &lt;code&gt;axes&lt;/code&gt; with entries of &lt;code&gt;(axis,)&lt;/code&gt; for each single-core-dimension argument and &lt;code&gt;()&lt;/code&gt; for all others. For instance, for a signature &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;, it is equivalent to passing in &lt;code&gt;axes=[(axis,), (axis,), ()]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecd974678a25bce6d0bb21975fdb524aa51f881" translate="yes" xml:space="preserve">
          <source>A single format (%10.5f), a sequence of formats, or a multi-format string, e.g. &amp;lsquo;Iteration %d &amp;ndash; %10.5f&amp;rsquo;, in which case &lt;code&gt;delimiter&lt;/code&gt; is ignored. For complex &lt;code&gt;X&lt;/code&gt;, the legal options for &lt;code&gt;fmt&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f72626ebddb5f9ee710e36e21cf37f297c4305c" translate="yes" xml:space="preserve">
          <source>A sorted sequence of &lt;code&gt;slice&lt;/code&gt; objects (start index, end index).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59026a2e0815a0ce41083ddb7ee186606c6d091" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc24fea5b7eed9eceb13972942907ac09867998" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.mtrand.randomstate.standard_normal#numpy.random.mtrand.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e6ec7e623d9c397e9c59873fafb24c4baac24c" translate="yes" xml:space="preserve">
          <source>A special variable type indicating the number of &amp;ldquo;kinds&amp;rdquo; of scalars distinguished in determining scalar-coercion rules. This variable can take on the values &lt;code&gt;NPY_{KIND}&lt;/code&gt; where &lt;code&gt;{KIND}&lt;/code&gt; can be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00866a4cd9f695363bff3007afb5f20a623db3b3" translate="yes" xml:space="preserve">
          <source>A special variable-type which can take on the values &lt;code&gt;NPY_{KIND}&lt;/code&gt; where &lt;code&gt;{KIND}&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a5231cd4b10f823ce716dfaa60723246dd2c6d" translate="yes" xml:space="preserve">
          <source>A specialized copy and transpose function that works only for 2-d arrays. The returned array is a transposed copy of &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774ff5fbcb64cd63fcb41a3daa1076f5946c7ae1" translate="yes" xml:space="preserve">
          <source>A string combining invalid characters that must be deleted from the names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a384e3c2e6a14cf6c36ba5a2e36844384b8f3f" translate="yes" xml:space="preserve">
          <source>A string containing the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92fb30e44bde7fa02db5d823fe26a99afa2efe0" translate="yes" xml:space="preserve">
          <source>A string integer specifies which axis to stack multiple comma separated arrays along. A string of two comma-separated integers allows indication of the minimum number of dimensions to force each entry into as the second integer (the axis to concatenate along is still the first integer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641af276b72e55102c42cfb585abb388eea7dfe" translate="yes" xml:space="preserve">
          <source>A string name for the ufunc. This is used dynamically to build the __doc__ attribute of ufuncs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114cd592cdf4bef478ab0fc63ad99238e2d8ce95" translate="yes" xml:space="preserve">
          <source>A string naming the dump file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292579b654816d2d1cb9494934238580c48fc2c0" translate="yes" xml:space="preserve">
          <source>A string providing a name associated with this portion of the datatype. This could also be a tuple of &lt;code&gt;('full name',
'basic_name')&lt;/code&gt; where basic name would be a valid Python variable name representing the full name of the field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619f5c1475ced21cf4fa25f8cd5302b1602c1052" translate="yes" xml:space="preserve">
          <source>A string providing the basic type of the homogenous array The basic string format consists of 3 parts: a character describing the byteorder of the data (&lt;code&gt;&amp;lt;&lt;/code&gt;: little-endian, &lt;code&gt;&amp;gt;&lt;/code&gt;: big-endian, &lt;code&gt;|&lt;/code&gt;: not-relevant), a character code giving the basic type of the array, and an integer providing the number of bytes the type uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90aac579586e4ebd136c30a26daae199bbf4715" translate="yes" xml:space="preserve">
          <source>A string that matches one of the &lt;code&gt;SNAME&lt;/code&gt; prefixes used in &lt;code&gt;Vector.h&lt;/code&gt; and &lt;code&gt;Vector.cxx&lt;/code&gt;. For example, &lt;code&gt;&quot;double&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a21b6388a76d32ee94fe75187d475e1e9a31be" translate="yes" xml:space="preserve">
          <source>A string with &amp;lsquo;f&amp;rsquo; representing trim from front and &amp;lsquo;b&amp;rsquo; to trim from back. Default is &amp;lsquo;fb&amp;rsquo;, trim zeros from both front and back of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5fc7d583671fa3d14d3cf2a8c5d45637921d25" translate="yes" xml:space="preserve">
          <source>A string with three comma-separated integers allows specification of the axis to concatenate along, the minimum number of dimensions to force the entries to, and which axis should contain the start of the arrays which are less than the specified number of dimensions. In other words the third integer allows you to specify where the 1&amp;rsquo;s should be placed in the shape of the arrays that have their shapes upgraded. By default, they are placed in the front of the shape tuple. The third argument allows you to specify where the start of the array should be instead. Thus, a third argument of &amp;lsquo;0&amp;rsquo; would place the 1&amp;rsquo;s at the end of the array shape. Negative integers specify where in the new shape tuple the last dimension of upgraded arrays should be placed, so the default is &amp;lsquo;-1&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d2ae7b6da7c3e66b0ffab924afae035a474e84" translate="yes" xml:space="preserve">
          <source>A structured data type containing a 16-character string (in field &amp;lsquo;name&amp;rsquo;) and a sub-array of two 64-bit floating-point number (in field &amp;lsquo;grades&amp;rsquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f180152a86fa9b648a6bab2cda7a10f4905a48b6" translate="yes" xml:space="preserve">
          <source>A subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; designed to manipulate numerical arrays with missing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9d85237edf034be6cf9bf1e244b291b0aee63a" translate="yes" xml:space="preserve">
          <source>A synonym for PyArray_DESCR, named to be consistent with the &amp;lsquo;dtype&amp;rsquo; usage within Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2681289891032d09b18ed94e9f65a0e2826ff47" translate="yes" xml:space="preserve">
          <source>A synonym for PyArray_DIMS, named to be consistent with the &amp;lsquo;shape&amp;rsquo; usage within Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4410cbe0b9f7cf51e2244cb7c5c5dd5f8dc17d" translate="yes" xml:space="preserve">
          <source>A third option is to take the view of an existing array. In that case, the mask of the view is set to &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; if the array has no named fields, or an array of boolean with the same structure as the array otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f636d16ad05af695598dcc38696ba8fa663d5b8" translate="yes" xml:space="preserve">
          <source>A third source of entropy, used internally when calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c732466671bb9ce60ffffbea1204a8445e601bb" translate="yes" xml:space="preserve">
          <source>A total of the number of skipped and known failing tests is displayed at the end of the test run. Skipped tests are marked as &lt;code&gt;'S'&lt;/code&gt; in the test results (or &lt;code&gt;'SKIPPED'&lt;/code&gt; for &lt;code&gt;verbose &amp;gt; 1&lt;/code&gt;), and known failing tests are marked as &lt;code&gt;'x'&lt;/code&gt; (or &lt;code&gt;'XFAIL'&lt;/code&gt; if &lt;code&gt;verbose &amp;gt;
1&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f95a5aede16bea5ef8a6ca146177fb6b3b182" translate="yes" xml:space="preserve">
          <source>A traditional character code indicating the data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2b4cceb7cfb51035a175e0d658850c2512647b" translate="yes" xml:space="preserve">
          <source>A tuple indicating the shape of the mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c14115771a7d712b28ce39ebe75a1449ae6de7" translate="yes" xml:space="preserve">
          <source>A tuple of integer arrays, one array for each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae51c3ea3c094cd9cddbc02935737e4b00f64a16" translate="yes" xml:space="preserve">
          <source>A type object, which is an &lt;code&gt;_ndtpr&lt;/code&gt; instance containing dtype, ndim, shape and flags information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dc5b16a9633f04f2b77831428f3b69798d84b3" translate="yes" xml:space="preserve">
          <source>A unique character code for each of the 21 different built-in types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d057a382d54c38b38dfa71e3ba451944dcf3b8d8" translate="yes" xml:space="preserve">
          <source>A unique number for each of the 21 different built-in types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c1f6c06cc51041e07183275cab6719aeb64fb9" translate="yes" xml:space="preserve">
          <source>A universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) is a function that operates on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; in an element-by-element fashion, supporting &lt;a href=&quot;#ufuncs-broadcasting&quot;&gt;array broadcasting&lt;/a&gt;, &lt;a href=&quot;#ufuncs-casting&quot;&gt;type casting&lt;/a&gt;, and several other standard features. That is, a ufunc is a &amp;ldquo;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-vectorization&quot;&gt;vectorized&lt;/a&gt;&amp;rdquo; wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5238c72cf80b5c60c913bcf36e0c3b2aca2141" translate="yes" xml:space="preserve">
          <source>A use case for this function is to match the shape and layout of the iterator and tack on one or more dimensions. For example, in order to generate a vector per input value for a numerical gradient, you pass in ndim*itemsize for itemsize, then add another dimension to the end with size ndim and stride itemsize. To do the Hessian matrix, you do the same thing but add two dimensions, or take advantage of the symmetry and pack it into 1 dimension with a particular encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23b4448f23bf99116b098b7042336b6a0a35ca9" translate="yes" xml:space="preserve">
          <source>A user-defined type number is returned that uniquely identifies the type. A pointer to the new structure can then be obtained from &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; using the returned type number. A -1 is returned if an error occurs. If this &lt;em&gt;dtype&lt;/em&gt; has already been registered (checked only by the address of the pointer), then return the previously-assigned type-number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15cfd1e60814b656a603a12c408fd84b9dc49bd" translate="yes" xml:space="preserve">
          <source>A variable &lt;code&gt;x&lt;/code&gt; has a log-normal distribution if &lt;code&gt;log(x)&lt;/code&gt; is normally distributed. The probability density function for the log-normal distribution is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a380132a2a22dec2d9e0225f137d26ed0fb90cb8" translate="yes" xml:space="preserve">
          <source>A variable type indicating the kind of clipping that should be applied in certain functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9bf0dccea77846a06e4f1221f1f221c098b27c" translate="yes" xml:space="preserve">
          <source>A version which returns complex numbers when given negative reals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcfc20f282779542aca2d1f71202cb495e262a7" translate="yes" xml:space="preserve">
          <source>A very common operation in much of NumPy code is the need to iterate over all the elements of a general, strided, N-dimensional array. This operation of a general-purpose N-dimensional loop is abstracted in the notion of an iterator object. To write an N-dimensional loop, you only have to create an iterator object from an ndarray, work with the dataptr member of the iterator object structure and call the macro &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it) on the iterator object to move to the next element. The &amp;ldquo;next&amp;rdquo; element is always in C-contiguous order. The macro works by first special casing the C-contiguous, 1-D, and 2-D cases which work very simply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d293e5beee6d752c5e9563e11d78a171279a315" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the columns reversed. Since a view is returned, this operation is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bdbd39fa3f528ae4cecafafda9e6501691569a" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the entries of axis reversed. Since a view is returned, this operation is done in constant time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248e57cd70b2bdbb1ce54ae0d4a6550da9299aaf" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the rows reversed. Since a view is returned, this operation is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51b7d94b5a97c50779fd88d4376e83b681ccdf5" translate="yes" xml:space="preserve">
          <source>A warning of class warning_class should be thrown by the callable when invoked with arguments args and keyword arguments kwargs. If a different type of warning is thrown, it will not be caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fb89647e9cf799e65a16c0b2c72ed24fcc54ac" translate="yes" xml:space="preserve">
          <source>A.V. Oppenheim and R.W. Schafer, &amp;ldquo;Discrete-Time Signal Processing&amp;rdquo;, Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e333a8f5d6c832811356beeee9fce0dffa5d510b" translate="yes" xml:space="preserve">
          <source>ABI incompatibility is automatically detected in every numpy&amp;rsquo;s version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest NPY_FEATURE_VERSION as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5995866cb7ff67106f4964a2376febd406b1609d" translate="yes" xml:space="preserve">
          <source>ALIGNED (A) the data and strides are aligned appropriately for the hardware (as determined by the compiler);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4304323acf2d8950ef646184d037e624bf247b5a" translate="yes" xml:space="preserve">
          <source>ALIGNED / A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c669e6d697ad4a42bc9b5d0d37cf73bc259d9578" translate="yes" xml:space="preserve">
          <source>ALIGNED and WRITEABLE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f993136f3c88fcde984662580493081020efb4f2" translate="yes" xml:space="preserve">
          <source>ALIGNED can only be set &lt;code&gt;True&lt;/code&gt; if the data is truly aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ec8580d4ae0d82a2150753bb70bdbc01a7704e" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A. (Eds.). &amp;ldquo;Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables, 9th printing,&amp;rdquo; New York: Dover, 1972.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1f50a3f5352b9780a93248146f73d95f25a2f5" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A., &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e736856e2b97e31bab4e474e99a3cd42ea1797" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A., &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 79ff. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72be1abc9c41f18cb036851d094c7e5ee1691674" translate="yes" xml:space="preserve">
          <source>Absolute tolerance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ef1ee54a653575269705dbdf26ea3643a0677d" translate="yes" xml:space="preserve">
          <source>Absolute tolerance. The absolute difference is equal to &lt;code&gt;atol&lt;/code&gt;. Default is 1e-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b82fc5344b46b896168f341b2c8150deb1752e" translate="yes" xml:space="preserve">
          <source>Absolute values including &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975afb77a17099a273652740c50322176a7899c3" translate="yes" xml:space="preserve">
          <source>Abstract base class for seed sequences that can spawn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a56b6f89460611cc544ed578033449602d74856" translate="yes" xml:space="preserve">
          <source>Abstract base class for seed sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb77f2711885dd2e0c1b501af744fd631f7962c" translate="yes" xml:space="preserve">
          <source>Accepts a boolean array which is broadcast together with the operands. Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone. This argument cannot be used for generalized ufuncs as those take non-scalar input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ee5fd6920ddbc4707845c10dec516fb18e5f" translate="yes" xml:space="preserve">
          <source>Accepts any object as input, but always returns False unless the input is a MaskedArray containing masked values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eafeaa5f92d0428891758cafdbada426336787" translate="yes" xml:space="preserve">
          <source>Access the values in a BitGenerator, convert them to &lt;code&gt;float64&lt;/code&gt; in the interval &lt;code&gt;[0.0.,&lt;/code&gt; `` 1.0)``. In addition to the &lt;code&gt;size&lt;/code&gt; kwarg, now supports &lt;code&gt;dtype='d'&lt;/code&gt; or &lt;code&gt;dtype='f'&lt;/code&gt;, and an &lt;code&gt;out&lt;/code&gt; kwarg to fill a user- supplied array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c5166155700e6456d3ac7078b3466894c92ea9" translate="yes" xml:space="preserve">
          <source>Accessing a field of a masked array with structured datatype returns a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad44652f541aceec356fa1b8d890a83b5e7dc497" translate="yes" xml:space="preserve">
          <source>Accessing a mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae3364beb66b0f5f244cd535829f92651c28eaf" translate="yes" xml:space="preserve">
          <source>Accessing only the valid entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097badc57289f74986291250ca0d50ffba8b6adb" translate="yes" xml:space="preserve">
          <source>Accessing the BitGenerator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cea573b7dc8cfac38c95967f1d0a9124dc54f0" translate="yes" xml:space="preserve">
          <source>Accessing the data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c56508764b810016753b53da256711e1fc59c95" translate="yes" xml:space="preserve">
          <source>Accessing the mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2444770b8ea0a7f5ab0c34a322154eaab7c51273" translate="yes" xml:space="preserve">
          <source>Accumulate</source>
          <target state="translated">Accumulate</target>
        </trans-unit>
        <trans-unit id="22b15212c762693681b9a14af1311471df5ef0ae" translate="yes" xml:space="preserve">
          <source>Accumulate along axis 0 (rows), down columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dbcb1067a3510dbd548c0a2abcca4e50a8d0fa" translate="yes" xml:space="preserve">
          <source>Accumulate along axis 1 (columns), through rows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d21cbdbf197dfdab9c0eb8a5bda1ff0c8fa94a" translate="yes" xml:space="preserve">
          <source>Accumulate the result of applying the operator to all elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="56ced59b1ab2a27a1e28eb186c93bb18811d3b07" translate="yes" xml:space="preserve">
          <source>Add a new suppressing filter or apply it if the state is entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d043d90a01e9bb2a87e33e05fa61ed3580fe178f" translate="yes" xml:space="preserve">
          <source>Add a sub-package to the current Configuration instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f6e016bc697e252d23d45724a67632f941a1b2" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;endpoint&lt;/code&gt; kwarg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519a7255bd3f55d1b7e212ac3f5b0f7f59ed48fd" translate="yes" xml:space="preserve">
          <source>Add arguments element-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5ce0052c3cb14c88808808de75ffbd43bea0ed" translate="yes" xml:space="preserve">
          <source>Add data files to configuration data_files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974de5ada8253a5d4e9c975a8b5b2b2cc87bc9f2" translate="yes" xml:space="preserve">
          <source>Add extension to configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24e0797845ace332ac782f3100ed9496873f75c" translate="yes" xml:space="preserve">
          <source>Add files to the list of data_files to be included with the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6d39fc613a2412b3149971ccc3066ea668ccca" translate="yes" xml:space="preserve">
          <source>Add installable headers to configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192c191f7a03fc113ffda7fc0311b90dbf55dc23" translate="yes" xml:space="preserve">
          <source>Add items 0 and 1 in first array to second array, and store results in first array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42403b1e1d797b817002a948120252be5c28e7af" translate="yes" xml:space="preserve">
          <source>Add library to configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f20ffde813ddf49b70fa6579528381531956ef" translate="yes" xml:space="preserve">
          <source>Add one Chebyshev series to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd817ff95924ec8272d634ce0e8ab2243af60b54" translate="yes" xml:space="preserve">
          <source>Add one Hermite series to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8b661c7b6f0c6c875176dc938142703c034819" translate="yes" xml:space="preserve">
          <source>Add one Laguerre series to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d32b5903dcfaf0d99ed0343cee2fd7fd1ebf6a" translate="yes" xml:space="preserve">
          <source>Add one Legendre series to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d912f77007b5acc37a22e3054240ae70a3da350" translate="yes" xml:space="preserve">
          <source>Add one polynomial to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8041fb737a2e0a0d3f536fb0552a96a43ffb7877" translate="yes" xml:space="preserve">
          <source>Add other to self in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d36d753b402c69d5e17a3850443960310aff1c" translate="yes" xml:space="preserve">
          <source>Add other to self, and return a new masked array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38367eda00cb06221a825ac891db31d4b74dcd00" translate="yes" xml:space="preserve">
          <source>Add padding to the fields to match what a C compiler would output for a similar C-struct. Can be &lt;code&gt;True&lt;/code&gt; only if &lt;code&gt;obj&lt;/code&gt; is a dictionary or a comma-separated string. If a struct dtype is being created, this also sets a sticky alignment flag &lt;code&gt;isalignedstruct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb521c915ba75bbea5f83fd82b92d84dd986501" translate="yes" xml:space="preserve">
          <source>Add paths to configuration include directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0967ccc52cda50cec6242dcae20e3e663f6b35ba" translate="yes" xml:space="preserve">
          <source>Add scripts to configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd9e8736f2494a49ed757670af12e62654adc57" translate="yes" xml:space="preserve">
          <source>Add self to other, and return a new masked array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867e6fef453e3af448d8c2735af394c1c3900828" translate="yes" xml:space="preserve">
          <source>Add the given sequence of files to the beginning of the headers list. By default, headers will be installed under &amp;lt;python- include&amp;gt;/&amp;lt;self.name.replace(&amp;lsquo;.&amp;rsquo;,&amp;rsquo;/&amp;rsquo;)&amp;gt;/ directory. If an item of files is a tuple, then its first argument specifies the actual installation location relative to the &amp;lt;python-include&amp;gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12793661dc735a50f73c70cbbe55f373e9453216" translate="yes" xml:space="preserve">
          <source>Add the given sequence of paths to the beginning of the include_dirs list. This list will be visible to all extension modules of the current package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e621d32dc1acbceb0f631d5058189d13dfa7e90e" translate="yes" xml:space="preserve">
          <source>Add the sequence of files to the beginning of the scripts list. Scripts will be installed under the &amp;lt;prefix&amp;gt;/bin/ directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1cf6cab2980b1934b9fc8b7e4e15ffc7a86fa0" translate="yes" xml:space="preserve">
          <source>Added in API version 0x0000000D</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e363efb6a62f825b55e45a4c27ae9d8e6d08be0" translate="yes" xml:space="preserve">
          <source>Added the &lt;code&gt;optimize&lt;/code&gt; argument which will optimize the contraction order of an einsum expression. For a contraction with three or more operands this can greatly increase the computational efficiency at the cost of a larger memory footprint during computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1190df5112112b0d1382beaeaf5f8e64d6c7c049" translate="yes" xml:space="preserve">
          <source>Adding and removing elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b71895b23af2e6dac13ac1dabde5dfa97ef31a6" translate="yes" xml:space="preserve">
          <source>Adding the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ceef7d48b3859f43536940686eb939e0f9e4ac" translate="yes" xml:space="preserve">
          <source>Addition and Subtraction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e979316df7e66e1ac30d87235c1730e8f93451f" translate="yes" xml:space="preserve">
          <source>Additional arguments to &lt;code&gt;func1d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f33c64b8e45a0b559c62344568b319008aa4e48" translate="yes" xml:space="preserve">
          <source>Additional named arguments to &lt;code&gt;func1d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6f855c96ea61fde07e7f6094fffb0063607dcd" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;index&lt;/code&gt; specified. If the iterator was constructed with the flag &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;index&lt;/code&gt; is the C-order index, and if the iterator was constructed with the flag &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;index&lt;/code&gt; is the Fortran-order index. Returns an error if there is no index being tracked, the index is out of bounds, or inner loop iteration is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53e871abed99db7c60f0e6f2c2a24b11cc57547" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;iterindex&lt;/code&gt; specified. The IterIndex is an index matching the iteration order of the iterator. Returns an error if the &lt;code&gt;iterindex&lt;/code&gt; is out of bounds, buffering is enabled, or inner loop iteration is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44fa8caa936143e610fe1aa66906556f9b4b048" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;ndim&lt;/code&gt; indices pointed to by &lt;code&gt;multi_index&lt;/code&gt;. Returns an error if a multi-index is not being tracked, the indices are out of bounds, or inner loop iteration is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390482652fc6614f94b8e0b5d3b8e3e7bc440efc" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to its next (broadcasted) element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb4a413c0c668de3526e3736ba4eab0d5ad4902" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to the corresponding location of the &lt;em&gt;index&lt;/em&gt; into the flattened broadcasted array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bcba17a49d905680f64f4b64cd0da0763a1fdc" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06248316b0b57b9742900b7804039e7df16e3f2" translate="yes" xml:space="preserve">
          <source>Advance the pointer of only the &lt;em&gt;i&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd761b85cd8dca1120d21ecad95bbc6dec40fee8" translate="yes" xml:space="preserve">
          <source>Advance the underlying RNG as-if delta draws have occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a9df64655f2d3ba6fe67579fc92c420e65f624" translate="yes" xml:space="preserve">
          <source>Advanced Indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0922b66273cf1a5abf90475333bea716b31aac15" translate="yes" xml:space="preserve">
          <source>Advanced indexes always are &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcast&lt;/a&gt; and iterated as &lt;em&gt;one&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999315f478c86ddb00ef69d19a9dca673920820f" translate="yes" xml:space="preserve">
          <source>Advanced indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ba30d88906e0b53b1be5c5761d50dabce952b7" translate="yes" xml:space="preserve">
          <source>Advanced indexing always returns a &lt;em&gt;copy&lt;/em&gt; of the data (contrast with basic slicing that returns a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb03decbf1f08def4c5022df624652f98eb5d13" translate="yes" xml:space="preserve">
          <source>Advanced indexing is handled with this Python type. It is simply a loose wrapper around the C-structure containing the variables needed for advanced array indexing. The associated C-structure, &lt;code&gt;PyArrayMapIterObject&lt;/code&gt;, is useful if you are trying to understand the advanced-index mapping code. It is defined in the &lt;code&gt;arrayobject.h&lt;/code&gt; header. This type is not exposed to Python and could be replaced with a C-structure. As a Python type it takes advantage of reference- counted memory management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbc11f3f0cea97e5215f4270cb134a05ddd8588" translate="yes" xml:space="preserve">
          <source>Advanced indexing is triggered when the selection object, &lt;em&gt;obj&lt;/em&gt;, is a non-tuple sequence object, an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing: integer and Boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611a42a1d4f61c91b62b09d02ca4dcaf618fc419" translate="yes" xml:space="preserve">
          <source>Advancing a RNG updates the underlying RNG state as-if a given number of calls to the underlying RNG have been made. In general there is not a one-to-one relationship between the number output random values from a particular distribution and the number of draws from the core RNG. This occurs for two reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1491b2d39360f6989a2a9f95147bc552e01c99" translate="yes" xml:space="preserve">
          <source>Advancing the RNG state resets any pre-computed random numbers. This is required to ensure exact reproducibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95973a9f50f3287c49850414751629648c88b21" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;make&lt;/code&gt; is used to build the testing extension modules, &lt;code&gt;testVector.py&lt;/code&gt; can be run to execute the tests. As with other scripts that use &lt;code&gt;unittest&lt;/code&gt; to facilitate unit testing, &lt;code&gt;testVector.py&lt;/code&gt; defines a class that inherits from &lt;code&gt;unittest.TestCase&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95a5016bd3b1fa69cde64b52dc8446b4fe73b5a" translate="yes" xml:space="preserve">
          <source>After being allocated with this flag, the caller may retrieve the new array by calling &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; and getting the i-th object in the returned C array. The caller must call Py_INCREF on it to claim a reference to the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68eb223f793cecafa70b72b2b2cd87c7e3024552" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;NpyIter_HasMultiIndex(iter)&lt;/code&gt; will return false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90e047a5904835abb0e3a66bba8cc0c6a4b3394" translate="yes" xml:space="preserve">
          <source>After checking, the thread-specific global variables, the inputs are evaluated to determine how the ufunc should proceed and the input and output arrays are constructed if necessary. Any inputs which are not arrays are converted to arrays (using context if necessary). Which of the inputs are scalars (and therefore converted to 0-D arrays) is noted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84eaa230a19f707fcc5c351e2944b878215aece7" translate="yes" xml:space="preserve">
          <source>After constructing the format_parser object, the dtype attribute is the converted data-type: &lt;code&gt;dtype = format_parser(formats, names, titles).dtype&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455eb55512bcb65b5c410bb05796baeb29acbfea" translate="yes" xml:space="preserve">
          <source>After preparation, getting and setting is relatively straight forward, although the different modes of iteration need to be considered. Unless there is only a single indexing array during item getting, the validity of the indices is checked beforehand. Otherwise it is handled in the inner loop itself for optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b44505fd313d9b8c894a494c99e13592310d3" translate="yes" xml:space="preserve">
          <source>After this call, iter-&amp;gt;dataptr points to the next point of the neighborhood. Calling this function after every point of the neighborhood has been visited is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9513877fd0ed1a40b8e9bf67003ecbb52357dd" translate="yes" xml:space="preserve">
          <source>Again, the hardware error flags are checked at the end of each 1-D loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15999ccd033219cd638f144231839361b543c152" translate="yes" xml:space="preserve">
          <source>Algebra</source>
          <target state="translated">Algebra</target>
        </trans-unit>
        <trans-unit id="9e977544bb11abd40aa27a0e17f3a1e6f9d61990" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d7f23a72a8843faf44deebd6c5b5926eb14ec8" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.mtrand.randomstate.random_sample#numpy.random.mtrand.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba36176b4a9c759d4fcc72655567ebf82febab0" translate="yes" xml:space="preserve">
          <source>Aliases for column names. For example, if &lt;code&gt;names&lt;/code&gt; were &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; and &lt;code&gt;titles&lt;/code&gt; is &lt;code&gt;('x_coordinate', 'y_coordinate', 'z_coordinate')&lt;/code&gt;, then &lt;code&gt;arr['x']&lt;/code&gt; is equivalent to both &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.x_coordinate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5bb328be3f290ae38f62da3e4ece591ab22fc8" translate="yes" xml:space="preserve">
          <source>Aliases for functions which may be accelerated by Scipy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b88c72578e1bc088ddcd72007a263c4697a72b" translate="yes" xml:space="preserve">
          <source>Align the fields in memory as the C-compiler would.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cba54c6d1af128e2fd6357be91e0ede30e9060" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;N&lt;/code&gt; elements of the matrix are placed into a single row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acddbf25025c4514b513776312b69fb5576c2571" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants have corresponding &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; constants defined. The &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; constants provide the number of bits in the data type. Specifically, the available &lt;code&gt;{CTYPE}s&lt;/code&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be76fffeff958a29e1cfac06d834cba1ca2ac9cb" translate="yes" xml:space="preserve">
          <source>All BitGenerators can produce doubles, uint64s and uint32s via CTypes (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.ctypes#numpy.random.pcg64.PCG64.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;) and CFFI (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.cffi#numpy.random.pcg64.PCG64.cffi&quot;&gt;&lt;code&gt;cffi&lt;/code&gt;&lt;/a&gt;). This allows the bit generators to be used in numba.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bb8ae0504c4fd355ed5e394a6eda23387682d2" translate="yes" xml:space="preserve">
          <source>All BitGenerators in numpy use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to convert seeds into initialized states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93006b441b63a8f203fde18dc1e2540284859337" translate="yes" xml:space="preserve">
          <source>All arrays generated by basic slicing are always &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;views&lt;/a&gt; of the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9be37c010a50fce0078664c2aec450a0fb2c2e9" translate="yes" xml:space="preserve">
          <source>All bit generators can produce doubles, uint64s and uint32s via CTypes (&lt;code&gt;ctypes&lt;/code&gt;) and CFFI (&lt;code&gt;cffi&lt;/code&gt;). This allows these bit generators to be used in numba.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69727cbe4d73bbfb0e440e37962ff9d4d419505" translate="yes" xml:space="preserve">
          <source>All built-in data-type objects have byteorder either &amp;lsquo;=&amp;rsquo; or &amp;lsquo;|&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7a0f2018eee680f412af1df03ac77a63a47767" translate="yes" xml:space="preserve">
          <source>All but the last (righthand-most) bin is half-open. In other words, if &lt;code&gt;bins&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff69c40820720e31d32ccaa63294de4fbcef8495" translate="yes" xml:space="preserve">
          <source>All elements of &lt;code&gt;a&lt;/code&gt; will be assigned this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab491eb1f9e84afa82844be62a42785a977e7753" translate="yes" xml:space="preserve">
          <source>All flags can be accessed using the single (upper case) letter as well as the full name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1cb3a6a2fd8188553a31c71d030165f948de9" translate="yes" xml:space="preserve">
          <source>All input arrays except int64 and uint64 can be safely cast to the returned dtype without loss of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0b857c5a9b73e7d57ed711dbd367f8fced9c77" translate="yes" xml:space="preserve">
          <source>All input arrays with &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; smaller than the input array of largest &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt;, have 1&amp;rsquo;s prepended to their shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca446ec5487618f081b9b30abeedd928222d6468" translate="yes" xml:space="preserve">
          <source>All ndarrays are &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-homogenous&quot;&gt;homogenous&lt;/a&gt;: every item takes up the same size block of memory, and all blocks are interpreted in exactly the same way. How each item in the array is to be interpreted is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt;, one of which is associated with every array. In addition to basic types (integers, floats, &lt;em&gt;etc.&lt;/em&gt;), the data type objects can also represent data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2b25874ee4e8732493aa486d012f0b0bed29b3" translate="yes" xml:space="preserve">
          <source>All of the classes are immutable and have the same methods, and especially they implement the Python numeric operators +, -, *, //, %, divmod, **, ==, and !=. The last two can be a bit problematic due to floating point roundoff errors. We now give a quick demonstration of the various operations using NumPy version 1.7.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23d8201105a40c14ba3b7be79618b80eab9ec1b" translate="yes" xml:space="preserve">
          <source>All of the numeric data types (integer, floating point, and complex) have constants that are defined to be a specific enumerated type number. Exactly which enumerated type a bit-width type refers to is platform dependent. In particular, the constants available are &lt;code&gt;PyArray_{NAME}{BITS}&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; is &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;FLOAT&lt;/strong&gt;, &lt;strong&gt;COMPLEX&lt;/strong&gt; and &lt;code&gt;{BITS}&lt;/code&gt; can be 8, 16, 32, 64, 80, 96, 128, 160, 192, 256, and 512. Obviously not all bit-widths are available on all platforms for all the kinds of numeric types. Commonly 8-, 16-, 32-, 64-bit integers; 32-, 64-bit floats; and 64-, 128-bit complex types are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a846311d841d583030d446986226f22871d26f" translate="yes" xml:space="preserve">
          <source>All of the ufunc methods use the same underlying 1-D computational loops with input and output arguments adjusted so that the appropriate reduction takes place. For example, the key to the functioning of reduce is that the 1-D loop is called with the output and the second input pointing to the same position in memory and both having a step- size of 0. The first input is pointing to the input array with a step- size given by the appropriate stride for the selected axis. In this way, the operation performed is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b156f6c315198e56c123c4ccd661578933f08cc" translate="yes" xml:space="preserve">
          <source>All of these functions can be used in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the &amp;ldquo;O&amp;amp;&amp;rdquo; format specifier to automatically convert any Python object to the required C-object. All of these functions return &lt;a href=&quot;#c.NPY_SUCCEED&quot;&gt;&lt;code&gt;NPY_SUCCEED&lt;/code&gt;&lt;/a&gt; if successful and &lt;a href=&quot;#c.NPY_FAIL&quot;&gt;&lt;code&gt;NPY_FAIL&lt;/code&gt;&lt;/a&gt; if not. The first argument to all of these function is a Python object. The second argument is the &lt;strong&gt;address&lt;/strong&gt; of the C-type to convert the Python object to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2247f8b0604f20c2ebdf433c5eb69f188bf79464" translate="yes" xml:space="preserve">
          <source>All python indexing operations &lt;code&gt;arr[index]&lt;/code&gt; are organized by first preparing the index and finding the index type. The supported index types are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696c30921da1780c98302e930b24c2f3424b4299" translate="yes" xml:space="preserve">
          <source>All quotes are for clarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f230907dd19dccf16b4f94379f148d5d107bfa02" translate="yes" xml:space="preserve">
          <source>All the dates for one month:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92efcb4e59829949c6cee13f46fe21646e8a17b1" translate="yes" xml:space="preserve">
          <source>All the entries of an array can be masked at once by assigning &lt;code&gt;True&lt;/code&gt; to the mask:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10c13da687020f879a5a16ee83f203fa91cc081" translate="yes" xml:space="preserve">
          <source>All the following expressions construct the same block matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffebe2f92d5f410095769cef8e73e9e4be3848b" translate="yes" xml:space="preserve">
          <source>All the partition algorithms make temporary copies of the data when partitioning along any but the last axis. Consequently, partitioning along the last axis is faster and uses less space than partitioning along any other axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a70c541e6faf05b3fbeaa0081931d87c5fc3fd1" translate="yes" xml:space="preserve">
          <source>All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c4b64299274980aca1edafbb8e3c5466dde177" translate="yes" xml:space="preserve">
          <source>All timings were taken using Linux on a i5-3570 processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6801ef087b25df864317061c09ae2a58f2f84b" translate="yes" xml:space="preserve">
          <source>All trailing coefficients less than &lt;code&gt;tol&lt;/code&gt; will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1b305863dfd31164de95c6a2ba21a9d7316e39" translate="yes" xml:space="preserve">
          <source>All trigonometric functions use radians when an angle is called for. The ratio of degrees to radians is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be5744ad69fc918df7773d4afd2f7e1b293377" translate="yes" xml:space="preserve">
          <source>All ufuncs can also take output arguments. If necessary, output will be cast to the data-type(s) of the provided output array(s). If a class with an &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used for the output, results will be written to the object returned by &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Then, if the class also has an &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; method, it is called so metadata may be determined based on the context of the ufunc (the context consisting of the ufunc itself, the arguments passed to the ufunc, and the ufunc domain.) The array object returned by &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; is passed to the ufunc for computation. Finally, if the class also has an &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, the returned &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; result will be passed to that method just before passing control back to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d45789ac1ad3aa209fa7142eb2b247f7550708c" translate="yes" xml:space="preserve">
          <source>All ufuncs have four methods. However, these methods only make sense on scalar ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. The reduce-like methods all take an &lt;em&gt;axis&lt;/em&gt; keyword, a &lt;em&gt;dtype&lt;/em&gt; keyword, and an &lt;em&gt;out&lt;/em&gt; keyword, and the arrays must all have dimension &amp;gt;= 1. The &lt;em&gt;axis&lt;/em&gt; keyword specifies the axis of the array over which the reduction will take place (with negative values counting backwards). Generally, it is an integer, though for &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;, it can also be a tuple of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to reduce over several axes at once, or &lt;code&gt;None&lt;/code&gt;, to reduce over all axes. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to manage a very common problem that arises when naively using &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no &lt;em&gt;dtype&lt;/em&gt; is given for a reduction on the &amp;ldquo;add&amp;rdquo; or &amp;ldquo;multiply&amp;rdquo; operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the &lt;code&gt;int_&lt;/code&gt; data type, it will be internally upcast to the &lt;code&gt;int_&lt;/code&gt; (or &lt;code&gt;uint&lt;/code&gt;) data-type. Finally, the &lt;em&gt;out&lt;/em&gt; keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If &lt;em&gt;out&lt;/em&gt; is given, the &lt;em&gt;dtype&lt;/em&gt; argument is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2318c4003a311a2e1f7718e453877fa81f4be7b" translate="yes" xml:space="preserve">
          <source>All ufuncs take optional keyword arguments. Most of these represent advanced usage and will not typically be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08323fec08cd786e333ebc5f45dc257ddef21b88" translate="yes" xml:space="preserve">
          <source>All values are within the given interval:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3557caeafcef351493a190e0ca76e645501ead19" translate="yes" xml:space="preserve">
          <source>All warnings matching will be appended to the &lt;code&gt;log&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b6fefe401a8781996bd809383b4e94b035998f" translate="yes" xml:space="preserve">
          <source>Allow a copy of &lt;code&gt;op[i]&lt;/code&gt; to be made if it does not meet the data type or alignment requirements as specified by the constructor flags and parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404967cc7ae4678bf28075900a5a4a4ae1c650b" translate="yes" xml:space="preserve">
          <source>Allow any cast, no matter what kind of data loss may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546d0b09674a5e30e0706f69483253c6d7dc53df" translate="yes" xml:space="preserve">
          <source>Allow any safe casts, and casts between types of the same kind. For example, float64 -&amp;gt; float32 is permitted with this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897375acca9fa85a02ea8180e3301f00c8d2bb31" translate="yes" xml:space="preserve">
          <source>Allow identical and casts involving byte swapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e82a87fb0d9abd791679a7a9c324f1f365a79d4" translate="yes" xml:space="preserve">
          <source>Allow loading pickled object arrays stored in npy files. Reasons for disallowing pickles include security, as loading pickled data can execute arbitrary code. If pickles are disallowed, loading object arrays will fail. Default: False</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7be66bfaf7dddda32176dfbd8947ed7745d9801" translate="yes" xml:space="preserve">
          <source>Allow saving object arrays using Python pickles. Reasons for disallowing pickles include security (loading pickled data can execute arbitrary code) and portability (pickled objects may not be loadable on different Python installations, for example if the stored objects require libraries that are not available, and not all pickled data is compatible between Python 2 and Python 3). Default: True</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a3f63d2a62cea8a28f6112a74010f0a2fa0c89" translate="yes" xml:space="preserve">
          <source>Allows memory-mapping of the data. See &lt;code&gt;open_memmep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9475de22330f0492d32cb9f57a359ae9ebe0344c" translate="yes" xml:space="preserve">
          <source>Allows reductions of empty arrays where they would normally fail, i.e. for ufuncs without an identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4262e7f150c5914529572b5cd9e309be4f3a1f9" translate="yes" xml:space="preserve">
          <source>Alpha, positive (&amp;gt;0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebdee21b6a505b4aeefd9e14363fed83b554743" translate="yes" xml:space="preserve">
          <source>Alpha: &amp;lsquo;1.8.0a1&amp;rsquo;, &amp;lsquo;1.8.0a2&amp;rsquo;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5e93aa3d78ef4ca7f7e53b7add77cc4b81efd4" translate="yes" xml:space="preserve">
          <source>Also accepts mu and sigma arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7c5f22b134cc3af66091a2f87fc3b22e43c5ef" translate="yes" xml:space="preserve">
          <source>Also allow scalars for indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d90d80696a309c7c8556cc68ea2ea97804da3bb" translate="yes" xml:space="preserve">
          <source>Also known as the Lorentz distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5314418ba7fc916c6ffe45c7e85e8067bf9357ce" translate="yes" xml:space="preserve">
          <source>Also known as the power function distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d179db72fc2e3131c342afeebad7f69e76c4889" translate="yes" xml:space="preserve">
          <source>Also note that, in general, the result of integrating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5069b3090820edc390ac4ea5af79b726578db6bc" translate="yes" xml:space="preserve">
          <source>Also recognize that &lt;code&gt;x[[1,2,3]]&lt;/code&gt; will trigger advanced indexing, whereas due to the deprecated Numeric compatibility mentioned above, &lt;code&gt;x[[1,2,slice(None)]]&lt;/code&gt; will trigger basic slicing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ce80b72a9c1717eb089ed66d73f56dd1035944" translate="yes" xml:space="preserve">
          <source>Also works for complex numbers (and thus can be used to map any line in the complex plane to any other line therein).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4104c7b18b9b6bb1e8bc147a280cadca288f5d" translate="yes" xml:space="preserve">
          <source>Also works for complex numbers, and thus can be used to calculate the parameters required to map any line in the complex plane to any other line therein.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f352a3bcd45d367a7b48fa8429730ec7b58156e" translate="yes" xml:space="preserve">
          <source>Also, when invoking the entire SciPy test suite, your tests will be found and run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1698709727c2d257ee26f16d4cc2df0ac59e987" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if &lt;code&gt;dtype(out)&lt;/code&gt; is float, the result will consist of 0.0&amp;rsquo;s and 1.0&amp;rsquo;s). See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d8cfa461bbd4723af0411cedff8e47a335d9d0" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of &lt;code&gt;a&lt;/code&gt;). See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4866e784e2d9af93d956076b9ca654f019b24a96" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output, but the type is cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1ad439f43dc00d7ef73618d741c98ced923654" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;. If provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; for details. The casting of NaN to integer can yield unexpected results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df7e48a8694bc511c33f4fdb83c6299c349bb3" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad525857dfba045e849cea18042cc3d7880b99c2" translate="yes" xml:space="preserve">
          <source>Alternately, one can omit the seed parameter and set the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c50d39f026457c3ef039adee4c7d2e01334bf3" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. If size is not None, it must have the same shape as the provided size and must match the type of the output values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac126422935264a529db37a224ca2732607cef38" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e863787368c91b7bab7460b77df3b49a02452a31" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9008d4b2e922f165a265eb88d277e1ffec09130a" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6716188c035c63d861379b98db31dc6a05b5e2ca" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a76cb94a0ca7efaae715d349afff176965d63b9" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c295d74f775619fe463f057ab1dbd08a7d79f8f7" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a2880769e0fb1df50a4ab9060f58e553c38840" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b99c7a8d7488b79863b62ea908025b20096c8f" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd666e1b61b4360073157ecd0d0fcb9aaf5ef0cb" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886dc56850e1cdcb4b242ab241178dd7eddb1737" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fc9cbd185de6b1e0ea1c76efbbd7a9e0eec0f8" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0988f7b666b0761e9579b2bdb1096aad1df99ee" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;#numpy.testing.assert_raises&quot;&gt;&lt;code&gt;assert_raises&lt;/code&gt;&lt;/a&gt; can be used as a context manager:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042b85098c25d452344f7eaee4b5c7db2499e054" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;Philox&lt;/code&gt; can be used in parallel applications by using a sequence of distinct keys where each instance uses different key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0623427bd96685461eb8fa62b01f63338db5ece" translate="yes" xml:space="preserve">
          <source>Alternatively, calling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603108a6af86b03c6a3e370901679f4bbc10b9d8" translate="yes" xml:space="preserve">
          <source>Alternatively, can be used as a context manager like &lt;a href=&quot;numpy.testing.assert_raises#numpy.testing.assert_raises&quot;&gt;&lt;code&gt;assert_raises&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d1b2b8f8933f7c73a15d5c48954079a5c5f378" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is set to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then as a special case, special methods like &lt;code&gt;ndarray.__add__&lt;/code&gt; will notice this and &lt;em&gt;unconditionally&lt;/em&gt; raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is useful if you want to create objects that interact with arrays via binary operations, but are not themselves arrays. For example, a units handling system might have an object &lt;code&gt;m&lt;/code&gt; representing the &amp;ldquo;meters&amp;rdquo; unit, and want to support the syntax &lt;code&gt;arr * m&lt;/code&gt; to represent that the array has units of &amp;ldquo;meters&amp;rdquo;, but not want to otherwise interact with arrays via ufuncs or otherwise. This can be done by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; and defining &lt;code&gt;__mul__&lt;/code&gt; and &lt;code&gt;__rmul__&lt;/code&gt; methods. (Note that this means that writing an &lt;code&gt;__array_ufunc__&lt;/code&gt; that always returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; is not quite the same as setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;: in the former case, &lt;code&gt;arr + obj&lt;/code&gt; will raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, while in the latter case it is possible to define a &lt;code&gt;__radd__&lt;/code&gt; method to prevent this.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e228119d8236b4e4d18e3b2e104d4d85e550ff8" translate="yes" xml:space="preserve">
          <source>Although we provide the &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; BitGenerator for use independent of &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, note that its default seeding uses &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; rather than the legacy seeding algorithm. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; will use the legacy seeding algorithm. The methods to use the legacy seeding algorithm are currently private as the main reason to use them is just to implement &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. However, one can reset the state of &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; using the state of the &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc9ccd559a420363c97ebc977b2af5b809d20bf" translate="yes" xml:space="preserve">
          <source>Always returns False if &lt;code&gt;x&lt;/code&gt; isn&amp;rsquo;t a MaskedArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6227067f2d29f54359191689a5ac01ab8ecb4c" translate="yes" xml:space="preserve">
          <source>Always returns a sorted complex array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c68db5bc6e63b5b5bb435069771f8f296cb78c3" translate="yes" xml:space="preserve">
          <source>Among other things that are made possible is one can create a new array metadata object that uses the same data buffer to create a new view of that data buffer that has a different interpretation of the buffer (e.g., different shape, offset, byte order, strides, etc) but shares the same data bytes. Many operations in numpy do just this such as slices. Other operations, such as transpose, don&amp;rsquo;t move data elements around in the array, but rather change the information about the shape and strides so that the indexing of the array changes, but the data in the doesn&amp;rsquo;t move.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d580c4489c2c610aab44ce0ad58b3f097208f00d" translate="yes" xml:space="preserve">
          <source>Amount paid against the loan changes. The &lt;code&gt;per&lt;/code&gt; is the period of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="acae2de70c42b720bf5497e24967979b922bd47e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, which is a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; of &lt;em&gt;N&lt;/em&gt; non-negative integers that specify the sizes of each dimension. The type of items in the array is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object (dtype)&lt;/a&gt;, one of which is associated with each ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc19800098fdeab8e6191cd2c74779ca9496d4b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method&amp;rsquo;s docstring has a more complete description.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa95663d09715fdd85c3c286e62db310ab9bc156" translate="yes" xml:space="preserve">
          <source>An Hermite series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ba78634b9174a697f0599ae6f6dc13ecb77ada" translate="yes" xml:space="preserve">
          <source>An HermiteE series class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774f2ca6463ce8bcd64cdfd525d1845b4ce03eef" translate="yes" xml:space="preserve">
          <source>An N-dimensional array containing samples of a scalar function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d538fa8637c715f6bbc2c9c38a813643eb7ae9b" translate="yes" xml:space="preserve">
          <source>An N-dimensional iterator object to index arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd52a8c903e6e44d839c6aa398f48a49b2e9a83" translate="yes" xml:space="preserve">
          <source>An N-dimensional tuple of current coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0469df4347714bf84d92842d69579d7dfabaaa72" translate="yes" xml:space="preserve">
          <source>An additional feature is that the path to a data-file can actually be a function that takes no arguments and returns the actual path(s) to the data-files. This is useful when the data files are generated while building the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dfa862bcfcc9668a1db552ab4daea86348201e" translate="yes" xml:space="preserve">
          <source>An additional list of paths to look for .ini files can be given to &lt;code&gt;get_info&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963bad104cdcf2da9f9197c7dd8bbca2134670a8" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same form as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290ba89cf67c59979f1b14cebdae08675ffa3872" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same form as that of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535d7085464b23925e15a73868df4653982051e0" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aadce1a1c3678a4b3a0e8fd514232b417ea179b" translate="yes" xml:space="preserve">
          <source>An alias for the density argument that behaves identically. To avoid confusion with the broken normed argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;density&lt;/code&gt; should be preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dff9706411c38850b8de8293266d9884231cabd" translate="yes" xml:space="preserve">
          <source>An arbitrary Python function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caae7edaffe66ab62bffc1b2b0bd2b213c039100" translate="yes" xml:space="preserve">
          <source>An array class with possibly masked values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c85e68fd622a0d5a6428884a31f19296d5b57f7" translate="yes" xml:space="preserve">
          <source>An array containing the number of bytes to jump to get to the next element in each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ae13ad9fa748df727082d88d41d03835abae7a" translate="yes" xml:space="preserve">
          <source>An array containing the roots of the polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40188341aa1ae4126e28065ab4ae4528efd4ab80" translate="yes" xml:space="preserve">
          <source>An array containing the size of the array in each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5525cd97ca2fd0380b69e5fa824c4cb8926190c" translate="yes" xml:space="preserve">
          <source>An array containing the x coordinates of the points to be histogrammed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0350b6b12b116d1bc018ccc6e377cd22ea853f" translate="yes" xml:space="preserve">
          <source>An array containing the y coordinates of the points to be histogrammed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd97d56d812219b3b28e1a0c52b1ff6cc695c36" translate="yes" xml:space="preserve">
          <source>An array describing the shape and dtype of the required MaskedArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf313c17a2dcae5eace0c3bac8edc28ea3d4e63f" translate="yes" xml:space="preserve">
          <source>An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of &lt;code&gt;self.itemsize&lt;/code&gt;. Understanding &lt;code&gt;memory-alignment&lt;/code&gt; leads to better performance on most hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d722ed07993e54ee58671613ec6bb989469ec46" translate="yes" xml:space="preserve">
          <source>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; provides more description and examples of this useful approach to looping over an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8ecafe80193daba2a801115dc110f22a3a74c2" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cce5f6c6a06c1eb7b057cb09fd7ff7ffd616b00" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1e82b5439e905b1ddafb253ce61f57276c43a9" translate="yes" xml:space="preserve">
          <source>An array object satisfying the specified requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bb351e2eb8c7a3b66881caf4f6450b8b6137b9" translate="yes" xml:space="preserve">
          <source>An array of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4c885c1848f9a375fc02dab6bce7ae4010158c" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a99ea190c51364ce40fbff67e226039938f643" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52ec49035d815a8b775d98b8000ec27cfc67177" translate="yes" xml:space="preserve">
          <source>An array of floats to be rounded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3de1a372b66bb0f894c2b02cc87913d27ccf3e7" translate="yes" xml:space="preserve">
          <source>An array of function pointers &amp;mdash; one for each data type supported by the ufunc. This is the vector loop that is called to implement the underlying function &lt;em&gt;dims&lt;/em&gt; [0] times. The first argument, &lt;em&gt;args&lt;/em&gt;, is an array of &lt;em&gt;nargs&lt;/em&gt; pointers to behaved memory. Pointers to the data for the input arguments are first, followed by the pointers to the data for the output arguments. How many bytes must be skipped to get to the next element in the sequence is specified by the corresponding entry in the &lt;em&gt;steps&lt;/em&gt; array. The last argument allows the loop to receive extra information. This is commonly used so that a single, generic vector loop can be used for multiple functions. In this case, the actual scalar function to call is passed in as &lt;em&gt;extradata&lt;/em&gt;. The size of this function pointer array is ntypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ccf0c919c71e47e2ddd7bf201588725f440dd1" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;code&gt;NPY_QUICKSORT&lt;/code&gt;, &lt;code&gt;NPY_HEAPSORT&lt;/code&gt;, and &lt;code&gt;NPY_MERGESORT&lt;/code&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16de626c174b91da42175d30f3d8341b71b66d8" translate="yes" xml:space="preserve">
          <source>An array of function pointers to cast from the current type to all of the other builtin types. Each function casts a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;from&lt;/em&gt; to a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;to&lt;/em&gt; The number of items to cast is given by &lt;em&gt;n&lt;/em&gt;, and the arguments &lt;em&gt;fromarr&lt;/em&gt; and &lt;em&gt;toarr&lt;/em&gt; are interpreted as PyArrayObjects for flexible arrays to get itemsize information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e200feb9e53ed4ebf2adb54be5ba987c1cf7059b" translate="yes" xml:space="preserve">
          <source>An array of function pointers to sorting algorithms for this data type. The same sorting algorithms as for sort are available. The indices producing the sort are returned in &lt;code&gt;result&lt;/code&gt; (which must be initialized with indices 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf461a6da3a9c78b86edef9e37f8d374d2671a0" translate="yes" xml:space="preserve">
          <source>An array of indices into the flattened version of an array of dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a2b96955709f32822d46286842703f4390b599" translate="yes" xml:space="preserve">
          <source>An array of indices or a single index value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c327e0cbb835c3f65406d2930b711dc0438fe097" translate="yes" xml:space="preserve">
          <source>An array of integers or booleans whose elements should be packed to bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760cd2caf69b9cf29b19f984123cfb0704600d65" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44196e580ff225be1ef1476b121c70c9f63af8cb" translate="yes" xml:space="preserve">
          <source>An array of integers providing the shape in each dimension as long as nd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ed90156adc402e959f400c23d7929e6a74e615" translate="yes" xml:space="preserve">
          <source>An array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e82fd2fdc82899ac97dd9d7069f0c853f214d0" translate="yes" xml:space="preserve">
          <source>An array of numeric data can also be passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece80d1b5df43cd5fed015f36204934c9ec31960" translate="yes" xml:space="preserve">
          <source>An array of pointers to the actual data for the input and output arrays. The input arguments are given first followed by the output arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47c875bafe38f3ae53b22be1ca5e1e026b9c87a" translate="yes" xml:space="preserve">
          <source>An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, &lt;code&gt;edges&lt;/code&gt; is a list of the first and last index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dec96e92acd76ab0b9a5089a0591ab494441f3" translate="yes" xml:space="preserve">
          <source>An array of strings the same shape as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4864cc2ae1f8d0267df4cabfa6aa6a6b4bbde15b" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the cube cube-root of each element in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dca043d37393a6e2fc85fdd287fdcbcb4dfecc0" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the positive square-root of each element in &lt;code&gt;x&lt;/code&gt;. If any element in &lt;code&gt;x&lt;/code&gt; is complex, a complex array is returned (and the square-roots of negative reals are calculated). If all of the elements in &lt;code&gt;x&lt;/code&gt; are real, so is &lt;code&gt;y&lt;/code&gt;, with negative elements returning &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73f11faf81ffda921b160f49100211ca44e9e3b" translate="yes" xml:space="preserve">
          <source>An array of the same type as &lt;code&gt;a&lt;/code&gt;, containing the rounded values. Unless &lt;code&gt;out&lt;/code&gt; was specified, a new array is created. A reference to the result is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979601eabdfd48b8ade710f0f03e8b5a86f0bf28" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i)&lt;/code&gt;. Weights are normalized to 1 if &lt;code&gt;normed&lt;/code&gt; is True. If &lt;code&gt;normed&lt;/code&gt; is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e086307191e3a610d256fdc031206d0be076bb2f" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt;. Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ce1ac9c3e01f3e63767874318d5ec35c6c8162" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d3b67fb93cc4bc7812921dd986159ce97b0f1e" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). If &lt;code&gt;density&lt;/code&gt; is True, the weights are normalized, so that the integral of the density over the range remains 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08534b68e928582028171965f68debd33645b68" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). This is currently not used by any of the bin estimators, but may be in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66c5b78a1ee6031ffac8fb1c853e09ee03b883" translate="yes" xml:space="preserve">
          <source>An array shaped as &lt;code&gt;a&lt;/code&gt; but with the specified axis removed. Returns a reference to &lt;code&gt;out&lt;/code&gt; if specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28da6e5d441ca894170555ee158c5c43a7ecacb4" translate="yes" xml:space="preserve">
          <source>An array where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1e5537016317a890a5d4a449f9cc2d733ed07" translate="yes" xml:space="preserve">
          <source>An array whose nonzero or True entries indicate the elements of &lt;code&gt;arr&lt;/code&gt; to extract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9db9bfd04f4def5fd1afc2affd0945adf42512d" translate="yes" xml:space="preserve">
          <source>An array with (possibly) masked elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f661a37bc1f34ccd31f28fc314368c36fc3fd521" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt; together, containing the number of valid days between the begin and end dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4b7ef06bb85fc991c331148db99f16620489ed" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;dates&lt;/code&gt; and &lt;code&gt;offsets&lt;/code&gt; together, containing the dates with offsets applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb96764e2b9c06bb0ff9fb7ca3e50e3f3bfa36d0" translate="yes" xml:space="preserve">
          <source>An array with elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1229c9f2e1287182eb9a66528204171c6010bc1b" translate="yes" xml:space="preserve">
          <source>An array with ones at and below the given diagonal and zeros elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f9e7222fb1b0027174f3c545f28e69a270792e" translate="yes" xml:space="preserve">
          <source>An array with the elements of &lt;code&gt;a&lt;/code&gt;, but where values &amp;lt; &lt;code&gt;a_min&lt;/code&gt; are replaced with &lt;code&gt;a_min&lt;/code&gt;, and those &amp;gt; &lt;code&gt;a_max&lt;/code&gt; with &lt;code&gt;a_max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d81681b563f7cbf7ca14e4beb55c0e61ff30a7" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned. If an output array is specified, a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baa9b65de91284b3761237390d81577243ec095" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as &lt;code&gt;a&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70abaa821cac7240773cdf6e7844c07f6b75f59" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;dates&lt;/code&gt;, containing True for each valid day, and False for each invalid day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd1a7da3ce189a324136cbefbaa56e7594e5b61" translate="yes" xml:space="preserve">
          <source>An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c2325cc9f9529260815a39ebd69bc396f69b18" translate="yes" xml:space="preserve">
          <source>An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567f786634fc5daa235d994c1657787eea4b779a" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt;. Copies are made only if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba647ea9fdf896d7caaed5b946ba91dc1f4274e" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;. Copies are avoided where possible, and views with two or more dimensions are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20047f5be3a0546654cf45798129be0ced7cf529" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt;. Copies are avoided where possible, and views with three or more dimensions are returned. For example, a 1-D array of shape &lt;code&gt;(N,)&lt;/code&gt; becomes a view of shape &lt;code&gt;(1, N, 1)&lt;/code&gt;, and a 2-D array of shape &lt;code&gt;(M, N)&lt;/code&gt; becomes a view of shape &lt;code&gt;(M, N, 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d598faf58dcce518852d1c23ec2af6d3886d1a" translate="yes" xml:space="preserve">
          <source>An assertion is raised if the following condition is not met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3adef5312938abeed5e9919b7facafa03477317" translate="yes" xml:space="preserve">
          <source>An assignment example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8cae1664bf34207082790eecd4cff8bc80d113" translate="yes" xml:space="preserve">
          <source>An authority is a person who can tell you more about something than you really care to know. &amp;mdash; &lt;em&gt;Unknown&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88aa14c58828551e162cc4a4661a6843968586b6" translate="yes" xml:space="preserve">
          <source>An empty (tuple) index is a full scalar index into a zero dimensional array. &lt;code&gt;x[()]&lt;/code&gt; returns a &lt;em&gt;scalar&lt;/em&gt; if &lt;code&gt;x&lt;/code&gt; is zero dimensional and a view otherwise. On the other hand &lt;code&gt;x[...]&lt;/code&gt; always returns a view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8fe74c5bf94bc803b1bb945a029de2c98e9baa" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating how permissive data conversions should be. This is used by the iterator added in NumPy 1.6, and is intended to be used more broadly in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f076fadc0ee0a286669da0779a627fc24ddf6053" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating the element order that an array should be interpreted in. When a brand new array is created, generally only &lt;strong&gt;NPY_CORDER&lt;/strong&gt; and &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; are used, whereas when one or more inputs are provided, the order can be based on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e8f4d7015b6070bf3f50c3e64f0fbef756b878" translate="yes" xml:space="preserve">
          <source>An example from Glantz[1], pp 47-40:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad321a0ede9c3a9da071e8e5fe72a77cf61d678" translate="yes" xml:space="preserve">
          <source>An example of a non-associative case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bcbe60f6b1cdb52a7d953fc81ff3369b0f2592" translate="yes" xml:space="preserve">
          <source>An example to show comments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab59fb864b641fc21102fa6867c9f294d4d4a6b9" translate="yes" xml:space="preserve">
          <source>An example using a &amp;ldquo;vector&amp;rdquo; of letters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae67380a5d930011edb475d7e700cc0a79c17af2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;b&lt;/code&gt; is a scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94faf0f11390e7c87a6db1e320054aa5b39eed5b" translate="yes" xml:space="preserve">
          <source>An example with fixed-width columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3a8754bce53d43d3e15790bf69e69f40787cb1" translate="yes" xml:space="preserve">
          <source>An extended example taking advantage of the overloading of + and *:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234994ab6fdb07f0421cdf6417fa8d08aaed3974" translate="yes" xml:space="preserve">
          <source>An important thing to be aware of for this iteration is that the order is chosen to match the memory layout of the array instead of using a standard C or Fortran ordering. This is done for access efficiency, reflecting the idea that by default one simply wants to visit each element without concern for a particular ordering. We can see this by iterating over the transpose of our previous array, compared to taking a copy of that transpose in C order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8e2f3f33d5cad8aca5e828b4984abc49c8c85d" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; estimator that works better with non-normal datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04b75dbec8a648ba0471c30efe8cb82bf3011bd" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; formula that produces better estimates for non-normal datasets. This estimator attempts to account for the skew of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0daf8923a8ff879a417d16aa3697c8609e06f7" translate="yes" xml:space="preserve">
          <source>An index which matches the order of iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3ef13b14659602803a66f38a194c91b0d16c51" translate="yes" xml:space="preserve">
          <source>An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24428e2d87c0033a748d11a9f2ce4caa1e91c810" translate="yes" xml:space="preserve">
          <source>An input object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd98d417809c28451b9172282e9fd64d1c41e89" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; can be thought as the combination of several elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6e3d42720c490f4a7b292acd6a9d04e387f93f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634a502415ebc5263dc90361e50dd67e1f0e70b8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea316e4ad89d0b127e75fd6f9a3da36dffed3ba" translate="yes" xml:space="preserve">
          <source>An instance of class &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps &lt;em&gt;N&lt;/em&gt; integers into the location of an item in the block. The ranges in which the indices can vary is specified by the &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; of the array. How many bytes each item takes and how the bytes are interpreted is defined by the &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt; associated with the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1c5ac8d50b25041dc87f2c7519eb1a86058078" translate="yes" xml:space="preserve">
          <source>An integer array whose elements are indices into the flattened version of an array of dimensions &lt;code&gt;shape&lt;/code&gt;. Before version 1.6.0, this function accepted just one index value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4276a3e1422ad086a54d759953deada7066bbc35" translate="yes" xml:space="preserve">
          <source>An integer as a dimension name freezes that dimension to the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa126ddddd0a6a8da1f0e66c4d42624e8184e08" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is &lt;code&gt;None&lt;/code&gt; or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7827031c1e4779ee518d6bbc19386c165a21aa2f" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740a8c0291954a1fc0b575bf55fa7f345ee70e49" translate="yes" xml:space="preserve">
          <source>An integer showing the version of the interface (i.e. 3 for this version). Be careful not to use this to invalidate objects exposing future versions of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87fed7bbbc954e477fb70394a40418f3fdbf745" translate="yes" xml:space="preserve">
          <source>An integer, &lt;em&gt;i&lt;/em&gt;, returns the same values as &lt;code&gt;i:i+1&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt; the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the &lt;em&gt;p&lt;/em&gt;-th element an integer (and all other entries &lt;code&gt;:&lt;/code&gt;) returns the corresponding sub-array with dimension &lt;em&gt;N - 1&lt;/em&gt;. If &lt;em&gt;N = 1&lt;/em&gt; then the returned object is an array scalar. These objects are explained in &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Scalars&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9337d47802d85cb5aefc4c6ec7749f6fe4d0f859" translate="yes" xml:space="preserve">
          <source>An introduction, with definitions and general explanations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e55a620091e71a89cb39a3c09fd5cc874040b26" translate="yes" xml:space="preserve">
          <source>An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, is represented by a Python object whose type is one of the &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar types&lt;/a&gt; built in NumPy. The array scalars allow easy manipulation of also more complicated arrangements of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de99db091c92a4334b9f2bbfb02c196f89f1e72f" translate="yes" xml:space="preserve">
          <source>An iterable object providing data for the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c683940adaf3e17b5b2d4dbfdc8fb1f9285bc0" translate="yes" xml:space="preserve">
          <source>An masked array with &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; elements where the condition is masked, elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce742f07c8b93ebe9e87ec17c3c1ca6bc05421b" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortan-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84038cf3f95c6f7f876de572eb50dcdd65ebb4e5" translate="yes" xml:space="preserve">
          <source>An ndarray containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For complex input, &lt;code&gt;a + ib&lt;/code&gt;, the absolute value is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937ff1e9853b1d8bb7896ced9c9a3c640f4a20fd" translate="yes" xml:space="preserve">
          <source>An ndarray of appropriate shape and dtype, filled with False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ee74273207da7ae537266764fb0a696c970cac" translate="yes" xml:space="preserve">
          <source>An nditer for each item in &lt;code&gt;axes&lt;/code&gt;, outermost first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7605eba941666733600a4275983300b4a00400c" translate="yes" xml:space="preserve">
          <source>An ndpointer instance is used to describe an ndarray in restypes and argtypes specifications. This approach is more flexible than using, for example, &lt;code&gt;POINTER(c_double)&lt;/code&gt;, since several restrictions can be specified, which are verified upon calling the ctypes function. These include data type, number of dimensions, shape and flags. If a given array does not satisfy the specified restrictions, a &lt;code&gt;TypeError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8249a78054c0cb82583f75cad623801b99c6e816" translate="yes" xml:space="preserve">
          <source>An object that can be passed as an argument to the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; constructor to create the array&amp;rsquo;s dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b070f54d715dc3c886991b214975d29e065cb3" translate="yes" xml:space="preserve">
          <source>An object that can be queried for it&amp;rsquo;s numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757fdfd1c89cb8f173de4247aa51861595590920" translate="yes" xml:space="preserve">
          <source>An object that exposes the buffer interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa10d88b8c5173358367cce862fb4a6d6fc0051" translate="yes" xml:space="preserve">
          <source>An object that specifies a custom set of valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9697eabfa36a0c57b03730a9e63e9c0dd7cc2d09" translate="yes" xml:space="preserve">
          <source>An object to simplify the interaction of the array with the ctypes module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d04ad5d02d58a854d2c57fda919f98926805a2" translate="yes" xml:space="preserve">
          <source>An offset can be passed also to the masking function. This gets us the indices starting on the first diagonal right of the main one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bb40a65a5fed271af7ea895f0c3a327894df3e" translate="yes" xml:space="preserve">
          <source>An open file object, or a string containing a filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61177b92fd6e93436d3f1589cdd0e84373a28c0" translate="yes" xml:space="preserve">
          <source>An optional argument which is passed through to &lt;code&gt;mask_func&lt;/code&gt;. Functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; take a second argument that is interpreted as an offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1965c219b7008fe9d099c530f609263a14ec3ab8" translate="yes" xml:space="preserve">
          <source>An optional shape tuple providing how many times this part of the structure should be repeated. No repeats are assumed if this is not given. Very complicated structures can be described using this generic interface. Notice, however, that each element of the array is still of the same data-type. Some examples of using this interface are given below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53899654d34ff89eb71076f6e6bc7701229a1b68" translate="yes" xml:space="preserve">
          <source>An order as close to the order of the inputs as possible, even if the input is in neither C nor Fortran order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62dbe9a66cb25d1e5f12073cb6b65d7c95221376" translate="yes" xml:space="preserve">
          <source>An ordered tuple of field names. It is NULL if no field is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43728498911f9a35c7cfcd97027ee53c73e05582" translate="yes" xml:space="preserve">
          <source>And for assigning values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb83d7408641f0a8ebf4e9525e3b469b9150326" translate="yes" xml:space="preserve">
          <source>And here are the time units:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b699ec82ab8d002ac2193762454ef347af6a2da" translate="yes" xml:space="preserve">
          <source>And in more detail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96cb503f931b03fd273a49b170890809399fc62" translate="yes" xml:space="preserve">
          <source>And use it to set the diagonal of an array of zeros to 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240ae7e192fffb9c12f05d721f8aebdc4754f4de" translate="yes" xml:space="preserve">
          <source>Angle in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0184757264cf635f3a2e2e908775a586af284275" translate="yes" xml:space="preserve">
          <source>Angle, in radians (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531138e549dac342fe270e2699b3c5521bbf5ec8" translate="yes" xml:space="preserve">
          <source>Angles in degrees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4043a7e9def49f8cd15e6e1c3c67b85fcd702c3b" translate="yes" xml:space="preserve">
          <source>Another difference with the standard ndarray of str data-type is that the chararray inherits the feature introduced by Numarray that white-space at the end of any element in the array will be ignored on item retrieval and comparison operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcd2747e1a6d1d5aac68e7e1ee2b04c96abcc9c" translate="yes" xml:space="preserve">
          <source>Another example is the function &lt;code&gt;inner1d(a, b)&lt;/code&gt; with a signature of &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;. This applies the inner product along the last axis of each input, but keeps the remaining indices intact. For example, where &lt;code&gt;a&lt;/code&gt; is of shape &lt;code&gt;(3, 5, N)&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is of shape &lt;code&gt;(5, N)&lt;/code&gt;, this will return an output of shape &lt;code&gt;(3,5)&lt;/code&gt;. The underlying elementary function is called &lt;code&gt;3 * 5&lt;/code&gt; times. In the signature, we specify one core dimension &lt;code&gt;(i)&lt;/code&gt; for each input and zero core dimensions &lt;code&gt;()&lt;/code&gt; for the output, since it takes two 1-d arrays and returns a scalar. By using the same name &lt;code&gt;i&lt;/code&gt;, we specify that the two corresponding dimensions should be of the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c72feff7651c1b9feda841c49b58c2d454b80e" translate="yes" xml:space="preserve">
          <source>Another important role played by deprecation markings in the C API is to move towards hiding internal details of the NumPy implementation. For those needing direct, easy, access to the data of ndarrays, this will not remove this ability. Rather, there are many potential performance optimizations which require changing the implementation details, and NumPy developers have been unable to try them because of the high value of preserving ABI compatibility. By deprecating this direct access, we will in the future be able to improve NumPy&amp;rsquo;s performance in ways we cannot presently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91143b613b806bdad96301f98bc353e17238828f" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd6c16778a959995e7dc3e9960a7fccd4bf7af0" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt;&lt;code&gt;getmask&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt;&lt;code&gt;getmaskarray&lt;/code&gt;&lt;/a&gt; functions. &lt;code&gt;getmask(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array, and the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; otherwise. &lt;code&gt;getmaskarray(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array. If &lt;code&gt;x&lt;/code&gt; has no invalid entry or is not a masked array, the function outputs a boolean array of &lt;code&gt;False&lt;/code&gt; with as many elements as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af7d96a4421569602af070d1f51ae85302570e" translate="yes" xml:space="preserve">
          <source>Another use of this flag is for setting up reduction operations. After the iterator is created, and a reduction output is allocated automatically by the iterator (be sure to use READWRITE access), its value may be initialized to the reduction unit. Use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get the object. Then, call &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; to allocate and fill the buffers with their initial values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1273c53271563cf36a39aab59fe3df9f43442e63" translate="yes" xml:space="preserve">
          <source>Another way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9a549b7d1a971f20baf0bc7c2890ecc79e2921" translate="yes" xml:space="preserve">
          <source>Another way to retrieve the valid data is to use the &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; method, which returns a one-dimensional &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (or one of its subclasses, depending on the value of the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c793b7f96dc3a05a24bc874af2795d6270941c5" translate="yes" xml:space="preserve">
          <source>Anti-derivative of a polynomial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a193823ba578f9f1e7b81264ee2c1d9779647da7" translate="yes" xml:space="preserve">
          <source>Any Python object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e444efe77e462bb342fdd66c1b5f6f6487f4f4" translate="yes" xml:space="preserve">
          <source>Any binary operation can be extended to an array operation in an outer product fashion like in &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;outer&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a way to accomplish this by explicitly mapping the axes of the operands. It is also possible to do this with &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; indexing, but we will show you how to directly use the nditer &lt;code&gt;op_axes&lt;/code&gt; parameter to accomplish this with no intermediate views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10078c28a66a73c575c275e6dbad2ad1c3448ead" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c392144526317c8f8ed6b5a13470ac5e7a3986" translate="yes" xml:space="preserve">
          <source>Any combination of N scalars/arrays with the meaning of 2. and 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b31e220e37372f3e91f15af6702628188b111" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0107d5bdb46b9143c29ff9e836efde601fe340" translate="yes" xml:space="preserve">
          <source>Any dynamically allocated memory. Currently, this is used for dynamic ufuncs created from a python function to store room for the types, data, and name members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1796623bc2027a8a0877fb0e869c4d3c3990d76" translate="yes" xml:space="preserve">
          <source>Any further arguments given to &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, 1, 'a')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd7c425a186534062ca5afb654fb680173c25d5" translate="yes" xml:space="preserve">
          <source>Any keyword arguments the function requires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487737106c5cb105d4cc96a9c1768d045f864529" translate="yes" xml:space="preserve">
          <source>Any masked values in x is propagated in y, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3e589175f1027a44f22dd657bf35194fb4efe1" translate="yes" xml:space="preserve">
          <source>Any object that can be interpreted as a numpy data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6945ac0af9b8b9ad29a3d13b28b137c3c2801d79" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99411ff6757ed2755306b2b1a16852e86b5af656" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb631f6c3d9ec9fd114b3a0b6be2d92e321c394" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3abc478c3f222918197160be100f748fcb675c9" translate="yes" xml:space="preserve">
          <source>Any of the above can be repeated with an arbitrary array-like instead of just integers. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be291c901c4e86c13d0921234777782594d69ca9" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fc04558da8dd3c7bccbbace9c70f03ebdb6a80" translate="yes" xml:space="preserve">
          <source>Any string in &lt;code&gt;numpy.sctypeDict&lt;/code&gt;.keys():</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d713c0e047edfbd49f0b3846ac98a9a40d4a3161" translate="yes" xml:space="preserve">
          <source>Any third argument to &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt;&lt;code&gt;pow&lt;/code&gt;&lt;/a&gt; is silently ignored, as the underlying &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; takes only two arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be63b1330ee25c1f855c85df25ca52d3b0d9ac" translate="yes" xml:space="preserve">
          <source>Any type object with a &lt;code&gt;dtype&lt;/code&gt; attribute: The attribute will be accessed and used directly. The attribute must return something that is convertible into a dtype object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26626a547f9526333d65f7f7ac98e634e8d404b" translate="yes" xml:space="preserve">
          <source>Append a new recording filter or apply it if the state is entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01347379ae01a5a40d3d1ed49513be6a422e707d" translate="yes" xml:space="preserve">
          <source>Append elements at the end of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e89159e1cc33f0d869902b46493c6f6e94db543" translate="yes" xml:space="preserve">
          <source>Append values to the end of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9cf77e8ba225a7ce0a29de1d2139c5781725d4" translate="yes" xml:space="preserve">
          <source>Appends a data function to the data_files list that will generate __svn_version__.py file to the current package directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f5ee9b7c00e9ead408311c459141d052778da5" translate="yes" xml:space="preserve">
          <source>Applies an offset counted in valid days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf57444d43c734213e1d3c851fdf1b3fb150bdf" translate="yes" xml:space="preserve">
          <source>Applies glob.glob(&amp;hellip;) to each path in the sequence (if needed) and pre-pends the local_path if needed. Because this is called on all source lists, this allows wildcard characters to be specified in lists of sources for extension modules and libraries and scripts and allows path-names be relative to the source directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78652f7b097973c5af68766b38955ba3ae45a013" translate="yes" xml:space="preserve">
          <source>Applies the Einstein summation convention to the array operands provided, returning a new array or placing the result in &lt;em&gt;out&lt;/em&gt;. The string in &lt;em&gt;subscripts&lt;/em&gt; is a comma separated list of index letters. The number of operands is in &lt;em&gt;nop&lt;/em&gt;, and &lt;em&gt;op_in&lt;/em&gt; is an array containing those operands. The data type of the output can be forced with &lt;em&gt;dtype&lt;/em&gt;, the output order can be forced with &lt;em&gt;order&lt;/em&gt; (&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is recommended), and when &lt;em&gt;dtype&lt;/em&gt; is specified, &lt;em&gt;casting&lt;/em&gt; indicates how permissive the data conversion should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15deb464b32712e5faad1a95646f2d13bba4428" translate="yes" xml:space="preserve">
          <source>Apply a decorator to all methods in a class matching a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aba00bb90c6eaaa703b9d293078221144653ecd" translate="yes" xml:space="preserve">
          <source>Apply a function repeatedly over multiple axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930471cd723d35b6c2b966e96ceecc291d0fdf6a" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices along the given axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e579e665f3197d6488027d302750921e380286" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices of an array along the given axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f37352400ea0595778e975d3829366956d6422" translate="yes" xml:space="preserve">
          <source>Apply glob to paths and prepend local_path if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d57e8ee432c77c347bd91e42e1ec296a790a962" translate="yes" xml:space="preserve">
          <source>Apply linear map to input points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b451c47d03d2342612630d90e5961330763668d9" translate="yes" xml:space="preserve">
          <source>Apply the same function to a scalar value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19a38c87eebd888f6ee1a1c74150ed1ef57dd31" translate="yes" xml:space="preserve">
          <source>Apply the ufunc &lt;code&gt;op&lt;/code&gt; to all pairs (a, b) with a in &lt;code&gt;A&lt;/code&gt; and b in &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a7e07004db73b8ccd197df301f0c0c88108495f" translate="yes" xml:space="preserve">
          <source>Arbitrary data (extra arguments, function names, &lt;em&gt;etc.&lt;/em&gt; ) that can be stored with the ufunc and will be passed in when it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c0ec3c601093336049eacec64ee0a29b472718" translate="yes" xml:space="preserve">
          <source>Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses will be accepted for writing, but only the array data will be written out. A regular numpy.ndarray object will be created upon reading the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91c75193c3842b9d909ec7b8dd4d035b07a9f55" translate="yes" xml:space="preserve">
          <source>Are all arguments of a type that we know how to handle?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bf0c3e3104c86791f4ce367eca2a5cc6cd438f" translate="yes" xml:space="preserve">
          <source>Are the array elements of type unicode (True) or string (False). Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b5fdf11f1c668ee1bccda74e473d486cb80034" translate="yes" xml:space="preserve">
          <source>Argout Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f693ea5d95326ee12ba9edafca87f6f5ac163dc" translate="yes" xml:space="preserve">
          <source>Argout View Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9362235cd642830a37eb4b0e960e60e4a8a7f208" translate="yes" xml:space="preserve">
          <source>Argout arrays are arrays that appear in the input arguments in C, but are in fact output arrays. This pattern occurs often when there is more than one output variable and the single return argument is therefore not sufficient. In Python, the conventional way to return multiple arguments is to pack them into a sequence (tuple, list, etc.) and return the sequence. This is what the argout typemaps do. If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list, depending on the version of Python. The Python user does not pass these arrays in, they simply get returned. For the case where a dimension is specified, the python user must provide that dimension as an argument. The argout signatures are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d811a8c8b43b06e028e619f05e9d14eafcdca7" translate="yes" xml:space="preserve">
          <source>Argoutview arrays are for when your C code provides you with a view of its internal data and does not require any memory to be allocated by the user. This can be dangerous. There is almost no way to guarantee that the internal data from the C code will remain in existence for the entire lifetime of the NumPy array that encapsulates it. If the user destroys the object that provides the view of the data before destroying the NumPy array, then using that array may result in bad memory references or segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply have no other choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69013bc8794a33ce0d96e2362b8fd29875b1d20a" translate="yes" xml:space="preserve">
          <source>Argument can be either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e8304a176934810abc17d2d26c3888e65cbaa7" translate="yes" xml:space="preserve">
          <source>Argument of complex values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103cd4d5d40741b2189f1a4cd45b1145dc7d5cc2" translate="yes" xml:space="preserve">
          <source>Argument of the Bessel function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da03da7501b0f4c3d0e71a81aacac0740f6ea6ce" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a267e3ae3a20fe67defefd5d3c99d6c87f6bed7" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1fece9ebb467e36ae935eb7f9713ac9a4f47e841" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed091b4d91808383da4576963f0c43e1c919be23" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the nose test runner. &lt;code&gt;argv[0]&lt;/code&gt; is ignored. All command line arguments accepted by &lt;code&gt;nosetests&lt;/code&gt; will work. If it is the default value None, sys.argv is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47a631225ff0c3415173266008602c859777e94" translate="yes" xml:space="preserve">
          <source>Arguments to pass on to the ufunc. Typically &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="424915704fdafa9f1991a2f818f149305624ecb5" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e6f1226f47528d48f2f359b548a2a985744686" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;code&gt;data&lt;/code&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574e424bf0f02d1b18e3ad5386f39a38953e230d" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; are defined as element-wise operations, and generally yield &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects as results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6179dfdf1f721c4f139e7add385d54ea9025725c" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
