<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">부호없는 64 비트 / 8 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위를 기준으로 날짜 또는 날짜 시간을 정밀도로 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위의 정수로 시간 길이를 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">두 개의 NPY_LONGDOUBLE 값으로 구성된 플랫폼 별 복합 부동 소수점 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">플랫폼 특정 부동 소수점 유형의 열거 값은 NPY_DOUBLE 이상이지만 많은 플랫폼에서 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">(void *) 포인터와 동일한 크기의 부호있는 정수 유형의 열거 값입니다. 모든 인덱스 배열에서 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8 비트 / 1 바이트 부호있는 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">부호없는 8 비트 / 1 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">(void *) 포인터와 동일한 크기의 부호없는 정수 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">임의의 Python 객체에 대한 참조의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">부울 유형의 열거 값으로 1 바이트로 저장됩니다. 값은 0과 1로만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스크에 사용 된 유형의 열거 값입니다 (예 : &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 반복자 플래그 사용). 이것은 &lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">부동 소수점 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">정수 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">오류 마스크는 4 개의 부동 소수점 오류에 대한 처리 정보를 보유하는 단일 정수입니다. 각 오류 유형에 대한 정보는 정수의 3 비트에 포함됩니다. 8 진법으로 인쇄하면 &quot;무효&quot;, &quot;언더&quot;, &quot;오버&quot;및 &quot;분할&quot;이 어떤 순서로 설정되어 있는지 확인할 수 있습니다. 인쇄 된 문자열은</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">실패시 인쇄 할 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 가져오고 설정하는 다른 함수 ( &lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 설정하는 다른 함수 ( &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">오류 개체, [내부 numpy 버퍼 크기, 오류 마스크, 오류 콜백 함수]의 세 가지 요소가 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">이 평가는 일명 합성 부문 인 Clenshaw 재귀를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">평가에는 Horner의 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">느린 테스트의 정확한 정의는 주관적 및 하드웨어에 따라 다르지만 일반적으로 1 초 또는 2 초 이상이 필요한 개별 테스트는 느리게 레이블이 지정되어야합니다 (전체 제품군은 수천 개의 테스트로 구성되므로 1 초도 중요한).</target>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">위의 규칙에 대한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">예상되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">예상되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">지수는 임의의 정수 또는 긴 정수, 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eps&lt;/code&gt; 를 산출하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epsneg&lt;/code&gt; 를 생성하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">지수. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">추출 된 대각선 또는 구성된 대각선 배열.</target>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">&lt;code&gt;'col1, col2, col3'&lt;/code&gt; 형식의 쉼표로 구분 된 문자열 또는 &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; 형식의 문자열 목록 또는 튜플 로 지정된 필드 이름 입니다 . 비어있는 목록을 사용할 수 있으며이 경우 기본 필드 이름 ( 'f0', 'f1',&amp;hellip;)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">파일에 객체 배열이 포함되어 있지만 allow_pickle = False가 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">파일이이 모드에서 열립니다 :</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">배열 데이터 버퍼로 사용될 파일 이름 또는 파일 객체.</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">로드 할 파일 또는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 피클 할 파일 입니다. 문자열 인 경우 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">읽을 파일입니다. 파일과 유사한 객체는 &lt;code&gt;seek()&lt;/code&gt; 및 &lt;code&gt;read()&lt;/code&gt; 메서드를 지원해야합니다 . 절인 파일을 사용하려면 파일과 유사한 객체가 &lt;code&gt;readline()&lt;/code&gt; 메서드도 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">fill_value는 &lt;code&gt;value&lt;/code&gt; 로 설정되고 마스크는 가능한 경우 &lt;code&gt;nomask&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">채워진 배열.</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다. 설정하면 데이터 유형에 따라 없음이 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 점이 False가 아닌 한 시퀀스의 최종 값입니다 . 이 경우 &lt;code&gt;num + 1&lt;/code&gt; 값은 로그 공간의 간격에 걸쳐 간격을두고 마지막 (길이 &lt;code&gt;num&lt;/code&gt; 시퀀스)을 제외한 모든 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">처음 6 바이트는 정확히 &lt;code&gt;\x93NUMPY&lt;/code&gt; 와 같은 마술 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 의 첫 번째 &lt;code&gt;nargs&lt;/code&gt; 요소는 스칼라 ufunc와 동일하게 유지됩니다. 다음 요소에는 모든 인수에 대한 모든 핵심 차원의 보폭이 순서대로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">첫 번째 인수에는 &lt;code&gt;depends&lt;/code&gt; , &lt;code&gt;sources&lt;/code&gt; 등 의 속성에 액세스하고 빌드 프로세스 중에 속성을 수정하는 데 유용한 Extension 인스턴스가 포함되어 있습니다 . 두 번째 인수는 디스크에 파일을 작성할 때 사용해야하는 빌드 디렉토리의 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">첫 번째 인수는 고정 크기 데이터 형식 개체로 변환 할 수있는 개체입니다. 두 번째 인수는이 유형의 원하는 모양입니다. shape 매개 변수가 1이면 데이터 유형 오브젝트는 고정 dtype과 같습니다. 경우 &lt;em&gt;형상&lt;/em&gt; 튜플, 새로운 DTYPE는 소정 형상의 서브 어레이를 정의한다.</target>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">첫 번째 인수는 크기가 0 인 유연한 데이터 형식 개체로 변환되는 개체 여야하며 두 번째 인수는 원하는 항목 크기를 제공하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">첫 번째 배열은 주사위를 10 번 던지는 결과를 보여주고, 두 번째 배열은 주사위를 20 번 던지는 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">첫 번째 주장은 예외를 제기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">날짜 또는 그 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">날짜 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">첫 번째 문자는 데이터 종류를 지정하고 나머지 문자는 유니 코드를 제외하고 항목 당 바이트 수를 지정합니다 (유니 코드는 문자 수로 해석 됨). 항목 크기가 기존 유형과 일치해야합니다. 그렇지 않으면 오류가 발생합니다. 지원되는 종류는</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">첫 번째 차이는 주어진 축을 따라 &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; 주어지며 &lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; 를&lt;/a&gt; 재귀 적 으로 사용하여 더 큰 차이를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">첫 번째 요소 인 &lt;em&gt;field_name&lt;/em&gt; 은 필드 이름입니다 ( &lt;code&gt;''&lt;/code&gt; 인 경우 표준 필드 이름 &lt;code&gt;'f#'&lt;/code&gt; 가 지정됨). 필드 이름은 첫 번째 문자열이 &quot;제목&quot;(문자열 또는 유니 코드 문자열 일 수 있음)이거나 임의의 개체가 될 수있는 필드의 메타 데이터 인 두 개의 문자열 일 수도 있습니다. 유효한 파이썬 식별자 여야하는 &quot;이름&quot;</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">첫 번째 예는 &lt;code&gt;p&lt;/code&gt; 를 한 번 통합하고 두 번째 예는 p를 두 번 통합합니다. 기본적으로 적분의 하한과 적분 상수는 0이지만 둘 다 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">첫 번째 양식이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774 년부터 라플라스의 제 1 법칙에 따르면 오차의 빈도는 오차의 절대 크기의 지수 함수로 표현 될 수 있으며, 이는 라플라스 분포를 초래합니다. 경제 및 건강 과학의 많은 문제에서이 분포는 표준 가우스 분포보다 데이터를 더 잘 모델링하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">첫 번째 출력은 위치 또는 키워드 매개 변수로 제공 될 수 있습니다. 키워드 'out'인수는 위치 인수와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫 번째 매개 변수 arr은 ndarray 또는 서브 클래스 여야합니다. 파라미터는, &lt;em&gt;플래그&lt;/em&gt; : 배열이 가질 수있는 가능한 비트 플래그의 조합으로 이루어진 정수이어야 &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">나열된 첫 번째 서명 &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; 은 하드 코딩 된 차원을 가진 1 차원 배열을위한 것입니다. 마찬가지로 &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; 는 하드 코딩 된 차원을 가진 2 차원 배열 용이며 3 차원도 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">먼저 스레드 별 전역 사전에서 버퍼 크기, 오류 마스크 및 관련 오류 개체에 대한 현재 값을 조회합니다. 오류 마스크의 상태는 오류 조건이 발견 될 때 발생하는 상황을 제어합니다. 하드웨어 오류 플래그 검사는 각 1D 루프가 실행 된 후에 만 ​​수행됩니다. 즉, 단일 1D 루프가 수행되도록 입력 및 출력 배열이 연속적이고 올바른 유형 인 경우 배열의 모든 요소가 계산 될 때까지 플래그를 확인할 수 없습니다. 스레드 별 사전에서 이러한 값을 찾으려면 아주 작은 배열을 제외하고는 쉽게 무시되는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">가장 먼저 이해해야 할 것은 2 차원 배열을 인덱싱하는 두 가지 상충되는 규칙이 있다는 것입니다. 행렬 표기법은 첫 번째 인덱스를 사용하여 어떤 행이 선택되고 있는지 나타내고 두 번째 인덱스는 어떤 열이 선택되었는지 나타냅니다. 이것은 사람들이 일반적으로 첫 번째 인덱스가 x 위치 (즉, 열)를 나타내고 두 번째 인덱스가 y 위치 (즉, 행)를 나타내는 것으로 생각되는 이미지의 기하학적 지향적 컨벤션과 반대입니다. 이것만으로도 많은 혼란이 발생합니다. 매트릭스 지향 사용자와 이미지 지향 사용자는 인덱싱과 관련하여 두 가지 다른 것을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">플래그 멤버는 데이터의 해석 방법을 나타내는 5 비트와 인터페이스의 해석 방법을 나타내는 1 비트로 구성 될 수 있습니다. 데이터 비트는 &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200) 및 &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400)입니다. 최종 플래그 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800)은이 구조에 arrdescr 필드가 있는지 여부를 나타냅니다. 이 플래그가 없으면 필드에 액세스하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">반환되는 가변형 배열에는 두 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 예외는 IEEE 754 표준 &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">바닥 분할 연산자 &lt;code&gt;//&lt;/code&gt; 는 Python 2.2에서 &lt;code&gt;//&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 또는 동등한 연산자 로 추가되었습니다 . 의 기본 바닥 나눗셈 연산 &lt;code&gt;/&lt;/code&gt; 는 과 진정한 사업부로 대체 될 수 &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 각 요소의 바닥입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">스칼라 &lt;code&gt;x&lt;/code&gt; 의 바닥은 가장 큰 정수 &lt;code&gt;i&lt;/code&gt; 이므로 &lt;code&gt;i &amp;lt;= x&lt;/code&gt; 입니다. 종종 다음과 같이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">fmax는 x1과 x2가 NaN이 아닌 경우 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르며 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1과 x2가 NaN이 아닌 경우 fmin은 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르며 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">다음 속성은 배열의 메모리 레이아웃에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">다음 비교는 예외를 일으키지 않습니다. 입력에 NaN이 있지만 동일한 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">다음 데이터 유형은 &lt;strong&gt;융통성이 있습니다&lt;/strong&gt; . 사전 정의 된 크기가 없으며 설명하는 데이터의 길이가 서로 다른 배열 일 수 있습니다. 문자 코드에서 &lt;code&gt;#&lt;/code&gt; 은 데이터 유형으로 구성되는 요소 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;a * a+ * a == a&lt;/code&gt; 및 &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">다음 예제는이 특정 dtype에 대한 조작에 Python C-API가 필요하다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; 또는 &lt;code&gt;x[np.newaxis]&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">0.6이 표준 편차의 약 2 배인 경우 다음 사항에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">다음 키가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">&lt;code&gt;npy_math.h&lt;/code&gt; 에서 다음 수학 상수를 사용할 수 있습니다 . &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;l&lt;/code&gt; 접미사를 각각 추가하여 단 ​​정밀도 및 확장 정밀도도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">마스크에 대한 정보에 액세스하거나 마스크를 조작하는 데 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">다음 방법은 피클 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">다음과 같은 규범을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">다음과 같은 미리 정의 된 명명 된 반복 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">파일 시퀀스의 각 요소 형태는 매우 유연하여 패키지에서 파일을 가져올 위치와 궁극적으로 시스템에 설치해야하는 위치를 다양하게 조합 할 수 있습니다. 가장 기본적인 사용법은 파일 인수 시퀀스의 요소가 간단한 파일 이름이되는 것입니다. 이로 인해 로컬 경로의 파일이 self.name 패키지의 설치 경로 (패키지 경로)에 설치됩니다. 파일 인수는 상대 경로 일 수도 있으며,이 경우 전체 상대 경로가 패키지 디렉토리에 설치됩니다. 마지막으로, 파일은 절대 경로 이름 일 수 있으며,이 경우 파일은 절대 경로 이름에 있지만 패키지 경로에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">서명의 공식 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">형식 설명은 &lt;code&gt;'f8, i4, a5'&lt;/code&gt; 형식의 쉼표로 구분 된 형식 설명이있는 문자열로 지정 되거나 &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; 형식의 형식 설명 문자열 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">형식은 &lt;code&gt;__array_interface__&lt;/code&gt; 속성 의 'descr'키에 필요한 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 이진 파일 형식의 형식은 &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">정방향 2 차원 FFT로, &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; 는 역입니다.</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">정방향 &lt;em&gt;n&lt;/em&gt; 차원 FFT이며,이 중 &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 은 역입니다.</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">이는 실제 입력의 전방 N 차원 FFT &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; 가&lt;/a&gt; 역이다.</target>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">네 가지 핵심 분포 ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; )는 모두 &lt;code&gt;out&lt;/code&gt; 키워드 인수 를 사용하여 기존 배열을 채울 수 있습니다 . 기존 어레이는 연속적이고 올바르게 작동해야합니다 (쓰기 가능 및 정렬). 일반적인 상황에서 &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt; 와 같은 공통 생성자를 사용하여 생성 된 배열 은 이러한 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">3 차 다항식의 4 차 미분 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">주어진 숫자가 음수이면 분수 부분과 정수 부분은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt; 함수 는 numpy의 기본 &lt;code&gt;BitGenerator&lt;/code&gt; 로 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt; 기능을 사용하면 업무 일에 지정된 오프셋을 'D'(일) 단위로 날짜 시간에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">이 함수는 필요한 경우 가장 작은 것 앞에 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 치수 수가 같다고 가정 합니다. 경우 &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; 하고 &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; 는 크로네 커 제품 형상을 갖는다 &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; . 요소는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소로 구성된 제품으로 다음 과 같이 명시 적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">이 함수의 평균은</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">함수의 피크 (모드)가</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">이 함수는 평균에서 피크를 가지며 표준 편차에 따라 &quot;스프레드&quot;가 증가합니다 (이 함수는 최대 0.607 배에 도달)</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">이 함수는 각도가 배수 인 0을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">이 함수는 휴일과 같은 며칠을 계산할 때도 유용합니다. 캐나다와 미국에서 어머니의 날은 5 월 둘째 주 일요일이며, 맞춤 주 마스크로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">이 함수는 _data 및 _mask (있는 경우) 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">이 함수는 N 개의 매개 변수로 호출되며, 여기서 N은 &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 의 순위입니다 . 각 매개 변수는 특정 축을 따라 변하는 배열의 좌표를 나타냅니다. 예를 들어 &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;(2, 2)&lt;/code&gt; 이면 매개 변수는 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 및 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">이 함수는 N 개의 매개 변수로 호출되며, 여기서 N은 &lt;code&gt;shape&lt;/code&gt; 의 순위입니다 . 각 매개 변수는 특정 축을 따라 변하는 배열의 좌표를 나타냅니다. 예를 들어 &lt;code&gt;shape&lt;/code&gt; 가 &lt;code&gt;(2, 2)&lt;/code&gt; 이면 매개 변수는 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 및 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">NpyAuxData 복제 함수의 함수 포인터 유형입니다. 이러한 함수는 다중 스레드 컨텍스트에서 호출 될 수 있으므로 오류시 Python 예외를 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">NpyAuxData 프리 함수에 대한 함수 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">이 함수는 다항식의 계수를 반환합니다</target>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">x와 y가 생략 될 때 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">보간 할 함수입니다. &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 형식의 단일 변수 함수 여야합니다. 여기서 &lt;code&gt;a, b, c...&lt;/code&gt; 는 &lt;code&gt;args&lt;/code&gt; 매개 변수에 전달 된 추가 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능은 &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; 를&lt;/a&gt; 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">이 기능 은 1.6에 도입 된 반복자 &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; , 플래그 &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; 또는 모든 피연산자에 대해 동일한 dtype 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에 대한 많은 산술 특수 메소드를 구현하기 위해 호출되는 함수는 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; 를&lt;/a&gt; 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">미래 가치는 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">이득은 상당하며 규모가 적당히 큰 경우에도 스케일링이 합리적입니다. 어레이 생성 오버 헤드로 인해 기존 어레이를 사용하지 않는 호출에 비해 이득이 훨씬 큽니다.</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">브로드 캐스트의 일반적인 개념은 브로드 &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 반복자를 사용하여 Python에서도 사용할 수 있습니다 . 이 개체는</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">생성 된 파일의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">생성 된 랜덤 샘플</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">일반 계층 유형 오브젝트는 연관에 따라 해당 유형 오브젝트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">주어진 데코레이터는 정규식 &lt;code&gt;testmatch&lt;/code&gt; ( &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ) 와 일치하는 모든 공개 &lt;code&gt;cls&lt;/code&gt; 메소드에 적용됩니다 . 개인용 (즉, 밑줄로 시작) 메소드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">구배는 내부 점에서의 2 차 정확한 중심 차이 및 경계에서의 1 차 또는 2 차 정확한 단측 (앞 또는 뒤로) 차이를 사용하여 계산된다. 반환 된 그래디언트는 입력 배열과 모양이 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">최대 공약수</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">입력 절대 값의 최대 공약수 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">헤더 파일 &amp;lt;numpy / halffloat.h&amp;gt;는 IEEE 754-2008 16 비트 부동 소수점 값과 작동하는 기능을 제공합니다. 이 형식은 일반적으로 숫자 계산에 사용되지 않지만 부동 소수점이 필요하지만 정밀도가 많이 필요하지 않은 값을 저장하는 데 유용합니다. 부동 소수점 반올림 오류의 특성을 이해하기위한 교육 도구로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">일반적인 SciPy &lt;code&gt;__init__.py&lt;/code&gt; 의 헤더 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 동일한 종류 ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ) 의 최고 정밀도 데이터 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">쌍곡 코사인은 매달린 케이블의 모양을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">삼각형의 빗변. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">항등 배열은 주 대각선을 가진 정사각형 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">아이덴티티 값.</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">복잡한 주장의 허구 적 구성 요소. 경우 &lt;code&gt;val&lt;/code&gt; 진짜의 종류 &lt;code&gt;val&lt;/code&gt; 출력에 사용됩니다. &lt;code&gt;val&lt;/code&gt; 에 복잡한 요소가 있으면 반환 된 유형은 float입니다.</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">배열의 허수 부.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">마스크 배열의 허수 부.</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">이 정보를 생성하는 테스트 구현.</target>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">평균 계산에서 각 요소의 중요성. 가중치 배열은 1 차원 (이 경우 길이는 주어진 축의 크기 여야 함 )이거나 &lt;code&gt;a&lt;/code&gt; 와 같은 모양 일 &lt;code&gt;a&lt;/code&gt; 있습니다. &lt;code&gt;weights=None&lt;/code&gt; 인 경우 &lt;code&gt;a&lt;/code&gt; 의 모든 데이터 는 가중치가 1과 같다고 가정합니다. &lt;code&gt;weights&lt;/code&gt; 가 복잡한 경우 허수 부분은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">포함 된 BitGenerator는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">포함 된 생성기는 다음 세 가지 방법 중 하나로 병렬 분산 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">인덱스 결과.</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">인덱싱은 평탄화 된 대상 배열에서 작동합니다. &lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; 은 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">인덱스는 배열에 대한 인덱스로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">삼각형의 인덱스. 반환 된 튜플에는 배열의 한 차원을 따라 인덱스가있는 두 개의 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">삼각형의 인덱스. 반환 된 튜플에는 배열의 한 차원을 따라 인덱스가있는 두 개의 배열이 포함됩니다. 모양의 ndarray ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ) 를 슬라이스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">배열에서 마스크되지 않은 첫 번째 값과 마지막 값의 인덱스입니다. 모든 값이 마스크 된 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">현재 반복의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; 의 공통 값이 처음 나타나는 인덱스입니다 . &lt;code&gt;return_indices&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar2&lt;/code&gt; 의 공통 값이 처음 나타나는 인덱스입니다 . &lt;code&gt;return_indices&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">원래 배열에서 고유 한 값이 처음 나타나는 인덱스입니다. &lt;code&gt;return_index&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일치하는 값의 인덱스는 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 값으로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">추출 할 값의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">고유 한 배열에서 원래 배열을 재구성하는 인덱스입니다. &lt;code&gt;return_inverse&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">인덱스는 치수가 arr과 동일한 정사각형 배열에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">인덱스는 정사각형 배열에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">플로트 ndarray로 입력 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">Fortran 또는 열 주요 순서 의 입력 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">입력 배열은 정수 dtype이어야합니다. 그렇지 않으면 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">유효하지 않은 항목이있는 입력 배열이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">이 함수에 의해 입력 배열의 마스크가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">길이가 1 인 차원의 일부 또는 전부가 제거 된 입력 배열입니다. 이것은 항상 자체 또는으로보기 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">입력 배열은 각각 &quot;분자&quot;(배당) 및 &quot;분모&quot;(제수) 다항식의 계수 (0과 같은 계수 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">입력은 임의의 유형 및 형상 일 수있다.</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">입력 데이터 유형이 유지됩니다. list / tuple in은 list / tuple out을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 데이터 타입. 이것은이 될 수 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 객체 나에 변환 가능한 객체 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">입력 도메인</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">입력은 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 형태 , 즉 주파수가 증가하는 순서로 복소수 양수 항이 따르는 실제 제로 주파수 항이됩니다. 실수 입력의 이산 푸리에 변환은 허미 시안-대칭이므로, 음의 주파수 항은 해당 양의 주파수 항의 복소 공액으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 전체 상태를 채 웁니다. 첫 번째 요소는 최상위 비트 만 설정되도록 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 두 값을 모두 생성합니다. 증분은 독립적으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 처음 3 개의 값을 생성 한 다음 &lt;code&gt;SFC64&lt;/code&gt; 알고리즘을 약간 반복하여 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 키를 생성합니다. 카운터는 0으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">입력은 &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 것과 같은 방식으로 정렬되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">에 의해 반환되는대로 입력은 동일한 방식으로 정렬되어야 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 관해서 즉 &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 및에 대해, 최종 변환 축 &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 모든 다른 축을 따라.</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">입력 값.</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 입력 은 &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 것과 같은 방식으로 정렬 되어야합니다. 축, 축 중간의 나이 퀴 스트 주파수에 대한 항, 양 축의 후반에 음수 주파수 항이 감소하는 음수 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 입력 은 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; 에서 반환 된 것과 같은 방식으로 정렬되어야합니다 . 즉, 하위 코너의 모든 축에서 주파수가 0 인 용어, 모든 축의 전반에서 양의 주파수 용어가 있어야합니다. , 감소하는 음의 주파수 순으로 모든 축의 중간에있는 나이키 스트 주파수에 대한 항과 모든 축의 후반에 음의 주파수 항에 대한 항을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">적분 상수는 기본적으로 0이지만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보간 된 값으로 &lt;code&gt;x&lt;/code&gt; 와 같은 모양 입니다.</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">역 &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;acos&lt;/code&gt; 또는 cos ^ -1 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">역 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">역 가우시안 분포는 브라운 운동과 관련하여 처음 연구되었습니다. 1956 년 MCK Tweedie는 단위 거리를 커버하는 시간과 단위 시간을 커버하는 거리 사이에 역의 관계가 있기 때문에 역 가우시안이라는 이름을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">역함수.</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">역 쌍곡 사인은 &lt;code&gt;asinh&lt;/code&gt; 또는 &lt;code&gt;sinh^-1&lt;/code&gt; 로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">역 쌍곡 탄젠트는 &lt;code&gt;atanh&lt;/code&gt; 또는 &lt;code&gt;tanh^-1&lt;/code&gt; 로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">의 역 &lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , 역 &lt;em&gt;N&lt;/em&gt; 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 .</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 의 역 , 즉 실제 입력의 n 차원 FFT의 역.</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 .</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">의 역 &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; 되도록하는 경우 &lt;code&gt;y = cos(x)&lt;/code&gt; 다음 &lt;code&gt;x = arccos(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 . 짝수 길이 &lt;code&gt;x&lt;/code&gt; 에 대해서는 동일하지만 함수는 홀수 &lt;code&gt;x&lt;/code&gt; 에 대해 하나의 샘플만큼 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">tan의 역수이므로 &lt;code&gt;y = tan(x)&lt;/code&gt; 이면 &lt;code&gt;x = arctan(y)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">실수 입력 의 &lt;em&gt;n&lt;/em&gt; 차원 FFT의 역수 .</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 차원 FFT 의 역수 .</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 1 차원 FFT의 역수.</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 2 차원 FFT의 역수.</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">싱글 톤 치수를 추가하는 역 연산</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">싱글 톤 치수를 제거하는 역 연산</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">역 사인은 &lt;code&gt;asin&lt;/code&gt; 또는 sin ^ {-1} 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; , 라디안 및 닫힌 간격 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; 의 각 요소에 대한 역 사인 값 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">역 탄젠트는 &lt;code&gt;atan&lt;/code&gt; 또는 tan ^ {-1} 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">역 2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">비이성적 인 숫자 &lt;code&gt;e&lt;/code&gt; 는 오일러 숫자라고도합니다. 약 2.718281이며 자연 로그의 기초 인 &lt;code&gt;ln&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">반복자 플래그&amp;ldquo;delay_bufalloc&amp;rdquo;는 반복자 할당 감소 피연산자가 버퍼링과 함께 존재할 수 있도록합니다. 이 플래그가 설정되면, 반복자는 재설정을 수신 할 때까지 버퍼를 초기화되지 않은 상태로두고 그 후에 정기적 인 반복을 준비합니다. 버퍼링을 활성화하면 이전 예제의 모습입니다.</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">반복자는 반복자에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">반복자 레이아웃은 내부 세부 사항이며 사용자 코드는 불완전한 구조체 만 보입니다.</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">NumPy 1.6에 도입 된 반복자 객체 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 체계적인 방식으로 하나 이상의 배열의 모든 요소를 ​​방문 할 수있는 여러 가지 유연한 방법을 제공합니다. 이 페이지는 파이썬에서 배열에 대한 계산을 위해 객체를 사용하는 몇 가지 기본 방법을 소개 한 다음 Cython에서 내부 루프를 가속화하는 방법으로 마무리합니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 의 Python 노출은 C 배열 반복자 API의 비교적 간단한 매핑이므로 이러한 아이디어는 C 또는 C ++의 배열 반복 작업에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">반복자는 NumPy의 캐스팅 규칙을 사용하여 특정 변환이 허용되는지 여부를 결정합니다. 기본적으로 '안전한'캐스팅이 적용됩니다. 예를 들어, 64 비트 부동 소수점 배열을 32 비트 부동 소수점 배열로 취급하려고하면 예외가 발생합니다. 대부분의 경우 'same_kind'규칙은 64 비트에서 32 비트 부동 소수점으로 변환 할 수 있지만 float에서 int로 또는 복소수에서 부동 소수점으로 변환 할 수 없으므로 사용하기에 가장 적합한 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">점프 크기는</target>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">열쇠는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">정보를 얻는 정수 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">비교할 더 큰 객체.</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">가장 큰 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">마지막은 핵심 차원을 동결시키는 인스턴스이며 ufunc 성능을 향상시키는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">추가 차원으로 인해 첫 번째 요소 만 제공하는 마지막 요소입니다. 이 예제를 이해하려면 &lt;code&gt;rowsum.nonzero()&lt;/code&gt; 를 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">&lt;code&gt;{NAME}s&lt;/code&gt; 후자 그룹은 배열 인터페이스 유형 문자열 스펙에 사용 된 문자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">각 차원을 따라 빈의 가장 왼쪽과 오른쪽 가장자리 ( &lt;code&gt;bins&lt;/code&gt; 매개 변수에 명시 적으로 지정되지 않은 경우 ) : &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; . 이 범위를 벗어나는 모든 값은 특이 치로 간주되며 히스토그램에서 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">의 길이 &lt;code&gt;condlist&lt;/code&gt; 은 의 일치해야합니다 &lt;code&gt;funclist&lt;/code&gt; . 하나의 추가 함수 &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; 예 : len (funclist) == len (condlist) + 1)가 제공 되면 해당 추가 함수가 기본값이며 모든 조건이 false 인 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">정수 목록의 길이입니다. &lt;em&gt;ptr&lt;/em&gt; [0]에서 &lt;em&gt;ptr&lt;/em&gt; [len-1] 에 액세스하는 것이 안전하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">접두사 및 접미사 문자열의 길이는 각각 출력을 정렬하고 줄 바꿈하는 데 사용됩니다. 배열은 일반적으로 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">결과 문자열의 길이</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">반환되는 문자열의 길이는 경우 &lt;code&gt;num&lt;/code&gt; 양수 또는 2의 보수의 길이 경우 &lt;code&gt;num&lt;/code&gt; 이 제공 음수 &lt;code&gt;width&lt;/code&gt; 의 비트 적어도 충분한 개수 &lt;code&gt;num&lt;/code&gt; 지정된 형태로 표현된다.</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">바이트 단위의 세그먼트 길이</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">범위의 길이는 64 비트 정수의 범위에 날짜 또는 단위 길이를 곱한 값입니다. 예를 들어, 'W'(주)의 시간 범위는 'D'(일)의 시간 범위보다 정확히 7 배 길고 'D'(일)의 시간 범위는 시간 범위보다 정확히 24 배 길다 'h'(시간).</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">위의 줄은 z ** 3 + 0 * z ** 2 + 0 * z + 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">위의 줄은 z ** 3-z / 4를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old&lt;/code&gt; 도메인을 &lt;code&gt;new&lt;/code&gt; 도메인에 매핑하는 선형 맵 &lt;code&gt;offset + scale*x&lt;/code&gt; 가 포인트 &lt;code&gt;x&lt;/code&gt; 에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">출력 요소를 가져 오는 배열 목록입니다. &lt;code&gt;condlist&lt;/code&gt; 와 길이가 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">선택 목록의 어떤 배열에서 출력 요소를 가져 &lt;code&gt;choicelist&lt;/code&gt; 를 결정하는 조건 목록입니다 . 여러 조건이 충족되면 &lt;code&gt;condlist&lt;/code&gt; 에서 처음 발견 된 조건 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">슬라이스에서, 마스킹 요소의 각각에 대한 연속적인 영역 일 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">슬라이스의 목록에서 마스킹 요소들 각각에 대한 연속적인 영역 일 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">소스 목록에는 패턴 &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 함수 ( '소스 생성기')가 포함될 수 있습니다 . &lt;code&gt;funcname&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 소스가 생성되지 않습니다. 또한 모든 소스 생성기를 처리 한 후 &lt;code&gt;Extension&lt;/code&gt; 인스턴스에 소스가 없으면 확장 모듈이 빌드되지 않습니다. 이는 확장 모듈을 조건부로 정의하기 위해 권장되는 방법입니다. 소스 생성 기능에 의해 호출되는 &lt;code&gt;build_src&lt;/code&gt; 의 의 명령 &lt;code&gt;numpy.distutils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">배포 모드의 위치입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">로그 계열 분포는 1943 년 Fisher, Corbet 및 Williams가 처음 제안한 종의 풍부함과 발생을 나타내는 데 자주 사용됩니다 [2]. 자동차에서 보이는 탑승자 수를 모델링하는 데 사용될 수도 있습니다 [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 10 인 로그는 요소 별입니다. x가 음수이면 NaN이 반환됩니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">출력 함의 하한 및 상한 범위 제공되지 않으면 범위는 단순히 &lt;code&gt;(a.min(), a.max())&lt;/code&gt; 입니다. 범위를 벗어난 값은 무시됩니다. 범위의 첫 번째 요소는 두 번째보다 작거나 같아야합니다. &lt;code&gt;range&lt;/code&gt; 는 자동 빈 계산에도 영향을줍니다. &lt;code&gt;range&lt;/code&gt; 너비는 range 내의 실제 데이터를 기반으로 최적으로 계산되지만 구간 개수는 데이터가없는 부분을 포함하여 전체 범위를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">샘플의 상위 1 %에 대한 하한은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">명확한 적분의 하한.</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">적분의 하한. (기본값 : 0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">최저 공배수</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">입력 절대 값의 최소 공배수 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">의 가장 큰 특징 &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈이다 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 의&lt;/a&gt; 클래스의 하위 클래스 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 이&lt;/a&gt; . 클래스, 속성 및 메소드는 &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray 클래스&lt;/a&gt; 섹션 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">가수 &lt;code&gt;x1&lt;/code&gt; 및 2 개의 지수 &lt;code&gt;x2&lt;/code&gt; 는 부동 소수점 숫자 &lt;code&gt;x1 * 2**x2&lt;/code&gt; 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">맵 &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; 는 첫 번째 도메인을 두 번째 도메인에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">매핑 기능은 &lt;code&gt;off + scl*x&lt;/code&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 이 유효한 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 마스크가 손실됩니다 !</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 이 유효한 MaskedArray가 아닌 경우 마스크가 손실됩니다 !</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">마스크 된 어레이의 마스크는 해당 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; 속성을 통해 액세스 할 수 있습니다 . 마스크 의 &lt;code&gt;True&lt;/code&gt; 항목은 &lt;em&gt;유효하지 않은&lt;/em&gt; 데이터를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">채우기 값을 비교할 마스크 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">matmul 함수는 PEP465 에 이어 Python 3.5에 도입 된 &lt;code&gt;@&lt;/code&gt; 연산자 의 의미를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">행렬 클래스는 ndarray의 Python 하위 클래스이며 ndarray의 자체 하위 클래스를 구성하는 방법에 대한 참조로 사용할 수 있습니다. 행렬은 다른 행렬, 문자열 및 &lt;code&gt;ndarray&lt;/code&gt; 로 변환 할 수있는 다른 항목으로 만들 수 있습니다 . &amp;ldquo;mat&amp;rdquo;이라는 이름은 NumPy에서&amp;ldquo;matrix&amp;rdquo;의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 로 주어진 모양을 가진 임의의 값의 행렬 .</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">입력 값의 행렬 곱입니다. 이것은 x1, x2가 모두 1-d 벡터 인 경우에만 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">조건 번호를 찾는 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">행렬이지만 모양이 (N, 1) 인 경우 (1, N) 행렬로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1과 x2가 모두 nans 인 경우 최대 값은 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르며 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">배열에 허용되는 최대 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">읽을 최대 행 수입니다. skip_footer와 동시에 사용해서는 안됩니다. 주어진 경우 값은 1 이상이어야합니다. 기본값은 전체 파일을 읽는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">공차에 대한 마지막 위치의 최대 단위 수입니다 (주 참조). 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소가 다를 수 있는 마지막 위치의 최대 단위 수입니다 . 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">요소 별 최대 &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">주어진 축을 따라 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 주어진 축을 따라 배열의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값으로, NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">출력 요소의 최대 값 빈 슬라이스에서 계산할 수 있도록 있어야합니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">평균은 샘플이 생성 될 가능성이 가장 높은 위치를 나타내는 N 차원 공간의 좌표입니다. 이것은 1 차원 또는 일 변량 정규 분포에 대한 종 곡선의 피크와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">평균은 일반적으로 &lt;code&gt;x.sum() / N&lt;/code&gt; 으로 계산되며 , 여기서 &lt;code&gt;N = len(x)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;ddof&lt;/code&gt; 를 지정하면 제수 &lt;code&gt;N - ddof&lt;/code&gt; 가 대신 사용됩니다. 표준 통계 실습에서, &lt;code&gt;ddof=1&lt;/code&gt; 은 가정 무한 모집단의 분산에 대한 편견 추정치를 제공합니다. &lt;code&gt;ddof=0&lt;/code&gt; 은 정규 분포 변수에 대한 분산의 최대 우도 추정값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">멤버들은</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">이 구조의 멤버는</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">memmap 객체는 ndarray가 허용되는 모든 곳에서 사용할 수 있습니다. memmap의 주어 &lt;code&gt;fp&lt;/code&gt; , &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; 반환 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">고급 인덱싱 결과의 메모리 레이아웃은 각 인덱싱 작업에 대해 최적화되며 특정 메모리 순서는 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">병합 된 결과.</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">메소드는 조작 결과를 리턴하거나 요청 된 조작이 구현되지 않은 경우 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 를&lt;/a&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">이 메소드는 계산에 다음 특성을 사용합니다. let</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">최적의 빈 수를 추정하는 방법은 문헌에 잘 나와 있으며 R이 히스토그램 시각화를 위해 제공하는 선택에서 영감을 얻었습니다. 빈 개수에 비례하여</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">최소 데이터 유형</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1과 x2가 NaN이 아닌 경우 최소값은 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르고 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 최소값은 요소 별입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">표현 가능한 최소값.</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">주어진 축을 따라 최소값.</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 주어진 축을 따라 배열의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값으로, NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">출력 요소의 최소값입니다. 빈 슬라이스에서 계산할 수 있도록 있어야합니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">모드는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">수정 된 Bessel 함수는 &lt;code&gt;x&lt;/code&gt; 의 각 요소에서 평가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">척도 모수를 포함하여보다 일반적인 2 모수 Weibull</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 로 수행 할 수있는 가장 기본적인 작업 은 배열의 모든 요소를 ​​방문하는 것입니다. 각 요소는 표준 Python 반복자 인터페이스를 사용하여 하나씩 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">날짜 / 시간을 생성하는 가장 기본적인 방법은 ISO 8601 날짜 또는 날짜 / 시간 형식의 문자열입니다. 내부 저장 단위는 문자열 형식에서 자동으로 선택되며 &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;날짜 단위&lt;/a&gt; 또는 &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;시간 단위 &lt;/a&gt;일 수 있습니다 . 날짜 단위는 년 ( 'Y'), 월 ( 'M'), 주 ( 'W') 및 일 ( 'D')이며 시간 단위는 시간 ( 'h'), 분 ( 'm' ), 초 ( 's'), 밀리 초 ( 'ms') 및 추가 SI- 접두사 초 기반 단위입니다.</target>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">이 함수의 가장 일반적인 용도는 블록 행렬을 만드는 것입니다</target>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">가수 (mantissa)에 선행 0이없는 것과 일치하는베이스 (2)의 가장 부정적인 힘.</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">샘플 x의 다차원 히스토그램. 가능한 다른 의미론에 대해서는 표준 및 가중치를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">다항 분포는 이항 분포의 다변량 일반화입니다. 가능한 &lt;code&gt;p&lt;/code&gt; 가지 결과 중 하나를 사용하여 실험 해보십시오 . 이러한 실험 예는 결과가 1 분포로부터 그려 각 샘플을 나타내는 제 통해 할 수있는 주사위 던지고 &lt;code&gt;n&lt;/code&gt; 이러한 실험. 그 값은 &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; , 결과가되는 횟수를 나타내는 &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">곱셈은 ​​Hermite 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">곱셈은 ​​Laguerre 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">곱셈은 ​​Legendre 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">멀티 스레드 난수 생성기를 사용하여 배열을 채울 수 있습니다. &lt;code&gt;values&lt;/code&gt; 방송을 충전 후의 랜덤 값 전 제로 값 속성.</target>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">다변량 정규, 다 정규 또는 가우시안 분포는 1 차원 정규 분포를 더 높은 차원으로 일반화합니다. 이러한 분포는 평균 및 공분산 행렬로 지정됩니다. 이 모수는 1 차원 정규 분포의 평균 (평균 또는 &quot;중심&quot;) 및 분산 (표준 편차 또는 &quot;폭&quot;제곱)과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n 차원 배열</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">n 번째 차이점. 출력의 모양과 동일 따라 제외 &lt;code&gt;axis&lt;/code&gt; 치수가 작아 인 &lt;code&gt;n&lt;/code&gt; . 출력 유형은 &lt;code&gt;a&lt;/code&gt; 의 두 요소 간 차이 유형과 동일 합니다 . 이 유형과 동일 대부분의 경우이다. 주목할만한 예외는 &lt;code&gt;datetime64&lt;/code&gt; 이며 &lt;code&gt;timedelta64&lt;/code&gt; 출력 배열이됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">인코딩 이름</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">각 열의 이름입니다 &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 예 : ( 'x', 'y', 'z')) .</target>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">함수의 이름은 '피크 투 피크'의 약어에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">다항식 변수의 이름</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">ufunc의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">sinc라는 이름은 &quot;사인 추기경&quot;또는 &quot;sinus cardinalis&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">바이트 오프셋 증가에 따라 이름이 정렬됩니다. 예를 들어, 이름이 지정된 모든 필드를 오프셋 순서로 탐색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">C 코드에서 유형의 이름은 c 명명 규칙을보다 밀접하게 따릅니다. 이러한 유형의 Python 이름은 Python 규칙을 따릅니다. 따라서 &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 는 C에서 32 비트 부동 소수점을 선택하지만 Python의 &lt;code&gt;numpy.float_&lt;/code&gt; 는 64 비트 double에 해당합니다. 비트 폭 이름은 명확성을 위해 Python과 C 모두에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">기본 NumPy 인덱싱 유형은 &lt;code&gt;intp&lt;/code&gt; 이며 기본 정수 배열 유형과 다를 수 있습니다. &lt;code&gt;intp&lt;/code&gt; 는 배열을 안전하게 색인하기에 충분한 가장 작은 데이터 유형입니다. 고급 인덱싱의 경우 다른 유형보다 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">결정 요인의 절대 값에 대한 자연 로그입니다.</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자연 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 지수 함수의 역수이므로 &lt;code&gt;log(exp(x)) = x&lt;/code&gt; 입니다. 자연 로그는 밑 &lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; 의&lt;/a&gt; 로그입니다 .</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 &lt;code&gt;x&lt;/code&gt; 의 자연 로그입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 가 호출되거나 컨텍스트가 종료 되면 nditer를 더 이상 반복 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">그러면 nditer는 사용자가 수정할 수있는 쓰기 가능한 버퍼 배열을 생성합니다. 그러나 nditer는 반복이 완료되면이 버퍼 데이터를 원래 배열로 다시 복사해야하므로 반복이 종료되면 두 가지 방법 중 하나로 신호를 보내야합니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">새로운 배열은 기존 배열의 데이터로 구성되며 필요한 수의 요소를 채우는 데 필요한 경우 반복됩니다. 데이터는 메모리에 저장된 순서대로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">새로운 인프라는 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 객체 에서 난수를 생성하는 다른 접근 방식을 취 합니다. 난수 생성은 비트 생성기와 임의 생성기의 두 가지 구성 요소로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">새로운 키워드 인수 인터페이스와 &lt;code&gt;excluded&lt;/code&gt; 인수 지원은 성능을 더욱 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">새로운 모양은 원래 모양과 호환되어야합니다. 정수가 제공되면 결과는 해당 길이의 1 차원 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">새로운 모양은 원래 모양과 호환되어야합니다. 정수이면 결과는 해당 길이의 1 차원 배열이됩니다. 하나의 모양 차원은 -1 일 수 있습니다. 이 경우 값은 배열의 길이와 나머지 차원에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">다음 1 바이트는 부호없는 바이트입니다. 파일 형식의 주 버전 번호입니다 (예 : &lt;code&gt;\x01&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">다음 1 바이트는 부호없는 바이트입니다. 파일 형식의 부 버전 번호입니다 (예 : &lt;code&gt;\x00&lt;/code&gt; . 참고 : 파일 형식 버전은 numpy 패키지 버전과 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">다음 2 바이트는 리틀 엔디안 부호없는 short int를 형성합니다. 헤더 데이터 길이 HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">다음 HEADER_LEN 바이트는 배열 형식을 설명하는 헤더 데이터를 형성합니다. 사전의 Python 리터럴 표현식을 포함하는 ASCII 문자열입니다. 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; ) 으로 끝나고 공백 ( &lt;code&gt;\x20&lt;/code&gt; )으로 &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; 정렬 목적으로 len (magic string) + 2 + len (length) + HEADER_LEN의 합계 를 64로 균등하게 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; 방향으로 &lt;code&gt;x1&lt;/code&gt; 의 다음 표현 가능한 값 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">다음 단계는 찾은 색인 유형에 따라 다릅니다. 모든 차원이 정수로 색인화되면 스칼라가 리턴되거나 설정됩니다. 단일 부울 인덱싱 배열은 특수한 부울 함수를 호출합니다. 줄임표 나 슬라이스를 포함하지만 고급 인덱싱은 포함하지 않은 인덱스는 항상 새로운 보폭과 메모리 오프셋을 계산하여 이전 배열에 대한 뷰를 만듭니다. 그런 다음이 뷰를 반환하거나 할당을 위해 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 를 사용하여 채울 수 있습니다. 배열이 객체 dtype 인 경우 복잡한 할당을 지원하기 위해 다른 분기의 임시 배열에서 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">다음 표는 레거시 생성기 &lt;code&gt;RandomState(MT19937())&lt;/code&gt; 의해 생성 된 값에 대한 성능을 백분율로 나타냅니다 . 전반적인 성능은 기하 평균을 사용하여 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">비 중심</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 본질적으로 종종 발생합니다. 예를 들어, 각각 고유 한 분포를 갖는 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 본질적으로 종종 발생합니다. 예를 들어, 각각 고유 한 분포를 갖는 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정규, 지수 및 감마 생성기는 &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; 에서 NumPy의 기본 구현보다 2-10 배 빠른 256 단계 Ziggurat 메소드를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">열 &lt;code&gt;v[:,i]&lt;/code&gt; 가 고유 값 &lt;code&gt;w[i]&lt;/code&gt; 대응하는 고유 벡터가되도록 정규화 된 (단위 &quot;길이&quot;) 고유 벡터 .</target>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">핵 규범은 특이 값의 합입니다.</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">숫자 13은 binaray 표현 &lt;code&gt;00001101&lt;/code&gt; 을 갖습니다 . 마찬가지로 16은 &lt;code&gt;00010000&lt;/code&gt; 으로 표시됩니다 . 13과 16의 비트 단위 OR은 &lt;code&gt;000111011&lt;/code&gt; 또는 29입니다.</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">숫자 13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시됩니다 . 마찬가지로 17은 &lt;code&gt;00010001&lt;/code&gt; 로 표시됩니다 . 따라서 13과 17의 비트 AND는 &lt;code&gt;000000001&lt;/code&gt; 또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">숫자 13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시됩니다 . 마찬가지로 17은 &lt;code&gt;00010001&lt;/code&gt; 로 표시됩니다 . 따라서 13과 17의 비트 XOR은 &lt;code&gt;00011100&lt;/code&gt; 또는 28입니다.</target>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">숫자 &lt;code&gt;w&lt;/code&gt; 는 &lt;code&gt;dot(a,v) = w * v&lt;/code&gt; 와 같은 벡터 &lt;code&gt;v&lt;/code&gt; 가 존재 &lt;code&gt;a&lt;/code&gt; 경우 a 의 고유 값입니다 . 따라서, 배열은 , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 방정식이 만족 &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; 에 대한 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">인수의 수</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">같은 모양으로 브로드 캐스트해야하는 어레이 수입니다.</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">단계의 기본 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">빈의 수 (크기 1)는 &lt;code&gt;x&lt;/code&gt; 의 가장 큰 값보다 하나 더 큽니다 . 경우 &lt;code&gt;minlength&lt;/code&gt; 지정되어, (필요한 경우 그것의 내용에 따라 더 길어질 수 있지만 출력 배열 빈들 중 적어도이 수있을 것이다 &lt;code&gt;x&lt;/code&gt; ). 각 구간은 &lt;code&gt;x&lt;/code&gt; 의 색인 값 발생 횟수를 제공합니다 . 경우 &lt;code&gt;weights&lt;/code&gt; 지정 값이있는 경우, 입력 배열은, 그것에 의해, 즉 가중 &lt;code&gt;n&lt;/code&gt; 위치에서 발견되는 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;out[n] += weight[i]&lt;/code&gt; 대신 &lt;code&gt;out[n] += 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">모든 차원에 대한 구간 수 (nx = ny =&amp;hellip; = bins).</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">각 차원의 빈 수 (nx, ny,&amp;hellip; = bins)</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">&lt;code&gt;a.size&lt;/code&gt; 수는 큐브 루트의 a.size에 비례합니다 . 빈 수를 과대 평가하는 경향이 있으며 데이터 변동성을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;a.size&lt;/code&gt; 는 a.size 의 기본 2 로그입니다 . 이 추정기는 데이터의 정규성을 가정하며 더 큰 비정규 데이터 세트에는 너무 보수적입니다. 이것이 R의 &lt;code&gt;hist&lt;/code&gt; 방법 의 기본 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">부호 및 바이어스를 포함하여 지수의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">부동 소수점 표현의 지수 부분에있는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">가수의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">유형이 차지하는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">시뮬레이션 된 값을 생성하는 데 필요한 비트 수는 기본 RNG에 의해 생성 된 비트 수와 다릅니다. 예를 들어, 32 비트 RNG의 단일 드로우에서 두 개의 16 비트 정수 값을 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">배열의 각 항목에 필요한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 배치 할 필드의 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">줄 바꿈을 삽입하기위한 줄당 문자 수입니다 (기본값 : 75).</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">이미 생성 된 어린이 수입니다. 직렬화 된 양식에서 &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 를 재구성하는 경우에만이를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">차원의 수와 각 차원의 크기</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">배열의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">브로드 캐스트 된 결과의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">8의 배수가 아닌 크기를 패킹하는 효과를 취소하는 방법으로 제공되는 &lt;code&gt;axis&lt;/code&gt; 따라 패킹 해제 할 요소의 수입니다 . 음수가 아닌 숫자는 &lt;code&gt;count&lt;/code&gt; 비트의 압축을 풉니 다 . 음수는 끝에서 많은 비트를 잘라내는 것을 의미합니다. &lt;code&gt;None&lt;/code&gt; 은 전체 배열의 압축을 풉니 다 (기본값). 사용 가능한 비트 수보다 큰 카운트는 출력에 제로 패딩을 추가합니다. 음수는 사용 가능한 비트 수를 초과해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">부동 소수점 유형의 수</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">입력 인수의 수</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">입력 수</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">수행 할 통합 수입니다.</target>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">&lt;em&gt;iterable&lt;/em&gt; 에서 읽을 항목 수입니다 . 기본값은 -1이며 모든 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">반복자 피연산자의 수입니다.</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">파일의 시작 부분에서 건너 뛸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">파일 끝에서 건너 뛸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">ufunc가 작동 할 수있는 숫자 NumPy 유형의 수는 총 18 개입니다.</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 가 반환 한 객체 수입니다 .</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">출력 인수의 수</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">출력 수</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">주기 &lt;code&gt;nper&lt;/code&gt; 는 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">요소가 이동하는 장소의 수입니다. 튜플 인 경우 &lt;code&gt;axis&lt;/code&gt; 동일한 크기의 튜플이어야하며 지정된 각 축은 해당 숫자만큼 이동합니다. int while &lt;code&gt;axis&lt;/code&gt; 이 int 의 튜플 인 경우 모든 주어진 축에 동일한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">각 요소의 반복 횟수입니다. 주어진 축의 모양에 맞게 &lt;code&gt;repeats&lt;/code&gt; 이 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">각 축을 따라 &lt;code&gt;A&lt;/code&gt; 반복 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">ufunc에 지원되는 데이터 유형 수입니다. 이 숫자는 사용 가능한 여러 가지 1 차원 루프 (내장 데이터 유형)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 제 1 및 제 2 축을 따라 반복되는 횟수 .</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">고유 값 각각이 원래 배열에 나타나는 횟수입니다. &lt;code&gt;return_counts&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">횟수 값이 다릅니다. 0이면 입력이 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">유형의 수</target>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">numpy 배열은 ctypes 객체와 메모리를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">numpy 핵심 수학 라이브러리 ( 'npymath')는이 방향의 첫 번째 단계입니다. 이 라이브러리에는 대부분의 수학 관련 C99 기능이 포함되어 있으며 C99가 제대로 지원되지 않는 플랫폼에서 사용할 수 있습니다. 핵심 수학 함수는 npy_ * 접두사를 제외하고 C99 함수와 동일한 API를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">numpy.ma 모듈</target>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">형식이 반환되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">형식 및 요구 사항 충족 배열로 변환 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">확인할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">&lt;code&gt;object_&lt;/code&gt; items를 포함하는 배열 은 항목 액세스시 &lt;code&gt;object_&lt;/code&gt; 오브젝트를 리턴하지 않고 대신 배열 항목이 참조하는 실제 오브젝트를 리턴 하므로 오브젝트 유형도 특별 합니다.</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">이러한 파라미터를 계산하고보다 자세한 정보를 보유한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">파일의 현재 위치로부터의 오프셋 (바이트)입니다. 기본값은 0입니다. 이진 파일에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">이전 오류 처리기</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">이전 반복자 API에는 PyArrayIter_Check, PyArray_Iter * 및 PyArray_ITER_ *와 같은 함수가 포함되어 있습니다. 다중 반복자 배열에는 PyArray_MultiIter *, PyArray_Broadcast 및 PyArray_RemoveSmallest가 포함됩니다. 새로운 반복자 디자인은이 모든 기능을 단일 객체 및 관련 API로 대체합니다. 새로운 API의 목표 중 하나는 기존 반복기의 모든 사용을 큰 노력없이 새 반복기로 교체 할 수 있어야한다는 것입니다. 1.6에서 이것에 대한 주요 예외는 이터레이터에 해당하는 기능이없는 이웃 이터레이터입니다.</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">1 차원 (앞으로) FFT로, &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 가 역인 경우</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">일반 (복잡한) 입력의 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">실제 입력의 1 차원 FFT는 &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">정의 및 규칙이 사용 된 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">1 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">결과 유형이 필요한 일부 연산의 피연산자</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">내부 루프의 연산은 간단한 곱셈입니다. 외부 제품과 관련된 모든 것은 반복자 설정에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">선택적 출력 인수를 사용하면 대규모 계산을 위해 메모리를 절약 할 수 있습니다. 배열이 크면 복잡한 계산은 임시 계산 공간의 생성 및 (나중에) 파괴로 인해 절대적으로 필요한 시간보다 오래 걸릴 수 있습니다. 예를 들어, 표현식 &lt;code&gt;G = a * b + c&lt;/code&gt; 는 &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; 와 같습니다 . G = T1 + C; 델 t1 . &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; 로 더 빨리 실행됩니다 . &lt;code&gt;G = A * B; G += C&lt;/code&gt; 와 동일한 add (G, C, G) ; G는 = C + .</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">선택적인 세 번째 요소 인 &lt;em&gt;field_shape&lt;/em&gt; 는이 필드가 두 번째 요소의 데이터 유형 배열을 나타내는 경우 모양을 포함합니다. 세 번째 인수가 1 인 3 개의 튜플은 2 개의 튜플과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">'축소', '완료'및 '원시'옵션은 numpy 1.8의 새로운 기능입니다. 자세한 내용은 참고를 참조하십시오. 기본값은 '감소'이며 이전 버전의 numpy와의 호환성을 유지하기 위해 이전 기본값 인 'full'을 생략 할 수 있습니다. 'raw'모드에서 반환 된 h 배열은 Fortran 호출을 위해 바뀝니다. '경제적'모드는 더 이상 사용되지 않습니다. 'full'및 'economic'모드는 이전 버전과의 호환성을 위해 첫 번째 문자 만 사용하여 전달할 수 있지만 다른 모든 문자는 철자해야합니다. 자세한 설명은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">배열 데이터가 메모리에 저장되는 순서 : 'C'-&amp;gt; &quot;행 주요&quot;순서 (기본값), &quot;F&quot;-&amp;gt; &quot;열 주요&quot;(Fortran) 순서.</target>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; 과 &lt;code&gt;v2&lt;/code&gt; 의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">입력 비트의 순서입니다. 'big'은 bin (val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 을 모방합니다 . =&amp;gt; 3 = 0b00000011 =&amp;gt;``, 'little'는 순서를 반대로하여``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3 입니다. 기본값은 'big'입니다.</target>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">반환 된 비트의 순서입니다. 'big'은 bin (val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; 을 모방합니다 . 'little'는 순서를 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; . 기본값은 'big'입니다.</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">다항식의 차수 또는 차수</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 의 방향은 &lt;code&gt;axisc&lt;/code&gt; 키워드를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;coef&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;domain&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;window&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out 인수는 결과를 배치 할 위치를 지정합니다. out이 NULL이면 출력 배열이 작성되고, 그렇지 않으면 출력이 올바른 크기 및 유형이어야합니다. 출력 배열에 대한 새로운 참조는 out이 NULL이 아닌 경우에도 항상 반환됩니다. 루틴 호출자는 NULL이 아니거나 메모리 누수가 발생하는 경우 &lt;code&gt;DECREF&lt;/code&gt; 를 수행 할 책임 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">외부 제품</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">출력 인수 (있는 경우)가 처리되고 누락 된 리턴 배열이 구성됩니다. 제공된 출력 배열에 올바른 유형이 없거나 잘못 정렬 된 경우 버퍼 크기보다 작은 경우 특수 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그가 설정된 새 출력 배열이 구성됩니다 . 함수가 &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 가 호출되어 그 내용이 출력 배열로 다시 복사됩니다. 그런 다음 출력 인수에 대한 반복자가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 축을 따라 모든 값이 마스킹되는 경우 출력 배열이 마스킹됩니다. 출력이 스칼라 였고 모든 값이 마스킹 된 경우 출력이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 와 일치하는 &lt;code&gt;file&lt;/code&gt; 내용의 일부를 포함하는 출력 배열 입니다. &lt;code&gt;output&lt;/code&gt; 은 항상 구조화 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">출력 배열, &lt;code&gt;x1&lt;/code&gt; 의 요소 별 Heaviside 단계 함수 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">출력 배열</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">출력 배열 측정의 수는 동일하다 이지만 형상은 다를 수있다. 이는 &lt;code&gt;func&lt;/code&gt; 이 입력과 관련하여 출력 모양을 변경 하는지 여부에 따라 다릅니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">출력 배열 형상 &lt;code&gt;out&lt;/code&gt; 의 형상과 동일하다 &lt;code&gt;arr&lt;/code&gt; 따라 제외 &lt;code&gt;axis&lt;/code&gt; 치수. 이 축은 제거되고 &lt;code&gt;func1d&lt;/code&gt; 의 반환 값 모양과 동일한 새 치수로 대체됩니다 . 따라서 &lt;code&gt;func1d&lt;/code&gt; 가 반환하면 스칼라 &lt;code&gt;out&lt;/code&gt; 은 &lt;code&gt;arr&lt;/code&gt; 보다 하나의 치수가 작습니다 .</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">위치 m의 출력은 &lt;code&gt;choicelist&lt;/code&gt; 에있는 배열 의 m 번째 요소이며 &lt;code&gt;condlist&lt;/code&gt; 에있는 해당 배열의 m 번째 요소 는 True입니다.</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">출력 데이터 유형 유형 코드 문자 문자열 또는 데이터 유형 지정자 목록으로 지정해야합니다. 각 출력마다 하나의 데이터 유형 지정자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">출력은 입력과 동일한 모양을 가지며 각 1D 루프는</target>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">출력은 접두사 문자열의 길이만큼 왼쪽으로 채워지고 &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; 열에서 줄 바꿈이 적용 됩니다 . 접두사 및 접미사 문자열의 내용은 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">출력은 x와 같은 모양과 유형이며 &lt;code&gt;funclist&lt;/code&gt; 의 부울 배열에 의해 정의 된대로 &lt;code&gt;x&lt;/code&gt; 의 적절한 부분 에서 funclist 의 함수를 호출하여 &lt;code&gt;condlist&lt;/code&gt; . 어떤 조건에서 다루지 않는 부분의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;argwhere&lt;/code&gt; 의 출력은 배열 인덱싱에 적합하지 않습니다. 이를 위해 &lt;code&gt;nonzero(a)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">ufunc (및 그 방법)의 출력은 반드시 없다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 모든 입력 인자가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; 이&lt;/a&gt; . 실제로 어떤 입력이 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메소드를 정의하면 제어가 해당 함수에 완전히 전달됩니다. 즉, ufunc가 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;재정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">치밀한 경우의 출력 형태는 치수의 튜플 앞에 치수의 수를 앞에 붙여서, 즉 &lt;code&gt;dimensions&lt;/code&gt; 가 길이 &lt;code&gt;N&lt;/code&gt; 의 튜플 &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; 인 경우 출력 형태는 &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">출력 유형은 지정되지 않은 경우 입력의 첫 번째 요소를 평가하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 출력 에는 모든 축의 하위 코너에있는 제로 주파수에 대한 항, 모든 축의 전반에있는 양의 주파수 항, 모든 축의 가운데에있는 나이키 스트 주파수에 대한 항 및 음수가 포함됩니다. 음의 주파수가 감소하는 순서로 모든 축의 후반부에있는 주파수 항.</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 출력 에는 변환 된 축의 하위 코너에있는 제로 주파수에 대한 항,이 축의 전반에있는 양의 주파수 항, 축의 중간에있는 나이키 스트 주파수에 대한 항 및 음의 주파수가 감소하는 순서로 축의 후반부에서 음의 주파수 항.</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">패키지는 마스크 된 항목이 계산에 사용되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">사용할 패딩 문자 (기본값은 공백)입니다.</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">패딩 기능을 사용하는 경우 순위 1 배열을 그 자리에서 수정해야합니다. 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">매개 변수 &lt;code&gt;oa_ndim&lt;/code&gt; 은 0이 아니거나 -1이 아닌 경우 사용자 지정 브로드 캐스트로 반복 될 차원 수를 지정합니다. 제공되는 경우 &lt;code&gt;op_axes&lt;/code&gt; 가 필요하고 &lt;code&gt;itershape&lt;/code&gt; 도 제공 할 수 있습니다. &lt;code&gt;op_axes&lt;/code&gt; 피연산자 배열의 축이 서로 일치하고 반복되는 방법을 보자 매개 변수는 구체적으로 제어 할 수 있습니다. 에서 &lt;code&gt;op_axes&lt;/code&gt; , 당신은의 배열을 제공해야 &lt;code&gt;nop&lt;/code&gt; 에 대한 포인터를 &lt;code&gt;oa_ndim&lt;/code&gt; 형의 2N 크기 배열 &lt;code&gt;npy_intp&lt;/code&gt; 을 . &lt;code&gt;op_axes&lt;/code&gt; 의 항목 이 NULL이면 일반 브로드 캐스트 규칙이 적용됩니다. 에서는 &lt;code&gt;op_axes[j][i]&lt;/code&gt; 하나의 유효 축 저장 &lt;code&gt;op[j]&lt;/code&gt; -1하는 수단 &lt;code&gt;newaxis&lt;/code&gt; . 각 &lt;code&gt;op_axes[j]&lt;/code&gt; 배열 내에서 축이 반복되지 않을 수 있습니다. 다음 예제는 일반 브로드 캐스트가 3D 배열, 2D 배열, 1D 배열 및 스칼라에 적용되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자체 및 &lt;code&gt;c&lt;/code&gt; 요소와 함께 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;r&lt;/code&gt; 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 매개 변수 는 합산과 같은 축소 연산이 수행되어야하는 데이터 유형을 지정합니다. 기본 축소 데이터 형식은 &lt;em&gt;self&lt;/em&gt; 데이터 형식과 동일합니다 . 오버플로를 피하려면 더 큰 데이터 유형을 사용하여 축소를 수행하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리되며 변환 후 동일한 모양을 가져야합니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 튜플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리되며 변환 후 동일한 모양을 가져야합니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 튜플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">현재 패키지 경로에 상대적인 템플릿 경로입니다.</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">doctest가 실행되는 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">중첩 된 반복자를 사용하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 더 복잡한 다른 발전기와 비슷합니다. 레거시 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 생성기 의 일반적인 성능은 Ziggurat 생성기보다는 Box-Muller 변환을 사용하므로 다른 것보다 훨씬 낮습니다. CDF를 반전시키기 위해 로그 함수를 계산하는 비용으로 인해 지수의 성능 격차도 큽니다. MT19973으로 표시된 열은 RandomState와 동일한 32 비트 생성기에서 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 되지만 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 사용하여 임의의 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">지불은 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">3 미터보다 큰 파도의 비율은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">32 비트 Windows에서 64 비트 생성기의 성능은 레지스터 너비로 인해 64 비트 운영 체제보다 훨씬 낮습니다. 2005 년 이래 NumPy에있는 생성기 인 MT19937은 32 비트 정수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">다항식 계수</target>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">입력 값의 곱셈으로 인한 다항식입니다. 입력 중 하나가 poly1d 객체이면 출력도 poly1d 객체입니다. 그렇지 않으면 다항식 계수의 1D 배열이 최고에서 최저까지입니다.</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">현재 인스턴스를 변환 할 다항식 계열 유형 클래스입니다. kind가 None이면 현재 인스턴스의 클래스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">다항식 계수 (감소 전력) 또는 두 번째 매개 변수의 값이 True 인 경우 다항식의 근 (다항식이 0으로 평가되는 값)입니다. 예를 들어 &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; 는 다음을 나타내는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">위치,</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">배열 요소의 중첩 가능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">전력 함수 분포는 파레토 분포의 역수입니다. 베타 배포의 특별한 경우로 보일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">병렬 응용 프로그램에서 &lt;code&gt;SeedSequence.spawn&lt;/code&gt; 를 사용하는 기본 방법 은 SeedSequence.spawn 메서드를 사용하여 엔트로피 값을 얻고이 값을 사용하여 새 BitGenerator를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">일반 유형 C 소스 파일의 전처리 (NumPy에서 또는 NumPy Distutils를 사용하는 타사 패키지에 상관없이)는 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py에&lt;/a&gt; 의해 수행됩니다 . 빌드 프로세스 중 이러한 모듈에서 생성 된 유형별 C 파일 (확장자 : .c)을 컴파일 할 준비가되었습니다. 이 형식의 일반 유형은 C 헤더 파일 (.h 파일을 생성하기 위해 사전 처리됨)에도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 의 존재는 또한 &lt;code&gt;arr&lt;/code&gt; 이 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 사용자 정의 클래스의 인스턴스 일 때 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;arr + obj&lt;/code&gt; 및 &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 와 같은 이진 연산을 처리 하는 방법에 영향을줍니다 . 두 가지 가능성이 있습니다. 경우 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 나타나지 않고 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;ndarray.__add__&lt;/code&gt; 과 친구들은 그 의미하는 ufunc 기계에 위임합니다 &lt;code&gt;arr + obj&lt;/code&gt; 된다 &lt;code&gt;np.add(arr, obj)&lt;/code&gt; 한 다음 &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; 를 발동 할 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; . 배열처럼 작동하는 객체를 정의하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">현재 값은 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">의 각 항목과 관련된 확률 제시되지 않은 경우 샘플은 a의 모든 항목에 대해 균일 한 분포를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">감마 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">가우스 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">Gumbel 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">초기 하 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">로그 시리즈 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">로지스틱 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">파레토 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">와 이블 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Zipf 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">이항 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">폰 미제스 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">확률 밀도 함수</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">레일리 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">Wald 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">전체 Cauchy 분포에 대한 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">비 중심 카이-제곱 분포의 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">t 분포에 대한 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">삼각 분포에 대한 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">카이 제곱 분포의 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">정규 분포의 확률 밀도 함수는 De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출됩니다 &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; . 특징적인 형태 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">정규 분포의 확률 밀도 함수는 De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출됩니다 &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; . 특징적인 형태 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">균일 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">확률 입력은 정규화되어야합니다. 구현 세부 사항으로, 마지막 항목의 값은 무시되고 남은 확률 질량을 취한다고 가정하지만, 이것에 의존해서는 안됩니다. 한쪽의 무게가 다른 쪽의 무게보다 2 배 큰 바이어스 동전은 다음과 같이 샘플링해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">로그 시리즈 분포의 확률 질량 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">기하 분포의 확률 질량 함수는</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">음 이항 분포의 확률 질량 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">개별 시험의 성공 확률.</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">여기서 문제는 하나의 차원 인수와 두 개의 배열 인수가 있고 단일 배열에 적용되는 차원에 대한 유형 맵이 설정되어 있다는 것입니다. 실제로 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는 &lt;code&gt;len&lt;/code&gt; 을 &lt;code&gt;vec2&lt;/code&gt; 와 연관 시켜 두 개의 Python 입력 인수를 취하는 메커니즘을 제공하지 않습니다. ). 권장되는 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">문제가 정확하게 해결되었습니다. 이 경우 함수는 배열간에 공유되는 요소가있는 경우에만 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 곱을 요소 단위입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">빈 배열의 곱은 중립 요소 1입니다.</target>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">승격 된 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 Vandermonde 매트릭스. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 Chebyshev 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 인덱스는 해당 Hermite 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 인덱스는 해당 HermiteE 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 Laguerre 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 Legendre 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">의 역행렬 . 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;matrix&lt;/code&gt; 예는 다음 그렇다 &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">행렬 A의 의사 역수</target>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">참조 횟수 확인의 목적은이 배열을 다른 Python 객체의 버퍼로 사용하지 않고 메모리를 재 할당하는 것입니다. 그러나 참조 횟수는 다른 방식으로 증가 할 수 &lt;code&gt;refcheck&lt;/code&gt; 배열의 메모리를 다른 Python 객체와 공유하지 않았다면 refcheck 를 False로 안전하게 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">사분면 (즉, 분기)은 &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; 가 원점에서 끝나고 점 (1,0)을 통과하는 광선과 원점에서 끝나고 통과하는 광선 사이의 라디안으로 표시된 각도 (라디안)로 선택됩니다 점을 통해 ( &lt;code&gt;x2&lt;/code&gt; , &lt;code&gt;x1&lt;/code&gt; ). 역할 역전에 유의하십시오.&amp;ldquo; &lt;code&gt;y&lt;/code&gt; -coordinate&amp;rdquo;는 첫 번째 기능 매개 변수이고&amp;ldquo; &lt;code&gt;x&lt;/code&gt; -coordinate&amp;rdquo;는 두 번째 기능 매개 변수 입니다. IEEE 규약에 따라이 기능은 &lt;code&gt;x2&lt;/code&gt; = +/- 0 및 둘 중 하나 또는 둘 다에 대해 정의됩니다. &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; = +/- inf (특정 값에 대한 참고 사항 참조)</target>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">랜덤 값은 거부 기반 방법을 사용하여 시뮬레이션되므로 평균적으로 단일 드로우를 생성하려면 기본 RNG의 둘 이상의 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 가&lt;/a&gt; 생성 한 임의의 값 은 BitGenerator에서 점화됩니다. BitGenerators는 임의의 숫자를 직접 제공하지 않으며, 시드, 상태 가져 오기 또는 설정, 상태 점프 또는 진행, 제공된 기능 (예 : &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba)에&lt;/a&gt; 효율적으로 액세스 할 수있는 코드를 사용하여 저수준 래퍼에 액세스하는 데 사용되는 방법 만 포함합니다. .</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">F 분포의 랜덤 변이 (피셔 분포라고도 함)는 분산 분석 검정에서 발생하는 연속 확률 분포이며 두 카이-제곱 변이의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False 인 경우에만 경고가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;code&gt;full&lt;/code&gt; = False 인 경우에만 경고가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;code&gt;full&lt;/code&gt; = False 인 경우에만 경고가 발생합니다 . 다음과 같은 방법으로 경고를 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">이율은 (비선형) 방정식을 반복적으로 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">복소수의 실수 부와 허수 부는 따로 반올림됩니다. 플로트를 반올림 한 결과는 플로트입니다.</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">복잡한 인수의 실제 구성 요소. 경우 &lt;code&gt;val&lt;/code&gt; 진짜의 종류 &lt;code&gt;val&lt;/code&gt; 출력에 사용됩니다. &lt;code&gt;val&lt;/code&gt; 에 복잡한 요소가 있으면 반환 된 유형은 float입니다.</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">배열의 실제 부분.</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">마스크 배열의 실제 부분.</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">멀티 스레드 반복에 권장되는 접근 방법은 먼저 플래그 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; 및 가능하면 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 반복자를 작성하는 것 입니다 . 각 스레드에 대해이 반복기의 사본을 작성하십시오 (첫 번째 반복기에서 1을 뺀 것). 그런 다음 반복 색인 범위 &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; 를 가져 와서 예를 들어 TBB parallel_for 루프를 사용하여 작업으로 분할하십시오. 스레드가 실행할 작업을 &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; 를 호출 하고 전체 범위에서 반복 하여 반복자의 사본을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">일반적인 사용에 권장되는 발전기는 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 입니다. 통계적으로 고품질이며 모든 기능을 갖추고 있으며 대부분의 플랫폼에서 빠르지 만 32 비트 프로세스 용으로 컴파일 할 때는 다소 느립니다.</target>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">무효로 마스크 배열의 하나 개 또는 여러 개의 특정 항목을 표시하는 권장 방법은 특수 값 할당하는 것입니다 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 그들에게를 :</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">권장되는 데이터 저장 및로드 방법 :</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">감소 기능은 감소 및 누적 기능의 일반화입니다. 인덱스로 지정된 입력 배열 범위의 축소 범위를 구현합니다. 루프 계산을 수행하기 전에 선택한 차원을 따라 모든 입력이 입력 배열에 비해 너무 크지 않은지 확인하기 위해 여분의 인덱스 인수가 검사됩니다. 루프 구현은 인덱스 입력에 요소가있는 횟수만큼 반복되는 축소 코드와 매우 유사한 코드를 사용하여 처리됩니다. 특히 : 기본 1 차원 계산 루프로 전달 된 첫 번째 입력 포인터는 인덱스 배열로 표시된 올바른 위치에서 입력 배열을 가리 킵니다. 또한 출력 포인터와 두 번째 입력 포인터는 기본 1D 루프 포인트로 전달되어 메모리의 동일한 위치를 가리 킵니다.1 차원 계산 루프의 크기는 현재 인덱스와 다음 인덱스의 차이로 고정됩니다 (현재 인덱스가 마지막 인덱스 인 경우 다음 인덱스는 선택된 차원을 따라 배열의 길이 인 것으로 가정 됨) ). 이런 식으로 1-D 루프는 지정된 인덱스에 대한 축소를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">축소 된 배열입니다. 경우 &lt;code&gt;out&lt;/code&gt; 공급하고, &lt;code&gt;r&lt;/code&gt; 에 대한 참조이다.</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">감소 된 값. 경우 &lt;code&gt;out&lt;/code&gt; 공급하고, &lt;code&gt;r&lt;/code&gt; 참조 인 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">정규식. 기본값은 없음이며,이 경우 노즈 기본값 ( &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; )이 사용됩니다. 경우 &lt;code&gt;testmatch&lt;/code&gt; 은 문자열입니다, 그것은 첫번째 정규 표현식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">64 비트 Linux 및 64 비트 Windows의 상대적 성능은 대체로 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">상대 공차 매개 변수 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 을 &lt;code&gt;x2&lt;/code&gt; 로 나눈 나머지입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">컴파일러에 따른이 데이터 유형의 필수 정렬 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">피연산자의 필수 데이터 유형입니다. 복사 또는 버퍼링이 활성화 된 경우 데이터는 원래 유형과 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">필요한 데이터 유형. None이면 현재 dtype을 유지합니다. 응용 프로그램에서 데이터가 기본 바이트 순서로되어 있어야하는 경우 dtype 사양의 일부로 바이트 순서 사양을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">요구 사항 목록은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">모양 변경 작업으로 복사본이 만들어지지 않는다고 보장 할 수 없으며, 모양을 수정하려면 &lt;code&gt;a.shape = s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">이 페이지의 나머지 부분에서는 SciPy의 모듈에 단위 테스트를 추가하는 방법에 대한 기본 아이디어를 제공합니다. 이 코드는 과학자와 연구원들이 사용하고 전 세계에 퍼져있는 많은 사람들이 개발하고 있기 때문에 광범위한 단위 테스트를하는 것이 매우 중요합니다. 따라서 SciPy에 참여할 패키지를 작성하는 경우 패키지를 개발할 때 테스트를 작성하십시오. 또한 SciPy의 대부분은 원래 단위 테스트없이 작성된 레거시 코드이므로 아직 테스트하지 않은 여러 모듈이 있습니다. 이 소개를 읽으면서이 모듈 중 하나를 자유롭게 선택하고 테스트를 개발하십시오.</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">결과는 timedelta와 동일한 단위를 사용하는 날짜 시간을 구성하는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">결과는 비트 너비에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">결과는 MaskedArray 가 &lt;strong&gt;아닙니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">결과는 tensordot 연산 &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 상대 값에 반비례합니다 . 즉, 부동 소수점 정확도까지 &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; 는 tensordot의 &quot;동일성&quot;텐서입니다. 조작.</target>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">끝에 0 비트를 삽입하여 결과를 전체 바이트로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">결과는 부울 배열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;m1&lt;/code&gt; 또는 &lt;code&gt;m2&lt;/code&gt; 로 마스크 된 값을 마스크합니다 .</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">다른 하나가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 (예 : False) 결과는 &lt;code&gt;m1&lt;/code&gt; 또는 &lt;code&gt;m2&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;cPickle.loads(strg)&lt;/code&gt; 의 결과 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1 * 2**x2&lt;/code&gt; 의 결과입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">입력 배열 비닝 결과입니다. &lt;code&gt;out&lt;/code&gt; 의 길이는 &lt;code&gt;np.amax(x)+1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">마스킹 결과 &lt;code&gt;a&lt;/code&gt; 여기서 &lt;code&gt;condition&lt;/code&gt; 참이다.</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">마스킹 &lt;code&gt;x&lt;/code&gt; 의 결과는 대략 &lt;code&gt;value&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">마스킹 &lt;code&gt;x&lt;/code&gt; 의 결과는 &lt;code&gt;value&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">를 반복 &lt;code&gt;a&lt;/code&gt; 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 전달됩니다. 따라서 형상 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 은&lt;/a&gt; 완전히 결정되어 &lt;code&gt;function&lt;/code&gt; . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;code&gt;shape&lt;/code&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 전달됩니다. 따라서 형상 &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 은&lt;/a&gt; 완전히 결정되어 &lt;code&gt;function&lt;/code&gt; . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">역 실수 2-D FFT의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">네거티브 배당 및 제수에 대한 모듈로 연산의 결과는 규칙에 따릅니다. 들어 &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; 에 대한하면서, 결과의 부호는 배당의 부호이며 &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; 결과의 부호는 제수의 부호이다. &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; 함수는 Matlab의 (TM)에 해당 &lt;code&gt;rem&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">실제 2 차원 FFT의 결과.</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">이것의 결과는 항상 0이 아닌 각 요소에 대한 행을 가진 2d 배열입니다.</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">입력을 다듬은 결과. 입력 데이터 형식이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">결과 유형</target>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">결과.</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">결과 근사치</target>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">결과 배열은 따라서 좌표 &lt;code&gt;(x, y, z)&lt;/code&gt; 에서 &lt;code&gt;fn(x, y, z)&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">결과 경로는 입력 수축의 어떤 용어가 먼저 수축되는지를 나타내며,이 수축의 결과는 수축리스트의 끝에 추가됩니다. 그런 다음이 목록은 모든 중간 수축이 완료 될 때까지 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">결과는 최대 100도까지만 테스트되었으며 문제가있을 수 있습니다. 가중치는 다음과 같은 사실을 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">결과는 100도까지만 테스트되었으며, 높은 수준은 문제가 될 수 있습니다. Gauss-Chebyshev의 경우 샘플 포인트 및 무게에 대한 폐쇄 형 솔루션이 있습니다. n = &lt;code&gt;deg&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">결과는 100도까지만 테스트되었으며, 높은 수준은 문제가 될 수 있습니다. 가중치는 다음과 같은 사실을 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">결과는이 배열에 배치됩니다. 적절한 클리핑을위한 입력 배열 일 수 있습니다. &lt;code&gt;out&lt;/code&gt; 출력을 보유 할 권리 모양이어야합니다. 유형이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">모든 배열이 정수 배열 인 경우에도 반환 형식은 항상 정확하지 않은 (예 : 부동 소수점) 스칼라 형식입니다. 입력 중 하나가 정수 배열 인 경우 반환되는 최소 정밀도 유형은 64 비트 부동 소수점 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">성공하면 리턴 값은 0이고 실패하면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">반환 값은 &lt;code&gt;M&lt;/code&gt; 과 같은 형태와 타입입니다 . 지수가 양수이거나 0이면 요소의 유형은 &lt;code&gt;M&lt;/code&gt; 의 유형과 동일 합니다. 지수가 음수이면 요소는 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 유사 함수 에서 &quot;O &amp;amp;&quot;구문을 사용하여 호출 된 실패한 변환기 함수의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 유사 함수 에서 &quot;O &amp;amp;&quot;구문을 사용하여 호출 된 성공적인 변환기 함수의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 복합 유형 인 경우 False를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">반환 값, &lt;code&gt;x&lt;/code&gt; 가 복합 유형이거나 복합 요소가 하나 이상 이면 True 입니다.</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열은 동일한 유형 갖는다 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">반환 된 배열은 항상 1D입니다.</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">반환 된 배열은 항상 구조화 된 배열이며 파일에서 정규식의 모든 일치 항목으로 구성됩니다. 정규식의 그룹은 구조화 된 배열의 필드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">반환 된 배열은 필요한 경우 복사본을 만들어 나열된 요구 사항을 갖도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">반환 된 배열의 크기 는 최소한 &lt;code&gt;ndmin&lt;/code&gt; 입니다. 그렇지 않으면 1 차원 축이 압착됩니다. 유효한 값 : 0 (기본값), 1 또는 2.</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">반환 된 클래스는 현재 인스턴스와 다른 유형이거나 도메인 및 / 또는 창이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">반환 된 float 배열 &lt;code&gt;f&lt;/code&gt; 에는 샘플 간격 단위당 사이클 단위의 주파수 빈 중심이 포함됩니다 (시작시 0). 예를 들어, 샘플 간격이 초라면 주파수 단위는 사이클 / 초입니다.</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">반환 된 인덱스는 모양 배열 (n, n)에 액세스하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">반환 된리스트는 dtype double, complex double 또는 object의 배열을 포함합니다. 1 차원 형상 인수 &lt;code&gt;(N,)&lt;/code&gt; 는 크기가 1 인 &lt;code&gt;N&lt;/code&gt; 개의 배열 로 구문 분석됩니다 . 2 차원 형상 인수 &lt;code&gt;(M,N)&lt;/code&gt; 는 크기가 &lt;code&gt;N&lt;/code&gt; 인 &lt;code&gt;M&lt;/code&gt; 개의 어레이 로 파싱되고 (즉, &quot;행에 의해 파싱된다&quot;); 더 높은 차원의 배열은 1 차원 배열 또는 2 차원 배열로 처음 재 형성되지 않으면 값 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">반환 된 객체는 Python 유형 &lt;em&gt;하위 유형&lt;/em&gt; 의 객체 이며 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형이어야합니다 . 배열 갖는 &lt;em&gt;ND&lt;/em&gt; 설명 치수 &lt;em&gt;희미&lt;/em&gt; . 새 배열의 데이터 유형 설명자는 &lt;em&gt;descr&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">다항식 &lt;code&gt;p&lt;/code&gt; 의 반환 순서 &lt;code&gt;m&lt;/code&gt; 반 유도 &lt;code&gt;P&lt;/code&gt; 는 다음을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">반환 된 포인터는 배열에 대한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">리턴 된 튜플은 &lt;code&gt;numpy.datetime64&lt;/code&gt; 및 &lt;code&gt;numpy.timedelta64&lt;/code&gt; 의 두 번째 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">반환 된 튜플에는 다음 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">리턴 된 유형 문자는 리턴 된 유형의 배열이 &lt;code&gt;typechars&lt;/code&gt; (또는 &lt;code&gt;typechars&lt;/code&gt; 가 배열 인 경우 dtype.char ) 의 모든 유형 배열의 데이터를 처리 할 수 ​​있도록 가장 작은 크기의 dtype을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">반환 된 ufunc는 항상 PyObject 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">반환 된 값 은 계열이 평가되기 전에 입력 인수에 적용되는 선형 맵 &lt;code&gt;off + scl*x&lt;/code&gt; 를 정의합니다 . 지도는 &lt;code&gt;domain&lt;/code&gt; 과 &lt;code&gt;window&lt;/code&gt; 에 따라 다릅니다 . 현재 &lt;code&gt;domain&lt;/code&gt; 이 &lt;code&gt;window&lt;/code&gt; 경우 결과 맵은 ID입니다. 시리즈 인스턴스의 계수가이 클래스 외부에서 자체적으로 사용되는 경우 선형 함수는 기본 다항식의 표준 표현에서 &lt;code&gt;x&lt;/code&gt; 를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">근본 추정값은 컴패니언 행렬의 고유 값으로 구합니다. 복소 평면의 원점에서 멀리 떨어진 근은 이러한 값에 대한 검정력 계열의 수치 적 불안정성으로 인해 큰 오류가있을 수 있습니다. 다중성이 1보다 큰 근은 그러한 점 근처의 계열 값이 근의 오차에 상대적으로 민감하지 않기 때문에 더 큰 오차를 나타냅니다. 원점 근처의 고립 된 뿌리는 뉴턴 방법의 몇 번의 반복으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">근본 추정값은 컴패니언 행렬의 고유 값으로 구합니다. 복소 평면의 원점에서 멀리 떨어진 근은 그러한 값에 대한 계열의 수치 적 불안정성으로 인해 큰 오류가있을 수 있습니다. 다중성이 1보다 큰 근은 그러한 점 근처의 계열 값이 근의 오차에 상대적으로 민감하지 않기 때문에 더 큰 오차를 나타냅니다. 원점 근처의 고립 된 뿌리는 뉴턴 방법의 몇 번의 반복으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">self (x) == 0 인 다항식의 근</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">반환 된 인덱스가 유효한 배열의 행 차원입니다.</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype 인수는 축소가 수행되어야하는 데이터 유형을 지정합니다. 배열의 데이터 유형이 출력을 처리하기에 &quot;큰&quot;크기가 아닌 경우에 중요합니다. 기본적으로 모든 정수 데이터 유형 한 크게 적어도 만들어진다 &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt; &quot;추가&quot;및 (평균, 합계 cumsum, 자극 및 cumprod 기능에 대한 기초를 형성하는) &quot;다중&quot;ufuncs 대한.</target>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">ABI 및 API 호환성에 대한 규칙은 다음과 같이 요약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">전체 테이블을 생성하기 위해 여러 다른 이율 및 / 또는 지불 및 / 또는 총액으로 동일한 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">동일한 기능이 4D 배열에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">치수를 확장하면 max 및 min에 대해서도 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 값에 해당하는 샘플 점 . 경우 &lt;code&gt;x&lt;/code&gt; 아무도없는 샘플 포인트 균등 것으로 가정 &lt;code&gt;dx&lt;/code&gt; 떨어져. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">감마 분포의 스케일입니다. 음수가 아니어야합니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">분포의 척도 모수입니다. 기본값은 1입니다. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">스케일 파라미터</target>
        </trans-unit>
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">scipy 구현은이 기능보다 권장됩니다. C로 작성된 적절한 ufunc이며, 10 배 이상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">두 번째 요소 인 &lt;em&gt;field_dtype&lt;/em&gt; 은 데이터 유형으로 해석 될 수있는 모든 요소 가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">두 번째는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 사용하여 오류 처리기를 'log'로 설정하는 것 입니다. 부동 소수점 오류는 제공된 객체의 'write'메소드에 대한 호출을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">이해해야 할 두 번째 문제는 배열이 메모리에 저장된 순서와 인덱스가 어떻게 일치하는지입니다. 포트란에서 첫 번째 인덱스는 메모리에 저장되어있는 2 차원 배열의 요소를 이동할 때 가장 빠르게 변하는 인덱스입니다. 인덱싱에 매트릭스 규칙을 채택하면 매트릭스가 한 번에 한 열씩 저장됨을 의미합니다 (첫 번째 인덱스는 변경 될 때 다음 행으로 이동하기 때문에). 따라서 포트란은 주요 언어로 간주됩니다. C는 반대의 규칙을 가지고 있습니다. C에서 마지막 인덱스는 메모리에 저장된 배열을 통해 이동할 때 가장 빠르게 변경됩니다. 따라서 C는 행 주요 언어입니다. 행렬은 행별로 저장됩니다. 두 경우 모두 색인에 대한 행렬 규칙이 사용되는 것으로 가정합니다 (즉, Fortran과 C 모두에 대해 첫 번째 색인은 행임).이 규칙은 인덱싱 규칙이 변하지 않으며 데이터 순서가 변경되도록 변경됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths (&amp;hellip;) 메소드는 경로를 포함 할 수있는 모든 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">각 차원의 요소 간 분리 ( '보도'). 이것은 요소 크기의 배수 일 필요는 없습니다</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">이 맥락에서 시리즈는 계수를 곱한 해당 다항식 기본 함수의 유한 합입니다. 예를 들어 파워 시리즈는</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">변환 할 시리즈 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">이 계열은 고차 항을 버림으로써 도 ( &lt;code&gt;deg&lt;/code&gt; )로 줄어 듭니다 . &lt;code&gt;deg&lt;/code&gt; 의 값은 음이 아닌 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">계열은 높은 수준의 용어를 삭제하여 길이 &lt;code&gt;size&lt;/code&gt; 로 줄어 듭니다 . &lt;code&gt;size&lt;/code&gt; 값은 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">사용 가능한 코덱 세트는 Python 표준 라이브러리에서 제공되며 런타임시 확장 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">사용 가능한 코덱 세트는 Python 표준 라이브러리에서 제공되며 런타임시 확장 될 수 있습니다. 자세한 내용은 코덱 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">리턴 된 문자가 선택된 문자 세트입니다. 기본 설정은 'GDFgdf'입니다.</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">열의 데이터를 값으로 변환하는 함수 세트입니다. 변환기를 사용하여 누락 된 데이터에 대한 기본값을 제공 할 수도 있습니다. &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int 값 집합은 비트 수가 동일한 유형에 대한 uint 값의 하위 집합이 아니며 &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; 에&lt;/a&gt; 반영되지 않지만 PyArray_ResultType 에서 특수한 경우로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int 값 집합은 비트 수가 동일한 유형에 대한 uint 값의 하위 집합이 아니며 &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; 에&lt;/a&gt; 반영되지 않지만 &lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; 에서 특수한 경우로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">누락 된 데이터에 해당하는 문자열 세트입니다.</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">데이터가 없을 때 기본값으로 사용되는 값 세트입니다.</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">세 가지 방법 모두에 대한 설정 함수는 &lt;code&gt;construct_reduce&lt;/code&gt; 입니다. 이 함수는 축소 루프 객체를 만들고 루프를 완료하는 데 필요한 매개 변수로 채 웁니다. 모든 메소드는 2 입력을 받고 1 출력을 리턴하는 ufunc에서만 작동합니다. 따라서 기본 &lt;code&gt;otype&lt;/code&gt; -D 루프는 [ otype , &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; ] 의 서명을 가정하여 선택됩니다 . 여기서 &lt;code&gt;otype&lt;/code&gt; 요청 된 축소 데이터 유형입니다. 그런 다음 (스레드 당) 글로벌 스토리지에서 버퍼 크기 및 오류 처리가 검색됩니다. 잘못 정렬되었거나 데이터 유형이 잘못된 작은 배열의 경우 버퍼되지 않은 코드 섹션이 사용되도록 복사가 이루어집니다. 그런 다음 루핑 전략이 선택됩니다. 배열에 1 개의 요소 또는 0 개의 요소가있는 경우 간단한 루핑 방법이 선택됩니다. 배열이 잘못 정렬되지 않았고 올바른 데이터 유형이있는 경우 스트라이드 루핑이 선택됩니다. 그렇지 않으면 버퍼 된 루핑을 수행해야합니다. 그런 다음 루핑 매개 변수가 설정되고 리턴 배열이 구성됩니다. 출력 배열은 방법이 축소, 누적 또는 축소인지에 따라 다른 모양입니다. 출력 배열이 이미 제공되어 있으면 모양이 확인됩니다. 출력 배열이 C 인접하지 않고 정렬 된 경우올바른 데이터 유형 인 경우 WRITEBACKIFCOPY 플래그가 설정된 임시 사본이 작성됩니다. 이런 식으로, 메소드는 잘 동작하는 출력 배열로 작업 할 수 있지만 결과는 실제 출력 배열로 다시 복사됩니다.&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;함수가 완료되면 PyArray_ResolveWritebackIfCopy 가 호출됩니다. 마지막으로 이터레이터는 올바른 축을 반복하도록 설정되고 (방법에 제공된 축의 값에 따라) 설정 루틴이 실제 계산 루틴으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">하위 배열의 모양 (항상 C 스타일 연속)은 Python 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">의 형상 및 데이터 타입 &lt;code&gt;a&lt;/code&gt; 반환 된 배열이 동일한 속성을 정의한다.</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 의 모양과 데이터 유형은 반환 된 배열의 동일한 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; 의 인덱스가 적용 되는 배열의 모양입니다 .</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">각 출력의 모양은 루프 치수와 출력의 코어 치수에 따라 결정됩니다</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">배열의 모양은 유지되지만 요소는 재정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">반복 할 배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 를 풀기 위해 사용할 배열의 모양 .</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">방송 결과의 모양 ( &lt;code&gt;nd&lt;/code&gt; 슬롯 만 사용됨).</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">원하는 배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">감마 분포의 모양. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">격자 모양.</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">새 배열의 모양입니다. 기본값은 &lt;code&gt;x.shape&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">출력의 모양은 &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 의 크기에 따라 달라지며 &lt;code&gt;a&lt;/code&gt; 보다 클 수 있습니다 ( &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">리턴 값의 모양은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">반환 된 배열의 모양은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">반환 된 행렬의 모양은 &lt;code&gt;x.shape + (order,)&lt;/code&gt; . 여기서</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">ctypes POINTER에서 변환 할 경우 shape 매개 변수를 제공해야합니다. ctypes 배열에서 변환하는 경우 shape 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shape 속성은 일반적으로 배열의 현재 모양을 얻는 데 사용되지만 배열 차원의 튜플을 배열로 제자리에 재구성하는 데 사용될 수도 있습니다. &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 새로운 모양 차원 중 하나는 -1 일 수 있으며,이 경우 값은 배열의 크기와 나머지 차원에서 추론됩니다. 사본이 필요한 경우, 배열을 제자리에서 재구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x, y 및 조건의 모양은 함께 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">시프트 된 배열</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">의 부호 &lt;code&gt;x2&lt;/code&gt; 복사됩니다 &lt;code&gt;x1&lt;/code&gt; . 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 부호 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">서명은 입력 및 출력 변수의 &quot;핵심&quot;차원을 정의하고 차원의 축소도 정의합니다. 서명은 다음 형식의 문자열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">서명은 각 입력 / 출력 배열의 차원이 코어 및 루프 차원으로 분할되는 방식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">가장 간단하고 빠른 추정기. 데이터 크기 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">&lt;em&gt;N 개의&lt;/em&gt; 정수로 인덱싱하는 가장 간단한 경우 는 해당 항목을 나타내는 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;배열 스칼라를&lt;/a&gt; 반환합니다 . 파이썬에서와 같이, 모든 인덱스는 0부터 시작합니다 : &lt;em&gt;i&lt;/em&gt; 번째 인덱스</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">C 스타일 배열의 시뮬레이션은 2 차원 및 3 차원 배열에 대해 완전하지 않습니다. 예를 들어, 시뮬레이션 된 포인터 배열은 정적으로 정의 된 특정 2 차원 및 3 차원 배열을 기대하는 서브 루틴으로 전달 될 수 없습니다. 이러한 종류의 입력이 필요한 함수에 전달하려면 필요한 배열을 정적으로 정의하고 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc 함수는</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc 함수는 앤티 앨리어싱, Lanczos 리샘플링 필터 구성 및 보간 등 다양한 신호 처리 응용 프로그램에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">사인은 삼각법 (삼각형의 수학 연구)의 기본 기능 중 하나입니다. 원점을 중심으로 반경 1의 원을 고려하십시오. 광선은</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">x의 각 원소의 사인입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">단일 스레드 호출은 BitGenerator를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpy의 상황은이 문제를 더욱 복잡하게 만듭니다. numpy 배열의 내부 기계는 인덱스 순서를 수용 할 수있을 정도로 유연합니다. 데이터의 순서를 바꾸지 않고 배열의 내부 보폭 정보를 조작하여 인덱스의 순서를 간단히 바꿀 수 있습니다. NumPy는 데이터를 이동하지 않고 새로운 인덱스 순서를 데이터에 매핑하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">출력 모양의 각 차원의 크기는 해당 차원의 모든 입력 크기의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">배열의 각 차원의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">각 단어의 크기입니다. &lt;code&gt;uint32&lt;/code&gt; 또는 &lt;code&gt;uint64&lt;/code&gt; 여야합니다 . 문자열 ( &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; )이 좋습니다. &lt;code&gt;uint64&lt;/code&gt; 를 요청 하면 동일한 &lt;code&gt;n_words&lt;/code&gt; 에 대해 &lt;code&gt;uint32&lt;/code&gt; 보다 두 배 많은 비트가 그려 집니다 . 이것은 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 배열 로 표현하는 BitGenerator 's 의 편의입니다 .</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">각 차원에서 배열의 크기에서 1을 뺀 값입니다.</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">반환 된 인덱스가 유효한 배열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">반환 된 인덱스를 사용할 수있는 배열의 각 차원에 따른 크기입니다.</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">확인할 작은 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">오버플로를 유발하는베이스 (2)의 최소 양의 힘.</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">사용 가능한 최소 양수 &lt;code&gt;tiny&lt;/code&gt; 유형은 적절한 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">표현할 수있는 가장 작은 수, 일반적으로 &lt;code&gt;-max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">&lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; 과 같이 표현 가능한 가장 작은 양수 입니다. &lt;code&gt;eps&lt;/code&gt; 의 유형은 적절한 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; 과 같은 가장 작은 표현 가능한 양수 입니다.</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Chebyshev 계열 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Hermite 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 HermiteE 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Laguerre 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Legendre 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 다항식 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">이 솔루션은 제곱 오차를 최소화합니다</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">솔루션은 LAPACK 루틴 &lt;code&gt;_gesv&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">복소수의 정렬 순서는 사전 식입니다. 실수 부와 허수 부가 모두 난이 아닌 경우, 순서는 동일 할 때를 제외하고 실수 부에서 결정되며,이 경우 순서는 허수 부에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">정렬 된 고유 값</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">사용 된 정렬 알고리즘.</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">소스 코드는 Python으로 작성된 객체에 대해서만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">소스 코드는 Python으로 작성된 객체에 대해서만 반환됩니다. 많은 함수와 클래스는 C로 정의되므로 유용한 정보를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 없음 인 경우 샘플 포인트 사이의 간격 입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값의 간격입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">사용되는 특정 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">지정된 행은 &lt;code&gt;off + scl*x&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">스택 형 배열은 입력 배열보다 차원이 하나 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">표준 배열에는 24 가지 데이터 형식이있을 수 있으며 고유 한 형식을 추가 할 수 있습니다. 이러한 데이터 유형에는 모두 열거 유형, 열거 유형 문자 및 해당 배열 스칼라 Python 유형 오브젝트 (계층 구조로 배치됨)가 있습니다. 주어진 데이터 유형의 요소를보다 쉽게 ​​조작 할 수 있도록 표준 C typedef도 있습니다. 숫자 유형의 경우 비트 폭에 해당하는 C typedef와 명명 된 typenumber가 있으므로 원하는 정밀도를 쉽게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">표준 캐스트 규칙은 스칼라가 기본적으로 다른 종류의 데이터가 아닌 경우 (즉, 데이터 유형 계층의 다른 계층 구조) 배열이 아닌 한 스칼라가 배열을 업 캐스트 할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">표준 편차는 평균과의 제곱 편차 평균의 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 예 : std = sqrt (mean (abs (x-x.mean ()) ** 2))) .</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">표준 편차는 평균과의 제곱 편차 평균의 제곱근입니다 : &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">시퀀스 슬라이싱의 표준 규칙은 차원 별 (단계 인덱스 사용 포함) 기본 슬라이싱에 적용됩니다. 기억해야 할 유용한 개념은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">데이터 버퍼 내에서 데이터의 시작 (데이터 버퍼의 시작에 대한 오프셋)</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">사용자 지정 데이터 형식에 사용되는 형식 번호의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 제품의 시작 값입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">시퀀스의 시작 값입니다.</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">리턴 된 큰 생성기의 상태는 2 ** (128 * 점프) 난수가 생성 된 것처럼 점프됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">단계 크기는 2 ** 128을 곱하면 phi-1이며 여기서 phi는 황금비입니다.</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">배열의 보폭. 각 차원에서 다음 요소로 이동하는 데 필요한 바이트 수</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">새로운 배열의 보폭. 기본값은 &lt;code&gt;x.strides&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">스칼라 유형에 해당하는 문자열 문자입니다.</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">배열의 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">부동 소수점 값의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">데이터에서 숫자를 구분하는 문자열입니다. 요소 사이의 추가 공백도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">로드 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">예상 문자열과의 동등성을 테스트 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">값을 구분하는 데 사용되는 문자열입니다. 기본적으로 모든 연속 공백은 구분 기호로 작동합니다. 정수 또는 정수 시퀀스는 또한 각 필드의 폭으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">값을 구분하는 데 사용되는 문자열입니다. 이전 버전과의 호환성을 위해 바이트 문자열은 'latin1'으로 디코딩됩니다. 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Python float.hex 메소드에 의해 생성 된 문자열은 float의 입력으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">우리가 방금 얻은 주요 대각선의 하위 배열; 각각은 가장 오른쪽 (열) 축 고정에 해당하며 대각선은 행으로 &quot;포장&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">배열이 채워지는 하위 대각선 at와 그 아래. &lt;code&gt;k&lt;/code&gt; = 0은 주 대각선이고 &lt;code&gt;k&lt;/code&gt; &amp;lt;0은 그 아래에 있고 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0은 위에 있습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">서브 어레이 &lt;code&gt;grid[k]&lt;/code&gt; 는 &lt;code&gt;k-th&lt;/code&gt; 축을 따라 ND 인덱스 배열을 포함합니다 . 명시 적으로 :</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첨자 문자열은 쉼표로 구분 된 첨자 레이블 목록으로, 각 레이블은 해당 피연산자의 차원을 나타냅니다. 레이블이 반복 될 때마다 레이블이 합산되므로 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; 는 &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; . 레이블은 한 번만 나타날 경우 그래서, 그것은 합산되지 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; 의 전망 생산 변경하지 있습니다. &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 의 다른 예 는 전통적인 행렬 곱셈을 설명하며 &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt; . 한 피연산자의 반복 첨자 레이블은 대각선을 사용합니다. 예를 들어, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; 는 &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt; 와 같습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">검색 할 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">요소 별 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 의 합입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">빈 배열의 합은 중립 요소 0입니다.</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">입력의 합입니다. 입력이 poly1d 객체이면 출력도 poly1d 객체입니다. 그렇지 않으면 다항식 계수의 1D 배열이 최고에서 최저까지입니다.</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 동작으로 억제 동작이 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t 검정은 데이터가 정규 분포에서 나온 것으로 가정합니다. t 검정은 표본 평균 (데이터에서 계산 된 평균)이 실제 평균의 적절한 추정값인지 여부를 테스트하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">템플릿 언어 블록은 &lt;code&gt;/**begin repeat&lt;/code&gt; 및 &lt;code&gt;/**end repeat**/&lt;/code&gt; 행으로 구분되며, &lt;code&gt;/**begin repeat1&lt;/code&gt; 및 &lt;code&gt;/**end repeat1**/&lt;/code&gt; 과 같이 연속적으로 번호가 지정된 구분선을 사용하여 중첩 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">입력의 텐서 도트 곱.</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">테스트는 반전 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; ( &lt;code&gt;allclose&lt;/code&gt; 는 다른 기본값 을 가짐 ). &lt;code&gt;actual&lt;/code&gt; 와 &lt;code&gt;desired&lt;/code&gt; 차이 를 &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; 와 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SkipMyTest&lt;/code&gt; 가 0이 아닌 것으로 평가 되면 테스트는 건너 뛴 것으로 표시되며 자세한 테스트 출력의 메시지는 &lt;code&gt;skipif&lt;/code&gt; 에 제공된 두 번째 인수 입니다. 마찬가지로 &lt;code&gt;xfail&lt;/code&gt; 을 사용하여 테스트를 알려진 실패로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">테스트 방법은 두 개 이상의 인수를 취할 수 있습니다. 첫 번째, &lt;code&gt;label&lt;/code&gt; 은 테스트 대상을 지정하는 문자열이고 두 번째, &lt;code&gt;verbose&lt;/code&gt; 는 출력 상세 레벨을 제공하는 정수입니다. 자세한 내용은 numpy.test에 대한 docstring을 참조하십시오. &lt;code&gt;label&lt;/code&gt; 의 기본값 은 'fast'입니다. 표준 테스트가 실행됩니다. 문자열 'full'은 실행 속도가 느린 것으로 확인 된 테스트를 포함하여 전체 테스트 배터리를 실행합니다. 경우 &lt;code&gt;verbose&lt;/code&gt; 적은 1 또는, 테스트는 실행되는 테스트에 대한 정보 메시지를 표시합니다; 그러나 1보다 크면 테스트는 누락 된 테스트에 대한 경고도 제공합니다. 따라서 모든 테스트를 실행하고 테스트가없는 모듈에 대한 메시지를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">레이블을 느리게 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">테스트는 동일한 모양과 &lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;desired&lt;/code&gt; 요소가 충족 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">이 테스트는 &lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;desired&lt;/code&gt; 요소가 충족 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">3 차원 계열은 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 동일한 모양을 가져야합니다. 임의의 경우 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 또는 &lt;code&gt;z&lt;/code&gt; 목록 또는 튜플, 그것은 먼저, 그렇지 않으면 그대로 방치하고 ndarray가 아닌 경우는 스칼라로 취급 ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">3 차원 계열은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 데카르트 곱의 점에서 평가됩니다 . 경우 &lt;code&gt;x&lt;/code&gt; `y`, 또는 &lt;code&gt;z&lt;/code&gt; 목록 또는 튜플, 그것은 먼저 그것이 ndarray하지 않으면, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">세 개의 구분 연산자가 모두 정의되어 있습니다. &lt;code&gt;div&lt;/code&gt; 는 기본적으로 활성화되어 있으며 &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 나누기가 유효한 경우 &lt;code&gt;truediv&lt;/code&gt; 가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">위의 임계 값은 SVD 계산에서 부동 소수점 반올림 오류를 처리합니다. 그러나 &lt;em&gt;유효&lt;/em&gt; 순위 부족 을 탐지하기 위해 다른 공차 값을 고려할 수 있는 &lt;code&gt;M&lt;/code&gt; 의 오차 원인에 대한 자세한 정보 가있을 수 있습니다 . 가장 유용한 공차 측정은 매트릭스에서 사용하려는 작업에 따라 다릅니다. 예를 들어, 데이터가 부동 소수점 엡실론보다 큰 불확실성을 가진 불확실한 측정에서 나온 경우, 그 불확실성에 가까운 공차를 선택하는 것이 좋습니다. 불확실성이 상대적인 것이 아니라 절대적인 경우 허용 오차는 절대적 일 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">타 일식 출력 배열</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">여러 스레드를 사용하여 생성하는 데 필요한 시간을 단일 스레드를 사용하여 생성하는 데 필요한 시간을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">아래의 타이밍은 특정 분포에서 1 개의 임의 값을 생성하는 시간 (ns)입니다. 원래 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 생성기는 더 빠른 생성기의 출력과 같도록 2 개의 32 비트 값이 필요하기 때문에 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">공차 값은 양수이며 일반적으로 매우 작은 수입니다. 상대 차이 ( &lt;code&gt;rtol&lt;/code&gt; * abs ( &lt;code&gt;b&lt;/code&gt; ))와 절대 차이 &lt;code&gt;atol&lt;/code&gt; 이 함께 더해 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 절대 차이를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">방송 된 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">총 인수 수 ( &lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt; ). &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">내장 된 NumPy 유형의 총 수 열거 범위는 0에서 NPY_NTYPES-1까지입니다.</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">주어진 축의 각 슬라이스를 따라 마스크 된 요소의 총 수 (축 = 없음) 또는 마스크 된 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">총 지불은 원금과이자에 대한 지불로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">기본 배열의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">실제 입력에 대한 변환은 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 에 의해 마지막 변환 축에 대해 수행 된 다음 나머지 축에 대한 변환은 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 . 출력 순서에 관해서이다 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 및에 대해, 최종 변환 축 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; 나머지 변환 축의.</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C 순서 배열의 조옮김은 FORTRAN 순서 배열입니다.</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">전치 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">삼각 분포는 하한이 왼쪽이고, 피크가 모드이며 상한이 오른쪽 인 연속 확률 분포입니다. 다른 분포와 달리이 매개 변수는 pdf의 모양을 직접 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">삼각 분포는 기본 분포가 알려져 있지 않지만 한계와 모드에 대한 지식이 존재하는 잘못 정의 된 문제에서 종종 사용됩니다. 종종 시뮬레이션에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">최대 값이 1로 정규화 된 삼각형 창 (샘플 수가 홀수 인 경우에만 값 1이 나타남)은 첫 번째 샘플과 마지막 샘플이 0입니다.</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; 의 실제 값 은 &lt;code&gt;1.00000000005e-10&lt;/code&gt; 에서 약 32 자리 유효 숫자입니다. 이 예는이 경우 expm1의 우수성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 . 변환 된 마지막 축의 길이는 &lt;code&gt;s[-1]//2+1&lt;/code&gt; 이고 나머지 변환 된 축은 &lt;code&gt;s&lt;/code&gt; 에 따라 길이를 가지 거나 입력에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 . 변환 된 각 축의 길이는 &lt;code&gt;s&lt;/code&gt; 의 해당 요소 또는 &lt;code&gt;s&lt;/code&gt; 를 지정하지 않은 경우 마지막 축을 제외한 모든 축의 입력 길이에 의해 지정됩니다. 최종 변환 축에서 &lt;code&gt;s&lt;/code&gt; 가 주어지지 않을 때 의 출력 길이 는 &lt;code&gt;2*(m-1)&lt;/code&gt; 입니다. 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 최종 변환 축의 길이입니다. 최종 축에서 홀수 개의 출력 점을 얻으려면 &lt;code&gt;s&lt;/code&gt; 를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">축을 따라 변환 절단 또는 제로 패딩 입력에 의해 나타낸 &lt;code&gt;axes&lt;/code&gt; 있으면, 마지막 두 축의 &lt;code&gt;axes&lt;/code&gt; 주어지지 않는다.</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다.</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 경우 &lt;code&gt;n&lt;/code&gt; 이 짝수, 변환 축의 길이는 &lt;code&gt;(n/2)+1&lt;/code&gt; . 경우 &lt;code&gt;n&lt;/code&gt; 이 홀수이고, 길이는 &lt;code&gt;(n+1)/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n//2 + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n&lt;/code&gt; 이거나, &lt;code&gt;n&lt;/code&gt; 을 지정하지 않으면 &lt;code&gt;2*(m-1)&lt;/code&gt; 입니다. 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 변환 된 축의 길이입니다. 홀수 개의 출력 포인트를 얻으려면 &lt;code&gt;n&lt;/code&gt; 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n&lt;/code&gt; 이거나, &lt;code&gt;n&lt;/code&gt; 이 지정되지 않은 경우 &lt;code&gt;2*m - 2&lt;/code&gt; 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 변환 된 축의 길이입니다. 홀수의 출력 포인트를 얻으려면 &lt;code&gt;n&lt;/code&gt; 을 지정해야합니다 (예 : 일반적인 경우 &lt;code&gt;2*m - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 각 요소가 잘린 값입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">스칼라의 절단 값 &lt;code&gt;x&lt;/code&gt; 정수에 가장 가까운 &lt;code&gt;i&lt;/code&gt; 가까운 제로보다 인 &lt;code&gt;x&lt;/code&gt; 이다. 간단히 말하면, 부호있는 숫자 &lt;code&gt;x&lt;/code&gt; 의 소수 부분 은 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">튜플 &lt;code&gt;args&lt;/code&gt; 및 dict &lt;code&gt;kwargs&lt;/code&gt; 는 원래 호출에서 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">__array_interface __ [ 'data']에서 반환 된 튜플은 16 진 문자열 (이제 정수 또는 긴 정수)이었습니다.</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">두 배열의 길이는 동일하므로 완전히 겹치는 위치는 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 점 &lt;code&gt;(x, y)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 모양을 가져야합니다. 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플, 그것은 먼저, 그렇지 않으면 그대로 방치하고 ndarray가 아닌 경우는 스칼라로 취급 ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 점 &lt;code&gt;(x, y)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 모양을 가져야합니다. 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플은, 그것은 먼저 ndarray가 아닌 경우, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 평가됩니다 . 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플은, 그것은 먼저 ndarray가 아닌 경우, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">지도를 결정하는 두 도메인 각각은 (성공적으로) 정확히 두 개의 값을 포함하는 1 차원 배열로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">입력 숫자가 음수이고 너비가 지정되면 2의 보수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">2 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">이 데이터 형식의 스칼라를 인스턴스화하는 데 사용되는 형식 개체입니다.</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">데이터의 유형은 &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">데이터 유형은 다음 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 속성으로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">값이 아닌 입력 유형이 확인됩니다. 입력에 허수 부가 0 인 경우에도 &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt; 는 True로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">값이 아닌 입력 유형이 확인됩니다. 따라서 입력에 허수 부분이 0 인 경우 &lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt; 는 데이터 유형이 복잡한 경우 False로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 주어지지 않는, 다른 입력 인수의 데이터 유형을 추론.</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;code&gt;dtype&lt;/code&gt; 주어지지 않는, 다른 입력 인수의 데이터 유형을 추론.</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">결과 유형은 지정된 인코딩에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. 기본적으로 &lt;code&gt;a&lt;/code&gt; 의 dtype 이 사용됩니다. &lt;code&gt;a&lt;/code&gt; 가 플랫폼 (u) intp보다 정밀도가 낮은 정수 유형을 갖는 경우 는 예외입니다 . 이 경우 플랫폼이 32 비트인지 64 비트인지에 따라 기본값은 (u) int32 또는 (u) int64입니다. 부정확 한 입력의 경우 dtype이 정확하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. &lt;code&gt;a&lt;/code&gt; 가 기본 플랫폼 정수보다 정밀도가 낮은 정수 dtype을 갖지 않는 한 &lt;code&gt;a&lt;/code&gt; 의 dtype이 기본적으로 사용됩니다 . 이 경우 &lt;code&gt;a&lt;/code&gt; 가 서명되면 플랫폼 정수가 사용되고 &lt;code&gt;a&lt;/code&gt; 가 서명되지 않으면 플랫폼 정수와 동일한 정밀도의 부호없는 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">반환 된 배열의 유형과 요소가 곱해지는 누산기의 유형입니다. &lt;code&gt;a&lt;/code&gt; 가 기본 플랫폼 정수보다 정밀도가 낮은 정수 dtype을 갖지 않는 한 &lt;code&gt;a&lt;/code&gt; 의 dtype이 기본적으로 사용됩니다 . 이 경우 &lt;code&gt;a&lt;/code&gt; 가 서명되면 플랫폼 정수가 사용되고 &lt;code&gt;a&lt;/code&gt; 가 서명되지 않으면 플랫폼 정수와 동일한 정밀도의 부호없는 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">중간 결과를 나타내는 데 사용되는 유형입니다. 출력 배열이 제공되는 경우 기본적으로 출력 배열의 데이터 유형이거나 출력 배열이 제공되지 않은 경우 입력 배열의 데이터 유형이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">중간 결과를 나타내는 데 사용되는 유형입니다. 출력 배열이 제공되는 경우 출력 배열의 데이터 유형으로 설정되거나 출력 배열이 제공되지 않은 경우 입력 배열의 데이터 유형으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 가 &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;int&lt;/code&gt; 와 같은 다른 데이터 유형의 배열 과 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 과 같은 다른 유형의 차원에 대해 제공하는 typemap 지시문 은 C 및 NumPy 유형 스펙을 제외하고 서로 동일합니다. 따라서 타입 맵은 매크로를 통해 (일반적으로 장면 뒤에서) 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">타입 맵 시그니처는 버퍼 포인터에 주어진 이름에서 크게 차별화됩니다. &lt;code&gt;FARRAY&lt;/code&gt; 가있는 이름 은 포트란 순서 배열이고 &lt;code&gt;ARRAY&lt;/code&gt; 가있는 이름 은 C 순서 (또는 1D 배열)입니다.</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 유형 맵은 12&amp;ndash;20, 25 및 30 코드 행을 담당합니다. 10 행은 입력을 &lt;code&gt;rms&lt;/code&gt; 함수 로 구문 분석합니다 . 형식 문자열 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; 에서 인수 목록이 단일 Python 객체 ( 콜론 앞에 &lt;code&gt;O&lt;/code&gt; 로 지정됨 )이고 포인터가 &lt;code&gt;obj0&lt;/code&gt; 에 저장되어 있음을 알 수 있습니다. &lt;code&gt;numpy.i&lt;/code&gt; 가 제공하는 많은 함수 가 호출되어 일반 Python 객체에서 NumPy 배열로의 (가능한) 변환을 확인합니다. 이 함수들은 &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt; 섹션에 설명되어 있지만 그 이름은 자명하다. 12 행에서 &lt;code&gt;obj0&lt;/code&gt; 을 사용 합니다NumPy 배열을 구성합니다. 17 행에서 결과의 유효성을 검사합니다. 결과가 널이 아니며 임의의 단일 길이를가집니다. 이러한 상태가 확인되면 라인 19와 라인 20에서 데이터 버퍼와 길이를 추출하여 라인 22에서 기본 C 함수를 호출 할 수 있습니다. 라인 25는 더 이상 새로운 배열을 생성하지 않은 경우 메모리 관리를 수행합니다. 필요합니다.</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">일반적인 루핑 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">ufunc 오브젝트의 생성에 의해 구현된다 &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt; . 기본 getattribute 동작, 인쇄 동작 만 구현하고 이러한 객체가 함수처럼 작동하도록하는 호출 동작을 갖는 매우 간단한 유형입니다. ufunc의 기본 개념은 연산을 지원하는 각 데이터 유형에 대해 빠른 1 차원 (벡터) 루프에 대한 참조를 유지하는 것입니다. 이 1 차원 루프는 모두 동일한 서명을 가지며 새로운 ufunc를 작성하는 데 핵심입니다. 그것들은 N 차원 함수를 구현하기에 적절하게 일반 루핑 코드에 의해 호출됩니다. 단일 스칼라 함수 ( &lt;em&gt;예 :&lt;/em&gt; atanh) 를 사용하여 ufunc를 정의 할 수있는 부동 및 복소수 부동 배열에 대해 정의 된 일부 일반적인 1 차원 루프가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">선택적 출력 인수를 사용하더라도 ufunc는 여전히 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">마스크 배열의 기본 데이터는 여러 가지 방법으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">'with'블록을 종료하면 기본 파일 설명자가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">상단 삼각 행렬.</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">부동 소수점 숫자와의 동등성을 확인하기위한 일반적인주의가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 기본 Laguerre 다항식 인 경우 Laguerre 다항식의 일반적인 컴패니언 행렬은 이미 대칭 이므로 스케일링이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1이 0 일 때 함수의 값입니다. &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 인 경우 공통 모양 (출력 모양이 됨)으로 브로드 캐스트 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">이 속성의 값은 리턴 된 오브젝트의 Python 유형에 대해 둘 이상의 가능성이있는 상황에서 리턴 할 오브젝트 유형을 판별하는 데 사용됩니다. 서브 클래스는이 속성에 대해 기본값 0.0을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">변환 할 값입니다. 양수 및 음수 값이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다 (기본적으로 없음). None이면 배열 의 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 속성이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">분포의 피크가 발생하는 값입니다. 값은 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 조건을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">최소 데이터 유형을 찾을 값입니다.</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">축소를 시작하는 데 사용되는 값입니다. ufunc에 ID가 없거나 dtype이 object이면 기본값은 None입니다. 그렇지 않으면 기본값은 ufunc.identity입니다. 경우 &lt;code&gt;None&lt;/code&gt; 주어지지, 감소의 첫 번째 요소는 사용하고, 감소가 비어있는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;ar1[in1d]&lt;/code&gt; 에 &lt;code&gt;ar2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; 의 각 값을 테스트 할 값입니다 .</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 의 각 값을 테스트 할 값입니다 . 이 인수는 배열이거나 array_like 인 경우 병합됩니다. 배열이 아닌 매개 변수의 동작에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">순위 -1 배열 &lt;code&gt;p&lt;/code&gt; 의 값은 다항식의 계수입니다. &lt;code&gt;p&lt;/code&gt; 의 길이 가 n + 1이면 다항식은 다음과 같이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">결과의 값은 소위 &quot;표준&quot;순서를 따릅니다. &lt;code&gt;A = fft(a, n)&lt;/code&gt; 인 경우 &lt;code&gt;A[0]&lt;/code&gt; 에는 주파수가 제로인 항 (신호의 합)이 포함됩니다. 입력. 그런 다음 &lt;code&gt;A[1:n/2]&lt;/code&gt; 에는 양의 주파수 항이 포함되고 &lt;code&gt;A[n/2+1:]&lt;/code&gt; 에는 음의 주파수 항이 내림차순으로 포함됩니다. 짝수의 입력 포인트에 대해 &lt;code&gt;A[n/2]&lt;/code&gt; 는 양수 및 음수 나이 퀴 스트 주파수를 나타내며 실제 입력에도 순수합니다. 홀수 개의 입력 포인트의 경우 &lt;code&gt;A[(n-1)/2]&lt;/code&gt; 에 가장 큰 양의 주파수가 포함되고 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; 에 가장 큰 음의 주파수가 포함됩니다. 루틴 &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; 은 출력에서 ​​해당 요소의 주파수를 제공하는 배열을 반환합니다. 루틴 &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; 변환과 해당 주파수를 이동하여 주파수가 0 인 성분을 중간에 배치하고 &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; 해당 이동을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 의 값은 -1과 1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">의 값 &lt;code&gt;x1&lt;/code&gt; 의 기호 &lt;code&gt;x2&lt;/code&gt; . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">히스토그램의 값. 가능한 의미론에 대한 설명은 &lt;code&gt;density&lt;/code&gt; 와 &lt;code&gt;weights&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">점의 다차원 다항식의 값은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 해당 값의 3 배로 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">점에 대한 다차원 다항식의 값은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 해당 값의 3 배로 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">시계열 현금 흐름의 값. 현금 흐름 &quot;사건&quot;사이의 (고정 된) 시간 간격은 &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 이 주어진 것과 동일해야합니다 (즉, 연간 &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 인 경우 각 현금 흐름 이벤트간에 정확히 1 년이 경과하는 것으로 이해됩니다). 통상적으로 투자 또는&amp;ldquo;예금&amp;rdquo;은 음수, 소득 또는&amp;ldquo;인출&amp;rdquo;은 양수입니다. &lt;code&gt;values&lt;/code&gt; 은 초기 투자로 시작해야하므로 &lt;code&gt;values[0]&lt;/code&gt; 은 일반적으로 음수입니다.</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 대응하는 값 쌍으로 형성된 점에서의 2 차원 체비 쇼프 계열의 값 .</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 2 차원 체비 쇼프 계열의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 대응하는 값 쌍으로 형성된 점에서의 2 차원 Legendre 시리즈의 값 .</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 대응하는 값 쌍으로 형성된 점에서의 2 차원 다항식의 값 .</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 2 차원 다항식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">보고 된 값은 각 표에서 MT19937의 속도와 관련하여 정규화됩니다. 값이 100이면 성능이 MT19937과 일치 함을 나타냅니다. 값이 클수록 성능이 향상되었음을 나타냅니다. 이 값은 테이블에서 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">큐브 뿌리가 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">제곱근이 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 독립, 표준 정규 분포 랜덤 변수 의 제곱을 합하여 얻은 변수 :</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; 매개 변수를 사용하여 &lt;code&gt;p&lt;/code&gt; 의 문자열 표현에 사용 된 변수를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">분산은 평균과의 제곱 편차 평균, 즉 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">특정 유형을 나타내는 다양한 문자 코드도 열거 목록의 일부입니다. 유형 문자에 대한 참조 (모두 필요해야 함)는 항상이 열거를 사용해야합니다. 형식은 &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; 이며 여기서 &lt;code&gt;{NAME}&lt;/code&gt; 은 (는)</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">다항식 패키지의 다양한 루틴은 모두 계수가 0에서 위로 올라가는 시리즈를 처리 합니다. 이는 Poly1d 규칙 의 &lt;em&gt;역순&lt;/em&gt; 입니다. 이것을 기억하는 쉬운 방법은 인덱스가도에 해당한다는 것입니다. 즉, coef [i]는도 i의 항의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">다양한 선택 알고리즘은 평균 속도, 최악의 성능, 작업 공간 크기 및 안정적인지 여부를 특징으로합니다. 안정적인 정렬은 동일한 키를 가진 항목을 동일한 상대 순서로 유지합니다. 사용 가능한 알고리즘에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">다양한 정렬 알고리즘은 평균 속도, 최악의 성능, 작업 공간 크기 및 안정적인지 여부를 특징으로합니다. 안정적인 정렬은 동일한 키를 가진 항목을 동일한 상대 순서로 유지합니다. NumPy에서 구현 된 네 가지 알고리즘은 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) 함수는 복소수를 dot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) 와 다르게 처리합니다 . 첫 번째 인수가 복잡한 경우 첫 번째 인수의 복합 켤레가 내적 계산에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">버전 1.0 형식은 배열 헤더의 총 크기가 65535 바이트 일 수만있었습니다. 많은 수의 열이있는 구조화 된 배열이이를 초과 할 수 있습니다. 버전 2.0 형식은 헤더 크기를 4GiB로 확장합니다. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; 는 데이터에 필요한 경우 자동으로 2.0 형식으로 저장합니다. 그렇지 않으면 항상 호환되는 1.0 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">버전 2 인터페이스는 매우 유사했습니다. 그 차이는 크게 미적이었습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">이러한 형식의 버전 번호는 NumPy 버전 번호와 무관합니다. 형식이 업그레이드되면 &lt;code&gt;numpy.io&lt;/code&gt; 의 코드 는 여전히 버전 1.0 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">von Mises 분포 (원형 정규 분포라고도 함)는 단위 원에 대한 연속 확률 분포입니다. 정규 분포의 원형 유사체로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">폰 미제스는 오스트리아-헝가리에서 태어난 리차드에 들러 폰 미제스 (Richard Edler von Mises)의 이름을 딴 것으로 우크라이나의 이름을 딴 것입니다. 그는 1939 년 미국으로 도망하여 하버드에서 교수가되었습니다. 그는 확률 이론, 공기 역학, 유체 역학 및 과학 철학에서 일했습니다.</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">다음과 같은 방법으로 경고를 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 가중치 함수 .</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">무게 기능은</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">체비 쇼프 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">변환 된 시리즈의 창입니다. 값이 None이면 기본 &lt;code&gt;kind&lt;/code&gt; 창이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">최대 값이 1로 정규화 된 창입니다 (1 은 &lt;code&gt;M&lt;/code&gt; 이 홀수 인 경우에만 나타남 ).</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">최대 값이 1로 정규화 된 창 (샘플 수가 홀수 인 경우에만 값 1이 나타남)</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&quot;0이 아닌&quot;이라는 단어 는 객체의 &quot;진실성&quot;을 테스트하는 Python 객체 의 Python 2.x 내장 메소드 &lt;code&gt;__nonzero__()&lt;/code&gt; ( Python 3.x에서 &lt;code&gt;__bool__()&lt;/code&gt; 으로 변경됨 )를 나타냅니다. 예를 들어, 숫자가 0이 아닌 경우 모든 숫자는 진실한 것으로 간주되고 빈 문자열이 아닌 경우 모든 문자열은 진실한 것으로 간주됩니다. 많은 요소들이 어떻게 따라서,이 함수 재귀 카운트 (및 그 서브 어레이에서) 자신이 &lt;code&gt;__nonzero__()&lt;/code&gt; 또는 &lt;code&gt;__bool__()&lt;/code&gt; 에 따라 평가 방법 &lt;code&gt;True&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">줄 바꿈 옵션은 키가 큰 행렬에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">보간 된 값을 평가할 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;period&lt;/code&gt; 지정하지 않으면 데이터 포인트의 x 좌표가 증가해야 합니다. 그렇지 않으면 &lt;code&gt;xp = xp % period&lt;/code&gt; 주기 경계를 정규화 한 후 &lt;code&gt;xp&lt;/code&gt; 가 내부적으로 정렬 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">데이터 포인트의 y 좌표와 같은 길이 &lt;code&gt;xp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">그 내용은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpy에 사용 된 &lt;code&gt;align&lt;/code&gt; 이라는 단어의 4 가지 관련 용도가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">데이터 버퍼가 사용하는 메모리 영역을 설명하는 6 (바이너리) 플래그가 있습니다. 이 상수는 &lt;code&gt;arrayobject.h&lt;/code&gt; 에 정의되어 있으며 플래그의 비트 위치를 결정합니다. 파이썬은 멋진 속성 기반 인터페이스와 이러한 플래그를 가져 오기 (및 적절한 경우)하기위한 사전과 유사한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">종료 간격 &lt;code&gt;[start, stop]&lt;/code&gt; 또는 반 개방 간격 &lt;code&gt;[start, stop)&lt;/code&gt; 에는 동일 간격의 샘플 수가 &lt;code&gt;num&lt;/code&gt; ( &lt;code&gt;endpoint&lt;/code&gt; 점이 True인지 False 인지에 따라 다름 )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">부호있는 정수, 부호없는 정수, 부동 소수점 및 특정 비트 너비의 복합 부동 소수점 유형에 대한 typedef도 있습니다. 사용 가능한 유형 이름은</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">현재 다양한 작업을 다루는 하나 이상의 유형 에 대해 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 로&lt;/a&gt; 정의 된 60 개 이상의 범용 함수 가 있습니다. 관련 중위 표기법을 사용하는 경우 이러한 ufuncs 중 일부는 배열에 자동으로 호출된다 ( &lt;em&gt;예를 들어&lt;/em&gt; , &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt; 경우 내부적으로 호출 &lt;code&gt;a + b&lt;/code&gt; 작성되고 또는 &lt;em&gt;b는&lt;/em&gt; 입니다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ). 그럼에도 불구하고, 선택적 출력 인수를 사용하여 출력을 선택한 객체에 배치하기 위해 ufunc 호출을 계속 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">간단한 &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; 및 후속 &lt;code&gt;%apply&lt;/code&gt; 지시문으로 다루지 않는 많은 C 또는 C ++ 배열 / NumPy 배열 상황이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">지수, 정규화 등의 부호가 다른 DFT를 정의하는 방법에는 여러 가지가 있습니다.이 구현에서 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 의 반환 값에 대한 일반적인 요구 사항은 없지만 대부분의 현명한 구현은 아마도 함수의 인수 중 하나와 동일한 유형의 배열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">하위 배열이 존재하지 않도록 정수 배열 인덱스 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 가 발생할 때 도움이 될 수있는 다른 래핑 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">마스크 배열을 구성하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">범용 함수에는 몇 가지 정보 속성이 있습니다. 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">각 숫자 데이터 유형 및 부울 데이터 유형에 대한 표준 변수 유형이 있습니다. 이들 중 일부는 이미 C 사양에서 사용 가능합니다. 이러한 유형의 확장 코드에서 변수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">1 차원, 2 차원 및 3 차원 배열 각각에 대해 3 가지 독립적 인 테스트 프레임 워크가 지원됩니다. 1 차원 배열의 경우 헤더와 소스라는 두 가지 C ++ 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">범용 ufunc와 유사한 계산이 필요한 ufunc의 세 가지 방법이 있습니다. 이들은 축소, 누적 및 축소입니다. 이러한 각 방법에는 설정 명령과 루프가 필요합니다. 비 요소, 하나의 요소, 스트라이드 루프 및 버퍼 루프에 해당하는 방법에는 네 가지 루프 스타일이 있습니다. 이들은 입력 배열 객체가 각각 0과 1 개의 요소를 가질 때 발생하는 특수한 경우 인 비 요소 및 단일 요소 경우를 제외하고 범용 함수 호출에 대해 구현 된 것과 동일한 기본 루프 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">여러 프로세스 (로컬 또는 분산)에서 반복 가능한 의사 난수를 생성하는 데 사용할 수있는 세 가지 전략이 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">numpy의 메모리 정렬과 관련된 세 가지 사용 사례가 있습니다 (1.14 기준).</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">메모리의 요소 레이아웃에 관계없이 특정 순서로 배열의 요소를 방문하는 것이 중요한 경우가 있습니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 목적은 제공 &lt;code&gt;order&lt;/code&gt; 반복의 이러한 양태를 제어하는 파라미터. 위에서 설명한 동작을 갖는 기본값은 기존 주문을 유지하기 위해 order = 'K'입니다. C 주문의 경우 order = 'C', Fortran 주문의 경우 order = 'F'로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">어레이를 저장된 것과 다른 데이터 유형으로 취급해야하는 경우가 있습니다. 예를 들어, 조작되는 어레이가 32 비트 플로트 인 경우에도 64 비트 플로트에서 모든 계산을 수행 할 수 있습니다. 저수준 C 코드를 작성할 때를 제외하고 일반적으로 내부 루프에서 데이터 유형을 직접 캐스팅하는 대신 반복자가 복사 또는 버퍼링을 처리하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">특별히 취급되는 두 개의 Timedelta 단위 ( 'Y', 연도 및 'M', 월)가 있습니다. 사용 시간에 따라 시간이 얼마나 변하는 지 나타냅니다. 타임 델타 일 단위는 24 시간에 해당하지만 월마다 다른 일 수가 있으므로 월 단위를 일로 변환 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">ndarray (: 두 가지 새로운 유형이 있습니다 &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; )와 ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; 는&lt;/a&gt; ). 추가 유형은 &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; 과 같은 지원 역할을 합니다 . &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; 는&lt;/a&gt; ndarray (평면 속성을 가져올 때 반환되는 개체)에 대한 평면 반복자의 유형입니다. &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; 이&lt;/a&gt; 호출 할 때 개체의 형식을 반환 &lt;code&gt;broadcast&lt;/code&gt; (). 중첩 시퀀스 컬렉션을 통해 반복 및 브로드 캐스트를 처리합니다. 또한 &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;인스턴스가 데이터를 설명하는 데이터 유형 설명자 유형입니다. 마지막으로, 배열에 사용 가능한 각 기본 데이터 유형에 해당하는 새로운 Python 스칼라 인 21 개의 새로운 스칼라 배열 유형이 있습니다. 배열 스칼라를 실제 Python 유형의 계층 구조에 맞출 수있는 다른 10 개의 다른 유형이 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">이 작업을 수행 할 수있는 두 가지 메커니즘, 임시 복사 및 버퍼링 모드가 있습니다. 임시 사본을 사용하면 전체 배열의 사본이 새 데이터 유형으로 작성되고 사본에서 반복이 수행됩니다. 모든 반복이 완료된 후 원래 배열을 업데이트하는 모드를 통해 쓰기 액세스가 허용됩니다. 임시 사본의 주요 단점은 특히 반복 데이터 유형의 항목 크기가 원래 항목보다 큰 경우 임시 사본이 많은 양의 메모리를 소비 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 를 사용하여 배열을 만드는 두 가지 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">부동 소수점 오류 메시지를 캡처하는 두 가지 방법이 있습니다. 첫 번째는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 사용하여 오류 처리기를 'call'으로 설정하는 것 입니다. 그런 다음이 기능을 사용하여 호출 할 기능을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">새로운 배열 스칼라 유형을 효과적으로 정의하는 두 가지 방법이 있습니다 ( 내장 스칼라 유형에서 구조화 된 유형 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt; 을 구성하는 것 제외 ). 한 가지 방법은 단순히 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱하고 관심있는 메소드를 덮어 쓰는 것입니다. 이것은 어느 정도 작동하지만 내부적으로 특정 동작은 배열의 데이터 유형에 의해 수정됩니다. 배열의 데이터 유형을 완전히 사용자 정의하려면 새 데이터 유형을 정의하고 NumPy에 등록해야합니다. 이러한 새로운 유형은 &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API를&lt;/a&gt; 사용하여 C에서만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">인터페이스를 사용하는 두 가지 방법이 있습니다 : 파이썬 측과 C 측. 둘 다 별도의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">배열에 존재할 수있는 각각의 다른 내장 데이터 유형에 대해 Python 유형이 있습니다. 이들은 대부분 C에서 해당 데이터 유형을 둘러싼 단순 랩퍼입니다. 이러한 유형의 C 이름은 &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; . &lt;code&gt;{TYPE}&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">파이썬 정수를 C &lt;code&gt;long&lt;/code&gt; 으로 변환하기위한 프래그먼트가 있습니다 . &lt;code&gt;long&lt;/code&gt; 정수에 정의 된 루틴을 호출 하는 Python 정수를 C &lt;code&gt;int&lt;/code&gt; 로 변환하는 다른 단편이 있습니다. &lt;code&gt;long&lt;/code&gt; 프래그먼트에 대한 정의를 변경하여 여기서 원하는대로 변경할 수 있습니다 . &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는&amp;ldquo;선착순&amp;rdquo;시스템을 사용하여 조각에 대한 활성 정의를 결정합니다. 즉, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 가 내부적으로 수행 하기 전에 &lt;code&gt;long&lt;/code&gt; 변환을 위한 프래그먼트를 정의해야합니다 . &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG를&lt;/a&gt; 사용하면 조각 정의를 &lt;code&gt;pyfragments.swg&lt;/code&gt; 파일에 넣어이 작업을 수행 할 수 있습니다 . 새로운 프래그먼트 정의를 &lt;code&gt;numpy.i&lt;/code&gt; 이면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">스칼라의 함수뿐만 아니라 벡터 (또는 배열)의 함수에 대해서도 반복이 필요합니다. 이 개념은 NumPy에서 범용 함수 (ufunc)를 일반화함으로써 실현됩니다. 일반 ufuncs에서 기본 기능은 요소 별 연산으로 제한되는 반면 일반화 된 버전 (gufuncs)은 &quot;서브 어레이&quot;연산으로 &quot;서브 어레이&quot;를 지원합니다. Perl 벡터 라이브러리 PDL은 유사한 기능을 제공하며 그 용어는 다음에서 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">기본 24 데이터 유형과 유용한 일반 이름을 제공하도록 정의 된 열거 유형 목록이 있습니다. 코드에 유형 번호가 필요할 때마다 열거 된 유형 중 하나가 요청됩니다. 유형은 모두 &lt;code&gt;NPY_{NAME}&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">하위 배열이 있지만 정확히 하나의 요소가 있습니다. 이 경우는 하위 배열이없는 것처럼 처리 할 수 ​​있지만 설정하는 동안 약간의주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">차원 수에 관계없이 각 요소를 수정하거나 처리하려는 상황에 맞는 &quot;평평한&quot;인플레 이스 배열도 있습니다. 한 가지 예는 배열의 각 요소를 1D, 2D 또는 그 밖의 다른 위치에서 양자화하는 &quot;양자화&quot;함수입니다. 이 양식은 연속성을 확인하지만 C 또는 Fortran 주문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">이 C API를 사용하는 사람들이 관심을 가질 수있는 &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;배열 반복에&lt;/a&gt; 대한 소개 안내서 가 있습니다. 많은 경우, C 반복 코드를 작성하기 전에 Python에서 반복자를 작성하여 아이디어를 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">API를 개선하기위한 지속적인 노력이 있습니다. 이 노력에서 NumPy 1.X 용으로 컴파일되는 코드가 NumPy 1.X 용으로 계속 컴파일되도록하는 것이 중요합니다. 동시에, 특정 API는 더 이상 사용되지 않는 것으로 표시되어 미래의 코드에서 이러한 API를 피하고 더 나은 방법을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">복소수에 일반적으로 사용되는 부호에 대한 정의가 두 개 이상 있습니다. 여기에 사용 된 정의는</target>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">하나의 인덱싱 배열이 있으며 할당 배열과 마찬가지로 배열을 간단하게 반복 할 수 있습니다. 예를 들어 연속적 일 수 있습니다. 또한 인덱싱 배열은 &lt;code&gt;intp&lt;/code&gt; 유형이어야하고 할당의 값 배열은 올바른 유형이어야합니다. 이것은 순전히 빠른 길입니다.</target>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">최소한 하나의 인수가 있어야하며 마지막 인수를 &lt;em&gt;item&lt;/em&gt; 으로 정의하십시오 . 그런 다음 &lt;code&gt;a.itemset(*args)&lt;/code&gt; 는 &lt;code&gt;a[args] = item&lt;/code&gt; 과 동일하지만 빠릅니다 . 항목은 스칼라 값 이어야 하며 &lt;code&gt;args&lt;/code&gt; 는 배열 &lt;code&gt;a&lt;/code&gt; 에서 단일 항목을 선택해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">__array_interface__ 사전에 __array_interface__ 속성이 없었으며 __array_interface__ 사전의 모든 키 (버전 제외)는 자체 속성이었습니다. 따라서 파이썬 측 정보를 얻으려면 속성에 별도로 액세스해야했습니다.</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">결과 자체에는 아무런 &lt;em&gt;문제&lt;/em&gt; 가 없습니다 . &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 의 처리 덕분에 0의 시드조차도 완벽하게 괜찮습니다 . 그냥 필요한 경우 &lt;em&gt;일부&lt;/em&gt; 단위 테스트 나 디버깅에 대한 고정 값을, 같은 어떤 씨앗 당신을 사용하여 주시기 바랍니다. 그러나 결과에서 추론을하거나 결과를 게시하려면 더 큰 종자 세트를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">이 부울 값 플래그는 numpy가 &lt;code&gt;a&lt;/code&gt; 에서 사용하는 메모리 영역을 해석하는 방법에 영향을줍니다 (아래 참고 참조). 데이터가 실제로 유형에 따라 정렬 된 경우에만 ALIGNED 플래그를 True로 설정할 수 있습니다. WRITEBACKIFCOPY 및 (더 이상 사용되지 않는) UPDATEIFCOPY 플래그는 True로 설정할 수 없습니다. WRITEABLE 플래그는 어레이가 자체 메모리를 소유하거나 메모리의 최종 소유자가 쓰기 가능한 버퍼 인터페이스를 표시하거나 문자열 인 경우에만 True로 설정할 수 있습니다. (문자열에 대한 예외는 메모리 복사없이 산 세척을 수행 할 수 있도록 만들어졌습니다.)</target>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">이들은 모두 동일한 결과를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">이들은 &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128 및 256에 대해 정의되며 해당 (부호없는) 정수 유형의 최대 (최소) 값을 제공합니다. 참고 : 모든 플랫폼에서 실제 정수 유형을 사용할 수있는 것은 아닙니다 (예 : 128 비트 및 256 비트 정수는 드 rare니다).</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이들은 &lt;code&gt;string_&lt;/code&gt; type 또는 &lt;code&gt;unicode_&lt;/code&gt; type 의 확장 배열입니다 . 이 배열은 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 로부터 상속 받지만 (브로드 캐스팅) 요소별로 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산을 특별히 정의합니다 . 이러한 조작은 문자 유형 의 표준 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 없습니다 . 또한 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 모든 표준 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; (및 &lt;code&gt;unicode&lt;/code&gt; ) 메소드가 있으며 요소별로 실행됩니다. 아마도 chararray를 만드는 가장 쉬운 방법은 &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt; 를 사용 하는 &lt;em&gt;것입니다.&lt;/em&gt;str 또는 유니 코드 데이터 유형의 ndarray입니다. 그러나 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt; 생성자를 사용하거나 &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt; 함수 를 통해 chararray를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">이것들은 대략 가장 작은 것부터 가장 작은 것까지 순서가 정해져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">다음은 몇 가지 자세한 참고 사항이며, 일일 인덱싱에는 중요하지 않습니다 (특별한 순서 없음).</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">이들은 조작을위한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이들은 배열 C-API에 액세스 할 수있는 것과 정확히 같은 방식으로 확장 모듈에서 ufunc C-API에 액세스하기위한 상수 및 함수입니다. &lt;code&gt;import_ufunc&lt;/code&gt; () 함수는 항상 (확장 모듈의 초기화 서브 루틴) 호출해야합니다. 확장 모듈이 하나의 파일에 있으면 필요한 것입니다. 다른 두 상수는 확장 모듈이 여러 파일을 사용하는 경우 유용합니다. 이 경우 &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 코드에 고유 한 것으로 정의한 다음 모듈 초기화 기능을 포함하지 않지만 여전히 UFUNC API에 액세스해야하는 소스 파일에서 &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 이전에 사용한 것과 동일한 이름으로 정의하고 NO_IMPORT_UFUNC 를 정의 &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">다음은 3x3 배열의 상단 삼각형 부분에 액세스 할 수있는 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">이들은 일반적으로 C / C ++에서 힙에 a (n) 배열을 할당하고 함수를 호출하여 배열 값을 채우는 상황에서 사용됩니다. 파이썬에서는 배열이 할당되어 새로운 배열 객체로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">이 배열은 원래 배열의보기입니다. 그것들은 일반적으로 인접하지 않습니다. 또한, 방송 된 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다. 배열에 쓰려면 먼저 복사하십시오. &lt;code&gt;writable&lt;/code&gt; 플래그를 True로 설정할 수 있지만 단일 출력 값에 쓰면 출력 배열에서 둘 이상의 위치가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; (및 해당 매크로 형식)에서 새 배열의 원하는 속성을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">여기에는 거의 전체 배열이 포함됩니다 (주 배열의 오른쪽 두 대각선).</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">이것들은 전체 배열의 작은 부분 (주된 것의 오른쪽에 두 개의 대각선) 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">이 예제는 저수준 &lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 생성자를 보여줍니다. ndarray를 구성하는보다 쉬운 방법은 위 의 &lt;code&gt;See Also&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">이 함수는 모두 정수 인수를 필요로하며 해당 인수의 비트 패턴을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">최소 설정 파일과 함께이 기능은 예제 폴더에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">이 함수와 매크로를 사용하면 C에서 ndarray 요소에 쉽게 액세스 할 수 있습니다. 이러한 기능은 모든 어레이에서 작동합니다. 그러나 머신의 바이트 순서가 아니거나 정렬이 잘못되었거나 쓰기가 불가능한 경우 어레이의 데이터에 액세스 할 때주의해야합니다. 즉, 수행중인 작업을 알지 못하거나 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 사용하여 쓰기 가능, 정렬 및 기계 바이트 순서로 배열을 미리 보장하지 않은 경우 플래그의 상태를 준수해야 합니다. 모든 유형의 배열을 처리하려는 경우 각 유형의 copyswap 기능은 잘못 작동하는 배열을 처리하는 데 유용합니다. 일부 플랫폼 (예 : Solaris)은 잘못 정렬 된 데이터를 좋아하지 않으며 잘못 정렬 된 포인터를 역 참조하면 충돌합니다. 다른 플랫폼 (예 : x86 Linux)은 잘못 정렬 된 데이터에서 더 느리게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">이 함수는 배열 객체의 메소드에서 적어도 한 번 사용되기 때문에 여기에 포함됩니다. 할당 된 객체 중 하나를 호출 할 수없는 경우 함수는 -1 (Python Error 설정하지 않고)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">이 매크로는 모두 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 구조 멤버에 액세스합니다 . 입력 인수 arr 은 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 및 해당 하위 유형 의 모든 인스턴스) 로 직접 해석 가능한 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">이러한 매크로는 확장 모듈을 컴파일하는 동안 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 True로 평가되는 경우에만 의미가 있습니다. 그렇지 않으면이 매크로는 공백과 같습니다. Python은 각 Python 프로세스마다 단일 GIL (Global Interpreter Lock)을 사용하므로 한 번에 하나의 스레드 만 실행할 수 있습니다 (멀티 CPU 시스템에서도). 계산하는 데 시간이 걸리고 업데이트 된 전역 변수와 같은 다른 스레드에 대한 부작용이없는 컴파일 된 함수를 호출 할 때 시간이 많이 걸리는 계산을 수행하는 동안 다른 Python 스레드가 실행될 수 있도록 GIL을 해제해야합니다. . 이는 두 그룹의 매크로를 사용하여 수행 할 수 있습니다. 일반적으로 그룹의 매크로 하나가 코드 블록에 사용되는 경우 모두 동일한 코드 블록에 사용해야합니다. 현재 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 환경 변수 &lt;code&gt;NPY_NOSMP&lt;/code&gt; 가 설정 되지 않은 경우 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 0으로 정의 되지 않는 한 파이썬 정의 &lt;code&gt;WITH_THREADS&lt;/code&gt; 상수 에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">이 매크로는 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 상수에 따라 다른 메모리 할당자를 사용 합니다. 시스템 malloc은 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 이 0 일 때 사용되며 , &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 이 1이면 Python 메모리 할당자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">이 멤버는 모두 &lt;em&gt;src&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 데이터를 복사 하고 표시된 경우 &lt;em&gt;스왑&lt;/em&gt; 하는 함수에 대한 포인터 입니다. arr의 값은 유연한 ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ) 배열 에만 사용 되며 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 에서 얻습니다 . 두 번째 함수는 단일 값을 복사하는 반면 첫 번째 함수는 제공된 보폭으로 n 값을 반복합니다. 이 함수는 잘못 동작 한 &lt;em&gt;src&lt;/em&gt; 데이터를 처리 할 수 ​​있습니다 . 경우 &lt;em&gt;SRC는&lt;/em&gt; NULL입니다 다음, 복사는 수행되지 않습니다. 경우 &lt;em&gt;스왑은&lt;/em&gt; 0, 다음 더 byteswapping는 발생하지 않는다. &lt;em&gt;dest&lt;/em&gt; 와 &lt;em&gt;src로&lt;/em&gt; 가정합니다&lt;em&gt;&lt;/em&gt;겹치지 마십시오. 겹치면 &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;)를 먼저 사용하고 그 뒤에 NULL 값이 &lt;code&gt;src&lt;/code&gt; 인 &lt;code&gt;copyswap(n)&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">이전 줄의이 숫자는 (0, 0)을 기계 정밀도로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">이 옵션은 부동 소수점 숫자, 배열 및 기타 NumPy 객체가 표시되는 방식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">이 포인터는 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; 가 허용하는 포인터와 다릅니다. 일부 축의 방향이 바뀌었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">이러한 속성을 함께 사용하면 일반적인 사용자 제공 시드를 간단한 증분 카운터와 안전하게 혼합하여 서로 매우 독립적 인 &lt;code&gt;BitGenerator&lt;/code&gt; 상태 를 얻을 수 있습니다. 우리는 이것을 사용하기 쉽고 잘못 사용하기 어려운 API로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">이 두 매크로는 비슷하며 배열의 데이터 버퍼에 대한 포인터를 얻습니다. 첫 번째 매크로는 두 번째가 일반 처리를위한 특정 포인터에 할당 될 수 있고 할당되어야합니다. 연속 및 / 또는 정렬 된 어레이를 보장하지 않은 경우 메모리 및 / 또는 정렬 문제를 피하기 위해 어레이의 데이터에 액세스하는 방법을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">이러한 형식 이름은 C-API의 일부이므로 확장 C 코드로 만들 수 있습니다. 도있다 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 과 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; 플랫폼에 대한 포인터를 저장할 수있는 정수 유형 중 하나에 대한 간단한 대체합니다. 이 스칼라 객체의 구조는 C 코드에 노출되지 않습니다. &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt; (..) 함수를 사용하여 배열 스칼라에서 C 유형 값을 추출하고 &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 함수를 사용하여 C 값에서 배열 스칼라 를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">이러한 유형 맵은 이제 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 인수가 기본 바이트 순서를 사용 하는지 확인합니다 . 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">이 값의 사본에 추가됩니다 . 이것은 정확한 형상 (동일 형상이어야 제외 &lt;code&gt;axis&lt;/code&gt; ). 경우 &lt;code&gt;axis&lt;/code&gt; 지정되지 않은, &lt;code&gt;b&lt;/code&gt; 어떤 모양이 될 수 있으며, 사용하기 전에 평평하게됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">이 값은 &lt;code&gt;arr&lt;/code&gt; 사본에 추가됩니다 . 올바른 모양이어야합니다 ( &lt;code&gt;axis&lt;/code&gt; 제외하고 &lt;code&gt;arr&lt;/code&gt; 과 동일한 모양 ). 경우 &lt;code&gt;axis&lt;/code&gt; 지정되지 않은 &lt;code&gt;values&lt;/code&gt; 어떤 모양이 될 수 있으며, 사용하기 전에 평평하게됩니다.</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">이 값은 &lt;code&gt;full&lt;/code&gt; = True 인 경우에만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">이 값은 요소별로 문자열에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">축소 피연산자와 할당 피연산자를 결합 할 때 상황이 조금 더 까다로워집니다. 반복이 시작되기 전에 모든 축소 피연산자가 시작 값으로 초기화되어야합니다. 다음은 &lt;code&gt;a&lt;/code&gt; 의 마지막 축을 따라 합계를 취하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt; 을 다음과 같이 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">이 장에서는 새로운 코드 일부의 논리를 설명하려고합니다. 이 설명의 목적은 누군가 코드를 쳐다 보는 것보다 구현의 아이디어를 좀 더 쉽게 이해할 수 있도록하는 것입니다. 아마도 이런 식으로, 알고리즘은 더 많은 사람들에 의해 개선, 빌리거나 및 / 또는 최적화 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 주소는 반복 루프 전에 캐시 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다. 버퍼링이 활성화 된 경우 반복 중에 값 자체가 변경 될 수 있습니다. 이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">이 고급 색인 작성은 obj가 비교 연산자에서 리턴 될 수있는 것과 같이 부울 유형의 배열 오브젝트 인 경우 발생합니다. 단일 부울 인덱스 배열은 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 와 실질적으로 동일합니다. 위에서 설명한 것처럼 &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;obj&lt;/em&gt; 의 &lt;code&gt;True&lt;/code&gt; 요소를 나타내는 정수 인덱스 배열 의 튜플 (길이 &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt; )을 반환합니다 . 그러나 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 때 더 빠릅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">이는 스칼라와 배열 결합을위한 NumPy 규칙을 사용하여 모든 입력에 유형 승격을 적용하여 피연산자 세트의 출력 유형을 판별합니다. 이것은 ufuncs가 생성하는 것과 동일한 결과 유형입니다. 사용되는 특정 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">어레이 인터페이스에 대한 이러한 접근 방식을 통해 하나의 속성 조회와 잘 정의 된 C 구조 만 사용하여 어레이에 더 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">인터페이스에 대한이 접근 방식은 &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 속성을 가진 객체로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">이 배열은 어레이를 매우 유연하게 사용할 수있게합니다. 배열 버퍼의 해석을 변경하기 위해 메타 데이터를 간단하게 변경하면됩니다. 배열의 바이트 순서를 변경하는 것은 데이터를 재 배열하지 않는 간단한 변경입니다. 데이터 버퍼의 데이터를 변경하거나 데이터를 전혀 복사하지 않고도 어레이의 모양을 매우 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">이 어레이 생성 루틴을 사용하면 기존 어레이의 모양 및 메모리 레이아웃과 일치하는 새 어레이를 편리하게 생성 할 수 있으므로 레이아웃 및 / 또는 데이터 유형이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">이 배열은 다른 배열의 복사본입니다. 기본 배열에 할당 해제하기 전에 C-API 함수 PyArray_ResolveWritebackIfCopy를 호출해야이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">이 배열은 40 바이트 단위로 메모리에 저장됩니다 (연속 메모리 블록이라고 함). 배열의 보폭은 특정 축을 따라 다음 위치로 이동하기 위해 메모리에서 건너 뛰어야하는 바이트 수를 나타냅니다. 예를 들어 다음 열로 이동하려면 4 바이트 (1 값)를 건너 뛰고 다음 행에서 동일한 위치에 도달하려면 20 바이트 (5 개 값)를 건너 뛰어야합니다. 이와 같이, 배열을위한 진보 &lt;code&gt;x&lt;/code&gt; 것 &lt;code&gt;(20, 4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">이 배열은 모든 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt; 마스크 피연산자 의 마스크입니다 . 코드는 선택된 ARRAYMASK 피연산자가 True 인 요소 만 &lt;code&gt;writemasked&lt;/code&gt; 을 나타내는 쓰기 마스크 된 플래그를 사용합니다 . 일반적으로 반복자는 이것을 강제하지 않으며, 그 약속을 따르기 위해 반복을 수행하는 코드에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">이 배열은 1 차원 인덱스에서 Nd 인덱스를 계산하는 데 사용됩니다. 필요한 치수의 제품이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">이 배열 방법은 편리하게 연결될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">이 배열에는 &lt;code&gt;[0, n-1]&lt;/code&gt; 정수가 포함되어야합니다 . 여기서 &lt;code&gt;mode=wrap&lt;/code&gt; 또는 &lt;code&gt;mode=clip&lt;/code&gt; 이 아닌 경우 정수가 허용되는 경우를 제외하고 &lt;code&gt;n&lt;/code&gt; 은 선택 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">이 배열은 &lt;code&gt;[0, n-1]&lt;/code&gt; 정수를 포함해야합니다 . 여기서 n은 선택 수입니다.</target>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">이 속성은 데이터를 공유하는 데 사용될 &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt; 를 노출하는 객체 일 수도 있습니다 . 이 키가 존재하지 않거나 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 객체 자체의 버퍼 인터페이스를 통해 메모리 공유가 수행됩니다. 이 경우 오프셋 키를 사용하여 버퍼의 시작을 나타낼 수 있습니다. 메모리 영역을 확보하려면 어레이 인터페이스를 노출하는 객체에 대한 참조를 새 객체로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">이 속성은 ctypes 모듈로 공유 라이브러리를 호출 할 때 배열을보다 쉽게 ​​사용할 수있는 객체를 만듭니다. 반환 된 객체는 특히 공유 라이브러리에 대한 인수로 사용할 수있는 ctypes 객체를 반환하는 data, shape 및 strides 속성 (아래 참고 참조)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">이 기본 동작은 파일 인수로 2 개의 튜플을 전달하여 기능을 보강 할 수 있습니다. 튜플의 첫 번째 요소는 나머지 파일 시퀀스를 설치해야하는 상대 경로 (패키지 설치 디렉토리 아래)를 지정해야합니다 (소스 배포의 파일 이름과 관련이 없음). 튜플의 두 번째 요소는 설치해야하는 파일 시퀀스입니다. 이 순서의 파일은 파일 이름, 상대 경로 또는 절대 경로 일 수 있습니다. 절대 경로의 경우 파일은 첫 번째 인수에 관계없이 최상위 패키지 설치 디렉토리에 설치됩니다. 파일 이름과 상대 경로 이름은 패키지 설치 디렉토리에 튜플의 첫 번째 요소로 지정된 경로 이름 아래에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방송은 &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 달성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">이 버그로 인해 3.4 이전의 Python은 한 번 무시 된 후에도 catch_warnings에서도 경고를 다시 표시하지 않습니다. 다음 테스트에서 경고를 확인해야 할 수 있으므로 &quot;무시&quot;필터를 쉽게 사용할 수 없습니다. 또한 경고 테스트를보다 쉽게 ​​수행 할 수 있으며 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">다차원 배열에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">이 클래스 는 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메소드를 연기 하여 비교 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 등) 및 산술 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 등)을 포함 하여 &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 거의 모든 Python 내장 연산자에 대한 특수 메소드를 구현합니다 . 어떤 서브 클래스가 구현해야하는지</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">이 클래스는 numarray 하위 호환성을 위해 제공됩니다. 새로운 코드 (numarray 호환성과 관련이없는)는 &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 유형의 배열을 사용해야하며 대신 빠른 벡터화 된 문자열 연산을 위해 &lt;code&gt;numpy.char&lt;/code&gt; 의 무료 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">이 클래스는 어떤 시점에서 뷰를 mmap 버퍼로 리턴하는 팩토리 함수로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">이 코드에는 상당한 양의 오류 처리 기능이 있습니다. 메모 &lt;code&gt;SWIG_fail&lt;/code&gt; 을 위한 매크로입니다 &lt;code&gt;goto fail&lt;/code&gt; 라인 (28) 사용자가 인수의 잘못된 번호를 제공하는 경우에 라벨을 참조, 이것은 라인 NumPy와 배열의 건설에 오류가 발생하거나 잘못된 배열을 생성하는 경우 (10)에 잡힐 것 차원 수에 따라 이러한 오류는 17 번째 줄에서 발견됩니다. 마지막으로 오류가 감지되면 30 번째 줄에서 메모리가 여전히 올바르게 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">이 상태는 입력을 통해 브로드 캐스트됩니다. 조건이 True 인 위치에서는 &lt;code&gt;out&lt;/code&gt; 배열이 ufunc 결과로 설정됩니다. 다른 경우, &lt;code&gt;out&lt;/code&gt; 배열은 원래 값을 유지합니다. 초기화되지 않은 &lt;code&gt;out&lt;/code&gt; 배열이 default &lt;code&gt;out=None&lt;/code&gt; 을 통해 생성 되면 조건이 False 인 배열 내의 위치는 초기화되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">이 생성자는 &lt;code&gt;empty&lt;/code&gt; 와 비교할 수 있습니다 . 새 레코드 배열을 작성하지만 데이터로 채우지는 않습니다. 데이터에서 레코드 배열을 작성하려면 다음 방법 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='Fortran'&lt;/code&gt; 사례하는, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='Fortran'&lt;/code&gt; 사례하는, &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">이 데코레이터는 DeprecationWarning을 필터링하여 테스트 스위트 실행 중에 인쇄를 피하고 테스트에서 실제로 DeprecationWarning이 발생하는지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">이 데코레이터는 테스트되지 않은 모듈에서 호출 할 수 있으므로 nose 네임 스페이스를 사용할 수 없습니다. 참조 &lt;code&gt;istest&lt;/code&gt; 및 &lt;code&gt;nottest&lt;/code&gt; 에 &lt;code&gt;nose.tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">이 기본 반복자는 차원의 하위 배열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">이 기본 임계 값은 SVD 계산의 숫자 오류에 대한 순위 부족 계산을 감지하도록 설계되었습니다. 의 컬럼이 있다는 상상 &lt;code&gt;M&lt;/code&gt; 다른 열의 선형 조합 (부동 소수점) 정확한 인 &lt;code&gt;M&lt;/code&gt; 이 . &lt;code&gt;M&lt;/code&gt; 에서 SVD를 계산하면 일반적으로 정확히 0과 같은 특이 값이 생성되지 않습니다. SVD 계산에서 수치가 부정확함에 따라 0과 가장 작은 SVD 값의 차이가 발생합니다. 작은 SVD 값에 대한 임계 값은이 수치 부정확성을 고려하며 기본 임계 값은 이러한 수치 순위 결함을 감지합니다. 매트릭스 선언 할 수있다 임계 &lt;code&gt;M&lt;/code&gt; 의 랭크가 결핍 된 경우에도 일부 열의 선형 조합 &lt;code&gt;M&lt;/code&gt; 정확히의 다른 열 같지 않은 &lt;code&gt;M&lt;/code&gt; 매우 가까이의 또 다른 컬럼 만 숫자 만 &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">이는 일반적인 상관 관계를 계산하지 않습니다. op2가 op1보다 크면 인수가 바뀌고 복합 배열에 대해 켤레가 사용되지 않습니다. 일반적인 신호 처리 상관 관계는 PyArray_Correlate2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">이를 통해 반복자가 데이터 종속성에 대해 추론하여 불필요한 사본을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">이 예제는 Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 스레드를 사용하여 배열을 채 웁니다. 스레드는 오래 지속되므로 반복 호출에는 스레드 작성으로 인한 추가 오버 헤드가 필요하지 않습니다. 기본 BitGenerator는 &lt;code&gt;PCG64&lt;/code&gt; 이며, 속도가 빠르며 오랜 시간이 &lt;code&gt;PCG64.jumped&lt;/code&gt; 상태를 진행시키면서 새 생성기를 반환하기 위해 PCG64.jumped 를 사용할 수 있습니다. 생성 된 난수는 동일한 시드가 동일한 출력을 생성한다는 의미에서 재현 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">이 예제는 순수한 파이썬 구현을 사용하여 numba를 사용하여 Box-Muller 법선을 생성하는 방법을 보여줍니다. 난수는 &lt;code&gt;ctypes.next_double&lt;/code&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">이 예제는 임시 파일을 사용하므로 doctest는 디렉토리에 파일을 쓰지 않습니다. '일반적인'파일 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; 에 대한이 설명은 완전하지 않습니다. 전체 사양은 &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">이 기능을 사용하면 프로세스 간 조정없이 스트림을 분할 할시기와 방법에 대한 로컬 결정을 내릴 수 있습니다. 공통 글로벌 서비스에서 겹치는 스트림 또는 요청 스트림을 피하기 위해 공간을 사전 할당 할 필요는 없습니다. 이 일반적인 &quot;트리 해싱&quot;체계는 &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;numpy에는 고유&lt;/a&gt; 하지 않지만 아직 널리 퍼져 있지는 않습니다. 파이썬은 점점 더 유연한 병렬화 메커니즘을 사용할 수 있으며,이 체계는 이러한 종류의 사용에 매우 적합합니다.</target>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">이 파일은 패키지 설치 디렉토리에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">이 플래그는 사용할 수 있습니다 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 때 &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; 이&lt;/a&gt; 활성화됩니다. 버퍼링이 없으면 내부 루프는 항상 가장 안쪽 반복 차원의 크기이므로 잘라 내기 위해서는 특별한 처리가 필요하므로 효과적으로 버퍼링 된 버전과 비슷해집니다.</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">이 플래그는 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; 가 반복자에서 사용 가능한 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 와 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">기본 배열이 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; 인 경우이&lt;/a&gt; 플래그는 true 입니다. 가능한 경우 계산을 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">이 플래그는 버퍼에서 어레이로의 쓰기에만 영향을줍니다. 이는 피연산자가 &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 인&lt;/a&gt; 경우 반복을 수행하는 코드가이 피연산자에 기록하여 어떤 요소가 손대지 않고 어떤 요소가 수정 될지를 제어 할 수 있습니다. 마스크가 입력 마스크의 조합이어야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">이 형식을 사용하면 C에서 'union'유형처럼 ​​작동하는 겹치는 필드로 struct dtype을 지정할 수 있습니다. 그러나이 사용법은 권장되지 않으며 공용 메커니즘이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">이 함수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;obj&lt;/code&gt; 에&lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔쳐 &lt;/strong&gt; &lt;code&gt;arr&lt;/code&gt; 의 기본 속성으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">이 함수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;op&lt;/code&gt; 에&lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔치고 &lt;/strong&gt; &lt;code&gt;op&lt;/code&gt; 가 기본 클래스 ndarray 인지 확인합니다 . 특수한 경우 배열 스칼라이지만 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 호출 합니다 ( &lt;code&gt;op&lt;/code&gt; , NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; , NULL).</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">이 함수는 인수 &lt;code&gt;bias&lt;/code&gt; 및 &lt;code&gt;ddof&lt;/code&gt; 를 받아들이지 만 버립니다 . 이것은이 기능의 이전 버전과의 호환성을위한 것입니다. 이 인수는 함수의 반환 값에 영향을 미치지 않았으며이 버전 및 이전 버전의 numpy에서는 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">이 기능은 단순히 형식이 지정된 파일을 빠르게 판독하는 것을 목표로합니다. &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 함수는 결 측값 이있는 행을 보다 정교하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">이 함수를 사용하면 하나의 구간 세트를 계산하고 여러 히스토그램에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">이 함수를 사용하면 ufunc가 사용자 정의 데이터 유형으로 입력 인수와 함께 호출 될 때마다 이미 작성된 ufunc와 함께 1-d 루프를 등록 할 수 있습니다. ufunc가 내장 데이터 유형과 작동하도록하기 위해 필요합니다. 데이터 유형은 이전에 numpy 시스템에 등록되어 있어야합니다. 루프는 &lt;em&gt;function으로&lt;/em&gt; 전달됩니다 . 이 루프로 전달되어야 할 임의의 데이터를 가지고 &lt;em&gt;데이터&lt;/em&gt; . 루프에 필요한 데이터 유형은 &lt;em&gt;arg_types&lt;/em&gt; 로 전달되며 , 최소한 ufunc-&amp;gt; nargs만큼 큰 메모리에 대한 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">이 함수를 사용하면 배열 객체의 tp_str 및 tp_repr 메소드를 Python 함수로 변경할 수 있습니다. 따라서 str (arr) 또는 repr (arr)가 Python에서 호출 될 때 모든 배열에서 발생하는 상황을 변경할 수 있습니다. 호출 할 함수는 &lt;em&gt;op&lt;/em&gt; 로 전달됩니다 . 경우 &lt;em&gt;에 repr가&lt;/em&gt; 제로가 아닌,이 기능은 달리 함수가 STR (도착)에 응답하여 호출 될 것이다에 repr (도착)에 응답하여 호출 될 것이다. &lt;em&gt;op&lt;/em&gt; 가 호출 가능한지 여부는 확인되지 않습니다 . &lt;em&gt;op에&lt;/em&gt; 전달 된 콜 러블 은 배열 인수를 예상하고 인쇄 할 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">이 함수는 사용자가 dtype type num 값 대신 PyArray_Descr 객체를 사용하여 1-d 루프를 등록 할 수 있다는 점을 제외하고는 위의 PyUFunc_RegisterLoopForType과 같이 작동합니다. 이를 통해 스칼라 데이터 유형 대신 구조화 된 배열 데이터 유형 및 사용자 정의 데이터 유형에 1-d 루프를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">이 함수는 마스크 배열 &lt;code&gt;a&lt;/code&gt; 의 채우기 값을 제자리에서 변경합니다 . &lt;code&gt;a&lt;/code&gt; 가 마스킹 된 배열이 아닌 경우 함수는 아무 작업도하지 않고 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">이 함수는 &lt;em&gt;arr&lt;/em&gt; 이 0 차원 배열인지 확인하고, 그렇다면 적절한 배열 스칼라를 반환합니다. 0 차원 배열을 파이썬으로 반환 할 때마다 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform) 를 사용하여 &lt;em&gt;M&lt;/em&gt; 차원 배열의 여러 축에 대해 &lt;em&gt;N&lt;/em&gt; 차원 이산 푸리에 변환을 계산합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform) 를 사용하여 &lt;em&gt;M&lt;/em&gt; 차원 배열의 모든 축에 대해 &lt;em&gt;n&lt;/em&gt; 차원 이산 푸리에 변환을 계산합니다 . 기본적으로 변환은 입력 배열의 마지막 두 축, 즉 2 차원 FFT에 대해 계산됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 실수 형 배열의 여러 축에 대해 N 차원 이산 푸리에 변환을 계산합니다. 기본적으로 모든 축은 마지막 축에 대해 실제 변환을 수행하면서 변환되며 나머지 변환은 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">이 함수는 신호 처리 텍스트에 일반적으로 정의 된 상관 관계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 모든 축에 대해 2 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. 기본적으로 역변환은 입력 배열의 마지막 두 축에 대해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 여러 축에 대한 실제 입력에 대해 N 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. ( &lt;code&gt;len(a)&lt;/code&gt; 가 &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 a. &lt;code&gt;a.shape&lt;/code&gt; 이 필요 합니다.)</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 여러 축에 대해 N 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. 사용 된 정의 및 규칙에 대한 설명은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; 로&lt;/a&gt; 계산 된 실제 입력 의 1 차원 &lt;em&gt;n&lt;/em&gt; 포인트 이산 푸리에 변환의 역을 계산합니다 . 즉, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. ( 여기서 &lt;code&gt;len(a)&lt;/code&gt; 가 필요한 이유는 아래 참고 사항을 참조 하십시오.)</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 로 계산 된 1 차원 &lt;em&gt;n-&lt;/em&gt; 포인트 이산 푸리에 변환 의 역을 계산합니다 . 다시 말해, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; ~ 수치 정확도 이내입니다. 알고리즘 및 정의에 대한 일반적인 설명은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)라고하는 효율적인 알고리즘을 통해 실수 배열 의 1 차원 &lt;em&gt;n&lt;/em&gt; 포인트 이산 푸리에 변환 (DFT)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">이 함수 는 효율적인 고속 푸리에 변환 (FFT) 알고리즘 [CT]을 사용 하여 1 차원 &lt;em&gt;n&lt;/em&gt; 포인트 이산 푸리에 변환 (DFT)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 계속 지원되지만 &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; 를 선호해야합니다 . 이동 &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; 기능이 NumPy 1.11에 추가되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
