<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="71fff5ea85661c16e7519843bc17a41ff8e91eb9" translate="yes" xml:space="preserve">
          <source>Distributions</source>
          <target state="translated">Distributions</target>
        </trans-unit>
        <trans-unit id="8b193321a119fbd0dcd684bd2d9426886ca75352" translate="yes" xml:space="preserve">
          <source>Divide one Chebyshev series by another.</source>
          <target state="translated">한 체비 쇼프 시리즈를 다른 것으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="143efc24501a0aca7c9b8146445d3052ccca2768" translate="yes" xml:space="preserve">
          <source>Divide one Hermite series by another.</source>
          <target state="translated">Hermite 시리즈를 다른 것으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="59969920d0ad8492606516de2799361ab80e51e4" translate="yes" xml:space="preserve">
          <source>Divide one Laguerre series by another.</source>
          <target state="translated">하나의 Laguerre 시리즈를 다른 시리즈로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="cb8fb14724e04e74acd5ed518b7956bde57f9f7f" translate="yes" xml:space="preserve">
          <source>Divide one Legendre series by another.</source>
          <target state="translated">하나의 Legendre 시리즈를 다른 시리즈로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="53b11bc9ec8586eecc94bbdfc2f103e8f1cdcb61" translate="yes" xml:space="preserve">
          <source>Divide one polynomial by another.</source>
          <target state="translated">하나의 다항식을 다른 다항식으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c51ce5484f877f3b3126642a285f454856b1a199" translate="yes" xml:space="preserve">
          <source>Divide other into self, and return a new masked array.</source>
          <target state="translated">다른 것을 자기로 나누고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="2ef1e5ad95321353adac46fbc8491e615e836d21" translate="yes" xml:space="preserve">
          <source>Divide self by other in-place.</source>
          <target state="translated">다른 곳으로 자기를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="1e3c651961978f36b837c449de83e63bcfcd74e0" translate="yes" xml:space="preserve">
          <source>Divide self into other, and return a new masked array.</source>
          <target state="translated">자기 자신을 다른 것으로 나누고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="fdde9e15039c0cebf1238ec9b7a4737bb63abb02" translate="yes" xml:space="preserve">
          <source>Dividend array.</source>
          <target state="translated">배당 배열.</target>
        </trans-unit>
        <trans-unit id="94054a2bd282906d6045981a996c888ef4e4b84a" translate="yes" xml:space="preserve">
          <source>Dividend polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">배당 다항식의 계수.</target>
        </trans-unit>
        <trans-unit id="ae3d5366321b2cda8048303484a9efb3b8012809" translate="yes" xml:space="preserve">
          <source>Dividend.</source>
          <target state="translated">Dividend.</target>
        </trans-unit>
        <trans-unit id="3da76ff26283ccdfb95f22f35e70c08074f9c0d6" translate="yes" xml:space="preserve">
          <source>Division by zero: infinite result obtained from finite numbers.</source>
          <target state="translated">0으로 나누기 : 유한 숫자에서 얻은 무한 결과.</target>
        </trans-unit>
        <trans-unit id="5c970858ddd5ebfccc0979913547b40892ea84f0" translate="yes" xml:space="preserve">
          <source>Division:</source>
          <target state="translated">Division:</target>
        </trans-unit>
        <trans-unit id="e528cec9df846efb2d96080851febbb0ef5214b8" translate="yes" xml:space="preserve">
          <source>Divisor array. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">제수 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="35ac85bf74de66241c9334431207aa5df69df721" translate="yes" xml:space="preserve">
          <source>Divisor polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">제수 다항식의 계수.</target>
        </trans-unit>
        <trans-unit id="a079e40a62a4209488cf119d0047ff12fb70cf71" translate="yes" xml:space="preserve">
          <source>Divisor. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">제수. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="1a536da5cd434d26e0ec447ec43ce448909aa6d1" translate="yes" xml:space="preserve">
          <source>Divmod:</source>
          <target state="translated">Divmod:</target>
        </trans-unit>
        <trans-unit id="3d78017db5e95583684a29d66eb903a8ce60aba4" translate="yes" xml:space="preserve">
          <source>Do a keyword search on docstrings.</source>
          <target state="translated">docstring에서 키워드 검색을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ea9d279c47a9187c1db7b1f7b114b04d8f0172e5" translate="yes" xml:space="preserve">
          <source>Do not lose the type info if the sequence contains unknown objects.</source>
          <target state="translated">시퀀스에 알 수없는 객체가 포함 된 경우 유형 정보를 잃지 마십시오.</target>
        </trans-unit>
        <trans-unit id="37d435c090c5ec2cb12a71fd3a6a6e5087869ea8" translate="yes" xml:space="preserve">
          <source>Do not rely on the combination of &lt;code&gt;tofile&lt;/code&gt; and &lt;a href=&quot;#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt; for data storage, as the binary files generated are are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent &lt;code&gt;.npy&lt;/code&gt; format using &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">생성 된 이진 파일은 플랫폼 독립적이지 않기 때문에 데이터 저장을 위해 &lt;code&gt;tofile&lt;/code&gt; 과 &lt;a href=&quot;#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt; 의 조합에 의존하지 마십시오 . 특히 바이트 순서 또는 데이터 유형 정보는 저장되지 않습니다. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 사용하여 플랫폼 독립적 인 &lt;code&gt;.npy&lt;/code&gt; 형식으로 데이터를 저장할 수 있습니다대신 를 .</target>
        </trans-unit>
        <trans-unit id="a3e1823cbbdfbb28b0abf8529520a9bf10c3f493" translate="yes" xml:space="preserve">
          <source>Do not use the Python keywords &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp;amp; and | instead.</source>
          <target state="translated">Python 키워드 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 논리 배열 표현식을 결합 하지 마십시오 . 이 키워드는 전체 배열의 실제 값을 테스트합니다 (예상대로 요소별로 아님). 비트 연산자 &amp;amp; 및 | 대신에.</target>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="974974af4b7655224f60ff495507eedae4f6994e" translate="yes" xml:space="preserve">
          <source>Doctests are a convenient way of documenting the behavior of a function and allowing that behavior to be tested at the same time. The output of an interactive Python session can be included in the docstring of a function, and the test framework can run the example and compare the actual output to the expected output.</source>
          <target state="translated">Doctest는 함수의 동작을 문서화하고 그 동작을 동시에 테스트 할 수있는 편리한 방법입니다. 대화 형 Python 세션의 출력은 함수의 docstring에 포함될 수 있으며 테스트 프레임 워크는 예제를 실행하고 실제 출력을 예상 출력과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2706eec51222f32b825a53b6e68123a18fe8dfd" translate="yes" xml:space="preserve">
          <source>Documentation for the ufunc. Should not contain the function signature as this is generated dynamically when __doc__ is retrieved.</source>
          <target state="translated">ufunc에 대한 설명서. __doc__을 검색 할 때 동적으로 생성되므로 함수 서명을 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0d7bd4643db21c4724f9db11e4bb21b57a80e3fc" translate="yes" xml:space="preserve">
          <source>Does &lt;em&gt;not&lt;/em&gt; conjugate! For the complex conjugate transpose, use &lt;code&gt;.H&lt;/code&gt;.</source>
          <target state="translated">않습니다 &lt;em&gt;하지&lt;/em&gt; 활용할! 복합 접합 전치의 경우 &lt;code&gt;.H&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0e5a02446a93df5c6a9418c49d06da3e217cfb" translate="yes" xml:space="preserve">
          <source>Does not check that the x-coordinate sequence &lt;code&gt;xp&lt;/code&gt; is increasing. If &lt;code&gt;xp&lt;/code&gt; is not increasing, the results are nonsense. A simple check for increasing is:</source>
          <target state="translated">x 좌표 시퀀스 &lt;code&gt;xp&lt;/code&gt; 가 증가하고 있는지 확인하지 않습니다 . 경우 &lt;code&gt;xp&lt;/code&gt; 증가되지 않으며, 결과는 말도 있습니다. 증가에 대한 간단한 점검은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37a9483068c43f31f29b0fa4bbb6e7ded8b89453" translate="yes" xml:space="preserve">
          <source>Does not include memory consumed by non-element attributes of the array object.</source>
          <target state="translated">배열 객체의 비 요소 속성이 사용하는 메모리는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82197e5e2b65bee680b92d50de02f93e5275ccd4" translate="yes" xml:space="preserve">
          <source>Does their energy intake deviate systematically from the recommended value of 7725 kJ?</source>
          <target state="translated">그들의 에너지 섭취는 권장 값 7725 kJ에서 체계적으로 벗어 납니까?</target>
        </trans-unit>
        <trans-unit id="fda52ba5b69a393e193dac1fab0651122da1f1df" translate="yes" xml:space="preserve">
          <source>Doing a little timing in IPython shows that the reduced overhead and memory allocation of the Cython inner loop is providing a very nice speedup over both the straightforward Python code and an expression using NumPy&amp;rsquo;s built-in sum function.:</source>
          <target state="translated">IPython에서 약간의 타이밍을 수행하면 Cython 내부 루프의 오버 헤드 및 메모리 할당이 줄어들어 간단한 Python 코드와 NumPy의 내장 합계 함수를 사용하는 표현식에 비해 매우 빠른 속도를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5a2e054286be13032ccbf78259a0703d8d83b801" translate="yes" xml:space="preserve">
          <source>Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is [].</source>
          <target state="translated">결과 시리즈의 도메인. 없음 인 경우 도메인은 가장 작은 루트에서 가장 큰 루트까지의 간격입니다. [] 인 경우 도메인은 클래스 도메인입니다. 기본값은 []입니다.</target>
        </trans-unit>
        <trans-unit id="4eb122f9bcef4efacc38db644f8b8fbbbd3f1f52" translate="yes" xml:space="preserve">
          <source>Domain over which &lt;code&gt;func&lt;/code&gt; is interpolated. The default is None, in which case the domain is [-1, 1].</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 보간 되는 도메인 . 기본값은 없음입니다.이 경우 도메인은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="f2d15df66fa784a07d3132cdc84cc4e9d2a43f78" translate="yes" xml:space="preserve">
          <source>Domain to use for the returned series. If &lt;code&gt;None&lt;/code&gt;, then a minimal domain that covers the points &lt;code&gt;x&lt;/code&gt; is chosen. If &lt;code&gt;[]&lt;/code&gt; the class domain is used. The default value was the class domain in NumPy 1.4 and &lt;code&gt;None&lt;/code&gt; in later versions. The &lt;code&gt;[]&lt;/code&gt; option was added in numpy 1.5.0.</source>
          <target state="translated">반환 된 시리즈에 사용할 도메인입니다. 않으면 &lt;code&gt;None&lt;/code&gt; , 그 점 덮는 최소 도메인 &lt;code&gt;x&lt;/code&gt; 선택되지 않는다. 만약 &lt;code&gt;[]&lt;/code&gt; 클래스 도메인이 사용됩니다. 기본값은 NumPy 1.4의 클래스 도메인이고 이후 버전에서는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;[]&lt;/code&gt; 옵션은 NumPy와 1.5.0에서 추가되었다.</target>
        </trans-unit>
        <trans-unit id="82edf41d9d3177c9bd118b575de636ba573d4e3f" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [-1, 1].</source>
          <target state="translated">사용할 도메인. 간격 &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; 은 이동 및 스케일링에 의해 간격 &lt;code&gt;[window[0], window[1]]&lt;/code&gt; 에 매핑됩니다 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="07b2e5d2cce01727bf325f6bd8595469a9076b39" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [0, 1].</source>
          <target state="translated">사용할 도메인. 간격 &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; 은 이동 및 스케일링에 의해 간격 &lt;code&gt;[window[0], window[1]]&lt;/code&gt; 에 매핑됩니다 . 기본값은 [0, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="99ef7d89dc77a04fadda76f62633917fa42d732a" translate="yes" xml:space="preserve">
          <source>Domains. Each domain must (successfully) convert to a 1-d array containing precisely two values.</source>
          <target state="translated">도메인. 각 도메인은 (성공적으로) 정확히 두 개의 값을 포함하는 1 차원 배열로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="845a637b103bbcbbace502867de0ec52f11db37e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be fooled by this attribute&amp;rsquo;s name: &lt;code&gt;reduceat(a)&lt;/code&gt; is not necessarily smaller than &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이 속성의 이름에 속지 마십시오. &lt;code&gt;reduceat(a)&lt;/code&gt; 가 반드시 &lt;code&gt;a&lt;/code&gt; 보다 작을 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="63f6c0cae180c1519a43cdaf129188e65581d9cb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amax(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">2 개의 배열을 요소별로 비교하기 위해 &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; 를 사용하지 마십시오 . 경우 &lt;code&gt;a.shape[0]&lt;/code&gt; 2 인 &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; 보다 빠른 인 &lt;code&gt;amax(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee45e18cb25f4ffa299fe638bc542425558ed71" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amin(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">2 개의 배열을 요소별로 비교하기 위해 &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 . 경우 &lt;code&gt;a.shape[0]&lt;/code&gt; 2 인 &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; 보다 빠른 인 &lt;code&gt;amin(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ed26a26d95479b379119608058dbb2109efb38" translate="yes" xml:space="preserve">
          <source>Dot product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Can be an int, float, or complex depending on the types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">내적 와 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 의 유형에 따라 int, float 또는 complex 일 수 있습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b5eb09c46c81da930e48b39cbd0988e1d15009" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays.</source>
          <target state="translated">두 배열의 내적.</target>
        </trans-unit>
        <trans-unit id="69fc04836f683a90b063205daff794ec842891ec" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays. Specifically,</source>
          <target state="translated">두 배열의 내적. 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="10eebd1ec669729dbb8a387ff1f1ee83e265b551" translate="yes" xml:space="preserve">
          <source>Draw &lt;code&gt;size&lt;/code&gt; samples of dimension k from a Dirichlet distribution. A Dirichlet-distributed random variable can be seen as a multivariate generalization of a Beta distribution. The Dirichlet distribution is a conjugate prior of a multinomial distribution in Bayesian inference.</source>
          <target state="translated">그리기 &lt;code&gt;size&lt;/code&gt; 디리클레 분포로부터 치수 (k)의 샘플. Dirichlet 분포 랜덤 변수는 베타 분포의 다변량 일반화로 볼 수 있습니다. Dirichlet 분포는 베이지안 추론에서 다항 분포 이전의 켤레입니다.</target>
        </trans-unit>
        <trans-unit id="8cef6690ff1fb5f0c2316445230ab79655322c59" translate="yes" xml:space="preserve">
          <source>Draw each 100 values for lambda 100 and 500:</source>
          <target state="translated">람다 100과 500에 대해 각각 100 개의 값을 그립니다 :</target>
        </trans-unit>
        <trans-unit id="81a1f06763debec752f9772c00b9c8c55a29d67f" translate="yes" xml:space="preserve">
          <source>Draw random samples from a multivariate normal distribution.</source>
          <target state="translated">다변량 정규 분포에서 랜덤 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="bc8a71087c0197828056ce59780ae3569bbf2e6d" translate="yes" xml:space="preserve">
          <source>Draw random samples from a normal (Gaussian) distribution.</source>
          <target state="translated">정규 (가우시안) 분포에서 랜덤 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c671d5af70be0d6ee7f133745fc1b0ba932a0dc3" translate="yes" xml:space="preserve">
          <source>Draw samples and plot the distribution:</source>
          <target state="translated">표본을 그리고 분포를 그리십시오 :</target>
        </trans-unit>
        <trans-unit id="d0efc43d29d4ab1659826dde574edba31ec35e3f" translate="yes" xml:space="preserve">
          <source>Draw samples from a 1-parameter Weibull distribution with the given shape parameter &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">주어진 모양 모수 &lt;code&gt;a&lt;/code&gt; 를 사용하여 1 모수 Weibull 분포에서 표본을 추출합니다 . .</target>
        </trans-unit>
        <trans-unit id="fc465d9bb43792a6a4d6d0b79fc58926df796844" translate="yes" xml:space="preserve">
          <source>Draw samples from a Beta distribution.</source>
          <target state="translated">베타 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="db385760aa8dd626fb9adb8853dfd6288a91a9df" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gamma distribution.</source>
          <target state="translated">감마 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="78ab6a861638484d02fed32908592521ecb292b9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution with specified location and scale. For more information on the Gumbel distribution, see Notes and References below.</source>
          <target state="translated">지정된 위치와 스케일로 Gumbel 분포에서 표본을 추출합니다. Gumbel 배포에 대한 자세한 내용은 아래 참고 및 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66a815e387ea9da74fa2238bda4162c421a8c8a9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution.</source>
          <target state="translated">Gumbel 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="cb301b24d49678b3e9fff80704432281d0df654a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Hypergeometric distribution.</source>
          <target state="translated">Hypergeometric 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="836d1593a600cfcfb833fff8c11191d4c4c5d27a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Pareto II or Lomax distribution with specified shape.</source>
          <target state="translated">지정된 모양의 파레토 II 또는 Lomax 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="721b7e6dfb7ad60658e5e614aa751c343f6988fc" translate="yes" xml:space="preserve">
          <source>Draw samples from a Poisson distribution.</source>
          <target state="translated">푸 아송 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="62a0b4d313dadcf54cda2bc4c9745765dcc56eb6" translate="yes" xml:space="preserve">
          <source>Draw samples from a Rayleigh distribution.</source>
          <target state="translated">레일리 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0cdf4a2aee4c3b56a5568531ce7576534f61561f" translate="yes" xml:space="preserve">
          <source>Draw samples from a Wald, or inverse Gaussian, distribution.</source>
          <target state="translated">Wald 또는 역 가우스 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="16cd7ccf53dc2b531e1445308d5381898213743b" translate="yes" xml:space="preserve">
          <source>Draw samples from a Weibull distribution.</source>
          <target state="translated">Weibull 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0e097ecaf2ff3b51bfb55b676dfdfa6cbd8e50b1" translate="yes" xml:space="preserve">
          <source>Draw samples from a Zipf distribution.</source>
          <target state="translated">Zipf 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b159750cd52438190e80fd2b264928bcdbbeffee" translate="yes" xml:space="preserve">
          <source>Draw samples from a binomial distribution.</source>
          <target state="translated">이항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3e18e00273a5fae8bbde1791f129e0cbe3bd2452" translate="yes" xml:space="preserve">
          <source>Draw samples from a chi-square distribution.</source>
          <target state="translated">카이 제곱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="7461bda090453d4ff12b83f4027e9d3a1946262b" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution with specified mean, standard deviation, and array shape. Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</source>
          <target state="translated">지정된 평균, 표준 편차 및 배열 모양을 가진 로그 정규 분포에서 표본을 추출합니다. 평균 및 표준 편차는 분포 자체의 값이 아니라 기본 정규 분포의 값입니다.</target>
        </trans-unit>
        <trans-unit id="418d59729801e30d611ad0edbc665078409b6f57" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution.</source>
          <target state="translated">로그 정규 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a1bc3727e4de5e7ab2b6eea3e4aaf62bfcf5bf0d" translate="yes" xml:space="preserve">
          <source>Draw samples from a logarithmic series distribution.</source>
          <target state="translated">로그 시리즈 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="259f9fd69d995b257a6d58ec3161de00c6ac8e73" translate="yes" xml:space="preserve">
          <source>Draw samples from a logistic distribution.</source>
          <target state="translated">로지스틱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="caeefc0caf49fe896c077769862c6d8f2a2d4d55" translate="yes" xml:space="preserve">
          <source>Draw samples from a multinomial distribution.</source>
          <target state="translated">다항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3f26805ca2b4fd1c182f06df074a9a855b5c8e20" translate="yes" xml:space="preserve">
          <source>Draw samples from a negative binomial distribution.</source>
          <target state="translated">음 이항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="6fad248b8adad205bba771cea1b6af2c597903fb" translate="yes" xml:space="preserve">
          <source>Draw samples from a noncentral chi-square distribution.</source>
          <target state="translated">비 중심 카이-제곱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9282b1d217bfacf12c8b8d4a104f2cce46e68b92" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Cauchy distribution with mode = 0.</source>
          <target state="translated">mode = 0 인 표준 Cauchy 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1bf09a114ab7401dced2153d963e20885d1b64c6" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Gamma distribution.</source>
          <target state="translated">표준 감마 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="14c3ce03d59dad5f0ba6dbc68a1db4e39a115c97" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Normal distribution (mean=0, stdev=1).</source>
          <target state="translated">표준 정규 분포에서 표본을 추출합니다 (평균 = 0, stdev = 1).</target>
        </trans-unit>
        <trans-unit id="0a5ed72650600061c64a7b3836210429f01c8df4" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Student&amp;rsquo;s t distribution with &lt;code&gt;df&lt;/code&gt; degrees of freedom.</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 자유도 를 사용하여 표준 Student 's t 분포에서 표본을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="a9791d093a2516b6b22df69cdc89a44c76c8547c" translate="yes" xml:space="preserve">
          <source>Draw samples from a uniform distribution.</source>
          <target state="translated">균일 한 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c8dcd074131ab16cf48b101b69dbb09a06467e24" translate="yes" xml:space="preserve">
          <source>Draw samples from a von Mises distribution.</source>
          <target state="translated">폰 미제스 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3f67bb2441c84f4b1162da84f12a83a78820075f" translate="yes" xml:space="preserve">
          <source>Draw samples from an F distribution.</source>
          <target state="translated">F 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b4cb12b4006c936a1a5eaa65c28e2a7372035b59" translate="yes" xml:space="preserve">
          <source>Draw samples from an exponential distribution.</source>
          <target state="translated">지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9016ff24a09fb989d28a00e24a13cde2696b4777" translate="yes" xml:space="preserve">
          <source>Draw samples from the Dirichlet distribution.</source>
          <target state="translated">Dirichlet 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a3fdcad14f303f834dc59b1f3dccb9f86e1705cd" translate="yes" xml:space="preserve">
          <source>Draw samples from the Laplace or double exponential distribution with specified location (or mean) and scale (decay).</source>
          <target state="translated">지정된 위치 (또는 평균) 및 스케일 (부패)을 사용하여 Laplace 또는 이중 지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="308c6270dd43fde905a32469d95cef01a142bca2" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution</source>
          <target state="translated">분포에서 표본 추출</target>
        </trans-unit>
        <trans-unit id="5b28ac74b7769bfdc417f7f61e050393575dc125" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution:</source>
          <target state="translated">분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="bf043e5601b2f68702eac5005c66d1ebbc6a2030" translate="yes" xml:space="preserve">
          <source>Draw samples from the geometric distribution.</source>
          <target state="translated">기하 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="570de821167a667775bfd8af3be681420e790f2f" translate="yes" xml:space="preserve">
          <source>Draw samples from the noncentral F distribution.</source>
          <target state="translated">비 중앙 F 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c575768cb70c661f622a7746787703873a7fb9c5" translate="yes" xml:space="preserve">
          <source>Draw samples from the standard exponential distribution.</source>
          <target state="translated">표준 지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dc17866b1f3b7819078bdef07b4d9d1716739b78" translate="yes" xml:space="preserve">
          <source>Draw samples from the triangular distribution over the interval &lt;code&gt;[left, right]&lt;/code&gt;.</source>
          <target state="translated">구간 &lt;code&gt;[left, right]&lt;/code&gt; 걸쳐 삼각 분포에서 표본을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="1abf94062d6b0e1580c4eed26b19473395f5dd35" translate="yes" xml:space="preserve">
          <source>Draw ten thousand values from the geometric distribution, with the probability of an individual success equal to 0.35:</source>
          <target state="translated">개별 분포 확률이 0.35 인 기하 분포에서 만 값을 구합니다.</target>
        </trans-unit>
        <trans-unit id="226c6736b8b9dc551d8a75e9fd86f951df1752ee" translate="yes" xml:space="preserve">
          <source>Draw values from a noncentral chisquare with very small noncentrality, and compare to a chisquare.</source>
          <target state="translated">비중 심성이 매우 작은 비 중앙 카이 제곱에서 값을 그리고 카이 제곱과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3329d33efc5189ab8786b87fd997f1cb2a5fa5e8" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram</source>
          <target state="translated">분포에서 값을 그리고 히스토그램을 플로팅</target>
        </trans-unit>
        <trans-unit id="2eb6c903d93ed4163d8a9ba3d7777ce26bf70cc2" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram:</source>
          <target state="translated">분포에서 값을 그리고 히스토그램을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="345d5990ad5e8dc2505201d616bdccd87cd84e5e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Fisher distribution.</source>
          <target state="translated">매개 변수화 된 Fisher 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="19d957a8e68c68660a252e592ee001bf286ee4ee" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Gumbel distribution.</source>
          <target state="translated">매개 변수화 된 Gumbel 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="3874e3e9ab062a1d7bfdc5d30325b887fbc419d7" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Laplace distribution.</source>
          <target state="translated">매개 변수화 된 Laplace 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="1cf05e207a79201534bfd254b9ef20861558f17e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Pareto distribution.</source>
          <target state="translated">매개 변수화 된 파레토 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="03c373308c04f8e25032a7f57925fc2cd89f5c43" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Poisson distribution.</source>
          <target state="translated">파라미터 화 된 포아송 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="800df344bc4e042b278de9e7bd37c782c2e5c6c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Rayleigh distribution.</source>
          <target state="translated">매개 변수화 된 Rayleigh 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="96c79cda5fd0d2766220ff50c40f50e59b603b40" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Wald distribution.</source>
          <target state="translated">매개 변수화 된 Wald 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="881edd9192611978afca45ae863cda6f17a1d7fb" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Weibull distribution.</source>
          <target state="translated">매개 변수화 된 Weibull 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="cec1a5674838f11821fe1b57bed9970f730915c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Zipf distribution.</source>
          <target state="translated">매개 변수화 된 Zipf 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="translated">매개 변수화 된 베타 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="translated">모수화 된 이항 분포에서 표본을 추출했습니다. 여기서 각 표본은 n 번의 시행에서 성공한 횟수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="translated">매개 변수화 된 카이 제곱 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="translated">모수화 된 지수 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="translated">매개 변수화 된 감마 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="translated">매개 변수화 된 기하 분포에서 추출한 표본.</target>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="translated">모수화 된 초기 하 분포에서 표본을 추출했습니다. 각 샘플은 &lt;code&gt;ngood&lt;/code&gt; good items 및 &lt;code&gt;nbad&lt;/code&gt; bad items 세트에서 가져온 &lt;code&gt;nsample&lt;/code&gt; 크기의 무작위로 선택된 하위 집합에 속하는 good items 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="translated">모수화 된 로그 정규 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="translated">매개 변수화 된 대수 시리즈 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="translated">매개 변수화 된 물류 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="translated">매개 변수화 된 음 이항 분포에서 추출 된 샘플 (각 샘플이 N과 같음), 총 n 개의 성공에 도달하기 전에 발생한 실패 수</target>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="translated">매개 변수화 된 비 중앙 Fisher 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="translated">매개 변수화 된 비 중앙 카이-제곱 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="translated">모수화 된 정규 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="translated">매개 변수화 된 배전에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="translated">매개 변수화 된 표준 스튜던트 t 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="translated">매개 변수화 된 표준 감마 분포에서 샘플을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="translated">모수화 된 삼각 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="translated">모수화 된 균일 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="translated">매개 변수화 된 폰 미제스 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="translated">채취 한 샘플.</target>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="translated">양의 지수 a-1을 갖는 전력 분포에서 [0, 1]의 샘플을 그립니다.</target>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="translated">구조화 된 배열의 Dtype입니다.</target>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조적 배열의 Dtype은 여러 형식으로 지정할 수 있지만 모든 형식은 최소한 데이터 형식과 필드 이름을 지정합니다. 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="translated">Duda, RO, Hart, PE 및 Stork, DG,&amp;ldquo;Pattern Classification&amp;rdquo;, 2nd ed., New York : Wiley, 2001.</target>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="translated">부동 소수점 반올림으로 인해 결과 배열은 에르 미트 (Hermitian)가 아니고 대각선 요소는 1이 아니고 요소는 부등식 abs (a) &amp;lt;= 1을 만족하지 않을 수 있습니다. 실수와 허수 부분은 간격 [-1로 클리핑됩니다. , 1] 그러한 상황을 개선하려는 시도에서 복잡한 경우에는 큰 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="translated">구조화 된 dtype의 해석에 한계가 있으므로 이름이 비어있는 필드가있는 dtype은 이름이 'f0', 'f1'등으로 대체됩니다. 이러한 배열은 형식을 완전히 정확하게 왕복하지 않습니다. 데이터는 손상되지 않았습니다. 필드 이름 만 다릅니다. 이 문제를 해결하기 위해 노력하고 있습니다. 이 수정은 파일 형식을 변경할 필요가 없습니다. 이러한 구조의 어레이는 여전히 저장 및 복원 될 수 있으며 &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; 메소드를 사용하여 올바른 dtype을 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="translated">배열의 피클을 지정된 파일로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="translated">배열의 피클을 지정된 파일로 덤프합니다. pickle.load 또는 numpy.load를 사용하여 배열을 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="translated">반복하는 동안 계산에 현재 요소의 색인을 사용할 수 있습니다. 예를 들어, 메모리의 순서로 배열의 요소를 방문하지만 C 순서, 포트란 순서 또는 다차원 인덱스를 사용하여 다른 배열의 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="translated">Durran DR (1999) 지구 물리학 적 유체 역학에서의 파동 방정식에 대한 수치 적 방법. 뉴욕 : 스프링거.</target>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, 106-108 페이지.</target>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, 109-110 페이지.</target>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, pp. 177-178.</target>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="translated">선택 튜플의 각 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체는 결과 선택의 크기를 한 단위 길이 차원으로 확장하는 역할을합니다. 추가 된 치수는 선택 튜플에서 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체 의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="translated">튜플의 각 배열은 &lt;code&gt;indices&lt;/code&gt; 배열 과 모양이 같습니다 .</target>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="translated">각 배열의 모양은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="translated">각 부울 배열은 &lt;code&gt;funclist&lt;/code&gt; 의 함수에 해당합니다 . 목적지 &lt;code&gt;condlist[i]&lt;/code&gt; 사실이다 &lt;code&gt;funclist[i](x)&lt;/code&gt; 의 출력값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; 의 각 부울 배열 은 &lt;code&gt;x&lt;/code&gt; 조각을 선택 하므로 &lt;code&gt;x&lt;/code&gt; 와 모양이 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="translated">각 내장 데이터 유형에는 고유하게 식별하는 문자 코드 (업데이트 된 숫자 유형 코드)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="translated">각 미분에 &lt;code&gt;scl&lt;/code&gt; 을 곱합니다 . 최종 결과는 &lt;code&gt;scl**m&lt;/code&gt; 곱하는 것 입니다. 변수의 선형 변경에 사용됩니다. (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="translated">서명의 각 차원은 모양 튜플의 끝에서 시작하여 해당 전달 배열의 차원과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="translated">서명의 각 차원은 모양 튜플의 끝에서 시작하여 해당 전달 배열의 차원과 일치합니다. 이들은 핵심 치수이며 배열에 있어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="translated">각각의 소자 &lt;code&gt;a&lt;/code&gt; 이진 - 값 출력으로 패킹 배열되어야 비트 필드를 나타낸다. 출력 배열의 모양은 1-D ( &lt;code&gt;axis&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 인 경우 )이거나 지정된 축을 따라 압축을 푼 입력 배열과 같은 모양입니다.</target>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="translated">'ipmt'및 'ppmt'배열 합계의 각 요소는 'pmt'와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="translated">각 함수는 해당 조건이 True 인 경우 &lt;code&gt;x&lt;/code&gt; 에 대해 평가 됩니다. 1d 배열을 입력으로 사용하고 1d 배열 또는 스칼라 값을 출력으로 제공해야합니다. 호출 가능 함수 대신 스칼라가 제공되면 상수 함수 ( &lt;code&gt;lambda x: scalar&lt;/code&gt; )가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="translated">각 일반화 된 ufunc에는 입력의 &quot;핵심&quot;차원이 무엇인지, 출력의 해당 차원 (요소 별 ufunc가 0의 핵심 차원을 가짐)을 나타내는 정보가 있습니다. 모든 인수의 핵심 차원 목록을 ufunc의 &quot;서명&quot;이라고합니다. 예를 들어, ufunc numpy.add에는 두 개의 스칼라 입력과 하나의 스칼라 출력을 정의하는 서명 &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="translated">각 항목은 nditer에 대한 &quot;op_axes&quot;인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="translated">첫 번째 &lt;code&gt;skip_header&lt;/code&gt; 행을 지나는 각 행 은 &lt;code&gt;delimiter&lt;/code&gt; 문자로 분할되며 &lt;code&gt;comments&lt;/code&gt; 문자 다음의 문자는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">각 산술 연산 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;divmod()&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;pow()&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) 및 비교 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) 상응하는 범용 기능 (또는 동등 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; NumPy와 짧은 경우). 자세한 내용은 섹션을 참조하십시오&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;범용 함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="translated">이 12 개의 클래스 각각은 &lt;code&gt;unittest.TestSuite&lt;/code&gt; 에 수집되어 실행됩니다. 오류와 실패가 합산되어 종료 인수로 리턴됩니다. 0이 아닌 결과는 하나 이상의 테스트가 통과되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="translated">텍스트 파일의 각 행은 같은 수의 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="translated">각 시퀀스는 정수 또는 부울 유형이어야합니다. 부울 시퀀스는 해당 차원에 대한 부울 마스크로 해석됩니다 ( &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt; 전달과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="translated">&lt;code&gt;VectorTestCase&lt;/code&gt; 클래스로 정의 된 각 테스트 는 &lt;code&gt;Vector&lt;/code&gt; 모듈의 사전 에 액세스하여 테스트하려는 Python 함수를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="translated">각 ufunc는 배열 인수의 가장 작은 부분에서 가장 기본적인 작업을 수행하는 기본 함수로 구성됩니다 (예 : 두 개의 숫자를 추가하는 것이 두 개의 배열을 추가하는 가장 기본적인 작업). ufunc는 기본 기능을 배열의 다른 부분에 여러 번 적용합니다. 기본 함수의 입력 / 출력은 벡터 일 수 있습니다. 예를 들어 inner1d의 기본 함수는 두 벡터를 입력으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="translated">각 범용 함수는 입력에 대해 요소 별 핵심 기능을 수행하여 배열 입력을 가져 와서 배열 출력을 생성합니다 (여기서 요소는 일반적으로 스칼라이지만 일반화 된 ufunc의 경우 벡터 또는 상위 차수 배열 일 수 있음). 정확히 동일한 모양을 공유하지 않는 입력을 여전히 유용하게 사용할 수 있도록 표준 브로드 캐스트 규칙이 적용됩니다. 방송은 다음 네 가지 규칙으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="translated">보다 쉬운 설정 및 분해 기능 / 방법</target>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">의 효과 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 인수의.</target>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;shrink&lt;/code&gt; 매개 변수의 영향 .</target>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="translated">효과적으로 다음을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="translated">배열을 반복하는 효율적인 다차원 반복자 객체.</target>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="translated">배열을 반복하는 효율적인 다차원 반복자 객체. 이 객체를 사용하려면 &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;배열 반복에&lt;/a&gt; 대한 소개 안내서를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="translated">오버랩 문제를 해결하기 위해 노력합니다 (최대 후보 솔루션 수 고려). 다음과 같은 특수 값이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="translated">오버랩 문제를 해결하기 위해 노력합니다. 자세한 내용은 &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;shares_memory&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;may_share_memory&lt;/code&gt; 의 기본값 은 범위 검사를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="translated">아인슈타인 요약 협약.</target>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="translated">'inv'또는 'zig'입니다. 'inv'는 기본 역 CDF 방법을 사용합니다. 'zig'는 Marsaglia와 Tsang의 훨씬 빠른 Ziggurat 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 기능에 대한 사용자 - 캐스팅 사전 함유 저수준 데이터 타입을 정의. 각 함수는 &lt;code&gt;PyCObject *&lt;/code&gt; 에 싸여 있으며 데이터 유형 번호로 키가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 배열 &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; 의&lt;/a&gt; 포인터. 이러한 포인터는 각각 &lt;code&gt;NULL&lt;/code&gt; 이거나 지정된 종류의이 데이터 유형의 스칼라를 안전하게 캐스트 할 수 있음을 나타내는 데이터 유형을 나타내는 정수 배열 ( &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 로&lt;/a&gt; 종료 됨 )에 대한 포인터 여야 합니다 (일반적으로 정밀도를 잃지 않고 의미 함).</target>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 (종료 정수 배열 &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 는&lt;/a&gt; )이 데이터 유형 (정밀도의 손실없이 일반적으로 의미 함)로 안전하게 전송할 수 있다는 데이터 타입을 표시.</target>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">어느 &lt;code&gt;None&lt;/code&gt; C 스타일 연속 배열 또는 해당 치수 다음 배열 요소로 이동하는데 필요한 바이트의 수를 제공하는 진보 터플을 표시 없음. 각 항목은 정수 여야합니다 (Python &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; ). 형상과 마찬가지로, 값은 C &quot;int&quot;또는 &quot;long&quot;으로 표현 될 수있는 것보다 클 수 있으며; 호출 코드는 오류를 발생 시키거나 C에서 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 을 사용하여이를 적절하게 처리해야합니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 C 스타일의 연속 메모리 버퍼를 의미합니다. 이 모델에서는 배열의 마지막 차원이 가장 빠르게 변합니다. 예를 들어 배열 항목의 길이가 8 바이트이고 모양이 (10,20,30) 인 객체의 기본 보폭은 튜플입니다 (4800, 240, 8).</target>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">어느 &lt;code&gt;PyUFunc_One&lt;/code&gt; , &lt;code&gt;PyUFunc_Zero&lt;/code&gt; , &lt;code&gt;PyUFunc_None&lt;/code&gt; 또는 &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; 는 이 작업에 대한 정체성을 나타냅니다. 빈 배열에서 축소 형 호출에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="translated">&lt;em&gt;typestr&lt;/em&gt; 또는 다른 목록 과 같은 기본 유형 설명 문자열 (중첩 구조화 된 유형의 경우)</target>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">데이터 유형, 데이터 유형의 튜플 또는 ufunc의 입력 및 출력 유형을 나타내는 특수 서명 문자열입니다. 이 인수를 사용하면 1-d 루프가 기본 계산에 사용할 특정 서명을 제공 할 수 있습니다. 지정된 루프가 ufunc에 대해 존재하지 않으면 TypeError가 발생합니다. 일반적으로 입력 유형을 사용 가능한 것과 비교하고 모든 입력을 안전하게 캐스트 할 수있는 데이터 유형이있는 루프를 검색하면 적합한 루프가 자동으로 발견됩니다. 이 키워드 인수를 사용하면 해당 검색을 무시하고 특정 루프를 선택할 수 있습니다. 사용 가능한 서명 목록은 ufunc 객체 의 &lt;strong&gt;types&lt;/strong&gt; 속성에 의해 제공됩니다 . 이전 버전과의 호환성을 위해이 인수를 &lt;em&gt;sig&lt;/em&gt; 로 제공 할 수도 있습니다.&lt;em&gt;&lt;/em&gt;긴 형태가 바람직하지만. 이것은 ufunc 객체 의 &lt;strong&gt;signature&lt;/strong&gt; 속성에 저장된 일반화 된 ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;서명&lt;/a&gt; 과 혼동되어서는 안됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="translated">파일 이름 (문자열) 또는 데이터가 저장 될 열린 파일 (파일과 같은 객체)입니다. 파일이 문자열 또는 경로 인 경우 파일 이름이 &lt;code&gt;.npz&lt;/code&gt; 인 경우 파일 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. k 번째 요소는 최종 정렬 위치에 있으며 모든 작은 요소는 요소와 그보다 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. k 번째 시퀀스가 ​​제공되면 모든 항목을 한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. 요소의 k 번째 값은 최종 정렬 위치에 있으며 모든 작은 요소는 요소와 그 이전의 요소와 같거나 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. k 번째 시퀀스가 ​​제공되면 k 번째로 인덱스 된 모든 요소를 ​​한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. k 번째 요소 값은 최종 정렬 된 위치에 있으며 모든 작은 요소는 그 이전의 요소와 그 이전의 모든 같거나 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. kth 시퀀스가 ​​제공되면 kth로 인덱스 된 모든 요소를 ​​한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 2의 거듭 제곱 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">소자 현명한 &lt;code&gt;x*x&lt;/code&gt; 와 동일한 형상의 DTYPE &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="translated">사분면을 올바르게 선택하는 &lt;code&gt;x1/x2&lt;/code&gt; 의 요소 별 아크 탄젠트 .</target>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 지수에서 1을 뺀 값 : &lt;code&gt;out = exp(x) - 1&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="translated">요소 별 최대 배열 요소</target>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="translated">최대 2 개의 요소 배열로 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 요소 별 최대 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="translated">원소 배열 최대 2 개의 배열은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="translated">NaN을 전파하는 요소 별 최대 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="translated">요소 별 최소 배열 요소</target>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="translated">원소 배열의 최소 배열은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 요소별로 최소 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="translated">두 배열의 요소 별 최소값으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="translated">NaN을 전파하는 요소 별 최소 두 배열.</target>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">바닥 분할로 인한 요소 별 지수. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">층 분할에서 요소 별 나머지. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="translated">초등학교 기능</target>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="translated">요소 셰이프는 브로드 캐스트없이 적절한 축을 따라 일치해야하지만 크기를 일치시키기 위해 필요에 따라 선행 1이 셰이프 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="translated">마지막 위치를 넘어서는 요소는 처음에 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">최대 값과 비교할 요소 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">최소값과 비교할 요소. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">제품에 포함 할 요소 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">합계에 포함 할 요소입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="translated">합계 할 요소</target>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="translated">요소 별 비트 연산</target>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="translated">주어진 모양과 유형의 빈 배열.</target>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="translated">기존 어레이에서 모델링 된 빈 마스크 어레이.</target>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="translated">모든 요소가 마스크 된 빈 마스크 된 배열.</target>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="translated">기존 배열의 속성을 가진 빈 마스크 배열.</target>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="translated">전체 &lt;code&gt;iterindex&lt;/code&gt; 범위 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; 의 하위 범위 반복을 지원합니다 . &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 반복 범위를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">지정된 배열 플래그를 활성화합니다. 이 함수는 유효성 검사를 수행하지 않으며 수행중인 작업을 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">axis = 키워드를 사용하고 None을 axis 인수로 사용하는 함수 및 메서드의 기능을 캡슐화합니다. 입력 배열은 &lt;code&gt;obj&lt;/code&gt; 이고 &lt;code&gt;*axis&lt;/code&gt; 는 변환 된 정수 (&amp;gt; = MAXDIMS는 None 값임)이며 &lt;code&gt;requirements&lt;/code&gt; 은 &lt;code&gt;obj&lt;/code&gt; 의 필요한 속성을 제공합니다 . 출력은 변환 된 버전의 입력이므로 요구 사항이 충족되고 필요한 경우 병합이 발생합니다. 출력에서 &lt;code&gt;*axis&lt;/code&gt; 음수 값 이 변환되고 &lt;code&gt;obj&lt;/code&gt; 모양과 일관성을 유지하기 위해 새 값이 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 입력 스트림에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 입력 스트림에는 적용되지 않습니다. 특수 값 'bytes'는 가능한 경우 결과로 바이트 배열을 수신하고 'latin1'인코딩 문자열을 변환기에 전달하는 이전 버전과의 호환성 해결 방법을 가능하게합니다. 유니 코드 배열을 수신하고 문자열을 변환기에 입력으로 전달하려면이 값을 대체하십시오. None으로 설정하면 시스템 기본값이 사용됩니다. 기본값은 '바이트'입니다.</target>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 &lt;code&gt;fname&lt;/code&gt; 이 파일 객체 인 경우에는 적용되지 않습니다 . 특수 값 'bytes'는 가능한 경우 바이트 배열을 수신하고 latin1로 인코딩 된 문자열을 변환기에 전달할 수 있도록 이전 버전과의 호환성 해결 방법을 가능하게합니다. 유니 코드 배열을 수신하고 문자열을 변환기에 입력으로 전달하려면이 값을 대체하십시오. None으로 설정하면 시스템 기본값이 사용됩니다. 기본값은 '바이트'입니다.</target>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="translated">출력 파일을 인코딩하는 데 사용되는 인코딩 출력 스트림에는 적용되지 않습니다. 인코딩이 'bytes'또는 'latin1'이외의 다른 경우 NumPy 버전 &amp;lt;1.14에서 파일을로드 할 수 없습니다. 기본값은 'latin1'입니다.</target>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">간격 끝 &lt;code&gt;step&lt;/code&gt; 가 정수가 아니고 부동 소수점 반올림이 &lt;code&gt;out&lt;/code&gt; 길이에 영향을 미치는 경우를 제외하고 간격에는이 값이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="translated">이 데이터의 엔디안 :</target>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="translated">위와 같이 배열을 확대하지만 누락 된 항목은 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="translated">입력 또는 출력이 반복 차원과 정확히 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">부호없는 32 비트 정수의 엔트로피 비트. size가 &lt;code&gt;None&lt;/code&gt; 인 경우 스칼라가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">열거 형</target>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="translated">동일 &lt;code&gt;np.prod(a.shape)&lt;/code&gt; , 즉, 배열의 차원 제품.</target>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="translated">동등한 배열 기능.</target>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="translated">동등한 배열 방법.</target>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="translated">동등한 기능</target>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="translated">ndarray에 해당하는 기능.</target>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="translated">NumPy 모듈의 해당 기능.</target>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="translated">마스크 어레이 모듈의 해당 기능</target>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 동등한 기능.</target>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 해당 기능</target>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 해당 기능.</target>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="translated">추가적인 동등한 기능 &lt;code&gt;loc&lt;/code&gt; 및 &lt;code&gt;scale&lt;/code&gt; 평균 및 표준 편차를 설정 인수.</target>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; 의&lt;/a&gt; 동등한 기능 .</target>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="translated">ndarray의 동등한 방법</target>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="translated">ndarray 객체에 해당하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="translated">1 차원 배열에서 작업 할 때 동등한 방법</target>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="translated">동등한 방법.</target>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="translated">동등한 ndarray 방법.</target>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Python &lt;code&gt;//&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 함수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt; &lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;dtype&lt;/em&gt; , &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 모든 요소가 True 인 &lt;code&gt;axis&lt;/code&gt; 으로 정의 된 모든 1 차원 하위 ​​배열 &lt;code&gt;self&lt;/code&gt; 대해 True 요소가있는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 요소가 True 인 &lt;em&gt;축&lt;/em&gt; 으로 정의 된 모든 1 차원 하위 ​​배열 &lt;em&gt;자체에&lt;/em&gt; 대해 True 요소가있는 배열을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 가장 큰 &lt;em&gt;self&lt;/em&gt; 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 가장 작은 &lt;em&gt;self&lt;/em&gt; 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택 하면 분할 된 버전의 &lt;em&gt;self&lt;/em&gt; 가 반환 되도록 인덱스 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택 하면 정렬 된 버전의 &lt;em&gt;self&lt;/em&gt; 가 반환 되도록 인덱스 배열을 반환합니다 . 경우 &lt;em&gt;자기&lt;/em&gt; -&amp;gt; DESCR 정의 필드 데이터 타입은 다음 자기&amp;gt; descr-&amp;gt; 이름이 정렬 순서를 결정하는 데 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드 등을 사용합니다. 구조화 된 배열의 정렬 순서를 변경하려면 다른 이름 순서로 새 데이터 유형을 작성하고 해당 새 데이터 유형으로 배열보기를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;inplace&lt;/em&gt; ). 데이터 영역이 바이트 랩핑 된 배열을 반환합니다. &lt;em&gt;inplace&lt;/em&gt; 가 0이 아닌 경우 , byteswap inplace를 수행하고 self에 대한 참조를 리턴하십시오. 그렇지 않으면, 바이트 랩핑 된 사본을 작성하고 자체를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;ret&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). &lt;em&gt;self&lt;/em&gt; 의 정수 값을 기반으로 &lt;em&gt;op&lt;/em&gt; 의 시퀀스에서 요소를 선택하여 새 배열을 만듭니다 . 배열은 모두 같은 모양으로 브로드 캐스트 가능 해야하며 &lt;em&gt;자체&lt;/em&gt; 항목 은 0과 len ( &lt;em&gt;op&lt;/em&gt; ) 사이 여야합니다 . 출력이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 출력은 &lt;em&gt;ret에&lt;/em&gt; 배치 &lt;em&gt;되며이&lt;/em&gt; 경우 새 출력이 작성됩니다. &lt;em&gt;clipmode의&lt;/em&gt; 인수 항목 때의 행동 결정 &lt;em&gt;자체가&lt;/em&gt; 없는 경우 0 렌 (아르 &lt;em&gt;영업 이익&lt;/em&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;min&lt;/em&gt; , &lt;em&gt;max&lt;/em&gt; ). 어레이, 클립 &lt;em&gt;자체를&lt;/em&gt; 보다 큰 값으로되도록, &lt;em&gt;최대가&lt;/em&gt; 고정되어 &lt;em&gt;최대&lt;/em&gt; 미만 값 &lt;em&gt;분&lt;/em&gt; 에 고정 &lt;em&gt;분&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;condition&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;조건&lt;/em&gt; 을 &lt;em&gt;충족&lt;/em&gt; 하는 요소에 해당하는 &lt;em&gt;축을&lt;/em&gt; 따라 요소를 반환 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;self의&lt;/em&gt; 켤레 복소수를 반환합니다 . &lt;em&gt;self&lt;/em&gt; 가 복잡한 데이터 유형이 아닌 경우 참조를 사용하여 &lt;em&gt;self&lt;/em&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;fortran&lt;/em&gt; ). &lt;em&gt;이전&lt;/em&gt; 배열을 복사하십시오 . 반환 된 배열은 항상 이전 배열과 동일하게 해석되는 데이터로 정렬되고 쓰기 가능합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 다음 C 스타일의 연속 배열이 반환됩니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , 다음 포트란 스타일의 연속 배열이 반환됩니다. &lt;em&gt;order가 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 인 경우 반환되는 배열 &lt;em&gt;은 &lt;/em&gt;이전 배열이 Fortran 스타일 인 경우에만 연속입니다. 그렇지 않으면 C 스타일이 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;code&gt;axis&lt;/code&gt; 따라 요소의 1 차원 누적 곱을 &lt;code&gt;self&lt;/code&gt; 반환 합니다. 데이터를 &lt;code&gt;rtype&lt;/code&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 소자에서의 1-D 누적 합을 반환 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; . 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; ). &lt;em&gt;axis1&lt;/em&gt; 과 &lt;em&gt;axis2로&lt;/em&gt; 정의 된 2 차원 배열 의 &lt;em&gt;오프셋&lt;/em&gt; 대각선을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). 배열의 1 차원 사본을 반환합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 요소는 포트란 순서대로 스캐닝된다 (제 1 차원은 빠른 변화). 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 요소 &lt;code&gt;self&lt;/code&gt; (최종 치수가 가장 빠른 변화) C-순서대로 스캐닝된다. 경우 &lt;em&gt;주문 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 의 다음 결과 &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자아&lt;/em&gt; )를 결정하는 데 사용되는 순서 평탄화한다.</target>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). 이 함수 &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;는 &lt;/a&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; 에대한 참조 를 훔치고 지정된 &lt;code&gt;offset&lt;/code&gt; (바이트)으로 현재 배열의 데이터를 사용하여 지정된 &lt;code&gt;dtype&lt;/code&gt; 의 새 배열을 반환 합니다. 새 배열 유형 의 &lt;code&gt;offset&lt;/code&gt; + 항목 크기는 &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 보다 작아야합니다. 그렇지 않으면 오류가 발생합니다. 원래 배열과 동일한 모양과 보폭이 사용됩니다. 따라서이 함수는 구조화 된 배열에서 필드를 반환하는 효과가 있습니다. 그러나 모든 배열 유형에서 특정 바이트 또는 바이트 그룹을 선택하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 가장 큰 &lt;em&gt;자기&lt;/em&gt; 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 열거 된 유형 &lt;em&gt;rtype&lt;/em&gt; 을 합산 할 데이터 유형으로 사용하여 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 요소의 평균을 반환합니다 . 기본 &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; 동작은 rtype에 대해 &lt;em&gt;NPY_NOTYPE을&lt;/em&gt; 사용하여 얻&lt;em&gt; 습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 가장 작은 &lt;em&gt;self&lt;/em&gt; 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 0이 아닌 &lt;em&gt;self&lt;/em&gt; 요소를 선택하는 인덱스 배열의 튜플을 반환합니다 . (nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; )) == 1이면 단일 인덱스 배열이 반환됩니다. 인덱스 배열의 데이터 유형은 &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt; 입니다. 튜플이 반환 된 경우 (nd</target>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). &lt;em&gt;ktharray&lt;/em&gt; 에 의해 색인화 된 요소의 값이 배열이 완전히 정렬되고 kth 이전의 kth보다 작은 모든 요소를 ​​배치하고 kth 요소 다음의 모든 요소를 ​​같거나 큰 경우 배열을 분할합니다. 파티션 내 모든 요소의 순서는 정의되어 있지 않습니다. 만약 &lt;em&gt;자기&lt;/em&gt;-&amp;gt; descr은 필드가 정의 된 데이터 유형이며, 정렬 순서를 결정하기 위해 self-&amp;gt; descr-&amp;gt; names가 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드 등을 사용합니다. 구조화 된 배열의 정렬 순서를 변경하려면 다른 이름 순서로 새 데이터 유형을 작성하고 해당 새 데이터 유형으로 배열보기를 구성하십시오. 성공하면 0을, 실패하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;em&gt;축을&lt;/em&gt; 따라 요소의 1 차원 제품을 &lt;em&gt;자체로&lt;/em&gt; 반환 합니다. 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 가장 큰 요소의 차이 돌아 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; 과의 가장 작은 소자 &lt;em&gt;자체&lt;/em&gt; 를 따라 &lt;em&gt;축&lt;/em&gt; . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;OP&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; 시간 요소를 복사합니다 . 어느 &lt;em&gt;연산이&lt;/em&gt; 스칼라 정수 또는 길이의 서열이다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; 치수 [- &lt;em&gt;축&lt;/em&gt; 여러 번 축을 따라 각 항목을 반복하는 방법을 나타낸다].&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">&lt;em&gt;모양&lt;/em&gt; 이 시퀀스 인 &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;shape&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;shape&lt;/em&gt; 를 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt; 구조로 변환 하고 내부적으로 &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 이전 버전과의 호환성을 위해 &amp;ndash; 권장하지 않음&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;newshape&lt;/em&gt; , refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt; , order = fortran). 이 기능은 단일 세그먼트 배열에서만 작동합니다. 그것은의 모양 변경 &lt;em&gt;자체&lt;/em&gt; 인플레 이스와의 메모리를 재 할당 할 &lt;em&gt;자가&lt;/em&gt; 있는 경우 &lt;em&gt;newshape은&lt;/em&gt; 다음 요소의 다른 총 번호 이전 형태를 갖는다. 재 할당이 필요한 경우, &lt;em&gt;자기&lt;/em&gt; 자신의 데이터를 소유해야합니다,이 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; 가지고 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; 하고, (refcheck가 0이 아닌) 다른 배열로 참조 할 수 없습니다. 포트란 인수는 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 ., &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; . 현재 효과가 없습니다. 결국 다른 차원의 배열을 만들 때 크기 조정 작업에서 데이터를 보는 방법을 결정하는 데 사용할 수 있습니다. 성공하면 없음을, 오류이면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;decimals&lt;/em&gt; , &lt;em&gt;out&lt;/em&gt; ). 가장 가까운 소수점 자리로 반올림 된 요소가있는 배열을 반환합니다. 소수점 이하 자릿수는</target>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;values&lt;/em&gt; , &lt;em&gt;side&lt;/em&gt; , &lt;em&gt;perm&lt;/em&gt; ). 가정 &lt;em&gt;자기하는&lt;/em&gt; 승순의 1 차원 배열이며, 출력은 동일한 형상 인덱스 배열을 인 &lt;em&gt;값&lt;/em&gt; 의 요소 경우 그에 따라, &lt;em&gt;값이&lt;/em&gt; 인덱스 앞에 삽입하고, 순서 &lt;em&gt;자체는&lt;/em&gt; 보존 될 수는. self가 오름차순인지 여부에 대한 점검은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;발&lt;/em&gt; , &lt;em&gt;DTYPE&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; ). 바이트 단위의 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작 하여 지정된 &lt;em&gt;dtype의 필드&lt;/em&gt; 를 &lt;em&gt;val로 설정하십시오&lt;/em&gt; . &lt;em&gt;오프셋&lt;/em&gt; 플러스 &lt;em&gt;DTYPE은&lt;/em&gt; -&amp;gt; elsize 미만이어야합니다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; descr-&amp;gt; elsize 또는 오류가 발생합니다 -. 그렇지 않으면, &lt;em&gt;val&lt;/em&gt; 인수는 배열로 변환되어 지정된 필드에 복사됩니다. 필요한 경우 &lt;em&gt;val&lt;/em&gt; 의 요소 는 대상 배열을 채우기 위해 반복되지만 대상의 요소 수는 요소의 수의 정수배 여야합니다.&lt;em&gt;val&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;자체&lt;/em&gt; 정렬 된 항목이있는 배열을 반환합니다 . 배열은 &lt;em&gt;kind&lt;/em&gt; 로 표시된 알고리즘을 사용하여 정렬되며, 사용되는 정렬 알고리즘의 유형을 가리키는 정수 / 열입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 길이 1의 모든 치수가 모양에서 제거 된 상태에서 새로운 &lt;em&gt;자기&lt;/em&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE을&lt;/em&gt; ). &lt;em&gt;축을&lt;/em&gt; 따라 데이터 유형 &lt;em&gt;rtype으로&lt;/em&gt; 변환 된 데이터를 사용하여 표준 편차를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 소자에서의 1 차원 벡터 합을 돌려 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; . 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;A1&lt;/em&gt; , &lt;em&gt;A2&lt;/em&gt; ). 반환 된 배열은 지정된 축 &lt;em&gt;a1&lt;/em&gt; 과 &lt;em&gt;a2&lt;/em&gt; 가 교체 된 &lt;em&gt;자체&lt;/em&gt; 데이터의 새로운 뷰입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;인덱스&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; 제외) &lt;em&gt;축&lt;/em&gt; = 파이썬 없음 설정함으로써 얻을 수 없다 &lt;em&gt;축&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; 를&lt;/a&gt; 자기 정수 값에 의해 표시로부터 항목을 추출 C.에서 &lt;em&gt;인덱스&lt;/em&gt; 주어진 따라 &lt;em&gt;축.&lt;/em&gt; clipmode 인수가 될 수 &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; 는&lt;/a&gt; 아웃 오브 바운드 인덱스 수행 할 작업을 나타냅니다. &lt;em&gt;RET의&lt;/em&gt; 인수보다는 내부를 생성하는 것보다 출력 배열을 지정할 수있다.</target>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). 이 배열의 바이트를 파이썬 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;self&lt;/em&gt; 에서 중첩 된 Python 목록을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). (사용 합 돌아 &lt;em&gt;RTYPE를&lt;/em&gt; 오버 합계의 데이터 형식으로) &lt;em&gt;오프셋&lt;/em&gt; 에 의해 정의되는 2 차원 어레이의 대각선 요소 &lt;em&gt;에서 축&lt;/em&gt; 과 &lt;em&gt;, 축&lt;/em&gt; 변수. 양의 오프셋은 주 대각선 위의 대각선을 선택합니다. 음수 오프셋은 주 대각선 아래의 대각선을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;permute&lt;/em&gt; ). 데이터 구조 &lt;em&gt;치환&lt;/em&gt; 에 따라 ndarray 객체 &lt;em&gt;자체&lt;/em&gt; 의 축을 &lt;em&gt;치환&lt;/em&gt; 하고 결과를 반환합니다. 경우 &lt;em&gt;변경하다가&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; , 그 결과 어레이는 반전 축을 갖는다. 예를 들어 &lt;em&gt;자기&lt;/em&gt; 모양이</target>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; ). 배열 &lt;em&gt;자체&lt;/em&gt; 의 새로운 뷰를 다른 데이터 유형, &lt;em&gt;dtype&lt;/em&gt; 및 다른 배열 서브 클래스 &lt;em&gt;ptype으로 &lt;/em&gt;&lt;em&gt;리턴하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">동등 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 이 사용 제외 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 를 매크로 공백 여부로 대체하는 경우를 결정하기 위해.</target>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">동등 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 이 사용 제외 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 를 매크로 공백 여부로 대체하는 경우를 결정하기 위해.</target>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; 및 &lt;code&gt;np.cos(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; 또는 &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;a.copy(order='K')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="translated">리턴 값이 전환 된 양의 &lt;code&gt;x&lt;/code&gt; 에 대한 &lt;code&gt;divmod(x, 1)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="translated">동등 &lt;code&gt;m[::-1,...]&lt;/code&gt; . 배열이 2 차원 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.asarray(self)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="translated">등가 &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="translated">요소 별 &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="translated">당량 &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; 또는 &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 실수 인 경우 &lt;code&gt;np.transpose(self)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="translated">상당 &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt; , 소자 현명. 경우 &lt;code&gt;x1&lt;/code&gt; 또는 &lt;code&gt;x2&lt;/code&gt; scalar_like (즉, 명확하게 주조 할 수 스칼라 타입)입니다, 그것은 다른 인수의 각 요소와 함께 사용하기 위해 방송된다. (실시 예 참조)</target>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="translated">&lt;code&gt;x.copy()&lt;/code&gt; 와 동일 하지만 산술을 지원하는 유형에 대해서만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1 - x2&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="translated">상당 &lt;em&gt;자기&lt;/em&gt; .put ( &lt;em&gt;값&lt;/em&gt; , &lt;em&gt;인덱스&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). 해당 (평평한) &lt;em&gt;지수&lt;/em&gt; 에서 &lt;em&gt;자체&lt;/em&gt; 에 &lt;em&gt;값&lt;/em&gt; 을 넣 습니다 . 경우 &lt;em&gt;값이&lt;/em&gt; 너무 작은 필요에 따라 반복됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; .ravel ( &lt;em&gt;order&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;order&lt;/em&gt; 가 0이고 &lt;em&gt;self&lt;/em&gt; 가 C 스타일 인 경우 모양이 변경되지만 복사는 수행되지 않는 것을 제외하고 &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt; &lt;code&gt;PyArray_Flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ) 과 동일한 기본 기능 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="translated">PyArray_CanCastTypeTo (fromtype, totype, NPY_SAFE_CASTING)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Python의 &lt;code&gt;%&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">파이썬의 &lt;code&gt;//&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt; 와 같지만 빠릅니다 . &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt; 를 확인하기 위해 점검이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="translated">명령 행에서 &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; 을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="translated">플랫폼에 따라 NPY_INT 또는 NPY_LONGLONG과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="translated">플랫폼에 따라 NPY_UINT 또는 NPY_ULONGLONG과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="translated">m [:, ::-1]과 같습니다. 배열이 2D 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Python &lt;code&gt;%&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mask&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="translated">마찬가지로 &lt;code&gt;MaskedArray&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="translated">마찬가지로 내부 루프를 제거하면 마지막 두 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="translated">마찬가지로 내부 루프를 제거하면 다음과 같이 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="translated">Equivalently:</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="translated">오류 객체</target>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="translated">x가 스칼라 입력일 때 첫 번째 인수와 두 번째 인수의 모양이 다르거 나 첫 번째 인수의 복소수 값이있는 경우 두 번째 인수도 제공하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="translated">x가 스칼라 입력일 때 첫 번째 인수와 두 번째 인수의 모양이 다르거 나 첫 번째 인수의 복소수 값이있는 경우 두 번째 인수도 제공하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="translated">첫 번째 인수가 스칼라 일 때 두 번째 인수가 제공되거나 첫 번째 인수와 두 번째 인수의 모양이 다른 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="translated">데이터와 가중치가 주어진 공분산 행렬을 추정합니다.</target>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="translated">공분산 행렬을 추정합니다.</target>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="translated">적분 제곱 오차의 일대일 교차 검증 유효성에 기초한 추정값입니다. Scott 규칙의 일반화로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="translated">Estimator는 가변성을 고려하지 않고 데이터 크기 만 고려합니다. 일반적으로 필요한 쓰레기통 수를 과대 평가합니다.</target>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="translated">오일러 상수, 자연 로그의 기초, 네이피어 상수.</target>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 Hermite 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2-D Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 HermiteE 계열을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 Laguerre 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="translated">포인트 (x, y)에서 2D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Hermite 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Hermite_e 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Laguerre 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="translated">포인트 x에서 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="translated">포인트 x에서 Laguerre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="translated">포인트 x에서 Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="translated">구간 별 함수를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="translated">점 x에서 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="translated">특정 값에서 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="translated">x 점에서 근에 의해 지정된 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="translated">포인트 x에서 Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="translated">포인트 x에서 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="translated">다항식 평가</target>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="translated">반복자가 모든 요소를 ​​반복하지 않는 한 TRUE를 평가하고, 그렇지 않으면 FALSE를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="translated">다중 반복자가 브로드 캐스트 된 결과의 모든 요소를 ​​반복하지 않는 한 TRUE를 평가하고, 그렇지 않으면 FALSE를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="translated">은자 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="translated">다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="translated">배열 &lt;em&gt;a1&lt;/em&gt; 과 &lt;em&gt;a2&lt;/em&gt; 의 모양이 동일한 경우 True로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="translated">참으로 평가하여하는 경우 &lt;code&gt;a&lt;/code&gt; FORTRAN 주문이다.</target>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 연속 배열 인 경우 true로 평가됩니다 . &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 할 수있는 경우 true로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 데이터 유형 객체 인 경우 true로 평가됩니다 ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="translated">의 데이터 버퍼 가 기본 바이트 순서를 사용 &lt;code&gt;a&lt;/code&gt; 경우 true로 평가됩니다 . &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="translated">피연산자에 대한 아인슈타인 요약 규칙을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="translated">중간 배열 생성을 고려하여 이인 식에 대한 최저 비용 수축 순서를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">a가 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 될 수 있다고 가정 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 의 데이터 버퍼를 가리키는 &lt;code&gt;void*&lt;/code&gt; 유형의 포인터를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">형의 배열로 평가 &lt;code&gt;npy_intp&lt;/code&gt; 및 길이 &lt;code&gt;array_numdims(a)&lt;/code&gt; 의 모든 차원의 길이주는 &lt;code&gt;a&lt;/code&gt; 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 캐스팅 될 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="translated">&lt;code&gt;npy_intp&lt;/code&gt; 유형 과 길이 &lt;code&gt;array_numdims(a)&lt;/code&gt; 의 배열로 평가하여를 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 할 수 있다고 가정 &lt;code&gt;a&lt;/code&gt; 의 모든 차원에 &lt;code&gt;a&lt;/code&gt; 보폭을 제공합니다 . 보폭은 동일한 축을 따라 요소와 바로 인접한 요소 사이의 바이트 단위 거리입니다.</target>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">평가 &lt;code&gt;i&lt;/code&gt; 의 번째 차원 크기 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 전송할 수있다 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">로 평가 &lt;code&gt;i&lt;/code&gt; 번째 보폭의 가정, &lt;code&gt;a&lt;/code&gt; 는 A를 캐스팅 할 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">의 정수 데이터 유형 코드로 평가 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 전송할 수있다 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">치수의 정수로 평가 &lt;code&gt;a&lt;/code&gt; , 가정 &lt;code&gt;a&lt;/code&gt; (A)에 캐스팅 될 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 C 스타일 연속 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 Fortran 스타일의 연속적이고 C 스타일의 연속이 &lt;em&gt;아닌&lt;/em&gt; 경우 true를 평가합니다 . &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 는 포트란 스타일 연속성을 테스트하는 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 포트란 스타일의 연속 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 type이 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형 인 Python 객체 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 유형의 Python 객체 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">만약 참으로 &lt;em&gt;연산이&lt;/em&gt; 파이썬 스칼라 오브젝트 (볼이다 &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; 를&lt;/a&gt; ) 배열 스칼라 (의 서브 타입의 인스턴스 &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) 또는 서브 타입의 인스턴스 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 차원 0이다.</target>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 내장 Python 스칼라 객체 (int, float, complex, str, unicode, long, bool) 이면 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 배열 반복자 (또는 배열 반복자 유형의 하위 클래스 인스턴스) 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 이고 크기가 0 인 경우 true를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt; 의 인스턴스 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 내장 숫자 유형 (int, float, complex, long, bool)의 인스턴스 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 Python 스칼라 객체 ( &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; 참조 )이거나 배열 스칼라 ( &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 의 하위 유형 인스턴스) 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 배열 스칼라 ( &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 의 하위 유형 인스턴스) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 차원이 0 인 PyArray_Type (의 서브 클래스) 인스턴스 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역에 쓸 수있는 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 단일 (C 스타일 또는 포트란 스타일) 연속 세그먼트로 구성된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 C 스타일의 연속, 정렬 및 기계 바이트 순서 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 C 스타일의 연속이고 &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; )가 true 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 포트란 스타일의 연속이고 &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; )가 true 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 포트란 스타일의 연속, 정렬 및 기계 바이트 순서 인 경우 true를 평가합니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서로 정렬 된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 디스크립터에 따라 기계 바이트 순서로 정렬되고 쓰기 가능한 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 기계에서 올바르게 정렬 된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">배열의 데이터 유형 설명자에 따라 ndarray &lt;em&gt;m&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서 가 &lt;strong&gt;아닌&lt;/strong&gt; 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">배열의 데이터 유형 설명자에 따라 ndarray &lt;em&gt;m&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="translated">Evaluation:</target>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">연속 배열 &lt;em&gt;의&lt;/em&gt; 경우 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 이거나 배열에 요소가없는 경우 지정된 차원 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 대한 보폭은 &lt;em&gt;임의적&lt;/em&gt; 일 수 있습니다 . 일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="translated">연속 배열 &lt;em&gt;의&lt;/em&gt; 경우 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 이거나 배열에 요소가없는 경우 지정된 차원 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 대한 보폭은 &lt;em&gt;임의적&lt;/em&gt; 일 수 있습니다 . 일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; . C API에서 배열 의 항목 &lt;code&gt;itemsize&lt;/code&gt; 에 액세스하는 올바른 방법 은 &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="translated">입력 배열이 2 차원 인 경우에도 :</target>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="translated">주어진 소수 자릿수로 고르게 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="translated">끝점을 신중하게 처리하여 균등 한 숫자.</target>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="translated">결국 &lt;code&gt;__array_function__&lt;/code&gt; 이 항상 활성화 되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="translated">SciPy 패키지 디렉토리의 모든 Python 모듈, 확장 모듈 또는 하위 패키지에는 해당 &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; 파일이 있어야 합니다. Pytest는 이러한 파일에서 테스트 방법 (test *)과 테스트 클래스 (Test *)를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="translated">모든 ufunc 계산에는 계산 설정과 관련된 약간의 오버 헤드가 포함됩니다. 이 오버 헤드의 실질적인 의미는 ufunc의 실제 계산이 매우 빠르더라도 ufunc보다 작은 배열에서 더 빨리 작동하는 배열 및 유형별 코드를 작성할 수 있다는 것입니다. 특히, ufunc를 사용하여 0-D 배열에서 많은 계산을 수행하는 것은 다른 Python 기반 솔루션보다 느릴 것입니다 (자동으로 가져온 스칼라 수학 모듈은 정확하게 배열 스칼라에 오버 헤드를 크게 줄인 ufunc 기반 계산의 모양과 느낌을주기 위해 존재합니다) ).</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="translated">예제 1 : 문자열에서 행렬 생성</target>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="translated">예제 2 : 중첩 시퀀스에서 매트릭스 생성</target>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="translated">예 3 : 배열에서 행렬 생성</target>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법을 보여주는 예 : 최소 제곱 문제 해결</target>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="translated">줄임표 사용 예 :</target>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="translated">&lt;em&gt;축&lt;/em&gt; 인수의 예</target>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="translated">scalar_like 인수의 브로드 캐스트를 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="translated">max_work를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오른쪽에서 분리하는 것을 제외하고 &lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누락 된 데이터 처리를 제외하고이 함수는 &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 자세한 내용과 예는 &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누락 된 데이터 처리를 제외하고이 함수는 &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 자세한 내용과 예는 &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">실행 &lt;code&gt;func1d(a, *args)&lt;/code&gt; &lt;code&gt;func1d&lt;/code&gt; 이 1-D 어레이에 동작하고, &lt;code&gt;a&lt;/code&gt; 의 1-D 슬라이스 인 &lt;code&gt;arr&lt;/code&gt; 따라 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="translated">출력에 사용할 기존 배열. 지정하지 않으면 a의 기본 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="translated">기존 어레이는 복사되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="translated">배열의 모양을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="translated">간격의 예상은&amp;gt; = 0이어야합니다. 예상 간격의 시퀀스는 요청 된 크기로 브로드 캐스트 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="translated">1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 를&lt;/a&gt; 예상하고 모든 값이 마스크 된 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">멋진 인덱싱없이 설명하면 다음과 같은 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 사용과 동일하며, &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="translated">가장 작은 (가장 제외) 전력 지수 &lt;code&gt;ibeta&lt;/code&gt; 1.0 첨가 즉, 1.0에서 다른 무언가를 준다</target>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="translated">1.0에서 빼는 &lt;code&gt;ibeta&lt;/code&gt; 의 가장 작은 힘의 지수는 1.0과 다른 것을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="translated">Exponentials</target>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="translated">지수와 로그</target>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="translated">Extending</target>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="translated">브로드 캐스트 및 버퍼링을보다 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; 제어 할 수있는 몇 가지 고급 옵션으로 NpyIter_MultiNew 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="translated">외부 링크:</target>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="translated">함수 호출에 사용되는 추가 인수 기본값은 추가 인수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="translated">1 차원 벡터 루프에 전달 될 추가 데이터 또는 추가 데이터가 필요하지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; . 이 C- 배열은 함수 배열 과 크기가 같아야합니다 ( &lt;em&gt;예 :&lt;/em&gt; ntype). extra_data가 필요하지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 이 사용됩니다. UFunc에 대한 여러 C-API 호출은이 추가 데이터를 사용하여 호출 할 실제 함수에 대한 포인터를받는 1 차원 벡터 루프입니다.</target>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="translated">NumPy Distutils의 추가 기능</target>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="translated">대각선을 추출하거나 대각선 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="translated">대각선을 추출하십시오 (명시 적 양식 필요).</target>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="translated">F &amp;amp; C 주문 유지, 그렇지 않으면 가장 유사한 주문</target>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="translated">F 주문</target>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="translated">입력이 C가 아닌 F이면 F 순서, 그렇지 않으면 C 순서</target>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="translated">FFT</target>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="translated">FFT (Fast Fourier Transform)는 계산 된 용어의 대칭을 사용하여 이산 푸리에 변환 (DFT)을 효율적으로 계산할 수있는 방법을 나타냅니다. &lt;code&gt;n&lt;/code&gt; 이 2의 거듭 제곱 인 경우 대칭이 가장 높 으므로 이러한 크기에 대해 변환이 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="translated">F_CONTIGUOUS / F / 포트란</target>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">C_CONTIGUOUS가 아닌 F_CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="translated">F_CONTIGUOUS 또는 C_CONTIGUOUS (1 세그먼트 테스트).</target>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="translated">행렬 &lt;code&gt;a&lt;/code&gt; 를 &lt;em&gt;qr&lt;/em&gt; 로 인수 분해 합니다 . 여기서 &lt;code&gt;q&lt;/code&gt; 는 정규직 선이고 &lt;code&gt;r&lt;/code&gt; 은 상위 삼각형입니다.</target>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">argument_class 클래스와 exception_regexp와 일치하는 메시지를 가진 예외가 인수 args 및 키워드 인수 kwargs와 함께 호출 될 때 호출 가능에 의해 발생하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">인수 args 및 키워드 인수 kwargs를 사용하여 호출 할 때 exception_class 클래스의 예외가 호출 가능에 의해 발생하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="translated">인수 args 및 키워드 인수 kwargs를 사용하여 호출 할 때 exception_class 클래스의 예외가 호출 가능에 의해 발생하지 않으면 실패합니다. 다른 유형의 예외가 발생하면 예외가 포착되지 않으며 예상치 않은 예외와 마찬가지로 테스트 사례에 오류가 발생한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="translated">주어진 콜 러블이 지정된 경고를 던지지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="translated">광신주의는 당신이 목표를 잊었을 때 당신의 노력을 배가시키는 것입니다. &amp;mdash; &lt;em&gt;조지 산타 야나&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="translated">기본 2에 대한 더 빠른 버전의 &lt;a href=&quot;#numpy.base_repr&quot;&gt; &lt;code&gt;base_repr&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="translated">필드 액세스</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">파일 확장자</target>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="translated">출력이 작성된 오브젝트와 같은 파일이며 기본값은 &lt;code&gt;stdout&lt;/code&gt; 입니다. 개체는 'w'또는 'a'모드에서 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="translated">파일 모드.</target>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="translated">읽을 파일 이름 또는 파일 객체.</target>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="translated">파일 객체.</target>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="translated">디스크의 파일은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="translated">데이터가 저장되는 파일 또는 파일 이름입니다. 파일이 파일 객체 인 경우 파일 이름은 변경되지 않습니다. 파일이 문자열 또는 경로 인 경우 파일 이름에 &lt;code&gt;.npy&lt;/code&gt; 확장자가없는 경우 파일 이름에 .npy 확장자가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">읽을 파일, 파일 이름, 목록 또는 생성기. 파일 이름 확장자가 &lt;code&gt;gz&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 인 경우 파일의 압축이 먼저 풀립니다. 생성기는 Python 3k에서 바이트 문자열을 반환해야합니다. 목록의 문자열 또는 생성기에 의해 생성 된 문자열은 라인으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="translated">읽을 파일, 파일 이름 또는 생성기 파일 이름 확장자가 &lt;code&gt;.gz&lt;/code&gt; 또는 &lt;code&gt;.bz2&lt;/code&gt; 인 경우 파일의 압축이 먼저 풀립니다. 생성기는 Python 3k에 대한 바이트 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="translated">출력을 쓸 파일과 같은 객체입니다. 생략하면 호출기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">객체 데이터 유형으로 구조의 모든 위치에서 단일 값 obj로 새로 생성 된 배열을 채 웁니다. 점검은 수행되지 않지만 &lt;em&gt;arr&lt;/em&gt; 은 데이터 유형 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; 이어야&lt;/a&gt; 하며 단일 세그먼트이고 초기화되지 않아야합니다 (이전의 오브젝트는 제 위치에 없음). 이 함수를 호출하기 전에 객체 배열의 모든 항목을 줄여야하는 경우 &lt;code&gt;PyArray_DECREF&lt;/code&gt; ( &lt;em&gt;arr&lt;/em&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; (바이트로 평가 된) 의 내용 으로 &lt;em&gt;obj가&lt;/em&gt; 가리키는 배열 (ndarray의 (하위 클래스)이어야 함)을 채 웁니다 . 이 매크로는 memset을 호출하므로 obj는 연속적이어야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="translated">배열을 스칼라 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">주어진 스칼라 객체 &lt;em&gt;obj로&lt;/em&gt; 배열 &lt;em&gt;arr을 채 웁니다&lt;/em&gt; . 객체는 먼저 데이터 유형 &lt;em&gt;arr&lt;/em&gt; 로 변환 된 후 모든 위치에 복사됩니다. 오류가 발생하면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="translated">해당 차원의 주어진 배열의 주 대각선을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="translated">값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="translated">마스크 배열 채우기</target>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="translated">누락 된 데이터 작성</target>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">충전 가치. 일관성 검사는 반드시 값의 DTYPE와 호환되는지 확인하기 위해 수행된다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="translated">충전 가치. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="translated">&lt;code&gt;nop&lt;/code&gt; 플래그를 채 웁니다 . &lt;code&gt;op[i]&lt;/code&gt; 를 읽을 수 있으면 &lt;code&gt;outreadflags[i]&lt;/code&gt; 를 1로 설정 하고, 그렇지 않으면 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="translated">&lt;code&gt;nop&lt;/code&gt; 플래그를 채 웁니다 . &lt;code&gt;op[i]&lt;/code&gt; 쓸 수 있으면 &lt;code&gt;outwriteflags[i]&lt;/code&gt; 를 1로 설정 하고, 그렇지 않으면 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="translated">테스트 스위트를 실행하는 동안 사용 중단 경고를 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="translated">컨텍스트 관리자 내에 추가 된 필터는 그대로두면 다시 삭제됩니다. 컨텍스트 외부에 정의 된 모든 필터를 입력하면 자동으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="translated">최종 출력 조작</target>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="translated">마지막으로 &lt;code&gt;Configuration&lt;/code&gt; 에는 모든 구성 데이터를 &lt;code&gt;setup(..)&lt;/code&gt; 함수 로 전달하기에 적합한 사전으로 반환하는 &lt;code&gt;.todict()&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="translated">마지막으로, 데이터 유형은 다른 데이터 유형의 항목 배열 인 항목을 설명 할 수 있습니다. 그러나 이러한 하위 배열은 크기가 고정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="translated">마지막으로 &lt;code&gt;integrate&lt;/code&gt; 모듈과 같은 SciPy의 서브 세트 만 테스트하려는 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">마지막으로, 그 강조 &lt;code&gt;v&lt;/code&gt; 의 이루어져 &lt;em&gt;오른쪽&lt;/em&gt; 의 고유 벡터 (우측에서와 같이) . 벡터 &lt;code&gt;y&lt;/code&gt; 를 만족하는 &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; 어떤 번호에 대해 &lt;code&gt;z&lt;/code&gt; 불리며 &lt;em&gt;왼쪽&lt;/em&gt; 의 고유 벡터 각각 일반적으로 행렬의 좌측 및 우측 고유 벡터는 반드시 (아마도 접합체) 아니다, 및 전치 다른. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="translated">마지막으로 특정 항목을 마스크에 일련의 부울을 할당하여 마스크 및 / 또는 마스크 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="translated">마지막으로, 루핑 메커니즘을 실행하여 입력 배열의 모든 요소가 결합되어 올바른 유형의 출력 배열을 생성하는 방법에 대한 결정이 내려집니다. 루프 실행 옵션은 단일 루프 (연속, 정렬 및 올바른 데이터 유형의 경우), strided-loop (비 연속이지만 여전히 정렬 및 올바른 데이터 유형의 경우) 및 버퍼 루프 (오정렬 또는 잘못된 데이터의 경우)입니다. 유형 상황). 어떤 실행 방법이 필요한지에 따라 루프가 설정되고 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="translated">재무 기능</target>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="translated">제공된 값으로 정의 된 다항식 또는 체비 쇼프 시리즈에 적합한 도메인을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="translated">주어진 축을 따라 마스크 배열에서 연속 된 마스크되지 않은 데이터를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="translated">정렬 된 배열에서 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="translated">정렬 된 배열에서 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="translated">순서를 유지하기 위해 v의 요소를 삽입해야하는 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">순서를 유지하기 위해 요소를 삽입해야하는 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="translated">주어진 근의 순서로 다항식의 계수를 구합니다.</target>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="translated">주어진 근의 순서로 다항식의 계수를 구합니다.</target>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">차수 &lt;code&gt;m&lt;/code&gt; 의 미분을 구합니다 .</target>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="translated">정렬 된 배열의 인덱스 찾기 의 해당 요소 경우 그에 따라, &lt;code&gt;v&lt;/code&gt; 인덱스 앞에 삽입하고, 순서 &lt;code&gt;a&lt;/code&gt; 유지 될있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="translated">0이 아닌 배열 요소의 색인을 요소별로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="translated">축을 따라 마스크되지 않은 첫 번째 값과 마지막 값의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="translated">마스크되지 않은 첫 번째 값과 마지막 값의 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="translated">두 배열의 교집합을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="translated">두 다항식의 곱을 구합니다.</target>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="translated">뿌리를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="translated">두 배열의 차 집합을 구합니다.</target>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="translated">배타적 또는 두 배열의 집합을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="translated">두 다항식의 합을 구합니다.</target>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="translated">두 배열의 합집합을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="translated">배열의 고유 한 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="translated">도움 찾기</target>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="translated">마스크 된 데이터 찾기</target>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="translated">&lt;em&gt;type1&lt;/em&gt; 과 &lt;em&gt;type2&lt;/em&gt; 가 안전하게 변환 될 수있는 가장 작은 크기와 종류의 데이터 유형을 찾습니다 . 이 기능은 대칭적이고 연관성이 있습니다. 문자열 또는 유니 코드 결과는 문자열 또는 유니 코드로 변환 된 입력 유형의 최대 값을 저장하기에 적합한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="translated">두 입력 다항식의 곱셈에 따른 다항식을 찾습니다. 각 입력은 poly1d 객체이거나 다항식 계수의 1D 시퀀스 (최고도에서 최저도) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="translated">먼저 &lt;code&gt;roll&lt;/code&gt; 규칙 에 따라 유효 날짜에 해당하는 날짜를 조정 한 다음 유효 날짜로 계산 된 지정된 날짜에 오프셋을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="translated">첫 번째 주장.</target>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="translated">첫 번째 배열</target>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="translated">첫 번째 배열 요소는 두 번째 배열에서 요소 단위로 제곱됩니다.</target>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="translated">첫 번째 축.</target>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="translated">첫 번째 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="translated">첫 번째 입력 벡터. 1 차원이 아닌 경우 입력이 전개됩니다.</target>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="translated">첫 번째 모드, &lt;code&gt;buffer&lt;/code&gt; 는 없음 :</target>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="translated">우선, 혼란 스럽거나 불확실한 경우에는 예제를 살펴보십시오. 전체적으로 일반적으로이 함수는 다음 코드 설명 (ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt; 아래)에서 볼 수있는 것보다 덜 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="translated">최초의 1 차원 입력 배열.</target>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="translated">먼저 다항식 클래스와 다항식 인스턴스가 필요합니다. 클래스는 다항식 패키지 또는 관련 유형의 모듈에서 직접 가져올 수 있습니다. 여기서 우리는 패키지에서 가져 와서 친숙 함으로 인해 기존의 다항식 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="translated">먼저 우리는</target>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="translated">Fisher, RA, AS Corbet 및 CB Williams. 동물 집단의 무작위 표본에서 종의 수와 개인의 수 사이의 관계. 동물 생태 저널, 12 : 42-58.</target>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="translated">노이즈가 많은 데이터 포인트를 통해 &lt;code&gt;y = mx + c&lt;/code&gt; 선을 맞추십시오 .</target>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">맞는 다항식 &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; 정도 &lt;code&gt;deg&lt;/code&gt; 점 &lt;code&gt;(x, y)&lt;/code&gt; . &lt;code&gt;deg&lt;/code&gt; , &lt;code&gt;deg-1&lt;/code&gt; ,&amp;hellip; &lt;code&gt;0&lt;/code&gt; 순서로 제곱 오차를 최소화하는 계수 &lt;code&gt;p&lt;/code&gt; 로 구성된 벡터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">체비 쇼프 시리즈를 사용하는 피팅은 일반적으로 파워 시리즈를 사용하는 피팅보다 더 잘 조절되지만 샘플 포인트의 분포와 데이터의 부드러움에 따라 달라질 수 있습니다. 피팅의 품질이 적절하지 않으면 스플라인이 좋은 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터를 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 할 수있을 때 Hermite 시리즈를 사용한 피팅이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Hermite 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야하며 가중치 함수는 &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 될 수있는 경우 HermiteE 계열을 사용한 적합이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 HermiteE 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야합니다 . 가중 함수는 &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 될 수있을 때 Laguerre 계열을 사용한 적합이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Laguerre 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야하며 가중치 함수는 &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Legendre 계열을 사용한 적합은 일반적으로 검정력 계열을 사용하는 적합보다 잘 조정되지만 표본 점의 분포와 데이터의 평활도에 따라 크게 달라질 수 있습니다. 피팅의 품질이 적절하지 않으면 스플라인이 좋은 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="translated">Fitting</target>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="translated">피팅은 &lt;code&gt;domain&lt;/code&gt; 및 &lt;code&gt;window&lt;/code&gt; 속성이 편의 클래스의 일부인 이유입니다 . 문제를 설명하기 위해 최대 5도까지 체비 쇼프 다항식의 값이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="translated">축의 시작에서 보폭이 수정 되었습니까? 기본값은 0입니다.&amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="translated">플래그 확인</target>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="translated">BitGenerator가 MT19937 일 때 레거시 튜플 상태를 반환 함을 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="translated">튜플 &lt;code&gt;(result, sum of weights)&lt;/code&gt; 을 출력 (True) 또는 결과 (False)로 반환 해야하는지 여부를 나타내는 플래그 입니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="translated">테스트를 더 이상 사용되지 않는 것으로 표시할지 여부를 결정하는 플래그입니다. 조건이 호출 가능한 경우 런타임에 동적으로 결정을 내리는 데 사용됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="translated">데코 레이팅 된 테스트를 알려진 실패로 표시할지 (True 인 경우) 표시하지 않을지 (False 인 경우)를 결정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="translated">데코 레이팅 된 테스트를 건너 뛸지 여부를 결정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="translated">플래그와 같은 상수</target>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 가리키는 메모리를 해석하는 방법을 나타내는 플래그. 가능한 플래그는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 전달 될 수 플래그 &lt;code&gt;flags&lt;/code&gt; 에서 설명하는 글로벌 및 당 연산 플래그의 조합입니다 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; 를 제외하고, &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="translated">전체 반복자에 적용 되는 &lt;code&gt;flags&lt;/code&gt; 로 전달 될 수있는 플래그 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;op_flags[i]&lt;/code&gt; 로 전달 될 수있는 플래그 , 여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="translated">반복자의 동작을 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="translated">플랫 이터레이터 인덱싱</target>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="translated">플랫 배열 반복자.</target>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="translated">플랫 반복</target>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="translated">배열을 반복하는 플랫 반복자 객체.</target>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="translated">이 기능의 평탄화 된 버전.</target>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="translated">배열을 가로로 뒤집습니다 (축 = 1).</target>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="translated">배열을 가로로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="translated">배열을 세로로 뒤집습니다 (축 = 0).</target>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="translated">배열을 수직으로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="translated">왼쪽 / 오른쪽 방향으로 배열을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="translated">어레이를 위 / 아래 방향으로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="translated">각 열의 항목을 위 / 아래 방향으로 뒤집습니다. 행은 유지되지만 이전과 다른 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="translated">각 행의 항목을 왼쪽 / 오른쪽 방향으로 뒤집습니다. 열은 유지되지만 이전과 다른 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="translated">입력 배열을 강제 변환하는 부동 유형 코드 &lt;code&gt;a&lt;/code&gt; . &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 'int'dtype 중 하나 인 경우 float64로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="translated">플로팅 기능</target>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="translated">부동 소수점</target>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="translated">부동 소수점 분류</target>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="translated">부동 소수점 오류 처리</target>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;beta**minexp&lt;/code&gt; (사용 가능한 가장 작은 [크기]) 부동 값.</target>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="translated">부동 소수점 정밀도를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 정밀도. 기본값은 &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="translated">부동 소수점 루틴</target>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="translated">부동 소수점 값은 정수로 강등되지 않으며 복소수 값은 부동 소수점으로 강등되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">-1과 1 사이의 부동 소수점 값 &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="translated">부동 소수 점수 &lt;code&gt;beta**machep&lt;/code&gt; (부동 소수 점수)</target>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;beta**negep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="translated">부동 소수점 숫자 :</target>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">플로트는 &lt;code&gt;[0, 1)&lt;/code&gt; 균일하게 분포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="translated">바닥은 다른 장소로 자기를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="translated">플로어 나누기 '//'는 다항식 클래스의 나누기 연산자이며, 다항식은 이와 관련하여 정수처럼 취급됩니다. Python 버전 &amp;lt;3.x의 경우 '/'연산자는 Python과 마찬가지로 '//'에 매핑됩니다. 이후 버전의 경우 '/'는 스칼라로 나누기 만 가능합니다. 언젠가는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="translated">각 적분 후에 적분 상수가 추가되기 전에 결과 에 &lt;code&gt;scl&lt;/code&gt; 이 &lt;em&gt;곱해&lt;/em&gt; 집니다 . (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="translated">헤더 다음에는 배열 데이터가옵니다. dtype에 Python 객체가 포함 된 경우 (예 : &lt;code&gt;dtype.hasobject is True&lt;/code&gt; ) 데이터는 배열의 Python 피클입니다. 그렇지 않으면 데이터는 배열 의 연속 (fortran_order에 따라 C- 또는 &lt;code&gt;fortran_order&lt;/code&gt; ) 바이트입니다. 소비자는 모양에 주어진 요소의 수 ( &lt;code&gt;shape=()&lt;/code&gt; 는 1 요소가 있음을 &lt;code&gt;dtype.itemsize&lt;/code&gt; )에 dtype.itemsize 를 곱하여 바이트 수를 알아낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="translated">21 개 유형 중 18 개에 대해이 숫자는 데이터 유형으로 고정됩니다. 융통성있는 데이터 유형의 경우이 숫자는 무엇이든 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="translated">2 차원 배열의 경우 행렬 곱입니다.</target>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="translated">2-D가 1-D와 혼합 된 경우 결과는 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="translated">8 비트 문자열의 경우이 방법은 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="translated">들면 및 &lt;code&gt;B&lt;/code&gt; 일차원,이 동등하다 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="translated">들면 &lt;code&gt;a.view(some_dtype)&lt;/code&gt; 경우 &lt;code&gt;some_dtype&lt;/code&gt; 은 (구조적 배열에 규칙적인 배열로 변환 예) 이전 DTYPE보다 엔트리 당 바이트의 다른 번호를 가지고, 그 볼의 동작은 단지 표면 외관으로부터 예측 될 수 없다 의 (도시 의해 &lt;code&gt;print(a)&lt;/code&gt; ). 또한 &lt;code&gt;a&lt;/code&gt; 가 메모리에 어떻게 저장 되는지에 달려 있습니다. 따라서 만약 &lt;code&gt;a&lt;/code&gt; 가 C- 순서 대 포트란 순서, 대 슬라이스 또는 조옮김 등으로 정의되면, 뷰는 다른 결과를 줄 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="translated">를 들어 &lt;code&gt;e, E&lt;/code&gt; 및 &lt;code&gt;f&lt;/code&gt; 지정자 자릿수 소수점 후 인쇄한다.</target>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="translated">용 &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; , 유효 숫자의 최대 수.</target>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="translated">대한 &lt;code&gt;s&lt;/code&gt; , 문자의 최대 수.</target>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">NumPy&amp;gt; = 1.10.0의 &lt;code&gt;a&lt;/code&gt; 항상 a의보기 가 리턴됩니다. NumPy와 이전의 버전의 도면 &lt;code&gt;a&lt;/code&gt; 축의 순서가 변경되고, 그렇지 않으면 입력 배열을 반환만을 반환한다.</target>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">만약 NumPy와 내용&amp;gt; = 1.10.0, &lt;code&gt;a&lt;/code&gt; ndarray 된 다음의 도면 &lt;code&gt;a&lt;/code&gt; 리턴되고; 그렇지 않으면 새 배열이 작성됩니다. NumPy와 이전의 버전의 도면 &lt;code&gt;a&lt;/code&gt; 축의 순서가 변경되고, 그렇지 않으면 입력 배열을 반환만을 반환한다.</target>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="translated">파이썬의 경우, 균질 한 데이터의 연속적 (또는 기술적으로 &lt;em&gt;스트 라이딩 된&lt;/em&gt; ) 블록 을 처리하는 선호되는 방법은 NumPy를 사용하는 것입니다. NumPy는 다차원 데이터 배열에 대한 객체 지향 액세스를 제공합니다. 따라서 &lt;code&gt;rms&lt;/code&gt; 함수에 대한 가장 논리적 인 파이썬 인터페이스 는 다음과 같습니다 (doc 문자열 포함).</target>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="translated">1 차원 배열의 경우, 조옮김 벡터는 단순히 동일한 벡터이므로 효과가 없습니다. 1 차원 배열을 2 차원 열 벡터로 변환하려면 추가 차원을 추가해야합니다. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; 는 &lt;code&gt;a[:, np.newaxis]&lt;/code&gt; 와 같이 이것을 달성합니다 . 2 차원 배열의 경우 이것은 표준 행렬 전치입니다. nD 배열의 경우 축이 제공되는 경우 순서는 축이 치환되는 방식을 나타냅니다 (예 참조). 축이 제공되지 않고 &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt; 인 경우 &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="translated">1D 배열의 경우 &lt;code&gt;a.tolist()&lt;/code&gt; 는 &lt;code&gt;list(a)&lt;/code&gt; 와 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="translated">마스크 배열의 생성 방법에 대한 자세한 내용은 &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;마스크 배열 구성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 설명은 &lt;code&gt;.npy&lt;/code&gt; 형식을 참조 &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션에 대한 자세한 설명은 &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">1D 배열을 반환하는 함수의 경우 &lt;code&gt;outarr&lt;/code&gt; 의 차원 수는 &lt;code&gt;arr&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">더 높은 차원의 배열을 반환하는 함수의 경우 해당 차원이 &lt;code&gt;axis&lt;/code&gt; 차원 대신 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="translated">다차원 배열의 경우 누적은 한 축 (기본적으로 축 0, 아래 예 참조)을 따라 적용되므로 여러 축에 누적하려면 반복적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="translated">사소한 서명의 경우 &lt;code&gt;dimensions&lt;/code&gt; 에는 두 번째 항목부터 시작하여 핵심 차원의 크기도 포함됩니다. 고유 한 각 차원 이름에 대해 하나의 크기 만 제공되며 서명에서 처음 나타나는 차원 이름에 따라 크기가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="translated">1 차원 배열의 경우 누적은 다음과 같은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="translated">단측 t- 검정의 경우 t 통계가 분포에서 얼마나 멀리 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="translated">다른 서명을 가진 가능한 미래 루프 선택기.</target>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="translated">간단한 예를 들어, 배열의 모든 요소의 합을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="translated">고급 과제의 경우 일반적으로 반복 순서를 보장하지 않습니다. 즉, 요소가 두 번 이상 설정되면 최종 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="translated">이러한 모든 매크로에서 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 여야 하지만 검사는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">자유도가 0 인 모든 NaN 슬라이스 또는 슬라이스의 경우 NaN이 반환되고 &lt;code&gt;RuntimeWarning&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">모든 NaN 슬라이스의 경우 NaN이 반환되고 &lt;code&gt;RuntimeWarning&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="translated">어레이 들어 와 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; , 지수는 대각선으로 위치 목록은 &lt;code&gt;a[i, ..., i]&lt;/code&gt; 모든 동일. 이 함수는 입력 배열을 내부에서 수정하며 값을 반환하지 않습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="translated">순위가 1보다 큰 배열의 경우 이후 축의 일부 패딩은 이전 축의 패딩에서 계산됩니다. 패딩 배열의 모서리가 첫 번째 축의 패딩 값을 사용하여 계산되는 순위 2 배열을 생각하면 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">짝수의 입력 포인트에 대해, &lt;code&gt;A[n//2]&lt;/code&gt; 는 양과 음의 나이 퀴 스트 주파수에서의 값의 합을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="translated">슬라이싱 및 축 삽입을 포함한 인덱스 조합의 경우 &lt;code&gt;a[indices]&lt;/code&gt; 는 모든 배열 &lt;code&gt;a&lt;/code&gt; 의 &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; 와 같습니다 . 그러나 &lt;code&gt;np.index_exp[indices]&lt;/code&gt; 는 Python 코드의 어느 곳에서나 사용할 수 있으며 복잡한 인덱스 표현식을 구성하는 데 사용할 수있는 슬라이스 객체 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">&lt;em&gt;축&lt;/em&gt; 키워드 를 사용하는 배열 메서드의 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. axis가 &lt;em&gt;None&lt;/em&gt; 이면 배열은 1 차원 배열로 처리됩니다. &lt;em&gt;축의&lt;/em&gt; 다른 값 은 작업이 진행되는 차원을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="translated">이전 버전과의 호환성 및 표준 &quot;컨테이너&quot;클래스로 Numeric의 UserArray가 NumPy로 가져와 이름이 &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt; &lt;code&gt;numpy.lib.user_array.container&lt;/code&gt; &lt;/a&gt; 컨테이너 클래스는 self.array 속성이 ndarray 인 Python 클래스입니다. numpy.lib.user_array.container를 사용하면 ndarray 자체보다 다중 상속이 더 쉬울 수 있으므로 기본적으로 포함됩니다. 가능한 경우 ndarray 클래스를 직접 사용하도록 권장되기 때문에 여기에 존재를 언급하는 것 이상으로 문서화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">파이썬 2와 이전 버전과의 호환성을 위해 &lt;code&gt;S&lt;/code&gt; 와 typestrings 제로 종료 바이트 남아 &lt;code&gt;np.string_&lt;/code&gt; 가 매핑 계속 &lt;code&gt;np.bytes_&lt;/code&gt; . Python 3에서 실제 문자열을 사용하려면 &lt;code&gt;U&lt;/code&gt; 또는 &lt;code&gt;np.unicode_&lt;/code&gt; 를 사용 하십시오 . 제로 종료가 필요없는 부호있는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;i1&lt;/code&gt; 을 사용할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="translated">이전 버전과의 호환성을 위해 datetime64는 여전히 표준 시간대 오프셋을 구문 분석하여 UTC로 변환하여 처리합니다. 그러나 결과 날짜 시간은 표준 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 캐시 된 가우시안 값에 대한 정보 &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt; 가 누락되었지만 양식 (str, 624 uints, int의 배열)도 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="translated">불연속 시간 신호의 대역 제한 보간의 경우 이상적인 보간 커널은 sinc 함수에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="translated">버퍼링 된 루프의 경우 루프 함수가 호출되기 전에 기본 루프가 올바른 데이터 유형 (바이트 순서 포함)의 정렬 된 데이터를 기대하기 때문에 데이터를 복사하고 캐스트하기 위해주의를 기울여야합니다. 버퍼링 된 루프는 사용자 지정 bufsize보다 크지 않은 청크에서 루프 함수를 호출하기 전에이 복사 및 캐스팅을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">명확성을 위해 유형 설명 및 해당 &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'항목의 몇 가지 예를 제공하는 것이 좋습니다 . 이 예제에 대해 Scott Gilbert에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 예외 유형 및 처리 옵션에 대한 전체 문서는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="translated">완성도를 높이기 위해 'external_loop'및 'buffered'플래그를 추가합니다.이 플래그는 일반적으로 성능상의 이유로 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="translated">복잡한 인수 &lt;code&gt;x = a + ib&lt;/code&gt; 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="translated">복소수 dtype의 경우, 위의 &lt;code&gt;x&lt;/code&gt; 의 실제 및 가상의 구성 요소 각각에 개별적으로 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; 함수는 &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt; 반환 하고, 그렇지 않으면 sign (x.imag) + 0j를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, -1]&lt;/code&gt; 및 &lt;code&gt;[1, inf]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자에서 위와 후에서 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; 는 브랜치 컷 &lt;code&gt;[-inf, 1]&lt;/code&gt; 있고 위에서부터 연속되는 복잡한 분석 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.arcsin&quot;&gt; &lt;code&gt;arcsin&lt;/code&gt; &lt;/a&gt; 은 일반적으로 브랜치 컷 [-inf, -1] 및 [1, inf]를 가지며 복소수에서 위와 아래에서 연속되는 복소수 분석 함수입니다.</target>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; 은 분기 컷으로 [ &lt;code&gt;1j, infj&lt;/code&gt; ] 및 [ &lt;code&gt;-1j, -infj&lt;/code&gt; ] 가있는 복소수 분석 함수이며 전자의 왼쪽부터 후자의 오른쪽부터 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-1, -inf]&lt;/code&gt; 및 &lt;code&gt;[1, inf]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자에서 위와 후에서 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 있고 위에서 연속 된 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; 은 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 가지며 위에서부터 연속되는 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; 은 부동 소수점 음수 0을 C99 표준에 따라 무한한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, -1]&lt;/code&gt; 있고 위에서부터 연속되는 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 가지며 위에서부터 연속되는 복잡한 분석 함수입니다 . &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[1j, infj]&lt;/code&gt; 및 &lt;code&gt;[-1j, -infj]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자의 오른쪽과 후자의 왼쪽에서 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="translated">히스토그램과 일관성을 유지하기 위해 사전 계산 된 빈 배열이 수정되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">편의성과 이전 버전과의 호환성을 위해 단일 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 인스턴스의 메서드를 numpy.random 네임 스페이스로 가져옵니다 . 전체 목록 은 &lt;a href=&quot;legacy#legacy&quot;&gt;레거시 임의 생성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="translated">항상 같은 크기 (예 : long) 인 데이터 형식의 경우 데이터 형식의 크기가 유지됩니다. 다른 배열이 다른 요소 화를 가질 수있는 유연한 데이터 유형의 경우 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="translated">하위 배열을 설명하는 데이터 형식의 경우 :</target>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="translated">사용 된 DFT 및 규칙의 정의</target>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="translated">NumPy 개발자의 경우 : 모듈 수준에서이를 인스턴스화하지 마십시오. 이러한 매개 변수의 초기 계산은 비용이 많이 들고 가져 오기 시간에 부정적인 영향을 미칩니다. 이러한 객체는 캐시되므로 함수 내에서 반복적으로 &lt;code&gt;finfo()&lt;/code&gt; 호출 하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="translated">각각의 개별 코어 차원에 대해 &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; 플래그 세트</target>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">각각의 개별 코어 치수에 대해 &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 가 0 인 경우 가능한 &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;고정&lt;/a&gt; 크기</target>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선택적 인수 &lt;code&gt;deletechars&lt;/code&gt; 에서 발생하는 모든 문자 가 제거되고 나머지 문자는 지정된 변환 표를 통해 매핑 된 문자열의 복사본을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 모든 하위 문자열 &lt;code&gt;old&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 로 대체 된 문자열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선행 및 후행 문자가 제거 된 사본을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선행 문자가 제거 된 사본을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">의 각 요소에 대해 , 라인 경계에서 파괴, 요소의 라인의 목록을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 구분 기호 문자열로 &lt;code&gt;sep&lt;/code&gt; 를 사용하여 문자열의 단어 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소 서브 스트링, 여기서 스트링에서 가장 높은 인덱스를 반환 &lt;code&gt;sub&lt;/code&gt; 발견되도록, &lt;code&gt;sub&lt;/code&gt; [내에 포함 된 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 각 요소에 대해 요소 를 &lt;code&gt;sep&lt;/code&gt; 의 첫 번째 발생으로 분할하고 구분 기호 앞 부분, 구분자 자체 및 구분 기호 뒤 부분을 포함하는 3 개의 문자열을 반환합니다. 구분 기호를 찾을 수 없으면 문자열 자체를 포함하는 3 개의 문자열과 두 개의 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">각 요소 , 마지막에 검출 소자로 분할 &lt;code&gt;sep&lt;/code&gt; 및 세퍼레이터 세퍼레이터 자체 세퍼레이터 뒷부분 전에 수용 부 (3 개) 스트링을 반환한다. 구분 기호를 찾을 수 없으면 문자열 자체를 포함하는 3 개의 문자열과 두 개의 빈 문자열을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소에 10 진수 만 있으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소에 숫자 만있는 경우 True를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선택적 인수 &lt;code&gt;deletechars&lt;/code&gt; 에서 발생하는 모든 문자 가 제거되고 나머지 문자가 제공된 변환 표를 통해 맵핑 된 문자열의 사본을 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 모든 하위 문자열 &lt;code&gt;old&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 로 대체 된 문자열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 대문자를 소문자로 변환 한 문자열의 복사본을 반환하고 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선행 및 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소 의 행 목록을 리턴하고 행 경계를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 &lt;code&gt;sep&lt;/code&gt; 를 구분 기호 문자열로 사용하여 문자열의 단어 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 제목이 지정된 문자열 버전을 반환합니다. 단어는 대문자로 시작하고 나머지 모든 대문자는 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소에 대하여 &lt;code&gt;self&lt;/code&gt; 서브 스트링, 여기서 스트링에서 가장 높은 인덱스를 반환 &lt;code&gt;sub&lt;/code&gt; 발견되도록, &lt;code&gt;sub&lt;/code&gt; [내에 포함 된 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="translated">각 요소에 대해 요소에 10 진수 만 있으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="translated">각 요소에 대해 요소에 숫자 만있는 경우 True를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소에 대해 substring &lt;code&gt;sub&lt;/code&gt; 가 있는 문자열에서 가장 낮은 인덱스를 반환하여 &lt;code&gt;sub&lt;/code&gt; 가 [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ] 범위에 포함되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="translated">각 요소에 대해 하위 문자열 &lt;code&gt;sub&lt;/code&gt; 가 있는 문자열에서 가장 낮은 인덱스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="translated">분리가 예상되는 이벤트의 경우</target>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;슬라이싱&lt;/a&gt; 은 배열의 뷰를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="translated">예를 들어 소스 디렉토리에 fun / foo.dat 및 fun / bar / car.dat가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 의 상태는 624 개의 &lt;code&gt;uint32&lt;/code&gt; 정수 로 구성 됩니다. 32 비트 정수 시드를 사용하는 순진한 방법은 상태의 마지막 요소를 32 비트 시드로 설정하고 나머지는 0으로 두는 것입니다. 이것은 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; 에&lt;/a&gt; 유효한 상태 이지만 좋은 상태는 아닙니다 . Mersenne Twister 알고리즘 &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;은 0이 너무 많으면 어려움을 겪습니다&lt;/a&gt; . 유사하게, 2 개의 인접한 32 비트 정수 시드 (즉, &lt;code&gt;12345&lt;/code&gt; 및 &lt;code&gt;12346&lt;/code&gt; )는 매우 유사한 스트림을 생성 할 것이다.</target>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="translated">예를 들어 add.accumulate ()는 np.cumsum ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="translated">예를 들어 add.reduce ()는 sum ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="translated">예를 들어, a가 32 비트 부동 소수점의 배열 인 3 * a를 계산하면 직관적으로 32 비트 부동 출력이 발생합니다. 3이 32 비트 정수인 경우 NumPy 규칙은 손실없이 32 비트 부동 소수점으로 변환 할 수 없음을 나타내므로 64 비트 부동 소수점이 결과 유형이어야합니다. 상수 '3'의 값을 살펴보면 32 비트 부동 소수점으로 손실없이 캐스팅 할 수있는 8 비트 정수에 맞는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="translated">예를 들어, 서명이 &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt; 인 ufunc를 고려하십시오 . 이 경우 &lt;code&gt;args&lt;/code&gt; 에는 입력 / 출력 배열 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 의 데이터에 대한 세 개의 포인터가 포함됩니다 . 또한 루프 의 &lt;code&gt;N&lt;/code&gt; 크기 와 코어 치수 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 의 크기 &lt;code&gt;I&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 를 정의하는 &lt;code&gt;dimensions&lt;/code&gt; 는 &lt;code&gt;[N, I, J]&lt;/code&gt; 입니다. 마지막으로, &lt;code&gt;steps&lt;/code&gt; 는 필요한 모든 보폭을 포함하는 &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">예를 들어 분기 컷이있는 &lt;code&gt;log&lt;/code&gt; 와 같은 함수의 경우이 모듈의 버전은 복잡한 평면에서 수학적으로 유효한 답을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="translated">예를 들어, 일반적인 소스 생성기 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="translated">예를 들어, &lt;code&gt;a&lt;/code&gt; 가 3x3 배열 인 경우 :</target>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="translated">예를 들어, 단일 배열을 입력으로 사용하여 반복자가 생성되고 모든 축을 재정렬 한 다음 단일 스트라이드 반복으로 축소 할 수 있으면 1 차원 배열 인 뷰가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="translated">예를 들어 (일반 Linux x64 gcc) 시스템에서 numpy &lt;code&gt;complex64&lt;/code&gt; 데이터 유형은 &lt;code&gt;struct { float real, imag; }&lt;/code&gt; . 이것은 &quot;true&quot;정렬이 4이고 &quot;uint&quot;정렬이 8입니다 ( &lt;code&gt;uint64&lt;/code&gt; 의 실제 정렬과 동일 ).</target>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="translated">예를 들어 다양한 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="translated">유한 값의 경우 isclose는 다음 방정식을 사용하여 두 부동 소수점 값이 동일한 지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 인수의 경우 결과 길이는 &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt; 입니다. 포인트 오버플 부동하므로이 규칙의 마지막 요소가 발생할 수 &lt;code&gt;out&lt;/code&gt; 보다 큰 &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="translated">부동 소수점 숫자의 경우 합계 (및 &lt;code&gt;np.add.reduce&lt;/code&gt; ) 의 숫자 정밀도는 일반적으로 각 숫자를 개별적으로 직접 추가하여 모든 단계에서 반올림 오류를 발생시킴으로써 제한됩니다. 그러나 종종 numpy는 많은 유스 케이스에서 정밀도를 향상시키기 위해 수치 적으로 더 나은 접근 방식 (부분 쌍별 합계)을 사용합니다. 이 개선 된 정밀도는 &lt;code&gt;axis&lt;/code&gt; 이 제공되지 않을 때 항상 제공됩니다 . 경우 &lt;code&gt;axis&lt;/code&gt; 주어, 그 축이 합산 된 의존 할 것이다. 기술적으로 가능한 최고 속도를 제공하기 위해 향상된 정밀도는 메모리에서 요약이 빠른 축을 따르는 경우에만 사용됩니다. 정확한 정밀도는 다른 매개 변수에 따라 달라질 수 있습니다. Python의 &lt;code&gt;math.fsum&lt;/code&gt; 인 NumPy와 달리함수는 더 느리지 만 더 정확한 합계 방법을 사용합니다. 특히 &lt;code&gt;float32&lt;/code&gt; 와 같이 많은 수의 낮은 정밀도 부동 소수점 수를 합하면 숫자 오류가 커질 수 있습니다. 이러한 경우 출력에 더 높은 정밀도를 사용 하려면 &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 &lt;em&gt;std&lt;/em&gt; 는 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 float32의 경우 결과가 정확하지 않을 수 있습니다 (아래 예 참조). &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고 정확도 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 분산은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;code&gt;float32&lt;/code&gt; 의 경우 결과가 정확하지 않을 수 있습니다 (아래 예 참조). &lt;code&gt;dtype&lt;/code&gt; 키워드를 사용하여 고 정확도 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">전체 설명서는 &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;numpy.searchsorted&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="translated">인쇄에 도움이되도록 다음 문자열은 printf 및 관련 명령에서 올바른 형식 지정자로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="translated">고차원 배열의 경우 단일 축을 줄임표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">난 속 &lt;code&gt;range(len(indices))&lt;/code&gt; , &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt; 계산해 &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt; 를 i 번째의 일반화 된 &quot;행&quot;과 평행하게되고, &lt;code&gt;axis&lt;/code&gt; 최종 결과에 (예를 들어, 2 차원 배열에서, &lt;code&gt;axis = 0&lt;/code&gt; 이면 i 번째 행이되고 &lt;code&gt;axis = 1&lt;/code&gt; 이면 i 번째 열이됩니다). 이에 대한 세 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="translated">지정된 버퍼 크기보다 작은 입력 배열의 경우 작은 배열의 경우 단일 루프가 사용되도록 복사본이 연속되지 않거나 잘못 정렬되거나 바이트 순서가 아닌 모든 배열로 만들어집니다. 그런 다음 모든 입력 배열에 대해 배열 반복자가 작성되고 결과 반복자 콜렉션이 단일 모양으로 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="translated">절대 값이 1보다 큰 정수 인수의 경우 Python이 정수 나누기를 처리하는 방식으로 인해 결과는 항상 0입니다. 정수 0의 경우 결과는 오버플로입니다.</target>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="translated">정수 입력의 경우 반환 값은 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="translated">정수 지정자 (예 : &lt;code&gt;d,i,o,x&lt;/code&gt; )의 경우 최소 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 유형의 경우 &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; 과 동일한 방식으로 정확한 동등성이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="translated">정수의 경우 채우기 값은 일반적으로 &lt;code&gt;masked_equal&lt;/code&gt; 결과와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="translated">정사각형이 아니거나 (음수의 경우) 행렬의 경우 숫자로 반전 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="translated">단조롭게 _increasing_ &lt;code&gt;bins&lt;/code&gt; 의 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="translated">보다 자세한 설명서</target>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;linalg.lstsq&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="translated">qr 인수 분해에 대한 자세한 정보는 다음을 참조하십시오 : &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 경고를 억제 할 수있는 방법, 그리고 예를 들어 &lt;a href=&quot;#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; 발행되는 참조 &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;../index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; 모듈을 참조 하고 배열의 메소드 및 속성을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="translated">음수의 경우 너비를 지정하지 않으면 빼기 부호가 앞에 추가됩니다. 너비를 지정하면 해당 너비와 관련하여 숫자의 2의 보수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="translated">정류 적이 지 않거나 연관성이없는 작업의 경우 여러 축에 대해 축소를 수행하는 것은 잘 정의되어 있지 않습니다. ufuncs는 현재이 경우 예외를 제기하지 않지만 앞으로는 그렇게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="translated">다른 키워드 전용 인수는 &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="translated">이 예에서는 제곱합 함수를 만듭니다. 시작하기 위해이 함수를 간단한 파이썬으로 구현해 봅시다. numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 함수 와 유사한 'axis'매개 변수를 지원하려고 하므로 &lt;code&gt;op_axes&lt;/code&gt; 매개 변수에 대한 목록을 구성해야합니다 . 이것이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="translated">산세.</target>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="translated">양의 정수 &lt;code&gt;n&lt;/code&gt; 에 대해 거듭 제곱 행렬 반복과 행렬 곱셈으로 검정력을 계산합니다. &lt;code&gt;n == 0&lt;/code&gt; 인 경우 M과 동일한 모양의 항등 행렬이 반환됩니다. 경우 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , 역수 계산 된 다음에 발생 &lt;code&gt;abs(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="translated">NumPy는 개인용으로 네임 스페이스 오염을 피하기 위해 NumPy include 디렉토리에 &lt;code&gt;config.h&lt;/code&gt; 를 구성합니다.이 디렉토리는 NumPy에서 내 보내지 않습니다 (즉, numpy C API를 사용하는 python 확장 프로그램은 해당 기호를 표시하지 않음).</target>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="translated">에서 무작위 샘플</target>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arcsinh&quot;&gt; &lt;code&gt;arcsinh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 반환 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; 은&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; 은&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;em&gt;arcsin은&lt;/em&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="translated">실수 입력의 경우, &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;x&lt;/code&gt; 에 대해서도 정확 하므로 부동 소수점 정확도에서 &lt;code&gt;1 + x == 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="translated">반복성과 가독성을 위해 사전 키는 알파벳 순서로 정렬됩니다. 이것은 단지 편의를위한 것입니다. 작가는 가능하다면 이것을 구현해야한다. 독자는 이것에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="translated">형태 변경, 크기 조정 및 전치의 경우, 단일 튜플 인수는 n 개의 튜플로 해석되는 &lt;code&gt;n&lt;/code&gt; 개의 정수 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="translated">스칼라 &lt;code&gt;a&lt;/code&gt; 의 경우 값을 보유 할 수있는 가장 작은 크기와 가장 작은 스칼라 종류의 데이터 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="translated">스칼라 &lt;code&gt;a&lt;/code&gt; 의 경우 값을 보유 할 수있는 가장 작은 크기와 가장 작은 스칼라 종류의 데이터 형식을 반환합니다. 스칼라가 아닌 배열 &lt;code&gt;a&lt;/code&gt; 의 경우 벡터의 dtype을 수정하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="translated">여러 메소드의 경우 선택적 &lt;em&gt;out&lt;/em&gt; 인수도 제공 할 수 있으며 결과는 제공된 출력 배열에 배치됩니다. &lt;em&gt;아웃&lt;/em&gt; 인수는해야 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 와 같은 수의 원소를 가지고있다. 캐스팅이 수행되는 다른 데이터 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">부호있는 정수 입력의 경우 2의 보수가 반환됩니다. 2의 보수 시스템에서 음수는 2의 절대 값의 보수로 표시됩니다. 이것은 컴퓨터에서 부호있는 정수를 나타내는 가장 일반적인 방법입니다 &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N 비트 2의 보수 시스템은 범위 내의 모든 정수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="translated">표준 라이브러리 기능의 경우 :</target>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="translated">구조화 된 배열의 경우 모든 필드는 마스크 된 값을 무시하고 결합됩니다. 모든 필드가 마스킹 된 경우 결과가 마스킹되며, 자체 및 다른 필드가 모두 마스킹 된 경우에만 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="translated">구조화 된 유형의 경우 구조화 된 스칼라가 리턴되며 각 필드에는 해당 유형의 기본 채우기 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="translated">서브 어레이 유형의 경우 채우기 값은 기본 스칼라 채우기 값을 포함하는 동일한 크기의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="translated">NumPy 버전에서 1.6.2까지의 키가 큰 행렬의 경우 N 열 뒤에 대각선이 &quot;줄 바꿈&quot;됩니다. 이 옵션으로이 동작을 수행 할 수 있습니다. 이것은 키가 큰 행렬에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="translated">첫 번째 실행에서는 3 번 1, 4 번 2 등을 던졌습니다. 두 번째 실행에서는 2 번 1, 4 번 2 등을 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 방법에는 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 에&lt;/a&gt; 해당하는 함수가 있습니다 . &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt; &lt;code&gt;argmax&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt; &lt;code&gt;argmin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt; &lt;code&gt;choose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt; &lt;code&gt;diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt; &lt;code&gt;imag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt; &lt;code&gt;partition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt; &lt;code&gt;squeeze&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;swapaxes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="translated">일반적인 경우 반복 작업은 반복자 객체의 좌표 카운터 목록을 추적하여 작동합니다. 반복 할 때마다 마지막 좌표 카운터가 증가합니다 (0부터 시작). 이 카운터가 해당 차원의 배열 크기 (사전 계산 및 저장된 값)보다 1보다 작 으면 카운터가 증가하고 해당 차원의 보폭에 의해 dataptr 멤버가 증가하고 매크로가 종료됩니다. 차원의 끝에 도달하면 마지막 차원의 카운터가 0으로 재설정되고 해당 차원의 요소 수보다 보폭 값을 1만큼 뺀 값으로 dataptr이 해당 차원의 시작으로 다시 이동합니다. 또한 미리 계산되어 반복자 객체의 백스트리트 멤버에 저장됩니다). 이 경우 매크로는 끝나지 않습니다.그러나 로컬 차원 카운터는 마지막 차원이 마지막 차원의 역할을 대체하고 이전에 설명 된 테스트가 다음 차원에서 다시 실행되도록 로컬 차원 카운터가 감소됩니다. 이러한 방식으로, dataptr은 임의의 보폭에 적합하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="translated">대부분의 경우, 디스패치에 대한 규칙 &lt;code&gt;__array_function__&lt;/code&gt; 을 위한 그 일치 &lt;code&gt;__array_ufunc__&lt;/code&gt; 을 . 특히:</target>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">typenum 매크로의 경우 인수는 열거 된 배열 데이터 유형을 나타내는 정수입니다. 매크로를 확인 배열 유형의 인수가 있어야합니다 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 직접으로 해석 될 수 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="translated">이러한 이유로 가능한 경우 &lt;code&gt;as_strided&lt;/code&gt; 를 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="translated">이러한 이유로 NumPy는 &amp;lt;numpy / halffloat.h&amp;gt;를 포함하고 'npymath'에 연결하여 액세스 가능한 npy_half 값으로 작업 할 수있는 API를 제공합니다. 산술 연산과 같이 직접 제공되지 않은 함수의 경우 선호되는 방법은 다음 예와 같이 부동 또는 이중으로 변환 한 후 다시 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="translated">이 함수가 ndarray의 하위 클래스에서 작동 하려면 kwarg &lt;code&gt;keepdims&lt;/code&gt; 로&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이러한 이유로, 다음 &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt; &lt;code&gt;apply_along_axis&lt;/code&gt; &lt;/a&gt; 사용과 동일하지만 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="translated">이 샘플 배열의 경우</target>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="translated">2 차원 배열의 경우 반환되는 축은 2 개의 배열입니다. 이 예제에서 첫 번째 배열은 행의 그라데이션을 나타내고 두 번째 배열은 열 방향의 그라데이션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="translated">파이썬 함수에서 동적으로 생성 된 ufunc의 경우이 멤버는 기본 파이썬 함수에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ufunc의 경우 __array_ufunc__ 대신이 메소드를 더 이상 사용하지 않기를 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="translated">산 세척 용.</target>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="translated">부호없는 정수 배열의 경우 결과도 부호가 없습니다. 결과가 직접 차이를 계산하는 것과 일치하기 때문에 이것은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">RandomState 인스턴스에서 사용하는 비트 생성기의 내부 상태를 수동으로 (재설정) 할 이유가있는 경우에 사용합니다. 기본적으로 RandomState는 &quot;Mersenne Twister&quot; &lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 의사 난수 생성 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 경우이 플래그는 출력에 배열 하위 유형 할당을 비활성화하여 직선 ndarray가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 과 함께 사용</target>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="translated">반올림 된 십진수 값의 중간에있는 값의 경우 NumPy는 가장 가까운 짝수 값으로 반올림합니다. 따라서 1.5 및 2.5는 2.0으로 반올림하고, -0.5 및 0.5는 0.0으로 반올림합니다. IEEE 부동 소수점 표준 &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 에서 소수점 이하 자릿수의 부정확 한 표현 및 10의 거듭 제곱으로 스케일링 할 때 발생하는 오류 로 인해 결과가 놀랍 습니다.</target>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">&lt;code&gt;ord &amp;lt;= 0&lt;/code&gt; 값의 경우 결과는 엄밀히 말하면 수학적인 '노름'이 아니지만 다양한 수치 목적에 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="translated">벡터 (1 차원 배열)의 경우 일반 내부 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="translated">벡터를 들어 &lt;code&gt;x1&lt;/code&gt; , &lt;code&gt;x2&lt;/code&gt; , ..., &quot;XN&quot;와 길이 &lt;code&gt;Ni=len(xi)&lt;/code&gt; , 창 &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; 모양의 배열 인덱스 = 'IJ'또는 경우 &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; 형 배열의 요소 인덱스 = &quot;XY&quot;경우 &lt;code&gt;xi&lt;/code&gt; 위한 제 차원에 따른 행렬 채우기 위해 반복 &lt;code&gt;x1&lt;/code&gt; 위한 제 &lt;code&gt;x2&lt;/code&gt; 등이있다.</target>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="translated">안전하게 수행 할 수없는 경우에도 출력 유형으로 캐스트를 수행하십시오. 이 플래그가 없으면 데이터 캐스트는 안전하게 수행 할 수있는 경우에만 발생하며, 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="translated">마스크를 세게 누릅니다.</target>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="translated">마스크를 부드럽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="translated">형식 버전 1.0</target>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="translated">형식 버전 2.0</target>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="translated">형식 버전 3.0</target>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="translated">부동 소수점 스칼라를 위치 표기법으로 10 진수 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="translated">과학적 표기법으로 부동 소수점 스칼라를 10 진수 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="translated">텍스트 파일 출력을위한 형식 문자열입니다. 배열의 각 항목은 먼저 가장 가까운 Python 유형으로 변환 한 다음 &quot;format&quot;% 항목을 사용하여 텍스트로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Fornberg B. (1988) 임의로 이격 된 격자에서 유한 차 분식의 생성, 계산의 수학 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="translated">포트란 파일</target>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="translated">모든 입력이 포트란이면 포트란 순서, 그렇지 않으면 C</target>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="translated">포트란 주문.</target>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="translated">디코딩을 시도하지 않고 서브 프로세스 호출에서 콘솔로 바이트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="translated">네 가지 출력 값은 유효하지 않습니다. 첫 번째 값은 음수의 제곱근을 취하고 두 번째 값은 0으로 나눈 값과 입력이 마스크 된 마지막 두 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="translated">푸리에 분석은 기본적으로 함수를 주기적 구성 요소의 합으로 표현하고 해당 구성 요소에서 기능을 복구하는 방법입니다. 함수와 푸리에 변환이 모두 이산화 된 대응으로 대체 될 때,이를 DFT (Discrete Fourier Transform)라고합니다. DFT는 FFT (Fast Fourier Transform)라고 불리는 매우 빠른 컴퓨팅 알고리즘 덕분에 수치 컴퓨팅의 주류가되었으며, 이는 Gauss (1805)에게 알려졌으며 Cooley와 터키 &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt; . Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; 은 푸리에 분석 및 응용에 대한 접근성있는 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">제공된 유형 맵에 포함되지 않은 사례를 처리하는 특수 유형 맵, 확장 또는 인라인 된 함수를 작성하는 데 사용할 수있는 14 개의 C 매크로 및 15 개의 C 함수 매크로 및 함수는 버전 1.6 이후 API의 일부 측면이 더 이상 사용되지 않기 전후에 NumPy 버전 번호에 관계없이 NumPy C / API와 함께 작동하도록 특별히 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 분수 부분 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Sourceforge 프로젝트의 파레토 배포에 관한 Francis Hunt와 Paul Johnson.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">주어진 FFT 매개 변수에 대한 주파수 구간.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">프로 베니 우스 표준</target>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">4x3 배열에서 고급 인덱싱을 사용하여 모서리 요소를 선택해야합니다. 따라서 열이 &lt;code&gt;[0, 2]&lt;/code&gt; 중 하나이고 행이 &lt;code&gt;[0, 3]&lt;/code&gt; 중 하나 인 모든 요소를 선택해야합니다. 고급 인덱싱을 사용하려면 모든 요소를 &lt;em&gt;명시 적으로&lt;/em&gt; 선택해야합니다 . 앞에서 설명한 방법을 사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">날짜와 시간에서 :</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">배열에서 합계가 2보다 작거나 같은 모든 행을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">각 행에서 특정 요소를 선택해야합니다. 행 인덱스는 단지 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 이며 열 인덱스는 해당 행에 대해 선택할 요소를 지정합니다 (여기서는 &lt;code&gt;[0, 1, 0]&lt;/code&gt; . 두 가지를 함께 사용하면 고급 인덱싱을 사용하여 작업을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">기존 데이터에서</target>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">다른 물체에서</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">기스로부터</target>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">완전 간접 정렬</target>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">완전한 종류.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">전체 정렬</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">전체 기능에 특정 억제를 적용하는 함수 데코레이터.</target>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">ndarray에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 의&lt;/a&gt; 함수 포인터</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">float 배열을 float로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다. 이것은 현재 구현에 유용한 것으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float 또는 float 배열을 정수 또는 정수 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">단일 float를 문자열로 변환하는 함수입니다. 기본값은 &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 또는 정수 배열을 부동 또는 부동 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">배열을 예쁘게 인쇄하는 데 사용되는 기능입니다. 함수는 단일 배열 인수를 예상하고 배열 표현의 문자열을 리턴해야합니다. None 인 경우, 기능은 기본 NumPy 기능으로 재설정되어 배열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">부동 소수점 오류 ( 'call'-mode) 또는'write '메소드가 이러한 메시지를 기록하는 데 사용되는 객체 ('log'-mode)에 대해 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">ufunc에 대한 마스크 된 내부 루프를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">기능적 프로그래밍</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">반복 함수</target>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">내부 기능을 구현하는 기능. 이 함수 포인터를 모두 주어진 유형에 대해 정의해야하는 것은 아닙니다. 필수 멤버는 &lt;code&gt;nonzero&lt;/code&gt; 이 아닌 , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; 및 &lt;code&gt;cast&lt;/code&gt; 입니다. 이들은 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 것으로 가정 되며 &lt;code&gt;NULL&lt;/code&gt; 항목은 프로그램 충돌을 일으 킵니다. 다른 함수는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있으며, 이는 해당 데이터 유형의 기능이 축소되었음을 의미합니다. 또한 사용자 정의 데이터 유형을 등록 할 때 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 0이 아닌 함수는 기본 함수로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">축을 따라 인덱스를 반환하는 함수 &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt;함수는이 함수에 적합한 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">numpy 네임 스페이스에 있고 함수를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">에 대한 추가 설명 &lt;code&gt;fmt&lt;/code&gt; 매개 변수에 ( &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">또한 어떻게 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 결합 .</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">또한이 함수로 생성 된 어레이에는 종종 자체 중복 메모리가 포함되므로 두 요소가 동일합니다. 이러한 어레이에서 벡터화 된 쓰기 작업은 일반적으로 예측할 수 없습니다. 작은 배열, 큰 배열 또는 바뀐 배열에 대해 다른 결과를 제공 할 수도 있습니다. 이러한 어레이에 대한 쓰기는 매우주의해서 테스트하고 수행해야하므로 우발적 인 쓰기 작업을 피하기 위해 &lt;code&gt;writeable=False&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">또한 콜백 함수는 이전과 동일한 유형, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; 입니다. &lt;code&gt;args&lt;/code&gt; 는 호출 될 때 모든 입력 / 출력 인수의 데이터를 포함하는 길이 &lt;code&gt;nargs&lt;/code&gt; 의 목록입니다 . 스칼라 기본 함수의 경우 &lt;code&gt;steps&lt;/code&gt; 길이가 &lt;code&gt;nargs&lt;/code&gt; 는 인수에 사용 된 보폭을 나타내는 입니다. &lt;code&gt;dimensions&lt;/code&gt; 는 루프 될 축의 크기를 정의하는 단일 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">미래 가치</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">미래 가치 (기본 = 0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">미래 가치. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한 미래 값을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">GH Golub 및 CF Van Loan, &lt;em&gt;매트릭스 계산&lt;/em&gt; , Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">G. Strang,&amp;ldquo;선형 대수와 그 응용, 2 판&amp;rdquo;Academic Press, pg. 182, 1980.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 다양한 pp.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 139-142 쪽.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , Orlando, FL, Academic Press, Inc., 1980, pg. 285.</target>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">가우스 체비 쇼프 구적법.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">가우스-허 마이트 구적법.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Gauss-HermiteE 구적법.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">가우스-라게 레 구적법.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">Gauss-Legendre 직교.</target>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">파이썬 타입의 일반적인 점검</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">파이썬의 예외에서 파생 된 범용 예외 클래스. 예외 클래스는 선형 대수 관련 조건이 함수의 올바른 실행을 방해 할 때 linalg 함수에서 프로그래밍 방식으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 두 번째 마지막 차원을 사용하는 일반화 된 행렬 곱 .</target>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">일반화 된 범용 함수 API</target>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">일반화 된 함수 클래스.</target>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">일반화 된 ufunc는 많은 linalg 함수와 테스트 스위트에서 내부적으로 사용됩니다. 아래의 예는 이들에서 가져온 것입니다. 스칼라에서 작동하는 ufunc의 경우 서명은 &lt;code&gt;None&lt;/code&gt; 이며 모든 인수에 대해 '()'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">벡터화 된 행렬-벡터 곱셈을위한 일반화 된 범용 함수 서명, 예를 들어 &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; . 제공되는 경우 &lt;code&gt;pyfunc&lt;/code&gt; 는 해당 코어 크기의 크기로 주어진 모양을 가진 배열로 호출됩니다 (그리고 반환 될 것으로 예상됩니다). 기본적으로 &lt;code&gt;pyfunc&lt;/code&gt; 는 스칼라를 입력 및 출력으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">일반적으로 파일은 빌드시에만 알려진 일부 정보 (예 : 접두사)가 필요하므로 빌드 중에 생성해야합니다. &lt;code&gt;Configuration&lt;/code&gt; 방법 &lt;code&gt;add_npy_pkg_config&lt;/code&gt; 를 사용하는 경우 대부분 자동 입니다. 다음과 같이 템플릿 파일 foo.ini.in이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">3 개의 다른 하한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">3 가지 상한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">dtype이 uint8 인 브로드 캐스팅을 사용하여 2 x 4 배열 생성</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">다음을 포함하여 0에서 4 사이의 정수로 2 x 4 배열을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 체비 쇼프 시리즈를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 은자 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 HermiteE 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Laguerre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Legendre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Vandermonde 매트릭스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">주어진 근을 가진 음의 다항식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">템플릿에서 npy-pkg 구성 파일을 생성하고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보가 포함 된 config.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보를 포함하는 패키지 __config__.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">SVN 개정 번호에서 __svn_version__.py 패키지 패키지를 생성하십시오. 파이썬이 종료되면 제거되지만 sdist 등 명령이 실행될 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">주어진 1 차원 배열에서 무작위 표본을 생성합니다</target>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">인덱스 배열 생성</target>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">생성기 : BitGenerator의 임의 비트 시퀀스를 지정된 간격 내에서 특정 확률 분포 (예 : 균일, 정규 또는 이항)를 따르는 숫자 시퀀스로 변환하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">linalg 함수에 의해 생성 된 일반 파이썬 예외 파생 객체.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">itemptr이 가리키는 위치에서 ndarray &lt;em&gt;arr&lt;/em&gt; 에서 내장 유형의 Python 객체를 가져옵니다. 실패 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">반복자의 사본을 1 차원 배열로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">반복자의 사본을 현재 상태로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 로컬 변수에 대한 포인터가 전달되어 상태를 설정하는 코드와 관련하여 공격적인 컴파일러 최적화에서이 함수 호출을 다시 지정하지 못하게되어 잘못된 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 다음과 같은 플래그로 비트 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">함수, 클래스 또는 모듈에 대한 도움말 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">날짜 또는 시간 유형의 단계 크기에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">PRNG 상태 가져 오기 또는 설정</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오. 구조화 된 배열의 경우 &lt;strong&gt;모든&lt;/strong&gt; 필드가 마스크 된 경우 항목이 &lt;code&gt;True&lt;/code&gt; 인 부울의 ndarray를 반환하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">자원 정보를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">이름 조회가 무시되는 경우 기본값이 설정되지 않은 경우 스레드 로컬 저장 영역에서 ufunc 처리에 사용되는 Python 값을 가져옵니다. 이름은 &lt;em&gt;* errobj&lt;/em&gt; 의 첫 번째 요소에 문자열로 배치됩니다 . 두 번째 요소는 오류 콜백을 호출하는 조회 기능입니다. 조회 할 버퍼 크기 의 값은 &lt;em&gt;bufsize&lt;/em&gt; 로 전달되고 오류 마스크의 값은 &lt;em&gt;errmask에&lt;/em&gt; 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">부동 소수점 오류를 처리하는 현재 방법을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">배열의 차원 수를 구합니다</target>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Getitem / setitem / copyswap 함수 : ufuncs와 유사하게이 함수에는 일반적으로 두 개의 코드 경로가 있습니다. 경우 &lt;code&gt;ALIGNED&lt;/code&gt; 거짓입니다 그들은 진정한 정렬 그래서 인수를 버퍼링 코드 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">고정되거나 전체 반복 중에 변경되지 않는 보폭 배열을 가져옵니다. 변경 가능한 보폭의 경우 NPY_MAX_INTP 값이 보폭에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">가져 &lt;code&gt;iterindex&lt;/code&gt; 반복기의 반복 순서와 일치하는 인덱스 반복기의이.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">반복되는 &lt;code&gt;iterindex&lt;/code&gt; 하위 범위를 가져옵니다 . 경우 &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; 가&lt;/a&gt; 지정되지 않았습니다이 항상 범위를 반환 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">반복 인덱스 0에 해당하는 데이터 포인터의 배열을 버퍼로 절대 배열에 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">지정된 축에 대한 보폭 배열을 가져옵니다. 반복자가 다중 색인을 추적하고 버퍼링을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">생성기에서 사용하는 비트 생성기 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">소스에서 추가 포트란 77 컴파일러 옵션 얻기</target>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">다항식 0의 시퀀스가 ​​주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">같은 모양 의 배열 ( &lt;em&gt;sort_keys&lt;/em&gt; ) 시퀀스가 주어지면 배열을 사전 식으로 정렬하는 인덱스 배열 ( &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 과 유사)을 반환 하십시오. 사전 식 정렬은 두 개의 키가 동일 할 때 순서가 후속 키의 비교를 기반으로 함을 지정합니다. 유형에 대해 병합 항목 (동일한 항목을 그대로 유지)을 정의해야합니다. 정렬 먼저 인덱스 선별 제를 사용하여 달성된다 &lt;em&gt;sort_key을&lt;/em&gt; 다음 두 번째 사용 &lt;em&gt;sort_key를&lt;/em&gt; 등등과. 이것은 lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) Python 명령과 동일합니다. 병합 정렬이 작동하는 방식 때문에 &lt;em&gt;sort_keys&lt;/em&gt; 의 순서를 이해해야합니다.&lt;em&gt;&lt;/em&gt; 에 있어야합니다 (두 요소를 비교할 때 사용하는 순서와 반대로).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">일련의 조건과 해당 기능이 주어지면 입력 데이터의 각 기능이 조건에 맞는지 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">예컨대 형상, 주어진 &lt;code&gt;(m,n,k)&lt;/code&gt; , &lt;code&gt;m*n*k&lt;/code&gt; 샘플을 생성 및 포장 &lt;code&gt;m&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; -by- &lt;code&gt;k&lt;/code&gt; 배열. 각 표본은 &lt;code&gt;N&lt;/code&gt; 차원이므로 출력 모양은 &lt;code&gt;(m,n,k,N)&lt;/code&gt; 입니다. 모양을 지정하지 않으면 단일 ( &lt;code&gt;N&lt;/code&gt; -D) 샘플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">정사각형 배열 객체가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;a&lt;/code&gt; 가 주어지면 &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; 만족 하는 행렬 &lt;code&gt;ainv&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 &lt;code&gt;q&lt;/code&gt; 번째 백분위 수의 &lt;code&gt;V&lt;/code&gt; 되는 값 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 의 정렬 된 사본 &lt;code&gt;V&lt;/code&gt; 의 &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; 의 중간 값이며 &lt;code&gt;N&lt;/code&gt; 이 홀수 일 때 &lt;code&gt;N&lt;/code&gt; 이 짝수 일 때 &lt;code&gt;V_sorted&lt;/code&gt; 의 두 중간 값 .</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이의 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , 경우 &lt;code&gt;N&lt;/code&gt; 이 홀수 개의 중간 값의 평균이며 의 &lt;code&gt;V_sorted&lt;/code&gt; 때 &lt;code&gt;N&lt;/code&gt; 은 짝수이다.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 백분위 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 분위수 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법은 &lt;code&gt;V&lt;/code&gt; 는 . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않는 경우 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 뿐만 아니라 가장 가까운 두 이웃의 값과 거리가 Quantile을 결정합니다 . 이 함수는 &lt;code&gt;q=0.5&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0.0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=1.0&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 와 &lt;code&gt;N&lt;/code&gt; 의 값을 마스크 비의 평균 &lt;code&gt;V&lt;/code&gt; 는 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; 즉 -) &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 이 홀수 또는 &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; &lt;code&gt;N&lt;/code&gt; 이 짝수 인 경우 / 2-1] + Vs [N / 2]} / 2</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">창 길이 &lt;code&gt;n&lt;/code&gt; 과 샘플 간격 &lt;code&gt;d&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">정수 의 &quot;인덱스&quot;어레이 ( &lt;code&gt;a&lt;/code&gt; ) 및 &lt;code&gt;n&lt;/code&gt; 개의 어레이 ( &lt;code&gt;choices&lt;/code&gt; ) 의 시퀀스가 주어지면 , &lt;code&gt;a&lt;/code&gt; 및 각 선택 어레이는 필요에 따라 공통 형상의 어레이로 먼저 브로드 캐스트된다; 이것을 호출&lt;em&gt; Ba&lt;/em&gt; 와 &lt;em&gt;Bchoices [i], i = 0,&amp;hellip;, n-1&lt;/em&gt; 이라고 &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; 반드시 각 &lt;code&gt;i&lt;/code&gt; 에 대해 Ba.shape == Bchoices [i] .shape 가됩니다 . 그런 다음 모양이 &lt;code&gt;Ba.shape&lt;/code&gt; 인 새 배열이 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">정수 배열과 n 개의 선택 배열 집합이 주어지면이 메소드는 각 선택 배열을 병합하는 새 배열을 만듭니다. 의 값 여기서 &lt;code&gt;a&lt;/code&gt; I 인 새로운 배열을 선택 [I]이 동일 위치에 포함 된 값을 가질 것이다.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">간격이 주어지면 간격 밖의 값이 간격 가장자리에 잘립니다. 예를 들어, 간격 &lt;code&gt;[0, 1]&lt;/code&gt; 을 지정하면 0보다 작은 값은 0이되고 1보다 큰 값은 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">스프레드 시트에서 열로 해석 될 수있는 여러 정렬 키가 제공되면 lexsort는 여러 열의 정렬 순서를 설명하는 정수 인덱스 배열을 반환합니다. 시퀀스의 마지막 키는 기본 정렬 순서에 사용되며, 두 번째에서 마지막 키는 보조 정렬 순서에 사용됩니다. keys 인수는 동일한 모양의 배열로 변환 될 수있는 일련의 객체 여야합니다. keys 인수에 2D 배열이 제공되는 경우 행은 정렬 키로 해석되며 정렬은 마지막 행, 두 번째 마지막 행 등에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">직각 삼각형의&amp;ldquo;다리&amp;rdquo;가 주어지면 빗변을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">배열의 모양이 &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 인스턴스의 N 차원 인덱스를 반복합니다. 각 반복에서 튜플 인덱스가 반환되고 마지막 차원이 먼저 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">두 개의 &lt;em&gt;n&lt;/em&gt; 길이의 정수 배열이 주어지면 &lt;em&gt;l1&lt;/em&gt; 및 &lt;em&gt;L2&lt;/em&gt; , 복귀 한리스트가 동일한 경우; 그렇지 않으면 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 첫 번째 객체의 모든 요소가 두 번째 객체의 요소보다 엄격하게 작은 지 확인하십시오. 모양이 일치하지 않거나 잘못 정렬 된 값에서 예외가 발생합니다. 개체의 치수가 0이면 모양 불일치가 발생하지 않습니다. Numpy의 표준 사용법과 달리 NaN은 비교되며 두 개체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 이러한 객체의 모든 요소가 동일한 지 확인하십시오. 모양 불일치 또는 충돌하는 값에서 예외가 발생합니다. Numpy의 표준 사용법과 달리 NaN은 숫자처럼 비교되며 두 객체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">두 개의 숫자가 주어지면 대략 같은지 확인하십시오. 대략적인 숫자는 동의하는 유효 자릿수로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">두 개의 객체 (스칼라,리스트, 튜플, 사전 또는 numpy 배열)가 주어지면이 객체의 모든 요소가 동일한 지 확인하십시오. 첫 번째 충돌 값에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">두 개의 다항식 &lt;code&gt;a1&lt;/code&gt; 과 &lt;code&gt;a2&lt;/code&gt; 가 주어지면 &lt;code&gt;a1 - a2&lt;/code&gt; 반환합니다 . &lt;code&gt;a1&lt;/code&gt; 및 &lt;code&gt;a2&lt;/code&gt; 는 다항식 계수 (0과 같은 계수 포함)의 array_like 시퀀스이거나 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">두 텐서 주어진 및 &lt;code&gt;b&lt;/code&gt; , 및 물체 array_like 두 함유 array_like 오브젝트 &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; ,의 제품 합계 'S 및 &lt;code&gt;b&lt;/code&gt; 로 지정된 축상에서의 구성 요소 (부품) &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; . 세 번째 인수는 음이 아닌 단일 integer_like 스칼라 &lt;code&gt;N&lt;/code&gt; 일 수 있습니다 . 그러한 경우, &lt;code&gt;a&lt;/code&gt; 의 마지막 &lt;code&gt;N&lt;/code&gt; 치수 와 &lt;code&gt;b&lt;/code&gt; 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 치수 가 합산됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Glantz, Stanton A.&amp;ldquo;생체 통계학 전문가&amp;rdquo;, McGraw-Hill, 5 판, 2002.</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">그라디언트는 주어진 축을 따라서 만 계산됩니다. 기본값 (축 = 없음)은 입력 배열의 모든 축에 대한 그라디언트를 계산하는 것입니다. 축은 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">그라디언트는 경계에서 N 차의 정확한 차를 사용하여 계산됩니다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 매개 변수 의 그래픽 그림 :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">그래픽 일러스트 :</target>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (빠른 최적 경로 근사치) : ~ 160ms</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N- 차원으로 균일 한 간격의 숫자로 이루어진 격자 모양의 배열.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">그룹 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">그룹 2</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">ufuncs / setitem / casting code에 대한 안전한 정렬 된 액세스 보장</target>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Gumbel, EJ,&amp;ldquo;극단 통계&amp;rdquo;, 뉴욕 : Columbia University Press, 1958.</target>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">반 정밀도 함수</target>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; 에&lt;/a&gt; 의해 처리</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">복소수 처리</target>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 처리</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">마스크 취급</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">하드 코딩 된 치수, 데이터 버퍼-치수-치수 사양 및 크기-그린-데이터-버퍼 규격.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">마스크의 경도</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">효과가 없으며 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 와 모양이 같습니다 . &lt;code&gt;element[isin]&lt;/code&gt; 값 은 &lt;code&gt;test_elements&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Heckert, NA 및 Filliben, James J.&amp;ldquo;NIST 핸드북 148 : 데이터 플롯 참조 매뉴얼, 제 2 권 : 부속 명령 및 라이브러리 기능 사용&amp;rdquo;, 2003 년 6 월 National Institute of Standards and Technology Handbook Series, &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https : //www.itl.nist. gov / div898 / software / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">피클 도우미.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">도우미 루틴</target>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">다음은 사용자 정의 주 마스크 값의 몇 가지 예입니다. 이 예에서는 월요일부터 금요일까지의 &quot;버스 데이&quot;기본값을 유효한 날짜로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">서명의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">날짜 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">새 반복자와 함께 사용할 함수에 대한 변환 표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">반복자를 사용하는 간단한 복사 기능은 다음과 같습니다. &lt;code&gt;order&lt;/code&gt; 파라미터가 할당 결과의 메모리 레이아웃을 제어하는 데 사용되는 통상적 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 가&lt;/a&gt; 바람직하다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
