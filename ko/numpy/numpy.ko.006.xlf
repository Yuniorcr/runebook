<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">핵심 생성기로 사용할 BitGenerator</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">BitGenerators : 난수를 생성하는 객체. 이들은 일반적으로 32 또는 64 개의 임의 비트 시퀀스로 채워진 부호없는 정수 워드입니다.</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 오른쪽에 &lt;code&gt;x2&lt;/code&gt; 0을 추가하여 비트를 왼쪽으로 이동합니다 . 숫자의 내부 표현은 이진 형식 &lt;code&gt;x1&lt;/code&gt; 연산은 x1 에 &lt;code&gt;2**x2&lt;/code&gt; 를 곱하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">비트는 오른쪽 &lt;code&gt;x2&lt;/code&gt; 로 이동합니다 . 숫자의 내부 표현은 이진 형식 &lt;code&gt;x1&lt;/code&gt; 연산은 x1 을 &lt;code&gt;2**x2&lt;/code&gt; 로 나누는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">객체 데이터 유형에 설정된 비트 : ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Blackman, RB and Tukey, JW, (1958) 전력 스펙트럼의 측정, Dover Publications, New York.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">블록은 어떤 차원이든 될 수 있지만 일반적인 규칙을 사용하여 브로드 캐스트되지는 않습니다. 대신 크기가 1 인 리딩 축이 삽입 되어 모든 블록에 대해 &lt;code&gt;block.ndim&lt;/code&gt; 을 동일 하게 만듭니다 . 이것은 주로 스칼라 작업에 유용하며 &lt;code&gt;np.block([v, 1])&lt;/code&gt; 과 같은 코드 가 유효 하다는 것을 의미합니다 . 여기서 &lt;code&gt;v.ndim == 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">최 목록의 블록 (참조 연결된다 &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; 최종 치수를 따라) (-1), 그 다음 이러한 두 번째 최종 치수를 따라 연결된다 (-2), 그래서 최 목록에 도달 할 때까지.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">부울 (모든 값이 True 또는 False 인 정수 유형)</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">반환 할 항목을 선택하는 부울 1-d 배열입니다. len (condition)이 축을 따라 a의 크기보다 작 으면 출력이 조건 배열의 길이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">부울 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 같은 모양의 부울 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">이 dtype의 바이트 순서가 플랫폼 고유인지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">dtype이 필드 정렬을 유지하는 구조 체인지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">dtype이 필드 정렬을 유지하는 구조 체인지 여부를 나타내는 부울입니다. 이 플래그는 고정되어 있으므로 여러 구조체를 함께 결합하면 유지되고 새로운 dtype도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">이 dtype에 필드 또는 하위 dtype에 참조 횟수 개체가 포함되어 있는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">부울 마스크 배열. 의 모양과 같아야 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">부울 마스크 배열. 의 크기와 같아야 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">부울 연산</target>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 가 스칼라 dtype 인지 확인한 부울 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용된 논리 OR 연산의 부울 결과 . 형태는 방송에 의해 결정됩니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용된 논리 XOR 연산의 부울 결과 . 형태는 방송에 의해 결정됩니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">같은 모양 부울 결과 &lt;code&gt;x&lt;/code&gt; 의 요소에 NOT 연산 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">부울도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">두 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 0 또는 1-D-D (ndim = 0 또는 1)해야하지만 &lt;code&gt;u.ndim&lt;/code&gt; 필요 같지 &lt;code&gt;v.ndim&lt;/code&gt; . 즉, &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; , &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; , &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; 및 &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; 네 가지 가능한 조합이 있습니다. ndim = 1- 작동합니다.</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">2 차원, 3 차원 및 4 차원 배열에 대해 C 순서 ( &quot;최종 차원&quot;) 또는 포트란 순서 ( &quot;최초 차원&quot;)를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">CType과 CFFI는 distributions.c를 DLL 등으로 컴파일 한 후 Numba에서보다 복잡한 배포판을 직접 사용할 수있게합니다. 보다 복잡한 배포판을 사용하는 예는 예제 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">두 인수 모두 총 크기가 동일한 데이터 유형 객체로 변환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">인덱싱 모두 :</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">이 루틴들 모두 정수 의 &lt;em&gt;n-&lt;/em&gt; 길이 배열 &lt;em&gt;seq를&lt;/em&gt; 곱하고 결과를 반환합니다. 오버 플로우 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">C 및 Fortran 차수는 &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;연속적&lt;/a&gt; 이며, &lt;em&gt;즉&lt;/em&gt; 단일 세그먼트 메모리 레이아웃으로, 일부 인덱스 조합으로 메모리 블록의 모든 부분에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">차원이 2 인 두 벡터</target>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., &quot;Rayleigh Distribution&quot;, &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">배열을 새로운 모양으로 브로드 캐스트</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">배열을 새로운 모양으로 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">서로 다른 배열을 브로드 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">입력 매개 변수를 서로 브로드 캐스트하고 결과를 캡슐화하는 오브젝트를 리턴하십시오. 여러 가지 중에서도, 그것을 갖는 &lt;code&gt;shape&lt;/code&gt; 및 &lt;code&gt;nd&lt;/code&gt; 특성 및 반복자로서 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">방송 (다중 반복자)</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">방송 배열 반복</target>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">방송 및 스칼라 곱셈 :</target>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">방송은 어레이 스택에 일반적입니다</target>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">방송은 NumPy 전체에서 사용되어 서로 다른 모양의 어레이를 처리하는 방법을 결정합니다. 예를 들어, &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 사이의 모든 산술 연산 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; ,&amp;hellip;)은 연산 전에 배열을 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">브로드 캐스트 규칙이 적용됩니다. 자세한 내용은 &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">브로드 캐스트는 항상 확장 차원에 대해 0 값의 보폭을 사용하여 숫자로 구현되었습니다. NumPy에서와 동일한 방식으로 수행됩니다. 가장 큰 차이점은 이제 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 에서 보폭 배열을 추적 하고, 브로드 캐스트 결과와 관련된 반복자는 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 하며, &lt;code&gt;PyArray_BroadCast&lt;/code&gt; 호출은 브로드 캐스트 규칙을 구현한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">방송, 요소 별 및 스칼라 곱셈, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">버퍼 ( &lt;code&gt;buf&lt;/code&gt; )는 이러한 보폭에 따라 해석됩니다 (스트라이드는 각 배열 요소, 행, 열 등이 메모리에서 차지하는 바이트 수를 정의합니다).</target>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">버퍼링 된 루프</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">큰 배열을위한 버퍼링 된 반복자.</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">버퍼링 모드는 메모리 사용 문제를 완화하고 임시 사본을 만드는 것보다 캐시 친화적입니다. 반복자 외부에서 한 번에 전체 배열이 필요한 특수한 경우를 제외하고 임시 복사보다 버퍼링이 권장됩니다. NumPy 내에서 버퍼링은 메모리 및 기타 기능에서 메모리 오버 헤드를 최소화하면서 유연한 입력을 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">배열 요소 버퍼링</target>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">문자열, 중첩 시퀀스 또는 배열에서 행렬 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">설치 가능한 C 라이브러리 빌드</target>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">행렬 만들기</target>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 작성된 출력 배열의 보폭과 동일한 보폭 세트를 빌드합니다. 여기서 op_axes 에 NULL이 전달되었습니다. 이것은 연속적으로 압축 된 데이터를위한 것이지만 반드시 C 또는 Fortran 순서로되어있는 것은 아닙니다. 생성자에 전달 된 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt; 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">내장 파이썬 타입</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">내장 스칼라 유형</target>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">영업일 기능</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">영업일 기능</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">그러나 다른 유형을 대체에 사용할 수 있습니다. 실제로 이것은 유형, 도메인 및 창 캐스팅에 대해 다항식 클래스의 변환이 수행되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">그러나 &lt;code&gt;rowsum&lt;/code&gt; 이 두 차원을 가지면 :</target>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">그러나 일부 &lt;code&gt;a, b, c, d&lt;/code&gt; 를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">그러나 그것이 그것을 보는 유일한 방법은 아닙니다. 데이터 파일에 저장된 큰 2 차원 배열 (이미지 또는 행렬)이 있다고 가정합니다. 데이터가 열이 아닌 행으로 저장되었다고 가정하십시오. 우리가 사용하는 언어에 따라 인덱스 규칙 (매트릭스 또는 이미지에 관계없이)을 유지해야하는 경우, 인덱스 규칙을 유지하기 위해 데이터를 메모리로 읽은 경우 데이터를 다시 정렬해야 할 수도 있습니다. 예를 들어, 재정렬하지 않고 행 순서 데이터를 메모리로 읽는 경우, C의 행렬 색인 규칙과 일치하지만 Fortran의 경우는 아닙니다. 반대로, Fortran의 이미지 인덱싱 규칙과 일치하지만 C의 경우에는 일치하지 않습니다. C의 경우 행 순서로 저장된 데이터를 사용하고 있고 이미지 인덱스 규칙을 유지하려는 경우 메모리를 읽을 때 데이터를 다시 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">그러나 라이브러리 파일 확장자와 같은 크로스 플랫폼 고려 사항이 있으며 Windows가 해당 이름으로 찾은 첫 번째 라이브러리를로드한다는 사실도 있습니다. NumPy는 편의상 load_library 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">그러나 이것은 약간의 미묘함을 생략합니다. 다음은 일반적인 요약입니다.</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">그러나 곱할 축을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">Buzas, Martin A .; Culver, Stephen J., 로그 시리즈 발생 분포를 통한 지역 종 다양성 이해 : 생물 다양성 연구 다양성 및 분포, 5 권, 5 호, 1999 년 9 월, 187-195 (9).</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">8 바이트 오프셋을 선택하면 뷰에서 배열의 복잡한 부분을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">일반적으로 마이너스 부호는 현금 유출을 나타냅니다 (즉, 현재 사용할 수없는 금액). 따라서 5 %의 연간 이자율로 한 달에 100 달러를 절약하면 10 년 동안 15,692.93 달러를 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">일반적으로 음수 부호는 현금 유출을 나타냅니다 (즉, 현재 사용할 수없는 돈). 따라서 10 년 만에 15,692.93 달러로 매월 5 %의 연간 이자율로 100 달러를 절약하려면 초기 예금도 100 달러가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt; 는 실패시 AssertionError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 에 의해 제공되는 비트 사용 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 에서 레거시 mt19937 난수 발생기보다 통계적 특성 갖는다 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">기본적으로 &lt;code&gt;float16&lt;/code&gt; 결과는 정밀도 를 높이기 위해 &lt;code&gt;float32&lt;/code&gt; 중간체를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">기본적으로 지정된 모양과 데이터 유형으로 새 배열이 작성됩니다. 경우 &lt;code&gt;buf&lt;/code&gt; 지정한 버퍼 인터페이스를 노출시키는 목적으로하고, 상기 어레이는 기존의 버퍼 메모리를 사용한다. 이 경우 &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이것이 false로 설정되고 &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 사본 대신 입력 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이것이 false로 설정되고 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 사본 대신 입력 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이것이 false로 설정되고 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 사본 대신 입력 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">기본적으로 모든 요소의 곱을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">기본적으로 마스크 된 값은 그대로 인식됩니다. 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 동일 형상을 가지고, 공통 마스크가 할당되어있는 경우 &lt;code&gt;x[i,j]&lt;/code&gt; 마스킹 한 후 &lt;code&gt;y[i,j]&lt;/code&gt; 또한 마스킹 될 것이다. &lt;code&gt;allow_masked&lt;/code&gt; 를 False로 설정 하면 입력 배열 중 하나에서 값이 누락 된 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">기본적으로 mode는 'full'입니다. 그러면 출력 모양이 (N + M-1) 인 각 오버랩 지점에서 컨벌루션이 반환됩니다. 컨벌루션의 끝점에서 신호가 완전히 겹치지 않고 경계 효과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">기본적으로 치수를 반대로하고, 그렇지 않으면 주어진 값에 따라 축을 치환합니다.</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 입력 피연산자를 읽기 전용 개체로 취급합니다. 배열 요소를 수정할 수 있으려면 &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; -operand 플래그를 사용하여 읽기 / 쓰기 또는 쓰기 전용 모드를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 None으로 전달되는 피연산자에 'allocate'및 'writeonly'플래그를 사용합니다. 이것은 두 개의 피연산자를 반복자에게 제공 할 수 있었고 나머지는 처리했습니다.</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">기본적으로 데이터 유형은 입력 데이터에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">기본적으로 인덱스는 평평한 배열에 있고 그렇지 않으면 지정된 축을 따라 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">기본적으로 반복자는 제공된 배열에 대한 포인터를 생성하며, 배열은 정렬되거나 정렬되지 않고 바이트 순서로 정렬 될 수 있습니다. 복사 또는 버퍼링이 사용 가능하지 않고 피연산자 데이터가 제한 조건을 만족하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">위의 설명에서 내부 루프를 제거하고 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 를 사용하여 간단한 슬라이스 객체 를 만들면 각 1 차원 슬라이스에 멋진 색인을 적용하는 관점에서 &lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">버퍼링 모드를 활성화하면 반복자가 내부 루프에 제공하는 청크를 크게 만들 수 있으므로 Python 인터프리터의 오버 헤드가 크게 줄어 듭니다. Fortran 반복 순서를 강제하는 예제에서 버퍼링이 활성화되면 내부 루프가 모든 요소를 ​​한 번에 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">계수를 살펴보면 선의 경사도가 대략 1이고 y 축을 -1로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">지금까지 가장 복잡한 경우는 고급 인덱싱으로 일반적인 뷰 기반 인덱싱과 결합되거나 결합되지 않을 수 있습니다. 여기서 정수 인덱스는 뷰 기반으로 해석됩니다. 이것을 이해하기 전에 그 미묘함에 익숙해지기를 원할 수 있습니다. 고급 인덱싱 코드에는 세 가지 분기와 하나의 특별한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">대체하여</target>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">상기 설명에 의해, 캐스팅 규칙은 본질적으로 데이터 타입이 다른 데이터 타입으로 &quot;안전하게&quot;캐스팅 될 수있는 시점에 의해 구현된다. 이 질문에 대한 답변은 파이썬에서 함수 호출 &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt; 으로 결정할 수 있습니다 . 아래 그림은 작성자의 64 비트 시스템에서 24 개의 내부 지원 유형에 대한이 호출의 결과를 보여줍니다. 그림에 제공된 코드를 사용하여 시스템에 대해이 테이블을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">데이터의 바이트 순서 ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">바이트 순서 강제; 위의 바이트 순서 스펙의 값 기본값 ( 'S')은 현재 바이트 순서를 교체합니다. 이 코드는 위의 대안에 대해 &lt;code&gt;new_order&lt;/code&gt; 의 첫 글자에서 대소 문자를 구분하지 않습니다 . 예를 들어, 'B'또는 'b'또는 'biggish'는 big-endian을 지정하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">바이트 순서 강제; 아래의 바이트 순서 스펙의 값 &lt;code&gt;new_order&lt;/code&gt; 코드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">바이트 순서 강제; 아래의 바이트 순서 스펙의 값 기본값 ( 'S')은 현재 바이트 순서를 교체합니다. &lt;code&gt;new_order&lt;/code&gt; 코드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">모든 필드의 바이트 순서.</target>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C API 지원 중단</target>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">C 주문</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">C 주문.</target>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">기본 기능 구현을위한 C-API</target>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">C 유형 외부 함수 인터페이스 ( &lt;code&gt;numpy.ctypeslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">C 유형 외부 함수 인터페이스 (numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">C 순서 배열은 FORTRAN 순서 인 경우에도 False로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">적분의 C- 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">어레이 인터페이스의 C면</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">C-struct 액세스</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">C 타입 이름</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw, &quot;수학적 기능을위한 체비 쇼프 시리즈&quot;, &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt; , vol. 5, 런던 : 폐하의 문구 사무소, 1962</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">C99와 같은 복잡한 기능이 추가되었습니다. 이식 가능한 C 확장을 구현하려는 경우 사용할 수 있습니다. C99 복합 유형이없는 플랫폼을 계속 지원하므로 다음과 같이 C90 호환 구문으로 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">CFFI 인터페이스</target>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">플랫폼의 CPU 아키텍처; 위 중 하나만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUOUS / C / 연속</target>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">입력 배열의 모든 &lt;code&gt;p&lt;/code&gt; 에 대해 &lt;code&gt;2**p&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">배열의 모든 요소에 대해 &lt;code&gt;2**x&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">배열의 모든 요소에 대해 &lt;code&gt;exp(x) - 1&lt;/code&gt; 을 계산 하십시오.</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">요소 별 절대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">입력 배열에있는 모든 원소의 지수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">단일 값 분해 (SVD)를 사용하고 모든 &lt;em&gt;큰&lt;/em&gt; 특이 값을 포함하여 행렬의 일반화 된 역을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">주어진 축을 따라 n 번째 이산 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">주어진 축을 따라 n 번째 이산 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">비 NaN 값의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">이 값의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">표준 편차의 제수가 자유도 N-1이되도록 ddof 매개 변수를 바이어스되지 않은 값으로 설정하여 t 통계량을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1/x&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">을 계산의 &lt;code&gt;element in test_elements&lt;/code&gt; 를 통해 방송, &lt;code&gt;element&lt;/code&gt; 만.</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">을 계산의 &lt;code&gt;element in test_elements&lt;/code&gt; 를 통해 방송, &lt;code&gt;element&lt;/code&gt; 만. element의 &lt;code&gt;element&lt;/code&gt; 가 &lt;code&gt;test_elements&lt;/code&gt; 에 있는 경우 True 인 &lt;code&gt;element&lt;/code&gt; 와 동일한 모양의 부울 배열을 리턴하고 그렇지 않으면 False 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;log(1 + x)&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">계산은 &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; . 이 함수는 계산 된 이벤트 확률이 정규 부동 소수점 수의 범위를 초과 할 정도로 작은 통계에 유용합니다. 이러한 경우 계산 된 확률의 로그가 저장됩니다. 이 기능을 사용하면 이러한 방식으로 저장된 확률을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">계산의 &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; . 이 함수는 계산 된 이벤트 확률이 정규 부동 소수점 수의 범위를 초과 할 정도로 작을 때 기계 학습에 유용합니다. 이러한 경우 계산 된 확률의 밑이 2 인 로그를 대신 사용할 수 있습니다. 이 기능을 사용하면 이러한 방식으로 저장된 확률을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b6b61d48a464831755d05e96c5b24edef1de03" translate="yes" xml:space="preserve">
          <source>Calculates which of the given dates are valid days, and which are not.</source>
          <target state="translated">주어진 날짜 중 어느 날짜가 유효한지 계산하고 그렇지 않은 날짜를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="dc6751bd6532a841494c31d2cb271a6c23434bcc" translate="yes" xml:space="preserve">
          <source>Calculation</source>
          <target state="translated">Calculation</target>
        </trans-unit>
        <trans-unit id="05d27dcc239bf9ea22989ad95d110b65fd4d9edb" translate="yes" xml:space="preserve">
          <source>Calculations</source>
          <target state="translated">Calculations</target>
        </trans-unit>
        <trans-unit id="c0b95ddbd1bbdb09cd17ce1c430a7adeedcc6050" translate="yes" xml:space="preserve">
          <source>Calculus</source>
          <target state="translated">Calculus</target>
        </trans-unit>
        <trans-unit id="bdf175380f108b91b68b35d6cba860e239285fd3" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.istitle&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.istitle&lt;/code&gt; 을 요소별로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5bbdd4afe52a03da69e768bb6350617fd2c2fe8" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.isupper&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isupper&lt;/code&gt; 를 요소 단위로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="204bec18a0c758d4b92300d3ccfda2d8f2d41215" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.lower&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.lower&lt;/code&gt; 를 요소 단위로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eef266f410d282365eeaef6f6541415ad4d67585" translate="yes" xml:space="preserve">
          <source>Call self as a function.</source>
          <target state="translated">자신을 함수라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="8829f8e417cdbefc80e5f0018c56210ff40f16e6" translate="yes" xml:space="preserve">
          <source>Callback upon error:</source>
          <target state="translated">오류시 콜백 :</target>
        </trans-unit>
        <trans-unit id="f76a0fdbe900eef0f77fc7210a232c0754707b8b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt;&lt;code&gt;str.encode&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt; &lt;code&gt;str.encode&lt;/code&gt; 를&lt;/a&gt; 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5ddbcf21043a5f353f23ca4baba1595ba4a4c298" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.capitalize&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.capitalize&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fac61b23fdecfba854b4b4efab7777fd152b2cd6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.center&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.center&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1314c79da136d136fb6bbb829ea41b9418ad141a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.count&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.count&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4bdc60efe7fe548bd722d4044bc214b413e9d4dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.decode&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.decode&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="065d9a82f4f8e8be749e189a1fda4fbbe3abbe4a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.encode&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.encode&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c1788f723cdc513a1b82d19f6d756a8fad670e36" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.endswith&lt;/code&gt; element-wise.</source>
          <target state="translated">요소 &lt;code&gt;str.endswith&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1506c8828926db71b8ee1e63d0d49604826d93cb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.expandtabs&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.expandtabs&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3c7293ade2e69f10fa46947bf34f0b6e9553dda9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.find&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.find&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="467102d858ecdef3b85b56bdb57ad38edb734308" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.index&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.index&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9028b020672a2d11380a1f6acfdb2435aab492c0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalnum&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isalnum&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fd4a785af6221c540650fb70b847d1cefb209fda" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalpha&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isalpha&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="656252d18256f4f02da62d1b2291d93d00dda7e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isdigit&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isdigit&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2a85e1b04f3860c701786f2c9eabf6a753b661de" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.islower&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.islower&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2bb68da644aa463ff4c1c36c7d9b40bf8b8f64bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isspace&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isspace&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="741c3bea47e11f849d26dfea4d3d3a40eab3c129" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.join&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.join&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a819deb9a44d524ac6731b6be53354ba9f42a375" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.ljust&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.ljust&lt;/code&gt; 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="be80be96a9f5d678d3f84ce0ae913fd30691c166" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.lstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.lstrip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3a06e70f258111f5ace799d0136012a728b9986f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.partition&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.partition&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="887a34caef57804ead86c1cf188ead795251b5a4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.replace&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.replace&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="05d90debebac8c8e525b11c833af03b1809c3595" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rfind&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rfind&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="89bfa6c81f923111ab3ece5d1065bb7a8b18172a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rindex&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rindex&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="55188dcc2c20e117f83220adcd9445f8940213ba" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rjust&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rjust&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="19291c82bbc252e358dcd5efe30bebd4ce3f47fc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rpartition&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rpartition&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e30544ad22292a0898136208de2fa5fc236f97f4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rsplit&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rsplit&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bf3f027903bcb2fa17e73f1d36c8446f531dbe5a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rstrip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="739adfdb756eef5e48a6b103e3600e5bc999cb7a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.split&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.split&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e51ab4b44c03ea14d792300213b602772f9ea6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.splitlines&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.splitlines&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6c953fe5d272055ef6fdc5b65d12465c629e73e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.startswith&lt;/code&gt; element-wise.</source>
          <target state="translated">요소별로 &lt;code&gt;str.startswith&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1827eeaf19d2fb7a578c669a1d5307476f133fcd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.strip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.strip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="274bbb89ddefdfebcf8c0b98e05e899bc5eb9615" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.swapcase&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.swapcase&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc28d6c4e67250d03ac5f9ac2fcd548d24d6297" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.title&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.title&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="91315156a48280f48729eabe9ec7862779adc8d2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.translate&lt;/code&gt; element-wise.</source>
          <target state="translated">호출 &lt;code&gt;str.translate&lt;/code&gt; 요소 현명한.</target>
        </trans-unit>
        <trans-unit id="2440d757fee8b2705315ead5568e7af63f8335a3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.upper&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.upper&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="691e1fcbb97130e6abfe067256904d840bcc927b" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.zfill&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.zfill&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9c60fe9461b9d2c89f3c3e872dadf8ad18517837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isdecimal&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;unicode.isdecimal&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e0a82d42fca087f606e832d63a055b7b362137" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isnumeric&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;unicode.isnumeric&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="79ab673318d7c81b7f76879d7f7e6d0f3ff543f1" translate="yes" xml:space="preserve">
          <source>Can be a local file or a remote URL.</source>
          <target state="translated">로컬 파일 또는 원격 URL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90e6085e13ad6ee060ad3eac04d655f92454003" translate="yes" xml:space="preserve">
          <source>Can be read from a filelike stream object instead of an actual file.</source>
          <target state="translated">실제 파일 대신 파일과 같은 스트림 객체에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07932047b9de074a44eece379f541bd670890cdd" translate="yes" xml:space="preserve">
          <source>Can be used, for example, to add broadcasting to a built-in Python function (see Examples section).</source>
          <target state="translated">예를 들어 내장 Python 함수에 브로드 캐스트를 추가하는 데 사용할 수 있습니다 (예제 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7139132bf88ca6d9cbbfb32a613254727892bf7e" translate="yes" xml:space="preserve">
          <source>Can represent all NumPy arrays including nested record arrays and object arrays.</source>
          <target state="translated">중첩 된 레코드 배열 및 개체 배열을 포함하여 모든 NumPy 배열을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="a058457334819b9647916ad868c25fa88bc97117" translate="yes" xml:space="preserve">
          <source>Cartesian (&amp;lsquo;xy&amp;rsquo;, default) or matrix (&amp;lsquo;ij&amp;rsquo;) indexing of output. See Notes for more details.</source>
          <target state="translated">출력의 데카르트 ( 'xy', 기본값) 또는 행렬 ( 'ij') 인덱싱 자세한 내용은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5599547be57585d8ed9f9e6e56fb372b94bf366" translate="yes" xml:space="preserve">
          <source>Cash flows (must contain at least one positive and one negative value) or nan is returned. The first value is considered a sunk cost at time zero.</source>
          <target state="translated">현금 흐름 (양수 및 음수 값을 하나 이상 포함해야 함) 또는 nan이 반환됩니다. 첫 번째 값은 시간이 0 일 때 가라 앉은 비용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4819b90bf3135701e4238f100f5eccaffb4cf77a" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;input&lt;/code&gt; to a &lt;code&gt;PyArrayObject*&lt;/code&gt; if legal, and ensure that it is of type &lt;code&gt;typecode&lt;/code&gt;. If &lt;code&gt;input&lt;/code&gt; cannot be cast, or the &lt;code&gt;typecode&lt;/code&gt; is wrong, set a Python error and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">유효한 경우 &lt;code&gt;PyArrayObject*&lt;/code&gt; &lt;code&gt;input&lt;/code&gt; 을 캐스트 하고 &lt;code&gt;typecode&lt;/code&gt; 유형인지 확인하십시오 . 경우 &lt;code&gt;input&lt;/code&gt; 캐스트 할 수없는, 또는 &lt;code&gt;typecode&lt;/code&gt; 잘못, 파이썬 오류 및 반환 설정 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5da405e72e65e85b0a6ff9fb710530d444100461" translate="yes" xml:space="preserve">
          <source>Cast code: This checks for &amp;ldquo;true&amp;rdquo; alignment, as it does &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; if aligned. Otherwise, it does &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; where dstval/srcval are aligned.</source>
          <target state="translated">캐스트 코드 : 정렬되면 &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; 와 같이 &quot;true&quot;정렬을 확인합니다 . 그렇지 않으면 &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; dstval / srcval이 정렬되는 memmove (dst, dstval) .</target>
        </trans-unit>
        <trans-unit id="4dbf7f264927d9ee6c0c9230f88c1b227f370d7c" translate="yes" xml:space="preserve">
          <source>Cast the elements of the array &lt;em&gt;in&lt;/em&gt; into the array &lt;em&gt;out&lt;/em&gt;. The output array should be writeable, have an integer-multiple of the number of elements in the input array (more than one copy can be placed in out), and have a data type that is one of the builtin types. Returns 0 on success and -1 if an error occurs.</source>
          <target state="translated">배열 요소 캐스트 &lt;em&gt;에&lt;/em&gt; 어레이로 &lt;em&gt;아웃&lt;/em&gt; . 출력 배열은 쓰기 가능해야하고, 입력 배열에 여러 요소의 정수 배수 (하나 이상의 사본을 배치 할 수 있음)가 있어야하며 내장 유형 중 하나 인 데이터 유형이 있어야합니다. 성공하면 0을, 에러가 발생하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6a8277578137a1b27ee47f6d99dc6ac5a6c8df7" translate="yes" xml:space="preserve">
          <source>Cast to the desired type, even if it can&amp;rsquo;t be done without losing information.</source>
          <target state="translated">정보 손실없이 수행 할 수없는 경우에도 원하는 유형으로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a945bfddda4f16646c0e1e8cf16a394a39e915e6" translate="yes" xml:space="preserve">
          <source>Casting Rules</source>
          <target state="translated">캐스팅 규칙</target>
        </trans-unit>
        <trans-unit id="0e43fbb5b95b8e028055445bd4f061de51dc4a06" translate="yes" xml:space="preserve">
          <source>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast &amp;ldquo;safely.&amp;rdquo; The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</source>
          <target state="translated">ufunc에 제공된 입력 유형에 대한 코어 루프 구현이 없을 때마다 하나 이상의 입력에서 캐스팅을 수행해야합니다. 입력 유형에 대한 구현을 찾을 수없는 경우 알고리즘은 모든 입력을 &quot;안전하게&quot;캐스팅 할 수있는 유형 서명이있는 구현을 검색합니다. 내부 루프 목록에서 찾은 첫 번째 루프는 필요한 모든 유형 캐스팅 후에 선택되어 수행됩니다. ufuncs 동안 (캐스팅에서도) 내부 사본은 내부 버퍼 (사용자 설정 가능)의 크기로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8748cec5513dc9c01c715b723dcb4b372a11fea9" translate="yes" xml:space="preserve">
          <source>Casting scalars</source>
          <target state="translated">스칼라 캐스팅</target>
        </trans-unit>
        <trans-unit id="cbb26092630998f6b4ebb2584d7e63c1ad783481" translate="yes" xml:space="preserve">
          <source>Casting the set to a list gives the expected result:</source>
          <target state="translated">세트를 목록으로 캐스트하면 예상 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3b9cb47a9c04d9f04e8fb247efea4728b9f0825f" translate="yes" xml:space="preserve">
          <source>Casting to allow when changing between datetime units.</source>
          <target state="translated">날짜 / 시간 단위 사이를 변경할 때 허용되는 캐스팅.</target>
        </trans-unit>
        <trans-unit id="1b7e02730ebfcc85f5732a8be223fd80563fe083" translate="yes" xml:space="preserve">
          <source>Categories are determined by first checking which of boolean, integer (int/uint), or floating point (float/complex) the maximum kind of all the arrays and the scalars are.</source>
          <target state="translated">범주는 먼저 모든 배열과 스칼라의 최대 종류가 부울, 정수 (int / uint) 또는 부동 소수점 (float / complex)인지 확인하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3325b57bdda8f0731fcea923488b3e46095663f1" translate="yes" xml:space="preserve">
          <source>Causes the iterator to convert all the operands to a common data type, calculated based on the ufunc type promotion rules. Copying or buffering must be enabled.</source>
          <target state="translated">반복자가 ufunc 유형 승격 규칙에 따라 계산 된 모든 피연산자를 공통 데이터 유형으로 변환합니다. 복사 또는 버퍼링이 활성화되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6e47e97b987638e04e1741c9188448c0cda9575" translate="yes" xml:space="preserve">
          <source>Causes the iterator to provide data for &lt;code&gt;op[i]&lt;/code&gt; that is in native byte order, aligned according to the dtype requirements, contiguous, or any combination.</source>
          <target state="translated">반복자가 dtype 요구 사항, 연속 또는 임의의 조합에 따라 정렬 된 원시 바이트 순서의 &lt;code&gt;op[i]&lt;/code&gt; 에 대한 데이터를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="78cd28e519e06a8be731a725d2ee50a3144a0620" translate="yes" xml:space="preserve">
          <source>Causes the iterator to skip iteration of the innermost loop, requiring the user of the iterator to handle it.</source>
          <target state="translated">반복자가 가장 안쪽 루프의 반복을 건너 뛰도록하여 반복자의 사용자가 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d748728383297b4bba46340904d34590fd3f0e6c" translate="yes" xml:space="preserve">
          <source>Causes the iterator to store buffering data, and use buffering to satisfy data type, alignment, and byte-order requirements. To buffer an operand, do not specify the &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags, because they will override buffering. Buffering is especially useful for Python code using the iterator, allowing for larger chunks of data at once to amortize the Python interpreter overhead.</source>
          <target state="translated">반복자가 버퍼링 데이터를 저장하고 버퍼링을 사용하여 데이터 유형, 정렬 및 바이트 순서 요구 사항을 충족시킵니다. 피연산자를 버퍼링하려면 버퍼링을 대체하므로 &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그를 지정하지 마십시오 . 버퍼링은 반복자를 사용하는 Python 코드에 특히 유용하므로 한 번에 더 많은 데이터 청크가 파이썬 인터프리터 오버 헤드를 상각 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe86966ee1567b8621995982683f047543e592a" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a multi-index. This prevents the iterator from coalescing axes to produce bigger inner loops. If the loop is also not buffered and no index is being tracked (&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; can be called), then the iterator size can be &lt;code&gt;-1&lt;/code&gt; to indicate that the iterator is too large. This can happen due to complex broadcasting and will result in errors being created when the setting the iterator range, removing the multi index, or getting the next function. However, it is possible to remove axes again and use the iterator normally if the size is small enough after removal.</source>
          <target state="translated">반복자가 다중 색인을 추적하도록합니다. 이것은 반복자가 축을 합쳐서 더 큰 내부 루프를 생성하는 것을 방지합니다. 루프가 버퍼링되지 않고 인덱스가 추적되지 않으면 ( &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 를 호출 할 수 있음) 반복기 크기가 &lt;code&gt;-1&lt;/code&gt; 일 수 있으므로 반복기가 너무 크다는 것을 나타냅니다. 이는 복잡한 브로드 캐스트로 인해 발생할 수 있으며 반복기 범위를 설정하거나 다중 인덱스를 제거하거나 다음 기능을 가져올 때 오류가 발생합니다. 그러나 제거 후 크기가 충분히 작 으면 축을 다시 제거하고 반복기를 정상적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78370684072181888bd07868c0ae200011c6b51" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching C order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복자가 C 순서와 일치하는 평면 인덱스를 추적하도록합니다. 이 옵션은 &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d09f5eb17dd94e9b8185491d29ffd82541173b9e" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching Fortran order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복자가 포트란 순서와 일치하는 평면 인덱스를 추적하도록합니다. 이 옵션은 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c0df50e511723d6385d81becfe6c98c0ca2c5dad" translate="yes" xml:space="preserve">
          <source>Chained array operations, in efficient calculation order, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;numpy.einsum_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">효율적인 연산 순서 체인화 어레이 동작, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;numpy.einsum_path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9f53c2498e2f3ad3fca9000468a403dc1def6c7" translate="yes" xml:space="preserve">
          <source>Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a &amp;lsquo;greedy&amp;rsquo; path or pre-computing the &amp;lsquo;optimal&amp;rsquo; path and repeatedly applying it, using an &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;einsum_path&lt;/code&gt;&lt;/a&gt; insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:</source>
          <target state="translated">체인 배열 연산. 더 복잡한 수축의 경우`` &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;einsum_path&lt;/code&gt; &lt;/a&gt; ''경로를 반복적으로 계산하거나 '최적의'경로를 사전 계산하고 einsum_path 삽입 (버전 1.12.0 이후)을 사용하여 반복적으로 적용하여 속도를 높일 수 있습니다. 더 큰 어레이에서는 성능 향상이 특히 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b14b1641c23a3ee01fb58fe8633eb893f1634ef" translate="yes" xml:space="preserve">
          <source>Change elements of an array based on conditional and input values.</source>
          <target state="translated">조건부 및 입력 값을 기준으로 배열의 요소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="03e304dc68ffb07e8cb055b859df002401eafba4" translate="yes" xml:space="preserve">
          <source>Change shape and size of array in-place.</source>
          <target state="translated">배열의 모양과 크기를 제자리에서 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1baf38892b5a38369da2ab3d5066a1bc5faa26e9" translate="yes" xml:space="preserve">
          <source>Change the shape of an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열의 모양을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="57cca933dc4ae8712cc751b049a24d49a1cbe977" translate="yes" xml:space="preserve">
          <source>Change the sign of x1 to that of x2, element-wise.</source>
          <target state="translated">x1의 부호를 요소 별 x2의 부호로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="f1fd8269d290cf6173d8944feb182f6867a500ae" translate="yes" xml:space="preserve">
          <source>Change the vector definition of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;axisa&lt;/code&gt; and &lt;code&gt;axisb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axisa&lt;/code&gt; 및 &lt;code&gt;axisb&lt;/code&gt; 를 사용하여 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 벡터 정의를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e76bac75a93f40062500cfe4d6d4594aea2a414" translate="yes" xml:space="preserve">
          <source>Changed in version 1.10.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">버전 1.10.0으로 변경 : 이전 NumPy 버전에는 dfnum&amp;gt; 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9e03441147d9c9bca84c6633efe853d678690f6f" translate="yes" xml:space="preserve">
          <source>Changed in version 1.11.0: When a single column has to be read it is possible to use an integer instead of a tuple. E.g &lt;code&gt;usecols = 3&lt;/code&gt; reads the fourth column the same way as &lt;code&gt;usecols = (3,)&lt;/code&gt; would.</source>
          <target state="translated">버전 1.11.0으로 변경 : 단일 열을 읽어야 할 때 튜플 대신 정수를 사용할 수 있습니다. 예를 들어 &lt;code&gt;usecols = 3&lt;/code&gt; 은 &lt;code&gt;usecols = (3,)&lt;/code&gt; 과 같은 방식으로 네 번째 열을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4240cc617a1809505e609f22132a15e64d1b8364" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Previously, the default was documented to be -1, but that was in error. At some future date, the default will change to -1, as originally intended. Until then, the axis should be given explicitly when &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt;, to avoid a FutureWarning.</source>
          <target state="translated">버전 1.13.0으로 변경 : 이전에는 기본값이 -1로 문서화되었지만 오류가 발생했습니다. 향후에는 원래 의도 한대로 기본값이 -1로 변경됩니다. 그때까지는 &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt; 일 때 FutureWarning을 피하기 위해 축을 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cf5dc6a75318b20c4a1e296708ff3954da61899" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Tuples are allowed for keyword argument.</source>
          <target state="translated">버전 1.13.0으로 변경 : 키워드 인수에 튜플이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8369be3972dcfca939d8870350211ef461655917" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">버전 1.14.0으로 변경 : 이전 NumPy 버전에는 dfnum&amp;gt; 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="90df01afcc61c5a576cbe17f8aa7128ba6554b30" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: If not set, a FutureWarning is given. The previous default of &lt;code&gt;-1&lt;/code&gt; will use the machine precision as &lt;code&gt;rcond&lt;/code&gt; parameter, the new default will use the machine precision times &lt;code&gt;max(M, N)&lt;/code&gt;. To silence the warning and use the new default, use &lt;code&gt;rcond=None&lt;/code&gt;, to keep using the old behavior, use &lt;code&gt;rcond=-1&lt;/code&gt;.</source>
          <target state="translated">버전 1.14.0으로 변경 : 설정되지 않은 경우 FutureWarning이 제공됩니다. 이전 기본값 &lt;code&gt;-1&lt;/code&gt; 은 기계 정밀도를 &lt;code&gt;rcond&lt;/code&gt; 매개 변수로 사용하고 새로운 기본값은 기계 정밀도 시간 &lt;code&gt;max(M, N)&lt;/code&gt; 합니다. 경고를 &lt;code&gt;rcond=None&lt;/code&gt; 새 기본값을 사용하려면 rcond = None 을 사용하고 이전 동작을 계속 사용하려면 &lt;code&gt;rcond=-1&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d2839d7d3bf87e0e23f5c67fc8d1ab0fe0551fd" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Broadcasted against the stack of matrices</source>
          <target state="translated">버전 1.14에서 변경 : 매트릭스 스택에 대해 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="348ee8de383634f48f0728f5bfaf909f0982c324" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Can now operate on stacks of matrices</source>
          <target state="translated">버전 1.14에서 변경 : 이제 매트릭스 스택에서 작동 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="05cf1c5d8f1269a7f5fa5c6cc3fc095bf8055509" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0.: The &amp;lsquo;stable&amp;rsquo; option was added.</source>
          <target state="translated">버전 1.15.0으로 변경 : 'stable'옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e6fb4664107937e52dcdbc13917b49d6b44f05c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: DeprecationWarnings are actually emitted.</source>
          <target state="translated">버전 1.15.0으로 변경 : DeprecationWarnings가 실제로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3b221df91333bee6b9f5792109b32e7e70567b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: None and tuples of axes are supported</source>
          <target state="translated">버전 1.15.0으로 변경 : 축 없음 및 튜플 지원</target>
        </trans-unit>
        <trans-unit id="83d75b7f177288265577e6765abc146d2cecb0e7" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Non-scalar &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are now supported.</source>
          <target state="translated">버전 1.16.0에서 변경 : 이제 스칼라가 아닌 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="25985fe044545f9478af4af504ffd04c8801c6e6" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Renamed from &lt;code&gt;dims&lt;/code&gt; to &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">버전 1.16.0에서 변경 : &lt;code&gt;dims&lt;/code&gt; 에서 &lt;code&gt;shape&lt;/code&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eef53483993b5fb29b126ef19278ead520adb6f9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.3: Made default False in response to CVE-2019-6446.</source>
          <target state="translated">버전 1.16.3으로 변경 : CVE-2019-6446에 대한 응답으로 기본 False가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff4dc328009aefab6de678232e1061e9bf30fb2d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; is also usable as a function decorator, saving a level of indentation if an entire function is wrapped. See &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt;&lt;code&gt;contextlib.ContextDecorator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">버전 1.17.0으로 변경 : &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; 는 함수 데코레이터로도 사용할 수 있으며 전체 함수가 랩핑 된 경우 들여 쓰기 수준을 저장합니다. 자세한 정보는 &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt; &lt;code&gt;contextlib.ContextDecorator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af2d1032fe2cc2a8c7b8fc21250999bf723a2b20" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; objects are now accepted.</source>
          <target state="translated">버전 1.17.0에서 변경 : &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 객체가 이제 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="61efb6f136dc51708e975673488296290e1e421b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: Casting between a simple data type and a structured one is possible only for &amp;ldquo;unsafe&amp;rdquo; casting. Casting to multiple fields is allowed, but casting from multiple fields is not.</source>
          <target state="translated">버전 1.17.0으로 변경 : 단순 데이터 유형과 구조화 된 유형 간의 캐스트는 &quot;안전하지 않은&quot;캐스트에만 가능합니다. 여러 필드로 캐스트 할 수 있지만 여러 필드에서 캐스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c9406124c2f89ed955f1ed4fdf79269cd807fab" translate="yes" xml:space="preserve">
          <source>Changed in version 1.8.0: Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">버전 1.8.0에서 변경 : 브로드 캐스트 규칙이 적용됩니다. 자세한 내용은 &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="442c1fd3d41745a2d4ec1e84a3657676ca62838e" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: A tuple of axes is supported</source>
          <target state="translated">버전 1.9.0에서 변경 : 축의 튜플이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="73bab6415b0560ad9f839326ef0b98ed7906af98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the max integer/float value converted.</source>
          <target state="translated">버전 1.9.0으로 변경 : '안전한'캐스팅 모드에서 숫자에서 문자열 유형으로 캐스팅하려면 변환 된 최대 정수 / 부동 값을 저장할 수있는 문자열 dtype 길이가 길어야합니다.</target>
        </trans-unit>
        <trans-unit id="8adc0d706675beb5229fbd846a1b85c2cfcca190" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the maximum integer/float value converted.</source>
          <target state="translated">버전 1.9.0에서 변경 : '안전한'캐스팅 모드에서 숫자에서 문자열 유형으로 캐스팅하려면 변환 된 최대 정수 / 부동 값을 저장할 수있는 문자열 dtype 길이가 길어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a255433707dd5f70c7a4be8e1821141fe49e182" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9: 1-D and 0-D cases are allowed.</source>
          <target state="translated">버전 1.9에서 변경 : 1-D 및 0-D 사례가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d447e3c0af8f91b0b6d56c2803ffc2d885c25ac6" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the array data type.</source>
          <target state="translated">배열 데이터 유형의 모든 필드 및 하위 배열에서도 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c8653ebb3c65244702565331c9f825090ef108" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the data type.</source>
          <target state="translated">데이터 유형의 모든 필드 및 하위 배열에서도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="988d6dcf1558a60cf9e3df8c88bfbf9aa6476a76" translate="yes" xml:space="preserve">
          <source>Changes elements of an array based on conditional and input values.</source>
          <target state="translated">조건부 및 입력 값을 기준으로 배열의 요소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="11f7d423e4a6c5aafe601b11f0668f2b9c2f00fa" translate="yes" xml:space="preserve">
          <source>Changes the variable used when printing &lt;code&gt;p&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; (see Examples).</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에서 &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; 인쇄 할 때 사용되는 변수를 변경합니다 (예 참조).</target>
        </trans-unit>
        <trans-unit id="a6b7a5b4726b415eac4533ff4c785ffd43ff58e3" translate="yes" xml:space="preserve">
          <source>Changes with NumPy 1.11</source>
          <target state="translated">NumPy 1.11의 변경 사항</target>
        </trans-unit>
        <trans-unit id="f88e590a9d42082459bee2897052e8478444520a" translate="yes" xml:space="preserve">
          <source>Changing array shape</source>
          <target state="translated">배열 모양 변경</target>
        </trans-unit>
        <trans-unit id="bb5d57bb97464b7a41e90965a34fd558225f91df" translate="yes" xml:space="preserve">
          <source>Changing kind of array</source>
          <target state="translated">배열 종류 변경</target>
        </trans-unit>
        <trans-unit id="4dac00a1fdb9bc9e870465fcb8ac48e7a6f41092" translate="yes" xml:space="preserve">
          <source>Changing number of dimensions</source>
          <target state="translated">치수 수 변경</target>
        </trans-unit>
        <trans-unit id="26a89ebf1c1d895edaaec0f680290afde6188baf" translate="yes" xml:space="preserve">
          <source>Changing the number of dimensions</source>
          <target state="translated">치수 수 변경</target>
        </trans-unit>
        <trans-unit id="659708d4116763fca54f546304717111fc0dcdbc" translate="yes" xml:space="preserve">
          <source>Changing the shape</source>
          <target state="translated">모양 변경</target>
        </trans-unit>
        <trans-unit id="472ea4d678f10230e80354665e55d5162f57e4eb" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">문자형 배열 ( &lt;code&gt;numpy.char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c77510e827185d4da42fdcbd8730a318064afdff" translate="yes" xml:space="preserve">
          <source>Character arrays (numpy.char)</source>
          <target state="translated">문자형 배열 (numpy.char)</target>
        </trans-unit>
        <trans-unit id="92c1e393951a713a4c1c2df5523a5b76ef600358" translate="yes" xml:space="preserve">
          <source>Character code</source>
          <target state="translated">문자 코드</target>
        </trans-unit>
        <trans-unit id="ba3973797ea212e06b4bd3f28ecf46f8274e1229" translate="yes" xml:space="preserve">
          <source>Character(s) used in replacement of white spaces in the variables names. By default, use a &amp;lsquo;_&amp;rsquo;.</source>
          <target state="translated">변수 이름에서 공백을 대체하는 데 사용되는 문자. 기본적으로 '_'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="faf08e2ed05138df0c2fc73c7cd9c35b89b1b4ee" translate="yes" xml:space="preserve">
          <source>Chebyshev</source>
          <target state="translated">Chebyshev</target>
        </trans-unit>
        <trans-unit id="b08808430b344bf934ff595f268dd7b3c9767d8c" translate="yes" xml:space="preserve">
          <source>Chebyshev Class</source>
          <target state="translated">체비 쇼프 클래스</target>
        </trans-unit>
        <trans-unit id="c805e26af7ca174190c79364ad41f4463c143779" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">체비 쇼프 모듈 ( &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="43b2dcb73cb4875580862bf8c8dd1ada4c4da4c6" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (numpy.polynomial.chebyshev)</source>
          <target state="translated">체비 쇼프 모듈 (numpy.polynomial.chebyshev)</target>
        </trans-unit>
        <trans-unit id="0efbe54789bc84b8d4e58d69167610bd2675854f" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서로 체비 쇼프 계수, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="96032d11ffc294810d816c812b7d22b436c23b79" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">체비 쇼프 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e63eba3c512c100441a580822bf3dee3fdc84ed" translate="yes" xml:space="preserve">
          <source>Chebyshev series</source>
          <target state="translated">체비 쇼프 시리즈</target>
        </trans-unit>
        <trans-unit id="f8c02252eba6ff12458afafb159b20cecff7478a" translate="yes" xml:space="preserve">
          <source>Chebyshev series of power.</source>
          <target state="translated">체비 쇼프 파워 시리즈.</target>
        </trans-unit>
        <trans-unit id="8a0ba9e6152e6c1500bb9491398112d62215acf4" translate="yes" xml:space="preserve">
          <source>Chebyshev series of the derivative.</source>
          <target state="translated">유도체의 체비 쇼프 시리즈.</target>
        </trans-unit>
        <trans-unit id="4f2d57204da6b30aece47fb6efed1a7b8e11e6b0" translate="yes" xml:space="preserve">
          <source>Chebyshev series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 체비 쇼프 시리즈.</target>
        </trans-unit>
        <trans-unit id="95aa0918943d1236cc6d32e54d1344d9d0be39c1" translate="yes" xml:space="preserve">
          <source>Chebyshev weight function.</source>
          <target state="translated">체비 쇼프 무게 기능.</target>
        </trans-unit>
        <trans-unit id="b18292f75bb94b7b116770748f5215372e100826" translate="yes" xml:space="preserve">
          <source>Chebyshev.__call__()</source>
          <target state="translated">Chebyshev.__call__()</target>
        </trans-unit>
        <trans-unit id="1bacc9adbf511d1e41a349b356ba0145d6ee7946" translate="yes" xml:space="preserve">
          <source>Chebyshev.basis()</source>
          <target state="translated">Chebyshev.basis()</target>
        </trans-unit>
        <trans-unit id="188210acd7ec982c8646fa316466c45a976f83f2" translate="yes" xml:space="preserve">
          <source>Chebyshev.cast()</source>
          <target state="translated">Chebyshev.cast()</target>
        </trans-unit>
        <trans-unit id="639e56acd1352c9b5b503ed1496fdb9a5d07c0c0" translate="yes" xml:space="preserve">
          <source>Chebyshev.convert()</source>
          <target state="translated">Chebyshev.convert()</target>
        </trans-unit>
        <trans-unit id="11392591347c8480770728aa505b563eccfa5f1d" translate="yes" xml:space="preserve">
          <source>Chebyshev.copy()</source>
          <target state="translated">Chebyshev.copy()</target>
        </trans-unit>
        <trans-unit id="41611d32208cae6870074acedaa6fe221b1b3446" translate="yes" xml:space="preserve">
          <source>Chebyshev.cutdeg()</source>
          <target state="translated">Chebyshev.cutdeg()</target>
        </trans-unit>
        <trans-unit id="8789ce0a4c5068fdfe534918cc2e90fdad042cd3" translate="yes" xml:space="preserve">
          <source>Chebyshev.degree()</source>
          <target state="translated">Chebyshev.degree()</target>
        </trans-unit>
        <trans-unit id="c6481905857e646a6d9c66a8532da7a6334a6377" translate="yes" xml:space="preserve">
          <source>Chebyshev.deriv()</source>
          <target state="translated">Chebyshev.deriv()</target>
        </trans-unit>
        <trans-unit id="6291088b6f8cbfecdb12bf2bdad126fa6f8f1e75" translate="yes" xml:space="preserve">
          <source>Chebyshev.domain</source>
          <target state="translated">Chebyshev.domain</target>
        </trans-unit>
        <trans-unit id="dd41304fdf8df9e37b5816500b41e22e66c61815" translate="yes" xml:space="preserve">
          <source>Chebyshev.fit()</source>
          <target state="translated">Chebyshev.fit()</target>
        </trans-unit>
        <trans-unit id="e4926f0eed8819f61f1604cce384a57795e1eabf" translate="yes" xml:space="preserve">
          <source>Chebyshev.fromroots()</source>
          <target state="translated">Chebyshev.fromroots()</target>
        </trans-unit>
        <trans-unit id="70d84e9f4f420d528a16ab4c0ba4755a5af5e65c" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samecoef()</source>
          <target state="translated">Chebyshev.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="119c3a01c7179401c8123c868c9643da34d59174" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samedomain()</source>
          <target state="translated">Chebyshev.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="1d9bea3b85c40da6ce150efb52fc340072577178" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_sametype()</source>
          <target state="translated">Chebyshev.has_sametype()</target>
        </trans-unit>
        <trans-unit id="21b9443d56e25c8c9434c2048384c54825cbad75" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samewindow()</source>
          <target state="translated">Chebyshev.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="f72f56cc281db3fc06403b01e30cee59ef5f1b34" translate="yes" xml:space="preserve">
          <source>Chebyshev.identity()</source>
          <target state="translated">Chebyshev.identity()</target>
        </trans-unit>
        <trans-unit id="4320540c12f7d006eb6f49d8596f1304f5f9b17f" translate="yes" xml:space="preserve">
          <source>Chebyshev.integ()</source>
          <target state="translated">Chebyshev.integ()</target>
        </trans-unit>
        <trans-unit id="c6cc890aac4433ddc758056a7a1ec57ab680d9dd" translate="yes" xml:space="preserve">
          <source>Chebyshev.interpolate()</source>
          <target state="translated">Chebyshev.interpolate()</target>
        </trans-unit>
        <trans-unit id="7c5cc657b6a0749c5b79e78f062d99b7bfa79e2e" translate="yes" xml:space="preserve">
          <source>Chebyshev.linspace()</source>
          <target state="translated">Chebyshev.linspace()</target>
        </trans-unit>
        <trans-unit id="318403bb4b0c9579e1e22548291a889f9ceb1ac1" translate="yes" xml:space="preserve">
          <source>Chebyshev.mapparms()</source>
          <target state="translated">Chebyshev.mapparms()</target>
        </trans-unit>
        <trans-unit id="e3d230253c27dda3445e4aef41453767831a496b" translate="yes" xml:space="preserve">
          <source>Chebyshev.roots()</source>
          <target state="translated">Chebyshev.roots()</target>
        </trans-unit>
        <trans-unit id="a90771ff29f5d5fd6c72cd284a6221aaeee66dbc" translate="yes" xml:space="preserve">
          <source>Chebyshev.trim()</source>
          <target state="translated">Chebyshev.trim()</target>
        </trans-unit>
        <trans-unit id="5b40364d3cb3cca7f44236a76dfee86aa086098b" translate="yes" xml:space="preserve">
          <source>Chebyshev.truncate()</source>
          <target state="translated">Chebyshev.truncate()</target>
        </trans-unit>
        <trans-unit id="68b29a44de315b426add922aecd8f169abef4bb9" translate="yes" xml:space="preserve">
          <source>Check for a complex type or an array of complex numbers.</source>
          <target state="translated">복소수 유형 또는 복소수 배열을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4bce08324cf028acd33defa95adda2d8f712ca10" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 77 compiler.</source>
          <target state="translated">Fortran 77 컴파일러의 가용성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8dfb4b491ef798ee13273ce6b905820e38be579c" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 90 compiler.</source>
          <target state="translated">Fortran 90 컴파일러의 가용성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fc680846edbe0485cdd86c89e2d8ba596476a1dd" translate="yes" xml:space="preserve">
          <source>Check if coefficients match.</source>
          <target state="translated">계수가 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d9700aa50368965f26007e9ef6dc12172f836968" translate="yes" xml:space="preserve">
          <source>Check if domains match.</source>
          <target state="translated">도메인이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7cda7e0160467a48240d75643f9aa9dd2aa8c3ec" translate="yes" xml:space="preserve">
          <source>Check if the array is Fortran contiguous but &lt;em&gt;not&lt;/em&gt; C contiguous.</source>
          <target state="translated">배열이 Fortran 인접하지만 C 인접 &lt;em&gt;하지&lt;/em&gt; 않은지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a996762c75a9633231bd44ab99dd3f19880ea7" translate="yes" xml:space="preserve">
          <source>Check if types match.</source>
          <target state="translated">유형이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d606aa3664f58aff3cd51e12c1f4292532053db" translate="yes" xml:space="preserve">
          <source>Check if windows match.</source>
          <target state="translated">창이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2fb7aaaa0fefc98b63923082fcb9b881a92a1f09" translate="yes" xml:space="preserve">
          <source>Check that all items of arrays differ in at most N Units in the Last Place.</source>
          <target state="translated">마지막 배열에서 배열의 모든 항목이 최대 N 개 단위가 다른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7eaa6b9db4d409e9c0e745dc239854957e8b786b" translate="yes" xml:space="preserve">
          <source>Check that the solution is correct:</source>
          <target state="translated">솔루션이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="abd3adad63a405998bb8027f9dd962bdd792cf51" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is Fortran contiguous. If so, return the input pointer and flag it as not a new object. If it is not Fortran contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 가 포트란 연속 인지 확인하십시오 . 그렇다면 입력 포인터를 반환하고 새 객체가 아닌 것으로 플래그를 지정하십시오. 포트란이 연속적이지 않은 경우 , 원래 데이터를 사용하여 새 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 생성 하고 새 객체로 플래그를 지정하고 포인터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6deabec9ba29d971d99676bd19f94bb36aab8ebd" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return the input pointer and flag it as not a new object. If it is not contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 가 연속 되어 있는지 확인하십시오 . 그렇다면 입력 포인터를 반환하고 새 객체가 아닌 것으로 플래그를 지정하십시오. 연속적이지 않으면 원래 데이터를 사용하여 새 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 만들고 새 개체로 플래그를 지정하고 포인터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7093331a27bd647ef152d8be9e2ae4a45e799c24" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result.</source>
          <target state="translated">반복이 남아 있는지 확인하고 결과를 리턴하지 않고 단일 내부 반복을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4144c2e0e789ff4e5b95e42eba75f165eee47a48" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result. Used in the C-style pattern do-while pattern. For an example, see &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복이 남아 있는지 확인하고 결과를 리턴하지 않고 단일 내부 반복을 수행하십시오. C 스타일 패턴 do-while 패턴에 사용됩니다. 예를 들어, &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed69b345e7c215832e51813de9d917baa4aa81d3" translate="yes" xml:space="preserve">
          <source>Check whether other does not equal self elementwise.</source>
          <target state="translated">다른 사람이 자기 적으로 요소가 아닌지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3d82cd61f57b9f18ee0eb4fb316060ba43247d8" translate="yes" xml:space="preserve">
          <source>Check whether other equals self elementwise.</source>
          <target state="translated">다른 요소가 요소와 같은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="434cdb1d625c09ab1050578e35a57522602ea24b" translate="yes" xml:space="preserve">
          <source>Checking the API Version</source>
          <target state="translated">API 버전 확인</target>
        </trans-unit>
        <trans-unit id="283049748626c9020e205907bb7476f70c9b37e7" translate="yes" xml:space="preserve">
          <source>Checks to see whether this is the first time the elements of the specified reduction operand which the iterator points at are being seen for the first time. The function returns a reasonable answer for reduction operands and when buffering is disabled. The answer may be incorrect for buffered non-reduction operands.</source>
          <target state="translated">반복자가 가리키는 지정된 축소 피연산자의 요소가 처음으로 보이는지 여부를 확인합니다. 이 함수는 축소 피연산자 및 버퍼링이 비활성화 된 경우 합리적인 답변을 반환합니다. 버퍼링 된 비 환원 피연산자에 대한 대답이 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa157d59451a76fbaaa96b55717e70ff4070a919" translate="yes" xml:space="preserve">
          <source>Chhikara, Raj S., and Folks, J. Leroy, &amp;ldquo;The Inverse Gaussian Distribution: Theory : Methodology, and Applications&amp;rdquo;, CRC Press, 1988.</source>
          <target state="translated">Chkara, Raj S. 및 Folks, J. Leroy,&amp;ldquo;역 가우스 분포 : 이론 : 방법론 및 응용 프로그램&amp;rdquo;, CRC Press, 1988.</target>
        </trans-unit>
        <trans-unit id="fdf0f4fddeb5edfe094f89b612af6bf23fbbf5d9" translate="yes" xml:space="preserve">
          <source>Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects can also spawn to make grandchildren, and so on. Each &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; has its position in the tree of spawned &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects mixed in with the user-provided seed to generate independent (with very high probability) streams.</source>
          <target state="translated">Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 객체는 손자를 만들기 위해 생성 될 수도 있습니다. 각 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 는 생성 된 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 오브젝트 트리 에서 사용자 제공 시드와 혼합하여 독립적 (매우 높은 확률로) 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a10cdc107364498984b83536b7e81520a19b878" translate="yes" xml:space="preserve">
          <source>Choice arrays. &lt;code&gt;a&lt;/code&gt; and all of the choices must be broadcastable to the same shape. If &lt;code&gt;choices&lt;/code&gt; is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to &lt;code&gt;choices.shape[0]&lt;/code&gt;) is taken as defining the &amp;ldquo;sequence&amp;rdquo;.</source>
          <target state="translated">선택 배열. 선택과 모두 같은 모양 캐스트 가능한해야합니다. 경우 &lt;code&gt;choices&lt;/code&gt; 자체 배열 (권장하지 않음), 그 후 최 사이즈 (즉, 대응하는 하나 &lt;code&gt;choices.shape[0]&lt;/code&gt; )를 &quot;시퀀스&quot;를 정의로한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ad7147824c2ea94d6560122c459caa4f4c34051" translate="yes" xml:space="preserve">
          <source>Choice arrays. The index array and all of the choices should be broadcastable to the same shape.</source>
          <target state="translated">선택 배열. 인덱스 배열과 모든 선택 사항은 같은 모양으로 브로드 캐스트 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3423d9c2caf056a50af1e5e388fbc351b162a74e" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition.</source>
          <target state="translated">hole 레 스키 분해.</target>
        </trans-unit>
        <trans-unit id="2ca2864418456f81d23c002bcfa240f2d8fca295" translate="yes" xml:space="preserve">
          <source>Choose five random numbers from the set of five evenly-spaced numbers between 0 and 2.5, inclusive (&lt;em&gt;i.e.&lt;/em&gt;, from the set</source>
          <target state="translated">0에서 2.5 사이의 균등 간격 숫자 5 개 세트에서 5 개의 난수를 선택하십시오 ( &lt;em&gt;예 :&lt;/em&gt; 세트에서</target>
        </trans-unit>
        <trans-unit id="35c9a25e2ab923acd6164ad4d06282c1e090295d" translate="yes" xml:space="preserve">
          <source>Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size.</source>
          <target state="translated">경로 유형을 선택하십시오. 튜플이 제공되면 두 번째 인수는 작성된 최대 중간 크기 인 것으로 가정합니다. 단일 인수 만 제공되는 경우 가장 큰 입력 또는 출력 배열 크기가 최대 중간 크기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6410e1ff6dea4bdf660fd03e09261c2e8c92a4a7" translate="yes" xml:space="preserve">
          <source>Christian Kleiber, Samuel Kotz, &amp;ldquo;Statistical size distributions in economics and actuarial sciences&amp;rdquo;, Wiley, 2003.</source>
          <target state="translated">Christian Kleiber, Samuel Kotz,&amp;ldquo;경제 및 계리 과학의 통계적 규모 분포&amp;rdquo;, Wiley, 2003.</target>
        </trans-unit>
        <trans-unit id="e799166bb71b4dde11ab28b58f6eff13ee75f067" translate="yes" xml:space="preserve">
          <source>Class for one-dimensional polynomials.</source>
          <target state="translated">1 차원 다항식 클래스.</target>
        </trans-unit>
        <trans-unit id="141f83ee32f213c3c3e30b940039c0256ca45642" translate="yes" xml:space="preserve">
          <source>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, despite many consequent attributes being either &amp;ldquo;get-only,&amp;rdquo; or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</source>
          <target state="translated">대부분의 (모든?) numpy 스칼라 유형이 파생되는 클래스입니다. 일관성을 위해 많은 결과 속성이 &quot;get-only&quot;또는 완전히 관련이 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 와 동일한 API를 노출합니다 . 이 클래스는 사용자가 사용자 지정 스칼라 형식을 파생시켜야하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f3a9c0c7155c7f2627130b00e8664e0c47570c98" translate="yes" xml:space="preserve">
          <source>Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API.</source>
          <target state="translated">제네릭 클래스는 단일 API를 제공하기 위해 ndarray 클래스의 모든 속성에서 numpy 스칼라를 도출하고 구현하지는 않지만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="50af8b2f53e369e6ce37192f4f707fa498a94b5e" translate="yes" xml:space="preserve">
          <source>Class instance.</source>
          <target state="translated">클래스 인스턴스.</target>
        </trans-unit>
        <trans-unit id="2785358c74196dd17652dd76c2cb1f0e3a27dcf4" translate="yes" xml:space="preserve">
          <source>Class of the underlying data (read-only).</source>
          <target state="translated">기본 데이터의 클래스 (읽기 전용).</target>
        </trans-unit>
        <trans-unit id="631eda8579e2970ff77106029d682f1124ccd882" translate="yes" xml:space="preserve">
          <source>Class to convert formats, names, titles description to a dtype.</source>
          <target state="translated">형식, 이름, 제목 설명을 dtype으로 변환하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="70956031e8aba40d5608418084c786b47da059e0" translate="yes" xml:space="preserve">
          <source>Class whose methods to decorate.</source>
          <target state="translated">메소드를 장식 할 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="94a0e1eeea610589ba223c0aebbf56c35a8d5343" translate="yes" xml:space="preserve">
          <source>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;Standard array subclasses&lt;/a&gt;.</source>
          <target state="translated">클래스 (ndarray 서브 클래스 포함)는 특정 특수 메소드를 정의하여 ufunc가 클래스에 대해 수행하는 방식을 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;표준 배열 하위 클래스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0716551020b700fbc40d6da11a6a973469d6550e" translate="yes" xml:space="preserve">
          <source>Clear the IEEE error flags.</source>
          <target state="translated">IEEE 오류 플래그를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="69cde09c8e5adab6b0a10f29c8e8089827660cd3" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call. Returns the previous status mask.</source>
          <target state="translated">부동 소수점 상태를 지 웁니다. 공격적인 컴파일러 최적화가이 함수 호출을 다시 지정하지 못하도록 로컬 변수에 대한 포인터가 전달됩니다. 이전 상태 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85631dab84756553305933ab9884fa05e7033c9b" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. Returns the previous status mask.</source>
          <target state="translated">부동 소수점 상태를 지 웁니다. 이전 상태 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95fd8bb886c035e55cfc935aa6369ec4437d9dba" translate="yes" xml:space="preserve">
          <source>Clears the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">지정된 배열 플래그를 지 웁니다. 이 함수는 유효성 검사를 수행하지 않으며 수행중인 작업을 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0259cd63a54e3479014d0b233265a7cb8a0c929d" translate="yes" xml:space="preserve">
          <source>Clip (limit) the values in an array.</source>
          <target state="translated">배열의 값을 클립 (제한)합니다.</target>
        </trans-unit>
        <trans-unit id="10b5f7285e869f556c319cd6389b16c1806e6590" translate="yes" xml:space="preserve">
          <source>Clipping and rounding</source>
          <target state="translated">클리핑 및 반올림</target>
        </trans-unit>
        <trans-unit id="01110fe45ef307b0f0fc59a0a0494616ad2d9d3c" translate="yes" xml:space="preserve">
          <source>Clips an index to the valid range if it is out of bounds.</source>
          <target state="translated">범위를 벗어난 경우 인덱스를 유효한 범위로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="4c6d56aa06140201b957d61e514a687a45637be2" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 32-bit system.</source>
          <target state="translated">32 비트 시스템의 &quot;안전하게 캐스트 가능&quot;테이블을 표시하는 코드 세그먼트입니다.</target>
        </trans-unit>
        <trans-unit id="4880c50f2ea2d547641da09b4c0bf604cbaad4e6" translate="yes" xml:space="preserve">
          <source>Coefficient array of the integral.</source>
          <target state="translated">적분의 계수 배열.</target>
        </trans-unit>
        <trans-unit id="90095bbe595b4717b5f28520d7191bc7b67d082b" translate="yes" xml:space="preserve">
          <source>Coefficient matrix.</source>
          <target state="translated">계수 행렬.</target>
        </trans-unit>
        <trans-unit id="7ff4e0921ad16edc7282af8e661233be9efdef85" translate="yes" xml:space="preserve">
          <source>Coefficient tensor, of shape &lt;code&gt;b.shape + Q&lt;/code&gt;. &lt;code&gt;Q&lt;/code&gt;, a tuple, equals the shape of that sub-tensor of &lt;code&gt;a&lt;/code&gt; consisting of the appropriate number of its rightmost indices, and must be such that &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (in which sense &lt;code&gt;a&lt;/code&gt; is said to be &amp;lsquo;square&amp;rsquo;).</source>
          <target state="translated">모양이 &lt;code&gt;b.shape + Q&lt;/code&gt; 인 계수 텐서 . &lt;code&gt;Q&lt;/code&gt; , 튜플은, 그 서브 텐서의 형상과 동일 그 우측 인덱스의 적절한 수 이루어지는을 한 것이어야한다 &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (여기서 감지 라고 '평방'이어야합니다.) &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f7d7eca3d654d7516012e0321be8d2b34b3af6d" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the quotient.</source>
          <target state="translated">몫의 0을 포함하여 계수.</target>
        </trans-unit>
        <trans-unit id="b57ec6a0b2d77f8f2ef4d5e927f014b094bd79db" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the remainder.</source>
          <target state="translated">나머지의 0과 같은 것을 포함한 계수.</target>
        </trans-unit>
        <trans-unit id="3a433dc0365548604b9b44d97f7bfbf6e88d77aa" translate="yes" xml:space="preserve">
          <source>Combination of &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt;&lt;code&gt;PyArray_FROM_OF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt;&lt;code&gt;PyArray_FROM_OT&lt;/code&gt;&lt;/a&gt; allowing both a &lt;em&gt;typenum&lt;/em&gt; and a &lt;em&gt;flags&lt;/em&gt; argument to be provided.</source>
          <target state="translated">조합 &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt; &lt;code&gt;PyArray_FROM_OF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt; &lt;code&gt;PyArray_FROM_OT&lt;/code&gt; 는&lt;/a&gt; 둘 다를 수 &lt;em&gt;typenum&lt;/em&gt; 와 &lt;em&gt;플래그&lt;/em&gt; 인수가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1825a72b8523c42869f6ed18e25b4d98c6db9809" translate="yes" xml:space="preserve">
          <source>Combinations of array flags</source>
          <target state="translated">배열 플래그의 조합</target>
        </trans-unit>
        <trans-unit id="04f619e0125978268f6037fab0f4bee54fa7538a" translate="yes" xml:space="preserve">
          <source>Combine two masks with the &lt;code&gt;logical_or&lt;/code&gt; operator.</source>
          <target state="translated">두 개의 마스크를 &lt;code&gt;logical_or&lt;/code&gt; 연산자 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac4e580a3225536b502c2bf6b739b38d8c6dc235" translate="yes" xml:space="preserve">
          <source>Combining advanced and basic indexing</source>
          <target state="translated">고급 인덱싱과 기본 인덱싱 결합</target>
        </trans-unit>
        <trans-unit id="6db9979c1fe0813b3eb2ee3a9a6ae24f7e5faea6" translate="yes" xml:space="preserve">
          <source>Combining multiple Boolean indexing arrays or a Boolean with an integer indexing array can best be understood with the &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; analogy. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; also supports boolean arrays and will work without any surprises.</source>
          <target state="translated">여러 부울 인덱싱 배열 또는 부울을 정수 인덱싱 배열과 결합하는 것은 &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; 유추로 가장 잘 이해할 수 있습니다 . &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 함수 는 부울 배열도 지원하며 놀랍지 않게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="39a64d591310ffe84aa9b684771a7d278ba716a5" translate="yes" xml:space="preserve">
          <source>Comma delimited file with mixed dtype</source>
          <target state="translated">dtype이 혼합 된 쉼표로 구분 된 파일</target>
        </trans-unit>
        <trans-unit id="39a95105f6ae1d2c8ab5b77d2df7fa0bdc43b7b9" translate="yes" xml:space="preserve">
          <source>Common test support for all numpy test scripts.</source>
          <target state="translated">모든 numpy 테스트 스크립트에 대한 공통 테스트 지원.</target>
        </trans-unit>
        <trans-unit id="c2a68a63dc41f356e6d15c8c535eea2cf026660b" translate="yes" xml:space="preserve">
          <source>Companion matrix of dimensions (deg, deg).</source>
          <target state="translated">치수의 동반 행렬 (도,도).</target>
        </trans-unit>
        <trans-unit id="38428edac9ae2355adbd42053821bdf711ded835" translate="yes" xml:space="preserve">
          <source>Compare against built-in broadcasting:</source>
          <target state="translated">내장 된 방송과 비교 :</target>
        </trans-unit>
        <trans-unit id="b5977dbb9726befd30db9317959bca3faeb91b26" translate="yes" xml:space="preserve">
          <source>Compare the power function distribution to the inverse of the Pareto.</source>
          <target state="translated">거듭 제곱 분포를 파레토의 역수와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="abbe4b051440d5c3941fb5ca3a1c58883bee0b7d" translate="yes" xml:space="preserve">
          <source>Compare two array_like objects for equality with desired relative and/or absolute precision.</source>
          <target state="translated">두 개의 array_like 객체를 원하는 상대 및 / 또는 절대 정밀도와 같은지 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="6e9c538fcc856b4c5b41ccf954d897e3fba11150" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최대 값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 해당 요소가 리턴됩니다. 두 요소 모두 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="52e468afc192be1b2f72e0bc9d7f9f138350a871" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최대 값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 Nan이 아닌 요소가 반환됩니다. 두 요소 모두 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN은 가능한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ace9cb4b9063e509209a97ac371136964f6f7819" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최소값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 해당 요소가 리턴됩니다. 두 요소 모두 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="89c593ddd4725e7eb3064d75c349a4174bbacd17" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최소값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 Nan이 아닌 요소가 반환됩니다. 두 요소 모두 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN은 가능한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bc6a4145f838627dea20878218beb3ec59a9a475" translate="yes" xml:space="preserve">
          <source>Compare two arrays relatively to their spacing.</source>
          <target state="translated">두 배열을 간격과 상대적으로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="38460977eefc5ad076607c73457ab20f90eef5d2" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장하지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="37a1ac805be872bfc7e003c20b71f2f1bbbc823c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장하지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="d83995123f5ea98603e646a9178fcfffebb1958a" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.recarray.item#numpy.recarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장하지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.recarray.item#numpy.recarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c659be692ea2a97bb2ad6d27d767ba11002c5a0f" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 != h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1! = h2).</target>
        </trans-unit>
        <trans-unit id="a8531600ccd3e5208344582224d725dc6447d471" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;gt; h2).</source>
          <target state="translated">반 정밀도 부동 소수점 2 개를 비교합니다 (h1&amp;gt; h2).</target>
        </trans-unit>
        <trans-unit id="1fe54d41d33ca7b444169273c69fa5061d6e3f69" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;gt;= h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1&amp;gt; = h2).</target>
        </trans-unit>
        <trans-unit id="09c74964a2a76ed9d39c659abab42ad8913ca62f" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;lt; h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;h2).</target>
        </trans-unit>
        <trans-unit id="09ca56b6c4b7cdb0aacabc3d8ecbb1eef0726cc8" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;lt;= h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;= h2).</target>
        </trans-unit>
        <trans-unit id="2a372af75f04fe5db91b2eb992a65a4b830bbcda" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 == h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 == h2).</target>
        </trans-unit>
        <trans-unit id="6569476619ffc6f6e8942d6f762781ba11246ce3" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 &amp;lt; h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6caa81fd2bc3f158b7e80b5e938442169d219755" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 &amp;lt;= h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;= h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2488158fc090106e7c705b17853d535c32a0c590" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 == h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 == h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dff584999fbb6cd5911aa30f1590245afbbe3b17" translate="yes" xml:space="preserve">
          <source>Comparing Performance</source>
          <target state="translated">성능 비교</target>
        </trans-unit>
        <trans-unit id="eea251154fb167c3cc620efaacead79a92ce4964" translate="yes" xml:space="preserve">
          <source>Comparing needs to be done against a valid version string or other &lt;a href=&quot;#numpy.lib.NumpyVersion&quot;&gt;&lt;code&gt;NumpyVersion&lt;/code&gt;&lt;/a&gt; instance. Note that all development versions of the same (pre-)release compare equal.</source>
          <target state="translated">유효한 버전 문자열 또는 다른 &lt;a href=&quot;#numpy.lib.NumpyVersion&quot;&gt; &lt;code&gt;NumpyVersion&lt;/code&gt; &lt;/a&gt; 인스턴스 와 비교해야 합니다. 동일한 (사전) 릴리스의 모든 개발 버전은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2dfcf898a3bd4e011123eee87384ecb67d0919d4" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="translated">Comparison</target>
        </trans-unit>
        <trans-unit id="b25204cbd4bfc02484e2851632d991b06eb495ce" translate="yes" xml:space="preserve">
          <source>Comparison functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7de33d110c915ab8e665813e77fafb72e84afb2" translate="yes" xml:space="preserve">
          <source>Comparison operators:</source>
          <target state="translated">비교 연산자 :</target>
        </trans-unit>
        <trans-unit id="2f12ca1e5a55a63736464971fc76ee35d3a18342" translate="yes" xml:space="preserve">
          <source>Comparison value</source>
          <target state="translated">비교 가치</target>
        </trans-unit>
        <trans-unit id="7f4c99d898504a4d469f2c56fcd16f51caf889ab" translate="yes" xml:space="preserve">
          <source>Compatible with &lt;a href=&quot;https://docs.python.org/dev/library/random.html#random.random&quot;&gt;&lt;code&gt;random.random&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/random.html#random.random&quot;&gt; &lt;code&gt;random.random&lt;/code&gt; &lt;/a&gt; 과 호환</target>
        </trans-unit>
        <trans-unit id="9674cbe94fc34b0813752dbf21ea3ff49c519ffa" translate="yes" xml:space="preserve">
          <source>Compiler directives</source>
          <target state="translated">컴파일러 지시문</target>
        </trans-unit>
        <trans-unit id="ff834855dd2cb771e7308c2c45e567479f89e7e7" translate="yes" xml:space="preserve">
          <source>Complete path, including the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; destination directory.</source>
          <target state="translated">&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 대상 디렉토리를 포함한 전체 경로</target>
        </trans-unit>
        <trans-unit id="de68f54a7ada83b34c3c594c6d6dc315f2d1dff5" translate="yes" xml:space="preserve">
          <source>Complex dtypes are not supported, they will raise a TypeError.</source>
          <target state="translated">복잡한 dtype은 지원되지 않으며 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa65be528af88fb5c8a75d1c112c51079bcd9e1b" translate="yes" xml:space="preserve">
          <source>Complex floating point</source>
          <target state="translated">복잡한 부동 소수점</target>
        </trans-unit>
        <trans-unit id="50b56f643c3c403eee6bc18311217c2110cfc3d1" translate="yes" xml:space="preserve">
          <source>Complex floating-point numbers:</source>
          <target state="translated">복잡한 부동 소수점 숫자 :</target>
        </trans-unit>
        <trans-unit id="5b80d64d624d4f3ca65bbe7239e385812c1d03ee" translate="yes" xml:space="preserve">
          <source>Complex functions</source>
          <target state="translated">복잡한 기능</target>
        </trans-unit>
        <trans-unit id="0fa9ea03df83d22c3ed69e97864b69f2e7260411" translate="yes" xml:space="preserve">
          <source>Complex interpolation:</source>
          <target state="translated">복잡한 보간 :</target>
        </trans-unit>
        <trans-unit id="a65b5b7a1200ae7ef93272975b6c56910310c564" translate="yes" xml:space="preserve">
          <source>Complex is of a different type, so it up-casts the float in the &lt;code&gt;array_types&lt;/code&gt; argument:</source>
          <target state="translated">Complex는 다른 유형이므로 &lt;code&gt;array_types&lt;/code&gt; 인수 에서 float를 업 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="44fc04a3b7819c72bdc8be8966689f3ecd87dbfd" translate="yes" xml:space="preserve">
          <source>Complex-conjugate all elements.</source>
          <target state="translated">모든 요소를 ​​복합적으로 활용합니다.</target>
        </trans-unit>
        <trans-unit id="3ff5cadccad2941be3aad490dcbf596e9e2f1f26" translate="yes" xml:space="preserve">
          <source>Complex-conjugating dot product.</source>
          <target state="translated">복잡한 복합 도트 제품.</target>
        </trans-unit>
        <trans-unit id="f14b349bf9b6f0598bc456bea6a626f511dd720b" translate="yes" xml:space="preserve">
          <source>Complex-valued matrix with real e-values (but complex-valued e-vectors); note that &lt;code&gt;a.conj().T == a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is Hermitian.</source>
          <target state="translated">실제 e- 값을 갖는 복소수 행렬 (그러나 복소수 e- 벡터); 참고 &lt;code&gt;a.conj().T == a&lt;/code&gt; , 즉, &lt;code&gt;a&lt;/code&gt; 에르 미트이다.</target>
        </trans-unit>
        <trans-unit id="4745229c055fca9c55de4f5e19158b64c4e46c7f" translate="yes" xml:space="preserve">
          <source>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</source>
          <target state="translated">콤플렉스 : [R + Rj, R + nanj, nan + Rj, nan + nanj]</target>
        </trans-unit>
        <trans-unit id="07214e21bcf968861459229df35bdc3eb2301560" translate="yes" xml:space="preserve">
          <source>Components of the first vector(s).</source>
          <target state="translated">첫 번째 벡터의 구성 요소.</target>
        </trans-unit>
        <trans-unit id="034a68a3b46b5f19a8396a79ba6059edc518f621" translate="yes" xml:space="preserve">
          <source>Components of the second vector(s).</source>
          <target state="translated">두 번째 벡터의 구성 요소.</target>
        </trans-unit>
        <trans-unit id="45f45d1eb6794f5e653fdc744d97f27b67ca97c3" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;y = x1 * 2**x2&lt;/code&gt;, the inverse of &lt;a href=&quot;#numpy.frexp&quot;&gt;&lt;code&gt;frexp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">계산 &lt;code&gt;y = x1 * 2**x2&lt;/code&gt; 의 역 &lt;a href=&quot;#numpy.frexp&quot;&gt; &lt;code&gt;frexp&lt;/code&gt; 와&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c64182221e47c35867a7af81c848c36fa6d8bc1" translate="yes" xml:space="preserve">
          <source>Compute a matrix transpose, or reorder any number of axes:</source>
          <target state="translated">행렬 전치를 계산하거나 축의 수를 재정렬합니다.</target>
        </trans-unit>
        <trans-unit id="13e5ab403f3a3a2b71e3a1b4880046ec10502553" translate="yes" xml:space="preserve">
          <source>Compute a product-sum over the last dimension of &lt;em&gt;obj1&lt;/em&gt; and the second-to-last dimension of &lt;em&gt;obj2&lt;/em&gt;. For 2-d arrays this is a matrix-product. Neither array is conjugated.</source>
          <target state="translated">&lt;em&gt;obj1의&lt;/em&gt; 마지막 차원과 &lt;em&gt;obj2&lt;/em&gt; 의 두 번째 에서 마지막 차원에 대한 곱 합계를 계산합니다 . 2 차원 배열의 경우 이것은 행렬 곱입니다. 배열이 공액되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="056b92ccdbc0e24b6f67de04cffc75083bf356ab" translate="yes" xml:space="preserve">
          <source>Compute a product-sum over the last dimensions of &lt;em&gt;obj1&lt;/em&gt; and &lt;em&gt;obj2&lt;/em&gt;. Neither array is conjugated.</source>
          <target state="translated">&lt;em&gt;obj1&lt;/em&gt; 및 &lt;em&gt;obj2&lt;/em&gt; 의 마지막 차원에 대해 곱셈 합계를 계산합니다 . 배열이 공액되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7a1e013a739673e66d447edae1fe867b62d357" translate="yes" xml:space="preserve">
          <source>Compute an array where the subarrays contain index values 0, 1, &amp;hellip; varying only along the corresponding axis.</source>
          <target state="translated">서브 어레이에 인덱스 값 0, 1,&amp;hellip;이 해당 축을 따라서 만 변하는 배열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="947fc265208178db651870062fcd800d2541aa5f" translate="yes" xml:space="preserve">
          <source>Compute bit-wise inversion, or bit-wise NOT, element-wise.</source>
          <target state="translated">비트 단위 반전 또는 비트 단위 NOT을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4fa591d9d9af402206493fb5fda8248cb6f1c024" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent element-wise.</source>
          <target state="translated">쌍곡선 탄젠트를 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a87a1fe24ae7fbea279764c44fdccdccf954c207" translate="yes" xml:space="preserve">
          <source>Compute polynomial values.</source>
          <target state="translated">다항식 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="068ac2c1a4127e2fed43429a48f36264cc85457c" translate="yes" xml:space="preserve">
          <source>Compute tangent element-wise.</source>
          <target state="translated">접선을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d300b4bcd09d963652013deebe8168c3c89562c2" translate="yes" xml:space="preserve">
          <source>Compute tensor dot product along specified axes.</source>
          <target state="translated">지정된 축을 따라 텐서 도트 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fa371bab50ec7f5949bcd135ca6f29870a08c615" translate="yes" xml:space="preserve">
          <source>Compute the &amp;lsquo;inverse&amp;rsquo; of an N-dimensional array.</source>
          <target state="translated">N 차원 배열의 '역'을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fc5bbebd14e559d5af2472fcb7cd8cae4c38dfea" translate="yes" xml:space="preserve">
          <source>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</source>
          <target state="translated">행렬의 (무어-펜로즈) 의사 역수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7a0d3b8cffb38e55193b71b10895c89358380d6f" translate="yes" xml:space="preserve">
          <source>Compute the (multiplicative) inverse of a matrix.</source>
          <target state="translated">행렬의 (곱하기) 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ce317ec0f3a7246ebde3c56c949a94474c644f2c" translate="yes" xml:space="preserve">
          <source>Compute the 1-d correlation of the 1-d arrays &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; . The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">1 차원 배열 &lt;em&gt;op1&lt;/em&gt; 과 &lt;em&gt;op2&lt;/em&gt; 의 1 차원 상관 관계를 계산합니다 . &lt;em&gt;op1&lt;/em&gt; 에 시프트 된 버전의 &lt;em&gt;op2&lt;/em&gt; 를 곱하고 결과를 합산하여 각 출력 지점에서 상관 관계가 계산됩니다 . 시프트의 결과로 정의 된 &lt;em&gt;op1&lt;/em&gt; 및 &lt;em&gt;op2&lt;/em&gt; 범위를 벗어난 필요한 값 은 0으로 해석됩니다. 모드는 리턴 할 시프트 수를 결정합니다. 0-0 값을 가정 할 필요가없는 시프트 만 리턴합니다. 1- &lt;em&gt;op1&lt;/em&gt; 과 동일한 크기의 객체를 반환합니다 . 2-가능한 모든 시프트를 반환합니다 (모든 오버랩이 허용됨).</target>
        </trans-unit>
        <trans-unit id="c0d44872f577915a6980faf8dd21743d44adf9e2" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional FFT of a real array.</source>
          <target state="translated">실수 배열의 2 차원 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d178e7eb58c146939d28cee1561c739e0e5a7a6e" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional discrete Fourier Transform</source>
          <target state="translated">2 차원 이산 푸리에 변환 계산</target>
        </trans-unit>
        <trans-unit id="67a3a6e456306d80e1a85f7bd3abf35885e3417f" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional inverse FFT of a real array.</source>
          <target state="translated">실수 배열의 2 차원 역 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5dab8bf12f8acb88adf197e9679d392f9686e8f0" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">2 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e520eedb99a35ab7b8e9d96c9ee884bd6396de95" translate="yes" xml:space="preserve">
          <source>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.</source>
          <target state="translated">에르 미트 (Hermitian) 대칭, 즉 실제 스펙트럼을 갖는 신호의 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8d0c346e5e8eee0d8b840c557de8c1fb49e608f2" translate="yes" xml:space="preserve">
          <source>Compute the Heaviside step function.</source>
          <target state="translated">헤비 사이드 단계 함수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0af5dc6ec4bce95c7deeb2e22d43be085363a3c4" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional discrete Fourier Transform for real input.</source>
          <target state="translated">실제 입력을 위해 N 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="618a9fedeaaa9d126c314769627bca84416583fd" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional discrete Fourier Transform.</source>
          <target state="translated">N 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e7cb154cbbc3ce37f25f7537fe58a126b7946394" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">N 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fdada9bbbb0e0feab597366ef4af60a51ac07565" translate="yes" xml:space="preserve">
          <source>Compute the absolute values element-wise.</source>
          <target state="translated">절대 값을 요소 단위로 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="854c7a30aceed6c65bd1930d3f73b4435d8fefe0" translate="yes" xml:space="preserve">
          <source>Compute the anomalies (deviations from the arithmetic mean) along the given axis.</source>
          <target state="translated">주어진 축을 따라 비정상 (산술 평균에서 벗어난)을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="032bf5a750caf3fcc37d976c4abec0978e892339" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic mean along the specified axis, ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 산술 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c27697f73833b9f50c1ae272faa6ca6a07b48429" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic mean along the specified axis.</source>
          <target state="translated">지정된 축을 따라 산술 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d2a56a9fc18ac2ca14dd4e52739d766778e94a9f" translate="yes" xml:space="preserve">
          <source>Compute the bi-dimensional histogram of two data samples.</source>
          <target state="translated">두 데이터 샘플의 2 차원 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8d0e71a5459a34a1c578cae96fc1cfe3bd566fe6" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise AND of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 AND를 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e7eb6c1c60d6349cc90d5c8c4320d954c000c524" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise OR of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 OR을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="55b35d5464c0530c89b3ec03e495b9078bf4cf47" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise XOR of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 XOR을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f5acd6ba924e2efb344c13dbed92e0c329da8c41" translate="yes" xml:space="preserve">
          <source>Compute the condition number of a matrix.</source>
          <target state="translated">행렬의 조건 번호를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b1c67fc04779c3f2a70b86099aedfddb41f66c14" translate="yes" xml:space="preserve">
          <source>Compute the determinant of an array.</source>
          <target state="translated">배열의 결정자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b702821ff84d14c559452b05bb97c2de7fb25e9d" translate="yes" xml:space="preserve">
          <source>Compute the differences between consecutive elements of an array.</source>
          <target state="translated">배열의 연속 요소 간 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="951e81c96daf183677546cd31bf58f658274b345" translate="yes" xml:space="preserve">
          <source>Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.</source>
          <target state="translated">단일 함수 호출에서 둘 이상의 배열의 내적을 계산하면서 가장 빠른 평가 순서를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6d2ef25b4e32887cf6b0d4b62f770b736c0bf3b1" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues and right eigenvectors of a square array.</source>
          <target state="translated">정사각형 배열의 고유 값과 오른쪽 고유 벡터를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7972ade8ee96398f7c3dca6dc7f1e5fbe1dee9f0" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</source>
          <target state="translated">복잡한 Hermitian 또는 실제 대칭 행렬의 고유 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="df2018ad5cc925c4bd2d8d45424431e34663700a" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues of a general matrix.</source>
          <target state="translated">일반 행렬의 고유 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e2e2b6e6567897f80498047d4b073da0348b1fe0" translate="yes" xml:space="preserve">
          <source>Compute the future value.</source>
          <target state="translated">미래 가치를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ca53316c69a9d7dff355b503668c1872713b22a1" translate="yes" xml:space="preserve">
          <source>Compute the histogram of a set of data.</source>
          <target state="translated">데이터 집합의 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="089040bb2e30a76919dc623b5c63558c7963e5b8" translate="yes" xml:space="preserve">
          <source>Compute the interest portion of a payment.</source>
          <target state="translated">지불의이자 부분을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="deed0637d0888d671ccf558d5297ba636b52a784" translate="yes" xml:space="preserve">
          <source>Compute the inverse FFT of a signal that has Hermitian symmetry.</source>
          <target state="translated">Hermitian 대칭 신호의 역 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5919808f0861ce5e5c6edd192558abd6cdeed04d" translate="yes" xml:space="preserve">
          <source>Compute the inverse of the N-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 N 차원 FFT의 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ce30e6918f57933fede9b196ab6208b5d99d43fe" translate="yes" xml:space="preserve">
          <source>Compute the inverse of the n-point DFT for real input.</source>
          <target state="translated">실제 입력에 대한 n- 포인트 DFT의 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="146d4119420125716eb9e5162a664c6e708ec171" translate="yes" xml:space="preserve">
          <source>Compute the mean of the array.</source>
          <target state="translated">배열의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="75b405fa34c2293f176a80e9455e345d4ea00995" translate="yes" xml:space="preserve">
          <source>Compute the median along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5f2fe82c20077c9d0997165620b7b7093677b74f" translate="yes" xml:space="preserve">
          <source>Compute the median along the specified axis.</source>
          <target state="translated">지정된 축을 따라 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f49f4e3eff991416a03a71efdb176b02ad137665" translate="yes" xml:space="preserve">
          <source>Compute the multidimensional histogram of some data.</source>
          <target state="translated">일부 데이터의 다차원 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9f985f7023c691b407ddd9c38fd8d56c7f36cce8" translate="yes" xml:space="preserve">
          <source>Compute the number of periodic payments.</source>
          <target state="translated">정기적 인 지불 횟수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="733b57cc1709b7cf6a9c1de104182ed36cee85e6" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional FFT for real input.</source>
          <target state="translated">실제 입력을위한 1 차원 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8f2e370b04711ab583709ac47d198ba4e79cbadd" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional discrete Fourier Transform for real input.</source>
          <target state="translated">실제 입력을 위해 1 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e5e7857b86fdf420c15fe37d2645a15e124e2351" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional discrete Fourier Transform.</source>
          <target state="translated">1 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="76b7badeb6481641dd13f6eaf394bb9c18c8cab1" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">1 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9381b1752cc6a461f7e91077cdb6db7fe5a48f4d" translate="yes" xml:space="preserve">
          <source>Compute the outer product of two vectors.</source>
          <target state="translated">두 벡터의 외부 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cbc3ab7d3f6c89e7688a1bd6e4393422aa4c3b90" translate="yes" xml:space="preserve">
          <source>Compute the payment against loan principal plus interest.</source>
          <target state="translated">대출 원금과이자에 대한 지불을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="46ed86386ad333de82eb1b7762aabfed9c76dfaf" translate="yes" xml:space="preserve">
          <source>Compute the payment against loan principal.</source>
          <target state="translated">대출 원금에 대한 지불을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5b94637940b6e09f6a444aac566b5cffb0ef7cc5" translate="yes" xml:space="preserve">
          <source>Compute the present value.</source>
          <target state="translated">현재 가치를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ed2028550f82331ecb48f833083f7734128a7f0c" translate="yes" xml:space="preserve">
          <source>Compute the q-th percentile of the data along the specified axis.</source>
          <target state="translated">지정된 축을 따라 데이터의 q 번째 백분위 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c6ed1091760ac01a76bb052045201b29d9012406" translate="yes" xml:space="preserve">
          <source>Compute the q-th quantile of the data along the specified axis.</source>
          <target state="translated">지정된 축을 따라 데이터의 q 번째 Quantile을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a016c465eb4d3dc5939f0bdcc8907e529c903c76" translate="yes" xml:space="preserve">
          <source>Compute the qr factorization of a matrix.</source>
          <target state="translated">행렬의 qr 인수 분해를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="83309b8de9d230170ad49f73fb6a722aacbf72a8" translate="yes" xml:space="preserve">
          <source>Compute the qth percentile of the data along the specified axis, while ignoring nan values.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 번째 백분위 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4fe3d325fd56452aa7f5ecbc4f8b7dad9aae46d0" translate="yes" xml:space="preserve">
          <source>Compute the qth quantile of the data along the specified axis, while ignoring nan values.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 분위수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="de4cace71ddfe52eb9bc3f9b565cdbec00b48884" translate="yes" xml:space="preserve">
          <source>Compute the qth quantile of the data along the specified axis, while ignoring nan values. Returns the qth quantile(s) of the array elements.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 분위수를 계산합니다. 배열 요소의 q 번째 Quantile을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ed535359eae3077289b82f9fc67b3ffd54128d9" translate="yes" xml:space="preserve">
          <source>Compute the rate of interest per period.</source>
          <target state="translated">기간 당 이율을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1b7538c28d59530b835e6055fa30abb75407" translate="yes" xml:space="preserve">
          <source>Compute the roots for the series. Note that the accuracy of the roots decrease the further outside the domain they lie.</source>
          <target state="translated">시리즈의 근을 계산합니다. 뿌리의 정확성은 그들이 놓인 도메인 바깥으로 멀어 질수록 감소합니다.</target>
        </trans-unit>
        <trans-unit id="5c8b9d5cf9d0408e56b56c50cb4c4ea45a908e79" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2d641d9e2bcefe116338c34e7e9f40f95aa74cff" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Hermite series.</source>
          <target state="translated">은자 시리즈의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ae57b133f1570844585065d9e9104c93e1cbeadb" translate="yes" xml:space="preserve">
          <source>Compute the roots of a HermiteE series.</source>
          <target state="translated">HermiteE 시리즈의 근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="43f37ce85ee2223f1cd749d722bfe6cde31f8d3f" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Laguerre series.</source>
          <target state="translated">Laguerre 계열의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d296ea609a31255dd2dbb79a4294986988e4db61" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Legendre series.</source>
          <target state="translated">Legendre 시리즈의 근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="19abb563bbb5b6ab6c8e5baeecc0592cab5fb3b0" translate="yes" xml:space="preserve">
          <source>Compute the roots of a polynomial.</source>
          <target state="translated">다항식의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5d39f1a875851670d9065e685e3c7e7e93824abb" translate="yes" xml:space="preserve">
          <source>Compute the sign and (natural) logarithm of the determinant of an array.</source>
          <target state="translated">배열 결정 요인의 부호와 (자연) 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f10d7331dd9b2505d01acc79b5a5c28111413dab" translate="yes" xml:space="preserve">
          <source>Compute the standard deviation along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 표준 편차를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="66e310f2ac7182b1b997c8f29f43f4edc06f8e2a" translate="yes" xml:space="preserve">
          <source>Compute the standard deviation along the specified axis.</source>
          <target state="translated">지정된 축을 따라 표준 편차를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="88f78cc6a5ad581dc5a8fb410e447c660bd9fa8f" translate="yes" xml:space="preserve">
          <source>Compute the truth value of NOT x element-wise.</source>
          <target state="translated">NOT x의 진리 값을 요소 단위로 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="bea68d81fc2eb04da18ba084a78837621cebec88" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 AND x2 element-wise.</source>
          <target state="translated">x1 및 x2의 진리 값을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a79688781ca1781bce152cb44a9b15f66b72bfb1" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 OR x2 element-wise.</source>
          <target state="translated">x1 또는 x2의 진리 값을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="96e23b531f96b54840021483947c41a098b2ed1b" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 XOR x2, element-wise.</source>
          <target state="translated">요소 별 x1 XOR x2의 진리 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6a8a6092543ea859a93955c068e3715cc92a71ca" translate="yes" xml:space="preserve">
          <source>Compute the variance along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ab67fb4895d59fdba2f3312d3f97f40d39b32dc1" translate="yes" xml:space="preserve">
          <source>Compute the variance along the specified axis.</source>
          <target state="translated">지정된 축을 따라 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8ad00c6a1c7489e8566fc76ef273931215436611" translate="yes" xml:space="preserve">
          <source>Compute the weighted average along the specified axis.</source>
          <target state="translated">지정된 축을 따라 가중 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="79af5daa38dbf74799da93dffa5ef6f8fba6dccf" translate="yes" xml:space="preserve">
          <source>Compute two different sets of indices to access 4x4 arrays, one for the lower triangular part starting at the main diagonal, and one starting two diagonals further right:</source>
          <target state="translated">4 개의 배열에 액세스하기 위해 두 개의 다른 인덱스 세트를 계산합니다. 하나는 기본 대각선에서 시작하는 아래쪽 삼각형 부분에 대한 것이고 다른 하나는 오른쪽에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="471eda8864ca36b1868976a6ed358ad1c7812441" translate="yes" xml:space="preserve">
          <source>Compute two different sets of indices to access 4x4 arrays, one for the upper triangular part starting at the main diagonal, and one starting two diagonals further right:</source>
          <target state="translated">4 개의 배열에 액세스하기 위해 두 개의 다른 인덱스 세트를 계산합니다. 하나는 주 대각선에서 시작하는 위쪽 삼각형 부분에 대한 것이고 다른 하나는 오른쪽에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="197392cccae8af7bf76b914db915fad3a803ed5b" translate="yes" xml:space="preserve">
          <source>Compute z as follows:</source>
          <target state="translated">다음과 같이 z를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="e5847ac2ac3c001c3a2cac8771b53202e9193405" translate="yes" xml:space="preserve">
          <source>Computes a least-squares fit from the matrix.</source>
          <target state="translated">행렬에서 최소 자승을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d8ae02c2a1f37ef602fe9635ca3deb7ae7eff320" translate="yes" xml:space="preserve">
          <source>Computes a least-squares fit.</source>
          <target state="translated">최소 제곱 적합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fca5c893d0dd0095c803730ae984c8a5d1f22fbb" translate="yes" xml:space="preserve">
          <source>Computes spline fits.</source>
          <target state="translated">스플라인 맞춤을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="39bd0877aee14479f84fa968669682d5f4bb55d6" translate="yes" xml:space="preserve">
          <source>Computes the &amp;ldquo;exact&amp;rdquo; solution, &lt;code&gt;x&lt;/code&gt;, of the well-determined, i.e., full rank, linear matrix equation &lt;code&gt;ax = b&lt;/code&gt;.</source>
          <target state="translated">잘 결정된, 즉 전체 순위 선형 행렬 방정식 &lt;code&gt;ax = b&lt;/code&gt; 의 &quot;정확한&quot;해 &lt;code&gt;x&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="650917c230f0e3e59e23869cdea9804dfbb8e6f0" translate="yes" xml:space="preserve">
          <source>Computes the Kronecker product, a composite array made of blocks of the second array scaled by the first.</source>
          <target state="translated">두 번째 배열의 블록으로 구성된 복합 배열 인 Kronecker 곱을 첫 번째 축척으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="10cbc0814b0dd9715e5abe01e8dbaaa33fe8ad59" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise AND of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">입력 배열에있는 정수의 기본 이진 표현을 비트 단위 AND로 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="60c3fbdfba7bb7378090a32d8c51b3e9fca09817" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현의 비트 단위 NOT을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;~&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="42722e323632d4f5d01bc926af28a1c22d5e0f95" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현에 대한 비트 단위 OR을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67adfae8fffe1baa14f71537d861b7b2e85f7e48" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현에 대한 비트 단위 XOR을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;^&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7810254747fb57737310252a83ed1ecfa7ac7de1" translate="yes" xml:space="preserve">
          <source>Computes the remainder complementary to the &lt;a href=&quot;numpy.floor_divide#numpy.floor_divide&quot;&gt;&lt;code&gt;floor_divide&lt;/code&gt;&lt;/a&gt; function. It is equivalent to the Python modulus operator``x1 % x2`` and has the same sign as the divisor &lt;code&gt;x2&lt;/code&gt;. The MATLAB function equivalent to &lt;code&gt;np.remainder&lt;/code&gt; is &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.floor_divide#numpy.floor_divide&quot;&gt; &lt;code&gt;floor_divide&lt;/code&gt; &lt;/a&gt; 함수를 보완하는 나머지를 계산합니다 . 파이썬 모듈러스 연산자``x1 % x2 ''와 동일하며 제수 &lt;code&gt;x2&lt;/code&gt; 와 동일한 부호를 갖습니다 . &lt;code&gt;np.remainder&lt;/code&gt; 와 동등한 MATLAB 함수 는 &lt;code&gt;mod&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="531dbc47f0c42b16e91bc06f7934ffc0eee90d21" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Chebyshev quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">가우스 체비 쇼프 구적법에 대한 표본 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="d0825c93bd67fcabe34143f70ae3cf80cb8738d0" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Hermite quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Hermite quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="9e720112e13fbc925fc36348970ddc09e09d43c8" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-HermiteE quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-HermiteE quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="01551c6580e6c7cd7da039752c76647a860146e9" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Laguerre quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Laguerre quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="a1676ee2351ddea298864c94b5761c72628c1745" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Legendre quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Legendre quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="54ad29fb2a5fef5a2e2b0f26f16821ff1f58a836" translate="yes" xml:space="preserve">
          <source>Computing determinants for a stack of matrices:</source>
          <target state="translated">행렬 스택에 대한 컴퓨팅 결정 요인 :</target>
        </trans-unit>
        <trans-unit id="5ffa5ce5ed5560b7502b21e2214468e10166aa18" translate="yes" xml:space="preserve">
          <source>Computing log-determinants for a stack of matrices:</source>
          <target state="translated">행렬 스택에 대한 로그 결정 요소 계산 :</target>
        </trans-unit>
        <trans-unit id="0fe14fa20a118f97b78bbb776b8e138eb54dc0e1" translate="yes" xml:space="preserve">
          <source>Computing the mean in float64 is more accurate:</source>
          <target state="translated">float64의 평균을 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="0a9983d1df747790eaf4d763cc8f1c4f963a34f1" translate="yes" xml:space="preserve">
          <source>Computing the standard deviation in float64 is more accurate:</source>
          <target state="translated">float64의 표준 편차를 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="0d25e4fdfb9f10d7770a29a84aa8fcf9d6cb64d3" translate="yes" xml:space="preserve">
          <source>Computing the variance in float64 is more accurate:</source>
          <target state="translated">float64의 분산을 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="750f4a65465f4b9d86986bbaa22fd86a632eb891" translate="yes" xml:space="preserve">
          <source>Concatenate a sequence of arrays along the given axis.</source>
          <target state="translated">주어진 축을 따라 일련의 배열을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="69f1f5039a9914b263cf71649e1821ac86e01220" translate="yes" xml:space="preserve">
          <source>Concatenate function that preserves input masks.</source>
          <target state="translated">입력 마스크를 유지하는 기능을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="6f58d263f33944384921df8405fd4a36e06175e2" translate="yes" xml:space="preserve">
          <source>Concepts</source>
          <target state="translated">Concepts</target>
        </trans-unit>
        <trans-unit id="da18f43cbda77c14c1135f5d6d7534517acba1bc" translate="yes" xml:space="preserve">
          <source>Consequences of alignment</source>
          <target state="translated">정렬의 결과</target>
        </trans-unit>
        <trans-unit id="e539f73473510ee53613700e677295e3dfb96cf9" translate="yes" xml:space="preserve">
          <source>Consider a reasonable prototype for a dot product function:</source>
          <target state="translated">내적 함수에 대한 합리적인 프로토 타입을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cdfd5c5d52fe64ca5fe219ac6749930b18bf023b" translate="yes" xml:space="preserve">
          <source>Consider an urn with black and white marbles in it, &lt;code&gt;ngood&lt;/code&gt; of them are black and &lt;code&gt;nbad&lt;/code&gt; are white. If you draw &lt;code&gt;nsample&lt;/code&gt; balls without replacement, then the hypergeometric distribution describes the distribution of black balls in the drawn sample.</source>
          <target state="translated">검은 색과 흰색 대리석이있는 항아리를 고려하십시오 &lt;code&gt;ngood&lt;/code&gt; 는 검은 색이고 &lt;code&gt;nbad&lt;/code&gt; 는 흰색입니다. 교체하지 않고 &lt;code&gt;nsample&lt;/code&gt; 볼 을 그리는 경우 초 지오 분포 분포는 그린 샘플에서 검은 볼의 분포를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d56e4e8e5205e5f0b9d856e7027774cced155ea" translate="yes" xml:space="preserve">
          <source>Consider four points in different quadrants:</source>
          <target state="translated">다른 사분면에서 4 개의 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ed0667d145092c432f907df7626ac668935a1be1" translate="yes" xml:space="preserve">
          <source>Consider two variables,</source>
          <target state="translated">두 가지 변수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="40c1f81a4e69db7cd9d45c11cd781d9ad71dd11a" translate="yes" xml:space="preserve">
          <source>Constants of the &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; 모듈의 상수</target>
        </trans-unit>
        <trans-unit id="416f6fe7840ff98cc53cadbb77344b8df8be8efe" translate="yes" xml:space="preserve">
          <source>Constants of the numpy.ma module</source>
          <target state="translated">numpy.ma 모듈의 상수</target>
        </trans-unit>
        <trans-unit id="ff100071278ebc0dce3b27374571a0b6214de453" translate="yes" xml:space="preserve">
          <source>Construct Python bytes containing the raw data bytes in the array.</source>
          <target state="translated">배열에 원시 데이터 바이트를 포함하는 Python 바이트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2a92c9e90e58234afd363951b811ae566d58dd4a" translate="yes" xml:space="preserve">
          <source>Construct a 2-D histogram with variable bin width. First define the bin edges:</source>
          <target state="translated">빈 폭이 가변적 인 2 차원 히스토그램을 구성합니다. 먼저 빈 가장자리를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="b11f0a82e16bcae98f2244ba4878813b908a4c4a" translate="yes" xml:space="preserve">
          <source>Construct a configuration instance for the given package name. If &lt;em&gt;parent_name&lt;/em&gt; is not None, then construct the package as a sub-package of the &lt;em&gt;parent_name&lt;/em&gt; package. If &lt;em&gt;top_path&lt;/em&gt; and &lt;em&gt;package_path&lt;/em&gt; are None then they are assumed equal to the path of the file this instance was created in. The setup.py files in the numpy distribution are good examples of how to use the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">주어진 패키지 이름에 대한 구성 인스턴스를 구성하십시오. &lt;em&gt;parent_name&lt;/em&gt; 이 None이 아닌 경우 패키지를 &lt;em&gt;parent_name&lt;/em&gt; 패키지 의 하위 패키지로 구성하십시오 . 경우 &lt;em&gt;top_path&lt;/em&gt; 및 &lt;em&gt;package_path은&lt;/em&gt; 아무도 없습니다 그들은이 인스턴스에서 생성 된 파일의 경로와 동일한 가정한다. NumPy와 유통의 setup.py 파일을 사용하는 방법의 좋은 예입니다 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="433d0814f344913efe3de8118404c8ba5f5d7e7f" translate="yes" xml:space="preserve">
          <source>Construct a dtype description list from a given dtype.</source>
          <target state="translated">주어진 dtype에서 dtype 설명 목록을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="699e78314482350bc4ad52e8b449dfd4bedbe2f6" translate="yes" xml:space="preserve">
          <source>Construct a multi-dimensional &amp;ldquo;meshgrid&amp;rdquo; using indexing notation.</source>
          <target state="translated">인덱싱 표기법을 사용하여 다차원 &quot;메쉬 그리드&quot;를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1a333c2b137d94f4c46546de94da2e32f2f8d9" translate="yes" xml:space="preserve">
          <source>Construct a new 1-dimensional array of data-type determined by &lt;code&gt;descr&lt;/code&gt;, that ranges from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; (exclusive) in increments of &lt;code&gt;step&lt;/code&gt;. Equivalent to arange( &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;, &lt;code&gt;typenum&lt;/code&gt; ).</source>
          <target state="translated">결정 데이터 타입의 새로운 1 차원 어레이 구축 &lt;code&gt;descr&lt;/code&gt; 범위 것과, &lt;code&gt;start&lt;/code&gt; 을 &lt;code&gt;stop&lt;/code&gt; 단위로 (단독) &lt;code&gt;step&lt;/code&gt; . &lt;code&gt;typenum&lt;/code&gt; ( &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; , typenum ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fec9966593ee1edd10cbcd21d0622b1f630d401d" translate="yes" xml:space="preserve">
          <source>Construct a new 1-dimensional array of data-type, &lt;em&gt;typenum&lt;/em&gt;, that ranges from &lt;em&gt;start&lt;/em&gt; to &lt;em&gt;stop&lt;/em&gt; (exclusive) in increments of &lt;em&gt;step&lt;/em&gt; . Equivalent to &lt;strong&gt;arange&lt;/strong&gt; (&lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, &lt;em&gt;step&lt;/em&gt;, dtype).</source>
          <target state="translated">&lt;em&gt;step&lt;/em&gt; 씩 증가하는 &lt;em&gt;시작&lt;/em&gt; 에서 &lt;em&gt;중지&lt;/em&gt; (제외) 범위 의 새로운 1 차원 배열의 데이터 유형 &lt;em&gt;typenum을 구성하십시오&lt;/em&gt; . 상당 &lt;strong&gt;arange에&lt;/strong&gt; ( &lt;em&gt;시작&lt;/em&gt; , &lt;em&gt;중지&lt;/em&gt; , &lt;em&gt;단계&lt;/em&gt; , DTYPE).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a706c57cd0f57f685f10a9b48082253d3c7f348" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. Fill the memory with zeros (or the 0 object if &lt;em&gt;dtype&lt;/em&gt; corresponds to &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . &lt;em&gt;포트란&lt;/em&gt; 이 0이 아닌 경우 &lt;em&gt;포트란&lt;/em&gt; 배열이 작성되고, 그렇지 않으면 C 순서 배열이 작성됩니다. 메모리를 0 으로 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 웁니다&lt;/em&gt; (또는 &lt;em&gt;dtype이 NPY_OBJECT에&lt;/em&gt; 해당하는 경우 0 객체 ).</target>
        </trans-unit>
        <trans-unit id="8e79348d2a80859159fd1349201ec8444a12864b" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. The array is uninitialized unless the data type corresponds to &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case the array is filled with &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . &lt;em&gt;포트란&lt;/em&gt; 이 0이 아닌 경우 &lt;em&gt;포트란&lt;/em&gt; 배열이 작성되고, 그렇지 않으면 C 순서 배열이 작성됩니다. 데이터 유형이 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 에 해당하지 않으면 배열이 초기화되지 않습니다. 이 경우 배열은 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 으로 채워 집니다 .</target>
        </trans-unit>
        <trans-unit id="dd48627fbdfc02f6cd5a744335a7b8a3ec7e74ff" translate="yes" xml:space="preserve">
          <source>Construct a new Generator with the default BitGenerator (PCG64).</source>
          <target state="translated">기본 BitGenerator (PCG64)를 사용하여 새 생성기를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2293ee6e243af707ad818c946eb5f54c18c43217" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from a binary or (ASCII) text &lt;code&gt;string&lt;/code&gt; of length &lt;code&gt;slen&lt;/code&gt;. The data-type of the array to-be-created is given by &lt;code&gt;dtype&lt;/code&gt;. If num is -1, then &lt;strong&gt;copy&lt;/strong&gt; the entire string and return an appropriately sized array, otherwise, &lt;code&gt;num&lt;/code&gt; is the number of items to &lt;strong&gt;copy&lt;/strong&gt; from the string. If &lt;code&gt;sep&lt;/code&gt; is NULL (or &amp;ldquo;&amp;rdquo;), then interpret the string as bytes of binary data, otherwise convert the sub-strings separated by &lt;code&gt;sep&lt;/code&gt; to items of data-type &lt;code&gt;dtype&lt;/code&gt;. Some data-types may not be readable in text mode and an error will be raised if that occurs. All errors return NULL.</source>
          <target state="translated">길이가 &lt;code&gt;slen&lt;/code&gt; 인 이진 또는 (ASCII) 텍스트 &lt;code&gt;string&lt;/code&gt; 에서 단일 유형의 1 차원 ndarray를 구성합니다 . 작성 될 배열의 데이터 유형은 &lt;code&gt;dtype&lt;/code&gt; 에 의해 제공됩니다 . num이 -1이면 전체 문자열 을 &lt;strong&gt;복사&lt;/strong&gt; 하고 적절한 크기의 배열을 반환합니다. 그렇지 않으면 &lt;code&gt;num&lt;/code&gt; 은 문자열에서 &lt;strong&gt;복사&lt;/strong&gt; 할 항목 수입니다 . 경우 &lt;code&gt;sep&lt;/code&gt; (또는 &quot;&quot;) NULL 인 후 이진 데이터의 바이트와 같은 문자열을 해석 달리 서브 문자열로 분리 변환 &lt;code&gt;sep&lt;/code&gt; 데이터 타입의 항목 &lt;code&gt;dtype&lt;/code&gt; . 일부 데이터 유형은 텍스트 모드에서 읽을 수 없으며 오류가 발생하면 오류가 발생합니다. 모든 오류는 NULL을 반환합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5251a91820bd97dd4c2975d82383f312ad4f99bf" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from a binary or text file. The open file pointer is &lt;code&gt;fp&lt;/code&gt;, the data-type of the array to be created is given by &lt;code&gt;dtype&lt;/code&gt;. This must match the data in the file. If &lt;code&gt;num&lt;/code&gt; is -1, then read until the end of the file and return an appropriately sized array, otherwise, &lt;code&gt;num&lt;/code&gt; is the number of items to read. If &lt;code&gt;sep&lt;/code&gt; is NULL (or &amp;ldquo;&amp;rdquo;), then read from the file in binary mode, otherwise read from the file in text mode with &lt;code&gt;sep&lt;/code&gt; providing the item separator. Some array types cannot be read in text mode in which case an error is raised.</source>
          <target state="translated">이진 또는 텍스트 파일에서 단일 유형의 1 차원 ndarray를 구성하십시오. 열린 파일 포인터는 &lt;code&gt;fp&lt;/code&gt; 이며 생성 할 배열의 데이터 유형은 &lt;code&gt;dtype&lt;/code&gt; 으로 제공됩니다 . 파일의 데이터와 일치해야합니다. 경우 &lt;code&gt;num&lt;/code&gt; -1, 다음, 그렇지 않으면 파일이 끝날 때까지 읽고 적절한 크기의 배열을 반환 &lt;code&gt;num&lt;/code&gt; 읽을 수있는 항목의 수입니다. 경우 &lt;code&gt;sep&lt;/code&gt; (또는 &quot;&quot;) NULL이다하고 그렇지 텍스트 모드에서 파일로부터 판독 된 바이너리 모드에서 파일로부터 판독 &lt;code&gt;sep&lt;/code&gt; 상품 분리를 제공한다. 일부 배열 유형은 텍스트 모드에서 읽을 수 없으며이 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5dade1b4bc430d7a08d1e500dc891669be329c17" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from an object, &lt;code&gt;buf&lt;/code&gt;, that exports the (single-segment) buffer protocol (or has an attribute __buffer__ that returns an object that exports the buffer protocol). A writeable buffer will be tried first followed by a read- only buffer. The &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag of the returned array will reflect which one was successful. The data is assumed to start at &lt;code&gt;offset&lt;/code&gt; bytes from the start of the memory location for the object. The type of the data in the buffer will be interpreted depending on the data- type descriptor, &lt;code&gt;dtype.&lt;/code&gt; If &lt;code&gt;count&lt;/code&gt; is negative then it will be determined from the size of the buffer and the requested itemsize, otherwise, &lt;code&gt;count&lt;/code&gt; represents how many elements should be converted from the buffer.</source>
          <target state="translated">(단일 세그먼트) 버퍼 프로토콜을 내보내는 (또는 버퍼 프로토콜을 내보내는 객체를 반환하는 __buffer__ 속성이있는) 객체 &lt;code&gt;buf&lt;/code&gt; 에서 단일 유형의 1 차원 ndarray를 구성합니다 . 쓰기 가능한 버퍼가 먼저 시도 된 다음 읽기 전용 버퍼가 뒤 따릅니다. 반환 된 배열 의 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그는 성공한 것을 반영합니다. 데이터는 객체의 메모리 위치 시작부터 &lt;code&gt;offset&lt;/code&gt; 바이트 로 시작한다고 가정 합니다. 버퍼의 데이터 유형은 데이터 유형 설명자 &lt;code&gt;dtype.&lt;/code&gt; 에 따라 해석됩니다 . 경우에 &lt;code&gt;count&lt;/code&gt; 네거티브가 다음 인 것이 버퍼의 크기를 결정하고, 그렇지 않으면, itemsize 요청 될 &lt;code&gt;count&lt;/code&gt; 버퍼에서 변환해야하는 요소 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e92de9d29a116aa0b6d137e92f4fcc4342111c10" translate="yes" xml:space="preserve">
          <source>Construct a polynomial from its roots:</source>
          <target state="translated">뿌리에서 다항식을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54108fca709f2e6aae97ceda0d8c265646c4b46b" translate="yes" xml:space="preserve">
          <source>Construct a record array from a wide-variety of objects.</source>
          <target state="translated">다양한 객체로 레코드 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dddc1fb766bf2c0701978de30cc0096077f1469c" translate="yes" xml:space="preserve">
          <source>Construct a record array from data.</source>
          <target state="translated">데이터에서 레코드 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d4864a011f7d33f5af39ef59a61e350cf80e6b72" translate="yes" xml:space="preserve">
          <source>Construct an array by executing a function on grid positions.</source>
          <target state="translated">그리드 위치에서 함수를 실행하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb2f5ef9eabc5b7b4a11f36c9da5468304049228" translate="yes" xml:space="preserve">
          <source>Construct an array by executing a function over each coordinate.</source>
          <target state="translated">각 좌표에 대해 함수를 실행하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="b8c37852e1d20c54f490e5d55d35d32a2e77d1a3" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating A the number of times given by reps.</source>
          <target state="translated">A 회 반복 횟수를 반복하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="dbd2833638747627f536392fa321860afd1ae4eb" translate="yes" xml:space="preserve">
          <source>Construct an array from a text file, using regular expression parsing.</source>
          <target state="translated">정규식 구문 분석을 사용하여 텍스트 파일에서 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="001455fa868d0d982a84f3e1e1c5e71cab1576c5" translate="yes" xml:space="preserve">
          <source>Construct an array from an index array and a set of arrays to choose from.</source>
          <target state="translated">인덱스 배열과 선택할 배열 집합에서 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="bc43ce79bb40c8126c3a27887892f4214024c494" translate="yes" xml:space="preserve">
          <source>Construct an array from data in a text or binary file.</source>
          <target state="translated">텍스트 또는 이진 파일의 데이터로 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="899756aeb93d1b6aa9bd7c93436b76c0a22fadb6" translate="yes" xml:space="preserve">
          <source>Construct an array.</source>
          <target state="translated">배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="46ee020e3e38edbb070e9ee58f67dfe44037398b" translate="yes" xml:space="preserve">
          <source>Construct an ndarray that allows field access using attributes.</source>
          <target state="translated">속성을 사용하여 필드 액세스를 허용하는 ndarray를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="fb44631c7aa67652764b1577b600ec14bbff21bf" translate="yes" xml:space="preserve">
          <source>Construct an ndarray:</source>
          <target state="translated">ndarray를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="1836b53e3c198fe2973be15630e978884dacc6c1" translate="yes" xml:space="preserve">
          <source>Construct an open mesh from multiple sequences.</source>
          <target state="translated">여러 시퀀스에서 열린 메시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d3f16aad1976f8f22c5c798dc38d30d79a5e094c" translate="yes" xml:space="preserve">
          <source>Construct an open multi-dimensional &amp;ldquo;meshgrid&amp;rdquo; using indexing notation.</source>
          <target state="translated">인덱싱 표기법을 사용하여 열린 다차원 &quot;메쉬 그리드&quot;를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="55ed2507cc0269a472eaaccd89421410ab758bab" translate="yes" xml:space="preserve">
          <source>Construct index arrays.</source>
          <target state="translated">인덱스 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a0c11bbbca8e4a4ea9ed0b83b66214ccecaa653" translate="yes" xml:space="preserve">
          <source>Construct the polynomial</source>
          <target state="translated">다항식 구성</target>
        </trans-unit>
        <trans-unit id="192cbc084f005ca610c67957b0697275db236d0b" translate="yes" xml:space="preserve">
          <source>Constructing arrays</source>
          <target state="translated">배열 구성</target>
        </trans-unit>
        <trans-unit id="892df0306b57e168d52112a1ac784f3daa7382c7" translate="yes" xml:space="preserve">
          <source>Constructing masked arrays</source>
          <target state="translated">마스크 배열 생성</target>
        </trans-unit>
        <trans-unit id="3b2acad01b35b6a4b590dd72299d537e83394aa4" translate="yes" xml:space="preserve">
          <source>Constructing polynomials by specifying coefficients is just one way of obtaining a polynomial instance, they may also be created by specifying their roots, by conversion from other polynomial types, and by least squares fits. Fitting is discussed in its own section, the other methods are demonstrated below:</source>
          <target state="translated">계수를 지정하여 다항식을 구성하는 것은 다항식 인스턴스를 얻는 한 가지 방법 일 뿐이며, 근을 지정하거나 다른 다항식 유형에서 변환하고 최소 자승법으로도 만들 수 있습니다. 피팅은 자체 섹션에서 논의되며 다른 방법은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3bd2707e230a54a78bfb480ed5e48501ad49b7" translate="yes" xml:space="preserve">
          <source>Construction and Destruction</source>
          <target state="translated">건축과 파괴</target>
        </trans-unit>
        <trans-unit id="94e201ee9bbe86594c4ceb5d0adfb75c739dc4ae" translate="yes" xml:space="preserve">
          <source>Construction:</source>
          <target state="translated">Construction:</target>
        </trans-unit>
        <trans-unit id="38e2be5fd7d5e892898904110f6fb600a6f2fc5e" translate="yes" xml:space="preserve">
          <source>Constructs Python bytes showing a copy of the raw contents of data memory. The bytes object can be produced in either &amp;lsquo;C&amp;rsquo; or &amp;lsquo;Fortran&amp;rsquo;, or &amp;lsquo;Any&amp;rsquo; order (the default is &amp;lsquo;C&amp;rsquo;-order). &amp;lsquo;Any&amp;rsquo; order means C-order unless the F_CONTIGUOUS flag in the array is set, in which case it means &amp;lsquo;Fortran&amp;rsquo; order.</source>
          <target state="translated">데이터 메모리의 원시 내용 사본을 보여주는 Python 바이트를 구성합니다. bytes 객체는 'C'또는 'Fortran'또는 'Any'순서 (기본값은 'C'순서)로 생성 할 수 있습니다. '모든'순서는 배열의 F_CONTIGUOUS 플래그가 설정되지 않은 경우 C 순서를 의미하며,이 경우 'Fortran'순서를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ced0c9c71d4ab448d256e9755d975eecac83dca4" translate="yes" xml:space="preserve">
          <source>Container customization: (see &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;Indexing&lt;/a&gt;)</source>
          <target state="translated">컨테이너 사용자 정의 : ( &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;인덱싱&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="945b5909351c614284e294687fc5eed8d30bdfa8" translate="yes" xml:space="preserve">
          <source>Container for the BitGenerators.</source>
          <target state="translated">BitGenerators의 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="9518c0118e2383159ff89f0d3a6a9dc8b35e9445" translate="yes" xml:space="preserve">
          <source>Container for the Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Mersenne Twister 의사 난수 생성기를위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="d5e682207eece98b359f1e232839589a5bb83513" translate="yes" xml:space="preserve">
          <source>Container for the Philox (4x64) pseudo-random number generator.</source>
          <target state="translated">Philox (4x64) 의사 난수 생성기를위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="a3a1e2e5587dcb37af6a475783aa40a7e9e982e2" translate="yes" xml:space="preserve">
          <source>Container for the slow Mersenne Twister pseudo-random number generator. Consider using a different BitGenerator with the Generator container instead.</source>
          <target state="translated">느린 Mersenne Twister 의사 난수 생성기를위한 컨테이너입니다. 대신 Generator 컨테이너와 함께 다른 BitGenerator를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6d56c0715bcae84fdc288fbfdbc42c1f40a6702" translate="yes" xml:space="preserve">
          <source>Contains the new set of coefficients.</source>
          <target state="translated">새로운 계수 세트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="28ea8c81849521c495649532e08b0b593de2159c" translate="yes" xml:space="preserve">
          <source>Context manager and decorator doing much the same as &lt;code&gt;warnings.catch_warnings&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자 및 데코레이터는 &lt;code&gt;warnings.catch_warnings&lt;/code&gt; 와 거의 동일한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5df86c4c3ee2b6d151a9b289e9fec5a79fd29c69" translate="yes" xml:space="preserve">
          <source>Context manager for floating-point error handling.</source>
          <target state="translated">부동 소수점 오류 처리를위한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="bd35c159334bf5d6e2fa5b1e59c4a7083dc1dc6f" translate="yes" xml:space="preserve">
          <source>Context manager for setting print options.</source>
          <target state="translated">인쇄 옵션 설정을위한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="e74eade6a152d46f1eb9b2b5ababc0f77f6bb16e" translate="yes" xml:space="preserve">
          <source>Contiguous array of same shape and content as &lt;code&gt;a&lt;/code&gt;, with type &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; if specified.</source>
          <target state="translated">지정된 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 을&lt;/a&gt; 가진 &lt;code&gt;a&lt;/code&gt; 와 동일한 모양과 내용의 연속 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="053873361447a3f60bca70c8480df2214f748216" translate="yes" xml:space="preserve">
          <source>Contrary to &lt;a href=&quot;numpy.asanyarray#numpy.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt;, ndarray subclasses are not passed through:</source>
          <target state="translated">&lt;a href=&quot;numpy.asanyarray#numpy.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt; 와 달리 ndarray 서브 클래스는 다음을 통해 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fb6ba6e1303f6e5416d2c67796f8de91feba760" translate="yes" xml:space="preserve">
          <source>Controlling Iteration Order</source>
          <target state="translated">반복 순서 제어</target>
        </trans-unit>
        <trans-unit id="3381fbfd7109d41fe7b80cebebf3f59427289be0" translate="yes" xml:space="preserve">
          <source>Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the &amp;lsquo;greedy&amp;rsquo; algorithm. Also accepts an explicit contraction list from the &lt;code&gt;np.einsum_path&lt;/code&gt; function. See &lt;code&gt;np.einsum_path&lt;/code&gt; for more details. Defaults to False.</source>
          <target state="translated">중간 최적화 발생 여부를 제어합니다. False 및 True가 기본적으로 'greedy'알고리즘으로 설정되면 최적화가 수행되지 않습니다. &lt;code&gt;np.einsum_path&lt;/code&gt; 함수 에서 명시 적 수축 목록도 허용합니다 . 자세한 내용은 &lt;code&gt;np.einsum_path&lt;/code&gt; 를 참조하십시오. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="962dce34fa4c991d8761b74453473e2047eb1a3f" translate="yes" xml:space="preserve">
          <source>Controls post-processing trimming of trailing digits, as follows:</source>
          <target state="translated">다음과 같이 후행 자릿수의 사후 처리 트리밍을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d93cc903a5f85a76e394a8f4bb04305a43ea383d" translate="yes" xml:space="preserve">
          <source>Controls printing of the sign of floating-point types. If &amp;lsquo;+&amp;rsquo;, always print the sign of positive values. If &amp;lsquo; &amp;lsquo;, always prints a space (whitespace character) in the sign position of positive values. If &amp;lsquo;-&amp;lsquo;, omit the sign character of positive values. (default &amp;lsquo;-&amp;lsquo;)</source>
          <target state="translated">부동 소수점 유형의 부호 인쇄를 제어합니다. '+'이면 항상 양수의 부호를 인쇄하십시오. ''이면 항상 양수 값의 부호 위치에 공백 (공백 문자)을 인쇄합니다. '-'인 경우 양수의 부호 문자를 생략하십시오. (기본 '-')</target>
        </trans-unit>
        <trans-unit id="7e4e4469d00d85c02bbeabd4c04ac5324f9efb77" translate="yes" xml:space="preserve">
          <source>Controls printing of the sign of floating-point types. If &amp;lsquo;+&amp;rsquo;, always print the sign of positive values. If &amp;lsquo; &amp;lsquo;, always prints a space (whitespace character) in the sign position of positive values. If &amp;lsquo;-&amp;lsquo;, omit the sign character of positive values. Defaults to &lt;code&gt;numpy.get_printoptions()['sign']&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 유형의 부호 인쇄를 제어합니다. '+'이면 항상 양수의 부호를 인쇄하십시오. ''인 경우 항상 양수 값의 부호 위치에 공백 (공백 문자)을 인쇄합니다. '-'인 경우 양수의 부호 문자를 생략하십시오. 기본값은 &lt;code&gt;numpy.get_printoptions()['sign']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="841208ff2e453a067133b334501582310ba65939" translate="yes" xml:space="preserve">
          <source>Controls the interpretation of the &lt;code&gt;precision&lt;/code&gt; option for floating-point types. Can take the following values (default maxprec_equal):</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;precision&lt;/code&gt; 옵션 의 해석을 제어합니다 . 다음 값을 사용할 수 있습니다 (기본 maxprec_equal).</target>
        </trans-unit>
        <trans-unit id="bd5b6d8587399226c1239e4675c6dc1ac5b81996" translate="yes" xml:space="preserve">
          <source>Controls the interpretation of the &lt;code&gt;precision&lt;/code&gt; option for floating-point types. Defaults to &lt;code&gt;numpy.get_printoptions()['floatmode']&lt;/code&gt;. Can take the following values:</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;precision&lt;/code&gt; 옵션 의 해석을 제어합니다 . 기본값은 &lt;code&gt;numpy.get_printoptions()['floatmode']&lt;/code&gt; 입니다. 다음 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="053fc22cde7115d581a6dae5bcdbdffe93e520ff" translate="yes" xml:space="preserve">
          <source>Controls the iteration order. &amp;lsquo;C&amp;rsquo; means C order, &amp;lsquo;F&amp;rsquo; means Fortran order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; order if all the arrays are Fortran contiguous, &amp;lsquo;C&amp;rsquo; order otherwise, and &amp;lsquo;K&amp;rsquo; means as close to the order the array elements appear in memory as possible. This also affects the element memory order of &lt;code&gt;allocate&lt;/code&gt; operands, as they are allocated to be compatible with iteration order. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">반복 순서를 제어합니다. 'C'는 C 순서, 'F'는 포트란 순서, 'A'는 모든 배열이 포트란 연속 인 경우 'F'순서, 그렇지 않으면 'C'순서, 'K'는 배열 요소가 나타나는 순서에 가까운 것을 의미합니다. 가능한 메모리에. 이는 반복 피연산자와 호환되도록 할당되므로 &lt;code&gt;allocate&lt;/code&gt; 피연산자 의 요소 메모리 순서에도 영향을줍니다 . 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="e9576b535389b3dbd06f435cca5164180f9065da" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the copy. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible. (Note that this function and &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;numpy.copy&lt;/code&gt;&lt;/a&gt; are very similar, but have different default values for their order= arguments.)</source>
          <target state="translated">사본의 메모리 레이아웃을 조정합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'수단의 레이아웃과 일치 &lt;code&gt;a&lt;/code&gt; 가능한 가깝게한다. 이 함수와 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;numpy.copy&lt;/code&gt; &lt;/a&gt; 는 매우 유사하지만 order = 인수의 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0444f926d86651cc3dd5611e09e50dadc271143c" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the copy. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible. (Note that this function and &lt;a href=&quot;numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; are very similar, but have different default values for their order= arguments.)</source>
          <target state="translated">사본의 메모리 레이아웃을 조정합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'수단의 레이아웃과 일치 &lt;code&gt;a&lt;/code&gt; 가능한 가깝게한다. 이 함수와 &lt;a href=&quot;numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; 는 매우 유사하지만 order = 인수의 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="87b34e8b0f8ba396e7a4855d6f683c663aa9e3a5" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the output. &amp;lsquo;C&amp;rsquo; means it should be C contiguous. &amp;lsquo;F&amp;rsquo; means it should be Fortran contiguous, &amp;lsquo;A&amp;rsquo; means it should be &amp;lsquo;F&amp;rsquo; if the inputs are all &amp;lsquo;F&amp;rsquo;, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">출력의 메모리 레이아웃을 제어합니다. 'C'는 C가 연속적이어야 함을 의미합니다. 'F'는 포트란이 연속적이어야하고 'A'는 입력이 모두 'F'이면 'F'여야하고 그렇지 않으면 'C'임을 의미합니다. 'K'는 임의로 치환 된 축을 포함하여 가능한 한 입력이 레이아웃에 가까워 야 함을 의미합니다. 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="914761ad3f3f74151dc575c678b27db7c8a59e79" translate="yes" xml:space="preserve">
          <source>Controls the memory layout order of the result. &amp;lsquo;C&amp;rsquo; means C order, &amp;lsquo;F&amp;rsquo; means Fortran order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; order if all the arrays are Fortran contiguous, &amp;lsquo;C&amp;rsquo; order otherwise, and &amp;lsquo;K&amp;rsquo; means as close to the order the array elements appear in memory as possible. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">결과의 메모리 레이아웃 순서를 제어합니다. 'C'는 C 순서, 'F'는 포트란 순서, 'A'는 모든 배열이 포트란 연속 인 경우 'F'순서, 그렇지 않으면 'C'순서, 'K'는 배열 요소가 나타나는 순서에 가까운 것을 의미합니다. 가능한 메모리에. 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="2bd2cad71e7b306729d33e9e77734a57f4c762bf" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur when copying.</source>
          <target state="translated">복사시 어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5ffcf55707605cdac52bac56460f15163fa86687" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur when making a copy or buffering. Setting this to &amp;lsquo;unsafe&amp;rsquo; is not recommended, as it can adversely affect accumulations.</source>
          <target state="translated">복사 또는 버퍼링을 수행 할 때 어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이것을 '안전하지 않은'것으로 설정하면 누적에 악영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdeee7c21c5f079b8cf1347957a464129f951cd7" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b10dae3006bf56317c0969243da6568e60665a36" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur. Defaults to &amp;lsquo;unsafe&amp;rsquo; for backwards compatibility.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이전 버전과의 호환성을 위해 기본값은 '안전하지 않음'입니다.</target>
        </trans-unit>
        <trans-unit id="ef9a6184cd0365349f0a3f3a85fd00227eeb5110" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur. Setting this to &amp;lsquo;unsafe&amp;rsquo; is not recommended, as it can adversely affect accumulations.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이것을 '안전하지 않은'것으로 설정하면 누적에 악영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22a76f139a596a6451b3c663e17254b67d893014" translate="yes" xml:space="preserve">
          <source>Convenience class</source>
          <target state="translated">편의 수업</target>
        </trans-unit>
        <trans-unit id="d2fb0b32a197b1bc1c3268b6ce70b10c60d0e61b" translate="yes" xml:space="preserve">
          <source>Convenience function that accepts dimensions as input, e.g., &lt;code&gt;rand(2,2)&lt;/code&gt; would generate a 2-by-2 array of floats, uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">차원을 입력으로 받아들이는 편의 함수, 예를 들어 &lt;code&gt;rand(2,2)&lt;/code&gt; 는 &lt;code&gt;[0, 1)&lt;/code&gt; 균일하게 분포 된 2x2 부동 소수점 배열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="a01257e80e28e1d2f9b1bc8f0a212e62ad583d28" translate="yes" xml:space="preserve">
          <source>Conventional C libraries (installed through &lt;code&gt;add_library&lt;/code&gt;) are not installed, and are just used during the build (they are statically linked). An installable C library is a pure C library, which does not depend on the python C runtime, and is installed such that it may be used by third-party packages. To build and install the C library, you just use the method &lt;code&gt;add_installed_library&lt;/code&gt; instead of &lt;code&gt;add_library&lt;/code&gt;, which takes the same arguments except for an additional &lt;code&gt;install_dir&lt;/code&gt; argument:</source>
          <target state="translated">&lt;code&gt;add_library&lt;/code&gt; 를 통해 설치된 기존의 C 라이브러리 는 설치되지 않으며 빌드 중에 만 사용됩니다 (정적으로 링크되어 있음). 설치 가능한 C 라이브러리는 순수 C 라이브러리이며, Python C 런타임에 의존하지 않으며 타사 패키지에서 사용할 수 있도록 설치됩니다. C 라이브러리를 빌드하고 설치하려면 &lt;code&gt;add_library&lt;/code&gt; 대신 &lt;code&gt;add_installed_library&lt;/code&gt; 메소드를 사용하면됩니다.이 메소드 는 추가 &lt;code&gt;install_dir&lt;/code&gt; 인수를 제외하고 동일한 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="a17fb47b245c5cba5d75f315922fb16fc043d307" translate="yes" xml:space="preserve">
          <source>Conversion Utilities</source>
          <target state="translated">변환 유틸리티</target>
        </trans-unit>
        <trans-unit id="2ca5120be678740ebd6b346bd8c35bf444fe811c" translate="yes" xml:space="preserve">
          <source>Conversion between domains and class types can result in numerically ill defined series.</source>
          <target state="translated">도메인과 클래스 유형 간의 변환으로 인해 숫자가 잘못 정의 된 계열이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164fb2dcb28e63dc48fff2c40f2e5257de488afc" translate="yes" xml:space="preserve">
          <source>Conversion of &lt;code&gt;.src&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.src&lt;/code&gt; 파일 변환</target>
        </trans-unit>
        <trans-unit id="e986bec62e3e7ecaf96128a9c0f40c8e67846882" translate="yes" xml:space="preserve">
          <source>Conversion of &lt;code&gt;.src&lt;/code&gt; files using Templates</source>
          <target state="translated">템플릿을 사용하여 &lt;code&gt;.src&lt;/code&gt; 파일 변환</target>
        </trans-unit>
        <trans-unit id="da46a4c4a17ed3ea61b3092dc001141780833a19" translate="yes" xml:space="preserve">
          <source>Conversion operations</source>
          <target state="translated">변환 작업</target>
        </trans-unit>
        <trans-unit id="10a7c46d2fe217029ff23b380edb9248c804a468" translate="yes" xml:space="preserve">
          <source>Conversion; the operations &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt;. . They work only on arrays that have one element in them and return the appropriate scalar.</source>
          <target state="translated">변환; 작업은 &lt;code&gt;int&lt;/code&gt; 로 , &lt;code&gt;float&lt;/code&gt; 과 &lt;code&gt;complex&lt;/code&gt; . . 하나의 요소를 가진 배열에서만 작동하며 적절한 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5714517e2db28d492b0b79b54a5ada5c2a1521f" translate="yes" xml:space="preserve">
          <source>Conversions between types can be useful, but it is &lt;em&gt;not&lt;/em&gt; recommended for routine use. The loss of numerical precision in passing from a Chebyshev series of degree 50 to a Polynomial series of the same degree can make the results of numerical evaluation essentially random.</source>
          <target state="translated">유형 간 변환이 유용 할 수 있지만 일상적인 사용 &lt;em&gt;에는&lt;/em&gt; 권장 &lt;em&gt;되지 않습니다&lt;/em&gt; . 50 도의 체비 쇼프 계열에서 동일한 정도의 다항식 계열로 전달할 때 수치 정밀도가 손실되면 수치 평가 결과가 본질적으로 무작위로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03825a0528753ecd6c491dd8eedf420a0d9f4294" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;bytes&lt;/code&gt; in the encoding used by a subprocess into a filesystem-appropriate &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">변환은 &lt;code&gt;bytes&lt;/code&gt; 파일 시스템에 적합한 구성 프로세스에 의해 사용되는 인코딩 &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c7bd2e378946ee0f1c802ac20f6bf36a9ba9143" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a Fortran contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt; of the specified type. If the input object is not a Fortran contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt;, a new one will be created and the new object flag will be set.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 을 지정된 유형의 Fortran 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 변환 합니다. 입력 객체가 Fortran 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 가 아닌 경우 새로운 객체가 생성되고 새로운 객체 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="df4f3ea05c4d5f97fc6c549144dbe49c3b958747" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a NumPy array with the given &lt;code&gt;typecode&lt;/code&gt;. On success, return a valid &lt;code&gt;PyArrayObject*&lt;/code&gt; with the correct type. On failure, the Python error string will be set and the routine returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;typecode&lt;/code&gt; 를 사용하여 &lt;code&gt;input&lt;/code&gt; 을 NumPy 배열로 변환하십시오 . 성공하면 올바른 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 올바른 유형으로 반환 하십시오. 실패하면 Python 오류 문자열이 설정되고 루틴은 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="57614032e1d034b46eca1c59ddd0f6d15bf36d4e" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt; of the specified type. If the input object is not a contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt;, a new one will be created and the new object flag will be set.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 을 지정된 형식의 인접한 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 변환 합니다. 입력 객체가 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 가 아닌 경우 새로운 객체가 생성되고 새로운 객체 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="23cf93d55636e18fb2785cd6878809bff7d65f4b" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;number&lt;/code&gt; to the &lt;code&gt;base&lt;/code&gt; number system. The valid range is 2-36, the default value is 2.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 를 &lt;code&gt;base&lt;/code&gt; 숫자 시스템으로 변환하십시오 . 유효한 범위는 2-36이며 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="f55fe4032611ab151ac35085a484ba4bedcc1c10" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;obj&lt;/code&gt; to an ndarray. The argument can be any nested sequence or object that exports the array interface. This is a macro form of &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;NULL&lt;/code&gt;, 0, 0, 0 for the other arguments. Your code must be able to handle any data-type descriptor and any combination of data-flags to use this macro.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 를 ndarray로 변환하십시오 . 인수는 배열 인터페이스를 내보내는 중첩 시퀀스 또는 객체 일 수 있습니다. 이것은 다른 인수에 &lt;code&gt;NULL&lt;/code&gt; , 0, 0, 0을 사용 하는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 의 매크로 형식입니다 . 이 매크로를 사용하려면 코드에서 모든 데이터 유형 설명자와 모든 데이터 플래그 조합을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e59da10540b8b045df108e94cbefc0a270a68b5c" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; (starts with &amp;lsquo;q&amp;rsquo; or &amp;lsquo;Q&amp;rsquo;), &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; (starts with &amp;lsquo;h&amp;rsquo; or &amp;lsquo;H&amp;rsquo;), &lt;code&gt;NPY_MERGESORT&lt;/code&gt; (starts with &amp;lsquo;m&amp;rsquo; or &amp;lsquo;M&amp;rsquo;) or &lt;code&gt;NPY_STABLESORT&lt;/code&gt; (starts with &amp;lsquo;t&amp;rsquo; or &amp;lsquo;T&amp;rsquo;). &lt;code&gt;NPY_MERGESORT&lt;/code&gt; and &lt;code&gt;NPY_STABLESORT&lt;/code&gt; are aliased to each other for backwards compatibility and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">Python 문자열을 &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; ( 'q'또는 'Q'로 시작 ), &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; ( 'h'또는 'H'로 시작 ), &lt;code&gt;NPY_MERGESORT&lt;/code&gt; ( 'm'또는 'M'로 시작 ) 또는 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; ( '로 시작 ) 중 하나로 변환 위법'). &lt;code&gt;NPY_MERGESORT&lt;/code&gt; 와 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; 는 이전 버전과의 호환성을 위해 서로 별명을 지정하며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3306f9c5860e043187dbc26b17cfa1986c3541ca" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; (starts with &amp;lsquo;l&amp;rsquo; or &amp;lsquo;L&amp;rsquo;), or &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; (starts with &amp;lsquo;r&amp;rsquo; or &amp;lsquo;R&amp;rsquo;).</source>
          <target state="translated">Python 문자열을 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ( 'l'또는 'L'로 시작 ) 또는 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ( 'r'또는 'R'로 시작 ) 중 하나로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9665692749eb5f8271a8ef2c2766c29e0fe1a31a" translate="yes" xml:space="preserve">
          <source>Convert Python strings into the corresponding byte-order character: &amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;s&amp;rsquo;, &amp;lsquo;=&amp;rsquo;, or &amp;lsquo;|&amp;rsquo;.</source>
          <target state="translated">Python 문자열을 해당 바이트 순서 문자 ( '&amp;gt;', '&amp;lt;', 's', '='또는 '|')로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="0249cb69b2094a04bbecaea9fed7d306da9e809a" translate="yes" xml:space="preserve">
          <source>Convert a /-separated pathname to one using the OS&amp;rsquo;s path separator.</source>
          <target state="translated">OS의 경로 구분 기호를 사용하여 /로 구분 된 경로 이름을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="bbbde2984253b6c19463182f3ab3e49eacf0add1" translate="yes" xml:space="preserve">
          <source>Convert a Chebyshev series to a polynomial.</source>
          <target state="translated">Chebyshev 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3b725963ae7233b84da188095a5261995f877a10" translate="yes" xml:space="preserve">
          <source>Convert a Hermite series to a polynomial.</source>
          <target state="translated">Hermite 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c5774d379d320ad666e23c93d53c895b9282a781" translate="yes" xml:space="preserve">
          <source>Convert a Laguerre series to a polynomial.</source>
          <target state="translated">Laguerre 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c0cba427e743f4d7f6bd18952bc7a604ed734f1a" translate="yes" xml:space="preserve">
          <source>Convert a Legendre series to a polynomial.</source>
          <target state="translated">Legendre 시리즈를 다항식으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="7303080b96152a0bf0712c8711af50deecda280f" translate="yes" xml:space="preserve">
          <source>Convert a Python object, &lt;em&gt;obj&lt;/em&gt;, representing an axis argument to the proper value for passing to the functions that take an integer axis. Specifically, if &lt;em&gt;obj&lt;/em&gt; is None, &lt;em&gt;axis&lt;/em&gt; is set to &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; which is interpreted correctly by the C-API functions that take axis arguments.</source>
          <target state="translated">축 인수를 나타내는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 정수 축을 취하는 함수에 전달하기위한 적절한 값으로 변환합니다 . 특히 &lt;em&gt;obj&lt;/em&gt; 가 None 인 경우 &lt;em&gt;축은 &lt;/em&gt;&lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 로 설정되며 축 인수를 사용하는 C-API 함수에 의해 올바르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9724a7e14228c2698abcf68b1a251a0ae3b8f5" translate="yes" xml:space="preserve">
          <source>Convert a degree array to radians</source>
          <target state="translated">도 배열을 라디안으로 변환</target>
        </trans-unit>
        <trans-unit id="a5c1e0427139c907d167379333f020dfcf76dbc2" translate="yes" xml:space="preserve">
          <source>Convert a dtype into a ctypes type.</source>
          <target state="translated">dtype을 ctypes 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="04cea7e04fb2eca83318942c92f1c07b960f13bf" translate="yes" xml:space="preserve">
          <source>Convert a flat index into an index tuple.</source>
          <target state="translated">플랫 인덱스를 인덱스 튜플로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="608694c52c4ebed3a5e39984190479f5e8a306e1" translate="yes" xml:space="preserve">
          <source>Convert a list into an array. If all elements are finite &lt;code&gt;asarray_chkfinite&lt;/code&gt; is identical to &lt;code&gt;asarray&lt;/code&gt;.</source>
          <target state="translated">리스트를 배열로 변환합니다. 모든 요소가 유한 한 경우 &lt;code&gt;asarray_chkfinite&lt;/code&gt; 이 동일 &lt;code&gt;asarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03ed6ac231e004466351d76fc80aa6d480fc3b7" translate="yes" xml:space="preserve">
          <source>Convert a list into an array:</source>
          <target state="translated">리스트를 배열로 변환합니다 :</target>
        </trans-unit>
        <trans-unit id="9c374ac29e69d14674f6d6142f266b0eef36664b" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Chebyshev series.</source>
          <target state="translated">다항식을 체비 쇼프 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b5c9ed7a8b3e04ef89c09d23b7d0d8b444f0ef50" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Hermite series.</source>
          <target state="translated">다항식을 Hermite 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4e3ec08396dbbd66882318c251a298df01079281" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Laguerre series.</source>
          <target state="translated">다항식을 Laguerre 계열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="04c048566837ee3c2a27ff8795d4c53f80b84281" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Legendre series.</source>
          <target state="translated">다항식을 Legendre 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="030db426d65b1085bdfe94fd49af9bb5148d5b11" translate="yes" xml:space="preserve">
          <source>Convert a radian array to degrees</source>
          <target state="translated">라디안 배열을도 단위로 변환</target>
        </trans-unit>
        <trans-unit id="1fe8f7480d0d47cc60a5977befc1bf0fb1c97374" translate="yes" xml:space="preserve">
          <source>Convert a sequence of Python objects contained in &lt;em&gt;op&lt;/em&gt; to an array of ndarrays each having the same data type. The type is selected based on the typenumber (larger type number is chosen over a smaller one) ignoring objects that are only scalars. The length of the sequence is returned in &lt;em&gt;n&lt;/em&gt;, and an &lt;em&gt;n&lt;/em&gt; -length array of &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; pointers is the return value (or &lt;code&gt;NULL&lt;/code&gt; if an error occurs). The returned array must be freed by the caller of this routine (using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; ) and all the array objects in it &lt;code&gt;DECREF&lt;/code&gt; &amp;lsquo;d or a memory-leak will occur. The example template-code below shows a typically usage:</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 에 포함 된 일련의 Python 객체를 각각 동일한 데이터 유형을 가진 ndarray의 배열로 변환합니다. 유형은 스칼라 만있는 오브젝트를 무시하고 typenumber (작은 유형 번호보다 작은 유형 번호로 선택됨)를 기준으로 선택됩니다. 시퀀스의 길이는 &lt;em&gt;n&lt;/em&gt; 으로 반환되고 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 포인터 의 &lt;em&gt;n&lt;/em&gt; 길이 배열은 반환 값입니다 (또는 오류가 발생하면 &lt;code&gt;NULL&lt;/code&gt; ). 반환 된 배열은이 루틴의 호출자 ( &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt; &lt;code&gt;PyDataMem_FREE&lt;/code&gt; &lt;/a&gt; 사용 )에 의해 해제되어야 하고 &lt;code&gt;DECREF&lt;/code&gt; 'd에 있는 모든 배열 객체 가 발생하거나 메모리 누수가 발생합니다. 아래 예제 템플릿 코드는 일반적으로 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e101ec3d7ab1b665f48ac2d543089565c86aa54e" translate="yes" xml:space="preserve">
          <source>Convert all kinds of Python objects (including arrays and array scalars) to a (platform-pointer-sized) integer. On error, -1 is returned and an exception set.</source>
          <target state="translated">모든 종류의 Python 객체 (배열 및 배열 스칼라 포함)를 (플랫폼 포인터 크기) 정수로 변환합니다. 오류가 발생하면 -1이 반환되고 예외가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1af2928a63dcb1e8b49b18ef5eb4581fbe6b1379" translate="yes" xml:space="preserve">
          <source>Convert all kinds of Python objects (including arrays and array scalars) to a standard integer. On error, -1 is returned and an exception set. You may find useful the macro:</source>
          <target state="translated">모든 종류의 Python 객체 (배열 및 배열 스칼라 포함)를 표준 정수로 변환합니다. 오류가 발생하면 -1이 반환되고 예외가 설정됩니다. 당신은 유용한 매크로를 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ffbc378826f57347e9c8260b31120c1a5833498c" translate="yes" xml:space="preserve">
          <source>Convert an array of datetimes into an array of strings.</source>
          <target state="translated">날짜 시간 배열을 문자열 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="037f70609a1c007309e108da24f60e5d131632f5" translate="yes" xml:space="preserve">
          <source>Convert an array of size 1 to its scalar equivalent.</source>
          <target state="translated">크기가 1 인 배열을 스칼라 단위로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="53df29e4ff05ae420cc48926e99a3b9e70512010" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Chebyshev series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">체비 쇼프 계열의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;을 기준으로)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="6e39db716cf38d73c2e1474b5348e35ad5d45d64" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Hermite series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">최저 등급에서 최고 등급으로 정렬 된 Hermite 계열의 계수를 나타내는 배열을 최저 등급에서 최고 등급으로 정렬 된 등가 다항식 ( &quot;표준&quot;기준)의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8d92a2c5d4792677ccffae0416bcb9beb6eb167c" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Laguerre series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">Laguerre 계열의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;기준과 비교하여)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="a288bed0f35723755d6a37566e44ab92c6ecb769" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Legendre series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">Legendre 시리즈의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;기준을 기준으로)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="8f863e3ceaa930790565bf1f263428f91f82dc05" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Chebyshev series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 동등한 Chebyshev 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="77ebeb329b7c408d6e1a1754f29dec3917a76884" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Hermite series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고까지 정렬 된 동등한 Hermite 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5d3f4ebc3ae40ac476278051222e82a2168385fe" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Laguerre series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 동등한 Laguerre 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cec81c86dbe89e8d496cab1ec6207291b41341cd" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Legendre series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 해당 Legendre 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b17b279b5dccfd644af2817f95777400cf1861d" translate="yes" xml:space="preserve">
          <source>Convert angles from degrees to radians.</source>
          <target state="translated">각도를도에서 라디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7b990b4a48262db5915c35fe0989adfb1e63af66" translate="yes" xml:space="preserve">
          <source>Convert angles from radians to degrees.</source>
          <target state="translated">각도를 라디안에서 각도로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="45815db69ac2df469f002b3c383b11df15d3fe0f" translate="yes" xml:space="preserve">
          <source>Convert any Python object to a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;obj&lt;/em&gt;) is TRUE then its reference count is incremented and a reference placed in &lt;em&gt;address&lt;/em&gt;. If &lt;em&gt;obj&lt;/em&gt; is not an array, then convert it to an array using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; . No matter what is returned, you must DECREF the object returned by this routine in &lt;em&gt;address&lt;/em&gt; when you are done with it.</source>
          <target state="translated">Python 객체를 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 로&lt;/a&gt; 변환하십시오 . 경우 &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj가&lt;/em&gt; ) TRUE 인 다음의 기준 카운트는 증분되고 참조가 배치 &lt;em&gt;주소&lt;/em&gt; . &lt;em&gt;obj&lt;/em&gt; 가 배열이 아닌 경우 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 사용하여 배열로 변환하십시오 . 리턴 된 내용에 관계없이이 루틴이 리턴 한 오브젝트를 &lt;em&gt;주소&lt;/em&gt; 로 DECREF해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2c520cfad3eae214eac5cb30701aacd3d0256a7c" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, to &lt;a href=&quot;#c.NPY_TRUE&quot;&gt;&lt;code&gt;NPY_TRUE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_FALSE&quot;&gt;&lt;code&gt;NPY_FALSE&lt;/code&gt;&lt;/a&gt;, and place the result in &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;a href=&quot;#c.NPY_TRUE&quot;&gt; &lt;code&gt;NPY_TRUE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_FALSE&quot;&gt; &lt;code&gt;NPY_FALSE&lt;/code&gt; 로&lt;/a&gt; 변환 하고 결과를 &lt;em&gt;value에&lt;/em&gt; 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f11d66b7da05915fa0d0dcb369cc6d4a2e56d6e" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, with a (single-segment) buffer interface to a variable with members that detail the object&amp;rsquo;s use of its chunk of memory. The &lt;em&gt;buf&lt;/em&gt; variable is a pointer to a structure with base, ptr, len, and flags members. The &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Chunk&quot;&gt;&lt;code&gt;PyArray_Chunk&lt;/code&gt;&lt;/a&gt; structure is binary compatible with the Python&amp;rsquo;s buffer object (through its len member on 32-bit platforms and its ptr member on 64-bit platforms or in Python 2.5). On return, the base member is set to &lt;em&gt;obj&lt;/em&gt; (or its base if &lt;em&gt;obj&lt;/em&gt; is already a buffer object pointing to another object). If you need to hold on to the memory be sure to INCREF the base member. The chunk of memory is pointed to by &lt;em&gt;buf&lt;/em&gt; -&amp;gt;ptr member and has length &lt;em&gt;buf&lt;/em&gt; -&amp;gt;len. The flags member of &lt;em&gt;buf&lt;/em&gt; is &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; with the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag set if &lt;em&gt;obj&lt;/em&gt; has a writeable buffer interface.</source>
          <target state="translated">(단일 세그먼트) 버퍼 인터페이스가있는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 객체의 메모리 청크 사용을 자세히 설명하는 멤버가있는 변수로 변환합니다. &lt;em&gt;버피&lt;/em&gt; 변수베이스 PTR, 렌 및 플래그 부재와 구조에 대한 포인터이다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Chunk&quot;&gt; &lt;code&gt;PyArray_Chunk&lt;/code&gt; 의&lt;/a&gt; 구조 (32 비트 플랫폼의 LEN 부재 및 64 비트 플랫폼 파이썬 2.5 PTR의 부재를 통해) 파이썬 버퍼 객체 바이너리 호환. 돌아 왔을 때,베이스 멤버는 &lt;em&gt;obj&lt;/em&gt; (또는 &lt;em&gt;obj&lt;/em&gt; 가 다른 오브젝트를 가리키는 버퍼 오브젝트 인 경우 는 그베이스 )로 설정됩니다. 메모리를 잡아야하는 경우 반드시베이스 멤버를 INCREF해야합니다. 메모리 청크는 &lt;em&gt;buf-&lt;/em&gt; &amp;gt; ptr 멤버 가 가리키고 길이가 있습니다.&lt;em&gt;buf-&lt;/em&gt; &amp;gt; len. &lt;em&gt;obj&lt;/em&gt; 에 쓰기 가능한 버퍼 인터페이스가있는 경우 &lt;em&gt;buf&lt;/em&gt; 의 플래그 멤버 는 &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; 이며 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그가 설정됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c75a292870c1a62f954752682b5e4d2572c8fb49" translate="yes" xml:space="preserve">
          <source>Convert any Python sequence (or single Python number) passed in as &lt;em&gt;seq&lt;/em&gt; to (up to) &lt;em&gt;maxvals&lt;/em&gt; pointer-sized integers and place them in the &lt;em&gt;vals&lt;/em&gt; array. The sequence can be smaller then &lt;em&gt;maxvals&lt;/em&gt; as the number of converted objects is returned.</source>
          <target state="translated">&lt;em&gt;seq&lt;/em&gt; 로 전달 된 모든 Python 시퀀스 (또는 단일 Python 번호) 를 최대 포인터 크기의 정수 (최대)까지 &lt;em&gt;변환&lt;/em&gt; 하여 &lt;em&gt;vals&lt;/em&gt; 배열 에 배치합니다 . 변환 된 오브젝트 수가 리턴 될 때 순서는 &lt;em&gt;maxvals&lt;/em&gt; 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa9c12af167e2e17ab265f1ff4c7ad781660a664" translate="yes" xml:space="preserve">
          <source>Convert any Python sequence, &lt;em&gt;obj&lt;/em&gt;, smaller than &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; to a C-array of &lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;. The Python object could also be a single number. The &lt;em&gt;seq&lt;/em&gt; variable is a pointer to a structure with members ptr and len. On successful return, &lt;em&gt;seq&lt;/em&gt; -&amp;gt;ptr contains a pointer to memory that must be freed, by calling &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt;&lt;code&gt;PyDimMem_FREE&lt;/code&gt;&lt;/a&gt;, to avoid a memory leak. The restriction on memory size allows this converter to be conveniently used for sequences intended to be interpreted as array shapes.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 보다 작은 Python 시퀀스 &lt;em&gt;obj&lt;/em&gt; 를 npy_intp 의 C- 배열로 &lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt; &lt;code&gt;npy_intp&lt;/code&gt; &lt;/a&gt; . Python 객체는 단일 숫자 일 수도 있습니다. &lt;em&gt;서열의&lt;/em&gt; 변수는 렌과 PTR 회원들과 구조에 대한 포인터입니다. 성공적인 복귀에 &lt;em&gt;서열&lt;/em&gt; -&amp;gt; PTR은 호출하여 해제해야 메모리에 대한 포인터를 포함 &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt; &lt;code&gt;PyDimMem_FREE&lt;/code&gt; 을&lt;/a&gt; 메모리 누수를 방지하기를. 메모리 크기 제한으로 인해이 변환기는 배열 형태로 해석되는 시퀀스에 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69da68263fbc339b854ebcf71b991e1eb9b1a25a" translate="yes" xml:space="preserve">
          <source>Convert any compatible Python object, &lt;em&gt;obj&lt;/em&gt;, to a data-type object in &lt;em&gt;dtype&lt;/em&gt;. A large number of Python objects can be converted to data-type objects. See &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt; for a complete description. This version of the converter converts None objects to a &lt;a href=&quot;c-api.dtype#c.NPY_DEFAULT_TYPE&quot;&gt;&lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt;&lt;/a&gt; data-type object. This function can be used with the &amp;ldquo;O&amp;amp;&amp;rdquo; character code in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; processing.</source>
          <target state="translated">호환 가능한 Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;dtype&lt;/em&gt; 의 데이터 유형 객체로 &lt;em&gt;변환&lt;/em&gt; 합니다. 많은 수의 Python 객체를 데이터 유형 객체로 변환 할 수 있습니다. 자세한 설명은 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 오브젝트 (dtype)&lt;/a&gt; 를 참조하십시오 . 이 버전의 변환기는 None 개체를 &lt;a href=&quot;c-api.dtype#c.NPY_DEFAULT_TYPE&quot;&gt; &lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt; &lt;/a&gt; 데이터 형식 개체 로 변환 합니다. 이 기능은 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 처리 에서 &quot;O &amp;amp;&quot;문자 코드와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76aa53d3435e68fd8a448322e838d44b487cd7d8" translate="yes" xml:space="preserve">
          <source>Convert any compatible Python object, &lt;em&gt;obj&lt;/em&gt;, to a data-type object in &lt;em&gt;dtype&lt;/em&gt;. This version of the converter converts None objects so that the returned data-type is &lt;code&gt;NULL&lt;/code&gt;. This function can also be used with the &amp;ldquo;O&amp;amp;&amp;rdquo; character in PyArg_ParseTuple processing.</source>
          <target state="translated">호환 가능한 Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;dtype&lt;/em&gt; 의 데이터 유형 객체로 &lt;em&gt;변환&lt;/em&gt; 합니다. 이 버전의 변환기는 반환 된 데이터 유형이 &lt;code&gt;NULL&lt;/code&gt; 이되도록 None 객체를 변환 합니다 . 이 기능은 PyArg_ParseTuple 처리에서 &quot;O &amp;amp;&quot;문자와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9aec6c9ded5002efcbad399df89142237d7cc00" translate="yes" xml:space="preserve">
          <source>Convert input to a contiguous (C order) array.</source>
          <target state="translated">입력을 연속 (C 순서) 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="420fb690c0edc53e8debde6a0ec4d275687ce3ce" translate="yes" xml:space="preserve">
          <source>Convert input to a contiguous array.</source>
          <target state="translated">입력을 연속 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="33c1cb2e227b9bd61de344d0e7fbaab99233af47" translate="yes" xml:space="preserve">
          <source>Convert input to a floating point ndarray.</source>
          <target state="translated">입력을 부동 소수점 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a5f5c7c34bf3d8463c0f5b22aa43e1fd52fac998" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray with column-major memory order.</source>
          <target state="translated">열 주요 메모리 순서로 입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="045aaccfe763e323c93890206739ec75aade7286" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray with either row or column-major memory order.</source>
          <target state="translated">행 또는 열 주요 메모리 순서로 입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ef171cc954b4a91951ba1a6dda729099545ddf" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray.</source>
          <target state="translated">입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ccd7aa35d1ae2b4dc3b90cbbf72ce01559391330" translate="yes" xml:space="preserve">
          <source>Convert inputs to arrays with at least one dimension.</source>
          <target state="translated">입력 값을 1 차원 이상의 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a6f15509196d96b84e75e30f612e180331511cb6" translate="yes" xml:space="preserve">
          <source>Convert obj and place it in the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the place pointed to by itemptr. Return -1 if an error occurs or 0 on success.</source>
          <target state="translated">obj를 변환하고 itemptr이 가리키는 위치 의 ndarray &lt;em&gt;arr&lt;/em&gt; 에 배치하십시오. 에러가 발생하면 -1을, 성공하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="576d85a9ac7f4bb463bcd686151b14889c6fa48b" translate="yes" xml:space="preserve">
          <source>Convert series to a different kind and/or domain and/or window.</source>
          <target state="translated">시리즈를 다른 종류 및 / 또는 도메인 및 / 또는 창으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3f437b5b2be6d379bf2552ef729b64b4968647ed" translate="yes" xml:space="preserve">
          <source>Convert series to series of this class.</source>
          <target state="translated">시리즈를이 클래스의 시리즈로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="11dd67ff4e76c78a832c4fe82ad1fa604de8aae0" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;C&amp;rsquo;, &amp;lsquo;F&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, and &amp;lsquo;K&amp;rsquo; into the &lt;a href=&quot;#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'C', 'F', 'A'및 'K'를 &lt;a href=&quot;#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 로 변환하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e537ead60d0d43e6e588d78323ccc29eca3c8343" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;clip&amp;rsquo;, &amp;lsquo;wrap&amp;rsquo;, and &amp;lsquo;raise&amp;rsquo; into the &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt;&lt;code&gt;NPY_CLIPMODE&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'clip', 'wrap'및 'raise'를 &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt; &lt;code&gt;NPY_CLIPMODE&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; 로 변환하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc37cf0719273a042d912bf17405514329ce06ef" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;no&amp;rsquo;, &amp;lsquo;equiv&amp;rsquo;, &amp;lsquo;safe&amp;rsquo;, &amp;lsquo;same_kind&amp;rsquo;, and &amp;lsquo;unsafe&amp;rsquo; into the &lt;a href=&quot;#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'no', 'equiv', 'safe', 'same_kind'및 'unsafe'를 &lt;a href=&quot;#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="815ebb3363dd660001d42495eb8ae85f74f839e8" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="89dd3b39429f0c57adb052e020bf83426fade26c" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="0806bab1a140533a0bd7db5d9d14e0735040e429" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f61cec71e421e2035c68b35503551782f13e38" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;code&gt;chararray&lt;/code&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;code&gt;chararray&lt;/code&gt; 로 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="98730b39eb982a451cdb3b14184177191517f090" translate="yes" xml:space="preserve">
          <source>Convert the input to a masked array of the given data-type.</source>
          <target state="translated">입력을 주어진 데이터 유형의 마스크 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="049b0255d3e880a109ec0e5f8d964f2db189e876" translate="yes" xml:space="preserve">
          <source>Convert the input to a masked array, conserving subclasses.</source>
          <target state="translated">서브 클래스를 보존하면서 입력을 마스크 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff8828938f9435e62b42845c72c1f7535705ef18" translate="yes" xml:space="preserve">
          <source>Convert the input to an array, checking for NaNs or Infs.</source>
          <target state="translated">NaN 또는 Infs를 확인하여 입력을 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a3dfbf8e7020f742fa20a33d892353893c53d156" translate="yes" xml:space="preserve">
          <source>Convert the input to an array.</source>
          <target state="translated">입력을 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a1ee418db1bf6815f8924edb3f1ae12bdde4d6" translate="yes" xml:space="preserve">
          <source>Convert the input to an ndarray, but pass ndarray subclasses through.</source>
          <target state="translated">입력을 ndarray로 변환하지만 ndarray 서브 클래스를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="7e4e1bb160f7f12732c4b9f9c2fff13135191fc1" translate="yes" xml:space="preserve">
          <source>Convert to an ndarray, but pass through ndarray subclasses.</source>
          <target state="translated">ndarray로 변환하지만 ndarray 서브 클래스를 통과하십시오.</target>
        </trans-unit>
        <trans-unit id="0bf45673533df66645f8a1830f766ff21a3245ff" translate="yes" xml:space="preserve">
          <source>Convert to float.</source>
          <target state="translated">float로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4d25fc1fde9972ce3ca1a8543e86c1eba0e323da" translate="yes" xml:space="preserve">
          <source>Convert to int.</source>
          <target state="translated">int로 변환</target>
        </trans-unit>
        <trans-unit id="7cc45909f5c77c707373cc2714501a4d53754e23" translate="yes" xml:space="preserve">
          <source>Convert to long.</source>
          <target state="translated">길게 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="3ae1f71abfac0c88927feea8e530f4f046de5146" translate="yes" xml:space="preserve">
          <source>Convert typestring characters (with &lt;em&gt;itemsize&lt;/em&gt;) to basic enumerated data types. The typestring character corresponding to signed and unsigned integers, floating point numbers, and complex-floating point numbers are recognized and converted. Other values of gentype are returned. This function can be used to convert, for example, the string &amp;lsquo;f4&amp;rsquo; to &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT32&quot;&gt;&lt;code&gt;NPY_FLOAT32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 문자열 문자 ( &lt;em&gt;itemsize 포함&lt;/em&gt; )를 기본 열거 데이터 유형으로 변환하십시오 . 부호있는 정수 및 부호없는 정수, 부동 소수점 숫자 및 복소수 부동 소수점 숫자에 해당하는 유형 문자열 문자가 인식되고 변환됩니다. gentype의 다른 값이 리턴됩니다. 이 함수는 예를 들어 문자열 'f4'를 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT32&quot;&gt; &lt;code&gt;NPY_FLOAT32&lt;/code&gt; &lt;/a&gt; 로 변환하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e546d48fddfc2b2309057fe0163a99c4890872bf" translate="yes" xml:space="preserve">
          <source>Converting data types</source>
          <target state="translated">데이터 타입 변환</target>
        </trans-unit>
        <trans-unit id="7742f5240e1d4873e47ef6d80ce8f9d7eed5d915" translate="yes" xml:space="preserve">
          <source>Converting from Previous NumPy Iterators</source>
          <target state="translated">이전 NumPy 반복자에서 변환</target>
        </trans-unit>
        <trans-unit id="39ce420f01e01a6e4767054eb7e780c8c56e6e83" translate="yes" xml:space="preserve">
          <source>Converts a double-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system&amp;rsquo;s floating point underflow or overflow bit will be set.</source>
          <target state="translated">배정 밀도 부동 소수점을 반 정밀도 부동 소수점으로 변환합니다. 값은 가장 가까운 반올림으로 반올림되며, 가장 가까운 짝수로 연결됩니다. 값이 너무 작거나 크면 시스템의 부동 소수점 언더 플로 또는 오버플로 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e78be2704a6f40b5c4f51bfc40fd50007ac5b7c1" translate="yes" xml:space="preserve">
          <source>Converts a flat index or array of flat indices into a tuple of coordinate arrays.</source>
          <target state="translated">플랫 인덱스 또는 플랫 인덱스 배열을 튜플 좌표 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff19be80738f9cb33fa734371385cb9e202a0fe3" translate="yes" xml:space="preserve">
          <source>Converts a half-precision float to a double-precision float.</source>
          <target state="translated">반 정밀도 부동 소수점을 배정 밀도 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="225d72d1ef1fe464a60bf24f2bcd8995f6d8fb0b" translate="yes" xml:space="preserve">
          <source>Converts a half-precision float to a single-precision float.</source>
          <target state="translated">반 정밀도 부동 소수점을 단 정밀도 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b56df4d4b865c9ec05a120e856faf6520f962717" translate="yes" xml:space="preserve">
          <source>Converts a single-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system&amp;rsquo;s floating point underflow or overflow bit will be set.</source>
          <target state="translated">단 정밀도 부동 소수점을 반 정밀도 부동 소수점으로 변환합니다. 값은 가장 가까운 반올림으로 반올림되며, 가장 가까운 짝수로 연결됩니다. 값이 너무 작거나 크면 시스템의 부동 소수점 언더 플로 또는 오버플로 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3ee1fe16ee1828b519f490c6bae9191c320478" translate="yes" xml:space="preserve">
          <source>Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.</source>
          <target state="translated">인덱스 배열의 튜플을 다중 인덱스에 경계 모드를 적용하여 플랫 인덱스 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4d7fdb170c1f22bd4d4e265e352eb1cd10b68118" translate="yes" xml:space="preserve">
          <source>Converts either a sequence of clipmodes or a single clipmode into a C array of &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt;&lt;code&gt;NPY_CLIPMODE&lt;/code&gt;&lt;/a&gt; values. The number of clipmodes &lt;em&gt;n&lt;/em&gt; must be known before calling this function. This function is provided to help functions allow a different clipmode for each dimension.</source>
          <target state="translated">일련의 클립 모드 또는 단일 클립 모드를 &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt; &lt;code&gt;NPY_CLIPMODE&lt;/code&gt; &lt;/a&gt; 값 의 C 배열로 변환 합니다. 이 함수를 호출하기 전에 클립 모드 수 &lt;em&gt;n을&lt;/em&gt; 알아야합니다. 이 기능은 각 차원마다 다른 클립 모드를 허용하는 기능을 제공하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="250dc78cc5a9ee71a58ec6ac7dd196d5163a36c3" translate="yes" xml:space="preserve">
          <source>Convolve two arrays using the Fast Fourier Transform.</source>
          <target state="translated">고속 푸리에 변환 (Fast Fourier Transform)을 사용하여 두 개의 배열을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="576bd4ebce16db77995374ff7c034483bd0ae542" translate="yes" xml:space="preserve">
          <source>Cooley, James W., and John W. Tukey, 1965, &amp;ldquo;An algorithm for the machine calculation of complex Fourier series,&amp;rdquo; &lt;em&gt;Math. Comput.&lt;/em&gt; 19: 297-301.</source>
          <target state="translated">Cooley, James W. 및 1965 년 John W. Tukey,&amp;ldquo;복잡한 푸리에 시리즈의 기계 계산 알고리즘&amp;rdquo; &lt;em&gt;Math. 계산. &lt;/em&gt;19 : 297-301.</target>
        </trans-unit>
        <trans-unit id="6c00b1c278cb1ce0a4df76e32fd03a9e07108220" translate="yes" xml:space="preserve">
          <source>Copies values from one array to another, broadcasting as necessary.</source>
          <target state="translated">필요에 따라 브로드 캐스트하여 한 배열에서 다른 배열로 값을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="c60275d5c5be7a657ffd107291e98055ec17c0e9" translate="yes" xml:space="preserve">
          <source>Copy an element of an array to a standard Python scalar and return it.</source>
          <target state="translated">배열의 요소를 표준 Python 스칼라에 복사하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da203dab271c623df22148990806ffd79128f7db" translate="yes" xml:space="preserve">
          <source>Copy from the source array, &lt;code&gt;src&lt;/code&gt;, into the destination array, &lt;code&gt;dest&lt;/code&gt;, performing a data-type conversion if necessary. If an error occurs return -1 (otherwise 0). The shape of &lt;code&gt;src&lt;/code&gt; must be broadcastable to the shape of &lt;code&gt;dest&lt;/code&gt;. The data areas of dest and src must not overlap.</source>
          <target state="translated">소스 배열 &lt;code&gt;src&lt;/code&gt; 에서 대상 배열 &lt;code&gt;dest&lt;/code&gt; 로 복사하여 필요한 경우 데이터 유형 변환을 수행하십시오. 오류가 발생하면 -1을 반환하십시오 (그렇지 않으면 0). 의 모양 &lt;code&gt;src&lt;/code&gt; 의 형상 캐스트 가능한해야합니다 &lt;code&gt;dest&lt;/code&gt; . dest 및 src의 데이터 영역이 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9cf4b88f8aea8dc3032e39289c48a6f6e4000cca" translate="yes" xml:space="preserve">
          <source>Copy of self.</source>
          <target state="translated">자기의 사본.</target>
        </trans-unit>
        <trans-unit id="0f7a2502580eeb2a37c3da78f6d85e2d28d19dcb" translate="yes" xml:space="preserve">
          <source>Copy of the array, cast to a specified type.</source>
          <target state="translated">지정된 유형으로 캐스트 된 배열의 사본</target>
        </trans-unit>
        <trans-unit id="1855ebfecee0e89a08817f0c462727dd9e51acd0" translate="yes" xml:space="preserve">
          <source>Copy the mask and set the sharedmask flag to False.</source>
          <target state="translated">마스크를 복사하고 sharedmask 플래그를 False로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="eda7f5e21aefc109d198cff2108b69be2a88ea2f" translate="yes" xml:space="preserve">
          <source>Copy-on-write memmap:</source>
          <target state="translated">복사 중 쓰기 memmap :</target>
        </trans-unit>
        <trans-unit id="9efdf61f90e514f177252ac8197d7a3fecad778b" translate="yes" xml:space="preserve">
          <source>Copy-on-write: assignments affect data in memory, but changes are not saved to disk. The file on disk is read-only.</source>
          <target state="translated">기록 중 복사 : 할당은 메모리의 데이터에 영향을 주지만 변경 사항은 디스크에 저장되지 않습니다. 디스크의 파일이 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5b33d787803ee72e85555afb13ca15c7e8e68b1e" translate="yes" xml:space="preserve">
          <source>Core Dimension</source>
          <target state="translated">핵심 치수</target>
        </trans-unit>
        <trans-unit id="a935f62f1a313ebc5f0b4349a182f187ea660c8d" translate="yes" xml:space="preserve">
          <source>Core dimensions assigned to the same label in the signature (e.g. the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;inner1d&lt;/code&gt;&amp;rsquo;s &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;) must have exactly matching sizes, no broadcasting is performed.</source>
          <target state="translated">서명에 동일한 레이블 할당 코어 크기 (예 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;inner1d&lt;/code&gt; 의 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; )을 정확하게 일치하는 크기를 가져야에는 방송이 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="a85e68f4d74fe8012fbcc947dee9e830301ccda9" translate="yes" xml:space="preserve">
          <source>Core dimensions assigned to the same label in the signature must have exactly matching sizes, no broadcasting is performed.</source>
          <target state="translated">서명에서 동일한 레이블에 지정된 코어 크기는 정확히 일치하는 크기 여야하며 브로드 캐스트가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77d90b4a2e78538417c275f69722b0ac5a0a99f5" translate="yes" xml:space="preserve">
          <source>Core dimensions of each input or output array are represented by a list of dimension names in parentheses, &lt;code&gt;(i_1,...,i_N)&lt;/code&gt;; a scalar input/output is denoted by &lt;code&gt;()&lt;/code&gt;. Instead of &lt;code&gt;i_1&lt;/code&gt;, &lt;code&gt;i_2&lt;/code&gt;, etc, one can use any valid Python variable name.</source>
          <target state="translated">각 입력 또는 출력 배열의 핵심 치수는 괄호 안에 치수 이름 목록으로 표시됩니다 &lt;code&gt;(i_1,...,i_N)&lt;/code&gt; . 스칼라 입력 / 출력은 &lt;code&gt;()&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;i_1&lt;/code&gt; , &lt;code&gt;i_2&lt;/code&gt; 등 대신 유효한 Python 변수 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fda43cf5b94de17f1701a1daa8838cd689d1ac" translate="yes" xml:space="preserve">
          <source>Core signature string</source>
          <target state="translated">핵심 서명 문자열</target>
        </trans-unit>
        <trans-unit id="9a73d7eeec664afb4494a9c7d06291968be1807f" translate="yes" xml:space="preserve">
          <source>Cormen, &amp;ldquo;Introduction to Algorithms&amp;rdquo;, Chapter 15.2, p. 370-378</source>
          <target state="translated">Cormen,&amp;ldquo;알고리즘 소개&amp;rdquo;, 15.2 장, p. 370-378</target>
        </trans-unit>
        <trans-unit id="e09f45c90809a295b044ca045b6666387613a15c" translate="yes" xml:space="preserve">
          <source>Correlating</source>
          <target state="translated">Correlating</target>
        </trans-unit>
        <trans-unit id="c3ffb59304cd35f5989ecead23c1e787437b571d" translate="yes" xml:space="preserve">
          <source>Correspondingly, when the spectrum is purely real, the signal is Hermitian. The &lt;a href=&quot;generated/numpy.fft.hfft#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; family of functions exploits this symmetry by using &lt;code&gt;n/2+1&lt;/code&gt; complex points in the input (time) domain for &lt;code&gt;n&lt;/code&gt; real points in the frequency domain.</source>
          <target state="translated">이에 따라 스펙트럼이 순전히 실제 인 경우 신호는 에르 미트 (Hermitian)입니다. &lt;a href=&quot;generated/numpy.fft.hfft#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; 의&lt;/a&gt; 기능 가족 사용하여이 대칭성을 이용 &lt;code&gt;n/2+1&lt;/code&gt; 의 입력 (시간) 영역에서 복잡한 포인트 &lt;code&gt;n&lt;/code&gt; 주파수 영역에서 실시간 포인트.</target>
        </trans-unit>
        <trans-unit id="ef15bde640af7d5282d372b3668304d3b57605b8" translate="yes" xml:space="preserve">
          <source>Cosine element-wise.</source>
          <target state="translated">요소 별 코사인.</target>
        </trans-unit>
        <trans-unit id="f85bd4ac12155f7ab384c763ede09ca77aca792b" translate="yes" xml:space="preserve">
          <source>Count masked elements in array or along a given axis.</source>
          <target state="translated">배열 또는 주어진 축을 따라 마스크 된 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="dc43a8e6604d12ce95e869b8a107c8a135d37cfb" translate="yes" xml:space="preserve">
          <source>Count non-masked elements.</source>
          <target state="translated">마스크되지 않은 요소를 세십시오.</target>
        </trans-unit>
        <trans-unit id="fcd7647bccacf473f6f7538a24a5d644b1446db8" translate="yes" xml:space="preserve">
          <source>Count number of occurrences of each value in array of non-negative ints.</source>
          <target state="translated">음수가 아닌 정수의 배열에서 각 값의 발생 횟수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="32c1e63927fc36a57080f439614d4f3a9e9a4010" translate="yes" xml:space="preserve">
          <source>Count the non-masked elements of the array along the given axis.</source>
          <target state="translated">주어진 축을 따라 배열의 마스크되지 않은 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f478aa803be450d56ad50466a52a872cccc5840c" translate="yes" xml:space="preserve">
          <source>Count the number of masked elements along the given axis.</source>
          <target state="translated">주어진 축을 따라 마스크 된 요소의 수를 센다.</target>
        </trans-unit>
        <trans-unit id="78bd22c42b14c011a02df9e7d1c6c3966b587ac6" translate="yes" xml:space="preserve">
          <source>Counter to use in the Philox state. Can be either a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array. If not provided, the RNG is initialized at 0.</source>
          <target state="translated">Philox 상태에서 사용할 카운터. [0, 2 ** 256의 Python int (2.x에서 길게)) 또는 4 요소 uint64 배열 일 수 있습니다. 제공되지 않으면 RNG는 0에서 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="7810ca2eec9994e430b34bfbe7314516c25672d5" translate="yes" xml:space="preserve">
          <source>Counting</source>
          <target state="translated">Counting</target>
        </trans-unit>
        <trans-unit id="341d54df06a257a5db8eb7bb0f7914e4712491fe" translate="yes" xml:space="preserve">
          <source>Counting the missing elements</source>
          <target state="translated">누락 된 요소 계산</target>
        </trans-unit>
        <trans-unit id="e51f7ebad6498090d852d60e0437352e55df1b6d" translate="yes" xml:space="preserve">
          <source>Counts how many valid days are in a half-open date range.</source>
          <target state="translated">반 개방 날짜 범위에있는 유효 일수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ab06dd416d9201cfa1a776030c3073f0f296ef5c" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero elements in the array object &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">배열 객체 &lt;em&gt;self&lt;/em&gt; 의 0이 아닌 요소의 수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="35b1783f22a005e4a0e9aa8326071116370e26da" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero elements in the input array.</source>
          <target state="translated">입력 배열에서 0이 아닌 요소의 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c93aeb4f5df8b4c7a7489b48cdc9da95b95d9241" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero values in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 의 0이 아닌 값의 개수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a82b9a1216f695b2de1af812d1dbbca1ab80309a" translate="yes" xml:space="preserve">
          <source>Counts the number of valid days between &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt;, not including the day of &lt;code&gt;enddates&lt;/code&gt;.</source>
          <target state="translated">사이의 유효 기간 (일) 카운트 &lt;code&gt;begindates&lt;/code&gt; 및 &lt;code&gt;enddates&lt;/code&gt; 의 날을 포함하지 않는, &lt;code&gt;enddates&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0acc19acc7d5ef1e19db778f62f9ff93707d13fa" translate="yes" xml:space="preserve">
          <source>Covariance indicates the level to which two variables vary together. From the multivariate normal distribution, we draw N-dimensional samples,</source>
          <target state="translated">공분산은 두 변수가 서로 다른 수준을 나타냅니다. 다변량 정규 분포에서 N 차원 표본을 그리고</target>
        </trans-unit>
        <trans-unit id="146d5410def5b1425b9181e3a3d6c9a98ceaffcd" translate="yes" xml:space="preserve">
          <source>Covariance indicates the level to which two variables vary together. If we examine N-dimensional samples,</source>
          <target state="translated">공분산은 두 변수가 서로 다른 수준을 나타냅니다. N 차원 샘플을 살펴보면</target>
        </trans-unit>
        <trans-unit id="7e3640f844cf3cff392814080ea6e4fc7ebf5942" translate="yes" xml:space="preserve">
          <source>Covariance matrix</source>
          <target state="translated">공분산 행렬</target>
        </trans-unit>
        <trans-unit id="ba1dce691b3dd8e45383b40c4c84fa04284a8fb4" translate="yes" xml:space="preserve">
          <source>Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling.</source>
          <target state="translated">분포의 공분산 행렬. 적절한 샘플링을 위해서는 대칭적이고 양의 반음 수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e198169e22830014df6d95b3cbbb568dc11dce1f" translate="yes" xml:space="preserve">
          <source>Create a 2-D array with the flattened input as a diagonal.</source>
          <target state="translated">평평한 입력을 대각선으로 사용하여 2 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a59869cacd92085b66bb144f1578d32820c3bbe9" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e8c7020003f7473689a082f3999dbe024d7d290f" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="cf1fd6b11165877b30f8adf628ec7e27985f2765" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c66092d36950339cb427dfcbe2dfba19b7f580ca" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;chararray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chararray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="053bb3dd5cd61ee6d9da229f972809abcee13ee6" translate="yes" xml:space="preserve">
          <source>Create a boolean mask from an array.</source>
          <target state="translated">배열에서 부울 마스크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d93c678b3ed0b4d36476f41968f0182b90056627" translate="yes" xml:space="preserve">
          <source>Create a data type object.</source>
          <target state="translated">데이터 형식 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a87756a536e33363736738458832ff08b923fefb" translate="yes" xml:space="preserve">
          <source>Create a data-type.</source>
          <target state="translated">데이터 유형을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="93eb0ae31609f0ed48c3c5dfd8b5a3cb8402ac97" translate="yes" xml:space="preserve">
          <source>Create a matrix of the given shape and propagate it with random samples from a uniform distribution over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">주어진 모양의 행렬을 만들고 &lt;code&gt;[0, 1)&lt;/code&gt; 대한 균일 분포의 랜덤 표본으로 전파합니다 .</target>
        </trans-unit>
        <trans-unit id="c295b748c8517694492f48fd31f9b376f9c645c8" translate="yes" xml:space="preserve">
          <source>Create a memmap with dtype and shape that matches our data:</source>
          <target state="translated">데이터와 일치하는 dtype과 shape로 memmap을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="19e2c3798e7032d352bdeb16a194e1b2b2271bab" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a &lt;em&gt;binary&lt;/em&gt; file on disk.</source>
          <target state="translated">디스크 의 &lt;em&gt;이진&lt;/em&gt; 파일에 저장된 배열에 메모리 맵을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8a87bd8b7d3a950e18b45a000e101dc7d4817b57" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a binary file on disk.</source>
          <target state="translated">디스크의 이진 파일에 저장된 배열에 메모리 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="177322a71483684c72dfc2b3215cca2baa8b7843" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a file on disk.</source>
          <target state="translated">디스크의 파일에 저장된 어레이에 메모리 맵을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="dd122b2ab92f93dade4d0598cccec22c13f3cc51" translate="yes" xml:space="preserve">
          <source>Create a new 1-dimensional array from an iterable object.</source>
          <target state="translated">반복 가능한 객체에서 새로운 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="da0150ead372af08b1b57e37f89fc0a11de82d56" translate="yes" xml:space="preserve">
          <source>Create a new array with the provided data-type descriptor, &lt;em&gt;descr&lt;/em&gt;, of the shape determined by &lt;em&gt;nd&lt;/em&gt; and &lt;em&gt;dims&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;nd&lt;/em&gt; 및 &lt;em&gt;dims에&lt;/em&gt; 의해 결정된 형태 의 제공된 데이터 유형 설명자 &lt;em&gt;descr을&lt;/em&gt; 사용하여 새 배열을 작성하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66aa9bc65510d6c47313fc8c574666e0fb6ecdf0" translate="yes" xml:space="preserve">
          <source>Create a new broadcasting universal function from required variables. Each ufunc builds around the notion of an element-by-element operation. Each ufunc object contains pointers to 1-d loops implementing the basic functionality for each supported type.</source>
          <target state="translated">필요한 변수에서 새로운 방송 범용 기능을 만듭니다. 각 ufunc는 요소 별 연산 개념을 기반으로합니다. 각 ufunc 객체에는 지원되는 각 유형의 기본 기능을 구현하는 1-d 루프에 대한 포인터가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a2f526f17ce7c95e1ecc2546f61cdc127fd9387" translate="yes" xml:space="preserve">
          <source>Create a new data-type object from the built-in (or user-registered) data-type indicated by &lt;em&gt;typenum&lt;/em&gt;. All builtin types should not have any of their fields changed. This creates a new copy of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure so that you can fill it in as appropriate. This function is especially needed for flexible data-types which need to have a new elsize member in order to be meaningful in array construction.</source>
          <target state="translated">&lt;em&gt;typenum으로&lt;/em&gt; 표시되는 내장 (또는 사용자 등록) 데이터 유형에서 새 데이터 유형 오브젝트를 작성하십시오 . 모든 내장 유형은 필드를 변경하지 않아야합니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 의 새 사본을 작성하여 적절하게 채울 수 있습니다. 이 기능은 특히 배열 구성에서 의미를 갖기 위해 새로운 크기의 멤버를 가져야하는 유연한 데이터 유형에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2566b193178a539463843e8aa80394649f42e4a2" translate="yes" xml:space="preserve">
          <source>Create a new data-type object with the byteorder set according to &lt;em&gt;newendian&lt;/em&gt;. All referenced data-type objects (in subdescr and fields members of the data-type object) are also changed (recursively). If a byteorder of &lt;code&gt;NPY_IGNORE&lt;/code&gt; is encountered it is left alone. If newendian is &lt;code&gt;NPY_SWAP&lt;/code&gt;, then all byte-orders are swapped. Other valid newendian values are &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_LITTLE&lt;/code&gt;, and &lt;code&gt;NPY_BIG&lt;/code&gt; which all cause the returned data-typed descriptor (and all it&amp;rsquo;s referenced data-type descriptors) to have the corresponding byte- order.</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt; 에 따라 바이트 순서가 설정된 새 데이터 유형 객체를 &lt;em&gt;만듭니다&lt;/em&gt; . 참조 된 모든 데이터 유형 개체 (데이터 유형 개체의 하위 설명 및 필드 멤버)도 (재귀 적으로) 변경됩니다. &lt;code&gt;NPY_IGNORE&lt;/code&gt; 의 바이트 순서 가 발생하면 홀로 남습니다. newendian이 &lt;code&gt;NPY_SWAP&lt;/code&gt; 이면 모든 바이트 순서가 바뀝니다. 다른 유효한 뉴 엔디안 값은 &lt;code&gt;NPY_NATIVE&lt;/code&gt; , &lt;code&gt;NPY_LITTLE&lt;/code&gt; 및 &lt;code&gt;NPY_BIG&lt;/code&gt; 이며 , 이로 인해 반환 된 데이터 유형 설명자 (및 모든 참조 데이터 유형 설명자)가 해당 바이트 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f6986303dc6f9f6f31cfc3c9b4f4566a4e6fb42d" translate="yes" xml:space="preserve">
          <source>Create a new masked array from scratch.</source>
          <target state="translated">마스크 된 새 배열을 처음부터 만듭니다.</target>
        </trans-unit>
        <trans-unit id="db4af2ef3a8605462d0c80d1288e39839d7838af" translate="yes" xml:space="preserve">
          <source>Create a new uninitialized array of type, &lt;em&gt;typenum&lt;/em&gt;, whose size in each of &lt;em&gt;nd&lt;/em&gt; dimensions is given by the integer array, &lt;em&gt;dims&lt;/em&gt;.The memory for the array is uninitialized (unless typenum is &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case each element in the array is set to NULL). The &lt;em&gt;typenum&lt;/em&gt; argument allows specification of any of the builtin data-types such as &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt;. The memory for the array can be set to zero if desired using &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; (return_object, 0).This function cannot be used to create a flexible-type array (no itemsize given).</source>
          <target state="translated">유형의 새로운 초기화 배열 생성 &lt;em&gt;typenum&lt;/em&gt; 사이즈의 각각에, &lt;em&gt;ND&lt;/em&gt; 차원 정수 어레이에 의해 주어진다을 &lt;em&gt;흐리게&lt;/em&gt; typenum가 아닌 어레이에 대한 국지적 인 메모리 (초기화되지된다 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 어레이의 각 요소는 NULL로 설정된 경우 ). &lt;em&gt;typenum의&lt;/em&gt; 인수 등의 내장 된 데이터 유형의 사양 허용 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; 를&lt;/a&gt; . &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; (return_object, 0)를 사용하여 원하는 경우 배열의 메모리를 0으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c0c8b6de66490941ae490fc29850f004942457f" translate="yes" xml:space="preserve">
          <source>Create a new, empty record array:</source>
          <target state="translated">비어있는 새 레코드 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="12be6a102aebbe485e0f4ef96e897bf893ee3bfe" translate="yes" xml:space="preserve">
          <source>Create a numpy array from a ctypes array or POINTER.</source>
          <target state="translated">ctypes 배열 또는 POINTER에서 numpy 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="00bebe7beba9d200b07101646c92c66e5cd00025" translate="yes" xml:space="preserve">
          <source>Create a set of indices to access the diagonal of a (4, 4) array:</source>
          <target state="translated">(4, 4) 배열의 대각선에 액세스 할 인덱스 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="108a4b49ad391d95a892bf9a02c53f664759b30e" translate="yes" xml:space="preserve">
          <source>Create a standard ndarray and convert it to a record array, using &lt;code&gt;arr.view(np.recarray)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arr.view(np.recarray)&lt;/code&gt; 사용하여 표준 ndarray를 작성하고 레코드 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="c5cd4653ebf1e7a39dd1a7fde57d136d86e370ff" translate="yes" xml:space="preserve">
          <source>Create a tuple of &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; objects which iterate in nested loops over different axes of the op argument. The first iterator is used in the outermost loop, the last in the innermost loop. Advancing one will change the subsequent iterators to point at its new element.</source>
          <target state="translated">op 인수의 다른 축에 대해 중첩 루프에서 반복되는 &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 객체 의 튜플을 만듭니다 . 첫 번째 반복자는 가장 바깥 쪽 루프에서 사용되고 마지막 반복자는 가장 안쪽 루프에서 사용됩니다. 하나를 진행 시키면 다음 반복자가 새로운 요소를 가리 키도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0fc61fbee0ed5e8baf16ecef1179e57ba0313e61" translate="yes" xml:space="preserve">
          <source>Create a two-dimensional array with the flattened input as a diagonal.</source>
          <target state="translated">평평한 입력을 대각선으로 사용하여 2 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="137fea567dac73b2d57dd9dfb89ded4439c13d56" translate="yes" xml:space="preserve">
          <source>Create a view into the array with the given shape and strides.</source>
          <target state="translated">주어진 모양과 보폭으로 배열에 뷰를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="81d0dc00ee9f15e21759f9f0bec711bb9bd505df" translate="yes" xml:space="preserve">
          <source>Create an array from an iterator.</source>
          <target state="translated">반복자에서 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="925f773d387b010ea0e8a6321db588428ffb283e" translate="yes" xml:space="preserve">
          <source>Create an array from binary file data</source>
          <target state="translated">이진 파일 데이터에서 배열 만들기</target>
        </trans-unit>
        <trans-unit id="d2e4e179d70e58136861749bef7d847f8a1e83ea" translate="yes" xml:space="preserve">
          <source>Create an array of the given shape and populate it with random samples from a uniform distribution over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">주어진 모양의 배열을 만들고 &lt;code&gt;[0, 1)&lt;/code&gt; 대한 균일 분포의 무작위 표본으로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="8ef83bcd085ae088871cf8b9cc78b6a1d61e3207" translate="yes" xml:space="preserve">
          <source>Create an array with two fields, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 라는 두 개의 필드로 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a31fd94f016f355d7832212f15cccc2bc9c1da3" translate="yes" xml:space="preserve">
          <source>Create an array wrapper around &lt;em&gt;data&lt;/em&gt; pointed to by the given pointer. The array flags will have a default that the data area is well-behaved and C-style contiguous. The shape of the array is given by the &lt;em&gt;dims&lt;/em&gt; c-array of length &lt;em&gt;nd&lt;/em&gt;. The data-type of the array is indicated by &lt;em&gt;typenum&lt;/em&gt;. If data comes from another reference-counted Python object, the reference count on this object should be increased after the pointer is passed in, and the base member of the returned ndarray should point to the Python object that owns the data. This will ensure that the provided memory is not freed while the returned array is in existence. To free memory as soon as the ndarray is deallocated, set the OWNDATA flag on the returned ndarray.</source>
          <target state="translated">주어진 포인터가 가리키는 &lt;em&gt;데이터&lt;/em&gt; 주위에 배열 래퍼를 만듭니다 . 배열 플래그는 기본적으로 데이터 영역이 올바르게 작동하고 C 스타일로 연속적입니다. 어레이의 형상은 길이 &lt;em&gt;nd&lt;/em&gt; 의 &lt;em&gt;딤&lt;/em&gt; c- 배열에 의해 주어진다 . 배열의 데이터 유형은 &lt;em&gt;typenum&lt;/em&gt; 으로 표시됩니다 . 데이터가 참조 횟수가 지정된 다른 Python 객체에서 가져온 경우 포인터가 전달 된 후이 객체의 참조 횟수를 늘려야하며 반환 된 ndarray의 기본 멤버는 데이터를 소유 한 Python 객체를 가리켜 야합니다. 이렇게하면 반환 된 배열이 존재하는 동안 제공된 메모리가 해제되지 않습니다. ndarray가 할당 해제 되 자마자 메모리를 해제하려면 반환 된 ndarray에서 OWNDATA 플래그를 설정하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="47d4d6e775fe88f4b80d5ea4c370f0f98678742c" translate="yes" xml:space="preserve">
          <source>Create an array x, with a reference y and a copy z:</source>
          <target state="translated">참조 y와 사본 z를 사용하여 배열 x를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="edf37af870193c853e5704f79fa46afda7f8ab49" translate="yes" xml:space="preserve">
          <source>Create an array, but leave its allocated memory unchanged (i.e., it contains &amp;ldquo;garbage&amp;rdquo;).</source>
          <target state="translated">배열을 만들되 할당 된 메모리를 변경하지 않은 채로 두십시오 (즉, &quot;쓰레기&quot;가 포함됨).</target>
        </trans-unit>
        <trans-unit id="f8c0528bb084a014ea88bd25616f60c460edbaf2" translate="yes" xml:space="preserve">
          <source>Create an array, each element of which is zero.</source>
          <target state="translated">각 요소가 0 인 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="415b3ad3f5d5fec6811715fcb43c61600d019de3" translate="yes" xml:space="preserve">
          <source>Create an array.</source>
          <target state="translated">배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="efc38388dbd54fefe6577db0dc2a6d52f3139f02" translate="yes" xml:space="preserve">
          <source>Create and add an Extension instance to the ext_modules list. This method also takes the following optional keyword arguments that are passed on to the Extension constructor.</source>
          <target state="translated">확장 인스턴스를 작성하여 ext_modules 목록에 추가하십시오. 이 메소드는 또한 확장 생성자에 전달되는 다음 선택적 키워드 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2ce4b69bed16e520597783987ce2ba31407bbf8f" translate="yes" xml:space="preserve">
          <source>Create and array.</source>
          <target state="translated">작성하고 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="47f0f6dfd19f6638cbffe16ed61164856442a40f" translate="yes" xml:space="preserve">
          <source>Create and plot a band-limited signal with random phases:</source>
          <target state="translated">랜덤 위상으로 대역 제한 신호를 생성하고 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="655209fbd053b66333cb2ad561c140174943d616" translate="yes" xml:space="preserve">
          <source>Create and plot an image with band-limited frequency content:</source>
          <target state="translated">주파수 대역이 제한된 이미지를 생성하고 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="383101a807508f28ca3ca4eeb51cf4c39ba642f6" translate="yes" xml:space="preserve">
          <source>Create and return a ctypes object from a numpy array. Actually anything that exposes the __array_interface__ is accepted.</source>
          <target state="translated">numpy 배열에서 ctypes 객체를 만들고 반환합니다. 실제로 __array_interface__를 노출시키는 모든 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a48e85aeb37d4861d852029c32e85348705a141a" translate="yes" xml:space="preserve">
          <source>Create and return a new object.</source>
          <target state="translated">새 객체를 만들어 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4624b630f46c030fc80adec33ba7cfd098ce660b" translate="yes" xml:space="preserve">
          <source>Create and return a new object. See help(type) for accurate signature.</source>
          <target state="translated">새 객체를 만들어 반환합니다. 정확한 서명은 help (type)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f91b98f5452e2c2460f51aa523deeb885a2d07f" translate="yes" xml:space="preserve">
          <source>Create diagonal arrays.</source>
          <target state="translated">대각선 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="391f555392e014f93bf9364fc1af0a11257ae60d" translate="yes" xml:space="preserve">
          <source>Create nditers for use in nested loops</source>
          <target state="translated">중첩 루프에 사용할 nditer 생성</target>
        </trans-unit>
        <trans-unit id="cae0d44191595c4c5d6b5d99613364849c4f295d" translate="yes" xml:space="preserve">
          <source>Create or load a memory-mapped &lt;code&gt;.npy&lt;/code&gt; file.</source>
          <target state="translated">메모리 매핑 된 &lt;code&gt;.npy&lt;/code&gt; 파일을 만들거나로드 하십시오.</target>
        </trans-unit>
        <trans-unit id="9040f175bb70c201bfb2817bf6bea6562fe6e4f5" translate="yes" xml:space="preserve">
          <source>Create or overwrite existing file for reading and writing.</source>
          <target state="translated">읽고 쓸 기존 파일을 작성하거나 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="58d0f155eb04fd57d6905d8542d41ea23a2730f2" translate="yes" xml:space="preserve">
          <source>Creates a copy of the array with its elements rearranged in such a way that the value of the element in k-th position is in the position it would be in a sorted array. All elements smaller than the k-th element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined.</source>
          <target state="translated">k 번째 위치에있는 요소의 값이 정렬 된 배열에있는 위치에있는 방식으로 요소가 재 배열 된 배열의 복사본을 만듭니다. k 번째 요소보다 작은 모든 요소는이 요소보다 먼저 이동하고 같거나 큰 요소는 그 뒤로 이동합니다. 두 파티션의 요소 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7413e806f1e7017ca021144131a6ec01d636c42" translate="yes" xml:space="preserve">
          <source>Creates an iterator for broadcasting the &lt;code&gt;nop&lt;/code&gt; array objects provided in &lt;code&gt;op&lt;/code&gt;, using regular NumPy broadcasting rules.</source>
          <target state="translated">일반 NumPy 브로드 캐스트 규칙을 사용하여 &lt;code&gt;op&lt;/code&gt; 에 제공된 &lt;code&gt;nop&lt;/code&gt; 배열 객체 를 브로드 캐스팅하기위한 반복자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a06033694dc7625f6a25df5e7e99097ece139dbb" translate="yes" xml:space="preserve">
          <source>Creates an iterator for the given numpy array object &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">지정된 numpy 배열 객체 &lt;code&gt;op&lt;/code&gt; 의 반복자를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="820c06a933939c73d0a9ac20d7eebafd53283b18" translate="yes" xml:space="preserve">
          <source>Creating a mask</source>
          <target state="translated">마스크 만들기</target>
        </trans-unit>
        <trans-unit id="021b57ac73287317d5590d713033a11127224262" translate="yes" xml:space="preserve">
          <source>Creating a view on a structured array so it can be used in calculations</source>
          <target state="translated">계산에 사용할 수 있도록 구조화 된 배열에서보기 만들기</target>
        </trans-unit>
        <trans-unit id="98d1b3c0571161e2acd40362a47356cdc1716fa1" translate="yes" xml:space="preserve">
          <source>Creating aligned structs: In order to know how to offset a field when &lt;code&gt;align=True&lt;/code&gt;, numpy looks up &lt;code&gt;field.dtype.alignment&lt;/code&gt;. This includes fields which are nested structured arrays.</source>
          <target state="translated">정렬 된 구조체 만들기 : &lt;code&gt;align=True&lt;/code&gt; 일 때 필드를 오프셋하는 방법을 알기 위해 numpy는 &lt;code&gt;field.dtype.alignment&lt;/code&gt; 를 찾습니다 . 여기에는 중첩 구조화 된 배열 인 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d41cf53fbab96d2f7a854a59cb350d9b2f249330" translate="yes" xml:space="preserve">
          <source>Creating an array from sub-classes:</source>
          <target state="translated">서브 클래스에서 배열 만들기 :</target>
        </trans-unit>
        <trans-unit id="8c75c1be94407cd0140876081367297865708e3a" translate="yes" xml:space="preserve">
          <source>Creating arrays</source>
          <target state="translated">배열 만들기</target>
        </trans-unit>
        <trans-unit id="b0ac33e8f2407adfe99099892032a5786f48a98d" translate="yes" xml:space="preserve">
          <source>Creating character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">문자형 배열 만들기 ( &lt;code&gt;numpy.char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="46432ea81a249419eb894b0e722ae04982146aa4" translate="yes" xml:space="preserve">
          <source>Creating character arrays (numpy.char)</source>
          <target state="translated">문자형 배열 만들기 (numpy.char)</target>
        </trans-unit>
        <trans-unit id="a79124329baf0d3880f6e8bd974face711ed90d3" translate="yes" xml:space="preserve">
          <source>Creating data types</source>
          <target state="translated">데이터 타입 생성</target>
        </trans-unit>
        <trans-unit id="3623ceac932f771e89eb47270eaee4ca0c39adaa" translate="yes" xml:space="preserve">
          <source>Creating iterators for nested iteration requires some care. All the iterator operands must match exactly, or the calls to &lt;a href=&quot;#c.NpyIter_ResetBasePointers&quot;&gt;&lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;&lt;/a&gt; will be invalid. This means that automatic copies and output allocation should not be used haphazardly. It is possible to still use the automatic data conversion and casting features of the iterator by creating one of the iterators with all the conversion parameters enabled, then grabbing the allocated operands with the &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; function and passing them into the constructors for the rest of the iterators.</source>
          <target state="translated">중첩 된 반복을위한 반복자를 작성하려면 약간의주의가 필요합니다. 모든 반복자 피연산자가 정확히 일치해야합니다 . &lt;a href=&quot;#c.NpyIter_ResetBasePointers&quot;&gt; &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; &lt;/a&gt; 대한 호출 이 유효하지 않습니다. 즉, 자동 사본 및 출력 할당을 우연히 사용해서는 안됩니다. 모든 변환 매개 변수가 활성화 된 반복자 중 하나를 만든 다음 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 할당 된 피연산자를 잡고 나머지 반복기의 생성자에 전달함으로써 반복자의 자동 데이터 변환 및 캐스트 기능을 계속 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="c5120a7c7085b0117ed81c3444ff1fdacef6c111" translate="yes" xml:space="preserve">
          <source>Creating many similar tests</source>
          <target state="translated">많은 유사한 테스트 만들기</target>
        </trans-unit>
        <trans-unit id="1dcddc1ce5a75de776531479edb4473eaa2354c5" translate="yes" xml:space="preserve">
          <source>Creating record arrays (&lt;code&gt;numpy.rec&lt;/code&gt;)</source>
          <target state="translated">레코드 배열 만들기 ( &lt;code&gt;numpy.rec&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="63696d372e0aaf637bc994c371bc42b8f6e4087e" translate="yes" xml:space="preserve">
          <source>Creating structured datatypes with fields aligned like in a C-struct.</source>
          <target state="translated">C-struct에서와 같이 필드가 정렬 된 구조화 된 데이터 유형 작성</target>
        </trans-unit>
        <trans-unit id="e13e0554f557ba882751e261b5a60777b337bea6" translate="yes" xml:space="preserve">
          <source>Creation</source>
          <target state="translated">Creation</target>
        </trans-unit>
        <trans-unit id="5f939e5434d3a238da77ef47c3189ac69e40c937" translate="yes" xml:space="preserve">
          <source>Cross-correlation of two 1-dimensional sequences.</source>
          <target state="translated">두 개의 1 차원 시퀀스의 상호 상관.</target>
        </trans-unit>
        <trans-unit id="ce4fe4b7616cb7e3999589959d2a7bacb5e2b9bf" translate="yes" xml:space="preserve">
          <source>Cube each element in a list.</source>
          <target state="translated">목록에서 각 요소를 큐브로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cef7283ebb85e8146a8a72c4b6a145c8d059da03" translate="yes" xml:space="preserve">
          <source>Cumulative product across array propagating NaNs.</source>
          <target state="translated">어레이 전파 NaN에 걸친 누적 생성물.</target>
        </trans-unit>
        <trans-unit id="5e3b67811bb5290b6df8dbec735818173117ec67" translate="yes" xml:space="preserve">
          <source>Cumulative sum across array propagating NaNs.</source>
          <target state="translated">어레이 전파 NaN에 대한 누적 합계.</target>
        </trans-unit>
        <trans-unit id="7f04d49b0ca659708fb8cdf77308d17fd7ecaa88" translate="yes" xml:space="preserve">
          <source>Cumulative sum of array elements.</source>
          <target state="translated">배열 요소의 누적 합.</target>
        </trans-unit>
        <trans-unit id="140e87163ac45492f58df33d7f85da346c418f4c" translate="yes" xml:space="preserve">
          <source>Current flat index into the array.</source>
          <target state="translated">배열에 대한 현재 플랫 인덱스.</target>
        </trans-unit>
        <trans-unit id="ac8d8307cb5f245348dc52bf7e74dacfa1f5d300" translate="yes" xml:space="preserve">
          <source>Current mask.</source>
          <target state="translated">현재 마스크.</target>
        </trans-unit>
        <trans-unit id="df3e2af3c9d9f82f00a46adce3db218a6d9d7bd8" translate="yes" xml:space="preserve">
          <source>Currently SciPy project consists of two packages:</source>
          <target state="translated">현재 SciPy 프로젝트는 두 가지 패키지로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8eba10595ddae0a34a9053064e392f6c153817" translate="yes" xml:space="preserve">
          <source>Currently unused. Reserved for future use in caching hash values.</source>
          <target state="translated">현재 미사용. 나중에 해시 값을 캐싱하는 데 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="06783a663f807b884b2eb6d800592782869e00d8" translate="yes" xml:space="preserve">
          <source>Custom Weekmasks</source>
          <target state="translated">커스텀 위크 마스크</target>
        </trans-unit>
        <trans-unit id="5794c902f31f869d8d4450d4791299177dd6f5bf" translate="yes" xml:space="preserve">
          <source>Cut-off ratio for small singular values of &lt;code&gt;a&lt;/code&gt;. For the purposes of rank determination, singular values are treated as zero if they are smaller than &lt;code&gt;rcond&lt;/code&gt; times the largest singular value of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">작은 특이 값에 대한 차단 비율 . 순위 결정을 위해 특이 값은 &lt;code&gt;rcond&lt;/code&gt; 의 최대 특이 값 &lt;code&gt;a&lt;/code&gt; 의rcond 보다 작 으면 0으로 처리됩니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="963e5a96bd3d87f0909e596539f6dfa7d84581ea" translate="yes" xml:space="preserve">
          <source>Cutoff for small singular values. Singular values less than or equal to &lt;code&gt;rcond * largest_singular_value&lt;/code&gt; are set to zero. Broadcasts against the stack of matrices.</source>
          <target state="translated">작은 특이 값에 대한 컷오프. &lt;code&gt;rcond * largest_singular_value&lt;/code&gt; 보다 작거나 같은 특이 값 은 0으로 설정됩니다. 행렬 스택에 대해 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="55b3718b804d3ea7ee851e585782dfffc4ddaa91" translate="yes" xml:space="preserve">
          <source>Cygwin 98-4.10, Python 2.1.1(MSC) - echo tests fail i.e. redefining environment variables may not work. FIXED: don&amp;rsquo;t use cygwin echo! Comment: also &lt;code&gt;cmd /c echo&lt;/code&gt; will not work but redefining environment variables do work.</source>
          <target state="translated">Cygwin 98-4.10, Python 2.1.1 (MSC)-에코 테스트가 실패합니다. 다시 정의하면 환경 변수가 재정의되지 않을 수 있습니다. 수정 : cygwin echo를 사용하지 마십시오! 주석 : 또한 &lt;code&gt;cmd /c echo&lt;/code&gt; 는 작동하지 않지만 재정의 환경 변수는 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a512b3fa69c6f1d48fcf3a95fedda64e98719115" translate="yes" xml:space="preserve">
          <source>Cygwin 98-4.10, Python 2.3.3(cygming special)</source>
          <target state="translated">Cygwin 98-4.10, Python 2.3.3 (사이클링 스페셜)</target>
        </trans-unit>
        <trans-unit id="39b8f070b55c1bb2bcdf01997cdd384c00db9971" translate="yes" xml:space="preserve">
          <source>Cython</source>
          <target state="translated">Cython</target>
        </trans-unit>
        <trans-unit id="3b507900d710138d9fc14b9bf7ca033f1876815b" translate="yes" xml:space="preserve">
          <source>Cython can be used to unpack the &lt;code&gt;PyCapsule&lt;/code&gt; provided by a BitGenerator. This example uses &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;random_gauss_zig&lt;/code&gt;, the Ziggurat-based generator for normals, to fill an array. The usual caveats for writing high-performance code using Cython &amp;ndash; removing bounds checks and wrap around, providing array alignment information &amp;ndash; still apply.</source>
          <target state="translated">Cython을 사용하여 &lt;code&gt;PyCapsule&lt;/code&gt; 제공 하는 PyCapsule의 압축을 풀 수 있습니다 . 이 예제는 배열을 채우기 위해 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;random_gauss_zig&lt;/code&gt; 에 대한 Ziggurat 기반 생성기 random_gauss_zig 를 사용합니다. Cython을 사용하여 고성능 코드를 작성하는 일반적인주의 사항 &amp;ndash; 경계 검사 및 줄 바꿈 제거, 배열 정렬 정보 제공 &amp;ndash; 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="9c77f3b5da6a716c0c8711c7937fc207582f88d6" translate="yes" xml:space="preserve">
          <source>D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small Data Sets, CRC Press, 1994.</source>
          <target state="translated">DJ Hand, F. Daly, D. Lunn, E. Ostrowski, 소규모 데이터 세트 핸드북, CRC Press, 1994.</target>
        </trans-unit>
        <trans-unit id="9e1a42a64a9db004ac248d750b3e5535fe6705bf" translate="yes" xml:space="preserve">
          <source>DECREF&amp;rsquo;s an array object which may have the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set without causing the contents to be copied back into the original array. Resets the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag on the base object. This is useful for recovering from an error condition when writeback semantics are used, but will lead to wrong results.</source>
          <target state="translated">DECREF는 (더 이상 사용되지 않는) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그를 설정하여 내용이 원래 배열로 다시 복사 되지 않도록하는 배열 객체입니다 . 기본 개체 에서 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그를 재설정 합니다. 이것은 후기 입 시맨틱이 사용될 때 오류 조건에서 복구하는 데 유용하지만 잘못된 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="62c4f5e8f3e17d3ec22760be4806239a479b50bf" translate="yes" xml:space="preserve">
          <source>Dalgaard, Peter, &amp;ldquo;Introductory Statistics With R&amp;rdquo;, Springer, 2002.</source>
          <target state="translated">Dalgaard, Peter, &quot;R의 입문 통계&quot;, Springer, 2002.</target>
        </trans-unit>
        <trans-unit id="5101f6a6ee46d3f6405ba78646fba174a0c2beec" translate="yes" xml:space="preserve">
          <source>Dalgaard, Peter, &amp;ldquo;Introductory Statistics with R&amp;rdquo;, Springer-Verlag, 2002.</source>
          <target state="translated">Dalgaard, Peter, &quot;R에 대한 기초 통계&quot;, Springer-Verlag, 2002.</target>
        </trans-unit>
        <trans-unit id="4553061944cf001ceb7836359a71ad75f6dced22" translate="yes" xml:space="preserve">
          <source>Daniel Lemire., &amp;ldquo;Fast Random Integer Generation in an Interval&amp;rdquo;, ACM Transactions on Modeling and Computer Simulation 29 (1), 2019, &lt;a href=&quot;http://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt;.</source>
          <target state="translated">Daniel Lemire.,&amp;ldquo;간격의 빠른 임의 정수 생성&amp;rdquo;, ACM 모델링 및 컴퓨터 시뮬레이션에 관한 29, 2019, &lt;a href=&quot;http://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4caaaf9cb8047a53fc77dfac273916c0e02f27d3" translate="yes" xml:space="preserve">
          <source>Darwin 7.2.0, Python 2.3</source>
          <target state="translated">다윈 7.2.0, 파이썬 2.3</target>
        </trans-unit>
        <trans-unit id="5022178af7e5aff72e419a94ea0af31d5816c478" translate="yes" xml:space="preserve">
          <source>Data Type API</source>
          <target state="translated">데이터 타입 API</target>
        </trans-unit>
        <trans-unit id="d173cb51d3ffa8369ddc5c7d9051236f920814da" translate="yes" xml:space="preserve">
          <source>Data access</source>
          <target state="translated">데이터 접근</target>
        </trans-unit>
        <trans-unit id="a459c7310b8e7648c0f1c03ad2fe7505060e920c" translate="yes" xml:space="preserve">
          <source>Data attribute containing the identity element for the ufunc, if it has one. If it does not, the attribute value is None.</source>
          <target state="translated">ufunc의 식별 요소 (있는 경우)를 포함하는 데이터 속성입니다. 그렇지 않은 경우 속성 값은 None입니다.</target>
        </trans-unit>
        <trans-unit id="e78e721c9c235ccee8159d0be9160af82084ef4c" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc takes, including optional ones.</source>
          <target state="translated">선택적 인수를 포함하여 ufunc가 인수의 수를 포함하는 데이터 속성입니다.</target>
        </trans-unit>
        <trans-unit id="03fe7a08b0b586a0b8eaaf0cdad9fc9b9cc9f6e6" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc treats as input.</source>
          <target state="translated">ufunc가 입력으로 취급하는 인수 수를 포함하는 데이터 속성.</target>
        </trans-unit>
        <trans-unit id="adfa3ffdeaf44e2dd6067b0132906bd6eef47e97" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc treats as output.</source>
          <target state="translated">ufunc가 출력으로 취급하는 인수 수를 포함하는 데이터 속성.</target>
        </trans-unit>
        <trans-unit id="692287ce05c432ce06118a7f5a56e29867abb305" translate="yes" xml:space="preserve">
          <source>Data attribute listing the data-type &amp;ldquo;Domain-Range&amp;rdquo; groupings the ufunc can deliver. The data-types are given using the character codes.</source>
          <target state="translated">ufunc가 제공 할 수있는 데이터 유형 &quot;도메인 범위&quot;그룹을 나열하는 데이터 속성입니다. 데이터 유형은 문자 코드를 사용하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c0385a2191da01cdd85357b1f30dbba96a61452a" translate="yes" xml:space="preserve">
          <source>Data in new &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; is in the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt; (C) order, unless otherwise specified, but, for example, &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;basic array slicing&lt;/a&gt; often produces &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;views&lt;/a&gt; in a different scheme.</source>
          <target state="translated">달리 지정하지 않는 한 새 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 데이터 는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;행 메이저&lt;/a&gt; (C) 순서로되어 있지만, 예를 들어 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;기본 배열 슬라이싱은&lt;/a&gt; 종종 다른 방식으로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;뷰&lt;/a&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d84a810e9789b8179eb08002b6e519db8fa8ce7" translate="yes" xml:space="preserve">
          <source>Data is always written in &amp;lsquo;C&amp;rsquo; order, independent of the order of &lt;code&gt;a&lt;/code&gt;. The data produced by this method can be recovered using the function fromfile().</source>
          <target state="translated">데이터는 항상 순서의 독립, 'C'순서로 작성 . 이 메소드로 생성 된 데이터는 fromfile () 함수를 사용하여 복구 할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e53167df8cb2fa7234110a0a44d40ca2cbd6313" translate="yes" xml:space="preserve">
          <source>Data items are converted to the nearest compatible Python type. Masked values are converted to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is None, the corresponding entries in the output list will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">데이터 항목은 가장 가까운 호환 가능한 Python 유형으로 변환됩니다. 마스크 된 값은 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 . 경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 포함되지 않은 경우, 출력에서의 대응하는 엔트리가 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ac7e83183cb23b5999f887680eaa647e636fdc" translate="yes" xml:space="preserve">
          <source>Data read from the text file.</source>
          <target state="translated">텍스트 파일에서 읽은 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ab4616f27eff8ec482bc1f61a6613379d5019665" translate="yes" xml:space="preserve">
          <source>Data read from the text file. If &lt;code&gt;usemask&lt;/code&gt; is True, this is a masked array.</source>
          <target state="translated">텍스트 파일에서 읽은 데이터 경우 &lt;code&gt;usemask&lt;/code&gt; 은 True입니다,이 마스크 배열입니다.</target>
        </trans-unit>
        <trans-unit id="dadd6ac5ba02e2f7843ee180c516331cbdcd6a9f" translate="yes" xml:space="preserve">
          <source>Data sources</source>
          <target state="translated">데이터 소스</target>
        </trans-unit>
        <trans-unit id="c3c77ecb1755c1a69e821e1aaac71fd5ec5e7ec0" translate="yes" xml:space="preserve">
          <source>Data stored in the file. For &lt;code&gt;.npz&lt;/code&gt; files, the returned instance of NpzFile class must be closed to avoid leaking file descriptors.</source>
          <target state="translated">파일에 저장된 데이터. 들어 &lt;code&gt;.npz&lt;/code&gt; 파일, NpzFile 클래스의 반환 된 인스턴스는 파일 기술자 누수 방지하기 위해 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="b9d279299816a7c139a097762a532d3c7e26f292" translate="yes" xml:space="preserve">
          <source>Data to be averaged. Masked entries are not taken into account in the computation.</source>
          <target state="translated">평균화 할 데이터입니다. 마스킹 된 항목은 계산에서 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03c72d9dcd23e4e11ad5552205bb89141629001" translate="yes" xml:space="preserve">
          <source>Data to be saved to a text file.</source>
          <target state="translated">텍스트 파일로 저장 될 데이터.</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ebf87ff7259b3fa1470e7263b48576e422cbfd" translate="yes" xml:space="preserve">
          <source>Data type code.</source>
          <target state="translated">데이터 타입 코드.</target>
        </trans-unit>
        <trans-unit id="5c6b1bdaee5cd22bebfa68fe22da8ae17ee32ebc" translate="yes" xml:space="preserve">
          <source>Data type containing field &lt;code&gt;col1&lt;/code&gt; (10-character string at byte position 0), &lt;code&gt;col2&lt;/code&gt; (32-bit float at byte position 10), and &lt;code&gt;col3&lt;/code&gt; (integers at byte position 14):</source>
          <target state="translated">&lt;code&gt;col1&lt;/code&gt; 필드 (바이트 위치 0의 10 자 문자열), &lt;code&gt;col2&lt;/code&gt; (바이트 위치 10의 32 비트 부동 소수점) 및 &lt;code&gt;col3&lt;/code&gt; (바이트 위치 14의 정수 )을 포함하는 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="5323524ee17f1362827313c3d97940b4505408ab" translate="yes" xml:space="preserve">
          <source>Data type information</source>
          <target state="translated">데이터 타입 정보</target>
        </trans-unit>
        <trans-unit id="7f7a69abb16912ba94ab887a9c10ebbd9bc5371f" translate="yes" xml:space="preserve">
          <source>Data type objects</source>
          <target state="translated">데이터 타입 객체</target>
        </trans-unit>
        <trans-unit id="b653b6102e06af89505274160891e8ac6c604d2a" translate="yes" xml:space="preserve">
          <source>Data type objects (&lt;code&gt;dtype&lt;/code&gt;)</source>
          <target state="translated">데이터 유형 객체 ( &lt;code&gt;dtype&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ac3315e5339816f58a1895e052b1e8c043da3b3c" translate="yes" xml:space="preserve">
          <source>Data type objects (dtype)</source>
          <target state="translated">데이터 타입 객체 (dtype)</target>
        </trans-unit>
        <trans-unit id="6823842611ba946501e490386387306a34e9ab02" translate="yes" xml:space="preserve">
          <source>Data type of the output.</source>
          <target state="translated">출력의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="eae3a99bdeb47b16f78d7fea21224392e5ca6e46" translate="yes" xml:space="preserve">
          <source>Data type of the output. If &lt;code&gt;dtype&lt;/code&gt; is None, the type of the data argument (&lt;code&gt;data.dtype&lt;/code&gt;) is used. If &lt;code&gt;dtype&lt;/code&gt; is not None and different from &lt;code&gt;data.dtype&lt;/code&gt;, a copy is performed.</source>
          <target state="translated">출력의 데이터 유형 경우 &lt;code&gt;dtype&lt;/code&gt; 아무도없는 데이터 인자 (유형 &lt;code&gt;data.dtype&lt;/code&gt; 는 ) 사용된다. 경우 &lt;code&gt;dtype&lt;/code&gt; 에서 없음 다른되지 않습니다 &lt;code&gt;data.dtype&lt;/code&gt; , 사본이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9a65ce3721c38edabce27611aa8f46d66f3904ff" translate="yes" xml:space="preserve">
          <source>Data type of the result.</source>
          <target state="translated">결과의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="4ed14787943fa351395f0ee27e0b0514b81bf28b" translate="yes" xml:space="preserve">
          <source>Data type of the resulting array. If None, the dtypes will be determined by the contents of each column, individually.</source>
          <target state="translated">결과 배열의 데이터 유형입니다. 없음 인 경우 dtypes는 각 열의 내용에 따라 개별적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="339d59d85f01f8cdcf6fd821645f37195e30ec02" translate="yes" xml:space="preserve">
          <source>Data type of the returned array. For binary files, it is used to determine the size and byte-order of the items in the file.</source>
          <target state="translated">반환 된 배열의 데이터 형식입니다. 이진 파일의 경우 파일에있는 항목의 크기와 바이트 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f9f4851300f70d5dc3cf562fa3240960b4dbf05" translate="yes" xml:space="preserve">
          <source>Data type of the returned array. The default is float.</source>
          <target state="translated">반환 된 배열의 데이터 형식입니다. 기본값은 float입니다.</target>
        </trans-unit>
        <trans-unit id="ed2ace0ed658145111b32dfd15ea87700b2f229e" translate="yes" xml:space="preserve">
          <source>Data type routines</source>
          <target state="translated">데이터 타입 루틴</target>
        </trans-unit>
        <trans-unit id="594095b790071c2f98aec2dbd65de7709d74433d" translate="yes" xml:space="preserve">
          <source>Data type sizes</source>
          <target state="translated">데이터 타입 크기</target>
        </trans-unit>
        <trans-unit id="2adf3e418cb1c78b65b7a000ba430a45647a5ca7" translate="yes" xml:space="preserve">
          <source>Data type testing</source>
          <target state="translated">데이터 타입 테스트</target>
        </trans-unit>
        <trans-unit id="98a34d678f5229fc5eec78849854a56a627dd1d1" translate="yes" xml:space="preserve">
          <source>Data type to cast to.</source>
          <target state="translated">캐스트 할 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="182df8c2af2c2944401a368243e72ff53aba919b" translate="yes" xml:space="preserve">
          <source>Data type with fields &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; (with the given titles), both being 8-bit unsigned integers, the first at byte position 0 from the start of the field and the second at position 2:</source>
          <target state="translated">필드 &lt;code&gt;r&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; (주어진 제목 포함)를 가진 데이터 유형 (둘 다 부호없는 정수), 필드의 시작에서 바이트 위치 0에서 첫 번째, 위치 2에서 두 번째 문자 :</target>
        </trans-unit>
        <trans-unit id="b44a74dfbd4c8cbced718e34ed1777e530392fab" translate="yes" xml:space="preserve">
          <source>Data type with fields &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, each being an 8-bit unsigned integer:</source>
          <target state="translated">필드 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 가 각각 8 비트 부호없는 정수인 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="dce22c316f82e72fe3ef7972975de030981baa7a" translate="yes" xml:space="preserve">
          <source>Data type, scalar, or array to cast from.</source>
          <target state="translated">캐스팅 할 데이터 유형, 스칼라 또는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="555f1cb511a7fc830b4f9270140d6d7d6b86fdc6" translate="yes" xml:space="preserve">
          <source>Data types have the following method for changing the byte order:</source>
          <target state="translated">데이터 형식에는 바이트 순서를 변경하는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddbd1fc6e1311002ff40414585d42fb972fc1c73" translate="yes" xml:space="preserve">
          <source>Data with a given value representing missing data</source>
          <target state="translated">결측 데이터를 나타내는 주어진 값을 가진 데이터</target>
        </trans-unit>
        <trans-unit id="fd4e634077f484849d79c425f4661ed26b88a935" translate="yes" xml:space="preserve">
          <source>Data-type checking</source>
          <target state="translated">데이터 유형 검사</target>
        </trans-unit>
        <trans-unit id="391d43bd010ab4fe13de7cc4c6ed3a95e700d762" translate="yes" xml:space="preserve">
          <source>Data-type consisting of more than one element:</source>
          <target state="translated">둘 이상의 요소로 구성된 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="2bc09131fee35a52a645be0fa4f4e07fdb68a652" translate="yes" xml:space="preserve">
          <source>Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as &lt;code&gt;a&lt;/code&gt;. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the &lt;code&gt;type&lt;/code&gt; parameter).</source>
          <target state="translated">반환 된 뷰의 데이터 형식 설명자 (예 : float32 또는 int16) 기본값 None은 뷰와 데이터 유형이 동일 &lt;code&gt;a&lt;/code&gt; . 이 인수는 ndarray 서브 클래스로 지정 될 수도 있습니다. 그런 다음 리턴 된 오브젝트의 유형을 지정합니다 (이는 &lt;code&gt;type&lt;/code&gt; 매개 변수 설정과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="22f7dd2234bee3f3f18b97392a6490d3ba873dee" translate="yes" xml:space="preserve">
          <source>Data-type descriptors</source>
          <target state="translated">데이터 타입 설명자</target>
        </trans-unit>
        <trans-unit id="5047a1b21f308ef4a4edd9ded69fea90920bfe2e" translate="yes" xml:space="preserve">
          <source>Data-type encapsulation</source>
          <target state="translated">데이터 타입 캡슐화</target>
        </trans-unit>
        <trans-unit id="2507f1a7f55fba205d86cdd75b7ab0cf6f6fbdd9" translate="yes" xml:space="preserve">
          <source>Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference. Functions that take &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function.</source>
          <target state="translated">데이터 유형 오브젝트는 참조 횟수를 계산해야하므로 다른 C-API 호출의 데이터 유형 참조에 대한 조치를 알고 있어야합니다. 표준 규칙은 데이터 유형 객체가 반환 될 때 새로운 참조라는 것입니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; 객체 를 가져 오고 배열을 반환 하는 함수는 달리 명시되지 않는 한 입력에 대한 데이터 형식에 대한 참조를 훔칩니다. 따라서 이러한 함수의 입력으로 사용되는 모든 데이터 유형 객체에 대한 참조를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b15d5f87e12104d07e12104f29fa0201983c667c" translate="yes" xml:space="preserve">
          <source>Data-type of returned array.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="175ad74f523c9673c9dc38454591d4eb74c4d08a" translate="yes" xml:space="preserve">
          <source>Data-type of the array&amp;rsquo;s elements.</source>
          <target state="translated">배열 요소의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="083ed855a488906eb5ff7c9039d435f48aa3b852" translate="yes" xml:space="preserve">
          <source>Data-type of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;. By default, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is float.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 에 전달 된 좌표 배열의 데이터 유형입니다 . 기본적으로 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 은 float입니다.</target>
        </trans-unit>
        <trans-unit id="dea8e2a1f7fb1db9b7e34231c5e0957886ee508e" translate="yes" xml:space="preserve">
          <source>Data-type of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;. By default, &lt;code&gt;dtype&lt;/code&gt; is float.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 에 전달 된 좌표 배열의 데이터 유형입니다 . 기본적으로 &lt;code&gt;dtype&lt;/code&gt; 은 float입니다.</target>
        </trans-unit>
        <trans-unit id="4e15c31196d8acf582467b65de7e2dab92710470" translate="yes" xml:space="preserve">
          <source>Data-type of the field in which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 배치 할 필드의 데이터 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="39073b2fd3057c7b3b9a07d35e36e49c334d3ebb" translate="yes" xml:space="preserve">
          <source>Data-type of the output mask. By default, the output mask has a dtype of MaskType (bool). If the dtype is flexible, each field has a boolean dtype. This is ignored when &lt;code&gt;m&lt;/code&gt; is &lt;code&gt;nomask&lt;/code&gt;, in which case &lt;code&gt;nomask&lt;/code&gt; is always returned.</source>
          <target state="translated">출력 마스크의 데이터 유형입니다. 기본적으로 출력 마스크의 dtype은 MaskType (bool)입니다. dtype이 유연한 경우 각 필드에는 부울 dtype이 있습니다. &lt;code&gt;m&lt;/code&gt; 이 &lt;code&gt;nomask&lt;/code&gt; 인 경우에는 무시 되며 ,이 경우 &lt;code&gt;nomask&lt;/code&gt; 가 항상 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="51e15f46df8957d190b0e9a32edbef5e443c1138" translate="yes" xml:space="preserve">
          <source>Data-type of the output matrix.</source>
          <target state="translated">출력 행렬의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c5a46bdf3d87da37dab2e1edc7254de947ac4c8" translate="yes" xml:space="preserve">
          <source>Data-type of the output. Defaults to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">출력의 데이터 유형입니다. 기본값은 &lt;code&gt;float&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dae41e8d6682b39b1719c5f729cf4403ad9808e2" translate="yes" xml:space="preserve">
          <source>Data-type of the resulting array; default: float. If this is a structured data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array. In this case, the number of columns used must match the number of fields in the data-type.</source>
          <target state="translated">결과 배열의 데이터 유형. 디폴트 : float. 이것이 구조화 된 데이터 유형 인 경우 결과 배열은 1 차원이되고 각 행은 배열의 요소로 해석됩니다. 이 경우 사용 된 열 수는 데이터 유형의 필드 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b505071c887042075c861cc8fc2d25f1ea672dda" translate="yes" xml:space="preserve">
          <source>Data-type of the returned array.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="620d631e802c6625ade1eba3753c9c102dd738c0" translate="yes" xml:space="preserve">
          <source>Data-type of the returned array; default: float.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다. 디폴트 : float.</target>
        </trans-unit>
        <trans-unit id="b76cac3ce27a94ef1f707a3ae326b952d9ea72b6" translate="yes" xml:space="preserve">
          <source>Data-type of the returned matrix.</source>
          <target state="translated">반환 된 행렬의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="83e3321d6d9c1b02b3af684537a3f17f48f92529" translate="yes" xml:space="preserve">
          <source>Data-type to convert &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to if given. Default is None.</source>
          <target state="translated">주어진 경우 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 변환 할 데이터 유형 입니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="98198bc475e33e539f57bb5d611ce0c46719fda9" translate="yes" xml:space="preserve">
          <source>Data-type with fields &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, each being an unsigned 8-bit integer:</source>
          <target state="translated">필드가 &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 인 데이터 유형은 각각 부호없는 8 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="97d945f72df62bf65abebd32ec6eeec836638f9c" translate="yes" xml:space="preserve">
          <source>Data-type with fields &lt;code&gt;big&lt;/code&gt; (big-endian 32-bit integer) and &lt;code&gt;little&lt;/code&gt; (little-endian 32-bit integer):</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; (big-endian 32 비트 정수) 및 &lt;code&gt;little&lt;/code&gt; (little-endian 32 비트 정수) 필드가있는 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="f9892dceaf4c393849b8298d0123d5d5f05ba0c0" translate="yes" xml:space="preserve">
          <source>Data-types.</source>
          <target state="translated">Data-types.</target>
        </trans-unit>
        <trans-unit id="63d0f9bc2a331816b54d90289e0564cae9cab711" translate="yes" xml:space="preserve">
          <source>DataSource.abspath()</source>
          <target state="translated">DataSource.abspath()</target>
        </trans-unit>
        <trans-unit id="a75e29b5cace0f330a36c9eb65db62d75aa42186" translate="yes" xml:space="preserve">
          <source>DataSource.exists()</source>
          <target state="translated">DataSource.exists()</target>
        </trans-unit>
        <trans-unit id="bd4a229fdbfe009b3be26b6043f0184701a0533b" translate="yes" xml:space="preserve">
          <source>DataSource.open()</source>
          <target state="translated">DataSource.open()</target>
        </trans-unit>
        <trans-unit id="9406f9d63729835268647100d60fa6dda91bf0bf" translate="yes" xml:space="preserve">
          <source>DataSources can be local files or remote files/URLs. The files may also be compressed or uncompressed. DataSource hides some of the low-level details of downloading the file, allowing you to simply pass in a valid file path (or URL) and obtain a file object.</source>
          <target state="translated">데이터 소스는 로컬 파일 또는 원격 파일 / URL 일 수 있습니다. 파일이 압축되거나 압축되지 않을 수도 있습니다. DataSource는 파일 다운로드에 대한 일부 하위 레벨 세부 사항을 숨기므로 유효한 파일 경로 (또는 URL)를 전달하고 파일 오브젝트를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81b7d2ea42df2f5da13026da9e2cb57a3aabc441" translate="yes" xml:space="preserve">
          <source>Date:</source>
          <target state="translated">Date:</target>
        </trans-unit>
        <trans-unit id="3a634fe6b2da8d8d4c344bc698f77cf69c809b5f" translate="yes" xml:space="preserve">
          <source>Datetime</source>
          <target state="translated">Datetime</target>
        </trans-unit>
        <trans-unit id="bb7bfb490786a995bfa9e2a5b6823f17a1a216ef" translate="yes" xml:space="preserve">
          <source>Datetime Arithmetic</source>
          <target state="translated">날짜 / 시간 산술</target>
        </trans-unit>
        <trans-unit id="26757f51523448884cb35f7c2e7a9d830a1f0706" translate="yes" xml:space="preserve">
          <source>Datetime Support Functions</source>
          <target state="translated">날짜 / 시간 지원 기능</target>
        </trans-unit>
        <trans-unit id="e00cad3edede5f768d55ef060cdd96323a7571ad" translate="yes" xml:space="preserve">
          <source>Datetime Units</source>
          <target state="translated">날짜 시간 단위</target>
        </trans-unit>
        <trans-unit id="38b428bb26c8af0c4b0fd0c5793ec1f2bdae7051" translate="yes" xml:space="preserve">
          <source>Datetime and Timedelta Arithmetic</source>
          <target state="translated">날짜 및 시간 델타 산술</target>
        </trans-unit>
        <trans-unit id="48d6aa44d4ca3cc7a3a4b06f69e541ecb8ebd93c" translate="yes" xml:space="preserve">
          <source>Datetime support functions</source>
          <target state="translated">날짜 / 시간 지원 기능</target>
        </trans-unit>
        <trans-unit id="45540e9d36b6a636a7d3f2083fde0b3cb45e0a66" translate="yes" xml:space="preserve">
          <source>Datetimes and Timedeltas</source>
          <target state="translated">날짜 및 시간 델타</target>
        </trans-unit>
        <trans-unit id="d5889493937e34467174cb169e91b981059850e9" translate="yes" xml:space="preserve">
          <source>Datetimes and Timedeltas work together to provide ways for simple datetime calculations.</source>
          <target state="translated">Datetimes와 Timedeltas는 간단한 날짜 / 시간 계산 방법을 제공하기 위해 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51531cc702406b6c9763cc42d8bdd8ad26a43c0f" translate="yes" xml:space="preserve">
          <source>Datetimes are always stored based on POSIX time (though having a TAI mode which allows for accounting of leap-seconds is proposed), with an epoch of 1970-01-01T00:00Z. This means the supported dates are always a symmetric interval around the epoch, called &amp;ldquo;time span&amp;rdquo; in the table below.</source>
          <target state="translated">날짜 시간은 항상 POSIX 시간을 기준으로 저장되며 (도약 시간을 계산할 수있는 TAI 모드가 제 안됨) 1970-01-01T00 : 00Z의 에포크가 있습니다. 이는 지원되는 날짜가 항상 에포크 주변의 대칭 간격이며 아래 표에서 &quot;시간 범위&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="122763cb7427afdd4c15e276fdc1c80b3815094a" translate="yes" xml:space="preserve">
          <source>David McKay, &amp;ldquo;Information Theory, Inference and Learning Algorithms,&amp;rdquo; chapter 23, &lt;a href=&quot;http://www.inference.org.uk/mackay/itila/&quot;&gt;http://www.inference.org.uk/mackay/itila/&lt;/a&gt;</source>
          <target state="translated">David McKay,&amp;ldquo;정보 이론, 추론 및 학습 알고리즘,&amp;rdquo;23 장, &lt;a href=&quot;http://www.inference.org.uk/mackay/itila/&quot;&gt;http://www.inference.org.uk/mackay/itila/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="812d36d79a90e882bd2e8eae368ea14f78ae3b09" translate="yes" xml:space="preserve">
          <source>Dealing with types</source>
          <target state="translated">타입 다루기</target>
        </trans-unit>
        <trans-unit id="a8f5a30a4cb8786cd322dd6dbfd8f1d482955120" translate="yes" xml:space="preserve">
          <source>Deallocates the iterator object and resolves any needed writebacks.</source>
          <target state="translated">반복자 객체를 할당 해제하고 필요한 모든 쓰기 저장을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ad9c7cd74dc2bd34e8b8c600c07899c84dcc04dd" translate="yes" xml:space="preserve">
          <source>Debian (sid) Linux, Python 2.1.3+, 2.2.3+, 2.3.3 PyCrust 0.9.3, Idle 1.0.2</source>
          <target state="translated">데비안 (sid) 리눅스, Python 2.1.3+, 2.2.3+, 2.3.3 PyCrust 0.9.3, 유휴 1.0.2</target>
        </trans-unit>
        <trans-unit id="1111acbc77e1b6bc2fd9153a83aaaa3e388ca65d" translate="yes" xml:space="preserve">
          <source>Deciding what case applies, checking broadcasting, and determining the kind of transposition needed are all done in &lt;code&gt;PyArray_MapIterNew&lt;/code&gt;. After setting up, there are two cases. If there is no subarray or it only has one element, no subarray iteration is necessary and an iterator is prepared which iterates all indexing arrays &lt;em&gt;as well as&lt;/em&gt; the result or value array. If there is a subarray, there are three iterators prepared. One for the indexing arrays, one for the result or value array (minus its subarray), and one for the subarrays of the original and the result/assignment array. The first two iterators give (or allow calculation) of the pointers into the start of the subarray, which then allows to restart the subarray iteration.</source>
          <target state="translated">적용 사례 결정, 방송 확인 및 필요한 전이 종류 결정은 모두 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 에서 수행됩니다 . 설정 후 두 가지 경우가 있습니다. 하위 배열이 없거나 하나의 요소 만있는 경우 하위 배열 반복이 필요하지 않으며 결과 또는 값 배열 &lt;em&gt;뿐만 아니라&lt;/em&gt; 모든 색인 배열을 반복하는 반복자가 준비 됩니다. 하위 배열이 있으면 세 개의 반복자가 준비됩니다. 하나는 인덱싱 배열, 하나는 결과 또는 값 배열 (하위 배열 빼기), 다른 하나는 원본 및 결과 / 할당 배열의 하위 배열입니다. 처음 두 반복자는 하위 배열의 시작 부분에 포인터를 제공하거나 계산을 허용하여 하위 배열 반복을 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9516fdc9c7eef205e499da4e7ec3cede5ceb388" translate="yes" xml:space="preserve">
          <source>Decimal characters include digit characters, and all characters that that can be used to form decimal-radix numbers, e.g. &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt;.</source>
          <target state="translated">십진 문자에는 숫자 문자 및 십진 기수를 형성하는 데 사용할 수있는 모든 문자 (예 : &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e660781fd8b95b64d64b6f05b5f17d8ea5d1d96c" translate="yes" xml:space="preserve">
          <source>Decompose the elements of x into mantissa and twos exponent.</source>
          <target state="translated">x의 요소를 가수와 2의 지수로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="c0a2aa6456fc6630ef3dc6620f0cbae61a88fe6c" translate="yes" xml:space="preserve">
          <source>Decompositions</source>
          <target state="translated">Decompositions</target>
        </trans-unit>
        <trans-unit id="ffe4e593056575686068099d6790448db4206386" translate="yes" xml:space="preserve">
          <source>Decorator to apply to methods</source>
          <target state="translated">메소드에 적용하는 데코레이터</target>
        </trans-unit>
        <trans-unit id="e07b2c2e1e25e79a86c68698117e4cba4b32238d" translate="yes" xml:space="preserve">
          <source>Decorator which, when applied to a function, causes SkipTest to be raised when &lt;code&gt;skip_condition&lt;/code&gt; is True, and the function to be called normally otherwise.</source>
          <target state="translated">함수에 적용될 때 &lt;code&gt;skip_condition&lt;/code&gt; 이 True이면 SkipTest가 발생 하고 그렇지 않으면 함수가 정상적으로 호출 되는 데코레이터 .</target>
        </trans-unit>
        <trans-unit id="adc746be3b00936c8c3a3472b3e3078c3a4656a5" translate="yes" xml:space="preserve">
          <source>Decorator, which, when applied to a function, causes KnownFailureException to be raised when &lt;code&gt;fail_condition&lt;/code&gt; is True, and the function to be called normally otherwise.</source>
          <target state="translated">&lt;code&gt;fail_condition&lt;/code&gt; 이 True 인 경우 함수에 적용될 때 KnownFailureException 이 발생 하고, 그렇지 않으면 함수가 정상적으로 호출 되는 Decorator .</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="34692108afca567d865d43e42370d7e1925cff06" translate="yes" xml:space="preserve">
          <source>Default buffers</source>
          <target state="translated">기본 버퍼</target>
        </trans-unit>
        <trans-unit id="2335a11535e98158d8ca1e7070652f1e66fd9c56" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;greedy&amp;rsquo;.</source>
          <target state="translated">기본값은 '욕심'입니다.</target>
        </trans-unit>
        <trans-unit id="c17e4da3ff3b0f9f748a4d6acc1f8640afd0a462" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;r+&amp;rsquo;.</source>
          <target state="translated">기본값은 'r +'입니다.</target>
        </trans-unit>
        <trans-unit id="d6fc6505a7468b1eb07e232276a1a144ed108cc4" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;safe&amp;rsquo;.</source>
          <target state="translated">기본값은 '안전'입니다.</target>
        </trans-unit>
        <trans-unit id="ffe4ea797d5b8a7f8cfde90ab339db72e2e542a2" translate="yes" xml:space="preserve">
          <source>Default is 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b9ce70b65cf5b4dc82412d7768f94d53c38cac38" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;False&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, the tuple (&lt;a href=&quot;#numpy.average&quot;&gt;&lt;code&gt;average&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;sum_of_weights&lt;/code&gt;) is returned, otherwise only the average is returned. If &lt;code&gt;weights=None&lt;/code&gt;, &lt;code&gt;sum_of_weights&lt;/code&gt; is equivalent to the number of elements over which the average is taken.</source>
          <target state="translated">기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 경우 &lt;code&gt;True&lt;/code&gt; , 튜플 ( &lt;a href=&quot;#numpy.average&quot;&gt; &lt;code&gt;average&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;sum_of_weights&lt;/code&gt; 가 ) 반환되고, 그렇지 않으면 단지 평균이 반환됩니다. 경우 &lt;code&gt;weights=None&lt;/code&gt; , &lt;code&gt;sum_of_weights&lt;/code&gt; 하면 평균 촬영되는 동안 소자의 수와 동일하다.</target>
        </trans-unit>
        <trans-unit id="6fafe55b73fa98b695385282c370b435d27e1633" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;None&lt;/code&gt;, to use the entire axis.</source>
          <target state="translated">전체 축을 사용하려면 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28951177af990d02d67504338ec510505f905759" translate="yes" xml:space="preserve">
          <source>Default iteration</source>
          <target state="translated">기본 반복</target>
        </trans-unit>
        <trans-unit id="966299221cc27c9aaada9018f864b33036434b1d" translate="yes" xml:space="preserve">
          <source>Default normalization (False) is by &lt;code&gt;(N - 1)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations given (unbiased estimate). If &lt;code&gt;bias&lt;/code&gt; is True, then normalization is by &lt;code&gt;N&lt;/code&gt;. These values can be overridden by using the keyword &lt;code&gt;ddof&lt;/code&gt; in numpy versions &amp;gt;= 1.5.</source>
          <target state="translated">기본 정규화 (False)는 &lt;code&gt;(N - 1)&lt;/code&gt; . 여기서 &lt;code&gt;N&lt;/code&gt; 은 제공된 관측치 수입니다 (편견되지 않은 추정치). 경우 &lt;code&gt;bias&lt;/code&gt; True 인 후 정상화는 것입니다 &lt;code&gt;N&lt;/code&gt; . 이 값은 numpy 버전&amp;gt; = 1.5에서 키워드 &lt;code&gt;ddof&lt;/code&gt; 를 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90d359fa1c07cc7df5b917d7e3f5d34c57ec0aae" translate="yes" xml:space="preserve">
          <source>Default normalization (False) is by &lt;code&gt;(N-1)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations given (unbiased estimate). If &lt;code&gt;bias&lt;/code&gt; is True, then normalization is by &lt;code&gt;N&lt;/code&gt;. This keyword can be overridden by the keyword &lt;code&gt;ddof&lt;/code&gt; in numpy versions &amp;gt;= 1.5.</source>
          <target state="translated">기본 정규화 (False)는 &lt;code&gt;(N-1)&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 제공된 관측치 수입니다 (편견되지 않은 추정치). 경우 &lt;code&gt;bias&lt;/code&gt; True 인 후 정상화는 것입니다 &lt;code&gt;N&lt;/code&gt; . 이 키워드는 numpy 버전&amp;gt; = 1.5 의 키워드 &lt;code&gt;ddof&lt;/code&gt; 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="719f3db22853f6f54f02e96c26a2311da39af743" translate="yes" xml:space="preserve">
          <source>Default priority for arrays.</source>
          <target state="translated">배열의 기본 우선 순위.</target>
        </trans-unit>
        <trans-unit id="6716ba557871317c5fd2c10ccc1e593c8f19cb74" translate="yes" xml:space="preserve">
          <source>Default scalar priority (very small)</source>
          <target state="translated">기본 스칼라 우선 순위 (매우 작음)</target>
        </trans-unit>
        <trans-unit id="e641966d275ad425b62fc62d9745e763b1f6dd59" translate="yes" xml:space="preserve">
          <source>Default size of the user-settable internal buffers.</source>
          <target state="translated">사용자 설정 가능한 내부 버퍼의 기본 크기.</target>
        </trans-unit>
        <trans-unit id="5d1efc3a1f02c0ec5b61bbb0c9ab7a02738e94d3" translate="yes" xml:space="preserve">
          <source>Default subtype priority.</source>
          <target state="translated">기본 하위 유형 우선 순위.</target>
        </trans-unit>
        <trans-unit id="16a99af14cd742b7888548aa51fb6ac7d09e8605" translate="yes" xml:space="preserve">
          <source>Defaults to true. If set to false, the output will always be a strict array, not a subtype.</source>
          <target state="translated">기본값은 true입니다. false로 설정하면 출력은 항상 하위 유형이 아닌 엄격한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2b3e0f5011c5a7820f042e8646d3807526feef63" translate="yes" xml:space="preserve">
          <source>Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates &lt;code&gt;pyfunc&lt;/code&gt; over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.</source>
          <target state="translated">중첩 된 객체 시퀀스 또는 numpy 배열을 입력으로 사용하고 단일 numpy 배열 또는 numpy 배열의 튜플을 반환하는 벡터화 된 함수를 정의하십시오. 벡터화 된 함수 는 numpy의 브로드 캐스트 규칙을 사용하는 것을 제외하고는 파이썬 맵 함수와 같은 입력 배열의 연속 튜플에 대해 &lt;code&gt;pyfunc&lt;/code&gt; 를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="61505cbdb5cf52ffbc6a8bf8b8f8af1217631a20" translate="yes" xml:space="preserve">
          <source>Define the absolute value, which is &lt;code&gt;-x&lt;/code&gt; for &lt;code&gt;x &amp;lt;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; for &lt;code&gt;x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">인 절대 값 정의 &lt;code&gt;-x&lt;/code&gt; 대한 &lt;code&gt;x &amp;lt;0&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 에 대한 &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60c3116e72bd6db8e3267fc1ab9d7cb6e083f5e7" translate="yes" xml:space="preserve">
          <source>Define the sigma function, which is -1 for &lt;code&gt;x &amp;lt; 0&lt;/code&gt; and +1 for &lt;code&gt;x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; 0&lt;/code&gt; -1 이고 &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; +1 인 시그마 함수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5471ada09dfcde67297a0ac30990ba21a16931a" translate="yes" xml:space="preserve">
          <source>Defined as 0 for use with Bool.</source>
          <target state="translated">Bool과 함께 사용하기 위해 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="139ca190227fe964dc3838ddb050be0a20c65202" translate="yes" xml:space="preserve">
          <source>Defined as 1 for use with Bool.</source>
          <target state="translated">Bool과 함께 사용하기 위해 1로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="670d6eec1e9ea50b484d7c17bdc447c52fe95496" translate="yes" xml:space="preserve">
          <source>Defined in &lt;code&gt;numpy/npy_cpu.h&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy/npy_cpu.h&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="8b1b72675b98643cbdd56a0a279d2ae2f68589c9" translate="yes" xml:space="preserve">
          <source>Defined in &lt;code&gt;numpy/npy_endian.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy/npy_endian.h&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="26a40d9f0ef7f2215f8cc29e1f71feface330732" translate="yes" xml:space="preserve">
          <source>Defined to be the number of scalar kinds (not including &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;).</source>
          <target state="translated">스칼라 종류의 수로 정의됩니다 ( &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="ba198b982dcf4bd0cea8ecc26bd1efeae5fde285" translate="yes" xml:space="preserve">
          <source>Defined to be the number of sorts. It is fixed at three by the need for backwards compatibility, and consequently &lt;code&gt;NPY_MERGESORT&lt;/code&gt; and &lt;code&gt;NPY_STABLESORT&lt;/code&gt; are aliased to each other and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">정렬 수로 정의되었습니다. 이전 버전과의 호환성 요구로 인해 3으로 고정되어 결과적으로 &lt;code&gt;NPY_MERGESORT&lt;/code&gt; 와 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; 는 서로 별명을 가지며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c2126c80b6518c66a9593fe462e64cc5a15f601" translate="yes" xml:space="preserve">
          <source>Defines</source>
          <target state="translated">Defines</target>
        </trans-unit>
        <trans-unit id="6e49bf7d4a54a21945d1908234ab12cc2626625b" translate="yes" xml:space="preserve">
          <source>Defining a more complex dtype.</source>
          <target state="translated">보다 복잡한 dtype 정의</target>
        </trans-unit>
        <trans-unit id="45bcbf15eef8b7f89c50a8bf22d703e07ba3a825" translate="yes" xml:space="preserve">
          <source>Defining an &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt; is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here&amp;rsquo;s an example for a function which doubles up an element using an element copier function as a primitive.:</source>
          <target state="translated">정의 &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 하면&lt;/a&gt; ++ C의 클래스를 정의하는 것과 유사하지만, 물체 의미는 API 여기 C.에있는 프리미티브 소자 복사기 기능을 이용하여 요소를 두배로하는 기능에 대한 예시 이후 수동으로 추적 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="8834c54a1246a67dbc0ecb790c071b10a7e3b66b" translate="yes" xml:space="preserve">
          <source>Defining new types</source>
          <target state="translated">새로운 유형 정의</target>
        </trans-unit>
        <trans-unit id="adaa548fb9106ef1144d20b8ae04cecae72c8510" translate="yes" xml:space="preserve">
          <source>Definite integral as approximated by trapezoidal rule.</source>
          <target state="translated">사다리꼴 규칙에 의해 근사 된 명확한 적분.</target>
        </trans-unit>
        <trans-unit id="3332194d546c6c7cc86b5b84d7cd68baf0e623cb" translate="yes" xml:space="preserve">
          <source>Definition of the core elements a generalized ufunc operates on.</source>
          <target state="translated">일반화 된 ufunc가 작동하는 핵심 요소의 정의.</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="9184d3e4687563972d72b163e489c6c843a31654" translate="yes" xml:space="preserve">
          <source>Degree of the basis polynomial for the series. Must be &amp;gt;= 0.</source>
          <target state="translated">시리즈의 기본 다항식의 차수입니다. &amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="16c78a8e8f95308316ca05a4c6f57586f7f58e4d" translate="yes" xml:space="preserve">
          <source>Degree of the fitting polynomial</source>
          <target state="translated">피팅 다항식의 차수</target>
        </trans-unit>
        <trans-unit id="b8722a2887db9363ae0b8c5a5c30ec99ff352e3d" translate="yes" xml:space="preserve">
          <source>Degree of the interpolating polynomial.</source>
          <target state="translated">보간 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="214ea8bba1ed183b7e097241368f077a3cd144a1" translate="yes" xml:space="preserve">
          <source>Degree of the resulting matrix.</source>
          <target state="translated">결과 행렬의 정도입니다.</target>
        </trans-unit>
        <trans-unit id="80d0e0a542e906c0db420181650b3b792573e76e" translate="yes" xml:space="preserve">
          <source>Degree of the series, one less than the number of coefficients.</source>
          <target state="translated">계수의 수보다 1이 적은 계열의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="a6aec0c27c1647ddafe05683c8d4b8074b12d8ab" translate="yes" xml:space="preserve">
          <source>Degree(s) of the fitting polynomials. If &lt;code&gt;deg&lt;/code&gt; is a single integer all terms up to and including the &lt;code&gt;deg&lt;/code&gt;&amp;rsquo;th term are included in the fit. For NumPy versions &amp;gt;= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead.</source>
          <target state="translated">피팅 다항식의 차수입니다. 경우 &lt;code&gt;deg&lt;/code&gt; 하나의 정수입니다 및 포함한 모든 용어 &lt;code&gt;deg&lt;/code&gt; '제 용어는 적합에 포함되어 있습니다. NumPy 버전&amp;gt; = 1.11.0의 경우, 포함 할 항의 정도를 지정하는 정수 목록이 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4678dad6fdcb23005370fe1fca044a896edcd5e9" translate="yes" xml:space="preserve">
          <source>Degree(s) of the fitting polynomials. If &lt;code&gt;deg&lt;/code&gt; is a single integer, all terms up to and including the &lt;code&gt;deg&lt;/code&gt;&amp;rsquo;th term are included in the fit. For NumPy versions &amp;gt;= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead.</source>
          <target state="translated">피팅 다항식의 차수입니다. 경우 &lt;code&gt;deg&lt;/code&gt; 하나의 정수의 및 포함한 모든 용어 &lt;code&gt;deg&lt;/code&gt; '제 용어는 적합에 포함되어 있습니다. NumPy 버전&amp;gt; = 1.11.0의 경우, 포함 할 항의 정도를 지정하는 정수 목록이 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de0696584be15bbb43013a1abc8390fb59e0b4c" translate="yes" xml:space="preserve">
          <source>Degrees of freedom in denominator, must be &amp;gt; 0.</source>
          <target state="translated">분모의 자유도는&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d447133a9630e193dc9b4895034fdb7a2d5656cf" translate="yes" xml:space="preserve">
          <source>Degrees of freedom in numerator, must be &amp;gt; 0.</source>
          <target state="translated">분자의 자유도는&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fc860f3319e43352dfab21d263879520eed366e" translate="yes" xml:space="preserve">
          <source>Degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="efdf5c52531831e38290d369a2fc1a1d6c2f3ab4" translate="yes" xml:space="preserve">
          <source>Delete elements from an array.</source>
          <target state="translated">배열에서 요소를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="09e1a4ac558262087ade7474a27905ea0753215f" translate="yes" xml:space="preserve">
          <source>Delete self[key].</source>
          <target state="translated">자체 [키]를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="826d5fa4cd77081924ffa3247bc7e1144ad995c4" translate="yes" xml:space="preserve">
          <source>Delete the memmap instance to close the memmap file.</source>
          <target state="translated">memmap 인스턴스를 삭제하여 memmap 파일을 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="1b1ea38145f80e657023804a5a2fb9968cec7261" translate="yes" xml:space="preserve">
          <source>Deletion flushes memory changes to disk before removing the object:</source>
          <target state="translated">삭제는 객체를 제거하기 전에 메모리 변경 사항을 디스크로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="51de9c21719e1ebba2842f93455553ec20fd0114" translate="yes" xml:space="preserve">
          <source>Demonstrate how large values of non-centrality lead to a more symmetric distribution.</source>
          <target state="translated">비중 심의 큰 가치가 어떻게 더 대칭적인 분포로 이어지는 지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c9afd5880fd0526ff9d73beb159ef27c30006c77" translate="yes" xml:space="preserve">
          <source>Demonstrate that taking the products of random samples from a uniform distribution can be fit well by a log-normal probability density function.</source>
          <target state="translated">균일 분포에서 랜덤 표본의 곱을 얻는 것이 로그 정규 확률 밀도 함수에 잘 맞을 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7d7f05c3b413d3520059a47e99ca5537a68001e7" translate="yes" xml:space="preserve">
          <source>Denominator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">분모의 자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="ac772a011193bb984a652b0f5e9cfc8b6b3f2d87" translate="yes" xml:space="preserve">
          <source>Denominator. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">분모. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="b42515ab1d65352ed70392656cd1eb8f0df21091" translate="yes" xml:space="preserve">
          <source>Deprecated in 1.14, use &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; followed by &lt;code&gt;Py_XDECREF&lt;/code&gt;</source>
          <target state="translated">1.14에서 더 이상 사용되지 &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 와 Py_XDECREF를 차례로 사용 &lt;code&gt;Py_XDECREF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75510f16f2c885973d68ca6976d07c5d06c5ddae" translate="yes" xml:space="preserve">
          <source>Deprecated in numpy 1.9.0, use the abstract ABCPolyBase class instead. Note that the latter requires a number of virtual functions to be implemented.</source>
          <target state="translated">numpy 1.9.0에서 사용되지 않으므로 대신 추상 ABCPolyBase 클래스를 사용하십시오. 후자는 많은 가상 기능을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="90fbb082fd2714c0f36df6a60a4e4c93fb36448f" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.10.0.</source>
          <target state="translated">버전 1.10.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a505e56c3c318c866f582620a893576d41513eec" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.11.0.</source>
          <target state="translated">버전 1.11.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94443fd2ced7d37ea3bb33b7fb41ae4c59135a80" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.12.0.</source>
          <target state="translated">버전 1.12.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9a59ff61f9445930ed15b411b507cb3a3190092" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.14.0.</source>
          <target state="translated">버전 1.14.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229727d5d807915b35e3a79a88f55c01627e95f0" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.14: Passing &lt;code&gt;sep=''&lt;/code&gt;, the default, is deprecated since it will trigger the deprecated binary mode of this function. This mode interprets &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; as binary bytes, rather than ASCII text with decimal numbers, an operation which is better spelt &lt;code&gt;frombuffer(string, dtype, count)&lt;/code&gt;. If &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; contains unicode text, the binary mode of &lt;a href=&quot;#numpy.fromstring&quot;&gt;&lt;code&gt;fromstring&lt;/code&gt;&lt;/a&gt; will first encode it into bytes using either utf-8 (python 3) or the default encoding (python 2), neither of which produce sane results.</source>
          <target state="translated">버전 1.14부터 더 이상 사용되지 않음 : 기본값 인 &lt;code&gt;sep=''&lt;/code&gt; 를 전달하면 이 함수의 더 이상 사용되지 않는 이진 모드가 트리거되므로 더 이상 사용되지 않습니다. 이 모드는 &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 을 10 진수로 된 ASCII 텍스트가 아니라 2 진 바이트로 해석 합니다. 이 명령은 &lt;code&gt;frombuffer(string, dtype, count)&lt;/code&gt; 보다 나은 철자를 사용 합니다. &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 에 유니 코드 텍스트가 포함 된 경우 &lt;a href=&quot;#numpy.fromstring&quot;&gt; &lt;code&gt;fromstring&lt;/code&gt; &lt;/a&gt; 의 이진 모드 는 먼저 utf-8 (python 3) 또는 기본 인코딩 (python 2)을 사용하여 바이트로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dca5b7419ce0c6a33ee759ad9e3594c329bce938" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.15.0: In order to remain backward compatible with a common usage in Numeric, basic slicing is also initiated if the selection object is any non-ndarray and non-tuple sequence (such as a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;) containing &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; objects, the &lt;code&gt;Ellipsis&lt;/code&gt; object, or the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object, but not for integer arrays or other embedded sequences.</source>
          <target state="translated">버전 1.15.0부터 더 이상 사용되지 않음 : Numeric의 일반적인 사용법과 역 호환성을 유지하기 위해 선택 객체가 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 객체를 포함 하는 비 ndarray 및 튜플이 아닌 시퀀스 (예 : &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; ) 인 경우 기본 슬라이싱이 시작됩니다 . &lt;code&gt;Ellipsis&lt;/code&gt; 객체 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체이지만 정수 배열이나 다른 포함 된 시퀀스에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c18d46be05f158f4a9f48a23fcafd55bc8ee7952" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.16.</source>
          <target state="translated">버전 1.16부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6151f894a8e79cde423047d76e0abe9518b5d32" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.16: Deprecated, use &lt;code&gt;numpy.ndarray.item()&lt;/code&gt; instead.</source>
          <target state="translated">버전 1.16부터 사용되지 않음 : 사용되지 &lt;code&gt;numpy.ndarray.item()&lt;/code&gt; 대신 numpy.ndarray.item ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3fc485c4dc97b2ed8df47cb88214775178f80c1" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.17: The output is currently marked so that if written to, a deprecation warning will be emitted. A future version will set the &lt;code&gt;writable&lt;/code&gt; flag False so writing to it will raise an error.</source>
          <target state="translated">버전 1.17부터 더 이상 사용되지 않음 : 출력은 현재 표시되어 있으므로 쓰면 사용 중단 경고가 발생합니다. 이후 버전에서는 &lt;code&gt;writable&lt;/code&gt; 플래그를 False로 설정 하므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26689b58bf759fcfedfe480ee292230f1eae7e85" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.6.0.</source>
          <target state="translated">버전 1.6.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5ebd48a05d1197ffab8d82861190636acfcb48f" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, which is similar. This flag &amp;ldquo;automatically&amp;rdquo; copies the data back when the returned array is deallocated, which is not supported in all python implementations.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 이 플래그는 &quot;자동으로&quot;반환 된 배열이 할당 해제 될 때 데이터를 다시 복사합니다. 이는 모든 파이썬 구현에서 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="141e039b9533a98c94309e5719dbf35ad8e170ab" translate="yes" xml:space="preserve">
          <source>Deprecated: use npy_clear_floatstatus from npy_math.h instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 npy_math.h에서 npy_clear_floatstatus를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5cf6f463ce56314bce23e2b79281c112c8d5ef7b" translate="yes" xml:space="preserve">
          <source>Deprecation Mechanism NPY_NO_DEPRECATED_API</source>
          <target state="translated">지원 중단 메커니즘 NPY_NO_DEPRECATED_API</target>
        </trans-unit>
        <trans-unit id="6735a66773b194a7ae390d1ca4d06ddff66cb19d" translate="yes" xml:space="preserve">
          <source>Describes partition algorithms used.</source>
          <target state="translated">사용 된 파티션 알고리즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a4cf5c2fa78a781f3bab283524a5720dd26e5a08" translate="yes" xml:space="preserve">
          <source>Describes sorting algorithms used.</source>
          <target state="translated">사용되는 정렬 알고리즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="555c5d2cb07e18fc50ac305ad3849cdbe6160644" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; can be written to.</source>
          <target state="translated">여부를 설명 &lt;code&gt;a&lt;/code&gt; 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="424441bbf87af33c47ad0cfb1f7fa3b9fa63955e" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; is a copy of another &amp;ldquo;base&amp;rdquo; array.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 다른&amp;ldquo;기본&amp;rdquo;배열의 사본 인지 여부를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="65d8e7f90a58b5a5ee1060f1f22a86aed35beae6" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; is aligned properly for its type.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 해당 유형에 맞게 정렬되었는지 여부를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="3fcfa113d41636118b9fc7438de0f310d710e2cc" translate="yes" xml:space="preserve">
          <source>Description of the input data type code.</source>
          <target state="translated">입력 데이터 유형 코드에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="9829bed50f31ac25ea870651c23dc5ce8171f8e6" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result, either &amp;lsquo;d&amp;rsquo; (or &amp;lsquo;float64&amp;rsquo;) or &amp;lsquo;f&amp;rsquo; (or &amp;lsquo;float32&amp;rsquo;). All dtypes are determined by their name. The default value is &amp;lsquo;d&amp;rsquo;.</source>
          <target state="translated">결과의 원하는 dtype은 'd'(또는 'float64') 또는 'f'(또는 'float32')입니다. 모든 dtype은 이름으로 결정됩니다. 기본값은 'd'입니다.</target>
        </trans-unit>
        <trans-unit id="f21ac6e26595def622d7f71a3b4db5b0d1d28b7c" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result. All dtypes are determined by their name, i.e., &amp;lsquo;int64&amp;rsquo;, &amp;lsquo;int&amp;rsquo;, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is &amp;lsquo;np.int&amp;rsquo;.</source>
          <target state="translated">결과의 원하는 dtype입니다. 모든 dtype은 이름, 즉 'int64', 'int'등으로 결정되므로 바이트 순서를 사용할 수 없으며 플랫폼에 따라 특정 정밀도에 따라 C 유형이 다를 수 있습니다. 기본값은 'np.int'입니다.</target>
        </trans-unit>
        <trans-unit id="d121e78f3074bde690535b07325dfb836a0267ba" translate="yes" xml:space="preserve">
          <source>Desired output data-type for the array, e.g, &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">원하는 출력 데이터 타입 배열, 예 &lt;code&gt;numpy.int8&lt;/code&gt; . 기본값은 &lt;code&gt;numpy.float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b152ee224a01e68e60fe4dbd7092f5aa497fbc8" translate="yes" xml:space="preserve">
          <source>Desired output data-type.</source>
          <target state="translated">원하는 출력 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="d92d689242f2299b4475be6532f6b4c69b49753f" translate="yes" xml:space="preserve">
          <source>Desired precision, default is 6.</source>
          <target state="translated">원하는 정밀도, 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="57f388f8b04810bebe2800d826bdcb39eda4bd12" translate="yes" xml:space="preserve">
          <source>Desired precision, default is 7.</source>
          <target state="translated">원하는 정밀도, 기본값은 7입니다.</target>
        </trans-unit>
        <trans-unit id="cde9d9b4e0b9af3dfaaddd342aedc25e93ab8375" translate="yes" xml:space="preserve">
          <source>Destination array.</source>
          <target state="translated">대상 배열.</target>
        </trans-unit>
        <trans-unit id="e7808a0714f80da97918a2e4274a40d30bcdd7a7" translate="yes" xml:space="preserve">
          <source>Destination positions for each of the original axes. These must also be unique.</source>
          <target state="translated">각 원래 축의 대상 위치. 이것 또한 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="21ef51d75c614a51c95b2672f954fdc6c7fae2d1" translate="yes" xml:space="preserve">
          <source>Detailed notes</source>
          <target state="translated">자세한 메모</target>
        </trans-unit>
        <trans-unit id="7d40f5113e5a0be345c6e8da2b15397b86e772db" translate="yes" xml:space="preserve">
          <source>Details of Signature</source>
          <target state="translated">서명 내용</target>
        </trans-unit>
        <trans-unit id="600eeccd7db308f4a989eda843209f6bc5c9f6d7" translate="yes" xml:space="preserve">
          <source>Determinant of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 결정 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="706fbd5a75b61eb7b1941f3576619d3b0a2e0ad0" translate="yes" xml:space="preserve">
          <source>Determine an appropriate data-type object from the object &lt;em&gt;op&lt;/em&gt; (which should be a &amp;ldquo;nested&amp;rdquo; sequence object) and the minimum data-type descriptor mintype (which can be &lt;code&gt;NULL&lt;/code&gt; ). Similar in behavior to array(&lt;em&gt;op&lt;/em&gt;).dtype. Don&amp;rsquo;t confuse this function with &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt;. This function essentially looks at all the objects in the (nested) sequence and determines the data-type from the elements it finds.</source>
          <target state="translated">객체 &lt;em&gt;op&lt;/em&gt; ( &quot;중첩 된&quot;시퀀스 객체 여야 함)와 최소 데이터 유형 설명자 최소 유형 ​​( &lt;code&gt;NULL&lt;/code&gt; 일 수 있음 ) 에서 적절한 데이터 유형 객체를 결정합니다 . array ( &lt;em&gt;op&lt;/em&gt; ) .dtype과 유사합니다. 이 함수를 &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt; 와 혼동하지 마십시오 . 이 함수는 기본적으로 (중첩 된) 시퀀스의 모든 객체를보고 찾은 요소에서 데이터 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="898483c19901b499900035a5195202d8244c4b8f" translate="yes" xml:space="preserve">
          <source>Determine common type following standard coercion rules.</source>
          <target state="translated">표준 강제 규칙에 따라 공통 유형을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="f493f90604c24e63ef3589f15cfb3213ad17edc7" translate="yes" xml:space="preserve">
          <source>Determine if &lt;em&gt;newstrides&lt;/em&gt; is a strides array consistent with the memory of an &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape &lt;code&gt;dims&lt;/code&gt; and element-size, &lt;em&gt;elsize&lt;/em&gt;. The &lt;em&gt;newstrides&lt;/em&gt; array is checked to see if jumping by the provided number of bytes in each direction will ever mean jumping more than &lt;em&gt;numbytes&lt;/em&gt; which is the assumed size of the available memory segment. If &lt;em&gt;numbytes&lt;/em&gt; is 0, then an equivalent &lt;em&gt;numbytes&lt;/em&gt; is computed assuming &lt;em&gt;nd&lt;/em&gt;, &lt;em&gt;dims&lt;/em&gt;, and &lt;em&gt;elsize&lt;/em&gt; refer to a single-segment array. Return &lt;a href=&quot;#c.NPY_TRUE&quot;&gt;&lt;code&gt;NPY_TRUE&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;newstrides&lt;/em&gt; is acceptable, otherwise return &lt;a href=&quot;#c.NPY_FALSE&quot;&gt;&lt;code&gt;NPY_FALSE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만약 결정 &lt;em&gt;newstrides가&lt;/em&gt; 의 메모리 일관성 자선 배열이다 &lt;em&gt;ND&lt;/em&gt; 모양과 차원 배열 &lt;code&gt;dims&lt;/code&gt; 및 소자 크기 &lt;em&gt;elsize&lt;/em&gt; . &lt;em&gt;newstrides의&lt;/em&gt; 배열을 참조 할 것 선택하면 적 평균 점프보다 각 방향으로 제공되는 바이트 수만큼 점프 &lt;em&gt;하는 numBytes&lt;/em&gt; 가능한 메모리 세그먼트의 가정 된 크기이다. 한다면 &lt;em&gt;하는 numBytes이&lt;/em&gt; 0이고, 다음 상응 &lt;em&gt;하는 numBytes는&lt;/em&gt; 가정하에 계산 &lt;em&gt;ND&lt;/em&gt; , &lt;em&gt;희미&lt;/em&gt; 하고 &lt;em&gt;elsize은&lt;/em&gt; 단일 세그먼트 배열을 참조. &lt;a href=&quot;#c.NPY_TRUE&quot;&gt; &lt;code&gt;NPY_TRUE&lt;/code&gt; &lt;/a&gt; 있으면 &lt;em&gt;NPY_TRUE를&lt;/em&gt; 반환 합니다 &lt;em&gt;.&lt;/em&gt;허용되는 경우, 그렇지 않으면 &lt;a href=&quot;#c.NPY_FALSE&quot;&gt; &lt;code&gt;NPY_FALSE&lt;/code&gt; 를&lt;/a&gt; 리턴 하십시오 .</target>
        </trans-unit>
        <trans-unit id="da40e84ab5bf1317a201c92d2f871ba0d2269134" translate="yes" xml:space="preserve">
          <source>Determine if a class is a subclass of a second class.</source>
          <target state="translated">클래스가 두 번째 클래스의 서브 클래스인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="497b024471b22505be0452cda6ffd1b787cf7f0a" translate="yes" xml:space="preserve">
          <source>Determine if the first argument is a subclass of the second argument.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수의 서브 클래스인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="e06c23b59abd9e583829ad68cbb8b3a58d4c4624" translate="yes" xml:space="preserve">
          <source>Determine if two arrays might share memory</source>
          <target state="translated">두 배열이 메모리를 공유 할 수 있는지 확인</target>
        </trans-unit>
        <trans-unit id="13f31601af111fc0a9613647f0e8d82f16d06a6c" translate="yes" xml:space="preserve">
          <source>Determine if two arrays share memory</source>
          <target state="translated">두 배열이 메모리를 공유하는지 확인</target>
        </trans-unit>
        <trans-unit id="4fb1ffd013fbdd2899c42f65451c7410c495fa36" translate="yes" xml:space="preserve">
          <source>Determine whether input has masked values.</source>
          <target state="translated">입력 값에 마스크 값이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6da721475fcf2ac096aa56aec4327be0c131e55d" translate="yes" xml:space="preserve">
          <source>Determines the data-type of the returned array and of the accumulator where the elements are summed. If dtype has the value None and &lt;code&gt;a&lt;/code&gt; is of integer type of precision less than the default integer precision, then the default integer precision is used. Otherwise, the precision is the same as that of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열 및 요소가 합산되는 누산기의 데이터 유형을 결정합니다. dtype에 None 값이 있고 &lt;code&gt;a&lt;/code&gt; 가 기본 정수 정밀도보다 작은 정수 유형의 정밀도 인 경우 기본 정수 정밀도가 사용됩니다. 그렇지 않으면 정밀도는의 정밀도와 동일 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0165b0ce28795b6a5c6c8a8e2bfad91d293d9b" translate="yes" xml:space="preserve">
          <source>Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</source>
          <target state="translated">배열 데이터를 C (행 주요) 또는 FORTRAN (열 주요) 순서로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="62fef4817f86a662507fdd128bbc1b9cb8b3cd5a" translate="yes" xml:space="preserve">
          <source>Determines whether the given object represents a scalar data-type.</source>
          <target state="translated">주어진 객체가 스칼라 데이터 유형을 나타내는 지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5f0e0492ec52021d3c5b8cdeeb35e0f95d3b1d72" translate="yes" xml:space="preserve">
          <source>Determines whether the indices should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</source>
          <target state="translated">인덱스를 행 주요 (C 스타일) 또는 열 주요 (Fortran 스타일) 순서로 색인으로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d8ccfefbbecb3816295b6b2447f684f6ceabb4bd" translate="yes" xml:space="preserve">
          <source>Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</source>
          <target state="translated">다중 색인을 행 주요 (C 스타일) 또는 열 주요 (Fortran 스타일) 순서로 인덱싱으로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="66e7dd4c526a5148a42bbca5f07010c8a652ad99" translate="yes" xml:space="preserve">
          <source>Development versions (no git hash available): &amp;lsquo;1.8.0.dev-Unknown&amp;rsquo;</source>
          <target state="translated">개발 버전 (사용 가능한 git 해시 없음) : '1.8.0.dev-Unknown'</target>
        </trans-unit>
        <trans-unit id="d0fdf3b26f9c530f928d171827b0d01a3adcb222" translate="yes" xml:space="preserve">
          <source>Development versions after a1: &amp;lsquo;1.8.0a1.dev-f1234afa&amp;rsquo;,</source>
          <target state="translated">a1 이후 개발 버전 : '1.8.0a1.dev-f1234afa',</target>
        </trans-unit>
        <trans-unit id="5fcf12e6d8e4b52c92d8112af85cd4e8de564860" translate="yes" xml:space="preserve">
          <source>Development versions: &amp;lsquo;1.8.0.dev-f1234afa&amp;rsquo; (git commit hash appended)</source>
          <target state="translated">개발 버전 : '1.8.0.dev-f1234afa'(git commit hash가 추가됨)</target>
        </trans-unit>
        <trans-unit id="2587e018673361fa809647d0df3794abbf90b626" translate="yes" xml:space="preserve">
          <source>Diagnosing machine parameters.</source>
          <target state="translated">기계 매개 변수 진단.</target>
        </trans-unit>
        <trans-unit id="571a1b4f25ce9e3bf2b1d858d49e854688780a04" translate="yes" xml:space="preserve">
          <source>Diagonal above which to zero elements. &lt;code&gt;k = 0&lt;/code&gt; (the default) is the main diagonal, &lt;code&gt;k &amp;lt; 0&lt;/code&gt; is below it and &lt;code&gt;k &amp;gt; 0&lt;/code&gt; is above.</source>
          <target state="translated">요소 위의 대각선. &lt;code&gt;k = 0&lt;/code&gt; (기본값)이 주 대각선이고, &lt;code&gt;k &amp;lt; 0&lt;/code&gt; 이 그 아래에 있고 &lt;code&gt;k &amp;gt; 0&lt;/code&gt; 이 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="55837b5795b6970f83dccf9cc6ed178e395491c1" translate="yes" xml:space="preserve">
          <source>Diagonal covariance (&lt;code&gt;cov&lt;/code&gt; has non-negative elements, and only on the diagonal)</source>
          <target state="translated">대각선 공분산 ( &lt;code&gt;cov&lt;/code&gt; 는 음이 아닌 요소를 가지며 대각선에만 있음)</target>
        </trans-unit>
        <trans-unit id="997674fd629a0b4695b89afdafe7066dd8688712" translate="yes" xml:space="preserve">
          <source>Diagonal covariance means that points are oriented along x or y-axis:</source>
          <target state="translated">대각선 공분산은 점이 x 또는 y 축을 따라 정렬됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b13398d28ad559216c01627144dceb31c001c77" translate="yes" xml:space="preserve">
          <source>Diagonal in question. The default is 0. Use &lt;code&gt;k&amp;gt;0&lt;/code&gt; for diagonals above the main diagonal, and &lt;code&gt;k&amp;lt;0&lt;/code&gt; for diagonals below the main diagonal.</source>
          <target state="translated">문제의 대각선. 기본은 0입니다 . 주 대각선 위의 대각선 에는 &lt;code&gt;k&amp;gt;0&lt;/code&gt; 을 사용 하고 주 대각선 아래의 대각선에는 &lt;code&gt;k&amp;lt;0&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2272a7d3ef4499c2fba3286512459f06b9b8c4bb" translate="yes" xml:space="preserve">
          <source>Diagonal offset (see &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="translated">대각선 오프셋 (자세한 내용은 &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bdb7019564c135f875fc4c3e6f917c80e9b077c0" translate="yes" xml:space="preserve">
          <source>Diagonal offset (see &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="translated">대각선 오프셋 (자세한 내용은 &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="03d8dd8b377b7d9a317ab567d850a967ff187884" translate="yes" xml:space="preserve">
          <source>Diagonal to set; 0, the default, corresponds to the &amp;ldquo;main&amp;rdquo; diagonal, a positive (negative) &lt;code&gt;k&lt;/code&gt; giving the number of the diagonal above (below) the main.</source>
          <target state="translated">설정할 대각선; 기본값 인 0은 &quot;메인&quot;대각선에 해당하며 양 (음수) &lt;code&gt;k&lt;/code&gt; 는 메인 위 (아래)의 대각선 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b9cc7bface7de40b225d1e08bfd9974c80817b" translate="yes" xml:space="preserve">
          <source>Dictionary containing the information required to describe the state of the PRNG</source>
          <target state="translated">PRNG의 상태를 설명하는 데 필요한 정보가 포함 된 사전</target>
        </trans-unit>
        <trans-unit id="465ece096e63883c4adc1473d9e883a01beef81f" translate="yes" xml:space="preserve">
          <source>Dictionary containing the old settings.</source>
          <target state="translated">이전 설정이 포함 된 사전입니다.</target>
        </trans-unit>
        <trans-unit id="a302338cc77d36ca6ca6a444397d206bd6ba38d8" translate="yes" xml:space="preserve">
          <source>Dictionary of current print options with keys</source>
          <target state="translated">키가있는 현재 인쇄 옵션 사전</target>
        </trans-unit>
        <trans-unit id="9e2413069148ff06bfc90db576c632870eaad55e" translate="yes" xml:space="preserve">
          <source>Dictionary of named fields defined for this data type, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 데이터 유형 또는 정의라는 이름의 필드의 사전 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18fcf6662ee91bcc267021a433a9c47b4716fe9" translate="yes" xml:space="preserve">
          <source>Difference (subtraction) of two polynomials.</source>
          <target state="translated">두 다항식의 차이 (빼기).</target>
        </trans-unit>
        <trans-unit id="825117b1f5072a690e7d5d35fccadef88b068aef" translate="yes" xml:space="preserve">
          <source>Difference between sequence and scalars:</source>
          <target state="translated">시퀀스와 스칼라의 차이점 :</target>
        </trans-unit>
        <trans-unit id="44ae6a3aab38641659dd21a2dd5a0126482da74d" translate="yes" xml:space="preserve">
          <source>Differences Between 1.6 and 1.7 Datetimes</source>
          <target state="translated">1.6과 1.7 날짜 / 시간의 차이</target>
        </trans-unit>
        <trans-unit id="b75fd672a5cf256c07308370a04454e14a79f629" translate="yes" xml:space="preserve">
          <source>Differences with Array interface (Version 2)</source>
          <target state="translated">어레이 인터페이스 (버전 2)와의 차이점</target>
        </trans-unit>
        <trans-unit id="4300cd91f693489c6a5674ec8ec61a6dee25b189" translate="yes" xml:space="preserve">
          <source>Different &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; can share the same data, so that changes made in one &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; may be visible in another. That is, an ndarray can be a &lt;em&gt;&amp;ldquo;view&amp;rdquo;&lt;/em&gt; to another ndarray, and the data it is referring to is taken care of by the &lt;em&gt;&amp;ldquo;base&amp;rdquo;&lt;/em&gt; ndarray. ndarrays can also be views to memory owned by Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; or objects implementing the &lt;code&gt;buffer&lt;/code&gt; or &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;array&lt;/a&gt; interfaces.</source>
          <target state="translated">다른 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 는 동일한 데이터를 공유 할 수 있으므로 한 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 의&lt;/a&gt; 변경 사항이 다른 ndarray 에서 볼 수 있습니다. 즉, ndarray는 다른 ndarray에 대한 &lt;em&gt;&quot;보기&quot;&lt;/em&gt; 가 될 수 있으며 참조하는 데이터는 &lt;em&gt;&quot;기본&quot;&lt;/em&gt; ndarray 에 의해 처리됩니다. ndarray는 Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;strings&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;buffer&lt;/code&gt; 또는 &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;배열&lt;/a&gt; 인터페이스를 구현하는 객체가 소유 한 메모리에 대한 뷰일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d1293c185e75af6d69f6c98a33e894acc7589c9" translate="yes" xml:space="preserve">
          <source>Differentiate a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="8d839ccd2dfc63fbf3d7f72d0c5a816686c1455a" translate="yes" xml:space="preserve">
          <source>Differentiate a Hermite series.</source>
          <target state="translated">은자 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="350467ef2f75b4100fac9eb332f8dbf9310f3098" translate="yes" xml:space="preserve">
          <source>Differentiate a Hermite_e series.</source>
          <target state="translated">Hermite_e 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="7ecd2cf570222711a1cc1ae4380637a814f82362" translate="yes" xml:space="preserve">
          <source>Differentiate a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="320f56f9077471825e8d1549eab31dc00557c694" translate="yes" xml:space="preserve">
          <source>Differentiate a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="7bfc33e1228b29a88933a8f29aae49636b3414cf" translate="yes" xml:space="preserve">
          <source>Differentiate a polynomial.</source>
          <target state="translated">다항식을 미분하십시오.</target>
        </trans-unit>
        <trans-unit id="844fa0e757902457e0da48c9d9d537e645b1a135" translate="yes" xml:space="preserve">
          <source>Differentiate.</source>
          <target state="translated">Differentiate.</target>
        </trans-unit>
        <trans-unit id="5fbe5e498b5af2c25aac251fb6bb0a2c7a4ee208" translate="yes" xml:space="preserve">
          <source>Dimension Index</source>
          <target state="translated">차원 색인</target>
        </trans-unit>
        <trans-unit id="604ffcf9d27fb4fb0162fdca0045216d08973bc5" translate="yes" xml:space="preserve">
          <source>Dimension Name</source>
          <target state="translated">차원 이름</target>
        </trans-unit>
        <trans-unit id="16b40f0ccd35ed9bc1f597c1b6ca359ab12da9c4" translate="yes" xml:space="preserve">
          <source>Dimension indices in a flattened form; indices of argument &lt;code&gt;k&lt;/code&gt; are stored in &lt;code&gt;core_dim_ixs[core_offsets[k] : core_offsets[k] +
core_numdims[k]]&lt;/code&gt;</source>
          <target state="translated">평평한 형태의 치수 지수; 인수 &lt;code&gt;k&lt;/code&gt; 의 인덱스는 &lt;code&gt;core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]&lt;/code&gt; 저장됩니다 : core_offsets [k] + core_numdims [k]]</target>
        </trans-unit>
        <trans-unit id="4720f96f0dc9b13a80d3150f6ee99efe7a2bf618" translate="yes" xml:space="preserve">
          <source>Dimension lists for different arguments are separated by &lt;code&gt;&quot;,&quot;&lt;/code&gt;. Input/output arguments are separated by &lt;code&gt;&quot;-&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">다른 인수에 대한 차원 목록은 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 로 구분됩니다 . 입력 / 출력 인수는 &lt;code&gt;&quot;-&amp;gt;&quot;&lt;/code&gt; 로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="37cc6b0f7bb3682386878d1b4327551ac2b2f9c6" translate="yes" xml:space="preserve">
          <source>Discrete Fourier Transform (&lt;code&gt;numpy.fft&lt;/code&gt;)</source>
          <target state="translated">이산 푸리에 변환 ( &lt;code&gt;numpy.fft&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0599eda60b4e9fea359c989e15306fa6ba42641a" translate="yes" xml:space="preserve">
          <source>Discrete Fourier Transform (numpy.fft)</source>
          <target state="translated">이산 푸리에 변환 (numpy.fft)</target>
        </trans-unit>
        <trans-unit id="7e09c6be62e60a24d79a9a2519a544283d5d6191" translate="yes" xml:space="preserve">
          <source>Discrete cross-correlation of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 이산 상호 상관 .</target>
        </trans-unit>
        <trans-unit id="e53e1928d52ad6e33b46c1b8035d3e51b89bc405" translate="yes" xml:space="preserve">
          <source>Discrete fourier transform</source>
          <target state="translated">이산 푸리에 변환</target>
        </trans-unit>
        <trans-unit id="d506f48e956cd0fc595f2d760c2568b2ecab8f30" translate="yes" xml:space="preserve">
          <source>Discrete uniform distribution over the closed interval &lt;code&gt;[low, high]&lt;/code&gt;.</source>
          <target state="translated">닫힌 간격에 대한 불연속 균일 분포 &lt;code&gt;[low, high]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581725b9ae0b1aa5fab3c6862adf5b089aedf3b7" translate="yes" xml:space="preserve">
          <source>Discrete uniform distribution, yielding integers.</source>
          <target state="translated">불연속 균일 분포로 정수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e9cbd8c39929bc0b483e8db9cb22ad66356f9dd1" translate="yes" xml:space="preserve">
          <source>Discrete, linear convolution of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 불연속 선형 컨벌루션 .</target>
        </trans-unit>
        <trans-unit id="2f1bd27e525549ac4c15b3721fa99d1b05468878" translate="yes" xml:space="preserve">
          <source>Discrete, linear convolution of two one-dimensional sequences.</source>
          <target state="translated">두 개의 1 차원 시퀀스의 불연속 선형 컨벌루션.</target>
        </trans-unit>
        <trans-unit id="820f5171bb026c33497c51bf6408edd94f4c7574" translate="yes" xml:space="preserve">
          <source>Dispersion of the distribution, has to be &amp;gt;=0.</source>
          <target state="translated">분포의 분산은&amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b40bb754403d167b3c047ebbae91fd8d8cb0914f" translate="yes" xml:space="preserve">
          <source>Display histogram of the sample:</source>
          <target state="translated">샘플의 히스토그램을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="188801f0d5b3d1b7349810d9fd7ff8a72e496879" translate="yes" xml:space="preserve">
          <source>Display results as a histogram:</source>
          <target state="translated">히스토그램으로 결과 표시 :</target>
        </trans-unit>
        <trans-unit id="8a9edcfc295cbbba0c31cafd95aee17d95c83756" translate="yes" xml:space="preserve">
          <source>Display the histogram of the samples, along with the probability density function:</source>
          <target state="translated">확률 밀도 함수와 함께 샘플의 히스토그램을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e318b4b3e84c3dbcd35ba51c8d38616480afa39" translate="yes" xml:space="preserve">
          <source>Display the order (the leading zero-coefficients are removed):</source>
          <target state="translated">순서를 표시합니다 (선행 제로 계수가 제거됨).</target>
        </trans-unit>
        <trans-unit id="1d3c457cbe3e35739086346e0a4048653efa42e7" translate="yes" xml:space="preserve">
          <source>Distribution</source>
          <target state="translated">Distribution</target>
        </trans-unit>
        <trans-unit id="1908a0e50cf9cf44d92392e9f5f89a3166d12095" translate="yes" xml:space="preserve">
          <source>Distribution mean, must be &amp;gt; 0.</source>
          <target state="translated">분포 평균은&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="955961355de913bb9e7fa3e948b32a11d7c7c64d" translate="yes" xml:space="preserve">
          <source>Distribution parameter. Must be greater than 1.</source>
          <target state="translated">분포 모수. 1보다 커야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
