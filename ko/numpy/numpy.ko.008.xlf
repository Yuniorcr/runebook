<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">비 연속적 뷰 대신 연속적인 사본을 얻는 데 유용한 관용구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">다음은 &quot;lambda&quot;ufunc처럼 작동하는 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">외부 제품 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">위의 변수가 사용되는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">샘플 배열과 함께 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">파이썬 반복자 프로토콜을 사용하여 &lt;code&gt;iter_add&lt;/code&gt; 함수를 작성하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">다음은 동일한 기능이지만 C 스타일 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">sum_squares.pyx의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">여기서는 내장 열거 반복자를 사용하여 반복 인덱스와 값을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">여기서 U는 (0,1]에 대한 균일 분포에서 도출됩니다.</target>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">은자 반</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; 모듈, &quot;물리학 자&quot;( numpy.polynomial.hermite )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 은자 계수 는 &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">은자 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">은자 시리즈</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">적분의 은자 (Hermite) 계열 계수.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">은자 시리즈의 힘.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">파생 품의 은자 시리즈.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Hermite 시리즈.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">은둔 무게 기능</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">은자 클래스</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 HermiteE 계수 는 &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">HermiteE 시리즈</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">은자 무게 기능.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">적분의 Hermite_e 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Hermitian (모든 요소가 실제 인 경우 대칭), 양의 한정된 입력 행렬.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">은둔자 FFT</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">고유 값과 고유 벡터를 계산할 수있는 은자 또는 실제 대칭 행렬.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">고차 다항식이 크게 진동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">더 큰 치수</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">하라 모토 히로시, 마츠모토 마코 모토, 니시무라 타쿠 지, 프랑수아 판네, 피에르 레쿠 에르,&amp;ldquo;F2 선형 난수 생성기를위한 효율적인 점프 어드바이스&amp;rdquo;, JOURNAL ON COMPUTING, Vol. 20, No. 3, 2008 년 여름, pp. 385-390.</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">호너 스킴 &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다항식을 평가하는 데 사용됩니다. 그럼에도 불구하고 높은 다항식의 경우 반올림 오류로 인해 값이 정확하지 않을 수 있습니다. 신중하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">차원의 끝에서 시작으로 다시 이동하는 데 필요한 바이트 수 참고 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; 있지만,이 최적화 여기에 저장된다.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">한 번의 실행 후 몇 번의 시도가 성공 했습니까?</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">유효하지 않은 날짜를 처리하는 방법 기본값은 '올림'입니다.</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 레벨에서 배열 반복자를 사용하는 방법은 이후 섹션에서 자세히 설명합니다. 일반적으로 반복자 객체의 내부 구조에 신경 쓸 필요가 없으며 매크로 &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) 또는 &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index) 매크로를 사용하여 상호 작용할 필요가 없습니다 . 이 매크로는 모두 인수 필요 &lt;em&gt;가&lt;/em&gt; 될 &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">그러나 배열 스칼라는 변경할 수 없으므로 배열 스칼라 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">그러나 2D 배열의 경우 &lt;code&gt;tolist&lt;/code&gt; 는 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">그러나 단계 길이가 &lt;strong&gt;복소수&lt;/strong&gt; (예 : 5j) 인 경우, 그 크기의 정수 부분은 시작 값과 중지 값 사이에 작성할 포인트 수를 지정하는 것으로 해석되며 여기서 중지 값 &lt;strong&gt;은 포함&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180에서 해결할&lt;/a&gt; 수있는 필터 메커니즘도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">그러나 위의 인덱싱 배열은 자체 반복되므로 브로드 캐스트를 사용하여 ( &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; 와 같은 작업 비교 )이를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">그러나이 클래스는 직접 실행되지 않습니다. 오히려 여러 다른 파이썬 클래스에 대한 기본 클래스로 사용되며 각각은 특정 데이터 유형에 고유합니다. &lt;code&gt;VectorTestCase&lt;/code&gt; 의 클래스를 저장 입력 정보에 대한 두 개의 문자열 :</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">Bronshtein, KA Semendyayev 및 KA Hirsch (Eng. trans. Ed.), 뉴욕 &lt;em&gt;핸드북 수학&lt;/em&gt; , Van Nostrand Reinhold Co., 1985, pg. 720.</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">(양의) 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">NaN (Not a Number)의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">음의 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">음수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">양수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC 표준 9899 : 1999,&amp;ldquo;프로그래밍 언어 C&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">'왼쪽'이면 발견 된 첫 번째 적합한 위치의 색인이 제공됩니다. '오른쪽'이면 마지막 인덱스를 반환하십시오. 어떠한 적절한 인덱스가없는 경우 (N은의 길이 0 또는 N 리턴 &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">'out'이 None (기본값)이면 초기화되지 않은 반환 배열이 만들어집니다. 그런 다음 출력 배열은 브로드 캐스트 'where'가 True 인 위치에서 ufunc의 결과로 채워집니다. 'where'가 스칼라 True (기본값)이면 채워지는 전체 출력에 해당합니다. 명시 적으로 채워지지 않은 출력은 초기화되지 않은 값으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">/ NULL 값을 전달하는 경우 -1 &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; 및 &lt;code&gt;buffersize&lt;/code&gt; , 그것은 동등 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 여부에 관계없이의 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 이&lt;/a&gt; 되면, C-API는 선언한다 &lt;code&gt;extern void**&lt;/code&gt; 가 다른 컴파일 단위에서 정의 될 것으로 예상된다, 그래서.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; 이&lt;/a&gt; 불렀다, 당신은 플래그를 활성화 할 수 있습니다 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 을&lt;/a&gt; . 이 플래그는 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 허용되지 않으므로이 함수는 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 기능을 사용하도록 제공됩니다 . 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 있지만 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 이&lt;/a&gt; 아니다는 C-API는 선언한다 &lt;code&gt;void**&lt;/code&gt; 가 다른 컴파일 단위로 표시됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 설정되어 DTYPE이 일치하지 않는 경우, 배열은 복사 :</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 가 1 차원이 아닌 경우 출력에도이 차원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">하면 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 문자열이고, 그것이 콤마 컬럼 분리 공간 행 분리 세미콜론 매트릭스로 해석된다.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">경우에 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 이미 인 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ,이 플래그는 데이터가 (기본)에 복사할지 여부를 결정하거나, 뷰가 구성되어 있는지.</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , &lt;code&gt;reps&lt;/code&gt; 승격된다 그것의 1 사전이 출원하여 .ndim. 따라서 (2, 3, 4, 5) 모양 의 &lt;code&gt;A&lt;/code&gt; 에 대해 (2, 2) 의 &lt;code&gt;reps&lt;/code&gt; 은 (1, 1, 2, 2)로 처리됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 를 D 차원 새로운 축을 붙이는 것으로 의해 촉진된다. 따라서 2D 복제의 경우 모양 (3,) 배열이 (1, 3)으로, 3D 복제의 경우 모양 (1, 1, 3)으로 승격됩니다. 이것이 원하는 동작이 아닌 경우이 함수를 호출하기 전에 &lt;code&gt;A&lt;/code&gt; 를 d 차원으로 수동 승격 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">경우 &lt;code&gt;False&lt;/code&gt; , 결과는 각 빈에있는 샘플의 수를 포함합니다. 경우 &lt;code&gt;True&lt;/code&gt; , 결과 확률의 값 &lt;em&gt;밀도&lt;/em&gt; 되도록 정규화 빈의 함수, &lt;em&gt;적분&lt;/em&gt; 범위에서 히스토그램 값들의 합이 1과 같지 않을 것이다 1 주되어 선택된다 폭 화합의 빈들 않는; 확률 &lt;em&gt;질량&lt;/em&gt; 함수 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">경우 &lt;code&gt;None&lt;/code&gt; (기본값)은 모든 상수 가정하지 않습니다 제로가 될 수 있습니다. &lt;code&gt;m = 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; , 스왑이 자리에서 바이트, 기본값은 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 자릿수는 소수점 이하 자릿수 (앞의 0 포함)를 나타냅니다. &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 는 소수점 앞뒤의 유효 유효 자릿수 (제로 0을 무시)의 총 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; 후 출력하는 경우의 수를 결정하는 제 1 함수 호출 캐시 &lt;code&gt;otypes&lt;/code&gt; 이 설치되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 필요한 모든 숫자를 인쇄하십시오. 그렇지 않으면 &lt;code&gt;precision&lt;/code&gt; 숫자 후에 숫자 생성이 잘리고 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 필요한 모든 자릿수를 인쇄하십시오. 그렇지 않으면 &lt;code&gt;precision&lt;/code&gt; 자릿수 다음에 자릿수가 생성 되고 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">경우 &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; 채우기 값을 반환, 그렇지 않으면 None을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 다음에 의해 지정된 차원 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거되고, 새로운 축은 대각선에 대응하는 단부에 삽입 하였다.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim&lt;/code&gt; 가 0이고, 중첩 된 목록의 깊이가 0 그 이후, 모든의 목록,하지만 간단한 파이썬 스칼라되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">경우 &lt;code&gt;a.shape&lt;/code&gt; 는 (5,1)이다 &lt;code&gt;b.shape&lt;/code&gt; 가 있다 (1,6), &lt;code&gt;c.shape&lt;/code&gt; 는 (6)이고 &lt;code&gt;d.shape&lt;/code&gt; 는 그 () 그렇다 &lt;em&gt;D는&lt;/em&gt; 다음 스칼라 , &lt;em&gt;B&lt;/em&gt; , &lt;em&gt;C&lt;/em&gt; , 및 &lt;em&gt;D는&lt;/em&gt; 치수 (5,6)에 대한 모든 캐스트 가능한이고; 과&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 스칼라가 아닌 경우 마지막 차원이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 각각의 선택 배열이 모두 같은 모양으로 브로드 캐스트되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 자신의 데이터 또는 참조 또는 그것에 전망을 보유하고 있지 않습니다 존재하고, 데이터 메모리 변경해야합니다. PyPy 만 해당 : 데이터 메모리에 대한 참조 또는보기가 존재하는지 판별 할 수있는 확실한 방법이 없으므로 데이터 메모리를 변경해야하는 경우 항상 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 두 개 이상의 차원이에 설명 된대로 다음 방송 규칙이 적용 &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;번에 여러 행렬에 선형 대수학&lt;/a&gt; . 이는 SVD가 &quot;스택&quot;모드에서 작동한다는 것을 의미합니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원 의 모든 인덱스를 반복하며 각 조합에 대해 SVD는 마지막 두 인덱스에 적용됩니다. 행렬 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; 또는 &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; 를 사용하여 분해에서 재구성 할 수 있습니다 . 합니다 ( &lt;code&gt;@&lt;/code&gt; 의 연산자는 함수로 대체 될 수 &lt;code&gt;np.matmul&lt;/code&gt; 3.5 이하 파이썬 버전).</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 차원이 두 개 이상인 경우 axis1 및 axis2로 지정된 축을 사용하여 트레이스가 반환되는 2 차원 하위 ​​배열을 결정합니다. 생성 된 어레이의 형상은 동일하다 와 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1-D의 함수이다 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; 것과 동일하다 &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; 여기서, &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 되는 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 제로와마다 배치 다른 요소 : &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선의 반환 &lt;code&gt;a&lt;/code&gt; 오프셋으로 주어진, 즉, 폼 요소들의 집합 &lt;code&gt;a[i, i+offset]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 의 차원이 두 개 이상인 경우 &lt;code&gt;axis1&lt;/code&gt; 및 &lt;code&gt;axis2&lt;/code&gt; 로 지정된 축은 대각선이 반환되는 2 차원 하위 ​​배열을 결정하는 데 사용됩니다. 결과 배열의 모양은 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 를 제거 하고 결과 대각선의 크기와 동일한 오른쪽에 인덱스를 추가하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1, 리턴 오프셋은 주어진 요소의 합 즉, 2-D, 그 대각선을 따라 합 &lt;code&gt;a[i,i+offset]&lt;/code&gt; 모든 I에 대해.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선을 따라 합이 반환된다. 경우 &lt;code&gt;a&lt;/code&gt; 큰 크기를 가지며, 사선을 따라 합계 다음 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 다음 2-D는 대각선을 함유하는 1-D 배열이다 동일한 유형의 &lt;code&gt;a&lt;/code&gt; 않는 리턴 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 1-D 어레이보다는 (2-D)이 경우에, &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 리턴 이전 버전과의 호환성을 유지하기 위해.</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;matrix&lt;/code&gt; 객체 (AN 반대로 &lt;code&gt;ndarray&lt;/code&gt; )하고 있으므로 모든 리턴 값이다.</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 의 하위 클래스 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 그 클래스는 보존된다. 입력이 이미 &lt;code&gt;ndarray&lt;/code&gt; 이면 복사가 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이, 그것의 마지막 축 위에 합 제품 및 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; (여기서 멀티 디스크 배열 &lt;code&gt;M&amp;gt;=2&lt;/code&gt; )가 마지막 축 위에 합 제품 및 마지막에서 두 번째 축 &lt;code&gt;b&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 복잡 켤레 복소수는 내적을 계산하기 전에 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 하지 않은 것입니다 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 자체가 반환됩니다. 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;fill_value&lt;/code&gt; 를가 없음입니다, &lt;code&gt;fill_value&lt;/code&gt; 를가 로 설정되어 &lt;code&gt;a.fill_value&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 사각형이 나 반전에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 진짜, 유형 &lt;code&gt;a&lt;/code&gt; 출력에 사용됩니다. 경우 &lt;code&gt;a&lt;/code&gt; 복잡한 요소를 가지고, 반환 타입은 부동이다.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 '사각형'이 아닌 경우 (위의 의미에서).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 정사각형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 모양 속성이없는 경우 (즉, ndarray가 아님)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 0 만 행이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 1 또는 -1 열만이 마스크된다.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 없음입니다, 행 &lt;em&gt;과&lt;/em&gt; 열이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 정수이고, 그것의 축 지정 &lt;code&gt;x&lt;/code&gt; 벡터 기준을 계산을 따라. 경우 &lt;code&gt;axis&lt;/code&gt; 2- 튜플, 그것은 2-D 행렬을 길게 축을 지정하고, 이들 매트릭스의 매트릭스 기준이 계산된다. 경우 &lt;code&gt;axis&lt;/code&gt; 중에 어느 한 다음 벡터 놈 없다 (경우 &lt;code&gt;x&lt;/code&gt; 1-D이다) 또는 매트릭스 표준은 (경우 &lt;code&gt;x&lt;/code&gt; 2-D이다)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 주어, 가변 인자의 수는 축의 수와 같아야한다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 의 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 및 압착되는 축 길이가 1이 아닌</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 행렬이고, 모든 배열 행렬 결과로서 리턴된다.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 이 아래 목록의 문자열 인 경우 &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; 는 선택한 방법을 사용하여 최적의 bin 너비와 결과적으로 요청 된 범위 내에있는 데이터에서 bin 수 ( 추정자에 대한 자세한 내용 은 &lt;code&gt;Notes&lt;/code&gt; 참조 )를 계산합니다. 구간 폭은 범위 내 실제 데이터에 최적이지만 구간 수는 빈 부분을 포함하여 전체 범위를 채우도록 계산됩니다. 시각화를 위해 '자동'옵션을 사용하는 것이 좋습니다. 자동 출력 함 크기 선택에는 가중치 데이터가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 문자열이고, 그것이 의해 정의 된 최적 빈의 폭을 계산하기 위해 사용되는 방법을 정의 &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스는, 그 불균일 함을 허용 폭의 우측 에지를 포함 함 가장자리 일정하게 증가하는 배열을 정의한다.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스이며, 그 불균일 함을 허용 폭의 우측 가장자리를 포함하는 빈 에지를 정의한다.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 단조롭지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 없음, 만없는 &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;order&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 버퍼 인터페이스를 노출하는 객체입니다, 모든 키워드는 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">경우 &lt;code&gt;buffersize&lt;/code&gt; 제로, 크기 버퍼 기본 그렇지 않으면 사용에 대한 버퍼의 얼마나 큰 지정, 사용됩니다. 4096 또는 8192와 같이 2의 거듭 제곱 버퍼가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 미만 3 차원이, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 세 개 미만의 크기를 가지고, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape + y.shape + z.shape입니다.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape + y.shape입니다.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 하나의 암시는 2-D 있도록 그 형상에 부가 된 1-D 배열이다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermeval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 많은 HermiteE 시리즈의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Hermite 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;lagval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Laguerre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = legvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;legval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Legendre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;chebval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도 및 샘플 포인트의 많은 체비 쇼프 시리즈의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;polyval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도의 많은 수의 다항식 및 샘플 포인트의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;c&lt;/code&gt; 다차원이고, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor&lt;/code&gt; + x.shape : 참 형상 c.shape [1]가 될 것이다. 경우 &lt;code&gt;tensor&lt;/code&gt; 거짓 형상 c.shape [1]가 될 것이다. 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 부울 인 경우 :</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 제공되며,이 배열의 삶을 위해 살아 남기해야합니다. 이를 관리하는 한 가지 방법은 &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; 를 사용하는 것입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 해당 데이터 유형이 필요합니다. 복사가 허용되면 데이터를 캐스트 할 수있는 경우 임시 복사를합니다. 경우 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 그것은 또한 반복자 파괴에 따라 다른 캐스트와 데이터 등을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">경우 &lt;code&gt;enddates&lt;/code&gt; 의 지정 대응보다 이전 날짜 값 &lt;code&gt;begindates&lt;/code&gt; 의 날짜 값, 카운트는 제외 할 것이다.</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 가 정렬 정수 1-D 어레이이며, 항목이 함께 위치를 나타내는 &lt;code&gt;axis&lt;/code&gt; 배열이 분리된다. 예를 들어 &lt;code&gt;[2, 3]&lt;/code&gt; 은 &lt;code&gt;axis=0&lt;/code&gt; 의 경우</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수 N 인 배열을 따라 N 동일한 배열로 분할 될 &lt;code&gt;axis&lt;/code&gt; . 그러한 분할이 불가능하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수로 주어되지만 분할 동등한 분할을 초래하지 않는다.</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">경우 &lt;code&gt;legacy&lt;/code&gt; 거짓이다, 또는 BitGenerator이 NT19937되어 있지 않은 경우, 상태는 사전로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 과 &lt;code&gt;m2&lt;/code&gt; 에 다른 유연한 dtype이있는 경우</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 에 단일 열이 있으면 해당 열이 행렬의 단일 행으로 반환됩니다. 그렇지 않으면 &lt;code&gt;m&lt;/code&gt; 이 반환됩니다. 반환 된 매트릭스는 항상 하나입니다 &lt;code&gt;m&lt;/code&gt; 자체 또는로보기 &lt;code&gt;m&lt;/code&gt; . 축 키워드 인수를 제공하면 반환 된 행렬에 영향을 미치지 않지만 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">&lt;code&gt;maxsplit&lt;/code&gt; 이 제공 되면 최대 &lt;code&gt;maxsplit&lt;/code&gt; 분할이 수행됩니다 (가장 오른쪽).</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">경우 &lt;code&gt;maxsplit&lt;/code&gt; 이 주어진에서 가장 &lt;code&gt;maxsplit&lt;/code&gt; 의 분할이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 짝수이고, &lt;code&gt;A[-1]&lt;/code&gt; 양극과 음극 나이키 스트 주파수 (FS + / 2, -fs / 2) 모두를 표현하는 용어를 포함하고, 또한 실제 순수해야한다. 경우 &lt;code&gt;n&lt;/code&gt; 이 홀수, FS / 2에서 어떤 용어는 없다; &lt;code&gt;A[-1]&lt;/code&gt; 은 가장 큰 양의 주파수 (fs / 2 * (n-1) / n)를 포함하며 일반적인 경우에는 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;names&lt;/code&gt; True 인, 필드 이름은 첫 번째 후 첫 번째 줄에서 읽 &lt;code&gt;skip_header&lt;/code&gt; 의 라인. 이 행은 선택적으로 주석 분리 문자로 진행될 수 있습니다. 경우 &lt;code&gt;names&lt;/code&gt; 순서 또는 쉼표로 구분 명칭의 단일 스트링이고, 이름은 구성 DTYPE에 필드 명을 정의하는 데 사용된다. 경우 &lt;code&gt;names&lt;/code&gt; 없음입니다 (있는 경우) DTYPE 필드의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 에서 데이터를 복사하려고 시도하지 않습니다 . &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; 를&lt;/a&gt; 실행 취소 합니다 . 일반적으로 이것은 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 끝나면 오류 후에 호출됩니다 . 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. 그런 다음 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; 를 &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; 로 복사하고 복사 작업의 오류 상태를 리턴합니다. 이것은 &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; 와 반대입니다 . 일반적으로 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 완료하면 호출 됩니다. 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 . &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 참조.</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; 요소로 채워진 1 차원 어레이 반환 &lt;em&gt;X&lt;/em&gt; 에 대응하는 &lt;code&gt;True&lt;/code&gt; 값 &lt;em&gt;OBJ를&lt;/em&gt; . 검색 순서는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt; , C 스타일입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 의 경계 외부에있는 항목에 값을 &lt;em&gt;X&lt;/em&gt; , 다음 인덱스 오류가 발생합니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 보다 작은 &lt;em&gt;X&lt;/em&gt; 는 그것을 채우는 동일 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 적합한 숫자 유형이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; 에&lt;/a&gt; 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 Py_NotImplemented에 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다. 이 버전에서는 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 속성 을 찾는 배열 인터페이스 부분에서 유형과 컨텍스트를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">경우 &lt;code&gt;op&lt;/code&gt; 이미 (C 식)이며, 인접 단지 참조를 반환 한 후 잘 행동 그렇지는 (연속 및 품행) 배열의 카피 반환. op 매개 변수는 ndarray의 (하위 클래스)이어야하며 이에 대한 점검은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;op_dtypes&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 각 &lt;code&gt;op[i]&lt;/code&gt; 에 대해 데이터 유형 또는 &lt;code&gt;NULL&lt;/code&gt; 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">경우 &lt;code&gt;otypes&lt;/code&gt; 가 지정되어 있지 않은 경우, 상기 제 인수 함수 호출은 출력의 개수를 결정하는 데 사용된다. 이 호출의 결과 는 함수가 두 번 호출되지 않도록 &lt;code&gt;cache&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 캐시 됩니다. 그러나 캐시를 구현하려면 원래 함수를 래핑해야 후속 호출 속도가 느려질 수 있으므로 함수가 비싼 경우에만 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 분산을 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 제공되며,이 함수에 그 결과를 기록하고 참조 반환 &lt;code&gt;out&lt;/code&gt; . (실시 예 참조)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다. NaN 만 포함 된 슬라이스에 대해서는 Nan이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 분산을 포함하는 새 배열을 반환합니다. 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">경우에 &lt;code&gt;output&lt;/code&gt; 한 후 공급되지 소스 코드가 화면 (sys.stdout)에 출력된다. 파일 개체는 쓰기 'w'또는 추가 'a'모드로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 길이 N이며,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 리턴 시리즈는 다음 &lt;code&gt;p(x) == x&lt;/code&gt; X의 모든 값에 대해.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이, 그것은, 다운로드에 저장 될 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리와 거기에서 열었다.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이며, 다음 &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; 돌아갑니다 어느 위치에 파일을 로컬에 존재하거나 사용하여 열 때 위치가 존재 것이다 &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 백분위 수가 여러 개인 경우 결과의 첫 번째 축은 백분위 수에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 분위수이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 은 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;r&lt;/code&gt; 다차원, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor is ``True`&lt;/code&gt; 형상 r.shape [1] + x.shape 것; 즉, 각 다항식은 모든 &lt;code&gt;x&lt;/code&gt; 값에서 평가됩니다 . 경우 &lt;code&gt;tensor&lt;/code&gt; 인 &lt;code&gt;False&lt;/code&gt; , 형상 r.shape [1]가 될 것이다; 즉, 각 다항식은 해당 브로드 캐스트 값 &lt;code&gt;x&lt;/code&gt; 에 대해서만 평가됩니다 . 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 길이 인 &lt;code&gt;N&lt;/code&gt; ,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">경우 &lt;code&gt;rep&lt;/code&gt; 스칼라 DTYPE의 인스턴스, 사실이 반환됩니다. 그렇지 않으면 False가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">경우에는 &lt;code&gt;reps&lt;/code&gt; 길이 갖는 &lt;code&gt;d&lt;/code&gt; , 결과의 치수 것이다 &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">경우 &lt;code&gt;rowvar&lt;/code&gt; 이 참 (기본값), 각 행은 열에서 관측 변수를 나타냅니다. 그렇지 않으면 관계가 바뀝니다. 각 열은 변수를 나타내며 행에는 관측치가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 서로 다른 길이, 또는이 &lt;code&gt;axes&lt;/code&gt; 하지 주어 &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 길이가 다른 경우</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">&lt;code&gt;sctype&lt;/code&gt; 이 유형을 유추 할 수없는 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">만약 &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 다음 법적 인덱스에 대한 &lt;code&gt;index[k] == 0&lt;/code&gt; . 이것은 오프셋 공식에서</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수가 아닌 경우 &lt;code&gt;ret&lt;/code&gt; 은 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; 모두 &lt;code&gt;True&lt;/code&gt; 를 반환하도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수 인 경우 .</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되거나되지 않은 &lt;code&gt;None&lt;/code&gt; , 공백 문자열 세퍼레이터이다.</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;shape&lt;/code&gt; 길이를 갖는 하나의 예 &lt;code&gt;(N,)&lt;/code&gt; , 또는 스칼라 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; 형상의 단일 행 행렬이된다 &lt;code&gt;(1,N)&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">&lt;code&gt;tol&lt;/code&gt; &amp;lt;0 인 경우</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 2-D 어레이, 그 사본 반환 &lt;code&gt;k&lt;/code&gt; 번째 대각선. 경우 &lt;code&gt;v&lt;/code&gt; 1-D 어레이는 함께 2-D 배열을 반환 &lt;code&gt;v&lt;/code&gt; 상의 &lt;code&gt;k&lt;/code&gt; 번째 대각.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 보다 긴 , 배열은 계산하기 전에 교체된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 같은 크기되지 및 &lt;code&gt;mask&lt;/code&gt; 그것은 반복됩니다. 이것은 &lt;code&gt;a[mask] = values&lt;/code&gt; 와 다른 동작을 제공 합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복된다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x2&lt;/code&gt; 스칼라, 그 기호의 모든 요소에 복사됩니다 &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;r&lt;/code&gt; 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 다차원 어레이이며, 이는 단지 첫 번째 인덱스에 따라 셔플 링된다.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; poly1d 인스턴스이며, 그 결과는 두 다항식의 조성, 즉,이고 &lt;code&gt;x&lt;/code&gt; 에 &quot;치환&quot;되는 &lt;code&gt;p&lt;/code&gt; 및 단순화 된 결과가 복귀된다. 또한 &lt;code&gt;x&lt;/code&gt; -array_like 또는 poly1d 유형은 출력 유형을 제어합니다. &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; poly1d 객체 =&amp;gt; &lt;code&gt;values&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 연속하고있다 &lt;code&gt;p(x)&lt;/code&gt; 의 각 요소에 대해 리턴되는 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 다음 다른 다항식 복합 다항식 &lt;code&gt;p(x(t))&lt;/code&gt; 복귀된다.</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 의 하위 유형입니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 반환 값은 같은 유형이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 정수이고, 임의로 변경하다 &lt;code&gt;np.arange(x)&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 배열 인, 복사본을 만들고 무작위 요소를 섞는다.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 부정확 NaN이 제로에 의해 또는 사용자 정의 된 값으로 대체 &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; 키워드 무한대 부동 소수점 값으로 표현 가능한 최대 유한으로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 사용자 정의 값 &lt;code&gt;posinf&lt;/code&gt; 키워드 무한대가로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 &lt;code&gt;neginf&lt;/code&gt; 키워드 의 사용자 정의 값으로 표시 할 수있는 가장 음의 유한 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 정확하지 않습니다, 다음에는 교체가 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 부호있는 정수 타입이다, 출력 유형은 기본 플랫폼의 정수입니다 :</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;xp&lt;/code&gt; 및 &lt;code&gt;fp&lt;/code&gt; 상이한 길이를 갖는 경우 &lt;code&gt;xp&lt;/code&gt; 또는 &lt;code&gt;fp&lt;/code&gt; 1-D의 순서가 아닌 경우 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">경우 &lt;em&gt;도착을&lt;/em&gt; 배열하고, 그 데이터 형식 디스크립터를 반환하지만 경우 &lt;em&gt;도착은&lt;/em&gt; (0 차원을 갖는다) 배열 스칼라이고,이 값은 정수 오버플로 또는 절단없이 전환 될 수도있는 가장 작은 크기의 데이터 유형을 발견한다.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">경우 &lt;em&gt;축이&lt;/em&gt; 없는 &lt;em&gt;없음&lt;/em&gt; (디폴트), 어레이는 1-D 어레이로 처리하고, 동작은 전체 어레이에 걸쳐 수행된다. self가 0 차원 배열 또는 배열 스칼라 인 경우에도이 동작이 기본값입니다. 배열 스칼라는 float32, float64 등의 유형 / 클래스의 인스턴스이고 0 차원 배열은 정확히 하나의 배열 스칼라를 포함하는 ndarray 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">경우 &lt;em&gt;축&lt;/em&gt; 정수이고, 그 동작은 (소정의 축선을 따라 생성 될 수있는 각각의 1-D 서브 어레이에 대한) 주어진 축상에서 이루어진다.</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 , 새로운 단위 화 메모리가 할당되고 , 포트란 스타일의 연속 배열을 나타 내기 위해 &lt;em&gt;플래그&lt;/em&gt; 가 0이 아닌 값이 될 수 있습니다. &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; 를 사용 하여 메모리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 배열에 사용될 메모리를 가리키는 것으로 가정하고 &lt;em&gt;flags&lt;/em&gt; 인수는 배열의 새 플래그로 사용됩니다 ( &lt;code&gt;NPY_OWNDATA&lt;/code&gt; 상태 , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 새 배열의 &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그 제외) 재설정).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">경우 &lt;em&gt;DESCR이&lt;/em&gt; NULL 인의 데이터 타입 &lt;em&gt;프로토 타입을&lt;/em&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">경우 &lt;em&gt;DTYPE이&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; 을 , 다음 반환되는 배열은 같은 데이터 유형 것 &lt;em&gt;자체&lt;/em&gt; . 새로운 데이터 유형은 &lt;em&gt;self&lt;/em&gt; 의 크기와 일치해야합니다 . 항목 크기는 동일하거나 &lt;em&gt;self&lt;/em&gt; 는 단일 세그먼트 여야하고 총 바이트 수는 같아야합니다. 후자의 경우 반환 된 배열의 차원은 마지막 (또는 첫 번째 포트란 스타일의 연속 배열) 차원에서 변경됩니다. 반환 된 배열과 self의 데이터 영역은 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">경우 &lt;em&gt;연산이&lt;/em&gt; 이미 배열이지만, 조건을 만족하지 않고, 다음 복사 (요건을 만족하는 것)한다. 이 플래그가 존재하고 (이미 배열 인 오브젝트의) 사본이 작성되어야하는 경우, 대응하는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 리턴 된 사본에 설정되고 &lt;em&gt;op&lt;/em&gt; 는 읽기 전용이됩니다. 당신은 호출해야합니다 &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 을&lt;/a&gt; 내용으로 다시 복사 &lt;em&gt;연산&lt;/em&gt; 과 &lt;em&gt;연산&lt;/em&gt; 배열을 다시 쓰기 될 것이다. 경우 &lt;em&gt;영업 이익은&lt;/em&gt; 시작하는 쓰기가 아니거나 이미 배열이 아닌 경우, 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">경우 &lt;em&gt;변경하다는&lt;/em&gt; 것입니다 &lt;code&gt;NULL&lt;/code&gt; 이 결과의 모양입니다</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">경우 &lt;em&gt;subok가&lt;/em&gt; 1이고, 새로 생성 된 배열의 하위 유형 사용하는 &lt;em&gt;프로토 타입&lt;/em&gt; 그렇지 않으면 기본 수준의 배열을 만들 때, 새로운 배열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">경우 &lt;em&gt;아류&lt;/em&gt; 어레이 서브 대신 염기이다 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 후 &lt;em&gt;OBJ&lt;/em&gt; 받는 전달할 목적 &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; 의&lt;/a&gt; 서브 클래스의 방법.</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">q가 정규 직교가되도록 A = qr 인 경우 (Gram-Schmidt를 통해 항상 가능) &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; 입니다. 그러나 numpy 연습에서는 &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; 만&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">False이면 메모리를 보존하기 위해 원래 배열에 대한보기가 반환됩니다. 기본값은 True입니다. 제발 참고 &lt;code&gt;sparse=False, copy=False&lt;/code&gt; 가능성이 비 연속 배열을 반환합니다. 또한, 방송 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다. 배열에 쓰려면 먼저 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">False이면 참조 횟수를 확인하지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">K = min (M, N)이면</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">None 인 경우 인덱스는 전개 된 배열에 있고, 그렇지 않으면 지정된 축을 따라</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">None 인 경우 경로는 로컬 경로에 subpackage_name을 더한 것으로 가정합니다. subpackage_path에 setup.py 파일이 없으면 기본 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">None 인 경우 MaskType 인스턴스를 사용하십시오. 그렇지 않으면 부울 유형으로 변환 된 &lt;code&gt;dtype&lt;/code&gt; 과 동일한 필드를 가진 새 데이터 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">진정한 (기본값)의 사본 한 경우 &lt;code&gt;a&lt;/code&gt; 결과에. 거짓하다면 수정 &lt;code&gt;a&lt;/code&gt; 장소와 뷰를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">True (기본값) 인 경우 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;vh&lt;/code&gt; 의 모양은 각각 &lt;code&gt;(..., M, M)&lt;/code&gt; 및 &lt;code&gt;(..., N, N)&lt;/code&gt; 입니다. 그렇지 않으면 모양은 각각 &lt;code&gt;(..., M, K)&lt;/code&gt; 및 &lt;code&gt;(..., K, N)&lt;/code&gt; 이며 여기서 &lt;code&gt;K = min(M, N)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">True (기본값)이면 예쁜 인쇄 기능 ( &lt;code&gt;__repr__&lt;/code&gt; )이 설정되고 False이면 기본 문자열 표현 ( &lt;code&gt;__str__&lt;/code&gt; ) 을 반환하는 기능 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">True 인 경우 메모리를 절약하기 위해 스파 스 그리드가 반환됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;M&lt;/code&gt; 은 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;a&lt;/code&gt; 는 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;c_or_r&lt;/code&gt; 은 다항식의 근을 지정합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">True이면 &lt;code&gt;stop&lt;/code&gt; 이 마지막 샘플입니다. 그렇지 않으면 포함되지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">True이면 NaN이 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">True 인 경우 C- 컴파일러와 같이 패딩하여 필드를 정렬하십시오. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">True 인 경우 고유 한 배열을 제공하는 &lt;code&gt;ar&lt;/code&gt; (지정된 축을 따라 또는 평면 배열로) 의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 &lt;code&gt;ar&lt;/code&gt; 을 재구성하는 데 사용할 수있는 고유 배열 (제공된 경우 지정된 축에 대한)의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 각 고유 항목이 &lt;code&gt;ar&lt;/code&gt; 에 나타나는 횟수도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">True 인 경우 항상 고정 소수점 표기법을 사용하여 부동 소수점 숫자를 인쇄합니다.이 경우 현재 정밀도에서 0과 같은 숫자는 0으로 인쇄됩니다. False 인 경우 가장 작은 수의 절대 값이 &amp;lt;1e-4이거나 최대 절대 값과 최소값의 비율이&amp;gt; 1e3 일 때 과학 표기법이 사용됩니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">True이면 항상 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">True 인 경우 열 수에서 불일치가 감지되면 예외가 발생합니다. False이면 경고가 발생하고 문제가되는 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">True 인 경우 유효하지 않은 값에 대해 오류를 발생시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">True 인 경우 필드 이름은 대소 문자를 구분합니다. False 또는 'upper'이면 필드 이름이 대문자로 변환됩니다. '낮음'이면 필드 이름이 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 일부 값이 없을 때 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 예외가 발생합니다. 때문에 &lt;code&gt;bias&lt;/code&gt; 되지 않습니다,이 인수는 경고를 피하기 위해 키워드로 취급 될 필요가있다.</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">True 인 경우 ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; )을 반환 합니다. 여기서 &lt;code&gt;step&lt;/code&gt; 은 샘플 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">True이면 마스크 된 배열을 반환합니다. False이면 일반 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">True 인 경우 데코레이션 된 콜 러블이 테스트임을 지정합니다. False 인 경우 데코레이션 된 콜 러블이 테스트가 아님을 지정합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">True이면 서브 클래스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 축소 된 축은 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;code&gt;arr&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">True 인 경우 충돌하는 값이 오류 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">True이면 두 배열의 교점에 해당하는 인덱스가 반환됩니다. 값이 여러 개인 경우 값의 첫 번째 인스턴스가 사용됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">True 인 경우 입력 배열이 모두 고유 한 것으로 가정하여 계산 속도를 높일 수 있습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우 반복자는 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그 를 사용하여 작성되었으며 특성 &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 사용하여이를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">True 인 경우, 이터레이터는 &lt;code&gt;delay_bufalloc&lt;/code&gt; 플래그 로 작성 되었으며 아직 reset () 함수가 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우, 반복자는 만들었습니다 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그 및 속성 &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; 은&lt;/a&gt; 그것을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">True이면 반환 된 배열이 바뀝니다. 따라서 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">True 인 경우, 반환 된 배열이 바뀌므로 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 . 구조화 된 데이터 유형과 함께 사용하면 각 필드에 대해 배열이 리턴됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우 계수 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 것으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과는 &lt;code&gt;c&lt;/code&gt; 의 모든 계수 열 이 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;c&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;c&lt;/code&gt; 가 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우, 루트 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 것으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과는 &lt;code&gt;r&lt;/code&gt; 의 모든 계수 열 이 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;r&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;r&lt;/code&gt; 이 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">참이 반환 된 배열의 값이 반전되는 경우 (즉, 요소의 위치를 거짓 &lt;code&gt;ar1&lt;/code&gt; 되어 &lt;code&gt;ar2&lt;/code&gt; 달리 트루). 기본값은 거짓입니다. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; 는 &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 와 동일하지만 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">True 인 경우, 반환 된 배열의 값 &lt;code&gt;element not in test_elements&lt;/code&gt; 계산하는 것처럼 반전됩니다 . 기본값은 거짓입니다. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; 은 &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 와 같습니다 (그러나 빠릅니다 ) .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 를 중간 계산으로 수정하여 메모리를 절약 할 수 있습니다. 이 경우이 기능이 완료된 후 입력 &lt;code&gt;a&lt;/code&gt; 의 내용 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">참이면 계산에 입력 배열 (a)의 메모리 사용을 허용하십시오. 입력 배열은 중앙값 호출에 의해 수정됩니다. 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 해당 주 &lt;code&gt;overwrite_input&lt;/code&gt; 가 사실이고, 입력이 이미하지 &lt;code&gt;ndarray&lt;/code&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">True 인 경우 하위 클래스가 통과 (기본값)되고, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">True 인 경우 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열은 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">True 인 경우 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열은 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">True 인 경우 새로 만든 배열은 하위 클래스 유형 'a'를 사용하고 그렇지 않으면 기본 클래스 배열이됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">[배열, 배열]이면 각 차원의 빈 가장자리 (x_edges, y_edges = 빈)입니다.</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">[int, int] 인 경우 각 차원의 구간 수 (nx, ny = 구간).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">__svn_version__.py가 이미 존재하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">&amp;lt;1 인 경우</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">갖는 클래스 (ndarray 서브 여부) 경우 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; 의&lt;/a&gt; 방법은 출력 오브젝트로서 사용된다 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , 결과에 의해 리턴 된 객체에 기록한다 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . 입력 배열에서도 비슷한 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">클래스가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메서드를 정의하면 ufunc에 대해 아래 설명 된 &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 메커니즘을 비활성화합니다 (결국 더 이상 사용되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">컴파일 타임 고정 버퍼가 사용되는 경우 ( &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 모두 ) 내부 크기도 신호로 사용될 수 있습니다. &lt;code&gt;iternext()&lt;/code&gt; 가 false를 리턴 하면 크기가 0이되어 다음 루프 구성이 가능합니다. 이 구문을 사용하는 경우 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 를 플래그로 전달하면 안됩니다 . 일부 환경에서는 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">dtype 객체에이 속성이있는 필드가 검색되면 &lt;em&gt;모양&lt;/em&gt; 으로 암시 된 추가 차원 이 검색된 배열의 끝에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">특정 유형에 대해 포맷터가 지정된 경우 해당 유형에 대해 &lt;code&gt;precision&lt;/code&gt; 키워드가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">지정된 배열이 지정된 제한을 충족하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">a가 행렬 객체이면 반환 값도 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">a가 int이고 0보다 작은 경우 a 또는 p가 1 차원이 아닌 경우 a가 크기가 0 인 배열과 같거나 p가 확률의 벡터가 아닌 경우, a와 p의 길이가 다른 경우 또는 replace = 거짓이며 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">a가 int이고 0보다 작은 경우, p가 1 차원이 아닌 경우, a가 크기가 0 인 배열과 같은 경우, p가 확률 벡터가 아닌 경우, a와 p의 길이가 다르거 나 replace = 인 경우 False이고 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">문자열 목록 인 경우 각 문자열은 dtype을 나타내야합니다. array_like 인 경우 배열 dtype의 문자 표현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">스칼라 dtype 인 경우 해당 문자열 문자가 리턴됩니다. 객체 인 경우 &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; 는 스칼라 유형을 유추 한 다음 해당 문자열 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">스칼라 값이 전달 된 경우</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">두 번째 인수가 제공되면 결과가 저장됩니다. 해당 배열의 유형이 숫자 유형 인 경우 결과는 0과 1로 표시되며, 유형이 부울 인 경우 False 및 True로 표시됩니다. 리턴 값 &lt;code&gt;out&lt;/code&gt; 그 어레이에 대한 레퍼런스이다.</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">제로 차원 배열 인덱스에 존재하는 경우 &lt;em&gt;와&lt;/em&gt; 는 전체 정수 인덱스 인 결과가 될 것이다 &lt;em&gt;스칼라&lt;/em&gt; 아니라 제로 차원 어레이. (고급 인덱싱은 트리거되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">실제와 원하는 것이 지정된 정밀도와 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">실제와 원하는 것이 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">실제 및 원하는 객체가 동일하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">모든 경우 &lt;code&gt;__array_function__&lt;/code&gt; 방법은 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 을 , NumPy와는 올릴 &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">모든 배열이 1 차원 인 &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">모든 값이 마스킹되면 None을 반환합니다. 그렇지 않으면, 첫 번째 마스크 값과 마지막 마스크되지 않은 값의 인덱스에 각각 해당하는 두 개의 튜플 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">배열에 매우 작거나 큰 결정자가있는 경우 &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 호출 이 오버플로되거나 언더 플로 될 수 있습니다. 이 루틴은 결정자 자체가 아니라 결정자 로그를 계산하기 때문에 이러한 문제에 대해보다 강력합니다.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">배열에 요소가없는 경우 ( &lt;code&gt;self.size == 0&lt;/code&gt; ) 유효한 인덱스가없고 보폭이 사용되지 않습니다. 요소가없는 배열은 C 스타일과 포트란 스타일의 연속으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">하위 배열을 설명하는 데이터 형식을 사용하여 배열을 만들면 배열이 만들어 질 때 하위 배열의 차원이 배열 모양에 추가됩니다. 구조화 된 유형의 필드에있는 하위 배열은 다르게 동작합니다 ( &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;필드 액세스&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">이 방법으로 배열을 만들면 각 반복에 대해 'itemsize'를 추가하면 반복자와 일치하는 새 배열을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">소자의 경우 &lt;code&gt;axes&lt;/code&gt; 의 축수보다보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">index가 &lt;code&gt;axis&lt;/code&gt; 를 따라 배열의 차원을 초과하면 해당 하는 빈 하위 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">입력의 모양 크기가 1 인 경우 해당 차원의 첫 번째 데이터 항목이 해당 차원의 모든 계산에 사용됩니다. 다시 말해, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; 의 스테핑 기계 는 단순히 해당 치수를 따라 밟지 않습니다 (해당 치수의 &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;보폭&lt;/a&gt; 은 0입니다).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">ndarray 인 경우 요소에서 임의의 샘플이 생성됩니다. int 인 경우 a가 np.arange (a) 인 것처럼 임의 샘플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">객체가 제공되면 write 메소드는 하나의 인수 인 문자열을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">입력 값이 array_like 인 경우 &lt;code&gt;pv&lt;/code&gt; 는 동일한 모양의 배열을 반환합니다. 위의 예에서 다른 금리를 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">입력이 array_like 인 경우 동일한 모양의 배열을 반환합니다. 위의 예와 다른 금리를 비교해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">읽기 / 쓰기 오버랩이 존재하면이 플래그는 연산 결과가 모든 피연산자가 복사 된 것과 동일하도록합니다. 복사가 필요한 경우, &lt;strong&gt;이 플래그없이 계산 결과가 정의되지 않을 수 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">알파 값이 0보다 작거나 같은 경우</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">쓰기 피연산자가 읽기 피연산자와 겹치는 경우 임시 복사본을 만들어 모든 겹침을 제거하십시오 (필요한 경우 쓰기 피연산자에 UPDATEIFCOPY 사용). 두 배열에 공통적 인 데이터를 포함하는 메모리 주소가 있으면 피연산자 쌍이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">인수가 int dtypes로만 구성된 경우</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">키워드없이 인수가 전달되면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 'arr_0', 'arr_1'등입니다. 키워드 인수가 제공되면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 키워드 이름.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">축이 0이면 행만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">축이 1 또는 -1이면 열만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">axis가 None이면 행과 열이 모두 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 제품이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 합계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 평균화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">axis가 int의 튜플 인 경우 튜플에 지정된 모든 축에서 반전이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이이고, 그것은 (복소 공액)없이 벡터의 내적이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 2-D 어레이이고,는 매트릭스 승산이지만, 사용 &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; 을&lt;/a&gt; 하거나 &lt;code&gt;a @ b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 있는 &lt;code&gt;NULL&lt;/code&gt; , 다음 반환 &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;상태&lt;/em&gt; ). 그렇지 않으면, 두 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y를&lt;/em&gt; 지정해야하고 리턴 된 객체 형상되는 &lt;em&gt;조건&lt;/em&gt; 및 원소 가지고 &lt;em&gt;, X&lt;/em&gt; 및 &lt;em&gt;Y를&lt;/em&gt; 여기서 &lt;em&gt;조건은&lt;/em&gt; 각각 참 또는 거짓이다.</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">두 인수가 모두 2 차원이면 기존 행렬과 같이 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">양의 무한대와 음의 무한대가 모두 존재하면, 합계는 숫자가 아님 (NaN)이됩니다.</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">경고 클래스 이외의 모든 인수를 생략하고 호출하면 컨텍스트 관리자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">복잡한 부분이 0에 가까우면 복잡한 입력이 실제 배열을 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">condition이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 인 경우 결 측값 은 &lt;code&gt;False&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">copy가 False이고 입력 중 하나가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 이면 다른 입력 마스크의보기를 리턴하십시오. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">데이터가 &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; 로 전달 되면 새 배열이 삭제 될 때까지이 메모리를 할당 해제해서는 안됩니다. 이 데이터가 다른 Python 객체에서 온 경우 해당 객체에서 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; 를 사용하여 새 객체의 기본 멤버를 해당 객체를 가리 키도록 설정하면됩니다. 보폭이 전달되면 치수, 항목 크기 및 배열의 ​​데이터와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">정의한 경우의 축 , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 을 정의하는 벡터 (들) 및 외적 (들) 즉. 오버라이드 (override) &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; 및 &lt;code&gt;axisc&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">어느 경우 또는 &lt;code&gt;b&lt;/code&gt; 는 0 D (라), 그것과 동등하다 &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; 및 사용 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; 또는 &lt;code&gt;a * b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">인수 중 하나가 ND, N&amp;gt; 2 인 경우 마지막 두 인덱스에 상주하는 행렬의 스택으로 취급되어 그에 따라 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">배열에 하나 이상의 NaN이 포함되어 있으면 False가 반환됩니다. Infs는 두 배열에서 같은 위치에 있고 같은 부호를 가진다면 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">요소의 복소수가 0 인 복소수 유형 인 경우 해당 요소의 리턴 값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">팩토링이 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">파일이 문자열 또는 경로와 유사한 객체이면 해당 파일이 열리고 그렇지 않은 경우 파일 객체로 간주됩니다. 파일 객체는 랜덤 액세스를 지원해야합니다 (즉, tell 및 seek 메소드가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">필터가 추가되고 &lt;code&gt;module&lt;/code&gt; 키워드가 제공되면이 모듈의 경고 레지스트리는 적용, 컨텍스트 입력 또는 종료시 추가로 지워집니다. 이로 인해 컨텍스트가 한 번 인쇄되도록 구성되고 (기본값) 컨텍스트가 입력되기 전에 이미 인쇄 된 경우 컨텍스트를 떠난 후 경고가 두 번째로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">형식이 없음이면 형식이 자동 감지됩니다. 빠른 처리를 위해 목록 목록 대신 튜플 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 가 아니라 주어진 경우 추정값뿐만 아니라 공분산 행렬도 반환합니다. 공분산은 기본적으로 chi2 / sqrt (N-dof)에 의해 스케일링됩니다. 즉, 상대적 의미를 제외하고 가중치는 신뢰할 수없는 것으로 추정되며 감소 된 chi2가 일치하도록 모든 것이 스케일됩니다. 이 스케일링은 가중치가 1 / sigma ** 2 인 경우와 관련하여 sivma가 불확실성의 신뢰할 수있는 추정치 인 것으로 알려진 &lt;code&gt;cov='unscaled'&lt;/code&gt; 인 경우 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">제공된 경우 &lt;code&gt;@key@&lt;/code&gt; 형식의 문자열은 설치시 템플릿 파일에서 &lt;code&gt;subst_dict[key]&lt;/code&gt; 로 바뀝니다 . 설치 접두사는 setup.py에서 안정적으로 얻기 쉽지 않기 때문에 항상 &lt;code&gt;@prefix@&lt;/code&gt; 변수를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">주어진 경우 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 도메인의 끝점입니다. None이 주어지면 클래스 도메인이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">주어진 경우, 결과 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식 인 경우 여야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 창의 끝점입니다. None이 주어지면 클래스 창이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">주어진 경우, 유형을 판별 할 수없는 오브젝트에 대해 리턴됩니다. 지정하지 않으면 해당 오브젝트에 대해 없음이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">입력 배열 &lt;code&gt;a&lt;/code&gt; 가 2D가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">입력이 잘못된 모양 인 경우 (입력은 1D 또는 사각형 2D 배열이어야합니다).</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">키워드 인수가 제공되면 파일 이름이 키워드에서 가져옵니다. 키워드없이 인수를 전달하면 저장된 파일 이름은 arr_0, arr_1 등입니다.</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">예를 들어 &lt;code&gt;[[a, b], c]&lt;/code&gt; 와 같이 목록 깊이가 일치하지 않으면 &lt;code&gt;[[a, b], [c]]&lt;/code&gt; 철자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">목록이 비어있는 경우 (예 : &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">다중 차원 입력 인 경우 지정된 축을 따라 새 인덱스의 ndarray를 최소값으로 반환합니다. 그렇지 않으면 주어진 축을 따라 인덱스의 스칼라를 최소값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">필요한 경우 차이가 발생하기 전에 평평해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">둘 다 정의되지 않은 경우 C-API는 &lt;code&gt;static void**&lt;/code&gt; 선언 되므로 #includes numpy / arrayobject.h 인 컴파일 단위에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 메소드가 없으면 NumPy는 NumPy 배열에서 사용하기 위해 자체 구현을 호출하도록 기본 설정됩니다. 이 경우는 예를 들어 모든 배열과 같은 인수가 Python 숫자 또는 목록 인 경우에 발생합니다. (NumPy와 배열이 있습니까 &lt;code&gt;__array_function__&lt;/code&gt; 의 아래, 방법을, 그러나 항상 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 의 다른 인수가 NumPy와 배열 서브 클래스 구현이보다 경우 &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">입력 중 어느 것도 모든 출력 어레이가 전달 될 ufunc 재정의 없으면 &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 입력 방법 (또한 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 및 스칼라)하도록 정의를 &lt;strong&gt;하고&lt;/strong&gt; 가장 갖고 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 범용 기능 다른 입력한다. &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 의 기본 __array_priority__ 는 0.0이고 하위 유형 의 기본 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 은 0.0입니다. 행렬의 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 는 10.0입니다.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 정규화하는 것이다 &lt;code&gt;(N - ddof)&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 은 관찰의 수이고; 이 값은 &lt;code&gt;bias&lt;/code&gt; 에 의해 암시 된 값보다 우선합니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않을 경우 &lt;code&gt;None&lt;/code&gt; 에 의해 암시 기본값 &lt;code&gt;bias&lt;/code&gt; 무시됩니다. 참고 &lt;code&gt;ddof=1&lt;/code&gt; 이 두 경우에도 불편 추정치를 반환합니다 &lt;code&gt;fweights&lt;/code&gt; 및 &lt;code&gt;aweights&lt;/code&gt; 가 지정되고, &lt;code&gt;ddof=0&lt;/code&gt; 단순 평균을 반환합니다. 자세한 내용은 참고 사항을 참조하십시오. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">None이 아닌 경우 키는 각 형식 지정 기능이 적용되는 유형을 나타냅니다. 콜 러블은 문자열을 반환해야합니다. 해당 키로 지정되지 않은 유형은 기본 포맷터에서 처리합니다. 포맷터를 설정할 수있는 개별 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">None이 아닌 경우, 지정된 도메인이 호출 인스턴스의 도메인 대신 사용됩니다. &lt;code&gt;[beg,end]&lt;/code&gt; 형식이어야합니다 . 기본값은 없음이며 클래스 도메인이 사용되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">None이 아니라면 주어진 모드를 사용하여 파일을 메모리에 매핑합니다 (모드 에 대한 자세한 설명 은 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt; 참조 ). 메모리 매핑 배열은 디스크에 보관됩니다. 그러나 ndarray와 같이 액세스하고 슬라이스 할 수 있습니다. 메모리 매핑은 전체 파일을 메모리로 읽지 않고 큰 파일의 작은 조각에 액세스하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">하나의 인수가 스칼라 인 경우 &lt;code&gt;a&lt;/code&gt; 의 크기가 1 인 경우 에만 사용됩니다 . 두 개의 인수 : 마지막 인수가 설정 될 값이고 스칼라 여야하는 경우 첫 번째 인수는 단일 배열 요소 위치를 지정합니다. int 또는 tuple입니다.</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">입력 또는 출력 인수 중 하나에 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메소드 가 있으면 ufunc&lt;em&gt; 대신&lt;/em&gt; 실행 &lt;em&gt;됩니다&lt;/em&gt; . 둘 이상의 인수가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; 를&lt;/a&gt; 구현 하면 수퍼 클래스 이전의 서브 클래스, 출력 이전의 입력, 그렇지 않으면 왼쪽에서 오른쪽으로 순서대로 시도됩니다. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 이외의 것을 반환하는 첫 번째 루틴 이 결과를 결정합니다. 의 모든 경우 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 작업이 반환 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 을&lt;/a&gt; 하는 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">하나 개 이상의 요소들은 이상 다를 경우 &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">세 번째에 &quot;1&quot;이 나타날 때까지 주사위를 반복해서 던지면 세 번째 &quot;1&quot;이전에 나타나는 &quot;1&quot;이 아닌 숫자의 확률 분포는 음의 이항 분포입니다.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">여러 위치에서 동일한 차원 이름을 사용하는 경우 동일한 크기의 해당 차원이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">피연산자 플래그 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; 를 사용하는 경우 피연산자는 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그 를 사용하여 원래 데이터를 볼 수 있습니다 . 이 경우 nditer를 컨텍스트 관리자로 사용하거나 결과를 사용하기 전에 nditer.close 메소드를 호출해야합니다. &lt;code&gt;__exit__&lt;/code&gt; 함수가 호출되었지만 이전이 아닌 임시 데이터는 원래 데이터에 다시 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">out이 주어지고 마스크 속성이 없으면 a의 마스크가 손실됩니다!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">단일 ndarray 또는 스칼라 (0의 중첩 된 목록)를 전달하면 수정되지 않은 (복사되지 않은) 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정상&quot;(가우시안) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 배열 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 생성합니다 . 단일 부동 인수가 제공되지 않으면 분포에서 무작위로 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">제공된 경우 지정된 데이터 유형을 사용하도록 계산합니다. 변환을 허용하기 위해 보다 자유로운 &lt;code&gt;casting&lt;/code&gt; 매개 변수를 제공해야 할 수도 있습니다 . 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공되는 경우 각 피연산자에 대한 정수 목록 또는 없음입니다. 피연산자의 축 목록은 반복자의 차원에서 피연산자의 차원으로의 맵핑입니다. 항목에 -1 값을 배치하면 해당 차원이 &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">제공되는 경우, 분포에서 추출 할 가장 큰 (부호있는) 정수 위의 하나 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작은 위 참조 ). 배열과 같은 경우 정수 값을 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">제공된 경우 계산은이 배열로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 연결된 모양과 일치하는 모양이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 스택이 반환 한 것과 일치하는 형태가 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">제공된 경우 분포에서 추출 할 가장 큰 부호있는 정수 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작 참조 ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 &lt;code&gt;dtype&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 배치됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">제공된 경우이 배열은 결과로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">False로 설정하면 반환 된 배열은 항상 읽기 전용입니다. 그렇지 않으면 원래 배열이면 쓸 수 있습니다. 가능하면이를 False로 설정하는 것이 좋습니다 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">문자열 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 하면 1.13 레거시 인쇄 모드가 활성화됩니다. 이것은 float의 부호 위치에 공백을 포함시키고 0d 배열의 다른 동작으로 numpy 1.13 인쇄 출력과 비슷합니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 레거시 모드가 비활성화됩니다. 인식 할 수없는 문자열은 앞으로 호환성에 대한 경고와 함께 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">슬라이스 표기법을 사용하는 경우 구문 &lt;code&gt;start:stop:step&lt;/code&gt; 은 괄호 안의 &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; 와 같습니다 . 그러나, &lt;code&gt;step&lt;/code&gt; 가 허수 (즉, 100j) 인 경우, 정수 부분은 원하는 수의 포인트로 해석되며 시작 및 중지는 포함됩니다. 즉, &lt;code&gt;start:stop:stepj&lt;/code&gt; 는 괄호 안에 &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; 로 해석 됩니다. 슬라이스 표기법이 확장 된 후 모든 쉼표로 구분 된 시퀀스가 ​​함께 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 (및 &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ) &lt;code&gt;RankWarning&lt;/code&gt; 가 발생합니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 하위 다항식에 피팅하면 일반적으로 경고가 제거됩니다 (물론 원하는 것은 아닐 수도 있습니다. 작동하지 않는 정도를 선택 해야하는 독립적 인 이유가있는 경우 다음을 수행해야 할 수도 있음) 그 이유를 재고하고 /하거나 b) 데이터 품질을 재고하십시오. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 &lt;code&gt;RankWarning&lt;/code&gt; 이 발행됩니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 낮은 차수를 사용하면 일반적으로 경고가 사라집니다. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">스파 스가 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">스파 스가 참인 경우 :</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">스파 스가 true로 설정된 경우 그리드는 스파 스 표현으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정하면 모든 필드가 제공된 바이트 순서로 변경됩니다. 그렇지 않으면 기본 바이트 순서가 사용됩니다. 사용 가능한 모든 문자열 지정자에 대해서는 &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">state가 사전 인 경우 BitGenerators &lt;code&gt;state&lt;/code&gt; 속성을 사용하여 직접 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">(더 이상 사용되지 않는) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우, 이는 다른 의미를 갖습니다. 즉 base는 복사 배열시 현재 배열이 복사 될 배열입니다. 이 두 함수에 대한 기본 속성의 오버로드는 향후 버전의 NumPy에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">경우] &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체는 구조화 된 배열 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;필드&lt;/a&gt; 배열의 사전과 같은, 문자열 배열을 인덱싱하여 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">경우 &lt;code&gt;order&lt;/code&gt; 키워드 인수가 지정됩니다. 이 동작은 NumPy의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">상기 중간 &lt;code&gt;width&lt;/code&gt; 값이 불충분하고, 무시되며, &lt;code&gt;num&lt;/code&gt; 이진 (리턴한다 &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) 또는 2의 보수 ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) 양식을 그것의 수를 나타내는 데 필요한 비트들의 최소 수와 동일한 폭 지정된 양식. 이 동작은 더 이상 사용되지 않으며 나중에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">액세스 한 필드가 하위 배열 인 경우 하위 배열의 크기가 결과 모양에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">누산기가 너무 작은 경우 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">배열에 마스크가 없으면 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 의 주소 가 반환됩니다. 이 주소는 일반적으로 메모리의 데이터에 가깝지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">NumPy의 방송 규칙에 따라 어레이가 새 모양과 호환되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">버퍼에 머신 바이트 순서가 아닌 데이터가있는 경우 데이터 유형의 일부로 지정해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">공통 데이터 유형을 미리 알고 있으면이 플래그를 사용하지 마십시오. 대신, 모든 피연산자에 요청 된 dtype을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">조건이 호출 가능한 경우 런타임에 동적으로 결정을 내리는 데 사용됩니다. 이는 테스트 스위트가 실제로 실행될 때까지 비용을 지연시키기 위해 값 비싼 가져 오기가 필요한 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">변환이 불가능한 경우</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">ctypes 모듈을 사용할 수없는 경우 배열 객체의 ctypes 속성은 여전히 ​​유용한 것을 반환하지만 ctypes 객체는 반환되지 않으며 대신 오류가 발생할 수 있습니다. 특히 객체에는 여전히 &lt;code&gt;as_parameter&lt;/code&gt; 속성이 있으며이 속성은 data 속성과 동일한 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">현재 도메인이 구간 &lt;code&gt;[l1, r1]&lt;/code&gt; 이고 윈도우가 &lt;code&gt;[l2, r2]&lt;/code&gt; 인 경우 선형 맵핑 함수 &lt;code&gt;L&lt;/code&gt; 은 다음 방정식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">데이터 유형이 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 인 경우 다른 데이터 유형의 집계 ( &lt;em&gt;예 :&lt;/em&gt; 정수 및 부동 소수점으로 구성된 배열 항목 설명)</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">데이터 유형이 하위 배열 인 경우 해당 모양 및 데이터 유형은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">예를 들어, 분해가 실패 &lt;code&gt;a&lt;/code&gt; 경우 a 가 양의 한정이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 의 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 의 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 의 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">의 차원 경우 &lt;code&gt;a&lt;/code&gt; 는 2 이하이다.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 불연속성 이 &lt;code&gt;pi&lt;/code&gt; 보다 &lt;code&gt;discont&lt;/code&gt; 보다 큰 경우 2 * pi 보수를 사용하면 불연속성이 더 커지므로 언 래핑이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">고유 값 계산이 수렴하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">파일에 피클 데이터가 포함되어 있으면 피클에 저장된 모든 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">파일이 &lt;code&gt;.npy&lt;/code&gt; 파일이면 단일 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우, 리턴 된 값은 열린 함수와 유사한 방식으로 컨텍스트 관리자 프로토콜을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우 &lt;code&gt;{filename: array}&lt;/code&gt; 키-값 쌍 (아카이브의 각 파일에 대해 하나씩)을 포함하는 사전과 유사한 오브젝트가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">파일 이름이 &lt;code&gt;.gz&lt;/code&gt; 로 끝나면 파일은 자동으로 압축 된 gzip 형식으로 저장됩니다. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; 는 gzip으로 압축 된 파일을 투명하게 이해합니다.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 처리됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 취급됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">첫 번째 인수가 1-D이면 1을 차원 앞에 추가하여 행렬로 승격합니다. 행렬 곱셈 후 앞에 붙인 1이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">첫 번째 인수가 튜플이면 다른 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">다음 방정식이 요소 별 True이면 &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">다음 방정식이 요소 별 True이면 allclose는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">주어진 문자열이 같으면 &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; 은 아무 것도 수행하지 않습니다. 동일하지 않으면 AssertionError가 발생하고 문자열 사이의 차이가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double dot()&lt;/code&gt; 용 프로토 타입이 포함 된 헤더 파일 에 래핑하려는 다른 프로토 타입도 포함되어 있으므로이 헤더 파일 을 &lt;code&gt;%include&lt;/code&gt; 해야하는 경우 &lt;code&gt;%ignore dot;&lt;/code&gt; 도 필요합니다 . 지시문은 &lt;code&gt;%rename&lt;/code&gt; 뒤 및 &lt;code&gt;%include&lt;/code&gt; 지시문 앞에 배치 됩니다 . 또는 해당 함수가 클래스 메서드 인 경우 &lt;code&gt;%ignore&lt;/code&gt; 외에도 &lt;code&gt;%inline&lt;/code&gt; 대신 &lt;code&gt;%extend&lt;/code&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">인덱스 표현식에 쉼표로 구분 된 배열이 있으면 첫 번째 축을 따라 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">인덱스 표현식에 슬라이스 표기법 또는 스칼라가 포함 된 경우 슬라이스 표기법으로 표시되는 범위로 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 에 허수 부가 포함되어 있으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">입력 파일이 없거나 읽을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.max와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.min과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">입력이 2d이고 축이 지정된 경우 결과는 목록의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">입력이 1 차원이 아니거나 음수 값을 가진 요소를 포함하거나 &lt;code&gt;minlength&lt;/code&gt; 가 음수 인 경우</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 매개 변수 &lt;code&gt;n&lt;/code&gt; 이 입력 크기보다 큰 경우 끝에 0을 추가하여 입력을 채 웁니다. 이것이 일반적인 접근이지만 놀라운 결과를 초래할 수 있습니다. 다른 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">입력이 ndarray이면 np.greater는 '&amp;gt;'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">입력 또는 dtype이 복잡한 경우 출력은 복잡한 평면의 로그 나선형을 따릅니다. (두 점을 통과하는 무한의 나선이 있습니다. 출력은 가장 짧은 경로를 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">반복자가 버퍼링되면 사용중인 버퍼의 크기를 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">반복자가 다중 색인을 추적하는 경우, 다중 색인을 지원하지 않으며 다중 표시가 필요하지 않은 경우 가능한 추가 반복자 최적화를 수행합니다. 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 마지막 치수 가 다른 경우.</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">마지막 치수 경우 &lt;code&gt;a&lt;/code&gt; 의 마지막에서 두 번째 사이즈와 동일한 크기 아니다 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">마스킹 된 배열에 명명 된 필드가있는 경우 단일 항목에 액세스하면 마스킹 된 필드가없는 경우 &lt;code&gt;numpy.void&lt;/code&gt; 객체가 반환 되거나 필드 중 하나 이상이 마스킹 된 경우 초기 배열과 동일한 dtype을 갖는 0d 마스킹 된 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">모드가 일정한 채우기 (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING) 인 경우 fill_value는 채우기 값을 보유하는 배열 객체를 가리켜 야합니다 (첫 번째 항목은 배열에 둘 이상의 항목이 포함 된 경우 채우기 값이 됨). 다른 경우에는 fill_value가 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">이름에 &quot;?&quot;접미사가 붙은 경우 수정 자, 차원은 차원을 공유하는 모든 입력 및 출력에 존재하는 경우에만 핵심 차원입니다. 그렇지 않으면 무시됩니다 (초등 함수의 경우 크기 1의 치수로 대체 됨).</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">새로운 배열 원의 배열보다 큰 경우, 새로운 배열의 반복 복사 가득 . 이 동작은 &lt;code&gt;a&lt;/code&gt; 의 반복 된 사본 대신 0으로 채워지는 a.resize (new_shape)와 다릅니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">선택 튜플 객체의 수 미만이면 &lt;em&gt;N&lt;/em&gt; 다음 &lt;code&gt;:&lt;/code&gt; 후속 치수 가정한다.</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">제공된 객체가 배열 인 경우이 함수는 &lt;code&gt;base&lt;/code&gt; 포인터 체인을 통과하여 각 배열이 메모리 소유자를 직접 가리 키도록합니다. 베이스가 설정되면 다른 값으로 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">피연산자가 쓰기 전용으로 플래그 지정되고 복사가 필요한 경우, 초기화되지 않은 임시 배열이 작성된 다음 불필요한 복사 조작을 수행하는 대신 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 호출시 &lt;code&gt;op[i]&lt;/code&gt; 로 다시 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">선택적 인수 &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 가 제공되면 첫 번째 &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">iter의 위치가 변경되면 PyArrayNeighborhoodIter_Next에 대한 후속 호출은 정의되지 않은 동작이며 PyArrayNeighborhoodIter_Reset을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">요청 된 데이터 유형이 기본이 아닌 바이트 순서 인 경우 NBO 플래그가이를 대체하고 요청 된 데이터 유형이 기본 바이트 순서로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">반환 된 계수가 &lt;code&gt;c&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">두 번째 인수가 1-D이면 1을 차원에 추가하여 행렬로 승격합니다. 행렬 곱셈 후 추가 된 1이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">선택 튜플은 모든 항목이있는 경우 &lt;code&gt;:&lt;/code&gt; 제외한 &lt;em&gt;P&lt;/em&gt; 슬라이스 목적 번째 항목 &lt;code&gt;i:j:k&lt;/code&gt; 후 리턴 배열 차원있다 &lt;em&gt;N은&lt;/em&gt; 엘리먼트의 정수 인덱스에 의해 리턴 된 서브 - 어레이 연결하여 형성된 &lt;em&gt;나&lt;/em&gt; , &lt;em&gt;나는 + K를&lt;/em&gt; ,&amp;hellip;, &lt;em&gt;i + (m-1) k &amp;lt;j&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">간격 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 중 하나 개 이상의 요소는보다 큰 &lt;code&gt;nulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">문자열이 올바른 크기가 아닌 경우 요청 된 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;count&lt;/code&gt; 를 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 유형 이 부호없는 경우 출력 유형은 부호없는 플랫폼 정수입니다.</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">입력 유형이 복잡한 경우.</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">입력 유형이 부동 또는 복합 인 경우</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">ufunc에 2 개의 입력과 1 개의 출력이 있고 두 번째 입력이 Object 배열 인 경우, 두 번째 입력이 ndarray가 아니고 __array_priority__ 속성이 있고 __r {op } __ 특별한 방법. 이런 식으로 파이썬은 다른 객체가 일반적인 객체 배열 계산을 사용하는 대신 작업을 완료 할 수있는 기회를주기 위해 신호를 보냅니다. 이를 통해 (예를 들어) 희소 행렬이 곱셈 연산자 1-D 루프를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">기본 데이터가 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 인 경우 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되는 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달됩니다 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달됩니다 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">스칼라 만 있거나 스칼라의 최대 범주가 배열의 최대 범주보다 높으면 데이터 유형이 &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">스칼라 만 있거나 스칼라의 최대 범주가 배열의 최대 범주보다 높으면 데이터 유형이 &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">예상되는 확장자를 가진 라이브러리가 없거나 라이브러리에 결함이있어로드 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">부울 배열이 하나만 있고 정수 인덱싱 배열이 없으면 간단합니다. 부울 인덱스가 작업 할 &lt;em&gt;수있는&lt;/em&gt; 만큼의 차원을 갖도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">이러한 배열이 모두 구조화 된 배열로 수집되면 &lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)를 사용하여 배열을 직접 정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">이러한 조건이 유지되면 &lt;code&gt;__array_function__&lt;/code&gt; 은 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 대한 구현을 호출 한 결과를 반환해야합니다 . 그렇지 않으면, 센티넬 값 &lt;code&gt;NotImplemented&lt;/code&gt; 를 리턴 하여 함수가 이러한 유형으로 구현 되지 않았 음 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">이 배열이 자체 메모리를 소유하지 않으면 base는 자신을 소유 한 Python 오브젝트 (아마도 다른 배열 오브젝트)를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">이 배열에 (더 이상 사용되지 않는) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어 있으면이 배열은 &quot;잘못된 동작&quot;배열의 작업 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">이 함수가 true를 반환하면 호출자는 피연산자의 내부 루프 보폭도 확인해야합니다. 보폭이 0이면 가장 안쪽 외부 루프의 첫 번째 요소 만 처음 방문하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 &lt;code&gt;None&lt;/code&gt; 이면 모든 축에 대해 축소가 수행됩니다. 이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에 대해 평균이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에 대해 표준 편차가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 분산이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 카운트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 최대 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 최소값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">이것이 기본값 이외의 값이면 (빈 배열의 특수한 경우) 기본 배열 의 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 함수로 전달됩니다. 배열이 하위 클래스이고 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 에 kwarg &lt;code&gt;keepdims&lt;/code&gt; 가없는 경우 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">이것이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 ,이 데이터 유형 설명자는 다른 데이터 유형 설명 자의 C 스타일 연속 배열입니다. 다른 말로하면,이 디스크립터가 설명하는 각 요소는 실제로 다른 기본 디스크립터의 배열입니다. 이것은 다른 데이터 유형 설명 자의 필드에 대한 데이터 유형 설명 자로 가장 유용합니다. &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 필드 멤버는 NULL 이어야 &lt;code&gt;NULL&lt;/code&gt; ( 그러나 기본 디스크립터의 필드 멤버는 &lt;code&gt;NULL&lt;/code&gt; 이 아닐 수 있음 ). &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; 의 구조를 사용하여 정의되고</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">이것이 NULL이 아닌 경우,이 데이터 유형 설명자는 키가 이름 (및 주어진 경우 제목)이고 필드를 설명하는 튜플 인 파이썬 사전에 설명 된 필드를 갖습니다. 데이터 유형 설명자는 항상 고정 길이의 바이트 세트를 설명합니다. 필드는 총 고정 길이 컬렉션의 명명 된 하위 영역입니다. 필드는 다른 데이터 형식 설명자와 바이트 오프셋으로 구성된 튜플에 의해 설명됩니다. 선택적으로 튜플에는 일반적으로 Python 문자열 인 제목이 포함될 수 있습니다. 이 튜플은 이름 (및 주어진 경우 제목)을 기준으로 사전에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">이것이 바람직하지 않은 경우 먼저 배열을 더 큰 정수 유형으로 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">이 값을 &lt;code&gt;True&lt;/code&gt; 로 설정하면 축소 된 축이 크기가 1 인 차원으로 결과에 남게되므로 결과가 입력에 대해 올바르게 브로드 캐스트됩니다. 이 옵션은 모두 같은 수의 코어 치수를 가진 입력과 코어 치수가없는 출력, 즉 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 또는 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . 사용되는 경우 출력에서 ​​치수의 위치는 &lt;code&gt;axes&lt;/code&gt; 및 &lt;code&gt;axis&lt;/code&gt; 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">이 값을 True로 설정하면 표준 축이 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원본 &lt;code&gt;x&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 배열에 대해 올바르게 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 입력 배열에 대해 올바르게 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원본 &lt;code&gt;a&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;code&gt;arr&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원래 배열 &lt;code&gt;a&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">이 값이 기본값이 아닌 다른 값이면 서브 클래스의 관련 함수로 그대로 전달됩니다. 이러한 함수에 &lt;code&gt;keepdims&lt;/code&gt; kwarg 가 없으면 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true (기본값)이면 객체가 복사됩니다. 그렇지 않으면 __array__가 복사본을 반환하거나 obj가 중첩 시퀀스이거나 다른 요구 사항 ( &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 등) 을 충족시키기 위해 복사본이 필요한 경우에만 복사본이 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true (기본값)이면 객체가 복사됩니다. 그렇지 않으면 __array__가 복사본을 반환하거나 obj가 중첩 시퀀스이거나 다른 요구 사항 ( &lt;code&gt;itemsize&lt;/code&gt; , unicode, &lt;code&gt;order&lt;/code&gt; 등) 을 충족시키기 위해 복사본이 필요한 경우에만 복사본이 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">참이면 &lt;code&gt;stop&lt;/code&gt; 은 마지막 샘플입니다. 그렇지 않으면 포함되지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">true 인 경우 기본 [낮음, 높음] 대신 간격 [낮음, 높음]에서 샘플링합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하는 경우 보폭이 배치되는 방식 때문에 호출자의 내부 루프가 버퍼링없이 가능한 것보다 더 큰 청크를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 이 &lt;code&gt;bins&lt;/code&gt; 의 범위를 벗어나면 적절하게 0 또는 &lt;code&gt;len(bins)&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">의 값 경우 &lt;code&gt;x&lt;/code&gt; 는 그런 자들은 인덱스를 시도, 빈 범위를 벗어나는 것을 &lt;code&gt;bins&lt;/code&gt; 하는 지표로 &lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt; 반환은 IndexError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">&lt;code&gt;rms&lt;/code&gt; 를 설계했다면 아마도 &lt;code&gt;seq&lt;/code&gt; 라는 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;double&lt;/code&gt; 값으로 구성된 입력 전용 배열을 취하여 제곱 평균 제곱을 반환 하는 루틴으로 만들었을 것 입니다. 그러나 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 의 기본 동작은 컴파일하는 랩퍼 함수를 ​​작성하는 것이지만 C 루틴이 의도 한 방식으로 스크립팅 언어에서 사용하는 것은 거의 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">최대 값과 최소값을 동시에 얻으려면 먼저 인덱스를 쌓을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">'op'의 값에 쓰려는 경우 부울 'writeable'을 1로 설정하십시오. 'op'가 스칼라, 목록 목록 또는 기타 쓰기 불가능한 'op'인 경우 오류가 발생합니다. 이것은 쓰기 가능한 배열이 입력의 사본 일 수있는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 을 PyArray_FromAny 로 전달하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">C API를 사용하여 배열을 구성하고 자체 메모리를 지정하는 경우 &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 기본을 메모리를 소유 한 오브젝트로 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신의 서브 클래스가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 우리는 당신의 클래스가 같은 특별한 방법을 정의하는 것이 좋습니다 &lt;code&gt;__add__&lt;/code&gt; 을 하고 &lt;code&gt;__lt__&lt;/code&gt; ndarray가하는 것처럼 ufuncs 해당 대리자를. 이를 수행하는 쉬운 방법은 &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; 에서 서브 클래스를 만드는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">자체 메모리 버퍼를 매개 변수로 전달하여 배열을 구성하는 경우 메모리 버퍼 수명이 적절하도록 배열의 &lt;code&gt;base&lt;/code&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; 를 정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">현재 동작에 의존하는 경우 반환 된 배열을 명시 적으로 복사하는 것이 좋습니다. 즉, &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; 대신 np.diagonal (a) .copy ()를 사용하는 것이 &lt;code&gt;np.diagonal(a)&lt;/code&gt; . 이것은 NumPy의 과거와 미래 버전 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Fortran 순서를 사용하려면 고려해야 할 두 가지 접근 방법이 있음을 인식하십시오. 1) 첫 번째 색인이 메모리에서 가장 빠르게 변하는 것은 아니라는 점을 인정하고 메모리에서 디스크로 이동할 때 모든 I / O 루틴이 데이터를 다시 정렬하도록하십시오 또는 비자를 사용하거나 numpy의 메커니즘을 사용하여 첫 번째 인덱스를 가장 빠르게 변화하는 데이터에 매핑하십시오. 가능하면 전자를 권장합니다. 후자의 단점은 'order'키워드를주의해서 사용하지 않는 한 많은 numpy 함수가 포트란 순서없이 배열을 생성한다는 것입니다. 이렇게하는 것은 매우 불편합니다.</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">이 함수가 반환 한 배열에 쓰지 않으면 위의 모든 내용을 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">다음과 같은 Python 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">약간의 변형으로 여러 번 실행해야하는 테스트 모음이있는 경우 모든 공통 테스트를 포함하는 기본 클래스를 만든 다음 각 변형에 대한 하위 클래스를 만드는 것이 도움이 될 수 있습니다. 이 기술의 몇 가지 예가 NumPy에 존재합니다. 아래는 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.py&lt;/a&gt; 에서 발췌 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">datetime64 일 값의 배열이 있고 유효한 날짜 수를 원하는 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">좋은 시드 &quot;오프라인&quot;을 생성해야하는 경우 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; 또는 표준 라이브러리의 &lt;code&gt;secrets.randbits(128)&lt;/code&gt; 를 사용하는 것이 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">대출에 대해 $ 150 / 월만 지불했다면 연간 이자율 7 %로 $ 8,000의 대출을 상환하는 데 얼마나 걸립니까?</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">함수 또는 메소드가 배열에 대한 포인터를 리턴하는 상황이 발생하는 경우 클래스 메소드의 경우 &lt;code&gt;%extend&lt;/code&gt; 또는 &lt;code&gt;%ignore&lt;/code&gt; 및 &lt;code&gt;%rename&lt;/code&gt; 중 하나를 사용하여 랩핑 할 함수의 자체 버전을 작성하는 것이 가장 좋습니다. 함수의 경우 이름 을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">당신이를 지정하면 &lt;code&gt;n&lt;/code&gt; 하도록 &lt;code&gt;a&lt;/code&gt; 제로 패딩 또는 절단해야합니다, 추가 / 제거 값이 높은 주파수에서 삭제 / 추가됩니다. 따라서 &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; 의해 푸리에 보간을 통해 시리즈를 &lt;code&gt;m&lt;/code&gt; 포인트로 리샘플링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱하는 경우 모든 재정의 논리를 &lt;code&gt;__array_ufunc__&lt;/code&gt; 에 넣고 특수 메서드를 재정의하지 않는 것이 좋습니다 . 이렇게하면 클래스 계층 구조가 ufunc 기계와 이진 작업 규칙 (하위 클래스의 특수한 방법을 선호 함, &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 은 서브 클래스가 ufunc와 전혀 작동하지 않으므로 매우 예기치 않게 혼란스러워 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">정렬 된 &lt;code&gt;double&lt;/code&gt; 코드 로 배열을 편집하고 싶지만 순서는 중요하지 않은 경우이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">&lt;code&gt;iterindex&lt;/code&gt; 범위와 기본 포인터를 동시에 재설정 하려면 추가 버퍼 복사를 피하기 위해 다음을 수행 할 수 있습니다 (이 코드를 복사 할 때 리턴 코드 오류 검사를 추가하십시오).</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">극단적 인 가치 무시</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">일러스트 이미지 : &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">대각선 행렬의 고유 값이 대각선 요소라는 사실을 사용하여 왼쪽에 직교 행렬 &lt;code&gt;Q&lt;/code&gt; 와 오른쪽에 &lt;code&gt;Q.T&lt;/code&gt; ( &lt;code&gt;Q&lt;/code&gt; 의 전치 ) 를 곱 하면 &quot; 중간&amp;rdquo;매트릭스. 즉, &lt;code&gt;Q&lt;/code&gt; 가 직교 인 경우 &lt;code&gt;Q * A * Q.T&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 동일한 고유 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">이미지 &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; 는 사다리꼴 규칙을 나타냅니다. 점의 y 축 위치는 &lt;code&gt;y&lt;/code&gt; 배열 에서 가져 오며, 기본적으로 점 사이의 x 축 거리는 1.0이되며 &lt;code&gt;x&lt;/code&gt; 배열 또는 &lt;code&gt;dx&lt;/code&gt; 스칼라 와 함께 제공 될 수 있습니다 . 반환 값은 빨간색 선 아래의 결합 된 영역과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">32 비트 정수 배열 (각 4 바이트)을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">의 구현 &lt;code&gt;__array_function__&lt;/code&gt; 는 그들이 이외의 값 반환하여 작업을 처리 할 수 있음을 나타냅니다 &lt;code&gt;NotImplemented&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">commands.getstatusoutput 함수와 거의 동일한 exec_command 함수를 구현하지만 NT에서는 DOS 시스템에서 리턴 된 상태가 실제로 정확합니다 (반환 된 상태 값은 요인에 따라 다를 수 있음). 또한 exec_command는 환경 변수를 정의하는 키워드 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">사전 순 인 NumPy의 사전 정의 : 실수 부분을 먼저 비교 한 다음 실수 부분이 동일한 경우 복잡한 부분을 비교하여 NumPy의 정의를 사용하여 두 개의 복소수 (실제와 imag 멤버가있는 구조) 간의 복잡한 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">스칼라 강제 규칙을 구현합니다. 이 함수가 0이 아닌 값을 반환하면 스칼라는이 형식에서 필요한 형식으로 자동 강제 변환됩니다. 스칼라가 &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; 인 경우이 함수는 &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 규칙은 동일한 KIND의 스칼라가 동일한 KIND의 배열로 강제 변환 될 수 있다는 것입니다. 이 규칙은 고정밀 스칼라로 인해 동일한 KIND의 고정밀 배열이 업 캐스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">API 가져 오기</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">'clip'모드에서 일반적으로 줄 바꿈하는 음수 인덱스는 대신 0으로 클리핑됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">에서 &lt;code&gt;range(6)&lt;/code&gt; , 종류 라운딩이와 언더 플로우 처리하는 방법에 추가로 수행되는 사항에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">&lt;em&gt;명시 적 모드&lt;/em&gt; 에서는 출력 첨자 레이블을 지정하여 출력을 직접 제어 할 수 있습니다. 여기에는 식별자 '-&amp;gt;'및 출력 첨자 레이블 목록이 필요합니다. 이 기능은 필요할 때 합산을 비활성화하거나 강제 할 수 있으므로 기능의 유연성을 향상시킵니다. &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; 호출 은 &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 는 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 차이가 있다는 것입니다 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 는&lt;/a&gt; 기본적으로 방송 할 수 없습니다. 또한 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; 는 출력 첨자 레이블의 순서를 직접 지정하므로 위의 예와 같이 암시 적 모드와 달리 행렬 곱셈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">에서 &lt;em&gt;명시 적&lt;/em&gt; 모드, &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 은&lt;/a&gt; 불가능, 또는 요약을 통해 지정된 첨자 레이블을 강제로, 고전 아인슈타인 요약 작업으로 간주되지 않을 수 있습니다 다른 배열 작업을 계산하기 위해 더 유연성을 제공한다.</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">&lt;em&gt;암시 적 모드&lt;/em&gt; 에서는 출력 축이 사전 순으로 정렬되므로 선택한 아래 첨자가 중요합니다. 이는 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; 는 2D 배열에 영향을 미치지 않는 반면 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; 는 조옮김을 의미합니다. 또한 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 는 행렬 곱셈을 반환하는 반면, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; 는 첨자 'h'가 첨자보다 우선하므로 곱셈의 전치를 반환합니다. '나는'.</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">C에서는 Python이 지원하는 지원 중단 경고에 해당하지 않습니다. 지원 중단을 수행하는 한 가지 방법은 설명서 및 릴리스 정보에 해당 기능을 표시 한 다음 향후 주요 버전 (NumPy 2.0 이상)에서 사용되지 않는 기능을 제거하거나 변경하는 것입니다. 그러나 부 버전의 NumPy는 이전 부 릴리스에서 작동했던 코드를 막기 위해 주요 C-API 변경 사항이 없어야합니다. 예를 들어, NumPy 1.4에서 컴파일되고 작동 된 코드가 NumPy 1.7에서 작동하도록 (하지만 컴파일러 경고와 함께) 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">NumPy 1.16에서는 NumPy 함수 대체를 사용하기 위해 NumPy를 가져 오기 전에 환경 변수 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">NumPy 1.17에서 프로토콜은 기본적으로 활성화되어 있지만 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; 으로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">NumPy 1.6.0에서는 출력 승격 결정 메커니즘을 캡슐화하기 위해 유형 승격 API가 작성되었습니다. 자세한 내용은 &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; 함수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">NumPy 1.7 및 1.8에서는 대각선의 사본을 계속 반환하지만이 사실에 따라 더 이상 사용되지 않습니다. 결과 배열에 대한 쓰기는 예전처럼 계속 작동하지만 FutureWarning이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.7 이상에서이 형식을 사용하면 &lt;code&gt;base_dtype&lt;/code&gt; 을 구조화 된 dtype으로 해석 할 수 있습니다. 이 dtype으로 생성 된 배열에는 기본 dtype &lt;code&gt;base_dtype&lt;/code&gt; 이 있지만 &lt;code&gt;new_dtype&lt;/code&gt; 에서 가져온 필드 및 플래그가 있습니다 . &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;레코드 배열&lt;/a&gt; 에서와 같이 사용자 정의 구조화 된 dtype을 만드는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">NumPy 버전 &amp;lt;= 1.9.0에서는 모든 NaN이거나 비어있는 슬라이스에 대해 Nan이 반환됩니다. 이후 버전에서는 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">NumPy에는 다양한 유형의 스칼라를 설명하기위한 24 개의 새로운 기본 Python 유형이 있습니다. 이 타입 디스크립터는 주로 CPython이 작성된 C 언어로 제공되는 타입을 기반으로하며, 파이썬 타입과 호환되는 몇 가지 추가 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPy에서 범용 함수는 &lt;code&gt;numpy.ufunc&lt;/code&gt; 클래스의 인스턴스입니다 . 많은 내장 함수가 컴파일 된 C 코드로 구현됩니다. 기본 ufunc는 스칼라에서 작동하지만 기본 요소는 하위 배열 (벡터, 행렬 등)이며 일반화되어 다른 차원에서 브로드 캐스트됩니다. &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; 팩토리 함수를 사용하여 사용자 정의 &lt;code&gt;ufunc&lt;/code&gt; 인스턴스를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpy의 조상 인 Numeric에서 방송은 ufuncobject.c에 깊게 묻힌 여러 줄의 코드로 구현되었습니다. NumPy에서는 방송 개념이 추상화되어 여러 곳에서 수행 될 수 있습니다. 방송은 &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; 함수에 의해 처리됩니다 . 이 기능을 사용하려면 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; (또는 이진 형식의 항목)를 전달해야합니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트 결과의 전체 크기와 함께 각 차원의 브로드 캐스트 수와 크기를 추적합니다. 또한 브로드 캐스트중인 어레이 수와 브로드 캐스트중인 각 어레이에 대한 반복기에 대한 포인터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">파이썬 3.0 &lt;code&gt;//&lt;/code&gt; 바닥 분할 연산자이고 &lt;code&gt;/&lt;/code&gt; 참 나눗셈 연산자. &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 함수 파이썬 진정한 분할 동일하다.</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">Python에서 &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; 은 &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; . 후자는 전자에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">연구에서 귀무 가설에 대한 특정 대안을 테스트하려면 Noncentral F 분포를 사용해야합니다. 귀무 가설에 대한 F 분포의 값을 초과하는 분포의 꼬리 부분을 계산해야합니다. 비교를 위해 두 확률 분포를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">2의 보수 시스템에서 음수는 2의 절대 값의 보수로 표시됩니다. 이것은 컴퓨터에서 부호있는 정수를 나타내는 가장 일반적인 방법입니다 &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N 비트 2의 보수 시스템은 범위 내의 모든 정수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">또한 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 는 스칼라 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">키워드 생성자 를 통해 &lt;code&gt;Configuration&lt;/code&gt; 생성자에 지정할 수있는 속성 외에도 &lt;code&gt;Configuration&lt;/code&gt; 인스턴스 ( &lt;code&gt;config&lt;/code&gt; 로 표시하자 )에는 설정 스크립트를 작성하는 데 유용한 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 클래스 외에도 여러 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">또한 &lt;em&gt;데이터&lt;/em&gt; 가 NULL이 아닌 경우 &lt;em&gt;보폭&lt;/em&gt; 도 제공 할 수 있습니다. 경우 &lt;em&gt;스트라이드&lt;/em&gt; 이다 &lt;code&gt;NULL&lt;/code&gt; 후 어레이 스트라이드가 C 스타일 연속적으로 계산된다 (디폴트) 또는 포트란 식 연속 ( &lt;em&gt;플래그는&lt;/em&gt; 0이 아닌 것이다 &lt;em&gt;데이터&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;em&gt;플래그&lt;/em&gt; 및 &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 인 제로 비 NULL의 &lt;em&gt;데이터&lt;/em&gt; ). 제공된 &lt;em&gt;치수&lt;/em&gt; 및 &lt;em&gt;보폭&lt;/em&gt; 은 새로 할당 된 치수에 복사되고 새 배열 객체에 대한 보폭 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">지금까지의 요소의 모든 실시 예에서 &lt;code&gt;a&lt;/code&gt; 한번에 반복자 하나에 의해 제공되는 모든 때문에 반복 논리 반복자 내부이다. 이것은 간단하고 편리하지만 효율적이지 않습니다. 더 나은 방법은 1 차원 가장 안쪽 루프를 반복자 외부의 코드로 옮기는 것입니다. 이런 식으로 NumPy의 벡터화 된 연산은 방문중인 요소의 더 큰 청크에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">거의 모든 경우 에이 함수 대신 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 사용해야합니다. 0d 배열에 대해서도 true를 반환하기 때문입니다. 이것은 python이 &lt;code&gt;dx&lt;/code&gt; 인수 의 스타일 을 &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt; 로, &lt;code&gt;bins&lt;/code&gt; 인수를 &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 오버로드하는 방식입니다 . 몇 가지 주요 차이점 :</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">최대 값이 여러 번 발생하는 경우 첫 번째 발생에 해당하는 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">최소값이 여러 번 발생하는 경우 첫 번째 발생에 해당하는 색인이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">복사 모드에서 '복사'는 작업자 별 플래그로 지정됩니다. 이것은 오퍼레이터마다 제어를 제공하기 위해 수행됩니다. 버퍼링 모드는 반복자 플래그로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">모든 경우에 '설명'키는 선택 사항이지만 다양한 응용 프로그램에 중요한 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">일반적으로 인덱스에 부울 배열이 포함되어 있으면 결과는 동일한 위치에 &lt;code&gt;obj.nonzero()&lt;/code&gt; 를 삽입 하고 위에서 설명한 정수 배열 인덱싱 메커니즘을 사용하는 것과 동일합니다. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; 는 &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">일반적으로 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 C- 시리즈를 다른 C- 시리즈의 (다항식) 나눗셈은 체비 쇼프 다항식 기준 세트에없는 몫 및 나머지 항을 생성합니다. 따라서, 이러한 결과를 C- 시리즈로 표현하기 위해서는, 전형적으로 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성하는 상기 기준 세트에 따라 결과를 &quot;재 투영&quot;할 필요가 있으며; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Hermite 계열을 다른 Hermite 계열로 (다항식) 나누면 Hermite 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서 이러한 결과를 Hermite 계열로 표현하려면 결과를 Hermite 기준 세트로 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Laguerre 계열을 다른 Laguerre 계열로 (다항식) 나누면 Laguerre 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서 이러한 결과를 Laguerre 계열로 표현하려면 Laguerre 기준 세트에 결과를 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Legendre 시리즈를 다른 Legendre 계열로 (다항식) 나누면 Legendre 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서 이러한 결과를 Legendre 시리즈로 표현하려면 Legendre 기준 세트에 결과를 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 체비 쇼프 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 C- 시리즈로 표현하기 위해서는, 전형적으로 &quot;직관적이지 않은 라이브&quot;(그러나 정확한) 결과를 생성하는 상기 기본 세트로 제품을 &quot;재 투영&quot;할 필요가있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 Hermite 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 Hermite 시리즈로 표현하기 위해서는 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 Laguerre 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 라게 레 (Laguerre) 시리즈로 표현하기 위해서는, 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 Legendre 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 Legendre 시리즈로 표현하기 위해서는, 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 C 시리즈를 차별화 한 결과는 C 시리즈 기본 세트로 &quot;재 투영&quot;되어야합니다. 따라서 일반적으로이 기능의 결과는 정확하지만 &quot;직관적이지 않습니다&quot;. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Hermite 시리즈를 차별화 한 결과는 Power 시리즈에서 동일한 작동과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Laguerre 시리즈를 차별화 한 결과는 파워 시리즈에서 동일한 작업과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Legendre 시리즈를 차별화 한 결과는 파워 시리즈에서 동일한 작업과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">일반적으로 이러한 유형 맵 시그니처를 원하는 위치에 구체적으로 지정하고 완료 한 후에 지워야합니다.</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">더 높은 차원에서, 예를 들어 이미지 분석 및 필터링을 위해 FFT가 사용됩니다. FFT의 계산 효율은 시간 영역에서의 컨볼 루션이 주파수 영역에서의 포인트 별 곱셈과 동등한 특성을 사용하여 큰 컨볼 루션을 더 빠르게 계산할 수 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ArrayLike&lt;/code&gt; 객체와 숫자 또는 numpy 배열 간의 상호 작용 에서 결과는 항상 다른 &lt;code&gt;ArrayLike&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">선형 공간에서 시퀀스는 &lt;code&gt;base ** start&lt;/code&gt; 에서 시작 ( &lt;code&gt;base&lt;/code&gt; 은 &lt;code&gt;start&lt;/code&gt; 의 거듭 제곱)에서 시작 하고 &lt;code&gt;base ** stop&lt;/code&gt; 끝납니다 (아래 &lt;code&gt;endpoint&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">많은 경우에 유효하지 않은 데이터가 있으면 데이터 세트가 불완전하거나 오염 될 수 있습니다. 예를 들어, 센서가 데이터를 기록하지 못했거나 유효하지 않은 값을 기록했을 수 있습니다. &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 마스크 배열을 도입하여이 문제를 해결할 수있는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">메모리 오버랩 검사에서 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; 가 활성화 된 피연산자 는 반복자 순서로만 액세스 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">일반 버퍼링에서 각 내부 루프의 크기는 버퍼 크기와 같거나 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 가 지정된 경우 더 클 수 있습니다. 경우 &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; 가&lt;/a&gt; 활성화되고 감소가 발생하는 내부 루프는 감소 구조에 따라 작아지고있다.</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">numpy 버전&amp;gt; = 1.7.0에서는 &lt;code&gt;basis&lt;/code&gt; 및 &lt;code&gt;cast&lt;/code&gt; 클래스 메소드도 사용할 수 있습니다. cast 메소드는 convert 메소드와 같이 작동하지만 base 메소드는 주어진 정도의 기본 다항식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">SciPy에 Python 패키지를 추가하려면 빌드 스크립트 ( &lt;code&gt;setup.py&lt;/code&gt; )가 특정 요구 사항을 충족해야합니다. 가장 중요한 요구 사항은 패키지 가 &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; 에 전달하기에 적합한 사전을 반환하는 &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 함수를 정의 해야 한다는 것 입니다. 이 사전의 구성을 단순화하기 위해 &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 은 아래에 설명 된 &lt;code&gt;Configuration&lt;/code&gt; 클래스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">다른 확장 모듈에서 C-API를 사용하려면 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 함수를 호출해야합니다. 확장 모듈이 단일 .c 파일에 자체 포함되어 있으면이 모든 것이 완료되어야합니다. 그러나 확장 모듈에 C-API가 필요한 여러 파일이 포함 된 경우 몇 가지 추가 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">오늘 획득 한 20 만 달러를 상환 (즉, 미래 가치가 0)하기 위해서는 매달 $ 1,854.02의 지불이 필요합니다. 이 예 는 기본값이 0 인 &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; 의&lt;/a&gt; 사용법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">다시 말해, 각 항목 &lt;code&gt;out[i,j,...,:]&lt;/code&gt; 은 분포에서 도출 된 N 차원 값입니다.</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">즉, info 사용법은 blas_info 및 co를 사용할 때와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">이 예에서는 입력 배열을 복잡한 데이터 유형으로 처리하여 음수의 제곱근을 취할 수 있습니다. 복사 또는 버퍼링 모드를 사용하지 않으면 데이터 유형이 정확하게 일치하지 않으면 반복자가 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">인플레 이스 연산은 두 피연산자의 데이터 유형에 의해 결정된 정밀도를 사용하여 계산을 수행하지만 필요한 경우 결과를 자동으로 다운 캐스트하여 배열에 다시 맞출 수 있습니다. 따라서 혼합 정밀도 계산의 경우 &lt;code&gt;A {op}= B&lt;/code&gt; 는 &lt;code&gt;A = A {op} B&lt;/code&gt; 와 다를 수 있습니다 . 예를 들어, &lt;code&gt;a = ones((3,3))&lt;/code&gt; 이라고 가정 하십시오 . 그리고, &lt;code&gt;a += 3j&lt;/code&gt; 다르다 &lt;code&gt;a = a + 3j&lt;/code&gt; : 그들은 모두 동일한 계산을 수행하면서 &lt;code&gt;a += 3&lt;/code&gt; 캐스트 다시 맞는 결과 반면, &lt;code&gt;a = a + 3j&lt;/code&gt; 재 바인딩 이름 받는을 결과. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">이전 버전의 NumPy에서 datetime64 유형은 항상 UTC로 시간을 저장했습니다. 기본적으로 문자열에서 datetime64 객체를 만들거나 인쇄하면 현지 시간으로 또는 현지 시간으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">행 주요 C 스타일 순서에서는 2 차원에서 행 인덱스가 가장 느리게 변하고 열 인덱스가 가장 빠릅니다. 이것은 여러 차원으로 일반화 될 수 있는데, 여기서 행-주요 순서는 첫 번째 축을 따라 인덱스가 가장 느리게 변하고 마지막으로 가장 빠른 인덱스를 나타냅니다. 열의 주요한 포트란 스타일 인덱스 순서와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">단 정밀도에서는 &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 이 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">단 정밀도에서는 std ()가 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">단 정밀도에서 var ()는 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">경우에 따라 원하는 답변을 얻으려면 롤과 오프셋을 적절히 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">구조화 된 배열 및 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 인터페이스 와 같은 일부 경우 에는 객체를 이해하기 위해 데이터 유형을 사용해야합니다. 필요한 경우 'requested_dtype'에 대한 설명을 제공하고 그렇지 않으면 NULL을 제공하십시오. 이 참조는 도난되지 않았습니다. 또한 요청 된 dtype이 입력의 해석을 수정하지 않으면 out_dtype은 여전히 ​​'requested_dtype'에 전달 된 dtype이 아니라 객체의 &quot;고유&quot;dtype을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">향후 릴리스에서는 읽기 / 쓰기보기를 반환하고 반환 된 배열에 쓰면 원래 배열이 변경됩니다. 반환 된 배열은 입력 배열과 같은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">경우에 따라 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 매크로를 사용 하여 고유 한 유형에 대한 유형 맵을 구현할 수 있습니다. &lt;a href=&quot;#other-common-types-bool&quot;&gt;다른 일반적인 유형 : bool&lt;/a&gt; 또는 &lt;a href=&quot;#other-common-types-complex&quot;&gt;기타 일반적인 유형 : 복합&lt;/a&gt; 섹션을 참조하십시오 . 또 다른 상황은 치수가 &lt;code&gt;int&lt;/code&gt; 이외의 유형 인 경우입니다 ( 예 : &lt;code&gt;long&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">1 차원 및 0 차원에서는 인덱싱 및 희소 키워드가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">배정 밀도 테스트의 경우 Python 함수 &lt;code&gt;Vector.doubleLength&lt;/code&gt; 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">일반적인 2 차원 경우 (N = 1), 블록 구조를 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">결국, 포트란 또는 C에 대해 수행하는 작업은 데이터를 재정렬하지 않거나 색인 규칙을 유지하지 않고 어느 것이 더 중요한지에 달려 있습니다. 큰 이미지의 경우 데이터 순서를 바꾸면 비용이 많이들 수 있으며이를 피하기 위해 인덱싱 규칙이 바뀌는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">파일에서이 오프셋에서 배열 데이터가 시작됩니다. &lt;code&gt;offset&lt;/code&gt; 은 바이트 단위로 측정 되므로 일반적으로 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 의 바이트 크기의 배수 여야 합니다. 때 &lt;code&gt;mode != 'r'&lt;/code&gt; , 파일의 끝을 넘어도 긍정적 인 오프셋이 유효; 추가 데이터를 수용 할 수 있도록 파일이 확장됩니다. &lt;code&gt;filename&lt;/code&gt; 이 파일 포인터 &lt;code&gt;fp&lt;/code&gt; 이고 &lt;code&gt;fp.tell() != 0&lt;/code&gt; &lt;code&gt;memmap&lt;/code&gt; 기본적으로 memmap 은 파일 시작 부분에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">첫 번째 경우 적분의 하한이 -1로 설정되고 적분 상수가 0으로 설정됩니다. 두 번째 경우에도 적분 상수도 1로 설정됩니다. 유일한 옵션은 다항식이 구별되는 횟수이기 때문에 차별화가 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">첫 번째 경우, 고급 인덱싱 작업으로 인해 생성 된 차원이 결과 배열에서 먼저 나오고 그 후 부분 공간 크기로 나타납니다. 두 번째 경우, 고급 인덱싱 작업의 차원은 초기 배열과 같은 위치에 결과 배열에 삽입됩니다 (후자의 논리는 단순 고급 인덱싱이 슬라이싱과 같은 방식으로 작동하도록하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">다음 설명에서는 위에 나열된 C 데이터 유형 중 하나 일 수 있는 일반 &lt;code&gt;DATA_TYPE&lt;/code&gt; 및 여러 유형의 정수 중 하나 &lt;code&gt;DIM_TYPE&lt;/code&gt; 하는 DIM_TYPE 을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">과거에는 대부분의 구현에서 &lt;code&gt;PyCObject&lt;/code&gt; 자체 의 &quot;desc&quot;멤버 ( 위 의 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조 의 &quot;descr&quot;멤버와 혼동하지 마십시오. 두 가지 별도의 요소 임)를 사용하여 인터페이스를 노출하는 오브젝트에 대한 포인터를 보유했습니다. 이것은 이제 인터페이스의 명백한 부분입니다. &lt;code&gt;PyCObject&lt;/code&gt; _FromVoidPtrAndDesc 를 사용하여 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 작성할 때 오브젝트에 대한 참조를 소유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">-1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 범위에서는 +/- 1 사이에있는 등가 함수가 훌륭합니다. -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 범위에 대한 동일한 플롯 은 매우 다르게 보입니다.</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">가장 간단한 경우에는 &lt;em&gt;하나의&lt;/em&gt; 고급 인덱스 만 있습니다. 예를 들어 단일 고급 인덱스는 슬라이스를 대체 할 수 있으며 결과 배열은 동일하지만 사본이며 다른 메모리 레이아웃을 가질 수 있습니다. 가능하면 슬라이스가 바람직하다.</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">아래 표에서 &lt;code&gt;platform?&lt;/code&gt; 유형이 모든 플랫폼에서 사용 가능하지 않을 수 있음을 의미합니다. 다른 C 또는 Python 유형과의 호환성이 표시됩니다. 두 가지 유형은 데이터의 크기가 동일하고 동일한 방식으로 해석되는 경우 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">이 계산에서는 각 스트림에서 가져온 숫자의 양을 무시할 수 있습니다. 우리가 제공하는 각 PRNG에는 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 풀이 조금씩 다를 경우 겹침을 피하기위한 추가 보호 기능이 내장되어 있습니다. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;linalg.solve&lt;/code&gt; 및 &lt;code&gt;linalg.inv&lt;/code&gt; 를 사용하여 여러 데이터 유형의 행렬을 사용하여 선형 대수 문제 해결을 테스트하려고했습니다 . &lt;code&gt;LinalgTestCase&lt;/code&gt; 에서 일반적인 테스트 사례 (단 정밀도, 배정 밀도 등의 행렬)가 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">이 장에서는 기능별로 그룹화 된 일상적인 docstring이 제공됩니다. 많은 docstring에는 루틴의 기본 사용법을 보여주는 예제 코드가 포함되어 있습니다. 예제에서는 NumPy를 다음과 같이 가져 왔다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">이 예에서 &lt;code&gt;a&lt;/code&gt; 가 ndarray 인 경우 &quot;fancy&quot;색인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">이 예제에서 간격도 지정됩니다 : 축 = 0에 균일하고 축 = 1에 비 균일</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">이 예제에서 실제 입력은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 허미 시안 (Hermitian) 인 FFT, 즉 실수 부분에서 대칭이고 허수 부분에서 반대 칭 인 FFT를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">2 차원에서 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">NumPy 1.6 및 이전 버전에서 다음 플래그에는 _ARRAY_ 매크로 네임 스페이스가 없습니다. 상수 이름의 해당 형식은 1.7에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">1.7 이전의 NumPy 버전에서이 함수는 항상 대각선에 값의 사본을 포함하는 새로운 독립 배열을 리턴했습니다.</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">내부 배열</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">제자리 배열은 제자리에서 수정되는 배열로 정의됩니다. 입력 값이 사용되거나 사용되지 않을 수 있지만 함수가 반환 될 때의 값은 중요합니다. 제공된 Python 인수는 필수 유형의 NumPy 배열이어야합니다. 전체 서명은</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">전체 정렬.</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">배열의 다음 요소를 가리 키도록 &lt;em&gt;반복자&lt;/em&gt; 와 인덱스 및 dataptr 멤버를 증가시킵니다 . 배열이 (C 스타일) 연속이 아닌 경우 N 차원 좌표 배열도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">항목 0과 1을 늘리고 항목 2를 두 번 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">다차원 인덱스를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">사실, 목록과 다른 시퀀스에서 파이썬 인덱싱은 자연적으로 외부에서 내부 순서로 이어진다는 것입니다 (첫 번째 인덱스는 가장 큰 그룹화, 다음은 가장 큰 그룹화, 마지막은 가장 작은 요소). 이미지 데이터는 일반적으로 행별로 저장되므로 마지막으로 색인이 생성 된 행 내의 위치에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">독립 스트림</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">대각선 색인 : 0 (기본값)은 주 대각선을 나타내고 양수 값은 상단 대각선을, 음수 값은 하단 대각선을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">대각선의 인덱스 : 0은 주 대각선, 양수 값은 상단 대각선을, 음수 값은 하단 대각선을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 최대 요소의 인덱스 :</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">축을 따른 최대 값의 인덱스.</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">축을 따른 최소값의 인덱스.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">인덱싱 &lt;code&gt;x['field-name']&lt;/code&gt; 새 반환 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;뷰&lt;/a&gt; 와 동일한 형상 인 배열로 &lt;em&gt;(X)를&lt;/em&gt; (필드는 서브 어레이 인 경우는 제외)이지만 데이터 유형의 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 지정된 필드에 데이터의 일부만 포함합니다. 또한 &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;레코드 배열&lt;/a&gt; 스칼라를 이런 식으로 &quot;인덱싱&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">인덱싱 및 슬라이싱</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">인덱싱 배열</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 와 &lt;em&gt;같은&lt;/em&gt; 필드 이름 목록을 사용하여 구조화 된 배열로 인덱싱 할 수도 있습니다 . NumPy 1.16부터는 해당 필드 만 포함하는보기를 리턴합니다. 이전 버전의 numpy에서는 복사본을 반환했습니다. 다중 필드 인덱싱에 대한 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;구조적 배열에&lt;/a&gt; 대한 사용자 안내서 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">인덱싱 루틴</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">인덱싱 같은 작업</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">반복자의 사용자가 &lt;code&gt;op[i]&lt;/code&gt; 를 읽거나 쓰는 방법을 나타냅니다 . 피연산자마다 이러한 플래그 중 하나를 지정해야합니다. 사용 &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; 또는 &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 을 트리거 할 수있는 사용자 제공 피연산자 &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; 의 의미. &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 가 호출 되면 데이터는 원래 배열로 다시 쓰여집니다 .</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">지정된 축을 따라 제거 할 하위 배열의 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">이 데이터 유형의 배열을 산세하기 전에 목록으로 변환해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">작성시이 데이터 유형의 메모리를 초기화 (0으로 설정)해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">크기가 0 인 배열이 허용되어야 함을 나타냅니다. 일반적인 반복 루프는 크기가 0 인 배열에서는 자연스럽게 작동하지 않으므로 반복 루프에 들어가기 전에 IterSize가 0보다 큰지 확인해야합니다. 현재 피연산자 만 검사되며 강제 모양은 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">참조 유형 (객체 배열 또는 객체 유형을 포함하는 구조화 된 배열)을 가진 배열이 반복자에서 승인되어 사용될 수 있음을 나타냅니다. 이 플래그를 사용하면 호출자는 &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; 가 true 인지 확인해야하며 ,이 경우 반복 중에 GIL을 해제하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">이 데이터 유형의 항목이 참조 계산되어야 함을 나타냅니다 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">이 피연산자는 요소에 &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt; 플래그가 적용된 피연산자에 쓸 때 요소를 선택하는 데 사용할 마스크임을 나타냅니다 . 한 피연산자에만 &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 플래그가 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">항목이 다른 데이터 유형에 대한 포인터임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">이 데이터 유형에 액세스하는 동안 Python C-API가 필요함을 나타냅니다 (따라서 배열 액세스가 필요한 경우 GIL을 포기하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">간격에 오른쪽 또는 왼쪽 빈 가장자리가 포함되는지 여부를 나타냅니다. 기본 동작은 간격이 오른쪽 가장자리를 포함하지 않음을 나타내는 (right == False)입니다. 이 경우 왼쪽 빈 끝이 열려 있습니다. 즉, bins [i-1] &amp;lt;= x &amp;lt;bins [i]는 단조롭게 증가하는 빈의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">요소별로 인덱스를 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 상위 삼각형에 대한 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">0이 아닌 요소의 인덱스.</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">0이 아닌 요소의 인덱스. 인덱스는 요소별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 최소 요소 인덱스 :</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 정렬 된 요소 인덱스 :</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 각 1d 슬라이스를 따라 변경되는 인덱스 입니다. 이 편곡의 크기와 일치해야하지만, 니켈과 뉴저지의 치수에 대한 방송을 일을 할 수있다 &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 각 1d 슬라이스를 따라갈 인덱스 입니다. 이 편곡의 크기와 일치해야하지만, 크기 Ni 및 뉴저지 만에 방송에 필요한 &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">간접적 인 부분 정렬.</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">간접 파티션.</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">간접 정렬.</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">여러 키에 대한 안정적인 안정적인 정렬</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">여러 키를 사용한 간접 안정적인 정렬.</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">개별 값은 기본적으로 공백이 제거되지 않습니다. 사용자 정의 변환기를 사용할 때 함수가 공백을 제거하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;get_info&lt;/code&gt; 함수에서 정보를 쉽게 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">기본 데이터 요소의 해석에 대한 정보 (dtype 객체를 통해) 기본 데이터 요소는 int 또는 float만큼 단순하거나 복합 객체 (예 : struct-like), 고정 문자 필드 또는 Python 객체 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형의&lt;/a&gt; 하위 데이터 유형에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">배열의 메모리 레이아웃에 대한 정보</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">모든 함수 포인터와 멤버를 &lt;code&gt;NULL&lt;/code&gt; 로 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">내부 제품</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">두 어레이의 내부 제품.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">대체 파티션.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">적절한 정렬.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">입력 1D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">마스크가 필요한 입력 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">Input &lt;code&gt;MaskedArray&lt;/code&gt; , 또는 ndarray 또는 해당 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">입력과 출력</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">입력 인수는 모든 유형과 모양이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">배열을도 단위로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">라디안으로 입력 배열.</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">크기가 1 인 입력 배열.</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">대문자로 입력 할 문자열 배열을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 과 크기가 같은 입력 배열 .</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">무시할 nan 값을 포함하는 배열로 변환 할 수있는 입력 배열 또는 객체</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">무시할 nan 값을 포함하는 배열로 변환 할 수있는 입력 배열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">배열로 변환 할 수있는 입력 배열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">비닝 할 입력 배열입니다. NumPy 1.10.0 이전에는이 ​​배열이 1 차원이어야했지만 이제는 모든 모양을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">행렬식을 계산할 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">통합 할 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">datetime 또는 timedelta 데이터 형식의 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">입력 배열, ndarray의 (하위 클래스)</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">입력 배열, 복잡 할 수 있음</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">입력 배열은 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">대각선을 가져 오는 입력 배열.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">입력 배열은 2 차원 정사각형 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">입력 배열은 2D 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">실제 입력 배열.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;axis&lt;/code&gt; 것도없고, &lt;code&gt;x&lt;/code&gt; 1-D 또는 2-D이어야한다.</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;sorter&lt;/code&gt; 없음입니다, 그렇지 않으면, 오름차순으로 정렬해야 &lt;code&gt;sorter&lt;/code&gt; 는 그런 종류의 인덱스의 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">입력 배열. 의 요소 &lt;code&gt;a&lt;/code&gt; 에 의해 지정된 순서대로 판독 &lt;code&gt;order&lt;/code&gt; 및 1-D 어레이로 포장.</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">입력 배열. &lt;code&gt;axis&lt;/code&gt; 이 지정되어 있지 않으면 1D가 아닌 경우 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">입력 배열은 루틴으로 전달되지만 해당 위치에서 변경되거나 사용자에게 반환되지 않는 데이터 배열로 정의됩니다. 따라서 Python 입력 배열은 요청 된 유형의 배열로 변환 할 수있는 거의 모든 Python 시퀀스 (예 : 목록) 일 수 있습니다. 입력 배열 서명은</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">같은 모양의 입력 배열.</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">비교할 입력 배열.</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">곱할 입력 배열입니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">비교할 입력 배열.</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">입력 배열, 스칼라는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">입력 배열. 아직 1D가 아닌 경우 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">입력 배열. 아직 1D가 아닌 경우 전개됩니다.</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">기간 당 입력 현금 흐름. 일반적으로 순 &quot;예금&quot;은 음수이고 순 &quot;인출&quot;은 양수입니다. 따라서, 예를 들어, 초기 투자를 나타내는 적어도 제 1 &lt;code&gt;values&lt;/code&gt; 요소 는 전형적으로 음일 것이다.</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">입력 클래스. 클래스의 튜플 인 경우 &lt;code&gt;arg1&lt;/code&gt; 이 튜플 요소의 하위 클래스 인 경우 True가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">입력 클래스. &lt;code&gt;arg1&lt;/code&gt; 이 &lt;code&gt;arg2&lt;/code&gt; 의 서브 클래스 인 경우 True가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">입력 비교 배열.</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">마스크 배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록, ndarray 및 마스크 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다. 성공에는 NaN이나 Infs가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 스칼라, 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">평평하게되어 입력의 &lt;code&gt;k&lt;/code&gt; 번째 대각선으로 설정되는 입력 데이터 .</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">입력 데이터. 문자열 인 경우 현재 범위의 변수는 이름으로 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">입력 데이터. 히스토그램은 평평한 배열을 통해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">입력 마스크.</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">입력이 유효한 마스크로 간주 되려면 ndarray이거나 유사한 속성을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">정보를 얻을 객체 또는 이름을 입력하십시오. 경우 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; NumPy와 목적, 그 문서화 문자열이 주어진다. 문자열 인 경우 사용 가능한 모듈에서 일치하는 객체를 검색합니다. None이면 &lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt; 자체 에 대한 정보 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">입력 객체. 이것은 어떤 객체 (함수, 클래스, 모듈 등) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">입력 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">다항식을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">입력 순서.</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">입력 값.</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">입력 값. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">입력 벡터 또는 행렬 스택.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">입력 전용, 전체, argout, argoutview 및 메모리 관리 argoutview 동작.</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">배열을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">확장 배열 모양으로 &lt;code&gt;axis&lt;/code&gt; 위치에 나타날 새 축을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">배열에 요소를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">스칼라를 배열에 삽입하십시오 (가능한 경우 스칼라가 배열의 dtype으로 캐스트 됨)</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">주어진 인덱스 앞에 주어진 축을 따라 값을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">치수 삽입, 제거 및 결합 및 기존 크기 조정</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">요소 사이에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">배열에 데이터 삽입</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">텍스트가 &lt;code&gt;max_line_width&lt;/code&gt; 보다 긴 경우 줄 바꿈을 삽입합니다 . 기본값은 &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">배열 검사</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스는있는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">Python 클래스의 동작을 정의하는 특수 메소드 이름 대신 원하는 결과를 구현하는 함수를 가리키는 &quot;함수 테이블&quot;이 있습니다. Python 2.2부터 PyTypeObject 자체가 동적으로 바뀌어 C의 다른 C 유형에서 &quot;하위 유형&quot;이 될 수 있고 Python에서 하위 클래스가 될 수있는 C 유형을 허용합니다. 자식 형식은 부모로부터 특성과 메서드를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">전체 공분산 행렬을 지정하는 대신 널리 사용되는 근사값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">파이썬의 전통적인 'floor division'대신에 이것은 진정한 division을 반환합니다. 완전 분할은 입력 유형에 관계없이 최상의 응답을 제공하도록 출력 유형을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">정수형 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">정수 배열 인덱싱을 사용하면 &lt;em&gt;N&lt;/em&gt; 차원 인덱스를 기준으로 배열에서 임의의 항목을 선택할 수 있습니다 . 각 정수 배열은 해당 차원에 대한 여러 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">정수 지수 2. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">이 dtype이 내장 dtype과 어떤 관련이 있는지를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">정수 성능은 비슷한 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">포인터를 담을 수있는 정수</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 필수 부분 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">주어진 축을 따라 &lt;code&gt;y&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )를 적분합니다 .</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">Hermite 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Hermite_e 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">다항식을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">합성 사다리꼴 규칙을 사용하여 주어진 축을 따라 적분합니다.</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">적분 상수. &lt;code&gt;lbnd&lt;/code&gt; 의 첫 번째 적분 값이 목록의 첫 번째 값이고 &lt;code&gt;lbnd&lt;/code&gt; 의 두 번째 적분 값이 두 번째 값 등입니다. &lt;code&gt;k == []&lt;/code&gt; (기본값)이면 모든 상수가 0으로 설정됩니다. &lt;code&gt;m == 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">적분 상수. 0의 첫 번째 적분 값이 목록의 첫 번째 값이고, 0의 두 번째 적분 값이 두 번째 값 등입니다. &lt;code&gt;k == []&lt;/code&gt; (기본값)이면 모든 상수가 0으로 설정됩니다. &lt;code&gt;m == 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">적분 상수. 첫 번째 상수는 첫 번째 적분에 적용되고 두 번째 상수는 두 번째 정수에 적용됩니다. 값 목록의 길이 는 &lt;code&gt;m&lt;/code&gt; 보다 작거나 같아야하며 누락 된 값은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">적분 상수. 그것들은 통합의 순서로 주어진다 : 최상위 순서에 해당하는 것이 우선이다.</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">합성 사다리꼴 규칙을 사용한 배열 값의 통합.</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">배열의 두 축을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">일생 동안의 대출 변경 또는 대출에 대한 지불이자. &lt;code&gt;per&lt;/code&gt; 이자 금액을 계산하기 위해 지불 기간입니다.</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">지불의이자 부분. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한이자 지불을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">현금 흐름에 지불 된 이자율</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">재투자시 현금 흐름에 대한 이자율</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">내부 유연성</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">주기적 입력 값에 대한 내부 수익률.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">ndarray의 내부 메모리 레이아웃</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">numpy 배열의 내부 조직</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">내부적으로 사용되는 구조</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">내부적으로 버퍼는 잘못 정렬 된 데이터, 스왑 된 데이터 및 한 데이터 유형에서 다른 데이터 유형으로 변환해야하는 데이터에 사용됩니다. 내부 버퍼의 크기는 스레드별로 설정할 수 있습니다. 최대 수</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">내부적으로 코드는 주로 메모리 관리를 위해 일부 추가 Python 객체를 사용합니다. 이러한 유형은 Python에서 직접 액세스 할 수 없으며 C-API에 노출되지 않습니다. 여기에는 코드 이해에 대한 완전성 및 지원을 위해서만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">내부적으로 이러한 #define은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">첫 번째 종류의 체비 쇼프 지점에서 함수를 보간합니다.</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">체비 쇼프 인스턴스 보간.</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">주기적 x 좌표를 사용한 보간 :</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">버퍼를 1 차원 배열로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">입력을 행렬로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">인터럽트 처리</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">유효하지 않은 데이터는 &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 등의 값을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">잘못된 작업 : 결과는 표현 가능한 숫자가 아니며 일반적으로 NaN이 생성되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 탄젠트.</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">요소 별 역사 인.</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">여러 행렬의 역을 한 번에 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; ,하지만 더 사용할 수 있도록 &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">리버스 엔지니어링은 간단합니다. 데이터 세트는 종종 데이터 세트를 생성 한 프로그램보다 오래 지속됩니다. 유능한 개발자는 자신이 선호하는 프로그래밍 언어로 솔루션을 만들어서 많은 문서없이 제공된 대부분의 &lt;code&gt;.npy&lt;/code&gt; 파일 을 읽을 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">주어진 함수가 오버로드하는 방법을 알고 있습니까?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde 행렬의 순위가 &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 때 polyfit에 의해 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde 행렬의 순위가 &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 때 polyfit에 의해 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">설계 행렬에 순위가 부족할 때 chebfit이 발행합니다.</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">두 도메인이 일치하지 않는 경우 일반 Poly 클래스에서 발행합니다.</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; &lt;/a&gt; 장소에서도 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">EPS의 일반화로 간주 될 수 있습니다. &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; , &lt;code&gt;x + spacing(x)&lt;/code&gt; 와 x 사이에 표현 가능한 숫자가 없어야 합니다. 유한 x.</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">컨볼 루션</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">그것은 경우에 표시 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">지수 인수의 부호와 기본 정규화에 의해 정방향 변환과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">다음과 같은 구조로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">확률 밀도 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">numpy 배열을 다루는 방법에 대해 조금 이해하면 numpy를 더 잘 이해하는 데 도움이됩니다. 이 섹션은 자세하게 설명하지 않습니다. 자세한 내용을 이해하려는 사람들은 Travis Oliphant의 &quot;Guide to NumPy&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">모든 인덱스 것으로한다 &lt;code&gt;x&lt;/code&gt; 함께 우측의 인덱스와, 제품에 합산된다 로서 이루어, 예를 들면, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">다항식을 처리 하기 위해 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체 를 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">다항식을 처리 하기 위해 &lt;code&gt;poly1d&lt;/code&gt; 객체 를 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">또한 동등 &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">배열을 조작 할 때마다 변경 될 수 있는 플래그를 &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt; 를 사용하여 업데이트 된 상태로 유지하는 것이 중요합니다 . 이 플래그의 상태에 의존하는 NumPy의 이후 계산은 계산을 반복하여 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">반복자가 종료되면 댕글 링 참조 (예 : &lt;code&gt;x&lt;/code&gt; )가 원래 데이터 &lt;code&gt;a&lt;/code&gt; 와 데이터를 공유하거나 공유하지 않을 수 있습니다 . 라이트 백 의미가 활성 인 경우에 경우, 즉 &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; 이 있다 &lt;code&gt;True&lt;/code&gt; , 그 반복자 사이의 연결이 끊어 것이다 종료 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 쓰기하지, &lt;code&gt;x&lt;/code&gt; 로는 더 이상 쓰기 . 쓰기 저장 시맨틱이 활성화되지 않은 경우 &lt;code&gt;x.data&lt;/code&gt; 는 여전히 &lt;code&gt;a.data&lt;/code&gt; 의 일부를 가리키며 하나에 쓰면 다른 쪽에도 영향을 미칩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">모든 다항식 인스턴스는 변경할 수 없으므로 확장 연산 ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등) 및 다항식 인스턴스의 불변성을 위반하는 기타 기능은 의도적으로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">그것은 언어학자인 조지 킹슬리 지프 (George Kingsley Zipf)의 이름을 따서 명명되었습니다.</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">더 이상이 클래스를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">선형 대수에도이 클래스를 사용하지 않는 것이 좋습니다. 대신 일반 배열을 사용하십시오. 수업은 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">데이터를 복사하지 않고 배열의 모양을 변경할 수있는 것은 아닙니다. 데이터를 복사 할 때 오류가 발생하도록하려면 배열의 모양 속성에 새 모양을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">베이지안 추론 및 순서 통계에서 종종 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">이는 Weibull 및 Frechet을 포함하는 GEV (Generalized Extreme Value) 배포판 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;] # doctest : + SKIP를 사용하여 라이브러리를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">setup.py 스크립트에서 config_fc 옵션을 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;edge_order&lt;/code&gt; 를 사용하여 경계를 처리하는 방법을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">보다 일관된 부동 소수점 비교를 위해이 함수 대신 &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">매트릭스 서브 클래스를 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 아래 설명과 같이 행렬과 일반 배열을 일관되게 처리하는 함수를 작성하는 것은 매우 어렵습니다. 현재 이들은 주로 &lt;code&gt;scipy.sparse&lt;/code&gt; 와 상호 작용하는 데 사용됩니다 . 그러나이 사용에 대한 대안을 제공하고 결국 &lt;code&gt;matrix&lt;/code&gt; 서브 클래스를 제거하기를 희망합니다 .</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">예를 들어 보험 청구의 초과보고를 모델링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 에서 상속되지 않지만 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;Ufuncs를 재정의하는 메커니즘에&lt;/a&gt; 설명 된 배열과 같은 산술 및 numpy 범용 함수를 지원 해야하는 클래스를 작성하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">다음과 같은 경우 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">다항식 인스턴스를 명시 적으로 사용하는 것이 항상 편리한 것은 아니므로 튜플, 목록, 배열 및 스칼라는 산술 연산에서 자동으로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">1에 4 번, 2 번에 1 번 착륙했습니다.</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 구현 을 등록하기 위해 사용자 정의 데코레이터 ( 아래 &lt;code&gt;implements&lt;/code&gt; ) 를 정의하는 것이 편리 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">이 인터페이스를 사용하여 구조화 된 유형을 설명 할 수 있음을 분명히해야합니다.</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">2D에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">COW (Copy-On-Write) 배열에 할당 할 수 있지만 값은 배열의 메모리 사본에만 기록되고 디스크에는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">컴파일러와 독립적 인 방식으로 해당 config_fc 옵션 만 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">품목 선택 및 조작</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">이 데이터 형식의 배열 항목 은 두 개의 필드가 있는 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;배열 스칼라&lt;/a&gt; 형식으로 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">배열 반복</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">특정 데이터 유형으로 반복</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">배열을 반복</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">반복은 행 전공 C 스타일 순서로 수행됩니다 (마지막 색인이 가장 빠름). 반복자는 기본 슬라이싱 또는 고급 인덱싱을 사용하여 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">반복자 데이터 유형</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">반복자 플래그 &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">반복자 플래그 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">방송용 이터레이터</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">반복기 할당 출력 어레이</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">반복자는 배열 처리를위한 강력한 개념입니다. 기본적으로 반복자는 일반화 된 for-loop를 구현합니다. 경우 &lt;em&gt;myiter는&lt;/em&gt; 반복자 객체, 다음 파이썬 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser,&amp;ldquo;디지털 필터&amp;rdquo;&amp;ndash;&amp;ldquo;디지털 컴퓨터를 통한 시스템 분석&amp;rdquo;의 7 장, 편집자 : FF Kuo 및 JF Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon, Mark A. Moraes, Ron O. Dror 및 David E. Shaw,&amp;ldquo;병렬 난수 : 1, 2, 3만큼 쉬움&amp;rdquo;, 고성능 컴퓨팅, 네트워킹, 스토리지 및 분석 (SC11), 뉴욕, NY : ACM, 2011.</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">새 축을 따라 일련의 배열을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">기존 축을 따라 일련의 배열을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">일련의 배열을 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 의 객체 시퀀스를 &lt;em&gt;축을&lt;/em&gt; 따라 단일 배열로 결합합니다. 치수 또는 유형이 호환되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">배열 결합</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">2019 년 7 월 26 일</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">점프 크기</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">BitGenerator 상태 점프</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">상태 그대로 점프로 점프합니다 * 210306068529402873165736369884012333109 난수가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">그냥 경우처럼 같은 특별한 방법 내장에 대한 &lt;code&gt;__add__&lt;/code&gt; 제대로 작성 &lt;code&gt;__array_function__&lt;/code&gt; 의 방법은 항상 반환해야 &lt;code&gt;NotImplemented&lt;/code&gt; 를 알 수없는 유형이 발견 될 때. 그렇지 않으면 작업에 개체 중 하나가 포함되어 있으면 다른 개체에서 NumPy 함수를 올바르게 재정의하는 것이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Philox 상태에서 사용하는 키입니다. 시드와 달리 키의 값은 직접 설정됩니다. [0, 2 ** 128)의 Python int 또는 2 요소 uint64 배열 일 수 있습니다. &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;seed&lt;/code&gt; 를 모두 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">키워드 인수가 &lt;code&gt;func&lt;/code&gt; 에 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; 호출에 사용 된 키워드 인수 는 실행시 함수에 전달됩니다. 즉 &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; 이면 각 함수는 &lt;code&gt;f(x, alpha=1)&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">키워드 인수. 유효한 키워드는 가능한 부동 소수점 예외입니다. 각 키워드에는 특정 오류에 대한 처리를 정의하는 문자열 값이 있어야합니다. 가능한 값은 { 'ignore', 'warn', 'raise', 'call', 'print', 'log'}입니다.</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">키워드 이외의 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 전달됩니다 &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">키워드 이외의 &lt;code&gt;dtype&lt;/code&gt; 전달됩니다 &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">정보를 얻을 수있는 부동 소수점 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">알려진 버그 :</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">알려진 실패 및 테스트 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Kotz, Samuel 등 알. &amp;ldquo;Laplace 배포 및 일반화,&amp;rdquo;Birkhauser, 2001.</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">두 배열의 크로네 커 곱.</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman,&amp;ldquo;관리 재무 원칙, 요약&amp;rdquo;, 3 판, Addison-Wesley, 2003, pg. 346.</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman,&amp;ldquo;관리 재무 원칙, 요약&amp;rdquo;, 3 판, Addison-Wesley, 2003, pg. 348.</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">테스트에 '느린'레이블을 붙입니다.</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">라벨링 테스트</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">라게 레 클래스</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre 모듈 ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Laguerre 모듈 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서대로 Laguerre 계수, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Laguerre 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">라게 레 시리즈</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">적분의 Laguerre 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">Laguerre 시리즈의 힘.</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">Laguerre 계열의 파생 상품.</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Laguerre 계열.</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">Laguerre 무게 기능.</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">이 매뉴얼의 대부분은 Travis E. Oliphant의 &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;NumPy에 대한 안내서&lt;/a&gt; (2008 년 8 월에 Public Domain에 넉넉하게 도입 됨)에서 시작되었습니다. 많은 기능에 대한 참조 문서는 NumPy의 많은 기고자 및 개발자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">사용자가 설정 가능한 버퍼에 허용되는 최대 크기입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
