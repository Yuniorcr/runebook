<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="e93d86b822e12c4d9ce33d7af413f341c5867140" translate="yes" xml:space="preserve">
          <source>Shared table support for Nim. Use plain old non GC'ed keys and values or you'll be in trouble. Uses a single lock to protect the table, lockfree implementations welcome but if lock contention is so high that you need a lockfree hash table, you're doing it wrong.</source>
          <target state="translated">Nim에 대한 공유 테이블 지원 GC가 아닌 일반 키와 값을 사용하면 문제가 발생할 수 있습니다. 단일 잠금을 사용하여 테이블을 보호하고 잠금이없는 구현은 환영하지만 잠금 경합이 너무 커서 잠금이없는 해시 테이블이 필요한 경우 잘못하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec91193d5f88e5c879887f1193cd72ef6a694d25" translate="yes" xml:space="preserve">
          <source>Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</source>
          <target state="translated">가장 왼쪽 비트의 사본을 왼쪽에서 밀어 오른쪽으로 이동하고 가장 오른쪽 비트가 떨어지도록합니다.</target>
        </trans-unit>
        <trans-unit id="05a85db16fbdbc68d6790c4c1c6d2377589785de" translate="yes" xml:space="preserve">
          <source>Short description of Nim's modules</source>
          <target state="translated">님의 모듈에 대한 간단한 설명</target>
        </trans-unit>
        <trans-unit id="3aea3a391a6ebfd7b559fa27a009254bdee9654e" translate="yes" xml:space="preserve">
          <source>Short notation for:</source>
          <target state="translated">다음에 대한 짧은 표기법 :</target>
        </trans-unit>
        <trans-unit id="1b40ffe9db9b97f7227d428a8e93cd1910e5bd51" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a *(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">&lt;code&gt;?(a *(b a))&lt;/code&gt; 바로 가기입니다 . 일반적으로 구분 기호에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fea2072669df686bfd29fd3b1504df5061432af" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a +(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">&lt;code&gt;?(a +(b a))&lt;/code&gt; 바로 가기입니다 . 일반적으로 구분 기호에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb96e2c575443083f6d3ddc0cd31cddbe58784dd" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt; 바로 가기</target>
        </trans-unit>
        <trans-unit id="4f9539002b86530179421f52fa92949ef36aae77" translate="yes" xml:space="preserve">
          <source>Shortcut version to assign in let blocks. Example:</source>
          <target state="translated">let 블록에 할당 할 바로 가기 버전입니다. 예:</target>
        </trans-unit>
        <trans-unit id="7f2812564b5e2e84d2a67a63d392d651dcda3d10" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">대한 속기 &lt;code&gt;dt.inZone(local())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088f96652b3ac9c5f1a3b23e8ff7e823708ee634" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">대한 속기 &lt;code&gt;dt.inZone(utc())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc17510fc204a22966fffd1886072211dea19a4" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;getTime().local&lt;/code&gt;.</source>
          <target state="translated">대한 속기 &lt;code&gt;getTime().local&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccefd273539ba57e397a1a987afc4b367d6fd0cb" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">대한 속기 &lt;code&gt;t.inZone(local())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d38209d424b19a4a50f30394d53391f0377fef8" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">대한 속기 &lt;code&gt;t.inZone(utc())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6166daff0169e3dc89cc83eb9c8606a8a6917a8d" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;dt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 을 구성하고 &lt;code&gt;dt&lt;/code&gt; 형식을 지정하는 데 사용 하는 축약 형입니다 .</target>
        </trans-unit>
        <trans-unit id="f394b42391f134971c4fd4caf836bd1af83856ed" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;time&lt;/code&gt;. Will use the timezone specified by &lt;code&gt;zone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 을 구성하고 &lt;code&gt;time&lt;/code&gt; 형식을 지정하는 데 사용 하는 축약 형입니다 . &lt;code&gt;zone&lt;/code&gt; 에 지정된 시간대를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="719276957fc6ed6b9a172fd432c232dc57b61097" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;, then converting it a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 을 구성하고 이를 사용하여 &lt;code&gt;input&lt;/code&gt; 을 &lt;code&gt;DateTime&lt;/code&gt; 으로 구문 분석 한 다음이를 &lt;code&gt;Time&lt;/code&gt; 으로 변환하기 위한 속기입니다 .</target>
        </trans-unit>
        <trans-unit id="634ede6a595bd79a1f089d455148e4b9e1b829dc" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 을 구성하고 &lt;code&gt;input&lt;/code&gt; 을 &lt;code&gt;DateTime&lt;/code&gt; 으로 구문 분석하는 데 사용 하는 축약 형입니다 .</target>
        </trans-unit>
        <trans-unit id="0a88a0a1d83dbc4654c51021948189560a75286b" translate="yes" xml:space="preserve">
          <source>Shows global variables declarations.</source>
          <target state="translated">전역 변수 선언을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0e16604c6fe1879f13dbc7c436126fd3ae0ebb67" translate="yes" xml:space="preserve">
          <source>Shows the cursor.</source>
          <target state="translated">커서를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5ddc127fefceccd7916455147b0c6cd1bfd5eb59" translate="yes" xml:space="preserve">
          <source>Shows when the C compiler is called.</source>
          <target state="translated">C 컴파일러가 호출 된시기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="65a4950085292c6592af7d8392c4038e653ea152" translate="yes" xml:space="preserve">
          <source>Sign function. Returns -1 for negative numbers and &lt;em&gt;NegInf&lt;/em&gt;, 1 for positive numbers and &lt;em&gt;Inf&lt;/em&gt;, and 0 for positive zero, negative zero and &lt;em&gt;NaN&lt;/em&gt;.</source>
          <target state="translated">부호 기능. -1을 리턴하고 음수 대 &lt;em&gt;NegInf&lt;/em&gt; , 양수 및 1 &lt;em&gt;Inf를&lt;/em&gt; , 0 포지티브 제로 부의 제로위한 &lt;em&gt;NaN이&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8831fa9078748ee02f2347f5d90c34f992582819" translate="yes" xml:space="preserve">
          <source>Signal handling in Nim</source>
          <target state="translated">Nim의 신호 처리</target>
        </trans-unit>
        <trans-unit id="f006508366ff589e263e35089658634396886e2b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;recvLine&lt;/code&gt; but designed for non-blocking sockets.</source>
          <target state="translated">&lt;code&gt;recvLine&lt;/code&gt; 과 유사 하지만 비 차단 소켓 용으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3088f8f41c176a8c6c078dcbb7290cd8f5dcfe1d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;write&lt;/code&gt;, but treating terminal style arguments specially. When some argument is &lt;code&gt;Style&lt;/code&gt;, &lt;code&gt;set[Style]&lt;/code&gt;, &lt;code&gt;ForegroundColor&lt;/code&gt;, &lt;code&gt;BackgroundColor&lt;/code&gt; or &lt;code&gt;TerminalCmd&lt;/code&gt; then it is not sent directly to &lt;code&gt;f&lt;/code&gt;, but instead corresponding terminal style proc is called.</source>
          <target state="translated">유사 &lt;code&gt;write&lt;/code&gt; ,하지만 특별히 터미널 스타일의 인수를 치료. 일부 인수가 &lt;code&gt;Style&lt;/code&gt; , &lt;code&gt;set[Style]&lt;/code&gt; , &lt;code&gt;ForegroundColor&lt;/code&gt; , &lt;code&gt;BackgroundColor&lt;/code&gt; 또는 &lt;code&gt;TerminalCmd&lt;/code&gt; 이면 &lt;code&gt;f&lt;/code&gt; 로 직접 전송되지 않고 대신 해당 터미널 스타일 proc이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="775c84deb7fd1acce89cc09f380ce7f83b7c3680" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</source>
          <target state="translated">POSIX의 &lt;span id=&quot;getpeername_1&quot;&gt;getpeername과&lt;/span&gt; 유사&lt;span id=&quot;getpeername_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9112c6f819f5ac3102803b1b46b40279bc4dc6e4" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">POSIX의 &lt;span id=&quot;getsockname_1&quot;&gt;getsockname과&lt;/span&gt; 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d23f8837af17d948ac41ffcd02bd63cca20c677c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importcpp&lt;/code&gt; pragma can be used to import &lt;span id=&quot;cplusplus_2&quot;&gt;C++&lt;/span&gt; methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt;. In combination with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in C++:</source>
          <target state="translated">받는 유사 &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;C에 대한 importc 프라그&lt;/a&gt; 의 &lt;code&gt;importcpp&lt;/code&gt; 의 pragma는 가져올 수 있습니다 &lt;span id=&quot;cplusplus_2&quot;&gt;C ++&lt;/span&gt; 일반적으로 방법 또는 C ++ 문자. 그런 다음 생성 된 코드는 C ++ 메소드 호출 구문 &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt; 합니다. 와 결합 &lt;code&gt;header&lt;/code&gt; 및 &lt;code&gt;emit&lt;/code&gt; 프라 그마이 수 &lt;em&gt;정치 못한&lt;/em&gt; C ++로 작성된 라이브러리와 인터페이스를 :</target>
        </trans-unit>
        <trans-unit id="f0db59dc951868b6d9e5ad7d56c503fc95dfe4f0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importobjc&lt;/code&gt; pragma can be used to import &lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt; methods. The generated code then uses the Objective C method calling syntax: &lt;code&gt;[obj method param1: arg]&lt;/code&gt;. In addition with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in Objective C:</source>
          <target state="translated">받는 유사 &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;C 대 importc 프라그&lt;/a&gt; 상기 &lt;code&gt;importobjc&lt;/code&gt; 래그를 가져올 수있다 &lt;span id=&quot;objective-c_2&quot;&gt;목표 C의&lt;/span&gt; 방법. 그런 다음 생성 된 코드는 Objective C 메소드 호출 구문 &lt;code&gt;[obj method param1: arg]&lt;/code&gt; 합니다. &lt;code&gt;header&lt;/code&gt; 및 &lt;code&gt;emit&lt;/code&gt; pragma 외에도 Objective C로 작성된 라이브러리와의 &lt;em&gt;느슨한&lt;/em&gt; 인터페이스를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="3adf311c5dd828b7c450080b9fe51795b3cb57d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;import&lt;/code&gt; statement, the AST is different for &lt;code&gt;export ... except&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 문과 유사하게 AST는 &lt;code&gt;export ... except&lt;/code&gt; 따라 다릅니다 ... 제외 .</target>
        </trans-unit>
        <trans-unit id="17f571225bcdb0061542084cc744c2d22c9a95bd" translate="yes" xml:space="preserve">
          <source>Similarly to &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; in C, it is possible to call &lt;code&gt;paramStr(0)&lt;/code&gt; but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; instead.</source>
          <target state="translated">C의 &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; 와 마찬가지로 &lt;code&gt;paramStr(0)&lt;/code&gt; 을 호출하는 것이 가능 하지만 OS 특정 내용 (보통 호출 된 실행 파일의 이름)을 반환합니다. 이를 피하고 대신 &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename ()을&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0836ce8cc993ea5e6c237d5e13b1926310dd2fc9" translate="yes" xml:space="preserve">
          <source>Similarly to the old &lt;code&gt;doc&lt;/code&gt; command the old &lt;code&gt;jsondoc&lt;/code&gt; command has been renamed &lt;code&gt;jsondoc0&lt;/code&gt;.</source>
          <target state="translated">이전 &lt;code&gt;doc&lt;/code&gt; 명령과 마찬가지로 이전 &lt;code&gt;jsondoc&lt;/code&gt; 명령의 이름이 &lt;code&gt;jsondoc0&lt;/code&gt; 으로 변경 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="923d2208cc2a00f7a0f1b3452857f4ae436b40d2" translate="yes" xml:space="preserve">
          <source>Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.</source>
          <target state="translated">마찬가지로, 한 줄보다 긴 프로 시저 및 프로 시저 유형 선언도 동일한 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="03199fb1565fa787d6b802de955cc02879b12e5f" translate="yes" xml:space="preserve">
          <source>Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.</source>
          <target state="translated">간단한 PEG (Parsing expression grammar) 일치 암기는 사용하지 않지만 성능을 향상시키기 위해 수퍼 오퍼레이터와 심볼 인라이닝을 사용합니다. 참고 : 일치하는 성능은 최적화 된 정규식 엔진과 경쟁력이 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="642d63f4b98668cb5f7dde10bc28bf59ccdf215c" translate="yes" xml:space="preserve">
          <source>Simple assertions</source>
          <target state="translated">간단한 어설 션</target>
        </trans-unit>
        <trans-unit id="edcc542b12309c356f091b9913fd4380c94b4828" translate="yes" xml:space="preserve">
          <source>Simple example that parses the &lt;code&gt;/etc/passwd&lt;/code&gt; file line by line:</source>
          <target state="translated">&lt;code&gt;/etc/passwd&lt;/code&gt; 파일을 한 줄씩 파싱하는 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="e8a60d51d4165fef55cc82ac2db54d5e0a688774" translate="yes" xml:space="preserve">
          <source>Simply add --os:nintendoswitch to your usual &lt;code&gt;nim c&lt;/code&gt; or &lt;code&gt;nim cpp&lt;/code&gt; command and set the &lt;code&gt;passC&lt;/code&gt; and &lt;code&gt;passL&lt;/code&gt; command line switches to something like:</source>
          <target state="translated">일반적인 &lt;code&gt;nim c&lt;/code&gt; 또는 &lt;code&gt;nim cpp&lt;/code&gt; 명령에 &lt;code&gt;passC&lt;/code&gt; : nintendoswitch를 추가 하고 passC 및 &lt;code&gt;passL&lt;/code&gt; 명령 행 스위치를 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b090179dd62a9781100bf21383b86b639866ae6b" translate="yes" xml:space="preserve">
          <source>Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:</source>
          <target state="translated">Nim은 C ++을 직접 생성하므로 범위 종료시 C ++ 컴파일러가 모든 소멸자를 내재적으로 호출합니다. 이것은 종종 소멸자를 감싸지 않고 도망 갈 수 있음을 의미합니다! 그러나 명시 적으로 호출해야하는 경우 랩핑해야합니다. 패턴 언어는 필요한 모든 것을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2836b4cd35895fbe3e4607ab829e68b8adca5bab" translate="yes" xml:space="preserve">
          <source>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</source>
          <target state="translated">Nim이 Nim으로 구현되었으므로이 기능의 좋은 점 중 하나는 IDE를 지원하는 모든 사용자가 표준 라이브러리 구현을 신속하게 건너 뛰고 proc이 수행하는 내용을 정확히보고 언어에 대해 배우고 실제 사례를 볼 수 있다는 것입니다. 특정 기능을 작성 / 구현하는 방법.</target>
        </trans-unit>
        <trans-unit id="81d6398a9d34106da960c47713538b3d721fae12" translate="yes" xml:space="preserve">
          <source>Since Nim's garbage collector is not aware of the C code, once the &lt;code&gt;gimme&lt;/code&gt; proc has finished it can reclaim the memory of the &lt;code&gt;cstring&lt;/code&gt;. However, from a practical standpoint, the C code invoking the &lt;code&gt;gimme&lt;/code&gt; function directly will be able to use it since Nim's garbage collector has not had a chance to run &lt;em&gt;yet&lt;/em&gt;. This gives you enough time to make a copy for the C side of the program, as calling any further Nim procs &lt;em&gt;might&lt;/em&gt; trigger garbage collection making the previously returned string garbage. Or maybe you are &lt;a href=&quot;gc&quot;&gt;yourself triggering the collection&lt;/a&gt;.</source>
          <target state="translated">Nim의 가비지 수집기는 C 코드를 인식하지 못하므로 &lt;code&gt;gimme&lt;/code&gt; proc이 완료되면 &lt;code&gt;cstring&lt;/code&gt; 의 메모리를 회수 할 수 있습니다 . 그러나 실용적인 관점에서 &lt;code&gt;gimme&lt;/code&gt; 함수를 직접 호출하는 C 코드 는 Nim의 가비지 수집기가 &lt;em&gt;아직&lt;/em&gt; 실행할 기회가 없기 때문에이 기능을 직접 사용할 수 있습니다 . 추가 Nim 프로세스를 호출하면 가비지 콜렉션 &lt;em&gt;이&lt;/em&gt; 트리거되어 이전에 리턴 된 문자열 가비지 &lt;em&gt;가 생성 될 수 있으므로&lt;/em&gt; 프로그램의 C 측에 복사 할 수있는 충분한 시간을 제공합니다 . 아니면 &lt;a href=&quot;gc&quot;&gt;자신이 컬렉션을 트리거하고&lt;/a&gt; 있을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c2d2708a6e9c531e547adff103c4d9f239c3ef0" translate="yes" xml:space="preserve">
          <source>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; for details on how to change this behavior.</source>
          <target state="translated">클로저는 로컬 변수를 참조로 캡처하기 때문에 루프 바디 내부의 동작을 원하지 않는 경우가 많습니다. 이 동작을 변경하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="433b2057ed04740122c7f9487a7fd644b8ab062a" translate="yes" xml:space="preserve">
          <source>Since counting up occurs so often in programs, Nim also has a &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterator that does the same:</source>
          <target state="translated">카운트 업은 프로그램에서 자주 발생하기 때문에 Nim에는 &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; 반복자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f5358496f3a495272baef5ad9c4459080748780" translate="yes" xml:space="preserve">
          <source>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</source>
          <target state="translated">일반적으로 모듈 이름은 설명이 길기 때문에 기호를 한정 할 때 사용할 짧은 별칭을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb691770c7129b48bc1fbd85364e037b06e51a3" translate="yes" xml:space="preserve">
          <source>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</source>
          <target state="translated">객체는 힙이나 스택에있을 수 있으므로 언어의 표현성이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="d18abb59d5555a0cd68ad92ca498969b76edc73a" translate="yes" xml:space="preserve">
          <source>Since some cases are specific to either &lt;code&gt;ProcRun&lt;/code&gt; or &lt;code&gt;CaasRun&lt;/code&gt; modes, you can prefix a line with the mode and the line will be processed only in that mode.</source>
          <target state="translated">경우에 따라서는 &lt;code&gt;ProcRun&lt;/code&gt; 또는 &lt;code&gt;CaasRun&lt;/code&gt; 모드에만 해당되므로, 줄 앞에 해당 모드를 추가하면 해당 모드에서만 줄이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b539956855f09af0d247b1afd8148391989674" translate="yes" xml:space="preserve">
          <source>Since templates and macros that are not declared as &lt;code&gt;immediate&lt;/code&gt; participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type &lt;code&gt;untyped&lt;/code&gt; accomplishes:</source>
          <target state="translated">&lt;code&gt;immediate&lt;/code&gt; 선언되지 않은 템플릿과 매크로 는 오버로드 해상도에 참여하기 때문에 해결되지 않은 식을 템플릿이나 매크로에 전달하는 방법이 필수적입니다. 이것이 메타 유형의 유형이 &lt;code&gt;untyped&lt;/code&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="20070e544008a5d9a536d614aa3a8b327168b8fa" translate="yes" xml:space="preserve">
          <source>Since the input is not modified you can use this version of &lt;code&gt;map&lt;/code&gt; to transform the type of the elements in the input container.</source>
          <target state="translated">입력이 수정되지 않았으므로이 버전의 &lt;code&gt;map&lt;/code&gt; 을 사용 하여 입력 컨테이너의 요소 유형을 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bd7e9132b57aa66fa0c89392e52a98747d0fab5" translate="yes" xml:space="preserve">
          <source>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set &lt;code&gt;s&lt;/code&gt; to detect this case.</source>
          <target state="translated">유형 사이클을 가질 수 그래프이기 때문에, 상기 알고리즘은 보조 세트가 필요 &lt;code&gt;s&lt;/code&gt; 이 경우를 검출하기 위해.</target>
        </trans-unit>
        <trans-unit id="693c97bf55b6187119c714b7b185fa6734646019" translate="yes" xml:space="preserve">
          <source>Since we adopt the &quot;replay the top level statements&quot; idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example &lt;code&gt;squeaknim&lt;/code&gt; uses this snippet:</source>
          <target state="translated">우리는 &quot;최상위 진술 재생&quot;아이디어를 채택하기 때문에이 문제에 대한 자연스러운 해결책은 전역 변수에 수행 된 돌연변이를 반영하는 의사 최상위 진술을 방출하는 것입니다. 그러나 이것은 소리보다 훨씬 어렵습니다. 예를 들어 &lt;code&gt;squeaknim&lt;/code&gt; 은 다음 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d11cd8a4ff2f39268c05039e2c72e08ef63a5b60" translate="yes" xml:space="preserve">
          <source>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary &lt;code&gt;string&lt;/code&gt; variable and writing into it source code as if it were written &lt;em&gt;by hand&lt;/em&gt;, we use the &lt;code&gt;result&lt;/code&gt; variable directly and create a statement list node (&lt;code&gt;nnkStmtList&lt;/code&gt;) which will hold our children (line 7).</source>
          <target state="translated">앞의 예제 생성 소스 코드를 기반으로하기 때문에 그 차이점 만 언급 할 것입니다. &lt;em&gt;손&lt;/em&gt; 으로 작성한 것처럼 임시 &lt;code&gt;string&lt;/code&gt; 변수를 작성하고 소스 코드 에 작성하는 대신 &lt;code&gt;result&lt;/code&gt; 변수를 직접 사용 하고 하위 항목 (7 행)을 보유 할 명령문 목록 노드 ( &lt;code&gt;nnkStmtList&lt;/code&gt; )를 작성합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67281e7beeac085659bafd0aefa97a7715dd587c" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;size&lt;/code&gt; amount of bytes.</source>
          <target state="translated">바이트 &lt;code&gt;size&lt;/code&gt; 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="caa40925a8a5ba1ec2c47da0074b9498483ee486" translate="yes" xml:space="preserve">
          <source>Skips all characters until one char from the set &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">세트에서 하나 개의 문자까지 모든 문자를 스킵 &lt;em&gt;할 때까지&lt;/em&gt; 발견 또는 끝에 도달. 건너 뛴 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0250535bb44963b382eb260412b12ae060f9664" translate="yes" xml:space="preserve">
          <source>Skips all characters until the char &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">문자를 찾거나 끝에 도달 &lt;em&gt;할&lt;/em&gt; 때까지 모든 문자를 건너 뜁니다 . 건너 뛴 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82c633400ddfee46423e0bdfdd5bf1035984706d" translate="yes" xml:space="preserve">
          <source>Skips all characters while one char from the set &lt;em&gt;token&lt;/em&gt; is found. Returns number of characters skipped.</source>
          <target state="translated">설정된 &lt;em&gt;토큰&lt;/em&gt; 에서 하나의 문자 가 발견 되는 동안 모든 문자를 건너 뜁니다 . 건너 뛴 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7c8076f2280bb4f56da2f4ba9faf089bdaf35a9" translate="yes" xml:space="preserve">
          <source>Skips optional whitespace.</source>
          <target state="translated">선택적 공백을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="3b0fe98905d1d18450c150302cb674830bef8f5f" translate="yes" xml:space="preserve">
          <source>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a &lt;code&gt;parallel&lt;/code&gt; section.</source>
          <target state="translated">복사가 수행되지 않도록 슬라이스가 최적화됩니다. &lt;code&gt;parallel&lt;/code&gt; 섹션 외부의 일반 슬라이스에 대해서는이 최적화가 아직 수행되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="6b4413ae4cc49215fae1d8456ab98bdf32cdd690" translate="yes" xml:space="preserve">
          <source>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</source>
          <target state="translated">슬라이스는 구문에서 하위 범위 유형과 비슷해 보이지만 다른 컨텍스트에서 사용됩니다. 슬라이스는 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b의&lt;/em&gt; 두 경계를 포함하는 Slice 유형의 객체 일뿐 입니다. 슬라이스 자체는 그다지 유용하지 않지만 다른 컬렉션 유형은 슬라이스 객체를 허용하는 범위를 정의하는 연산자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c3fee626664b2a86ccfce0881ad458405c843067" translate="yes" xml:space="preserve">
          <source>Slightly different version of &lt;code&gt;acceptAddr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;acceptAddr&lt;/code&gt; 의 버전이 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="eee7a8ef42831f93c54af4a6309b748729834ca0" translate="yes" xml:space="preserve">
          <source>SmallLshouldNotBeUsed</source>
          <target state="translated">SmallLshouldNotBeUsed</target>
        </trans-unit>
        <trans-unit id="75f4dd2393a33188b388008b159b576f9d6c37ce" translate="yes" xml:space="preserve">
          <source>So &quot;pure object oriented&quot; code is easy to write:</source>
          <target state="translated">따라서 &quot;순수한 객체 지향&quot;코드는 작성하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1884ef29a0caad9d01db393c26a4dacb7998bb83" translate="yes" xml:space="preserve">
          <source>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</source>
          <target state="translated">따라서 많은 경우 콜백으로 인해 컴파일러가 효과 분석에서 지나치게 보수적 인 원인이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d04b96e54f57571cb5f26f417c712886d005cc49" translate="yes" xml:space="preserve">
          <source>So it is not necessary to write &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; in the above example.</source>
          <target state="translated">따라서 위의 예제에서 &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; 를 작성할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8675cecc3e20035fc6e573ebf270227f7c7eb995" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;G.c&lt;/code&gt; MUST contain both &lt;code&gt;P1&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt;, but we haven't even loaded &lt;code&gt;P1&lt;/code&gt; from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</source>
          <target state="translated">이제 &lt;code&gt;G.c&lt;/code&gt; 는 &lt;code&gt;P1&lt;/code&gt; 과 &lt;code&gt;P2&lt;/code&gt; 를 모두 포함해야 하지만 심볼 파일에서 &lt;code&gt;P1&lt;/code&gt; 을 로드 하지 않았으며 전체 프로그램의 큰 부분을 빠르게 복원하기 때문에 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2837e373a9e08b8e4ae0fadd7bcf34bea8bba71" translate="yes" xml:space="preserve">
          <source>So the string &lt;code&gt;b&lt;/code&gt; is of length 19, and two different ways of specifying the indices are</source>
          <target state="translated">따라서 문자열 &lt;code&gt;b&lt;/code&gt; 의 길이는 19이며 인덱스를 지정하는 두 가지 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e588b1291d20c18b6f2648d5846b37301ef51066" translate="yes" xml:space="preserve">
          <source>So what about &lt;code&gt;2 * a&lt;/code&gt;? We should tell the compiler &lt;code&gt;*&lt;/code&gt; is commutative. We cannot really do that however as the following code only swaps arguments blindly:</source>
          <target state="translated">그래서 &lt;code&gt;2 * a&lt;/code&gt; 어떻습니까? 우리는 &lt;code&gt;*&lt;/code&gt; 컴파일러 가 정식 적이 라고 말해야한다 . 그러나 다음 코드는 인수를 맹목적으로 교환하기 때문에 실제로는 그렇게 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4e6066da4ec97671c84015a233816abeed1a8d1" translate="yes" xml:space="preserve">
          <source>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: &lt;a href=&quot;tut2&quot;&gt;Part II&lt;/a&gt;</source>
          <target state="translated">그래서, 우리는 기본으로 수행되는 지금,의는 절차 적 프로그래밍을위한 좋은 구문에서 떨어져 어떤 님의 이벤트 보자 : &lt;a href=&quot;tut2&quot;&gt;파트 II를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99f2336f838a801c19d553e0c88c363ba411da59" translate="yes" xml:space="preserve">
          <source>SockClosed</source>
          <target state="translated">SockClosed</target>
        </trans-unit>
        <trans-unit id="2e364384ea1af26a7ae5749a4ee47846386614a6" translate="yes" xml:space="preserve">
          <source>SockConnected</source>
          <target state="translated">SockConnected</target>
        </trans-unit>
        <trans-unit id="ecb1db9b50d2375a93db032e8269b906e3a2d434" translate="yes" xml:space="preserve">
          <source>SockConnecting</source>
          <target state="translated">SockConnecting</target>
        </trans-unit>
        <trans-unit id="f96262d38e15e56e293b395e3a4e585d00445d21" translate="yes" xml:space="preserve">
          <source>SockIdle</source>
          <target state="translated">SockIdle</target>
        </trans-unit>
        <trans-unit id="49173abf46e65756efd207d62345b6562084170d" translate="yes" xml:space="preserve">
          <source>SockListening</source>
          <target state="translated">SockListening</target>
        </trans-unit>
        <trans-unit id="540e5e4a700a40f5403f5305e76a47af819360b6" translate="yes" xml:space="preserve">
          <source>SockUDPBound</source>
          <target state="translated">SockUDPBound</target>
        </trans-unit>
        <trans-unit id="22beb4639862a7b9b676d1e4836131999f91ce5b" translate="yes" xml:space="preserve">
          <source>Socket has been closed.</source>
          <target state="translated">소켓이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="879f6e69a5675653a92a791913da83a48c7fb678" translate="yes" xml:space="preserve">
          <source>Socket has only just been initialised, not connected or closed.</source>
          <target state="translated">소켓은 연결되거나 닫히지 않고 방금 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="af4d7eba62345b81d526d2643d898eb239b5cdcf" translate="yes" xml:space="preserve">
          <source>Socket is a UDP socket which is listening for data.</source>
          <target state="translated">소켓은 데이터를 수신하는 UDP 소켓입니다.</target>
        </trans-unit>
        <trans-unit id="54b2d18985d4b7f5023824f4fcfddd48ab27cdff" translate="yes" xml:space="preserve">
          <source>Socket is a server socket and is listening for connections.</source>
          <target state="translated">소켓은 서버 소켓이며 연결을 수신하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b53ea21e56f48fba083f112fde7dee58dc547eb7" translate="yes" xml:space="preserve">
          <source>Socket is connected to a server.</source>
          <target state="translated">소켓이 서버에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e26ccd61f472edc6a5d97a690d05af186f5bed" translate="yes" xml:space="preserve">
          <source>Socket is in the process of connecting to a server.</source>
          <target state="translated">소켓이 서버에 연결하는 중입니다.</target>
        </trans-unit>
        <trans-unit id="53b421c08a7dc0ab4bbd194fdc55f0c8077afbc0" translate="yes" xml:space="preserve">
          <source>Sockets which are &lt;strong&gt;not&lt;/strong&gt; ready for reading, writing or which don't have errors waiting on them are removed from the &lt;code&gt;readfds&lt;/code&gt;, &lt;code&gt;writefds&lt;/code&gt;, &lt;code&gt;exceptfds&lt;/code&gt; sequences respectively.</source>
          <target state="translated">있는 소켓 &lt;strong&gt;되지&lt;/strong&gt; 읽기 또는 쓰기를위한 준비, 그들을 기다리고 오류가에서 제거하지 않아도 &lt;code&gt;readfds&lt;/code&gt; , &lt;code&gt;writefds&lt;/code&gt; , &lt;code&gt;exceptfds&lt;/code&gt; 의 각각 시퀀스.</target>
        </trans-unit>
        <trans-unit id="441c0981544196354c221a53804d865bc53f74b3" translate="yes" xml:space="preserve">
          <source>Solution ~~~~~~~~</source>
          <target state="translated">해결책 ~~~~~~~~</target>
        </trans-unit>
        <trans-unit id="a18f034cd6a34c65d1fee4d43db529e754f206cf" translate="yes" xml:space="preserve">
          <source>Some builtins set an error flag. This is then turned into a proper exception. &lt;strong&gt;Note&lt;/strong&gt;: Ordinary application code should not call this.</source>
          <target state="translated">일부 내장은 오류 플래그를 설정합니다. 그런 다음 적절한 예외로 바뀝니다. &lt;strong&gt;참고&lt;/strong&gt; : 일반 응용 프로그램 코드는 이것을 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ab83d5be81d7366ced8b35ee80f8254106e6acd0" translate="yes" xml:space="preserve">
          <source>Some child may be missing. A missing child is a node of kind &lt;code&gt;nnkEmpty&lt;/code&gt;; a child can never be nil.</source>
          <target state="translated">일부 어린이가 없을 수 있습니다. 누락 된 자식은 &lt;code&gt;nnkEmpty&lt;/code&gt; 종류의 노드입니다 . 아이는 절대 무가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="fe96e74863b969e67aadbcee97242dea95a7b5c7" translate="yes" xml:space="preserve">
          <source>Some file not essential for the compiler's working could not be opened.</source>
          <target state="translated">컴파일러 작업에 필수적이지 않은 일부 파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a01546d483ad56932b56e6f4f843c335f7232622" translate="yes" xml:space="preserve">
          <source>Some keywords are unused; they are reserved for future developments of the language.</source>
          <target state="translated">일부 키워드는 사용되지 않습니다. 그들은 언어의 미래 발전을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb6d242fa43323b661e091ed4496920bf211e2d" translate="yes" xml:space="preserve">
          <source>Some terminology: in the example &lt;code&gt;question&lt;/code&gt; is called a (formal) &lt;em&gt;parameter&lt;/em&gt;, &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; is called an &lt;em&gt;argument&lt;/em&gt; that is passed to this parameter.</source>
          <target state="translated">일부 용어는 : 예제에 &lt;code&gt;question&lt;/code&gt; A (공식)라고 &lt;em&gt;매개 변수&lt;/em&gt; , &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; 이라고 &lt;em&gt;주장&lt;/em&gt; 이 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6e93c59acfbd4ca81868fe83cdee12101d3d70c7" translate="yes" xml:space="preserve">
          <source>Some user defined warning.</source>
          <target state="translated">일부 사용자 정의 경고.</target>
        </trans-unit>
        <trans-unit id="3e528bc25235f43baac24e5a82e6fba6ce5447ef" translate="yes" xml:space="preserve">
          <source>Sometimes a C++ class has a private copy constructor and so code like &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; must not be generated but instead &lt;code&gt;Class c(1,2);&lt;/code&gt;. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</source>
          <target state="translated">때때로 C ++ 클래스에는 개인용 복사 생성자가 있으므로 &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; 와 같은 코드가 있습니다 . 생성되지 않고 대신 &lt;code&gt;Class c(1,2);&lt;/code&gt; . 이를 위해 C ++ 생성자를 래핑하는 Nim proc에 &lt;span id=&quot;constructor_1&quot;&gt;생성자&lt;/span&gt; pragma를 주석 처리해야합니다 . 이 pragma는 또한 생성자가 복사 생성자를 호출하지 않으므로 더 빠른 C ++ 코드를 생성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e2bd3dc5145a046d8756e4c3b5e6319385dd6c64" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, &lt;code&gt;spawn&lt;/code&gt; is also used in the &lt;code&gt;parallel&lt;/code&gt; statement with slightly different semantics. &lt;code&gt;spawn&lt;/code&gt; always takes a call expression of the form &lt;code&gt;f(a, ...)&lt;/code&gt;. Let &lt;code&gt;T&lt;/code&gt; be &lt;code&gt;f&lt;/code&gt;'s return type. If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt; then &lt;code&gt;spawn&lt;/code&gt;'s return type is also &lt;code&gt;void&lt;/code&gt; otherwise it is &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">다소 혼란스럽게도 &lt;code&gt;spawn&lt;/code&gt; 은 의미가 약간 다른 &lt;code&gt;parallel&lt;/code&gt; 명령문 에도 사용됩니다 . &lt;code&gt;spawn&lt;/code&gt; 은 항상 &lt;code&gt;f(a, ...)&lt;/code&gt; 형식의 호출 식을 사용합니다 . 하자 &lt;code&gt;T&lt;/code&gt; 는 수 &lt;code&gt;f&lt;/code&gt; 를 의 반환 유형입니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;void&lt;/code&gt; 후 &lt;code&gt;spawn&lt;/code&gt; 의 반환형 또한 &lt;code&gt;void&lt;/code&gt; 그것이 그렇지 &lt;code&gt;FlowVar[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="e2de8e03eb7da80a014273d286391bd6a4e6c758" translate="yes" xml:space="preserve">
          <source>Source Code Filters</source>
          <target state="translated">소스 코드 필터</target>
        </trans-unit>
        <trans-unit id="3c6c119ba4476a2d13a835d7d4fcadc52e3ed050" translate="yes" xml:space="preserve">
          <source>Source code filters</source>
          <target state="translated">소스 코드 필터</target>
        </trans-unit>
        <trans-unit id="c53df7c2a21cf1297f0d2b03c1f92cdd4f7da3c4" translate="yes" xml:space="preserve">
          <source>Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.</source>
          <target state="translated">프로그래밍 또는 마크 업 언어를위한 소스 형광펜. 현재 일부 언어 만 지원되며 다른 언어가 추가 될 수 있습니다. 이 인터페이스는 한 언어가 다른 언어에 중첩 된 언어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="97ec2600b2e9e2b39f1b45d05ed5cf67fa2a6b53" translate="yes" xml:space="preserve">
          <source>Spacing also determines whether &lt;code&gt;(a, b)&lt;/code&gt; is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:</source>
          <target state="translated">간격은 &lt;code&gt;(a, b)&lt;/code&gt; 가 호출의 인수 목록으로 구문 분석되는지 또는 튜플 생성자로 구문 분석되는지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="49958459a4b8e1eb5bdebb01446519ea2cfeeae3" translate="yes" xml:space="preserve">
          <source>Spacing and Whitespace Conventions</source>
          <target state="translated">간격 및 공백 규칙</target>
        </trans-unit>
        <trans-unit id="f85b49adfe2544a4256034716240a926337b5692" translate="yes" xml:space="preserve">
          <source>Spawn statement</source>
          <target state="translated">스폰 진술</target>
        </trans-unit>
        <trans-unit id="491354246b5eb961b32b192cc1c055827162214c" translate="yes" xml:space="preserve">
          <source>Special Operators</source>
          <target state="translated">특수 연산자</target>
        </trans-unit>
        <trans-unit id="e552d4b23e8c0dfe309d5166ff7dd844ec3d8ffe" translate="yes" xml:space="preserve">
          <source>Special Types</source>
          <target state="translated">특수 유형</target>
        </trans-unit>
        <trans-unit id="b23516a1efd1b704e237ef91f3620e190e02d0f3" translate="yes" xml:space="preserve">
          <source>Special built-in that takes a variable number of arguments. Each argument is converted to a string via &lt;code&gt;$&lt;/code&gt;, so it works for user-defined types that have an overloaded &lt;code&gt;$&lt;/code&gt; operator. It is roughly equivalent to &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt;, but available for the JavaScript target too.</source>
          <target state="translated">가변 개수의 인수를 사용하는 특수 내장. 각 인수는 &lt;code&gt;$&lt;/code&gt; 를 통해 문자열로 변환 되므로 &lt;code&gt;$&lt;/code&gt; 연산자 가 오버로드 된 사용자 정의 유형에 작동합니다. &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt; 와 거의 같습니다 . flushFile (stdout) 이지만 JavaScript 대상에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05b76e5943515524507d846a60375ad51a71e57" translate="yes" xml:space="preserve">
          <source>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure &lt;code&gt;GCunref&lt;/code&gt; has to be called before freeing the untraced memory manually:</source>
          <target state="translated">추적되지 않은 개체에 추적 된 참조, 문자열 또는 시퀀스와 같은 추적 된 개체가 포함되어 있으면 특별한주의를 기울여야합니다. 모든 것을 올바르게 해제하려면 추적되지 않은 메모리를 수동으로 해제하기 전에 내장 프로 시저 &lt;code&gt;GCunref&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a17ccd8347abd9eacd874ea7f27e074ed74467ae" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; can be compiled without any semantic error. This can be used to check whether a type supports some operation:</source>
          <target state="translated">시맨틱 오류없이 &lt;em&gt;x&lt;/em&gt; 를 컴파일 할 수 있는지 확인하는 특수 컴파일 타임 프로 시저 유형이 일부 작업을 지원하는지 여부를 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a820fa7aa10cc8d5c0e8b3e7af391dbbe69898ef" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared in the current scope. &lt;em&gt;x&lt;/em&gt; has to be an identifier.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 가 현재 범위에서 선언되어 있는지 확인하는 특수 컴파일 타임 프로 시저 &lt;em&gt;x&lt;/em&gt; 는 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4043ead367d4586fd4c1c0c21c211b7645a7f10" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared. &lt;em&gt;x&lt;/em&gt; has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 가 선언 되었는지 확인하는 특수한 컴파일 타임 프로 시저 &lt;em&gt;x&lt;/em&gt; 는 식별자 또는 한정된 식별자 여야합니다. 라이브러리가 특정 기능을 제공하는지 여부를 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5d0a758aca8fbe6d34b755784c8711b34f72c9" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is defined. &lt;em&gt;x&lt;/em&gt; is an external symbol introduced through the compiler's &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d:x switch&lt;/a&gt; to enable build time conditionals:</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 가 정의 되어 있는지 확인하는 특수한 컴파일 타임 절차 . &lt;em&gt;x&lt;/em&gt; 는 빌드 시간 조건을 활성화하기 위해 컴파일러의 &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d : x 스위치&lt;/a&gt; 를 통해 도입 된 외부 심볼입니다 .</target>
        </trans-unit>
        <trans-unit id="9417dbf6690f564bf56645ff26108dd839309071" translate="yes" xml:space="preserve">
          <source>Special future that acts as a queue. Its API is still experimental and so is subject to change.</source>
          <target state="translated">대기열 역할을하는 특별한 미래. API는 아직 실험 중이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57782b746713c4b81ac3390082e47036bd29bd10" translate="yes" xml:space="preserve">
          <source>Special node kinds</source>
          <target state="translated">특수 노드 종류</target>
        </trans-unit>
        <trans-unit id="202355e0f6c77c7ad33ab91f862395103c925576" translate="yes" xml:space="preserve">
          <source>Specifies an OS Error Code.</source>
          <target state="translated">OS 오류 코드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8fff1eb8c0263a617b1052dd18dc76abb01e14c4" translate="yes" xml:space="preserve">
          <source>Specifies the default calling convention for all procedures (and procedure types) that follow.</source>
          <target state="translated">뒤에 나오는 모든 프로 시저 및 프로 시저 유형에 대한 기본 호출 규칙을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="33f3e9bd75e7c34e8805079b75662d2523e05166" translate="yes" xml:space="preserve">
          <source>Specifies whether this attribute was specified in the original document</source>
          <target state="translated">이 속성이 원본 문서에 지정되었는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9340a269dc5c3688e5ddd09b6883c53291b53287" translate="yes" xml:space="preserve">
          <source>Specify the suite name delimited by &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">스위트 이름을 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 으로 구분하여 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba777a0b8be9b27a2fc0aebaa99a53bd014d0bab" translate="yes" xml:space="preserve">
          <source>Specify the test name as a command line argument.</source>
          <target state="translated">테스트 이름을 명령 행 인수로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9ce8d37027aa3f3951f0667dbca699e808c4574d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fromProc&lt;/code&gt;, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</source>
          <target state="translated">지정 &lt;code&gt;fromProc&lt;/code&gt; 가 디버깅에 도움이로이 미래에 속한 시저의 이름을 지정하는 문자열입니다, 좋은 습관입니다.</target>
        </trans-unit>
        <trans-unit id="b1caea9869ffec0e67a014cd78af1ef02ba40db6" translate="yes" xml:space="preserve">
          <source>Specifying the location of the query</source>
          <target state="translated">쿼리 위치 지정</target>
        </trans-unit>
        <trans-unit id="d3924b51dd7eaa83d08808569b1b0ce045cdc5be" translate="yes" xml:space="preserve">
          <source>Split a number into mantissa and exponent. &lt;em&gt;frexp&lt;/em&gt; calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that &lt;em&gt;x&lt;/em&gt; (the original float value) equals m * 2**n. frexp stores n in &lt;em&gt;exponent&lt;/em&gt; and returns m.</source>
          <target state="translated">숫자를 가수와 지수로 나눕니다. &lt;em&gt;frexp&lt;/em&gt; 는 가수 m (0.5보다 크거나 같고 1보다 작은 float)과 &lt;em&gt;x&lt;/em&gt; (원래 float 값)가 m * 2 ** n 과 같은 정수 값 n을 계산합니다 . frexp는 n을 &lt;em&gt;지수로&lt;/em&gt; 저장 하고 m을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0745140758afddfc4ee7cc02a1b14f4076dc0642" translate="yes" xml:space="preserve">
          <source>Split the string at the first or last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">&lt;em&gt;sep&lt;/em&gt; 의 첫 번째 또는 마지막 발생시 문자열을 3 개의 튜플로 분할</target>
        </trans-unit>
        <trans-unit id="696d32e8d8bbfbcb085e88d7ad30d5090043c8af" translate="yes" xml:space="preserve">
          <source>Split the string at the last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">&lt;em&gt;sep&lt;/em&gt; 이 마지막으로 &lt;em&gt;나타날&lt;/em&gt; 때 문자열을 3 개의 튜플로 분할</target>
        </trans-unit>
        <trans-unit id="9b30837131faaf707d014d0ca36f825f274439f5" translate="yes" xml:space="preserve">
          <source>Splits a &lt;span id=&quot;command-line_1&quot;&gt;command line&lt;/span&gt; into several components; This proc is only occasionally useful, better use the &lt;em&gt;parseopt&lt;/em&gt; module.</source>
          <target state="translated">&lt;span id=&quot;command-line_1&quot;&gt;명령 행&lt;/span&gt; 을 여러 구성 요소로 분할합니다 . 이 proc은 가끔 유용하며 &lt;em&gt;parseopt&lt;/em&gt; 모듈을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e2f6fefaa7fc5767e6bf862c955b2209fdb94636" translate="yes" xml:space="preserve">
          <source>Splits a directory into (head, tail), so that &lt;code&gt;head / tail == path&lt;/code&gt; (except for edge cases like &quot;/usr&quot;).</source>
          <target state="translated">디렉토리를 (head, tail)로 분할하여 &lt;code&gt;head / tail == path&lt;/code&gt; ( &quot;/ usr&quot;과 같은 엣지 케이스 제외)</target>
        </trans-unit>
        <trans-unit id="d3a95cdd0557cc6b3279f5bbb847dfba5f79895c" translate="yes" xml:space="preserve">
          <source>Splits a filename into (dir, filename, extension). &lt;em&gt;dir&lt;/em&gt; does not end in &lt;em&gt;DirSep&lt;/em&gt;. &lt;em&gt;extension&lt;/em&gt; includes the leading dot.</source>
          <target state="translated">파일 이름을 (dir, filename, extension)으로 분할합니다. &lt;em&gt;dir&lt;/em&gt; 은 &lt;em&gt;DirSep로 끝나지&lt;/em&gt; 않습니다 . &lt;em&gt;확장&lt;/em&gt; 에는 선행 점이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="38adfc0e948e54bb128886ea5c9d463e755da1e5" translate="yes" xml:space="preserve">
          <source>Splits and distributes a sequence &lt;em&gt;s&lt;/em&gt; into &lt;em&gt;num&lt;/em&gt; sub sequences.</source>
          <target state="translated">시퀀스 &lt;em&gt;s&lt;/em&gt; 를 &lt;em&gt;num&lt;/em&gt; 하위 시퀀스 로 나누고 분배합니다 .</target>
        </trans-unit>
        <trans-unit id="a0c6e0e448f34874bff64437b7d2ab91fdf935d9" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; at whitespace stripping leading and trailing whitespace if necessary. If &lt;code&gt;maxsplit&lt;/code&gt; is specified and is positive, no more than &lt;code&gt;maxsplit&lt;/code&gt; splits is made.</source>
          <target state="translated">문자열 분할 &lt;code&gt;s&lt;/code&gt; 제거 선도하고 필요한 경우 공백을 후행 공백에. 경우 &lt;code&gt;maxsplit&lt;/code&gt; 이 지정입니다 긍정적 인, 더 이상 &lt;code&gt;maxsplit&lt;/code&gt; 분할이 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a79255370060c2e50f8a5845d572dc8618abf3bc" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into a seq of substrings.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 를 일련 의 하위 문자열로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="cb7b44f53469c886c88f238f833dcf716ae5cf1d" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 를 하위 문자열 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="7bee92474f34808ecc0e41e36df829980b2f1e85" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into its containing lines.</source>
          <target state="translated">문자열 분할 &lt;em&gt;들&lt;/em&gt; 의 포함 라인에.</target>
        </trans-unit>
        <trans-unit id="5b2ee834c17d5b26b6e4fac9083478adf72ace42" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">문자열 분할 &lt;em&gt;들&lt;/em&gt; 스트링 분리기를 사용하여 오른쪽에 하위. 역순을 제외하고 &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; 와 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="087310e18b69609a2aa211f0f42cebd7c1cd07af" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">문자열 분할 &lt;em&gt;들&lt;/em&gt; 스트링 분리기를 사용하여 오른쪽에 하위. 역순을 제외하고 &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; 와 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cd60b97467de78d203515610e7c117f7aca90a40" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a group of separators.</source>
          <target state="translated">구분 기호 그룹을 사용하여 문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="006e1144089a0526e01f597553d1e7c5c932d6fd" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a single separator.</source>
          <target state="translated">문자열 분할 &lt;em&gt;S를&lt;/em&gt; 하나의 세퍼레이터를 사용하여 문자열로.</target>
        </trans-unit>
        <trans-unit id="f52fdc09a9930420c66d61ce94065811386774f2" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a string separator.</source>
          <target state="translated">문자열 구분 기호를 사용하여 문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="bdcf8c0eeb58a21cdf0ea123c375dc7b74b4c1c3" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="7ba91be4e0a331af370fe3ce81d200f372c209c4" translate="yes" xml:space="preserve">
          <source>Square root for a complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="translated">복소수에 대한 제곱근 &lt;em&gt;Z&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c7d890a6474c971c057ab4ea575d83552a62c69b" translate="yes" xml:space="preserve">
          <source>StackTrace</source>
          <target state="translated">StackTrace</target>
        </trans-unit>
        <trans-unit id="5834da0d9d1f734eeb82b865257b78b65132ac61" translate="yes" xml:space="preserve">
          <source>StackTrace option</source>
          <target state="translated">StackTrace 옵션</target>
        </trans-unit>
        <trans-unit id="97a27501491262c65d421114e5586483e201f5db" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeFloat&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">표준 형식으로 구현 &lt;code&gt;SomeFloat&lt;/code&gt; . 이것을 직접 호출하는 것은 거의 의미가 없지만 &lt;code&gt;&amp;amp;&lt;/code&gt; 매크로에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9988eb477879aef4e84166efb847dbda62ecb3" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeInteger&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">표준 형식으로 구현 &lt;code&gt;SomeInteger&lt;/code&gt; . 이것을 직접 호출하는 것은 거의 의미가 없지만 &lt;code&gt;&amp;amp;&lt;/code&gt; 매크로에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="82b4f534d5b70cca26d540da82df24c1661c25fa" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;string&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">표준 형식으로 구현 &lt;code&gt;string&lt;/code&gt; . 이것을 직접 호출하는 것은 거의 의미가 없지만 &lt;code&gt;&amp;amp;&lt;/code&gt; 매크로에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="286926a53b71c9700c85a0fe22c8494800f423ec" translate="yes" xml:space="preserve">
          <source>Standard format specifier for strings, integers and floats</source>
          <target state="translated">문자열, 정수 및 부동 소수점에 대한 표준 형식 지정자</target>
        </trans-unit>
        <trans-unit id="e4536991ce4cfc6d6a8e33066d777f94420dea8c" translate="yes" xml:space="preserve">
          <source>Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 로 시작하는 포인터 / 참조가 아닌 경우 대문자 &lt;code&gt;T&lt;/code&gt; 로 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="59898b19b077c1855bd9ba49e69a1b8694d1ea8a" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for read availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">읽기 가능한 파일 디스크립터를보고 콜백 &lt;code&gt;cb&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="c48d22286fde2df857b4c72495d932198256b33b" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for write availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">쓰기 가능한 파일 디스크립터를보고 콜백 &lt;code&gt;cb&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e536d288d0851f6d9e8276875d7977f4844842b" translate="yes" xml:space="preserve">
          <source>Starting with c2nim version 0.9.8 it is also possible to directly embed Nim code in the C file. This is handy when you don't want to modify the generated Nim code at all. Nim code can be embedded directly via &lt;code&gt;#@ Nim code here @#&lt;/code&gt;:</source>
          <target state="translated">c2nim 버전 0.9.8부터는 Nim 코드를 C 파일에 직접 포함시킬 수도 있습니다. 생성 된 Nim 코드를 전혀 수정하지 않으려는 경우에 편리합니다. Nim 코드는 &lt;code&gt;#@ Nim code here @#&lt;/code&gt; 를 통해 직접 임베드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bde902e0e1c0a059e5fe83c9f5f9792a0e51c8a5" translate="yes" xml:space="preserve">
          <source>Starting with the simplest case, a &lt;code&gt;type&lt;/code&gt; section appears much like &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 경우부터 &lt;code&gt;type&lt;/code&gt; 섹션은 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 와 매우 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="5750880c4922c991ffb618071f7738d4d0253363" translate="yes" xml:space="preserve">
          <source>Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:</source>
          <target state="translated">언어의 0.10.1 버전부터 Nim은 여러 줄 주석을 지원합니다. 그들은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="0bc24feae6a6568706e81e7f2d7d483485e4dca3" translate="yes" xml:space="preserve">
          <source>Starting with version 0.14 of the language, Nim supports &lt;code&gt;field&lt;/code&gt; as a shortcut for &lt;code&gt;self.field&lt;/code&gt; comparable to the &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; keyword in Java or C++. This feature has to be explicitly enabled via a &lt;code&gt;{.this: self.}&lt;/code&gt; statement pragma. This pragma is active for the rest of the module:</source>
          <target state="translated">언어의 0.14 버전부터 Nim은 Java 또는 C ++에서 &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; 키워드 와 비교할 수있는 &lt;code&gt;self.field&lt;/code&gt; 의 바로 가기로 &lt;code&gt;field&lt;/code&gt; 를 지원 합니다 . 이 기능은 &lt;code&gt;{.this: self.}&lt;/code&gt; 문 pragma 를 통해 명시 적으로 활성화해야합니다 . 이 pragma는 나머지 모듈에 대해 활성화되어 있습니다.&lt;span id=&quot;this_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="fb2ad21d99439d76c4ae769b916f899ad8dad268" translate="yes" xml:space="preserve">
          <source>Starts a process. &lt;em&gt;Command&lt;/em&gt; is the executable file, &lt;em&gt;workingDir&lt;/em&gt; is the process's working directory. If &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; the current directory is used. &lt;em&gt;args&lt;/em&gt; are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. &lt;em&gt;args&lt;/em&gt; should not contain this argument! &lt;em&gt;env&lt;/em&gt; is the environment that will be passed to the process. If &lt;code&gt;env == nil&lt;/code&gt; the environment is inherited of the parent process. &lt;em&gt;options&lt;/em&gt; are additional flags that may be passed to &lt;em&gt;startProcess&lt;/em&gt;. See the documentation of &lt;code&gt;ProcessOption&lt;/code&gt; for the meaning of these flags. You need to &lt;em&gt;close&lt;/em&gt; the process when done.</source>
          <target state="translated">프로세스를 시작합니다. &lt;em&gt;Command&lt;/em&gt; 는 실행 파일이며 &lt;em&gt;workingDir&lt;/em&gt; 은 프로세스의 작업 디렉토리입니다. 경우 &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; 현재 디렉토리가 사용됩니다. &lt;em&gt;인수&lt;/em&gt; 는 프로세스에 전달되는 명령 줄 인수입니다. 많은 운영 체제에서 첫 번째 명령 줄 인수는 실행 파일의 이름입니다. &lt;em&gt;인수&lt;/em&gt; 는이 인수를 포함해서는 안됩니다! &lt;em&gt;env&lt;/em&gt; 는 프로세스에 전달 될 환경입니다. 경우 &lt;code&gt;env == nil&lt;/code&gt; 환경은 부모 프로세스의 상속됩니다. &lt;em&gt;옵션&lt;/em&gt; 은 &lt;em&gt;startProcess에&lt;/em&gt; 전달 될 수있는 추가 플래그입니다 . &lt;code&gt;ProcessOption&lt;/code&gt; 의 설명서를 참조하십시오이 플래그의 의미에 대해. 완료되면 프로세스 를 &lt;em&gt;닫아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e1e47e87b9fe76e44fbbfad1b5c2f3cec6f694d4" translate="yes" xml:space="preserve">
          <source>Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.</source>
          <target state="translated">모든 코 루틴이 종료되면 종료되는 메인 코 루틴 스케줄러 루프를 시작합니다. 이 proc을 호출하면 첫 번째 코 루틴 실행이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e4b62e8fbf218158e05c575bcb526db8434456d7" translate="yes" xml:space="preserve">
          <source>Starts the process of listening for incoming HTTP connections on the specified address and port.</source>
          <target state="translated">지정된 주소와 포트에서 들어오는 HTTP 연결 수신 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="95e9a635c9383520925e14042d4b923fd6c3ac7c" translate="yes" xml:space="preserve">
          <source>Startswith vs full match</source>
          <target state="translated">Startswith vs 전체 경기</target>
        </trans-unit>
        <trans-unit id="2f3fd7595abb518c6624f116892060fa788f065b" translate="yes" xml:space="preserve">
          <source>State of the random number generator. The procs that use the default state are &lt;strong&gt;not&lt;/strong&gt; thread-safe!</source>
          <target state="translated">난수 생성기의 상태입니다. 기본 상태를 사용하는 프로세서는 스레드로부터 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="585af40bd2ea53a8fcbac51a9fdd078062535c3e" translate="yes" xml:space="preserve">
          <source>Statement Macros</source>
          <target state="translated">명세서 매크로</target>
        </trans-unit>
        <trans-unit id="c1d090a6c68c4210ac3bd5dfc03a161d8ee95112" translate="yes" xml:space="preserve">
          <source>Statement list</source>
          <target state="translated">명세서 목록</target>
        </trans-unit>
        <trans-unit id="e9d413cd91133512c4e3171d0a7ea1f91f1b99be" translate="yes" xml:space="preserve">
          <source>Statement list expression</source>
          <target state="translated">명령문리스트 표현식</target>
        </trans-unit>
        <trans-unit id="561838a377363a51093422d3a816d894fc64a7aa" translate="yes" xml:space="preserve">
          <source>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</source>
          <target state="translated">명령문 매크로는 표현식 매크로로 정의됩니다. 그러나 콜론 다음에 오는 표현식에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="5328a225bf88e0ed36c05ac4a8717682f2fb065b" translate="yes" xml:space="preserve">
          <source>Statements and expressions</source>
          <target state="translated">진술과 표현</target>
        </trans-unit>
        <trans-unit id="28b50d2ede0bbc0df4e2532f866848d6bf82cffb" translate="yes" xml:space="preserve">
          <source>Statements and indentation</source>
          <target state="translated">진술과 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="2f0b50bd8139f25d6003b6a910f512893ff24a3e" translate="yes" xml:space="preserve">
          <source>Statements are separated into &lt;span id=&quot;simple-statements_1&quot;&gt;simple statements&lt;/span&gt; and &lt;span id=&quot;complex-statements_1&quot;&gt;complex statements&lt;/span&gt;. Simple statements are statements that cannot contain other statements like assignments, calls or the &lt;code&gt;return&lt;/code&gt; statement; complex statements can contain other statements. To avoid the &lt;span id=&quot;dangling-else-problem_1&quot;&gt;dangling else problem&lt;/span&gt;, complex statements always have to be indented. The details can be found in the grammar.</source>
          <target state="translated">문장은 &lt;span id=&quot;simple-statements_1&quot;&gt;간단한 문장&lt;/span&gt; 과 &lt;span id=&quot;complex-statements_1&quot;&gt;복잡한 문장&lt;/span&gt; 으로 구분됩니다 . 간단한 문장은 할당, 호출 또는 &lt;code&gt;return&lt;/code&gt; 문장 과 같은 다른 문장을 포함 할 수없는 문장입니다. 복잡한 문장에는 다른 문장이 포함될 수 있습니다. &lt;span id=&quot;dangling-else-problem_1&quot;&gt;다른 문제가 발생&lt;/span&gt; 하지 않도록하려면 복잡한 명령문을 들여 쓰기해야합니다. 세부 사항은 문법에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73e132de8d234237b097eae09c8f41a5d3aeb437" translate="yes" xml:space="preserve">
          <source>Statements can also occur in an expression context that looks like &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt;. This is called an statement list expression or &lt;code&gt;(;)&lt;/code&gt;. The type of &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; is the type of &lt;code&gt;ex&lt;/code&gt;. All the other statements must be of type &lt;code&gt;void&lt;/code&gt;. (One can use &lt;code&gt;discard&lt;/code&gt; to produce a &lt;code&gt;void&lt;/code&gt; type.) &lt;code&gt;(;)&lt;/code&gt; does not introduce a new scope.</source>
          <target state="translated">&lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; 와 같은 표현식 컨텍스트에서도 명령문이 발생할 수 있습니다 . 이를 명령문 목록 표현식 또는 &lt;code&gt;(;)&lt;/code&gt; 라고합니다 . 의 유형 &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; 의 유형입니다 &lt;code&gt;ex&lt;/code&gt; . 다른 모든 명령문은 &lt;code&gt;void&lt;/code&gt; 유형이어야합니다 . &lt;code&gt;void&lt;/code&gt; 를 생성하기 위해 &lt;code&gt;discard&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;(;)&lt;/code&gt; 는 새로운 범위를 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09ba2d803c92fca5d318023b8b22a1bf044aeec2" translate="yes" xml:space="preserve">
          <source>States that &lt;em&gt;every&lt;/em&gt; other parameter must not alias with the marked parameter.</source>
          <target state="translated">미국이 &lt;em&gt;모든&lt;/em&gt; 다른 매개 변수 표시 매개 변수를 사용하지 별칭해야합니다.</target>
        </trans-unit>
        <trans-unit id="b21c7be07ec4d071647590676d7c707716706eb2" translate="yes" xml:space="preserve">
          <source>States that the marked parameter needs to alias with &lt;em&gt;some&lt;/em&gt; other parameter.</source>
          <target state="translated">와 별명 매개 변수를 필요로 표시한다고 &lt;em&gt;몇 가지&lt;/em&gt; 다른 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="bda29e5bb4f9a6e91109576feba5b699a9ffa7c4" translate="yes" xml:space="preserve">
          <source>Static params can also appear in the signatures of generic types:</source>
          <target state="translated">정적 매개 변수는 일반 유형의 서명에도 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd4eea69c0fcf4c239e8f32cdb22fe3e56921d96" translate="yes" xml:space="preserve">
          <source>Static statement/expression</source>
          <target state="translated">정적 진술 / 표현</target>
        </trans-unit>
        <trans-unit id="1efa0116abdd20c68f5da9f1569291c9d6bcab18" translate="yes" xml:space="preserve">
          <source>Static types, like &lt;code&gt;static[int]&lt;/code&gt;, use &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkStaticTy&lt;/code&gt;.</source>
          <target state="translated">static &lt;code&gt;static[int]&lt;/code&gt; 와 같은 정적 유형 은 &lt;code&gt;nnkIdent&lt;/code&gt; 래핑 된 &lt;code&gt;nnkStaticTy&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="df6826b4250b90fb4e378254d9554431e3e76513" translate="yes" xml:space="preserve">
          <source>Statically typed wrapper around a JavaScript object.</source>
          <target state="translated">JavaScript 객체 주위에 정적으로 입력 된 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="f99da6af391d7d0b1782b934b78439cc36d3ec64" translate="yes" xml:space="preserve">
          <source>Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when a data value is pushed to the &lt;code&gt;RunningStat&lt;/code&gt; or &lt;code&gt;RunningRegress&lt;/code&gt; objects</source>
          <target state="translated">데이터의 기본 통계 분석을 수행하기위한 통계 분석 프레임 워크. 데이터 값이 &lt;code&gt;RunningStat&lt;/code&gt; 또는 &lt;code&gt;RunningRegress&lt;/code&gt; 객체로 푸시되면 단일 패스로 데이터가 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="95c5b7897012d8f6b29894d9aacb62893a21c7dd" translate="yes" xml:space="preserve">
          <source>StdTmpl filter</source>
          <target state="translated">StdTmpl 필터</target>
        </trans-unit>
        <trans-unit id="2d517ff3e91f20612466e4d677722b435331123f" translate="yes" xml:space="preserve">
          <source>Stop the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="translated">프로세스 &lt;em&gt;p를&lt;/em&gt; 중지하십시오 . Posix OS에서 절차는 &lt;code&gt;SIGTERM&lt;/code&gt; 을 프로세스로 보냅니다 . Windows 에서는 프로세스를 중지하기 위해 Win32 API 함수 &lt;code&gt;TerminateProcess()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="193670292bbf8be6929e6f76418e0773142d3e9f" translate="yes" xml:space="preserve">
          <source>Stops coroutine execution and resumes no sooner than after &lt;code&gt;sleeptime&lt;/code&gt; seconds. Until then other coroutines are executed.</source>
          <target state="translated">코 루틴 실행을 중지하고 잠자기 &lt;code&gt;sleeptime&lt;/code&gt; 초) 이 지나면 다시 시작합니다 . 그때까지 다른 코 루틴이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c692f32f2608c4a295dcfea18799b8cd9fd2f756" translate="yes" xml:space="preserve">
          <source>Stops the program immediately with an exit code.</source>
          <target state="translated">종료 코드를 사용하여 프로그램을 즉시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="6c7da5ae9d8453249af10e3df51f169922c5fe26" translate="yes" xml:space="preserve">
          <source>Store implementation-defined representation of the exception flags indicated by &lt;em&gt;excepts&lt;/em&gt; in the object pointed to by &lt;em&gt;flagp&lt;/em&gt;.</source>
          <target state="translated">상점에 표시된 예외 플래그의 표현을 구현 정의 &lt;em&gt;excepts&lt;/em&gt; 가 가리키는 객체의 &lt;em&gt;깃대&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd07ac3fcadc296f8eadaaee32c2d2045b485375" translate="yes" xml:space="preserve">
          <source>Store the current floating-point environment in the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;envp가&lt;/em&gt; 가리키는 객체에 현재 부동 소수점 환경을 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed122e970e1da75eae7113f501ba6a2683599b66" translate="yes" xml:space="preserve">
          <source>Stores arbitrary data inside SSLContext. The unique &lt;em&gt;index&lt;/em&gt; should be retrieved using getSslContextExtraDataIndex.</source>
          <target state="translated">SSLContext 내에 임의의 데이터를 저장합니다. 고유 &lt;em&gt;인덱스&lt;/em&gt; 는 getSslContextExtraDataIndex를 사용하여 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="3561a6520c3d5d295122d365e075a71d866713db" translate="yes" xml:space="preserve">
          <source>Stores the empty string or the last headline/overline found in the rst document, so it can be used as a prettier name for term index generation.</source>
          <target state="translated">첫 번째 문서에서 찾은 빈 문자열 또는 마지막 헤드 라인 / 개요를 저장하므로 용어 색인 생성을위한 더 예쁜 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c0d4450fba91caf6c704085748bb15b5343e9a" translate="yes" xml:space="preserve">
          <source>Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">쓰기 또는 읽기를 지원하는 스트림 인터페이스. 이 필드는 직접 사용해서는 안됩니다. 스트림 구현이이를 대체 할 수 있도록 액세스 가능합니다.</target>
        </trans-unit>
        <trans-unit id="51a31e0d2f2e0f77e70f94326ee6904303908d73" translate="yes" xml:space="preserve">
          <source>String &lt;span id=&quot;interpolation_1&quot;&gt;interpolation&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;format&lt;/span&gt; inspired by Python's &lt;code&gt;f&lt;/code&gt;-strings.</source>
          <target state="translated">파이썬의 &lt;code&gt;f&lt;/code&gt; - string 에서 영감을 얻은 문자열 &lt;span id=&quot;interpolation_1&quot;&gt;보간&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;형식&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="dff366ef5455c79b8728295225889786b796cf17" translate="yes" xml:space="preserve">
          <source>String and character literals</source>
          <target state="translated">문자열과 문자 리터럴</target>
        </trans-unit>
        <trans-unit id="8592962cea78137eedb95afe4474ceef0bee804c" translate="yes" xml:space="preserve">
          <source>String assignments are sometimes expensive in Nim: They are required to copy the whole string. However, the compiler is often smart enough to not copy strings. Due to the argument passing semantics, strings are never copied when passed to subroutines. The compiler does not copy strings that are a result from a procedure call, because the callee returns a new string anyway. Thus it is efficient to do:</source>
          <target state="translated">문자열 할당은 때때로 Nim에서 비쌉니다 : 전체 문자열을 복사해야합니다. 그러나 컴파일러는 종종 문자열을 복사하지 않을 정도로 똑똑합니다. 의미 전달 인수로 인해 서브 루틴으로 전달 될 때 문자열이 복사되지 않습니다. 수신자는 어쨌든 새 문자열을 반환하므로 컴파일러는 프로 시저 호출의 결과 인 문자열을 복사하지 않습니다. 따라서 다음을 수행하는 것이 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="translated">문자열 처리</target>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="translated">문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="af12c2e063676108d00610ed5b2b199ea508a589" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes. The &lt;code&gt;var&lt;/code&gt; statement declares a new variable named &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; with the value that is returned by the &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; procedure. Since the compiler knows that &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; returns a string, you can leave out the type in the declaration (this is called &lt;span id=&quot;local-type-inference_1&quot;&gt;local type inference&lt;/span&gt;). So this will work too:</source>
          <target state="translated">문자열 리터럴은 큰 따옴표로 묶습니다. &lt;code&gt;var&lt;/code&gt; 에 문은 새로운 변수 이름을 선언 &lt;code&gt;name&lt;/code&gt; 형식의 &lt;code&gt;string&lt;/code&gt; 에 의해 반환되는 값 &lt;a href=&quot;system#readLine,File&quot;&gt;의 readline&lt;/a&gt; 절차를. 컴파일러는 &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; 이 문자열을 리턴 한다는 것을 알고 있으므로 선언에서 유형을 생략 할 수 있습니다 ( &lt;span id=&quot;local-type-inference_1&quot;&gt;로컬 유형 유추&lt;/span&gt; 라고 함 ). 그래서 이것은 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="cbd76253c7810952b365eda2c20cec5a247a7e14" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with &lt;code&gt;\&lt;/code&gt;: &lt;code&gt;\n&lt;/code&gt; means newline, &lt;code&gt;\t&lt;/code&gt; means tabulator, etc. There are also &lt;em&gt;raw&lt;/em&gt; string literals:</source>
          <target state="translated">문자열 리터럴은 큰 따옴표로 묶습니다. 작은 따옴표로 된 문자 리터럴. 특수 문자와 이스케이프 &lt;code&gt;\&lt;/code&gt; : &lt;code&gt;\n&lt;/code&gt; 수단은 줄 바꿈, &lt;code&gt;\t&lt;/code&gt; 수단의 도표 작성 등도 있습니다 &lt;em&gt;원시&lt;/em&gt; 문자열 리터럴은 :</target>
        </trans-unit>
        <trans-unit id="91beede65eb4bf81fa0a0b03f71ed1840d87fbad" translate="yes" xml:space="preserve">
          <source>String literals can also be delimited by three double quotes &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;. Literals in this form may run for several lines, may contain &lt;code&gt;&quot;&lt;/code&gt; and do not interpret any escape sequences. For convenience, when the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline (there may be whitespace between the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt;, so this:</source>
          <target state="translated">문자열 리터럴은 세 개의 큰 따옴표 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 로 구분할 수도 있습니다 . 이 형식의 리터럴은 여러 줄에 걸쳐 실행될 수 있으며 &lt;code&gt;&quot;&lt;/code&gt; 이스케이프 시퀀스를 해석하지 않을 수 있습니다 . 편의상 여는 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 다음에 줄 바꿈이있을 때 (개시 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 와 줄 바꿈 사이에 공백이있을 수 있음 ) 개행 문자 (및 앞의 공백)는 문자열에 포함되지 않습니다. 문자열 리터럴의 끝은 &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt; 패턴으로 정의 되므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a98bf22b08be1e87b2f87e1e68dc04c240c4f84a" translate="yes" xml:space="preserve">
          <source>String literals can be delimited by matching double quotes, and can contain the following &lt;span id=&quot;escape-sequences_1&quot;&gt;escape sequences&lt;/span&gt;:</source>
          <target state="translated">문자열 리터럴은 큰 따옴표를 일치시켜 구분할 수 있으며 다음 &lt;span id=&quot;escape-sequences_1&quot;&gt;이스케이프 시퀀스를&lt;/span&gt; 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add4920af30df00399258f443c32b23c074019f6" translate="yes" xml:space="preserve">
          <source>String match ignoring case for back reference.</source>
          <target state="translated">역 참조를위한 문자열 일치 무시 사례.</target>
        </trans-unit>
        <trans-unit id="2a6aa06ff131f3961de8e3d1902b39032ccdc0a1" translate="yes" xml:space="preserve">
          <source>String match ignoring case.</source>
          <target state="translated">대소 문자를 무시하는 문자열 일치</target>
        </trans-unit>
        <trans-unit id="147076ac16a166598cdc8c313b99f065ab615a6a" translate="yes" xml:space="preserve">
          <source>String match ignoring style for back reference.</source>
          <target state="translated">역 참조를위한 문자열 일치 무시 스타일</target>
        </trans-unit>
        <trans-unit id="bb24a4c20f47d52b01a258419055f6b3dfdee121" translate="yes" xml:space="preserve">
          <source>String match ignoring style.</source>
          <target state="translated">스타일을 무시하는 문자열 일치</target>
        </trans-unit>
        <trans-unit id="02ac6c5d15d3833eb25c8fee2851790ab39dbbb4" translate="yes" xml:space="preserve">
          <source>String type</source>
          <target state="translated">문자열 타입</target>
        </trans-unit>
        <trans-unit id="986c54b2d8959694bd3a8d1059f1a28ae674bd61" translate="yes" xml:space="preserve">
          <source>String variables are &lt;strong&gt;mutable&lt;/strong&gt;, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a &lt;code&gt;cstring&lt;/code&gt; without doing a copy.</source>
          <target state="translated">문자열 변수는 &lt;strong&gt;변경 가능&lt;/strong&gt; 하므로 문자열에 추가하는 것이 가능하고 매우 효율적입니다. Nim의 문자열은 모두 0으로 끝나고 길이 필드가 있습니다. 문자열의 길이는 내장으로 검색 할 수 &lt;code&gt;len&lt;/code&gt; 절차; 길이는 종료 0을 계산하지 않습니다. 종료 0에 액세스하는 것은 오류이며, Nim 문자열을 복사하지 않고 &lt;code&gt;cstring&lt;/code&gt; 으로 변환 할 수 있도록하기 위해서만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="9582510d33852bda61d01257c5b36aff25c4246c" translate="yes" xml:space="preserve">
          <source>String: If the text ahead is the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">문자열 : 앞의 텍스트가 문자열 &lt;em&gt;s&lt;/em&gt; 이면이를 소비하고 성공을 나타냅니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="3fef5979e2a970ce485675c739e2e35d04689a53" translate="yes" xml:space="preserve">
          <source>Strings and C strings</source>
          <target state="translated">문자열과 C 문자열</target>
        </trans-unit>
        <trans-unit id="1b710e9083a424ca250da057248ace9578ab56d8" translate="yes" xml:space="preserve">
          <source>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</source>
          <target state="translated">문자열은 사전 순으로 비교됩니다. 모든 비교 연산자를 사용할 수 있습니다. 문자열은 배열처럼 인덱싱 할 수 있습니다 (하한은 0 임). 배열과 달리 case 문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c9bb4c72fe3ad8b1a94e6b29d07b028ab504ba" translate="yes" xml:space="preserve">
          <source>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;.</source>
          <target state="translated">문자열은 사전 순서를 사용하여 비교됩니다. 모든 비교 연산자가 지원됩니다. 일반적으로 모든 문자열은 UTF-8로 인코딩되지만 적용되지는 않습니다. 예를 들어, 이진 파일에서 문자열을 읽을 때는 문자열 시퀀스 일뿐입니다. 인덱스 연산 &lt;code&gt;s[i]&lt;/code&gt; 는 i 번째 &lt;em&gt;unichar가&lt;/em&gt; 아니라 &lt;code&gt;s&lt;/code&gt; 의 i 번째 &lt;em&gt;char&lt;/em&gt; 을 의미합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68f5a8dcb38cb2dcf8c5a38294f5911b71dc18ba" translate="yes" xml:space="preserve">
          <source>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</source>
          <target state="translated">Nim의 문자열에는 8 비트 값이 포함될 수 있으며 0도 포함됩니다. 그러나 일부 연산은 첫 번째 이진 0을 종료 자로 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b34aa10a7504c11b1c238076600885e8cb63777" translate="yes" xml:space="preserve">
          <source>Strip filter</source>
          <target state="translated">스트립 필터</target>
        </trans-unit>
        <trans-unit id="98e0d86ad6cb0129df0228988af89dce21ec584d" translate="yes" xml:space="preserve">
          <source>Strips leading or trailing &lt;em&gt;chars&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt; and returns the resulting string.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 에서 선행 또는 후행 &lt;em&gt;문자를&lt;/em&gt; 제거 하고 결과 문자열을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c8ff4b4dfac3e5ecfb01fa66e040f2be24062608" translate="yes" xml:space="preserve">
          <source>Structured types</source>
          <target state="translated">구조화 된 유형</target>
        </trans-unit>
        <trans-unit id="6617ba0382b36cb88686c64241a0d1066459e84e" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison.</source>
          <target state="translated">스타일에 둔감 한 비교.</target>
        </trans-unit>
        <trans-unit id="47c3fbfee5ccaddc82435585c637b37f1eed421b" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">스타일에 둔감 한 비교. &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 는 식별자 또는 기호 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327f538ea37da49ccf2c271b65129745ac5559a5" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">스타일에 둔감 한 비교. 식별자 또는 심볼 일 수있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a24820daa51bd1dce30c8565c1d952ac958b1e4f" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">스타일에 둔감 한 비교. &lt;code&gt;b&lt;/code&gt; 는 식별자 또는 기호 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af3750102e983bbf33f619b8dae0de2a0f4b3c0c" translate="yes" xml:space="preserve">
          <source>Subrange of &lt;code&gt;TimeUnit&lt;/code&gt; that only includes units of fixed duration. These are the units that can be represented by a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">고정 기간 단위 만 포함 하는 &lt;code&gt;TimeUnit&lt;/code&gt; 의 하위 범위입니다 . 이것들은 &lt;code&gt;Duration&lt;/code&gt; 으로 나타낼 수있는 단위입니다 .</target>
        </trans-unit>
        <trans-unit id="c3435d7cc8ec39979e476fdb02a131d9a1f16a5a" translate="yes" xml:space="preserve">
          <source>Subrange or subtype match: &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;range[T]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; matches &lt;code&gt;f&lt;/code&gt; exactly. Or: &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">하위 범위 또는 하위 유형 일치 : &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;range[T]&lt;/code&gt; 이고 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 와 정확히 일치 합니다. 또는 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="6ee14d0889156d81963bda220fbb8514a525f717" translate="yes" xml:space="preserve">
          <source>Subrange types</source>
          <target state="translated">하위 범위 유형</target>
        </trans-unit>
        <trans-unit id="041d20cfb351df25518b1fc63a1180aa4794aa06" translate="yes" xml:space="preserve">
          <source>Subranges</source>
          <target state="translated">Subranges</target>
        </trans-unit>
        <trans-unit id="b5f3755a0b5ea501c2ceef9602ab2b833039d687" translate="yes" xml:space="preserve">
          <source>Substitution Expressions (subex)</source>
          <target state="translated">대체 표현 (subex)</target>
        </trans-unit>
        <trans-unit id="10ae1fbab8828c5f045753afbdada38d4797d019" translate="yes" xml:space="preserve">
          <source>Substitution variables can also be words (that is &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt;) in which case the arguments in &lt;em&gt;a&lt;/em&gt; with even indices are keys and with odd indices are the corresponding values. An example:</source>
          <target state="translated">대체 변수는 또한 단어가 될 수있다 (하다 &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt; )이 경우에 인자 짝수 인덱스를 가지는 키 및 홀수 인덱스와의 대응 값은이다. 예를 들면 :&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="834dbbb6edc63f93dd355df612f58e6f6c9305b3" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;.</source>
          <target state="translated">하위 문자열은 &lt;em&gt;seps&lt;/em&gt; 만 포함하는 하위 문자열로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d2ec85e175386f10e5a8dc9ec3874b1df9dc2ae" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;. Examples:</source>
          <target state="translated">하위 문자열은 &lt;em&gt;seps&lt;/em&gt; 만 포함하는 하위 문자열로 구분됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="9b3a380e1c6cb3aaa0328c36e53f0fcd3dd31ec2" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the PEG &lt;em&gt;sep&lt;/em&gt;. Examples:</source>
          <target state="translated">하위 문자열은 PEG &lt;em&gt;sep&lt;/em&gt; 로 구분됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="e91de9d53e26c3248ed96f64d99b705efaf9da39" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the character &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">부분 문자열은 문자 &lt;em&gt;sep&lt;/em&gt; 로 구분됩니다 . 코드:</target>
        </trans-unit>
        <trans-unit id="5bff515ff93456666b03df7f012092cf65f567c4" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the regular expression &lt;code&gt;sep&lt;/code&gt; (and the portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned).</source>
          <target state="translated">문자열이 정규 표현식에 의해 분리된다 &lt;code&gt;sep&lt;/code&gt; (과 일치하는 부분 &lt;code&gt;sep&lt;/code&gt; 리턴되지 않는다).</target>
        </trans-unit>
        <trans-unit id="e8588d2a952b8b1b868045a8e60e1b1612fbdf6e" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">부분 문자열은 문자열 &lt;em&gt;sep&lt;/em&gt; 로 구분됩니다 . 코드:</target>
        </trans-unit>
        <trans-unit id="969d144035ae8c1097f28295048d2e10839468b5" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. This is a wrapper around the &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt;.</source>
          <target state="translated">부분 문자열은 문자열 &lt;em&gt;sep&lt;/em&gt; 로 구분됩니다 . 이것은 &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator를&lt;/a&gt; 감싸는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="518967ba497c08dc430a7afa2799aa4c61e41859" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the char &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">부분 문자열은 char &lt;em&gt;sep에&lt;/em&gt; 의해 오른쪽에서 분리됩니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2cd528c9f9109219b97fe511dbbed0b9acbd1118" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the set of chars &lt;em&gt;seps&lt;/em&gt;</source>
          <target state="translated">문자열이 문자의 집합으로 오른쪽 분리 &lt;em&gt;SEPS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e2f8adf7c1cab6995d76bf2a7d0ca46134fd40b" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the string &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">부분 문자열은 문자열 &lt;em&gt;sep에&lt;/em&gt; 의해 오른쪽에서 분리됩니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f96fd7e06b2e3440bae01cbcfe7490ed94381668" translate="yes" xml:space="preserve">
          <source>Subtract &lt;code&gt;interval&lt;/code&gt; from &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are subtracted in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 에서 &lt;code&gt;interval&lt;/code&gt; 을 뺍니다 . 에서 구성 요소 &lt;code&gt;interval&lt;/code&gt; 크기의 순서로 차감 즉, 먼저 &lt;code&gt;years&lt;/code&gt; 구성 요소, 다음 &lt;code&gt;months&lt;/code&gt; 구성 요소 등) 됩니다. 반환 된 &lt;code&gt;DateTime&lt;/code&gt; 은 입력과 동일한 시간대를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="76bc475fe96d51312be250027df1a17a17035b2c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">에서 &lt;em&gt;y&lt;/em&gt; 를 빼기&lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b1dcda865799d69866263f2964a5c388fd816f8c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">복소수에서 &lt;em&gt;y&lt;/em&gt; 를 빼기&lt;em&gt; x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4f3fc03c45197f8110a3f544c2fd44b496e0b4" translate="yes" xml:space="preserve">
          <source>Subtract a duration from another.</source>
          <target state="translated">다른 기간에서 기간을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="0a0ad440585f43f54b766a259c1467e330bf63c8" translate="yes" xml:space="preserve">
          <source>Subtract int &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 에서 int &lt;em&gt;y&lt;/em&gt; 빼기&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5428a30fe88840d786a7f61b7d233914d258e100" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from int &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">int &lt;em&gt;x&lt;/em&gt; 에서 유리수 &lt;em&gt;y&lt;/em&gt; 를 뺍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41acafc64eeedf3eca00c862873071d48f536cc2" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 에서 유리수 &lt;em&gt;y&lt;/em&gt; 를 뺍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bef7ee0413bb39584843be44a786acae479c9b7" translate="yes" xml:space="preserve">
          <source>Subtract two complex numbers.</source>
          <target state="translated">두 개의 복소수를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="7189d91ec5033b9efd0a25062c31f9a16c88f644" translate="yes" xml:space="preserve">
          <source>Subtract two rational numbers.</source>
          <target state="translated">두 개의 유리수를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="000947a7b3b6b45852df6f5a592408f7e55c3bb3" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;em&gt;interval&lt;/em&gt; from Time &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">감산은 &lt;em&gt;간격&lt;/em&gt; 시간에서 &lt;em&gt;시간&lt;/em&gt; . 경우 &lt;em&gt;간격이&lt;/em&gt; 어떤 년, 월, 주 또는 일을 포함하는 작업이 로컬 시간대에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="333dcd5ddf8f4d8066eab6ce4acb5ae7c09ae03c" translate="yes" xml:space="preserve">
          <source>Subtracts TimeInterval &lt;code&gt;ti1&lt;/code&gt; from &lt;code&gt;ti2&lt;/code&gt;.</source>
          <target state="translated">감산 TimeInterval이 &lt;code&gt;ti1&lt;/code&gt; 에서 &lt;code&gt;ti2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6179323b99f6b40288e7176393e0e598ec9f2ba" translate="yes" xml:space="preserve">
          <source>Subtracts a duration of time from a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">A로부터 시간의 기간 뺍 &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dcbc2b9a13a2d866e0df3c601f071ff376561ec" translate="yes" xml:space="preserve">
          <source>Subtracts complex &lt;em&gt;y&lt;/em&gt; from float &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">float &lt;em&gt;x&lt;/em&gt; 에서 복소수 &lt;em&gt;y&lt;/em&gt; 를 뺍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c88d3850624fa5509b42b7c6454e560083b18e5" translate="yes" xml:space="preserve">
          <source>Subtracts float &lt;em&gt;y&lt;/em&gt; from complex &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">복소수 &lt;em&gt;x&lt;/em&gt; 에서 float &lt;em&gt;y&lt;/em&gt; 를 뺍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f70590b4a99f5ea41cbbb277fc8ae20c97c2f508" translate="yes" xml:space="preserve">
          <source>Subtype relation</source>
          <target state="translated">하위 유형 관계</target>
        </trans-unit>
        <trans-unit id="0dfbf551cd1febe9be3271e47b0ace6915b7e99f" translate="yes" xml:space="preserve">
          <source>Success, SuccessX</source>
          <target state="translated">성공, 성공 X</target>
        </trans-unit>
        <trans-unit id="d9aa2dd47e2183e4004b0890583ddab7b0dd3b84" translate="yes" xml:space="preserve">
          <source>Successful compilation of a library or a binary.</source>
          <target state="translated">라이브러리 또는 바이너리를 성공적으로 컴파일했습니다.</target>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="8e3e076ed673ec7f1a40d1724dfcc98398c4fee1" translate="yes" xml:space="preserve">
          <source>Sugar for contains</source>
          <target state="translated">포함하는 설탕</target>
        </trans-unit>
        <trans-unit id="2b0f1741006e1749638aebbba0c62519275602e6" translate="yes" xml:space="preserve">
          <source>Sugar for not containing</source>
          <target state="translated">함유하지 않은 설탕</target>
        </trans-unit>
        <trans-unit id="861edba00547bc9ce7a08df78d4378766418179f" translate="yes" xml:space="preserve">
          <source>Suggestions</source>
          <target state="translated">Suggestions</target>
        </trans-unit>
        <trans-unit id="941d7d9ac0746aafb3a7018083b0465f921dce61" translate="yes" xml:space="preserve">
          <source>Supported OS primitives: &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt; and Windows &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">지원되는 OS의 기본 요소 : &lt;code&gt;epoll&lt;/code&gt; , &lt;code&gt;kqueue&lt;/code&gt; , &lt;code&gt;poll&lt;/code&gt; 및 Windows &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f3ef8bd9a226a902e3da626f593d8f6bdd720e" translate="yes" xml:space="preserve">
          <source>Supported PEG grammar</source>
          <target state="translated">지원되는 PEG 문법</target>
        </trans-unit>
        <trans-unit id="9d80112951ed980c75468e1be3b86df0f222e090" translate="yes" xml:space="preserve">
          <source>Supported features: files, sockets, pipes, timers, processes, signals and user events.</source>
          <target state="translated">지원되는 기능 : 파일, 소켓, 파이프, 타이머, 프로세스, 신호 및 사용자 이벤트.</target>
        </trans-unit>
        <trans-unit id="922e354db556982aaec9d3960cdeb221956777ff" translate="yes" xml:space="preserve">
          <source>Supported syntax with default empty &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt;:</source>
          <target state="translated">기본 비어있는 &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; 을 지원하는 구문 :</target>
        </trans-unit>
        <trans-unit id="52fecfba1182fabfdebf61ef0bd285c76b11a6aa" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the current async procedure for the next &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">다음 &lt;code&gt;ms&lt;/code&gt; 밀리 초 동안 현재 비동기 프로 시저 실행을 일시 중단합니다 .</target>
        </trans-unit>
        <trans-unit id="d5c77fcc8428eb1c29fb0edea391c5fde177f006" translate="yes" xml:space="preserve">
          <source>Suspends the process &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="translated">프로세스 &lt;em&gt;p를&lt;/em&gt; 일시 중단합니다 .</target>
        </trans-unit>
        <trans-unit id="ff172170c09b0a3f643ea6f3860725b0e3adcde6" translate="yes" xml:space="preserve">
          <source>Swaps the case of unicode characters in &lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">유니 코드 문자의 경우를 &lt;em&gt;s로&lt;/em&gt; 바꿉니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55b596882450b0f897f71f7b842053dfc1583f85" translate="yes" xml:space="preserve">
          <source>Swaps the positions of elements in a sequence randomly.</source>
          <target state="translated">순서대로 요소의 위치를 ​​무작위로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0ccabcb7feef7d8bfe041ead9426ae3125086c8c" translate="yes" xml:space="preserve">
          <source>Symbol binding in templates</source>
          <target state="translated">템플릿의 심볼 바인딩</target>
        </trans-unit>
        <trans-unit id="e15d9719893fff31a651b51709f3f17053857c18" translate="yes" xml:space="preserve">
          <source>Symbol lookup in generics</source>
          <target state="translated">제네릭의 심볼 조회</target>
        </trans-unit>
        <trans-unit id="93722351d20a0af3b4b9e37b38817089ab39c090" translate="yes" xml:space="preserve">
          <source>Symbol lookup of the identifiers &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; is performed after the rewriting step, so that all overloads of &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; are taken into account.</source>
          <target state="translated">식별자 &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; 의 심볼 조회는 재 작성 단계 후에 수행되므로, &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; 의 모든 과부하 가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="84e33e2c80c65f15d6048f2ca6f92d94cfd3e6de" translate="yes" xml:space="preserve">
          <source>Symbol usages</source>
          <target state="translated">기호 사용법</target>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="translated">심볼릭 링크.</target>
        </trans-unit>
        <trans-unit id="11ad0ab4dc32899beb01665dac0504b053480af8" translate="yes" xml:space="preserve">
          <source>Symbols declared in an &lt;em&gt;enter&lt;/em&gt; handler can be made visible in the corresponding &lt;em&gt;leave&lt;/em&gt; handler by annotating them with an &lt;em&gt;inject&lt;/em&gt; pragma.</source>
          <target state="translated">&lt;em&gt;enter&lt;/em&gt; 처리기에 선언 된 기호 는 &lt;em&gt;주입&lt;/em&gt; pragma 로 주석을 달아 해당 &lt;em&gt;휴가&lt;/em&gt; 처리기에 표시 될 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4b7119bc873b1a47de2955098054673778589df" translate="yes" xml:space="preserve">
          <source>Synonym for existsDir</source>
          <target state="translated">존재의 동의어</target>
        </trans-unit>
        <trans-unit id="ba60d4cc263ff180c27a4a09e6b636cd98ac4e3b" translate="yes" xml:space="preserve">
          <source>Synonym for existsFile</source>
          <target state="translated">existFile의 동의어</target>
        </trans-unit>
        <trans-unit id="e8aa2bdcd24d6964731df6f38e8110132abbce66" translate="yes" xml:space="preserve">
          <source>Syntactically a &lt;em&gt;type conversion&lt;/em&gt; is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</source>
          <target state="translated">구문 상 &lt;em&gt;유형 변환&lt;/em&gt; 은 프로 시저 호출과 유사하지만 유형 이름이 프로 시저 이름을 대체합니다. 형식 변환은 형식을 다른 형식으로 변환하지 못하면 예외가 발생한다는 점에서 항상 안전합니다 (정적으로 결정할 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="9c59412440fcb6dd3270f66f446a4acc85d89be4" translate="yes" xml:space="preserve">
          <source>Syntax sugar for anonymous procedures.</source>
          <target state="translated">익명의 절차를위한 구문 설탕.</target>
        </trans-unit>
        <trans-unit id="a492d9c66fdcf105c885da59425dccb0b62e918e" translate="yes" xml:space="preserve">
          <source>Syntax sugar for procedure types.</source>
          <target state="translated">프로 시저 유형의 구문 설탕.</target>
        </trans-unit>
        <trans-unit id="2e2159d4e1bf250922bd0a832c5179a9837c51e5" translate="yes" xml:space="preserve">
          <source>T = enum</source>
          <target state="translated">T = 열거 형</target>
        </trans-unit>
        <trans-unit id="4434fd593bde3375839bc932883b120b979c7044" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">이 소프트웨어는 저작권 소유자 및 배포자에 의해 &quot;있는 그대로&quot;제공되며, 명시 적 또는 묵시적 보증을 포함하되 이에 국한되지는 않지만 상품성 및 특정 목적에의 적합성에 대한 묵시적 보증은 이에 제한되지 않습니다. 어떠한 경우에도 저작권 소유자 나 제공자는 직접적, 간접적, 우발적, 특별, 간접적 또는 결과적 손해에 대해 책임을지지 않습니다 (대체 상품 또는 서비스의 제조, 데이터 손실, 사용 손실, 데이터 손실). 또는 비즈니스 중단) 계약, 엄격 책임 또는 불법 행위 (어떠한 태만 또는 기타 포함)에 관계없이 본 소프트웨어를 사용하지 않더라도 본 소프트웨어를 사용하지 않더라도 발생하는 책임 이론에 따라 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7cbcc89bc56ee06c7485bd88edf78b958d325e03" translate="yes" xml:space="preserve">
          <source>TODO: &lt;code&gt;/dev/poll&lt;/code&gt;, &lt;code&gt;event ports&lt;/code&gt; and filesystem events.</source>
          <target state="translated">TODO : &lt;code&gt;/dev/poll&lt;/code&gt; , &lt;code&gt;event ports&lt;/code&gt; 및 파일 시스템 이벤트.</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">테이블 생성자</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">태그 추적</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">오염 모드</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">유형을 &lt;code&gt;proc&lt;/code&gt; 로 선언 할 때는 특히주의하십시오 . 이 동작은 아래의 &lt;code&gt;Procedure declaration&lt;/code&gt; 과 비슷 하지만 &lt;code&gt;nnkGenericParams&lt;/code&gt; 를 처리하지 않습니다 . 일반 매개 변수는 &lt;code&gt;proc&lt;/code&gt; 자체가 아닌 유형으로 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">소요 &lt;code&gt;typedesc&lt;/code&gt; 의 첫 번째 인수로, 그리고 형의 표현의 일련의 &lt;code&gt;key: value&lt;/code&gt; , 각 필드에 지정된 유형의 값을 반환 &lt;code&gt;key&lt;/code&gt; 에 설정 &lt;code&gt;value&lt;/code&gt; 의 인수에 지정된대로 &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">유닉스 시대 이후의 시간 (초)을 포함하는 부동 소수점을 가져 와서 시간 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">유닉스 시대 이후의 초 수를 포함하는 int를 취하여 시간 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">정수를 취하고 &quot;hello world!&quot;를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">여러 시퀀스의 항목을 가져 와서 새로운 시퀀스로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">프로 시저 이름을 가져 와서 첫 번째 인수가없는 람다로 래핑합니다. &lt;code&gt;this&lt;/code&gt; 인수는 내장 된 JavaScript 를 프로 시저의 첫 번째 인수로 전달합니다. 결과 람다를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">템플릿 선언</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">왼쪽에서 오른쪽으로 시퀀스를 접어 누적을 반환하는 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">시퀀스를 오른쪽에서 왼쪽으로 접어 누적을 반환하는 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">&lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; 컴파일 타임 스위치 에 따라 stdout 또는 stderr로 확장되는 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">매크로와 마찬가지로 템플릿은 프로세스 및 반복기와 비교할 때 AST가 약간 확장되었습니다. 그 이유는 [term-rewriting macros] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; 입니다. 통지 &lt;code&gt;nnkEmpty()&lt;/code&gt; 의 두 번째 인수로 &lt;code&gt;nnkProcDef&lt;/code&gt; 및 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 위를? 그것은 용어 재 작성 매크로가가는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">템플릿은 Nim의 추상 구문 트리에서 작동하는 간단한 대체 메커니즘입니다. 템플릿은 컴파일러의 시맨틱 패스에서 처리됩니다. 이들은 나머지 언어와 잘 통합되며 C의 전 처리기 매크로 결함을 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">템플릿은 특히 게으른 평가 목적에 유용합니다. 로깅을위한 간단한 proc을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readLine&lt;/code&gt; 을 위한 임시 저장소</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">용어 재 작성 매크로</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">용어 다시 쓰기 매크로는 &lt;em&gt;이름&lt;/em&gt; 뿐만 아니라 컴파일러의 의미 검사 단계 이후에 검색 되는 &lt;em&gt;패턴&lt;/em&gt; 을 가진 매크로 또는 템플릿입니다 . 이는 사용자 정의 최적화를 통해 컴파일 파이프 라인을 쉽게 향상시킬 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">터미널 기호</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 심볼 : &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">비동기 http 서버 인스턴스를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">서버에 대한 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">테스트 케이스 파일 형식</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">블록 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">문자 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">디렉토리를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">메시지 큐를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">파이프 또는 FIFO 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">일반 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">세마포어를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">공유 메모리 객체를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">소켓을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">심볼릭 링크를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">전달 된 &lt;em&gt;예외&lt;/em&gt; 에서 &lt;em&gt;body&lt;/em&gt; 가 예외를 발견 했는지 테스트합니다 . 발생한 예외가 허용 가능한 예외의 일부이면 테스트에 통과합니다. 그렇지 않으면 실패합니다. 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">형식화 된 메모리 개체에 대한 테스트 매크로</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">테스트 스위트</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Linux, Windows, OSX와 같은 OS에서 테스트</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">테스트는 내포 될 수 있지만 내포 된 테스트 실패는 상위 테스트를 실패한 것으로 표시하지 않습니다. 설정 및 해제가 상속됩니다. 로컬로 설정을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">일치하는 테스트 &lt;strong&gt;어떤&lt;/strong&gt; 인수가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">DOM 구현이 특정 기능을 구현하고 해당 기능이이 노드에서 지원되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Amd64에서 GCC를 사용한 테스트에서 '환경'포인터가 첫 번째 인수가 아닌 마지막 인수로 전달되면 실제로 이점이 있음을 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">조건부 구문 &lt;code&gt;$[0|1|2|else]&lt;/code&gt; 덕분 에 형식 문자열 리터럴의 &lt;span id=&quot;internationalization_1&quot;&gt;국제화&lt;/span&gt; 를 상당히 잘 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">즉, 첫 글자 만 대소 문자 구분 방식으로 비교됩니다. 다른 문자는 ASCII 범위 내에서 대소 문자를 구분하지 않고 비교되며 밑줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">즉, 소문자로 변환하고 '_'를 제거하는 것을 의미합니다. Nim 식별자 이름을 정규화하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">&quot;``&quot;표기법을 사용하여 다른 절차와 마찬가지로 연산자를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">&quot;hello world&quot;프로그램에는 컴파일러에 이미 알려진 몇 가지 식별자 ( &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; 등) 가 포함되어 있습니다 . 이러한 내장 기능은 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈 에서 선언되며 다른 모듈에서 내재적으로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">템플릿의 &quot;유형&quot;은 &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 기호 일 수 있습니다 . 이들은 &quot;메타 유형&quot;이며 특정 상황에서만 사용할 수 있습니다. 일반 유형도 사용할 수 있습니다. 이는 &lt;code&gt;typed&lt;/code&gt; 표현식이 예상 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">'정밀도'는 부동 소수점 변환에서 소수점 뒤에 표시되어야하는 자릿수를 나타내는 10 진수입니다. 숫자가 아닌 유형의 경우이 필드는 최대 필드 크기, 즉 필드 내용에서 사용될 문자 수를 나타냅니다. 정수 변환의 경우 정밀도는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">'return'문은 제어 흐름 속성이 필요할 때 이상적으로 사용해야합니다. 가능할 때마다 프로 시저의 내재적 'result'변수를 사용하십시오. 가독성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">'sign'옵션은 숫자 유형에만 유효하며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">프로그램을 빌드하는 데 사용 된 아키텍처에서 부동 소수점 유형을 나타내는 데 사용되는 기수의 값 (정수)입니다.</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">이 페이지 의 &lt;a href=&quot;#nimble&quot;&gt;하단&lt;/a&gt; 에는 Nim 커뮤니티에서 만든 타사 패키지 목록이 포함되어 있습니다. 이 패키지는 표준 라이브러리의 모듈에 유용한 추가 기능입니다.</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">&lt;a href=&quot;nimc&quot;&gt;님 컴파일러 사용 설명서의&lt;/a&gt; 사용하여 문서 전형적인 컴파일러 호출, &lt;code&gt;compile&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 변환 명령을 &lt;code&gt;.nim&lt;/code&gt; 하나 개 이상에 파일을 &lt;code&gt;.c&lt;/code&gt; 인 다음 정적 바이너리로 플랫폼의 C 컴파일러로 컴파일 된 파일. 그러나 C ++, Objective-C 또는 JavaScript로 컴파일하는 다른 명령이 있습니다. 이 문서는 모든 백엔드 및 인터페이스 옵션을 한곳에 집중하려고합니다.</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; 명령 줄 스위치 대신 정적으로 링크 뭔가 필요하면 연결 동적를 방지 할 수 있습니다. 소스 파일을 정적으로 링크하도록 설계된 Nim 래퍼 는 소스가 적거나 시스템 라이브러리를 사용하는 것보다 Nim 코드를 따라 제공하는 것이 더 쉬운 경우 &lt;a href=&quot;nimc#compile-pragma&quot;&gt;컴파일 프라그 마를&lt;/a&gt; 사용할 수 있습니다 . 호스트 시스템에 설치된 라이브러리는 &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt; 와 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">&lt;a href=&quot;system#inc&quot;&gt;INC는&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;십이&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;SUCC&lt;/a&gt; 및 &lt;a href=&quot;system#pred&quot;&gt;PRED&lt;/a&gt; 동작은 상승하여 실패 할 수 &lt;em&gt;EOutOfRange&lt;/em&gt; 또는 &lt;em&gt;EOVERFLOW&lt;/em&gt; 예외. (적절한 런타임 검사를 설정 한 상태에서 코드를 컴파일 한 경우)</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; 의 운영자는 사실 템플릿에 있습니다</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">는 &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; 의 운영자는 사실 템플릿에있는이는 이점이 당신이 과부하 경우 그 &lt;code&gt;==&lt;/code&gt; 연산자는 &lt;code&gt;!=&lt;/code&gt; 연산자가 자동으로 사용할 수 있고 옳은 일을한다. (IEEE 부동 소수점 수를 제외하고-NaN은 기본 부울 논리를 중단합니다.)</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; 와 &lt;code&gt;#dynlib&lt;/code&gt; 의 지시는 상호 배타적입니다. &lt;code&gt;dynlib&lt;/code&gt; 를 사용하는 바인딩 은 &lt;code&gt;header&lt;/code&gt; 를 사용하는 바인딩 보다 훨씬 선호됩니다 ! Nim 컴파일러는 C 코드를 생성하지 않는 백엔드에서는 작동하지 않으므로 향후 &lt;code&gt;header&lt;/code&gt; pragma에 대한 지원을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; 지시어는 C 함수 프로토 타입과와 모든 수출 변수를 입력으로 인한 모든 시저에 주석을해야 c2nim을 알려줍니다 &lt;code&gt;header&lt;/code&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">&lt;code&gt;#skipcomments&lt;/code&gt; 의 지시어는 c2nim는 의견을 무시하고 생성 님 파일로 복사 할 수 있도록 C 코드에 투입 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">&lt;code&gt;#typeprefixes&lt;/code&gt; 의 지시어는 c2nim가 생성 만들기 위해 C 코드로 넣을 수 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 정의 된 모든 유형에 대한 접두사.</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 운영자는 그 이름에 어떤 열거 값을 변환 할 수 있습니다, 그리고 &lt;code&gt;ord&lt;/code&gt; PROC는 기본 정수 값으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">는 &lt;code&gt;**&lt;/code&gt; 많이 같다 &lt;code&gt;*&lt;/code&gt; 그뿐만 아니라 모든 인수를 수집하지만 것을 제외하고, 운영자도 역 폴란드어 표기법으로 일치 운영자 :</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 연산자 수 &lt;em&gt;평탄화&lt;/em&gt; 등 중첩 진 식 &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; 에 &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; idetools 스위치는 제안 전환에 매우 유사하지만, 대신에 사용자가 점 문자를 입력 한 후 사용되는,이 하나는 사용자가 입력 매개 변수를 시작하기 위해 여는 중괄호를 입력 한 후 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;--def&lt;/code&gt; idetools는 특정 기호의 정의에 대해 수행에게 질의를 전환 할 수 있습니다. 가능한 경우, idetools는 유형, 소스 파일, 행 / 열 정보 및 기타 문서 데이터 (문서 문자열과 같은 경우)로 응답합니다. 이 정보를 통해 IDE는 사용자가 커서를 심볼 위에 놓거나 마우스를 사용하여 심볼을 선택하고 심볼이있는 위치로 리디렉션 되는 일반적인 &lt;em&gt;점프 정의를&lt;/em&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;컴파일러 스위치를&lt;/a&gt; 변경하는 데 사용할 수 있습니다 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">&lt;code&gt;--suggest&lt;/code&gt; idetools 파일의 어느 시점에서 수행을 가능 완료 기호에 대한 질의를 전환 할 수 있습니다. IDE는 IDE가 현재 파일 (및 편집중인 언어에 대해 알고 있고 포함 / 가져 오기를 따르는 경우 관련 파일)을 스캔하고 사용자가 무언가를 입력하기 시작할 때 다른 옵션을 가진 완료 상자가 나타나는 자동 완성 기능을 쉽게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">&lt;code&gt;--usages&lt;/code&gt; 의 idetools은 위치에 나열 심볼의 모든 용도를 전환 할 수 있습니다. IDE는이를 사용하여 파일에서 기호가 사용 된 모든 위치를 찾고 동시에 모든 위치에서 이름을 바꿀 수 있습니다. 다시 말하지만 순수한 문자열 기반 검색 및 바꾸기는 함수 / 루프 범위에서 심볼을 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; (튜플 / 객체 필드 연산자에 액세스) 및 &lt;code&gt;[]&lt;/code&gt; (배열 / 문자열 / 시퀀스 인덱스 연산자) 연산자는 참조 유형에 대해 암시 적 역 참조 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">&lt;code&gt;C2NIM&lt;/code&gt; 의 기호 만 인식되고 &lt;code&gt;#ifdef&lt;/code&gt; 와 와 &lt;code&gt;#ifndef&lt;/code&gt; 구조! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; 가 작동 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 유형은 구문 분석과 다른 사용하여 포맷 할 수 있습니다 &lt;code&gt;parse&lt;/code&gt; 및 &lt;code&gt;format&lt;/code&gt; 절차를.</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InvalidObjectConversionError&lt;/code&gt; 의 경우 예외가 발생 &lt;code&gt;x&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">&lt;code&gt;RstParseOptions&lt;/code&gt; 는 , &lt;code&gt;FindFileHandler&lt;/code&gt; 및 &lt;code&gt;MsgHandler&lt;/code&gt; 유형은 상기에서 정의 된 &lt;a href=&quot;rst&quot;&gt;패키지 / docutils / RST 모듈&lt;/a&gt; . &lt;code&gt;options&lt;/code&gt; 은 첫 번째 파서의 동작을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 불리며 &lt;span id=&quot;generic-type-parameter_1&quot;&gt;제네릭 형식 매개 변수&lt;/span&gt; 또는 &lt;span id=&quot;type-variable_1&quot;&gt;형식 변수&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">는 &lt;code&gt;[: ]&lt;/code&gt; 표기법이 문제를 완화하기 위해 설계되었다 : &lt;code&gt;x.p[:T]&lt;/code&gt; 에 파서 재기록 &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt; 에 재 기입 &lt;code&gt;p[T](x, y)&lt;/code&gt; . 참고 있음 &lt;code&gt;[: ]&lt;/code&gt; 에는 AST 표현이없는, 재기록이 파싱 단계에서 직접 수행된다.</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 배열 액세스 연산자 과부하 제공 할 수 &lt;span id=&quot;array-properties_1&quot;&gt;배열 특성&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 지정된 필드가 존재하지 않을 때, 운영자는 예외를 발생시킬 것이다. 이 동작을 피하려면 대신 &lt;code&gt;{}&lt;/code&gt; 연산자를 사용 하면 필드를 찾을 수 없을 때 단순히 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다. &lt;code&gt;get&lt;/code&gt; 호출 할 때 -family 절차는 기본 값을 반환합니다 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 어레이 / openarrays / 시퀀스 첨자 연산자 과부하 될 수있다.</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">&lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 주장은 오직 매우 시작과 옵션이 설정되어 어떤 주제 문자열의 끝과 일치하는지의 전통적인 곡절과 달러 다르다. 차이 &lt;code&gt;\Z&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 하다 &lt;code&gt;\Z&lt;/code&gt; 반면, 문자열뿐만 아니라, 스트링의 끝에서 마지막 문자 개행 전에 일치 &lt;code&gt;\z&lt;/code&gt; 마지막에만 일치한다.</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt; 의 접미사는 릴리스 빌드에 사용되는 &lt;code&gt;_d&lt;/code&gt; 디버그 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 의 기간 동안 연결 소켓 연결을 끊이 경우 호출이 오류가 발생할 수 있습니다 &lt;code&gt;accept&lt;/code&gt; . &lt;code&gt;SafeDisconn&lt;/code&gt; 플래그가 지정 되면 이 오류가 발생하지 않고 대신 accept가 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">&lt;code&gt;acyclic&lt;/code&gt; 가 순환 것 같다하지만 pragma는 비순환도로를 표시 할 객체 유형에 사용할 수 있습니다. 이것은 가비지 수집기가이 유형의 객체를주기의 일부로 간주하지 않도록 &lt;strong&gt;최적화&lt;/strong&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 연산자는 L 값의 주소를 반환한다. 위치 유형이 &lt;code&gt;T&lt;/code&gt; 인 경우 &lt;em&gt;가산기&lt;/em&gt; 연산자 결과는 &lt;code&gt;ptr T&lt;/code&gt; 유형 입니다. 주소는 항상 추적되지 않은 참조입니다. 포인터가 스택의 객체보다 오래 존재할 수 있으므로 존재하지 않는 객체를 참조 할 수 있으므로 스택 에있는 객체의 주소를 가져 오는 것은 &lt;strong&gt;안전하지&lt;/strong&gt; 않습니다. 변수의 주소를 얻을 수는 있지만 &lt;code&gt;let&lt;/code&gt; 문을 통해 선언 된 변수에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 절차는 또한 try 문에 대한 제한적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 유형은 반환 형식과 매개 변수에 사용할 수 있습니다. 리턴 유형의 경우 컴파일러가 루틴 본문에서 유형을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; 를 호출은 많은 상황에서 사용할 수있다. 변수 선언의 오른쪽에서 사용할 수 있습니다 : &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; ,이 경우 변수는 미래의 값으로 자동 설정됩니다. 대기하기 위해 사용될 수있는 &lt;code&gt;Future&lt;/code&gt; 개체를 복귀 절차 기다린다 사용될 수있다 &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 문은 대응합니다 &lt;code&gt;mixin&lt;/code&gt; 문. 초기에 바인딩해야하는 식별자를 명시 적으로 선언하는 데 사용할 수 있습니다 (즉, 식별자는 템플릿 / 일반 정의의 범위에서 찾아야 함).</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">&lt;code&gt;bitsize&lt;/code&gt; pragma는 개체 필드 회원입니다. C / C ++에서 필드를 비트 필드로 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">&lt;code&gt;borrow&lt;/code&gt; pragma는 컴파일러가 구별 유형의 기본 유형 거래, 어떤 코드가 생성되지 않도록하는 시저와 같은 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 문은 즉시 블록을두고하는 데 사용됩니다. 경우 &lt;code&gt;symbol&lt;/code&gt; 주어집니다, 그것은 떠날 것입니다 바깥 쪽 블록의 이름입니다. 없는 경우 가장 안쪽 블록이 남습니다.</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">&lt;code&gt;bycopy&lt;/code&gt; 프라그 개체 또는 튜플 타입인가에 프록 값 유형을 전달하도록 컴파일러에 지시 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">&lt;code&gt;byref&lt;/code&gt; 프라그 개체 또는 튜플 타입에 적용 프록 참조 (숨겨진 포인터)으로 입력을 전달하도록 컴파일러에 지시 할 수있다.</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 제약 복사하는 의미를 가지고 종류의 이동 최적화를 구현하는 데 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 문은 if 문과 비슷하지만 여러 가지 선택을 나타냅니다. 키워드 후의 식 &lt;code&gt;case&lt;/code&gt; 평가되고 그 값이있는 경우 &lt;em&gt;slicelist&lt;/em&gt; (애프터 해당 문장 &lt;code&gt;of&lt;/code&gt; 키워드)가 실행된다. 값이 주어진에없는 경우 &lt;em&gt;slicelist &lt;/em&gt; &lt;code&gt;else&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;else&lt;/code&gt; 부분 이없고 &lt;code&gt;expr&lt;/code&gt; 이 보유 할 수있는 모든 가능한 값이 &lt;code&gt;slicelist&lt;/code&gt; 에서 발생 하지 않으면 정적 오류가 발생합니다. 이것은 서수 유형의 표현에만 적용됩니다. 의 &quot;모든 가능한 값&quot; &lt;code&gt;expr&lt;/code&gt; 에가 결정된다 &lt;code&gt;expr&lt;/code&gt; 의 유형입니다. 정적 오류를 억제하려면 빈 &lt;code&gt;discard&lt;/code&gt; 명령문이 있는 &lt;code&gt;else&lt;/code&gt; 부분을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">&lt;code&gt;codegenDecl&lt;/code&gt; 의 프라그를 직접 님의 코드 생성기에 영향을 줄 수 있습니다. 생성 된 코드에서 변수 또는 proc가 선언되는 방식을 결정하는 형식 문자열을받습니다.</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; pragma는 컴파일하는 데 사용하고 프로젝트와 C / C ++ 소스 파일을 링크 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt; 프라그은 컴파일시에 사용하는 PROC 또는 변수를 표시하는 데 사용됩니다. 코드가 생성되지 않습니다. 컴파일 타임 프로세서는 매크로의 도우미로 유용합니다. 언어, 사용을하는 시저의 버전 0.12.0 이후 &lt;code&gt;system.NimNode&lt;/code&gt; 의 매개 변수 유형 내에서 암시 적 선언 &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">&lt;code&gt;computedGoto&lt;/code&gt; 의 프라그는 어떻게 님의 컴파일하는 컴파일러에게하는 데 사용할 수있는 &lt;span id=&quot;case_2&quot;&gt;경우를&lt;/span&gt; A의 &lt;code&gt;while true&lt;/code&gt; 문. 문법적으로 루프 내부에서 명령문으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;con&lt;/code&gt; Nimsuggest 명령은 제안 명령, 대신 사용자가 점 문자를 입력 한 후 사용되는 매우 비슷합니다,이 하나는 사용자가 입력 매개 변수를 시작하기 위해 여는 중괄호를 입력 한 후 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">&lt;em&gt;호환 가능한 문자열을&lt;/em&gt; 의미 하는 &lt;code&gt;cstring&lt;/code&gt; 유형 은 컴파일 백엔드에 대한 문자열의 기본 표현입니다. C 백엔드의 경우 &lt;code&gt;cstring&lt;/code&gt; 유형은 Ansi C의 &lt;code&gt;char*&lt;/code&gt; 유형과 호환되는 0으로 끝나는 char 배열에 대한 포인터를 나타냅니다 . 기본 목적은 C와 쉽게 인터페이스하는 데 있습니다. 인덱스 작업 &lt;code&gt;s[i]&lt;/code&gt; 는 i 번째 &lt;em&gt;char을&lt;/em&gt; 의미합니다. 의 &lt;code&gt;s&lt;/code&gt; ; 그러나 인덱스 작업을 안전하지 않게 만드는 &lt;code&gt;cstring&lt;/code&gt; 에 대한 경계 검사 가 수행 되지 않습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 때 전달됩니다 응용 프로그램 정의 데이터이며, &lt;code&gt;ev&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 로 처리 할 때 전달되는 애플리케이션 정의 데이터 인 &lt;code&gt;pid&lt;/code&gt; 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 신호가 상승 할 때 전달되는 애플리케이션 정의 데이터이다.</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 타이머가 트리거 될 때 전달됩니다 응용 프로그램 정의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;def&lt;/code&gt; Nimsuggest 명령을 수행하는 특정 기호의 정의에 대한 질의. 사용 가능한 경우 Nimsuggest는 유형, 소스 파일, 행 / 열 정보 및 기타 문서 데이터 (문서 문자열과 같은 경우)로 응답합니다. 이 정보를 통해 IDE는 사용자가 커서를 심볼 위에 놓거나 마우스를 사용하여 심볼을 선택하고 심볼이있는 위치로 리디렉션 되는 일반적인 &lt;em&gt;점프 정의를&lt;/em&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt; 문은 또한에 설명 된대로 블록 주석을 만드는 데 사용할 수있는 &lt;a href=&quot;#comments&quot;&gt;댓글&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt; 문은 부작용에 대한 표현을 평가하고 멀리 식의 결과 값을 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;doc&lt;/code&gt; 명령</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; 의 수입 메커니즘은 버전 관리 체계를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; 의 프라그 지원 일반적으로뿐만 아니라 일정 인수로 문자열뿐만 아니라 문자열 식 :</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">&lt;code&gt;effects&lt;/code&gt; 프라그는 효과 분석과 프로그래머를 지원하기 위해 설계되었습니다. 컴파일러가 모든 유추 된 효과를 &lt;code&gt;effects&lt;/code&gt; 위치 까지 출력하도록하는 명령문입니다 .</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt; 프라 그마 직접 컴파일러의 코드 생성기의 출력에 영향을 미칠 수 있습니다. 따라서 코드를 다른 코드 생성기 / 백엔드로 이식 할 수 없습니다. 사용을 권장하지 않습니다! 그러나 &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; 또는 &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; 코드 와 인터페이스하는 데 매우 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 절차는 소요 &lt;code&gt;openarray&lt;/code&gt; 을 모두 배열 및 시퀀스 파라미터로서 전달 될 수 있도록.</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그도 (반복자 또는 PROC 같이) 심볼 주석을 사용할 수있다. &lt;em&gt;사용&lt;/em&gt; 심볼의는 컴파일 타임 오류를 트리거합니다. 이는 오버로드 및 유형 변환으로 인해 일부 작업이 유효하다는 것을 배제하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그 지정된 콘텐츠 컴파일러 출력 된 에러 메시지를 만들기 위해 사용된다. 그래도 오류 후에 컴파일이 중단되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma는 실험적인 언어 기능을 사용할 수 있습니다. 구체적인 기능에 따라, 이는 안정적인 릴리스를 위해 기능이 너무 불안정한 것으로 간주되거나 기능의 미래가 확실하지 않다는 것을 의미합니다 (언제든지 제거 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; pragma는 유형, 변수, 또는 C. 열거 형 상수에 대한 절차를 내보낼 수 없습니다를 수출 할 수있는 방법을 제공합니다. 선택적 인수는 C 식별자를 포함하는 문자열입니다. 인수가 없으면 C 이름은 &lt;em&gt;철자 그대로&lt;/em&gt; 의 Nim 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에 &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 &lt;code&gt;result = expr&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 컴파일러에 의해 도입 된 특별한 상징이다.</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt; 프라그 컴파일러 출력을 지정된 콘텐츠 에러 메시지를 만들기 위해 사용된다. 받는 반면 &lt;code&gt;error&lt;/code&gt; 프라그 컴파일이 래그에 의해 중단되도록 보장된다. 예:</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; paramater 정적 분석을 위해 충분하지만, 십오하는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 사용자가 여전히 줄을 입력의 중간에있을 수 있습니다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;dirtyfile.nim&lt;/code&gt; 옵션을 사용하여 Nimsuggest에 foobar.nim 을 &lt;code&gt;temporary/foobar.nim&lt;/code&gt; 에서 &lt;code&gt;foobar.nim&lt;/code&gt; 한다고 알립니다 .</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; pragma는 그것에서 상속 할 수 없음을 지정하는 객체 유형에 사용할 수 있습니다. 상속은 기존 객체 ( &lt;code&gt;object of SuperType&lt;/code&gt; 구문 의 객체를 통해 )에서 &lt;code&gt;inheritable&lt;/code&gt; 되거나 inheritable 로 표시된 객체에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">&lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; 구문은 더 심미적으로 만족이지만, 작은 잡았다을 숨 깁니다. 문자열은 &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;일반화 된 원시 문자열 리터럴&lt;/a&gt; 입니다. 이것은 놀라운 효과가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 본체의 단부까지 그 범위에 도달 - 루프 반복 변수를 선언한다. 반복 변수의 유형은 반복자의 리턴 유형으로 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 시퀀스로 사용될 때 진술 한 두 변수가 사용될 수있다. 하나의 변수 형식을 사용하면 변수는 시퀀스에서 제공 한 값을 보유합니다. &lt;code&gt;for&lt;/code&gt; 문에서 결과를 통해 반복되는 &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;항목 ()&lt;/a&gt; 로부터 반복자 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈을. 그러나 두 변수 형식을 사용하면 첫 번째 변수는 인덱스 위치를 유지하고 두 번째 변수는 값을 보유합니다. 여기서 &lt;code&gt;for&lt;/code&gt; 문은 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈 에서 &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs ()&lt;/a&gt; 반복자 의 결과를 반복 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 문은 모든 요소를 통해 루프에 구조입니다 &lt;em&gt;반복자&lt;/em&gt; 제공합니다. 이 예제는 내장 &lt;a href=&quot;system#countup&quot;&gt;카운트 업&lt;/a&gt; 반복자 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 문은 또한하여 기호를 사용할 수 있도록하지만, 사용 자격이 될 필요가 기호에 네임 스페이스의 자격을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 키워드를 소개하는 바로 가기 &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect의&lt;/span&gt; PROC.</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 작업이 반환 위의 기본 가치를 입증, 또는 제기 &lt;code&gt;UnpackError&lt;/code&gt; 을 값이없는 경우. 값을 얻는 또 다른 옵션이 있습니다 : &lt;code&gt;unsafeGet&lt;/code&gt; , 값이 존재하는지 확실하게 확신 할 때만 (예 : &lt;code&gt;isSome&lt;/code&gt; 확인 후 ) 사용해야 합니다. 당신이 작은 오버 헤드가 신경 쓰지 않으면 &lt;code&gt;get&lt;/code&gt; 원인을, 당신은 단순히 사용해서는 안 &lt;code&gt;unsafeGet&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 프라그는 글로벌 위치에 저장하도록 컴파일러에 지시 발동 내의 변수에 적용 프로그램 시작시에 한번 초기화된다.</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt; 주석은 또한 객체 내에서 필드를 보호 할 수 있습니다. 그러면 가드는 동일한 객체 또는 전역 변수 내의 다른 필드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; pragma는 항상 문자열 상수를 기대하고있다. 문자열 상수는 헤더 파일을 포함합니다. C의 경우처럼 시스템 헤더 파일은 꺾쇠 괄호로 묶습니다 : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . 꺾쇠 괄호가 제공되지 않으면 Nim은 생성 된 C 코드에서 헤더 파일을 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 프라그는 매우 유사하다 &lt;code&gt;noDecl&lt;/code&gt; 의 프라그 :이 선언되지 않아야 대신 생성 된 코드가 포함되어야한다는 것은 거의 모든 기호와 지정에 적용 할 수 &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; 프라그 지정된 콘텐츠 컴파일러 힌트 출력 메시지를 만들기 위해 사용된다. 힌트 후에 컴파일이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 키워드 후 표현 : 문은 제어 흐름에 지점을 만들 수있는 간단한 방법입니다 &lt;code&gt;if&lt;/code&gt; 는 후 해당 문이 true 인 경우, 평가 &lt;code&gt;:&lt;/code&gt; 실행됩니다. 그렇지 않으면, &lt;code&gt;elif&lt;/code&gt; 이후의 표현식 이 평가되면 ( &lt;code&gt;elif&lt;/code&gt; 분기 가있는 경우), true 인 경우 &lt;code&gt;:&lt;/code&gt; 다음의 해당 명령문 이 실행됩니다. 이것은 마지막 &lt;code&gt;elif&lt;/code&gt; 까지 계속됩니다 . 모든 조건이 실패하면 &lt;code&gt;else&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;else&lt;/code&gt; 부분 이 없으면 다음 명령문으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; 프라그는 PROC 또는 C.에서 변수 선택적 인수는 C 식별자를 포함하는 문자열을 가져올 수있는 수단을 제공한다. 인수가 없으면 C 이름은 &lt;em&gt;철자 그대로&lt;/em&gt; 의 Nim 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">는 &lt;code&gt;include&lt;/code&gt; 는 단지 파일의 내용을 포함한다 : 문이 모듈을 가져 오는 것보다 근본적으로 다른 일을한다. 는 &lt;code&gt;include&lt;/code&gt; 문은 여러 개의 파일로 큰 모듈을 분할하는 데 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;incompleteStruct&lt;/code&gt; 의 pragma는 기본 C를 사용하지 않도록 컴파일러에 지시 &lt;code&gt;struct&lt;/code&gt; A의 &lt;code&gt;sizeof&lt;/code&gt; 표현 :</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt; 및 &lt;code&gt;gensym&lt;/code&gt; 래그 마를 번째 클래스 주석이고; 템플릿 정의 외부에 의미가 없으며 추상화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">&lt;code&gt;injectStmt&lt;/code&gt; 의 프라그는 현재 모듈의 다른 모든 문 앞에 성명을 주입하는 데 사용할 수 있습니다. 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">&lt;code&gt;intsets&lt;/code&gt; 는 구현에게로 구현 효율적인 INT 세트 모듈 &lt;span id=&quot;sparse-bit-set_1&quot;&gt;성긴 비트 세트&lt;/span&gt; . &lt;strong&gt;참고&lt;/strong&gt; : Nim은 현재 할당 연산자의 오버로드를 허용하지 않기 때문에 &lt;code&gt;=&lt;/code&gt; int 세트의 경우 의미없는 얕은 복사를 수행합니다. 깊은 복사를 하려면 &lt;code&gt;assign&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">&lt;code&gt;int{lit}&lt;/code&gt; 형식의 표현에 대한 매개 변수 패턴 일치 &lt;code&gt;int&lt;/code&gt; 하지만 문자 그대로의 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">는 &lt;code&gt;is&lt;/code&gt; 컴파일시 타입 당량 대 운전자 검사한다. 따라서 일반 코드 내에서 유형 특수화에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 유형은 호출 컨벤션의 항상 &lt;code&gt;closure&lt;/code&gt; 암시; 다음 예제는 반복자를 사용하여 &lt;span id=&quot;collaborative-tasking_1&quot;&gt;협업 타스크&lt;/span&gt; 시스템 을 구현하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc0&lt;/code&gt; 의 명령</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc&lt;/code&gt; 의 명령</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;koch&lt;/code&gt; 프로그램은 님의 유지 보수 스크립트입니다. 이식성이 뛰어나다는 장점으로 make 및 shell 스크립팅을 대체합니다. 해당 옵션에 대한 자세한 내용은 &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문은 같은 작품 &lt;code&gt;var&lt;/code&gt; 에 문하지만 선언 기호는 &lt;em&gt;하나의 할당&lt;/em&gt; 변수 : 초기화 한 후 그 값을 변경할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; 프라그는 스택 백 트레이스에서 볼 수 있듯이 주석 문의 라인 정보에 영향을 미칠 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">&lt;code&gt;lineDir&lt;/code&gt; 의 옵션을 켜거나 끌 수 있습니다. 생성 된 C 코드를 켜면 &lt;code&gt;#line&lt;/code&gt; 지시문이 포함 됩니다. 이것은 GDB로 디버깅하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">&lt;code&gt;lineInfoFrom&lt;/code&gt; 의 생성 코드가 충돌 할 때 매개 변수는 온라인 정보에 사용됩니다. 변환중인 노드로 설정되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">&lt;code&gt;lineTrace&lt;/code&gt; 의 옵션은 의미 &lt;code&gt;stackTrace&lt;/code&gt; 옵션을 선택합니다. 설정하면 생성 된 C에 코드가 포함되어 프로그램이 충돌하거나 포착되지 않은 예외가 발생하는 경우 행 번호 정보가있는 적절한 스택 추적이 제공되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; 의 프라그는 어떻게 님의 컴파일하는 컴파일러에게하는 데 사용할 수있는 &lt;span id=&quot;case_1&quot;&gt;경우&lt;/span&gt; 문을. 문법적으로 그것은 진술로 사용되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; 의 프라그 선형 스캐닝을 통해에 대해 테스트해야 마지막 지점에 투입되어야한다. 전체 &lt;code&gt;case&lt;/code&gt; 문의 마지막 분기에 배치 하면 전체 &lt;code&gt;case&lt;/code&gt; 문은 선형 스캔을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 프라그는 프로젝트에 추가 파일을 링크 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; pragma는 또한 특수 값이 걸릴 수 있습니다 &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; . 동적 메소드 디스패치 컨텍스트에서 유용합니다. 다음 예에서 컴파일러는 &lt;code&gt;base&lt;/code&gt; 사례에 대해 잠금 수준 0을 유추 할 수 있습니다 . 그러나 오버로드 된 메소드 중 하나가 잠길 수있는 procvar를 호출합니다. 따라서 &lt;code&gt;g.testMethod&lt;/code&gt; 호출의 잠금 수준을 정적으로 유추 할 수 없으므로 컴파일러 경고가 발생합니다. 사용하여 &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; , 기지국 방법이 아니라 알려지지 로크 레벨을 갖는 것으로 명시 적으로 표시 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; 프라그가 잠금 식 목록 얻어 &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; 를 지원하기 위해서 &lt;em&gt;다중 잠금&lt;/em&gt; 문. 이것이 필수적인 이유는 &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;잠금 레벨&lt;/a&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; 이 더 런타임 의미가 없습니다 직접 사용할 수 없습니다 때문에 부분은 의도적으로 추한 보인다! 런타임에 일부 형식의 잠금을 구현하는 템플릿에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 수정할 수 있습니다 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;pairExists&lt;/code&gt; 키의 매핑을 변경하거나 테이블에서 삭제하는 값. 값을 추가 할 때 &lt;code&gt;val&lt;/code&gt; 수정과 함께 &lt;code&gt;pairExists&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 3 개 인수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt; 파라미터를 판독 할 수있는 최대 문자 수를 결정한다. 그 후에 &lt;code&gt;resString&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt; 파라미터를 판독 할 수있는 최대 문자 수를 결정한다. 그 후 결과가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">&lt;code&gt;msgHandler&lt;/code&gt; 는 사용자 오류보고에 사용되는 PROC입니다. 파일 이름, 줄, 열 및 구문 분석 중에 발견 된 오류 유형으로 호출됩니다. &lt;code&gt;nil&lt;/code&gt; 을 전달 하면 표준 출력에 메시지를 쓰는 기본 메시지 핸들러가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">&lt;code&gt;nim&lt;/code&gt; (이 순서로, 나중에 파일이 이전 설정을 덮어 쓰기) 다음 디렉토리에서 실행 프로세스 구성 파일 :</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">&lt;code&gt;nnkElifBranch&lt;/code&gt; 및 &lt;code&gt;nnkElse&lt;/code&gt; 부분이 누락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">&lt;code&gt;noDecl&lt;/code&gt; 의 pragma는 거의 모든 심볼 (변수, 시저, 유형 등)에 적용되고 C와 상호 운용성을 위해 때때로 유용 할 수 있습니다 : 그것은 C 코드의 기호에 대한 선언을 생성하지 않도록 님을 알려줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt; 의 프라그는 PROC를 표시하는 데 사용된다 / 반복기 부작용이 없음. 이는 proc / iterator가 매개 변수에서 도달 할 수있는 위치 만 변경하고 리턴 값은 인수에만 의존 함을 의미합니다. &lt;code&gt;var T&lt;/code&gt; 또는 &lt;code&gt;ref T&lt;/code&gt; 또는 &lt;code&gt;ptr T&lt;/code&gt; 유형의 매개 변수가 없는 위치는 수정 된 위치가 없음을 의미합니다. 컴파일러에서이를 확인할 수없는 경우 proc / iterator에 부작용이없는 것으로 표시하는 것은 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; pragma는 결코 반환하는 발동을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 이것은 왼쪽 접힘이므로 빼기와 같은 비 연관 이진 연산의 경우 숫자 1, 2 및 3의 시퀀스는 (((1)-2)-3)으로 괄호로 묶을 것이라고 생각합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 이것은 폴드이므로 뺄셈과 같은 비 연관 이진 연산의 경우 숫자 1, 2 및 3의 시퀀스는 (1-(2-(3)))로 괄호로 묶을 것이라고 생각합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 첫 &lt;code&gt;first&lt;/code&gt; 매개 변수는 시작 값 (첫 번째 &lt;code&gt;a&lt;/code&gt; )이므로 결과 유형을 정의합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">&lt;code&gt;optPeg&lt;/code&gt; 의 템플릿 패턴 만 프로그램 시작 한번에 분석되고 전역에 저장 될 수 있도록하는 것이, 캐릭터 문자와 PEG 생성자의 경우 최적화 &lt;code&gt;gl&lt;/code&gt; 사용 후 재이다. 이 최적화는 기존 루프 호이 스팅에 필적하기 때문에 호이 스팅이라고합니다.</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 프라그는 어떤에 적용 할 수있는 &lt;code&gt;object&lt;/code&gt; 유형입니다. 객체의 필드가 메모리에 연속적으로 패킹되도록합니다. 패킷이나 메시지를 네트워크 또는 하드웨어 드라이버와주고받는 데 유용하며 C와의 상호 운용성을 위해 유용합니다. 패킹 된 pragma와 상속을 결합하는 것은 정의되어 있지 않으며 GC의 메모리 (참조)와 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 배열을 지정 PARAMS IdentDefs 목록 뒤에 PROC의 복귀 형으로 시작한다.</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">&lt;code&gt;parseJson&lt;/code&gt; 의 절차는 JSON과 리턴이 포함 된 문자열 소요 &lt;code&gt;JsonNode&lt;/code&gt; 의 개체를. 이것은 객체 변형이며 &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt; 또는 &lt;code&gt;JNull&lt;/code&gt; 입니다. &lt;code&gt;kind&lt;/code&gt; 접근 자를 사용하여이 객체 변형의 종류를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">&lt;code&gt;parsecfg&lt;/code&gt; 의 모듈 구현하는 고성능 구성 파일 파서. 구성 파일의 구문은 Windows &lt;code&gt;.ini&lt;/code&gt; 형식 과 비슷 하지만 라인 기반 파서가 아니기 때문에 훨씬 강력합니다. 문자열 리터럴, 원시 문자열 리터럴 및 삼중 따옴표 문자열 리터럴은 Nim 프로그래밍 언어에서와 같이 지원됩니다. 이것은 구성 파일의 모양에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">&lt;code&gt;parsesql&lt;/code&gt; 의 모듈 구현하는 고성능 SQL 파일 파서. PostgreSQL 구문과 SQL ANSI 표준을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passC&lt;/code&gt; 의 프라그는 사용자가 명령 줄 스위치를 사용하는 것처럼 C 컴파일러에 추가 매개 변수를 전달하는 데 사용할 수 있습니다 &lt;code&gt;--passC&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt; 의 프라그는 사용자가 명령 줄 스위치를 사용하는 것처럼 링커에 추가 매개 변수를 전달하는 데 사용할 수 있습니다 &lt;code&gt;--passL&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 기능은 자체에 이벤트를 반환하지 않습니다. 대신 적절한 &lt;code&gt;Future&lt;/code&gt; 객체가 완성됩니다. &lt;code&gt;Future&lt;/code&gt; 아직 사용할 수없는 값을 보유하고 있지만, 어떤이 유형입니다 &lt;em&gt;수 있습니다&lt;/em&gt; 미래에 사용할 수 있습니다. &lt;code&gt;finished&lt;/code&gt; 기능 을 사용하여 미래의 완료 여부를 확인할 수 있습니다 . 미래가 완료되면 보유하고있는 값을 사용할 수 있거나 대신 오류가 발생 함을 의미합니다. 후자의 상황은 미래를 완료하기위한 조작이 예외로 실패 할 때 발생합니다. &lt;code&gt;failed&lt;/code&gt; 기능으로 두 상황을 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; 프라그는 선언 사용자 정의 프라그 마를로 사용할 수 있습니다. 이것은 Nim의 템플릿과 매크로가 pragma에 영향을 미치지 않기 때문에 유용합니다. 사용자 정의 pragma는 다른 모든 기호와 다른 모듈 범위에 있습니다. 모듈에서 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">&lt;code&gt;readCfgAtRuntime&lt;/code&gt; 의 PROC 지정된 파일명을 열고 돌아갑니다 &lt;code&gt;Table&lt;/code&gt; 로부터 &lt;a href=&quot;tables&quot;&gt;테이블 모듈&lt;/a&gt; . 파일 구문 분석은 &lt;a href=&quot;strutils#splitLines&quot;&gt;strutils 모듈&lt;/a&gt; 의 splitLines proc를 사용하여 유효하지 않은 데이터 또는 코너 케이스를 처리 할 때주의를 기울이지 않고 수행됩니다 . 실패 할 수있는 많은 것들이 있습니다. DRM 체계를 올바르게 구현하는 방법이 아니라 컴파일 타임에이를 실행하는 방법을 설명하는 것이 목적입니다.</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 프라그은 변수이다. 변수를 &lt;code&gt;register&lt;/code&gt; 로 선언하여 컴파일러가 변수에 빠르게 액세스하기 위해 하드웨어 레지스터에 배치해야한다는 힌트를줍니다. C 컴파일러는 일반적으로 이것을 무시하고 좋은 이유로 다음과 같이합니다. 종종 어쨌든 더 나은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; 변수는 이미 암시 적으로 'VAR 결과'로 다시 선언 할 수 있도록, 예를 들어, 동일한 이름의 일반 변수와 그림자 것, 함수의 시작 부분에 선언된다. 결과 변수는 이미 유형의 기본값으로 초기화되었습니다. 프로 시저 시작시 참조 데이터 유형은 &lt;code&gt;nil&lt;/code&gt; 아니므로 수동 초기화가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 문은 현재 프로 시저의 실행을 종료합니다. 절차에서만 허용됩니다. &lt;code&gt;expr&lt;/code&gt; 이 있으면 다음에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">&lt;code&gt;rst2tex&lt;/code&gt; 의 명령은 동일 호출 &lt;code&gt;rst2html&lt;/code&gt; , 대신 .html 중에서의 .tex 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">&lt;code&gt;scanp&lt;/code&gt; 는 구문 분석을 수행 님 코드로 문법 코드를 매핑합니다. 구문 분석은 사용자 정의 유형에 대해 구현할 수있는 3 개의 도우미 템플릿을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">&lt;code&gt;sets&lt;/code&gt; 구현에게 효율적인 모듈 &lt;span id=&quot;hash-set_1&quot;&gt;해시 세트&lt;/span&gt; 및 정렬 해시 세트를.</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; pragma는 유형의 의미에 영향을 컴파일러가 얕은 복사본을 만들 수 있습니다. 이로 인해 심각한 의미 문제가 발생하고 메모리 안전이 손상 될 수 있습니다! 그러나 Nim의 시맨틱은 시퀀스와 문자열의 깊은 복사가 필요하기 때문에 할당 속도를 상당히 높일 수 있습니다. 특히 트리 구조를 만드는 데 시퀀스를 사용하는 경우 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">&lt;code&gt;strtabs&lt;/code&gt; 은 구현을 문자열로 문자열에서 매핑이 효율적인 해시 테이블을 모듈. 대소 문자 구분, 대소 문자 구분 및 스타일 구분 모드를 지원합니다. 문자열 테이블에 대한 효율적인 문자열 대체 연산자 &lt;code&gt;%&lt;/code&gt; 도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">&lt;code&gt;sug&lt;/code&gt; Nimsuggest 명령은 파일의 어느 시점에서 가능한 완료 기호에 대한 쿼리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 모듈은 컴파일러 마법 (과 사양이 그렇게 말한다 때문에 요구가 될 수있는 물건)에 의해 지원을 필요로하는 RTL의 일부가 포함되어 있습니다. C 코드 생성기는 다른 모듈과 마찬가지로 C 코드를 생성합니다. 그러나 &lt;code&gt;addInt&lt;/code&gt; 와 같은 일부 프로 시저에 대한 호출 은 CCG에 의해 삽입됩니다. 따라서 모듈 &lt;code&gt;magicsys&lt;/code&gt; 는 테이블 (포함 &lt;code&gt;compilerprocs&lt;/code&gt; 로 표시된 모든 기호) &lt;code&gt;compilerproc&lt;/code&gt; 를 . &lt;code&gt;compilerprocs&lt;/code&gt; 생성기는 코드 생성기에 필요합니다. &lt;code&gt;magic&lt;/code&gt; PROC는 동일하지 않습니다 &lt;code&gt;compilerproc&lt;/code&gt; :의 &lt;code&gt;magic&lt;/code&gt; 발동입니다 그것의 의미 검사에 대한 요구 컴파일러 마술하는 &lt;code&gt;compilerproc&lt;/code&gt; 코드 생성기가 사용하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 모듈은 중요한 정의 &lt;a href=&quot;system#Natural&quot;&gt;자연&lt;/a&gt; 같은 유형 &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;하이&lt;/a&gt; 리턴 최대 값). 다른 프로그래밍 언어는 자연수에 부호없는 정수 사용을 제안 할 수 있습니다. 이것은 종종 &lt;strong&gt;현명하지 않습니다&lt;/strong&gt; : 숫자가 음수가 될 수 없기 때문에 부호없는 산술 (포장)을 원하지 않습니다. Nim의 &lt;code&gt;Natural&lt;/code&gt; 유형은 이러한 일반적인 프로그래밍 오류를 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">&lt;code&gt;tables&lt;/code&gt; 모듈 구현 효율적인 변종 &lt;span id=&quot;hash-table_1&quot;&gt;해시 테이블&lt;/span&gt; (종종 이름이 &lt;span id=&quot;dictionary_1&quot;&gt;사전&lt;/span&gt; 의 키와 값의 매핑은 다른 프로그래밍 언어에서). &lt;code&gt;Table&lt;/code&gt; 은 일반적인 해시 테이블 인 &lt;code&gt;CountTableRef&lt;/code&gt; 입니다. &lt;code&gt;OrderedTable&lt;/code&gt; 은 &lt;code&gt;Table&lt;/code&gt; 과 유사 하지만 삽입 순서를 기억하며 &lt;code&gt;CountTable&lt;/code&gt; 은 키에서 발생 횟수까지의 매핑입니다. Nim의 다른 모든 데이터 유형과 일관성을 유지하기 위해 &lt;strong&gt;값&lt;/strong&gt; 의미가 있습니다. 즉, &lt;code&gt;=&lt;/code&gt; 는 해시 테이블의 복사본을 수행합니다. 내용 &lt;strong&gt;참조&lt;/strong&gt; 시맨틱 사용 &lt;code&gt;Ref&lt;/code&gt; : 변형 &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt; 을 . 예를 들어, &lt;em&gt;a&lt;/em&gt; 가 테이블 인 경우 &lt;em&gt;var b = a&lt;/em&gt; 는 &lt;em&gt;b&lt;/em&gt; 를 새로운 독립 테이블로 제공 합니다. B는의 내용으로 초기화된다 . 변경 &lt;em&gt;B 것은&lt;/em&gt; 영향을주지 않습니다 및 부사장을 반대 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수는 함수가 어떤 이벤트가 준비가없는 경우 차단됩니다 (밀리 초)의 최대 수를 지정합니다. 시간 초과를 &lt;code&gt;-1&lt;/code&gt; 로 지정 하면 함수가 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수는 함수가 어떤 이벤트가 준비가없는 경우 차단됩니다 (밀리 초)의 최대 수를 지정합니다. 시간 초과를 &lt;code&gt;-1&lt;/code&gt; 로 지정 하면 함수가 무기한 차단됩니다. 사용 가능한 모든 이벤트가 &lt;code&gt;results&lt;/code&gt; 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 시간 (밀리 초) 서버와의 연결이 가능하도록 paremeter의 지정은 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문은 예외를 처리 :</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;unchecked&lt;/code&gt; pragma는 같은 명명 된 배열을 표시하는 데 사용할 수있는 &lt;code&gt;unchecked&lt;/code&gt; 그 경계를 확인하지 않습니다 의미를. 이것은 종종 유연한 크기의 맞춤형 배열을 구현하는 데 유용합니다. 또한 확인되지 않은 배열은 결정되지 않은 크기의 C 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 프라그는 어떤 적용 할 수 있습니다 &lt;code&gt;object&lt;/code&gt; 유형입니다. 그것은 모든 객체의 필드가 메모리에 겹쳐져 있음을 의미합니다. 이것은 생산 &lt;code&gt;union&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; 생성 된 C / C ++ 코드를. 그런 다음 객체 선언은 상속 또는 GC'ed 메모리를 사용해서는 안되지만 현재 검사되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; pragma는 그것이를 풀다해야 컴파일러 말할 수 있습니다 &lt;span id=&quot;for_2&quot;&gt;위해&lt;/span&gt; 또는 &lt;span id=&quot;while_1&quot;&gt;동시에&lt;/span&gt; 실행 효율성을 위해 루프를 :</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; Nimsuggest 명령은 위치에 심볼의 모든 용도를 나열합니다. IDE는이를 사용하여 파일에서 기호가 사용 된 모든 위치를 찾고 동시에 모든 위치에서 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 섹션은 같은 구문을 그룹화 기반 동일한 들여 쓰기를 사용 &lt;code&gt;var&lt;/code&gt; 하거나 &lt;code&gt;let&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">그만큼 &lt;code&gt;varargs&lt;/code&gt; 프라그은 절차 (및 절차 유형)에 적용 할 수 있습니다. Nim에게 proc이 마지막으로 지정된 매개 변수 다음에 다양한 수의 매개 변수를 사용할 수 있다고 알려줍니다. 님 문자열 값은 자동으로 C 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 타입은 모든 종류의 부재를 나타낸다. &lt;code&gt;void&lt;/code&gt; 형의 파라미터 존재하지 않는 것으로 취급되며 , 리턴 유형으로서 &lt;code&gt;void&lt;/code&gt; 는 프로 시저가 값을 리턴하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 유형은 매개 변수와 반환 형식에 대해서만 유효합니다; 다른 심볼은 &lt;code&gt;void&lt;/code&gt; 유형을 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">그만큼 &lt;code&gt;void&lt;/code&gt; 유형은 일반적인 코드에 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; pragma는 전용 변수입니다. 변수를 다음과 같이 선언합니다. &lt;code&gt;volatile&lt;/code&gt; C / C ++에서 의미하는대로 volatile (시맨틱은 C / C ++에서 잘 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">그만큼 &lt;code&gt;warning&lt;/code&gt; pragma는 컴파일러 출력에게 주어진 내용으로 경고 메시지를 만드는 데 사용됩니다. 경고 후에 컴파일이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문 조건부 컴파일 기술을 가능하게한다. 특수한 구문 확장으로 &lt;code&gt;when&lt;/code&gt; 구문은 &lt;code&gt;object&lt;/code&gt; 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 거의 동일 &lt;code&gt;if&lt;/code&gt; 일부 예외를 제외하고 문 :</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 거의 동일 &lt;code&gt;if&lt;/code&gt; 그러나 이러한 차이와, 문 :</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 유사 플랫폼 특정 코드를 작성하는 데 유용합니다 &lt;code&gt;#ifdef&lt;/code&gt; 와의 C 프로그래밍 언어 구조를.</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 문은 때까지 실행 &lt;code&gt;expr&lt;/code&gt; false로 평가합니다. 끝없는 루프는 오류가 없습니다. &lt;code&gt;while&lt;/code&gt; 문은 &lt;em&gt;암시 적 블록을&lt;/em&gt; 열어서 &lt;code&gt;break&lt;/code&gt; 문 으로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 문을 대신 사용된다 &lt;code&gt;return&lt;/code&gt; 반복자의 문. 반복자에서만 유효합니다. 실행자는 반복자를 호출 한 for 루프의 본문으로 리턴됩니다. 수율은 반복 프로세스를 종료하지 않지만 다음 반복이 시작되면 실행이 반복기로 다시 전달됩니다. 반복자에 대한 섹션을 참조하십시오 (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt; 반복자 및 for 문&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 중위 연산자로 사용되는 경우 순서대로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 기호는 대안을 표시하는 데 사용되며 우선 순위가 가장 낮습니다. &lt;code&gt;/&lt;/code&gt; 는 파서가 지정된 순서대로 대안을 시도해야하는 순서가 지정된 선택입니다. &lt;code&gt;/&lt;/code&gt; 는 문법이 모호하지 않도록 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 연산자는 것입니다 &lt;strong&gt;하지&lt;/strong&gt; 패턴 연산자 :</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;카운트 테이블 연산자.</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;해시 테이블 연산자.</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;int 세트 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;정렬 된 해시 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;문자열 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt;문자열 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">카운트 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블에 같은 개수의 동일한 키가 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">카운트 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 둘 다 같은 개수의 동일한 키를 포함하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 두 테이블의 내용에 동일한 키-값 쌍이 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. &lt;code&gt;true&lt;/code&gt; 를 반환두 테이블의 내용에 동일한 키-값 쌍이 포함되어 있으면 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자 내용과 순서가 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 내용과 순서가 같으면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">&lt;em&gt;님 컴파일러는&lt;/em&gt; 또한과 RST (reStructuredText) 파일에 대한 지원이 &lt;code&gt;rst2html&lt;/code&gt; 및 &lt;code&gt;rst2tex&lt;/code&gt; 명령을. 이와 같은 문서는 처음에 RST의 방언으로 작성되어 &lt;code&gt;.. code-block:: nim&lt;/code&gt; 접두어 로 nim 소스 코드 강조 표시에 대한 지원을 추가 합니다. &lt;code&gt;code-block&lt;/code&gt; 은 C ++ 및 다른 c와 유사한 언어의 강조 표시도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;em&gt;경우 표현식은&lt;/em&gt; 다시 case 문 매우 유사합니다 :</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">&lt;em&gt;문자 유형&lt;/em&gt; 이라고 &lt;code&gt;char&lt;/code&gt; . 크기는 항상 1 바이트이므로 대부분의 UTF-8 문자를 나타낼 수 없습니다. 그러나 멀티 바이트 UTF-8 문자를 구성하는 바이트 중 하나를 나타낼 &lt;em&gt;수 있습니다&lt;/em&gt; . 그 이유는 효율성입니다. 압도적 인 대다수의 유스 케이스의 경우 UTF-8이 특별히 설계되었으므로 결과 프로그램은 여전히 ​​UTF-8을 올바르게 처리합니다. 문자 리터럴은 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 매개 변수는 오류보고 및 파일에 인덱스 하이퍼 링크를 만드는 데 사용됩니다,하지만 당신은 메모리 스트림을 구문 분석하는 경우 여기에 빈 문자열을 전달할 수 있습니다. 경우 &lt;em&gt;파일 이름&lt;/em&gt; 과 끝 &lt;code&gt;.nim&lt;/code&gt; 확장, 문서의 제목은 기본적으로 설정됩니다 &lt;code&gt;Module filename&lt;/code&gt; . 이 기본 제목은 삽입 된 첫 번째 제목으로 대체 할 수 있지만 제목이 없으면 생성 된 색인을 미리 정의하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">&lt;em&gt;핸들러의&lt;/em&gt; 매개 변수에 대한 코드 블록으로 구성 &lt;em&gt;PegKinds&lt;/em&gt; 관심의 문법 요소를 정의. 각 블록은 구문 분석기가 문법 요소와 일치하는 텍스트를 입력하고 떠날 때 실행될 핸들러 코드를 포함 할 수 있습니다. 는 &lt;em&gt;입력&lt;/em&gt; 처리기 특정 PEG AST 노드는 다음과 같이 매칭되는 액세스 할 수 &lt;em&gt;P&lt;/em&gt; 와 같은 전체 파싱 문자열 &lt;em&gt;들&lt;/em&gt; 과의 매칭 된 텍스트 세그먼트의 위치 &lt;em&gt;들&lt;/em&gt; 과 같은 &lt;em&gt;시작&lt;/em&gt; . &lt;em&gt;휴가&lt;/em&gt; 핸들러 캔 접근 &lt;em&gt;p는&lt;/em&gt; , &lt;em&gt;들&lt;/em&gt; , &lt;em&gt;시작&lt;/em&gt; 또한 일치하는 텍스트 세그먼트의 길이와 &lt;em&gt;길이를&lt;/em&gt; . 실패한 경기의 경우&lt;em&gt;입력&lt;/em&gt; 및 &lt;em&gt;휴가&lt;/em&gt; 처리기는 &lt;em&gt;길이&lt;/em&gt; 가 -1로 설정된 상태에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">&lt;em&gt;ID는&lt;/em&gt; 길이가 달리 특정 앵커가 생성되지 않습니다, 0이 아닌 경우에만 해시 문자로 추가됩니다. 일반적으로 독립형 첫 번째 문서의 제목에 대해 빈 &lt;em&gt;id&lt;/em&gt; 값만 전달해야합니다 ( &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; 프로 시저 에는 특별합니다 . 자세한 내용 은 &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;색인 (idx) 파일 형식&lt;/a&gt; 참조). 다른 색인 용어와 달리 제목 항목은 누적 된 버퍼의 시작 부분에 삽입되어 논리적 순서의 항목을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize가의&lt;/em&gt; 매개 변수는 2의 거듭 제곱 할 필요가있다. 당신이 사용할 수있는&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt; math.nextPowerOfTwo ()&lt;/a&gt; 또는 &lt;em&gt;rightSize&lt;/em&gt; 를 하여 런타임시이를 보장 . &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; 및 &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()을&lt;/a&gt; 제외하고이 모듈의 다른 프로세서와 함께 사용하기 전에 모든 설정 변수를 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize가의&lt;/em&gt; 매개 변수는 2의 거듭 제곱 할 필요가있다. &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()를&lt;/a&gt; 사용할 수 있습니다 또는 &lt;em&gt;rightSize&lt;/em&gt; 를 하여 런타임시이를 보장 . &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; 및 &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()을&lt;/a&gt; 제외하고이 모듈의 다른 프로세서와 함께 사용하기 전에 모든 설정 변수를 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">블록의 선언 부분에 선언 된 변수 의 &lt;em&gt;범위&lt;/em&gt; 는 선언 지점부터 블록 끝까지 유효합니다. 블록에 식별자가 다시 선언 된 두 번째 블록이 포함 된 경우이 블록 내에서 두 번째 선언이 유효합니다. 내부 블록을 떠나면 첫 번째 선언이 다시 유효합니다. 프로 시저 또는 반복자 과부하 목적으로 유효한 경우를 제외하고 동일한 블록에서 식별자를 다시 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">&lt;em&gt;조잡 인터페이싱&lt;/em&gt; 예시 용도 &lt;code&gt;.emit&lt;/code&gt; 생산하는 &lt;code&gt;using namespace&lt;/code&gt; 선언을. 대신 &lt;code&gt;namespace::identifier&lt;/code&gt; 표기법을 통해 가져온 이름을 참조하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt;백 슬래시&lt;/span&gt; 문자는 여러 가지 용도가있다. 먼저 영숫자가 아닌 문자가 뒤에 오는 경우 해당 문자가 가질 수있는 특별한 의미를 제거합니다. 이스케이프 문자로 백 슬래시를 사용하면 내부 및 외부 문자 클래스에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">그만큼 &lt;span id=&quot;boot_1&quot;&gt;부트&lt;/span&gt; 명령은 컴파일러 부트 스트랩, 그리고 다른 옵션을 허용합니다</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;csource_1&quot;&gt;CSOURCE&lt;/span&gt; 명령은 설치를위한 C 소스를 작성합니다. &lt;a href=&quot;#boot-command&quot;&gt;boot 명령으로&lt;/a&gt; 전달할 때와 동일한 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;for_1&quot;&gt;에 대한&lt;/span&gt; 문은 컨테이너의 요소를 반복하는 추상적 인 메커니즘입니다. 그렇게하기 위해 &lt;span id=&quot;iterator_1&quot;&gt;반복자&lt;/span&gt; 에 의존합니다 . 처럼 &lt;code&gt;while&lt;/code&gt; 문 &lt;code&gt;for&lt;/code&gt; 문 열려&lt;span id=&quot;implicit-block_1&quot;&gt; 암시 적 블록을&lt;/span&gt; &lt;code&gt;break&lt;/code&gt; 문 으로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe의&lt;/span&gt; 주석 그렇지 않으면이 속성은 컴파일러에 의해 추정되어, gcsafe로 발동을 표시하는 데 사용할 수 있습니다. &lt;code&gt;noSideEffect&lt;/code&gt; 는 gcsafe를 의미 &lt;code&gt;gcsafe&lt;/code&gt; . 스레드를 생성하는 유일한 방법은 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;createThread&lt;/code&gt; 를 통하는 것 입니다. &lt;code&gt;spawn&lt;/code&gt; 이 일반적으로 선호되는 방법입니다. 어느 쪽이든 호출 된 proc은 &lt;code&gt;var&lt;/code&gt; 매개 변수를 사용해서는 안되며 매개 변수 중 하나에 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;closure&lt;/code&gt; 유형이 포함 되어서는 안됩니다 . &lt;em&gt;힙 공유 제한&lt;/em&gt; 이 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">&lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; 옵션은 코드에서의 변경은 실행중인 프로그램에 자동으로 적용 할 수있는 특수 편집 모드를 가능하게한다. 코드 재로드는 개별 모듈의 세분성에서 발생합니다. 모듈이 다시로드되면 Nim은 코드에서 표준 변수 선언으로 초기화 된 모든 전역 변수의 상태를 유지합니다. 다시로드 할 때마다 다른 모든 최상위 코드가 반복적으로 실행됩니다. 이 동작을 방지하려면 &lt;code&gt;once&lt;/code&gt; 구문 으로 코드 블록을 보호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">&lt;span id=&quot;koch_1&quot;&gt;코흐&lt;/span&gt; 프로그램은 님의 유지 보수 스크립트입니다. 이식성이 뛰어나다는 장점으로 make 및 shell 스크립팅을 대체합니다. &lt;em&gt;koch&lt;/em&gt; 라는 단어 는 독일어로 &lt;em&gt;요리&lt;/em&gt; 하는 것을 의미 합니다. &lt;code&gt;koch&lt;/code&gt; 는 주로 Nim 컴파일러를 빌드하는 데 사용되지만 다른 작업에도 사용할 수 있습니다. 이 문서는 지원되는 명령 및 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; 디렉토리는 컴파일시에 생성되고 백엔드 대상에 따라 중 일시적 또는 최종 파일을 개최한다. 디렉토리의 기본 이름은 사용 된 백엔드 및 OS에 따라 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;컴파일러 스위치&lt;/a&gt; 를 사용하여 디렉토리 를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">&lt;span id=&quot;parameter-constraint_1&quot;&gt;매개 변수 제약 조건&lt;/span&gt; 표현식은 연산자를 사용할 수 있습니다 &lt;code&gt;|&lt;/code&gt; (또는) &lt;code&gt;&amp;amp;&lt;/code&gt; (및) &lt;code&gt;~&lt;/code&gt; (not) 및 다음 술어 :</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">&lt;span id=&quot;pushslashpop_1&quot;&gt;푸시 / 팝&lt;/span&gt; 프라그 마를는 옵션 지시어와 매우 유사하지만, 일시적으로 설정을 재정의하는 데 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">&lt;span id=&quot;slice_1&quot;&gt;조각&lt;/span&gt; 도트를 포함하는 다른 토큰보다 우선 .. 연산자 {...}은 세 토큰 {...} 아닌 두 {토큰이다..}.</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_1&quot;&gt;교체&lt;/span&gt; 의 조작을 수행 문자열 치환 &lt;em&gt;formatstr&lt;/em&gt; 복귀 변형 &lt;em&gt;formatstr&lt;/em&gt; . 이것을 종종 &lt;span id=&quot;string-interpolation_1&quot;&gt;문자열 보간&lt;/span&gt; 이라고 &lt;span id=&quot;string-interpolation_1&quot;&gt;합니다.&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_2&quot;&gt;교체&lt;/span&gt; 의 조작을 수행 문자열 치환 &lt;em&gt;formatstr&lt;/em&gt; 복귀 변형 &lt;em&gt;formatstr&lt;/em&gt; . 이것은 종종 불린다&lt;span id=&quot;string-interpolation_2&quot;&gt; 문자열 보간 합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">&lt;span id=&quot;test_1&quot;&gt;테스트&lt;/span&gt; 명령은 별칭으로 호출 할 수 있습니다 &lt;code&gt;tests&lt;/code&gt; . 이 명령은 Nim 테스트 스위트의 주요 드라이버 인 &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; 을 컴파일하고 실행 합니다 . 당신은 옵션을 전달할 수 있습니다 &lt;code&gt;test&lt;/code&gt; 명령에 전달하면 테스터에게 전달됩니다. 사용 가능한 옵션에 대해서는 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;web_1&quot;&gt;웹&lt;/span&gt; 명령에 문서 변환 &lt;code&gt;doc&lt;/code&gt; HTML에 처음부터 디렉토리를. 또한 동일한 작업을 반복하지만 결과를 &lt;code&gt;web/upload&lt;/code&gt; 에 배치하여 &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt; 웹 사이트를 업데이트하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; paramater 정적 분석을 위해 충분하지만, 십오 갖는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 는 사용자가 여전히 라인 입력의 중간에있을 수있다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;--trackDirty&lt;/code&gt; 스위치 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">API는 &lt;strong&gt;사용하기 쉽고&lt;/strong&gt; 일관 되도록 설계되었습니다 . 사용의 용이성은 구체적인 높은 수준의 행동을 달성하기위한 호출 횟수로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">API는 AST diffing 개념을 수용해야합니다 . 세부 사항 은 모듈 &lt;code&gt;macrocache&lt;/code&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">님의 마지막</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">C와 같은 백엔드는 임시 &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; 또는 &lt;code&gt;.m&lt;/code&gt; 파일을 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리에 배치합니다. 이 파일의 이름은 &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; 패턴을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">목표와 같은 C</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">CellSet 데이터 구조</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">DevkitPro 설정은 &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;Mac / Linux의&lt;/a&gt; 경우 &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;여기&lt;/a&gt; 또는 Windows의 경우 새 설치 프로그램의 기본값과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">GC는 포인터 세트를 저장하기위한 매우 효율적인 데이터 구조에 의존 합니다.이를 소스 코드에서 &lt;code&gt;TCellSet&lt;/code&gt; 이라고합니다 . 삽입, 삭제 및 검색은 일정한 시간에 수행됩니다. 그러나 순회 중에 &lt;code&gt;TCellSet&lt;/code&gt; 을 수정하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">GC는 메모리 할당 작업에서만 트리거됩니다. 일부 타이머에 의해 트리거되지 않으며 백그라운드 스레드에서 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">GC의 시간 측정 방법 ( 구현 은 &lt;code&gt;lib/system/timers.nim&lt;/code&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">IEEE 예외는 런타임시 무시되거나 Nim 예외 &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt; 및 &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError로 매핑&lt;/span&gt; 됩니다. 이러한 예외는 &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; 기본 클래스 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">IEEE 표준은 5 가지 유형의 부동 소수점 예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">JS 대상은 실제로 &lt;code&gt;node.js&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">자바 스크립트 타겟</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">JavaScript 대상에는 가비지 수집 기능이 있으므로 인터페이스에 대한 추가 고려 사항이 없지만 C 대상을 사용하려면 &lt;code&gt;NimMain&lt;/code&gt; 함수를 호출하여 Nim의 내부를 초기화해야합니다 . 또한 C 코드에서는 함수에 대해 순방향 선언을 지정해야합니다. 그렇지 않으면 컴파일러가 런타임에 프로그램 충돌을 일으킬 수있는 반환 값 및 매개 변수에 특정 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Nim 컴파일러와 표준 라이브러리의 대부분은 테 인트 모드를 지원합니다. 입력 문자열은 &lt;code&gt;system&lt;/code&gt; 모듈에 선언 된 &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; 문자열 유형으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim 컴파일러는 &lt;code&gt;--header&lt;/code&gt; 명령 행 스위치를 통해 C 인터페이스 헤더를 생성 할 수 있습니다 . 생성 된 헤더에는 내 보낸 모든 심볼과 다른 Nim 코드보다 먼저 호출해야하는 &lt;code&gt;NimMain&lt;/code&gt; proc이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Nim 컴파일러는 &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt; 및 &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; 메시지 와 같은 다른 종류의 메시지를 생성 합니다. &lt;em&gt;오류&lt;/em&gt; 컴파일러는 정전기가 발생하면 에러 메시지가 방출된다.</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Nim 컴파일러에는 간단한 선형 방정식 솔버가 포함되어있어 정수 산술이 관련된 일부 상황에서 정적 매개 변수를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Nim 컴파일러는 주로 C, C ++ 및 Objective-C 대상과 JavaScript 대상의 두 가지 백엔드 제품군을 지원합니다. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;C like 대상&lt;/a&gt; 은 라이브러리 또는 최종 실행 파일로 컴파일 할 수있는 소스 파일을 만듭니다. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript 대상&lt;/a&gt; 은 HTML 파일에서 참조 하는 &lt;code&gt;.js&lt;/code&gt; 파일을 생성하거나 &lt;a href=&quot;http://nodejs.org&quot;&gt;독립형 nodejs 프로그램을&lt;/a&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Nim 컴파일러는 간단하지만 강력한 내장 템플릿 시스템으로서 소스 코드 필터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Nim 컴파일러는 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리 에서 생성 된 소스 파일을 &lt;code&gt;libfib.nim.a&lt;/code&gt; 정적 라이브러리로 링크하는 작업을 처리하며,이 라이브러리를 C 프로그램에 연결할 수 있습니다. 이 명령은 일반적이며 각 시스템마다 다릅니다. 예를 들어, Linux 시스템 에서는 필요한 dlopen 기능으로 링크 하기 위해 &lt;code&gt;-ldl&lt;/code&gt; 도 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Nim 라이브러리는 과부하를 많이 사용합니다. 그 이유 중 하나는 &lt;code&gt;+&lt;/code&gt; 와 같은 각 연산자 가 오버로드 된 프로 시저이기 때문입니다. 파서는 당신이 연산자를 사용할 수 있습니다 &lt;em&gt;중위 표기&lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; ) 또는 &lt;em&gt;접두사 표기법&lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ). 접두사 연산자는 항상 두 개의 인수를받습니다. 접두사 연산자는 항상 하나입니다. 이 모호한 것이기 때문에 (후위 연산자는, 불가능 : 않습니다 &lt;code&gt;a @ @ b&lt;/code&gt; 평균 &lt;code&gt;(a) @ (@b)&lt;/code&gt; 나 &lt;code&gt;(a@) @ (b)&lt;/code&gt; 그것은 항상 수단? &lt;code&gt;(a) @ (@b)&lt;/code&gt; 때문에 Nim에는 postfix 연산자가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">Nim 매뉴얼은 적절한 사양으로 발전 할 수있는 초안입니다.</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">Nim 프로그래밍 언어에는 Posix의 신호 처리 메커니즘에 대한 개념이 없습니다. 그러나 표준 라이브러리는 신호 처리를위한 기본적인 지원을 제공합니다. 특히 세그먼트 오류는 치명적인 오류로 바뀌어 스택 추적을 생성합니다. &lt;code&gt;-d:noSignalHandler&lt;/code&gt; 스위치를 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Nim 프로젝트의 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim 표준 라이브러리는 컬렉션의 문자열 표현을 생성 할 때 컬렉션의 요소에서이 기능을 사용합니다. 사용자측 컬렉션에도이 기능을 사용하는 것이 좋습니다. 사용자 정의 된 요소 표현을 구현하려는 경우 사용자 정의 (문자열 유사) 유형에 대해 &lt;em&gt;addQuoted&lt;/em&gt; 를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Nim 튜토리얼 1 부에서는 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Nim 튜토리얼 2 부에서는 고급 언어 구성을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">PEG 파서는이 문법을 구현합니다 (PEG 구문으로 작성).</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">위의 &lt;code&gt;debug&lt;/code&gt; 매크로는 &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 이 시스템 모듈에 선언되어 인스턴스화 컨텍스트에서 볼 수 있다는 사실에 의존합니다 . 언 바운드 식별자를 사용하는 대신 바인딩 된 식별자 (일명 &lt;span id=&quot;symbols_1&quot;&gt;symbol&lt;/span&gt; ) 를 사용하는 방법이 있습니다 . &lt;code&gt;bindSym&lt;/code&gt; 의 내장은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">위의 코드는 &lt;code&gt;i&lt;/code&gt; 이미 선언 한 신비한 오류 메시지와 함께 실패합니다 . 그 이유는 &lt;code&gt;var i = ...&lt;/code&gt; body가 &lt;code&gt;body&lt;/code&gt; 매개 변수 로 전달되기 전에 형식 검사가 필요하고 Nim의 형식 검사는 기호 조회를 의미 하기 때문 입니다. 심볼 조회가 성공하려면 &lt;code&gt;i&lt;/code&gt; 현재 (즉, 외부) 범위에 추가해야합니다. 유형 점검 후 기호 테이블에 대한 이러한 추가는 롤백되지 않습니다 (더 나은지 또는 더 나쁜지). 전달 된 본문을 유형 확인하지 않아도되므로 동일한 코드가 &lt;code&gt;untyped&lt;/code&gt; 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">위 코드는 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">위의 예제는 c2nim 이 이러한 정의를 &lt;em&gt;처리&lt;/em&gt; 하고 확장하도록 c2nim의 &lt;code&gt;#def&lt;/code&gt; 지시문을 사용하여 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">위 모듈은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;*&lt;/code&gt; 을 내보내 지만 &lt;code&gt;y&lt;/code&gt; 는 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">위의 출력은 다음과 같은 코드 스 니펫의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">가드 &lt;code&gt;x.L&lt;/code&gt; 이 활성화되어 있으므로 &lt;code&gt;x.v&lt;/code&gt; 필드에 액세스 할 수 있습니다. 템플릿 확장 후, 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">가산기 연산자</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">모듈 컴파일 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">알고리즘은 연속 분수 이론을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">문자열 할당 연산자는 항상 문자열을 복사합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 연접 스트링.</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">문자열의 할당 연산자는 문자열을 복사합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자를 사용하여 문자열을 연결하고 문자열에 &lt;code&gt;add&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">튜플의 할당 연산자는 각 구성 요소를 복사합니다. 객체의 기본 할당 연산자는 각 구성 요소를 복사합니다. 할당 연산자의 오버로드는 &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">튜플의 할당 연산자는 각 구성 요소를 복사합니다. &lt;code&gt;t.field&lt;/code&gt; 표기법 은 튜플의 필드에 액세스하는 데 사용됩니다. 또 다른 표기법은 &lt;code&gt;i&lt;/code&gt; 번째 필드 에 액세스하는 &lt;code&gt;t[i]&lt;/code&gt; 입니다. 여기서 &lt;code&gt;i&lt;/code&gt; 상수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">대입 연산자는 객체 또는 고유 한 유형 &lt;code&gt;T&lt;/code&gt; 에 연결해야합니다 . 서명은 &lt;code&gt;(var T, T)&lt;/code&gt; 이어야 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">과제 진술</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">할당 문은 변수 또는보다 일반적으로 저장 위치에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">비동기 디스패처는 프로 액터 패턴을 구현하고 IOCP도 구현합니다. 선택기 모듈을 통해 다른 OS에 대한 프로 액터 패턴을 구현합니다. 선물도 여기에서 구현되며 실제로 모든 절차가 미래를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">사용 가능한 부동 소수점 프리젠 테이션 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">사용 가능한 정수 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">백엔드에는 현재 처리 된 모듈이 컴파일 캐시에서 온 경우 &lt;code&gt;ast&lt;/code&gt; 필드에 액세스 할 수 없도록 몇 가지 논리가 있어야합니다 . 대신 심볼 본문에 대해 생성 된 C (++)도 캐싱하고 생성 된 C 파일에 다시 삽입해야합니다. 이 방법은 위에서 설명한 모든 문제를 해결하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">검사되지 않은 어레이의 기본 유형에는 GC 메모리가 포함되어 있지 않을 수 있지만 현재 검사되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">기본 알고리즘은 주기 감지를 사용한 &lt;em&gt;지연된 기준 계수&lt;/em&gt; 입니다. 스택의 참조는 더 나은 성능 및 더 쉬운 C 코드 생성을 위해 계산되지 않습니다. 사이클 감지는 현재 전체 (스레드 로컬 힙)를 스캔해야하는 간단한 mark &amp;amp; ​​sweep GC에 의해 수행됩니다. &lt;code&gt;--gc:v2&lt;/code&gt; 는 이것을 증분 마크와 스윕으로 대체합니다. 그러나 아직 생산 준비가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">기본 알고리즘은 주기 감지 기능 이있는 &lt;em&gt;지연 기준 계수&lt;/em&gt; 입니다. 성능 향상과 쉬운 C 코드 생성을 위해 스택의 참조는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">이진 &lt;code&gt;^*&lt;/code&gt; 연산자는 두 번째 인수로 구분 된 0 개 이상의 발생에 대한 속기로 사용됩니다. 마찬가지로 &lt;code&gt;^+&lt;/code&gt; 수단은 1 이상의 어커런스 : &lt;code&gt;a ^+ b&lt;/code&gt; 약자이며 &lt;code&gt;a (b a)*&lt;/code&gt; 및 &lt;code&gt;a ^* b&lt;/code&gt; 위한 짧은 &lt;code&gt;(a (b a)*)?&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">블록 문은 명령문을 (명명 된) &lt;code&gt;block&lt;/code&gt; 으로 그룹화하는 수단 입니다. 블록 내에서 &lt;code&gt;break&lt;/code&gt; 문은 블록을 즉시 떠날 수 있습니다. &lt;code&gt;break&lt;/code&gt; 문은 떠나 어떤 블록을 지정하는 주변 블록의 이름을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">블록 &lt;em&gt;레이블&lt;/em&gt; ( 이 예에서는 &lt;code&gt;myblock&lt;/code&gt; )은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">부울 유형의 이름 은 Nim에서 &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; 이며 미리 정의 된 두 값 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 중 하나 일 수 있습니다 . 의 조건 &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -statements이 형이 될 필요가 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">차용 pragma를 사용하여 고유 한 유형에 주석을 달아 특정 내장 조작을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">내장 &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc은 배열의 길이를 반환합니다. &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt; 는 배열 &lt;em&gt;a에&lt;/em&gt; 대해 가장 낮은 유효한 인덱스를 반환 하고 &lt;a href=&quot;system#high&quot;&gt;high (a)&lt;/a&gt; 에 가장 높은 유효한 인덱스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">내장 된 &lt;code&gt;deepCopy&lt;/code&gt; 는 클로저 및 해당 환경을 복제 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#parallel-spawn&quot;&gt;스폰&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">내장 &lt;code&gt;system.finished&lt;/code&gt; 를 사용하여 반복자가 작업을 완료했는지 확인할 수 있습니다. 이미 작업을 완료 한 반복자를 호출하려는 시도에서는 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">내장 문서 생성기 &lt;code&gt;nim doc&lt;/code&gt; 은 &lt;code&gt;.nim&lt;/code&gt; 소스 파일 에서 HTML 문서를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">미래가 완료되면 콜백도 호출됩니다. 따라서 &lt;code&gt;finished&lt;/code&gt; 를 사용 하여 데이터가 사용 가능한지 확인 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">콜백은 다음 중 하나를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">캐럿 문자 (^)는 이스케이프 문자 또는 분리 문자로 인식되지 않습니다. 문자는 프로그램의 argv 배열로 전달되기 전에 운영 체제의 명령 행 구문 분석기에서 완전히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">case 문은 정수, 기타 서수 유형 및 문자열을 처리 할 수 ​​있습니다. (서수 유형에 대해서는 곧 설명하겠습니다.) 정수 또는 기타 서수 유형의 경우 값 범위도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl 규칙은 프로 시저가 C 컴파일러와 동일한 규칙을 사용해야 함을 의미합니다. 창에서 생성 된 C 프로시 저는 &lt;code&gt;__cdecl&lt;/code&gt; 키워드로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">POSIX의 경우 ':'또는 ';'과 같이 검색 경로 구성 요소를 분리하기 위해 운영 체제에서 일반적으로 사용하는 문자 (PATH에서와 같이) Windows 용.</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">문자 유형은 Nim에서 &lt;code&gt;char&lt;/code&gt; 로 명명 됩니다. 크기는 1 바이트입니다. 따라서 UTF-8 문자를 나타낼 수 없지만 그 일부를 나타냅니다. 그 이유는 효율성입니다. 압도적 인 대다수의 유스 케이스의 경우 UTF-8이 특별히 설계되었으므로 결과 프로그램은 여전히 ​​UTF-8을 올바르게 처리합니다. 또 다른 이유는 많은 알고리즘이이 기능에 의존하기 때문에 Nim이 &lt;code&gt;array[char, int]&lt;/code&gt; 또는 &lt;code&gt;set[char]&lt;/code&gt; 효율적으로 지원할 수 있기 때문입니다 . &lt;em&gt;룬의&lt;/em&gt; 유형이 유니 코드 문자에 사용되는, 어떤 유니 코드 문자를 나타낼 수 있습니다. &lt;code&gt;Rune&lt;/code&gt; 은 &lt;a href=&quot;unicode&quot;&gt;유니 코드 모듈&lt;/a&gt; 에서 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">운영 체제에서 경로 이름 구성 요소를 구분하기 위해 사용하는 문자 (예 : POSIX의 경우 '/', 기본 Macintosh의 경우 ':')</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">기본 파일 이름을 확장자와 구분하는 문자입니다. 예를 들어 '.' 에 &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">스타일의 선택은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">닫는 &lt;code&gt;@#&lt;/code&gt; 는 선택적인 공백으로 시작하는 줄에 있어야합니다. 이런 식으로 &lt;code&gt;@#&lt;/code&gt; 은 예제와 같이 Nim 코드에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">이 코드에는 혼란스러운 &lt;code&gt;var&lt;/code&gt; 선언이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">코드에 지원되지 않는 8 진 시퀀스가 ​​포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">코드 재정렬 기능은 최상위 수준 범위에서 변수 선언 및 초기화와 함께 프로 시저, 템플릿 및 매크로 정의를 암시 적으로 재 배열 할 수 있으므로 프로그래머는 정의를 올바르게 순서화하거나 걱정할 필요가 없습니다. 모듈 내부에서 정의를 시작하는 선언.</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">이 코드는 더 이상 사용되지 않는 기호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">강제 변환 &lt;code&gt;type(x)&lt;/code&gt; 을 사용하여 주어진 표현식 &lt;code&gt;x&lt;/code&gt; 의 유형을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">콜렉터는 모든 &lt;code&gt;workPackage&lt;/code&gt; 반복 후 작업 시간이 아직 남아 있는지 확인합니다 . 현재 100으로 설정되어 있습니다. 다시 확인하기 전에 최대 100 개의 객체가 이송되고 해제됨을 의미합니다. 따라서 &lt;code&gt;workPackage&lt;/code&gt; 는 타이밍 세분성에 영향을 미치며 고도로 전문화 된 환경이나 구형 하드웨어에 맞게 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">명령 호출 구문은 복잡한 표현식을 인수로 가질 수도 없습니다. 예 : ( &lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; . ( &lt;a href=&quot;#do-notation&quot;&gt;표기법&lt;/a&gt; )은 제한되어 있지만 단일 proc에 사용할 수 있습니다 (해당 섹션의 예 참조). 인수가없는 함수 호출은 호출과 함수 자체를 첫 번째 클래스 값으로 구별하기 위해 여전히 ()이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">C, C ++ 또는 Objective-C로 컴파일하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">공통 &lt;code&gt;--&lt;/code&gt; 옵션이 아닌 인수 구분 기호는 빈 문자열 긴 옵션 키로 나타납니다. &lt;code&gt;OptParser.cmd&lt;/code&gt; , &lt;code&gt;OptParser.pos&lt;/code&gt; 및 &lt;code&gt;os.parseCmdLine&lt;/code&gt; 을 사용하여 구문 분석을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">공통 연산자 &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 는 부동 소수점에 대해 정의되며 IEEE-754 표준을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">공통 연산자 &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 는 정수로 정의됩니다. &lt;code&gt;and or xor not&lt;/code&gt; 사업자는 정수에 대해 정의하고 제공하는 &lt;em&gt;비트&lt;/em&gt; 작업을. 왼쪽 비트 이동은 &lt;code&gt;shl&lt;/code&gt; 로 수행되고 오른쪽 이동은 &lt;code&gt;shr&lt;/code&gt; 연산자로 수행됩니다. 비트 이동 연산자는 항상 인수를 &lt;em&gt;부호없는&lt;/em&gt; 것으로 취급합니다 . 들어 &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;산술 비트 시프트&lt;/span&gt; 일반적인 곱셈 또는 나눗셈을 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">컴파일러는 각 매개 변수가 정확히 하나의 인수를 수신하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 시맨틱을 검사하고 &lt;code&gt;true&lt;/code&gt; 로 평가되는 첫 번째 조건에 속하는 명령문에 &lt;em&gt;대해서만&lt;/em&gt; 코드를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">컴파일러 명령은 대상 백엔드를 선택하지만 필요한 경우 대상 CPU, 운영 체제 또는 컴파일러 / 링커 명령을 선택하기 &lt;a href=&quot;nimc#cross-compilation&quot;&gt;위해 크로스 컴파일&lt;/a&gt; 을 위한 추가 스위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 올바르게 작동하기 위해 시스템 모듈에 의존하고 시스템 모듈은 컴파일러에 의존합니다. 여기에 나열된 대부분의 루틴은 특수 컴파일러 마법을 사용합니다. 각 모듈은 시스템 모듈을 암시 적으로 가져옵니다. 명시 적으로 나열해서는 안됩니다. 이 때문에 &lt;code&gt;system&lt;/code&gt; 이라는 사용자 정의 모듈이있을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">컴파일러는 모든 코드 경로가 Null을 허용하지 않는 포인터를 포함하는 변수를 초기화하도록합니다. 이 분석의 세부 사항은 여전히 ​​여기에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">컴파일러는 프로그래머가 다음과 같이 작성한 것처럼 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;-d:release&lt;/code&gt; 또는 &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;명령 행 스위치를&lt;/a&gt; 통해 권장되는 경우 &lt;code&gt;assert&lt;/code&gt; 위해 코드를 전혀 생성하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">이 작업을 수행하려면 컴파일러에 C ++ (명령 &lt;code&gt;cpp&lt;/code&gt; ) 을 생성하도록 지시해야합니다 . 조건부 기호 &lt;code&gt;cpp&lt;/code&gt; 는 컴파일러가 C ++ 코드를 생성 할 때 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">이 작업을 수행하려면 Objective C (명령 &lt;code&gt;objc&lt;/code&gt; ) 를 생성하도록 컴파일러에 지시해야합니다 . 조건부 기호 &lt;code&gt;objc&lt;/code&gt; 는 컴파일러가 Objective C 코드를 생성 할 때 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">컴파일러는 이제 &lt;code&gt;x * 2&lt;/code&gt; 를 &lt;code&gt;x + x&lt;/code&gt; 로 다시 씁니다 . curlies 내부의 코드는 일치시킬 패턴입니다. 연산자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 패턴이 접두사 표기법으로 작성된 경우 패턴에 특별한 의미가 있으므로 일반적인 함수 호출 구문 에 대해 그대로 사용 하려면 &lt;code&gt;*&lt;/code&gt; 일반 함수 호출 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">컴파일러는 문자열 대 / 소문자 구분 문을 최적화합니다. 여러 다른 문자열 상수를 사용하는 경우 해시 구성표가 사용됩니다. 따라서 이와 같은 코드는 합리적으로 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">컴파일러는 &lt;code&gt;IOError&lt;/code&gt; 가 발생할 수 있다는 힌트 메시지를 생성합니다 . &lt;code&gt;effects&lt;/code&gt; pragma가 나타나는 분기에서 &lt;code&gt;OSError&lt;/code&gt; 를 발생시킬 수 없으므로 OSError 가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">컴파일러는 열거를 위해 내장 된 stringify 연산자 &lt;code&gt;$&lt;/code&gt; 를 지원합니다 . stringify의 결과는 사용할 문자열 값을 명시 적으로 제공하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">그런 다음 컴파일러는 &lt;code&gt;gdata&lt;/code&gt; 에 대한 모든 액세스가 &lt;code&gt;locks&lt;/code&gt; 섹션 내에 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">컴파일러의 아키텍처</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">상보 오차 함수</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">컴파일러는 식을 평가하지 못한 경우 또는 가능한 유형 불일치 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">다음과 같은 경우 개념이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">개념 유형은 일반 일반 유형과 마찬가지로 매개 변수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">A의 조건 &lt;code&gt;do while(condition)&lt;/code&gt; 문이 있어야합니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">운영 체제에서 현재 디렉토리를 참조하기 위해 사용하는 상수 문자열.</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">운영 체제에서 상위 디렉토리를 참조하기 위해 사용하는 상수 문자열.</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">구속 조건은 구체적 유형 또는 유형 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; 도 있습니다. &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">구문 &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (식별자와 여는 따옴표 사이에 공백이 없음)은 일반화 된 원시 문자열 리터럴입니다. 구성 &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; 의 바로 가기 이므로 원시 문자열 리터럴을 유일한 인수로 사용하여 프로 시저 호출을 나타냅니다. 일반화 된 원시 문자열 리터럴은 미니 언어를 Nim에 직접 임베드 할 때 특히 편리합니다 (예 : 정규식).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 수정 자 와 함께 도입 된 반 변형 매개 변수 는 현재 이러한 의미를 갖는 가져온 유형과 인터페이스 할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">사용자 정의 형식 &lt;span id=&quot;converter_1&quot;&gt;변환기&lt;/span&gt; 로 변환 관계를 완화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">크리트 비트 트리는 문자열에서 일부 유형 &lt;code&gt;T&lt;/code&gt; 로의 맵핑 또는 &lt;code&gt;T&lt;/code&gt; 가 void 인 경우 문자열 세트 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">현재 구현에서는 컴파일 시간 평가에 일부 제한이 있습니다. &lt;code&gt;cast&lt;/code&gt; 를 포함 하거나 외부 함수 인터페이스를 사용 하는 코드 는 컴파일 타임에 평가할 수 없습니다. 최신 버전의 Nim은 컴파일 타임에 FFI를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">사이클 컬렉터는 &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; 및 &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; 을 사용하여 GC의 다른 부분과 독립적으로 활성화 / 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">프로젝트의 기본 빌드는 &lt;span id=&quot;debug-build_1&quot;&gt;디버그 빌드&lt;/span&gt; 입니다. &lt;span id=&quot;release-build_1&quot;&gt;릴리스 빌드&lt;/span&gt; 를 컴파일하려면 &lt;code&gt;release&lt;/code&gt; 기호를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">내부 호출 프로 시저 (proc 내부의 proc)가 아닌 한 기본 호출 규칙은 &lt;code&gt;nimcall&lt;/code&gt; 입니다. 내부 프로세스의 경우 환경에 액세스하는지 여부에 대한 분석이 수행됩니다. 그렇게하면 호출 규칙 &lt;code&gt;closure&lt;/code&gt; 있고, 그렇지 않으면 호출 규칙 &lt;code&gt;nimcall&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">기본 컴파일러는 &lt;code&gt;config\nim.cfg&lt;/code&gt; 맨 위에 정의되어 있습니다. 이 설정을 변경하면 &lt;code&gt;koch&lt;/code&gt; 에서 Nim을 재 빌드하는 데 사용하는 컴파일러에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">기본 구성 ( &lt;em&gt;trim = true&lt;/em&gt; 및 &lt;em&gt;precision = 10&lt;/em&gt; )은 값 을 정확하게 표시하는 최대 값 (소수점 최대 10 자리)을 &lt;strong&gt;가장 짧은&lt;/strong&gt; 형식으로 표시합니다. 예를 들어, 4.100000은 4.1 (수학적으로 동일 함)로 표시되고 4.1000003은 4.1000003으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">기본 float 유형은 &lt;code&gt;float&lt;/code&gt; 입니다. 현재 구현에서 &lt;code&gt;float&lt;/code&gt; 는 항상 64 비트입니다.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">엔티티 &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 의 기호의 기본값 은 &lt;code&gt;gensym&lt;/code&gt; 이며 &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; 는 &lt;code&gt;inject&lt;/code&gt; 됩니다. 그러나 엔터티 이름이 템플릿 매개 변수로 전달되면 주입 된 기호입니다.</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">기본 정수 유형은 &lt;code&gt;int&lt;/code&gt; 입니다. 정수 리터럴은 기본이 아닌 정수 유형을 지정하기 위해 &lt;em&gt;유형 접미&lt;/em&gt; 부를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">더 이상 사용되지 않는 pragma는 기호를 사용되지 않음으로 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 1.0과 1.0보다 작은 최소값의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 1.0과 1.0보다 작은 최소값의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 의 차이점은 다음 과 같습니다. &lt;code&gt;let&lt;/code&gt; 은 재 할당 할 수없는 변수를 도입합니다. &lt;code&gt;const&lt;/code&gt; 는 &quot;컴파일 시간 평가를 시행하여 데이터 섹션에 넣습니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">두 세트의 차이는 수학적으로 &lt;em&gt;AB&lt;/em&gt; 로 표시되며 &lt;em&gt;s2&lt;/em&gt; 멤버가 아닌 &lt;em&gt;s1&lt;/em&gt; 멤버 인 모든 객체의 세트입니다 . 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">받는 사람 관련하여 차이 &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;제외 ()&lt;/a&gt; PROC이 시저가 반환하는 것입니다 &lt;em&gt;진정한&lt;/em&gt; 경우 &lt;em&gt;키가&lt;/em&gt; 존재하지 않았다 &lt;em&gt;의&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">받는 사람 관련하여 차이 &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;제외 ()&lt;/a&gt; PROC이 시저가 반환하는 것입니다 &lt;em&gt;진정한&lt;/em&gt; 경우 &lt;em&gt;키가&lt;/em&gt; 존재하지 않았다 &lt;em&gt;의&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">&lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; proc 과의 차이점 은 &lt;em&gt;key&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 이 proc이 &lt;em&gt;true를&lt;/em&gt; 반환한다는 것 입니다. 경우 PROC는 false를 돌려줍니다 &lt;em&gt;키&lt;/em&gt; 에 새로운 값으로 추가되었다 &lt;em&gt;의&lt;/em&gt; 이 통화 중. 예:&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">&lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; proc 과의 차이점 은 &lt;em&gt;key&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 이 proc이 &lt;em&gt;true를&lt;/em&gt; 반환한다는 것 입니다. 경우 PROC는 false를 돌려줍니다 &lt;em&gt;키&lt;/em&gt; 에 새로운 값으로 추가되었다 &lt;em&gt;의&lt;/em&gt; 이 통화 중. 예:&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">지원되는 다양한 형식 패턴이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">안전하지 않은 &lt;code&gt;asm&lt;/code&gt; 문 은 어셈블러 코드를 Nim 코드에 직접 포함시키는 기능을 지원 합니다. Nim 식별자를 참조하는 어셈블러 코드의 식별자는 명령문의 pragma에 지정할 수있는 특수 문자로 묶어야합니다. 기본 특수 문자는 &lt;code&gt;'`'&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">디렉토리에 아직 존재하지 않는 여러 서브 디렉토리가있을 수 있습니다. 전체 경로가 생성됩니다. 이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. 그것은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 대부분의 용도로이 오류를 표시하지 않기 때문에 디렉토리가 이미 존재하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">디스패처는 일종의 이벤트 루프 역할을합니다. 당신은 호출해야합니다 &lt;code&gt;poll&lt;/code&gt; 거기에 (또는 같은 당신을 위해 그렇게하는 기능 &lt;code&gt;waitFor&lt;/code&gt; 또는 &lt;code&gt;runForever&lt;/code&gt; ) 미결제 이벤트에 대한 설문 조사에 위해를. 기본 구현은 Linux의 epoll, Windows의 IO Completion Ports 및 기타 운영 체제를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">설명서는 여러 문서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">문서 생성기는 이러한 예제를 알고 있으며 &lt;code&gt;##&lt;/code&gt; doc 주석의 일부로 간주합니다 . 문서 생성의 마지막 단계로 예제는 &lt;code&gt;$file_example.nim&lt;/code&gt; 파일에 저장되고 컴파일 및 테스트됩니다. 수집 된 예제는 자체 모듈에 넣어 예제가 내 보내지 않은 기호를 나타내지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">효과 시스템 (발생 &lt;code&gt;raises: []&lt;/code&gt; )은 비동기 프로 시저에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">빈 &lt;a href=&quot;#procedures-discard-statement&quot;&gt;폐기 문&lt;/a&gt; 은 &lt;em&gt;아무 것도하지 않습니다&lt;/em&gt; . 컴파일러는 else 부분이있는 case 문이 실패 할 수 없으므로 오류가 사라진다는 것을 알고 있습니다. 가능한 모든 문자열 값을 처리하는 것은 불가능합니다. 따라서 문자열 케이스에는 항상 &lt;code&gt;else&lt;/code&gt; 분기 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">빈 &lt;code&gt;[]&lt;/code&gt; 의 첨자를 표기하는 데 사용될 수 &lt;em&gt;derefer&lt;/em&gt; 에 상품을 상기 기준 지점을 검색하는 의미 참조. &lt;code&gt;.&lt;/code&gt; (튜플 / 객체 필드 연산자에 액세스) 및 &lt;code&gt;[]&lt;/code&gt; (배열 / 문자열 / 시퀀스 인덱스 연산자) 연산자는 참조 유형에 대해 암시 적 역 참조 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">명시 적으로 나열되지 않은 예외가있는 경우 빈 &lt;code&gt;except&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;else&lt;/code&gt; 부분 과 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">다르게 나열되지 않은 예외가 있으면 빈 &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; 절이 실행됩니다. &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;else&lt;/code&gt; 절 과 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">빈 테이블은 &lt;code&gt;{:}&lt;/code&gt; (빈 세트와는 대조적으로 &lt;code&gt;{}&lt;/code&gt; )와 같이 쓸 수 있으며 이는 빈 배열 생성자 &lt;code&gt;[]&lt;/code&gt; 로 쓰는 또 다른 방법 입니다. 이 약간 특이한 테이블 지원 방법에는 많은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">에러 기능</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">이 예는 또한 proc의 본문이 값이 암시 적으로 리턴되는 단일 표현식으로 구성 될 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">벡터는 이미 &lt;code&gt;v[]&lt;/code&gt; 액세스를 제공하는 튜플에 의해 더 잘 모델링되므로이 예는 어리 석습니다 .</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">이 예는 일반 이진 트리를 보여줍니다. 컨텍스트에 따라 대괄호는 형식 매개 변수를 도입하거나 일반 proc, iterator 또는 형식을 인스턴스화하는 데 사용됩니다. 예제에서 알 수 있듯이 제네릭은 오버로드와 함께 작동합니다. 가장 일치하는 &lt;code&gt;add&lt;/code&gt; 가 사용됩니다. 시퀀스 에 내장 된 &lt;code&gt;add&lt;/code&gt; 프로시 저는 숨겨져 있지 않으며 &lt;code&gt;preorder&lt;/code&gt; 반복기 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">이 예제에서는 while 루프를 사용하여 사용자가 아무 것도 입력하지 않는 한 계속해서 이름을 요구합니다 (RETURN 만 누름).</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">예외 부분 은 &lt;code&gt;except&lt;/code&gt; 부분 에서 &lt;em&gt;소비&lt;/em&gt; 됩니다 . 예외가 처리되지 않으면 호출 스택을 통해 전파됩니다. 즉, &lt;code&gt;finally&lt;/code&gt; 절에 없는 나머지 프로시 저는 종종 실행되지 않습니다 (예외가 발생한 경우).</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">예외는 예외 처리기에서 &lt;em&gt;소비&lt;/em&gt; 됩니다. 그러나 예외 처리기는 다른 예외를 일으킬 수 있습니다. 예외가 처리되지 않으면 호출 스택을 통해 전파됩니다. 즉, &lt;code&gt;finally&lt;/code&gt; 절에 없는 나머지 프로시 저는 종종 실행되지 않습니다 (예외가 발생한 경우).</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">예외 추적은 님 &lt;span id=&quot;effect-system_1&quot;&gt;효과 시스템&lt;/span&gt; 의 일부입니다 . 예외를 발생시키는 것이 &lt;em&gt;효과&lt;/em&gt; 입니다. 다른 효과도 정의 할 수 있습니다. 사용자 정의 효과는 루틴 에 &lt;em&gt;태그&lt;/em&gt; 를 &lt;em&gt;지정&lt;/em&gt; 하고이 태그에 대한 검사를 수행 하는 수단입니다 .</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">예외 트리는 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈에 정의되어 있습니다. 모든 예외는 &lt;code&gt;system.Exception&lt;/code&gt; 을 상속 합니다. 프로그래밍 버그를 나타내는 예외는 &lt;code&gt;system.Defect&lt;/code&gt; ( &lt;code&gt;Exception&lt;/code&gt; 의 하위 유형) 에서 상속되며 전체 프로세스를 종료하는 작업에 매핑 될 수 있으므로 엄밀히 말하면 잡을 수 없습니다. 잡을 수있는 다른 런타임 오류를 나타내는 예외는 &lt;code&gt;system.CatchableError&lt;/code&gt; ( &lt;code&gt;Exception&lt;/code&gt; 의 하위 유형) 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">식 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;x.f&lt;/code&gt; 의미 (수단 심볼 조회 및 유형 검사가) 재기록되어야한다고 결정하기 전에 확인 될 필요가 &lt;code&gt;f(x)&lt;/code&gt; . 따라서 도트 구문은 템플릿 / 매크로를 호출하는 데 사용될 때 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">확장은 &lt;em&gt;#&lt;/em&gt; 및 공백으로 시작하는 주석 이 무시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">튜플 또는 객체 정의 내의 필드 식별자는 다음 위치에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">&lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; 파일 은 XML 파서를 사용하여 또 다른 간단한 작업을 수행하는 방법을 보여줍니다. HTML 문서에 포함 된 모든 링크를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">&lt;code&gt;examples/htmltitle.nim&lt;/code&gt; 파일 은 XML 파서를 사용하여 간단한 작업을 수행하는 방법을 보여줍니다. HTML 문서의 제목을 확인하려면.</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">스크립트 파일의 파일 확장자입니다. 예 : POSIX의 경우 &quot;&quot;, Windows의 경우 &quot;bat&quot;</target>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">기본 실행 파일의 파일 확장자입니다. 예 : POSIX의 경우 &quot;&quot;, Windows의 경우 &quot;exe&quot;</target>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">파일을 열 때 파일 모드입니다.</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">쿼리를 수행하려는 파일입니다. 일반적으로 &lt;strong&gt;proj.nim&lt;/strong&gt; 과 동일한 값을 &lt;strong&gt;전달&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">필터는 이것을 다음으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">마지막 계층은 비동기 대기 변환입니다. 이를 통해 동기식 스타일로 비동기 코드를 작성할 수 있으며 C #의 대기와 유사하게 작동합니다. 변환은 비동기 프로 시저를 반복자로 변환하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">첫 번째 명령은 생성 된 파일에서 &lt;code&gt;main()&lt;/code&gt; 함수 생성을 피하고, 오브젝트 파일을 최종 바이너리에 링크하지 않고, C 통합을위한 헤더 파일을 명시 적으로 생성 하지 않도록 세 가지 특수 옵션으로 Nim 컴파일러를 실행합니다 . 생성 된 모든 파일은 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리에 있습니다. 그렇기 때문에 다음 명령은 &lt;code&gt;maths.c&lt;/code&gt; 소스와 &lt;code&gt;nimcache&lt;/code&gt; 형식의 모든 &lt;code&gt;.c&lt;/code&gt; 파일을 컴파일합니다 . 이 경로 외에도 C 컴파일러에게 Nim의 &lt;code&gt;nimbase.h&lt;/code&gt; 헤더 파일 을 찾을 위치를 알려줘야 합니다.</target>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">첫 번째 줄은 메인 프로젝트 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">첫 번째 프로그램</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">가장 먼저 알아 두어야 할 것은 모든 호출 가능한 유형에는 매개 변수가 없더라도 적어도 쉼표가 있다는 것입니다. 매개 변수가 있으면 해당 유형으로 표시되며 쉼표로 구분됩니다. 일반 기호에는 호출 가능한 유형에 따라 접미사가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">소켓 사용을 시작하기 위해 항상해야 할 첫 번째 일은 &lt;code&gt;newSocket&lt;/code&gt; 프로 시저를 사용하여 &lt;code&gt;Socket&lt;/code&gt; 유형 의 새 인스턴스를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">첫 번째 버전은 &lt;em&gt;cmp&lt;/em&gt; 를 사용하여 요소를 비교합니다. 예상 반환 값은 system.cmp의 반환 값과 같습니다. 두 번째 버전은 기본 비교 함수 &lt;em&gt;cmp를&lt;/em&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">다음 Nim 코드 :</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">다음 알고리즘 (의사 코드)은 두 유형이 &lt;code&gt;distinct&lt;/code&gt; 유형에 관계없이 동일한 지 여부를 결정합니다 . 간결성을 위해 보조 세트 &lt;code&gt;s&lt;/code&gt; 를 사용한 사이클 점검 이 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">다음과 같은 내장 프로세스는 구현의 단순성으로 인해 오버로드 될 수 없습니다 (특별한 의미 검사가 필요함).</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">다음 코드 :</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">다음과 같은 도트 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">다음 예는 간단한 채팅 서버를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">다음 예제는 언어 선택에 따라 런타임에 판별되는 라이브러리에서 'greet'이라는 함수를로드하는 방법을 보여줍니다. 라이브러리가로드되지 않거나 'greet'함수를 찾지 못하면 실패 오류 코드와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">다음 예제는 세 개의 다른 핸들러에 동시에 로깅하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">다음 예제 는 가변 개수의 인수를 허용하는 강력한 &lt;code&gt;debug&lt;/code&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">다음 예제는 정규식에서 어휘 분석기를 생성하는 매크로를 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">다음 예제는 일반 이진 트리를 모델링 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">다음 예는 어떤 형태의 호이 스팅이 구현 될 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">다음 예제는 용어 재 작성으로 간단한 부분 평가를 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">다음 예제는 적절하게 이름이 'sample.nim'인 아래의 고안된 &lt;em&gt;Nim&lt;/em&gt; 모듈에 대한 문서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">다음과 같은 부동 소수점 유형이 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">다음 키워드는 예약되어 있으며 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">다음의 nim 코드 :</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">다음 단락은 대부분 자신을 생각 나게합니다. 명심해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">다음 섹션에서는 컴파일러가 수행하는 형식 검사를 설명하는 데 필요한 형식에 대한 몇 가지 관계를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">다음 섹션에서는 idetools가 유효한 출력을 반환하는 각 종류의 심볼에 대해 예상되는 출력을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">다음 섹션에서는 각 메타 문자 사용에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">다음 문자열은 다른 토큰을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">파일 이름을 &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; 파일 로 변환하는 형식 문자열 ( 일부 운영 체제 에서는 &lt;span id=&quot;shared-object_1&quot;&gt;공유 객체&lt;/span&gt; 라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">반복자가 정의되면 네 번째 열은 빈 문자열이됩니다. 파일의 해당 시점에서 파서는 아직 전체 행을 처리하지 않았기 때문입니다. 반복자의 이후 인스턴스에서 서명이 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">매크로가 정의되는 경우 네 번째 열은 빈 문자열이됩니다. 파일의 해당 시점에서 파서는 아직 전체 행을 처리하지 않았기 때문입니다. 서명은 매크로의 후방 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">파일의 시점에서 파서가 아직 전체 행을 처리하지 않았기 때문에 메소드가 정의되는 경우 네 번째 열은 빈 문자열입니다. 서명은 메소드의 후부 인스턴스에서 완료되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">파일의 해당 시점에서 파서가 아직 전체 행을 처리하지 않았으므로 proc이 정의되는 경우 네 번째 열은 빈 문자열입니다. 서명은 proc의 사후 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">템플릿을 정의하는 경우 파일의 해당 시점에서 파서가 아직 전체 행을 처리하지 않았으므로 네 번째 열은 빈 문자열입니다. 서명은 템플릿의 뒤쪽 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">백 슬래시의 네 번째 용도는 특정 &lt;span id=&quot;simple-assertions_1&quot;&gt;간단한 어설 션&lt;/span&gt; 입니다. 어설 션은 제목 문자열에서 문자를 소비하지 않고 일치하는 특정 지점에서 충족되어야하는 조건을 지정합니다. 보다 복잡한 어설 션에 하위 패턴을 사용하는 방법은 다음과 같습니다. 백 슬래시 된 어설 션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">지속 시간의 소수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">전체 출력은 여기에서 볼 수있다 : &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html를&lt;/a&gt; . 의미 검사 후 실행되며 컴파일러가 암시 적으로 첨부 한 pragma를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 와 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 에 의해 구현 된 기능 은 동일하므로 여기에 표시된 예에서 가장 적합한 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">향후 스트림이 완료되었습니다 (이는 더 이상 데이터가 기록되지 않음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">감마 기능</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">감마 함수 &lt;strong&gt;버전 0.19.0부터 사용되지 않음&lt;/strong&gt; : &lt;code&gt;gamma&lt;/code&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">표준 형식 지정자의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">생성 된 C 코드에는 명시적인 호출 규칙이 없으므로 C 컴파일러의 기본 호출 규칙이 사용됩니다. 절차에 대한 Nim의 기본 호출 규칙은 속도를 향상시키기 위해 &lt;code&gt;fastcall&lt;/code&gt; 이기 때문에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">이러한 랩퍼 중 일부에 대해 생성 된 HTML은 너무 커서 배포에 포함되지 않습니다. 그런 다음 웹 사이트에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Nim이 생성하는 생성 된 파일은 모두 &lt;code&gt;nimcache&lt;/code&gt; 라는 서브 디렉토리로 이동 합니다. 전체 경로는</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">생성 된 인덱스 &lt;strong&gt;색인 + (Ctrl + F) == 기쁨&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">getrlimit () 시스템 호출은 자원 한계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">좋은 소식은 많이 바뀌지 않았습니다! 먼저 입력 매개 변수 (라인 3) 처리를 변경해야합니다. 동적 버전에서 &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc은 문자열 매개 변수를 수신합니다. 그러나 매크로 버전에서는 문자열로도 선언되지만 이는 매크로 의 &lt;em&gt;외부&lt;/em&gt; 인터페이스입니다. 매크로가 실행될 때 실제로 문자열 대신 &lt;code&gt;PNimNode&lt;/code&gt; 객체를 가져 오므로 &lt;a href=&quot;macros&quot;&gt;매크로 모듈&lt;/a&gt; 에서 &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (5 행)을 호출 하여 매크로 에 전달되는 문자열을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">문법의 시작 기호는 &lt;code&gt;module&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">인사말 프로그램은 순차적으로 실행되는 3 개의 문으로 구성됩니다. 가장 원시적 인 프로그램만이 벗어날 수 있습니다 : 분기 및 루핑도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">보호대는 특정 유형일 필요는 없습니다. 낮은 수준의 잠금없는 메커니즘을 모델링 할 수있을만큼 유연합니다.</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">백 슬래시와 0 이외의 숫자를 처리하는 것은 복잡합니다. 문자 클래스 외부에서 PCRE는 10 진수로 문자 및 다음 숫자를 읽습니다. 숫자가 10보다 작거나 표현식에 이전에 캡처 한 왼쪽 괄호가 많으면 전체 시퀀스가 ​​역 참조로 사용됩니다. 이것의 작동 방식에 대한 설명은 괄호 안에있는 하위 패턴에 대한 설명에 따라 나중에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">힙 덤프 기능은 아직 초기 단계이지만 이미 우리에게 유용하다는 것이 입증되었으므로 유용 할 수 있습니다. 힙 덤프를 얻으려면 &lt;code&gt;-d:nimTypeNames&lt;/code&gt; 로 컴파일하고 프로그램의 전략적 위치에서 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 를 호출 하십시오. 그러면 프로그램에서 사용 된 유형 목록과 모든 유형에 대해이 유형에 대한 총 오브젝트 인스턴스 양과 해당 인스턴스가 차지하는 총 바이트 수가 생성됩니다. 이 목록은 현재 분류되지 않았습니다! 정렬하려면 외부 쉘 스크립트 해킹을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">요청한 클라이언트의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">가능한 경우 한 자리 숫자로, 0-23 범위입니다.</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">가능하면 한 자리수의 시간입니다. 1-12 범위.</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">항상 두 자리 숫자로 표시됩니다. 시간이 한 자리이면 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">항상 두 자리 숫자로 표시됩니다. 시간이 한 자리이면 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 키워드 다음의 식별자 는 현재 일치하는 유형의 인스턴스를 나타냅니다. 보다 구체적인 유형의 인스턴스를 나타 내기 위해 &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; 및 &lt;code&gt;static&lt;/code&gt; 과 같은 표준 유형 수정자를 적용 할 수 있습니다 . &lt;em&gt;형식&lt;/em&gt; 수정자를 적용 하여 형식 자체의 명명 된 인스턴스를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">idetools 명령은 컴파일러 서비스 (CAAS)로 실행될 수 있습니다. 여기서 컴파일러를 먼저 시작하면 서버처럼 온라인 상태를 유지하면서 텔넷과 같은 방식으로 쿼리를 수락합니다. 계속 유지하는 장점은 많은 쿼리의 경우 컴파일러가 컴파일 결과를 캐시 할 수 있으며 후속 쿼리는 밀리 초 범위에서 빠르므로 IDE에 충분히 응답해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">if 문은 제어 흐름을 분기하는 한 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">가상의 단위. &amp;radic;-1.</target>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">즉각적인 pragma는 더 이상 사용되지 않습니다. &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;형식화 된 매개 변수와 형식화되지 않은 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">구현은 최상의 액세스 성능을 위해 필드를 정렬합니다. 정렬은 C 컴파일러가 수행하는 방식과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">구현은 현재 다음과 같은 가능한 옵션을 제공합니다 (다양한 옵션이 나중에 추가 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">컴파일 캐시의 구현은 까다 롭습니다. 프론트 엔드 및 백엔드에 대해 해결해야 할 많은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">&lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; 유형 pragma를 통해 암시 적 초기화를 방지 할 수도 있습니다 . 컴파일러는 객체와 모든 필드를 명시 적으로 초기화해야합니다. 그러나 변수가 초기화되었음을 증명하기 위해 &lt;span id=&quot;control-flow-analysis_1&quot;&gt;제어 흐름 분석&lt;/span&gt; 을 수행하며 구문 특성에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">&lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma를 사용하여 최적화 이유로 암시 적 초기화를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">들여 쓰기 처리는 다음과 같이 구현됩니다. 어휘 분석기는 다음 토큰에 앞의 공백 수를 주석 처리합니다. 들여 쓰기는 별도의 토큰이 아닙니다. 이 방법을 사용하면 1 토큰만으로 Nim을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">인덱스 생성 도구에서 생성 된 문서를 구분하려고 &lt;code&gt;.nim&lt;/code&gt; 에서 생성 된 파일 및 문서 &lt;code&gt;.txt&lt;/code&gt; 또는 &lt;code&gt;.rst&lt;/code&gt; 파일. 전자는 항상 소스 코드와 밀접한 관련이 있으며 주로 API 항목으로 구성됩니다. 후자는 사람이 읽을 수있는 일반적인 문서입니다.</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; 을 호출하지 않으면 인덱스가 디스크에 기록되지 않습니다 . 색인의 목적은 &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen 도구 안내서에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">읽기 / 쓰기 추적에 대한 유추는 예외 추적에 대한 유추와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">태그 추적에 대한 유추는 예외 추적에 대한 유추와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">인라인 규칙은 호출자가 프로 시저를 호출하지 말고 코드를 직접 인라인해야 함을 의미합니다. Nim은 인라인되지 않지만 C 컴파일러에 남겨 둡니다. &lt;code&gt;__inline&lt;/code&gt; 프로 시저를 생성 합니다. 이것은 단지 컴파일러에 대한 힌트 : 완전히 무시할 수 있으며, 그것은으로 표시되지 않은 절차 인라인 수 있습니다 &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">스레드와 예외 간의 상호 작용은 간단합니다. 한 스레드에서 &lt;em&gt;처리 된&lt;/em&gt; 예외는 다른 스레드에 영향을 줄 수 없습니다. 그러나 하나의 스레드에서 &lt;em&gt;처리되지 않은&lt;/em&gt; 예외는 전체 &lt;em&gt;프로세스를&lt;/em&gt; 종료합니다 !</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">흥미로운 점은 매크로가 런타임 &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; 객체를 반환하지 않는다는 것입니다 . 대신 Nim 소스 코드를 &lt;code&gt;source&lt;/code&gt; 변수에 빌드합니다 . 구성 파일의 각 행에 대해 &lt;code&gt;const&lt;/code&gt; 변수가 생성됩니다 (15 행). 충돌을 피하기 위해이 변수 앞에 &lt;code&gt;cfg&lt;/code&gt; 를 붙 입니다. 본질적으로 컴파일러가 수행하는 작업은 매크로를 호출하는 행을 다음 코드 스 니펫으로 바꾸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">내부 문서는 컴파일러 구현 방법을 설명합니다. 컴파일러를 해킹하려면 이것을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">두 세트의 교집합은 수학적으로 &lt;em&gt;A &amp;cap; B&lt;/em&gt; 로 표시 되며 동시에 &lt;em&gt;s1&lt;/em&gt; 및 &lt;em&gt;s2의&lt;/em&gt; 구성원 인 모든 객체의 세트입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">언어 구조는 BNF의 확장을 사용하여 설명한다 &lt;code&gt;(a)*&lt;/code&gt; 의미 0 이상의 의, &lt;code&gt;a+&lt;/code&gt; 수단은 1 이상의 의, 그리고 &lt;code&gt;(a)?&lt;/code&gt; 선택적인 &lt;em&gt;a를&lt;/em&gt; 의미합니다 . 괄호는 요소를 그룹화하는 데 사용될 수 있습니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 가장 큰 양수입니다.</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 가장 큰 양수입니다.</target>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">연도의 마지막 두 자리. 구문 분석 할 때 현재 세기가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">마지막 두 매개 변수는 인증서 파일 경로와 키 파일 경로를 지정합니다. 서버 소켓은 이러한 파일이 없으면 작동하지 않을 가능성이 높습니다. 다음 명령을 사용하여 인증서를 생성 할 수 있습니다. &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">let 문</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">문자 'l'은 식별자로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">라이브러리는 이름을 짧지 만 의미있게 유지하기 위해 일반적인 약어를 사용하는 간단한 이름 지정 체계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">라이브러리는 이름을 짧지 만 의미있게 유지하기 위해 공통 약어를 사용하는 간단한 이름 지정 체계를 사용합니다. 버전 0.8.2부터이 구성표에 맞게 많은 기호의 이름이 바뀌 었습니다. 궁극적 인 목표는 프로그래머 가 이름을 &lt;em&gt;추측&lt;/em&gt; 할 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">여기에 나열된 pragma는 proc / method / converter의 코드 생성 옵션을 대체하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">배열 또는 시퀀스의 하한은 내장 proc &lt;code&gt;low()&lt;/code&gt; 에 의해 수신 될 수 있으며 , &lt;code&gt;high()&lt;/code&gt; 은 high ()에 의해 제한됩니다 . 길이는 &lt;code&gt;len()&lt;/code&gt; 의해 수신 될 수 있습니다 . 시퀀스 또는 열린 배열의 경우 &lt;code&gt;low()&lt;/code&gt; 는 항상 유효한 인덱스이므로 0을 반환합니다. &lt;code&gt;add()&lt;/code&gt; proc 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 를 사용하여 시퀀스에 요소를 추가 하고 &lt;code&gt;pop()&lt;/code&gt; proc를 사용하여 시퀀스의 마지막 요소를 제거 (및 가져 오기) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">매크로 호출은 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">매뉴얼에서는 &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim 문자열이 암시 적으로 cstring으로 변환되어&lt;/a&gt; 상호 작용이 일반적으로 고통스럽지 않다고 언급합니다 . &lt;code&gt;cstring&lt;/code&gt; 으로 변환 된 Nim 문자열을 허용하는 대부분의 C 함수 는이 문자열을 그대로 유지할 필요가 없으며 반환 할 때 더 이상 문자열이 필요하지 않습니다. 그러나 Nim 문자열을 보존하고 C 백엔드에서 &lt;code&gt;cstring&lt;/code&gt; 으로 사용할 수있는 드문 경우에는 문자열 데이터가 &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; 및 &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; 로 해제되지 않도록 수동으로 방지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">일치하는 도트 연산자는 원하는 효과에 따라 호출 가능한 종류 (프로세스, 템플릿 및 매크로)의 심볼 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">일치하는 AST는 호출 / 적용 식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">일치하는 AST는 lvalue 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">일치하는 AST에는 부작용이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">일치하는 AST에는 부작용이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">일치하는 AST에는 지정된 종류가 있어야합니다. (예 : &lt;code&gt;nkIfStmt&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 문을 나타냅니다 .)</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">컴파일러가 상수 접기와 같은 일부 최적화를 수행 한 후에 일치가 수행되므로 다음이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">일치하는 노드에는 하위가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">일치하는 노드는 &quot;abc&quot;, 12와 같은 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">일치하는 노드는 심볼 (바운드 식별자)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">일치하는 노드는 식별자 (바운드되지 않은 식별자) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">본문에 읽을 최대 내용 길이입니다.</target>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">의 최대 값 &lt;em&gt;(X)&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">두 정수의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">메소드 호출 구문은 명시적인 일반 인스턴스화와 충돌합니다. &lt;code&gt;x.p[T]&lt;/code&gt; 는 항상 &lt;code&gt;(x.p)[T]&lt;/code&gt; 로 구문 분석 되므로 &lt;code&gt;p[T](x)&lt;/code&gt; 는 &lt;code&gt;x.p[T]&lt;/code&gt; 로 쓸 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">최소 값 &lt;em&gt;(X)&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">두 정수의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">가능한 경우 1 자리의 분입니다.</target>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">백엔드가 지원되지 않는 경우 모듈은 순수 nim procs로 대체됩니다. &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; 플래그 를 사용하여 컴파일러 내장 함수를 비활성화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">가능하면 한 자리수의 월입니다.</target>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">항상 두 자리 숫자로 된 월입니다. 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">RTTI의 가장 중요한 이유. 순회 프로 시저를 생성하면 더 큰 코드가 생성되고 동적 프로 시저 바인딩을 예측하기 어렵 기 때문에 최신 하드웨어에서는 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">예외를 처리하는 가장 신뢰할 수있는 방법 은 미래에 &lt;code&gt;yield&lt;/code&gt; 을 사용 하고 미래의 &lt;code&gt;failed&lt;/code&gt; 자산 을 확인하는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">이 명령들 사이의 가장 중요한 차이점은 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리를 살펴보면 &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; 또는 &lt;code&gt;.m&lt;/code&gt; 파일을 찾을 수 있다는 것 외에 다른 모든 파일이 프로젝트의 기본 바이너리를 생성한다는 것입니다. 이를 통해 생성 된 코드를 가져 와서 이러한 언어를 사용하여 프로젝트에 직접 배치 할 수 있습니다. 다음은 일반적인 명령 행 호출입니다.</target>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">시간대의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">일반적인 &lt;code&gt;import&lt;/code&gt; 문은 모든 내 보낸 심볼을 가져옵니다 . 이는 &lt;code&gt;except&lt;/code&gt; 한정자 로 제외해야하는 이름 지정 기호로 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">일반적인 작업 모드는 &lt;code&gt;ProcRun&lt;/code&gt; 이라고 하며 명령 줄에서 Nim 컴파일러를 수동으로 실행하는 것과 유사하게 각 명령 또는 쿼리에 대한 프로세스를 시작합니다. &lt;code&gt;CaasRun&lt;/code&gt; 의 모드는 모든 쿼리에 응답하는 서버 프로세스를 시작합니다. &lt;code&gt;SymbolProcRun&lt;/code&gt; 의 모드는 컴파일러 개발자에 의해 사용됩니다. 즉, 모든 테스트를 실행하려면 모든 &lt;code&gt;*.txt&lt;/code&gt; 파일을 세 번 처리해야 하므로 시간이 많이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 표기법을 사용하여 &lt;code&gt;x&lt;/code&gt; 의 i 번째 요소에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">표기 &lt;code&gt;x[i]&lt;/code&gt; 액세스의 i 번째의 요소에 사용되는 &lt;code&gt;x&lt;/code&gt; . 배열 액세스는 항상 범위를 검사합니다 (컴파일 타임 또는 런타임시). pragma를 통해 또는 &lt;code&gt;--bound_checks:off&lt;/code&gt; 명령 줄 스위치 를 사용하여 컴파일러를 호출하여 이러한 검사를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">PEG에 사용 된 표기법은 EBNF와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">다음 결합 문자를 포함하여 's [i]'에 속하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">숫자는 모든 GC 힙의 개체 수를 계산하며 현재 스레드뿐만 아니라 실행중인 모든 스레드를 나타냅니다. 현재 스레드는 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 를 호출하는 스레드입니다 . 이는 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">숫자 식별자는 난수 일뿐입니다. 번호는 처리중인 파일에서 심볼의 섹션과 위치에 따라 지정되며 상수에 의존해서는 안됩니다. 심볼을 추가하거나 제거하면 숫자가 뒤섞 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">idetools의 사용은 사용자가 커서를 심볼에 놓거나 두 번 클릭하는 정의와 같은 정의에 적합하며 해당 심볼이 정의 된 위치에서 1 초 또는 2 초 후에 IDE가 표시됩니다. 이러한 대기 시간은 기호 제안과 같은 기능에 끔찍할 것입니다. 그리고 우리가 그것을 피할 수 있다면 왜 기다려야합니까?</target>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">일이 쉽지 않은 유일한 경우는 가비지 수집기가 작동하기 위해 어셈블러 조정이 필요한 경우입니다. 표준 버전의 GC는 C의 &lt;code&gt;setjmp&lt;/code&gt; 기능을 사용하여 모든 레지스터를 하드웨어 스택에 저장합니다. 새 플랫폼에서이 일반 코드를 일부 어셈블러 코드로 바꿔야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">해당 파일의 내용과이 proc에서 제공하는 값의 유일한 차이점은 &lt;code&gt;doc.file&lt;/code&gt; 변수입니다. 구성 파일 의 &lt;code&gt;doc.file&lt;/code&gt; 변수에는 독립형 페이지를 빌드하기위한 HTML이 포함되어 있으며이 proc은 &lt;code&gt;rstToHtml&lt;/code&gt; 과 같은 프로세스 의 컨텐츠 만 반환 하여 최소 HTML을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">&lt;code&gt;floatChecks&lt;/code&gt; pragma의 영향을받는 유일한 작업은 부동 소수점 유형에 대한 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">openarray 유형은 중첩 될 수 없습니다. 다차원 openarray는 거의 필요하지 않으며 효율적으로 수행 할 수 없기 때문에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">작업은 원자 적으로 수행되며 &lt;code&gt;mapper&lt;/code&gt; 가 호출되는 동안 테이블의 다른 작업은 차단 되므로 짧고 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">연산에서 무한 정밀도로 표현할 수없는 결과가 생성되었습니다 (예 : &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">연산은 지수 범위를 초과하는 결과를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">연산에서 너무 작아서 일반 숫자로 표시 할 수없는 결과가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">연산자의 우선 순위는 첫 문자로 결정됩니다. 자세한 내용은 매뉴얼에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">연산자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 가 중위 표기법으로 작성된 패턴에 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">연산자는 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; BOOL 타입에 대해 정의된다. &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 사업자 단락 평가를 수행한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">연산자는 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; BOOL 타입에 대해 정의된다. &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 운영자는 바로 가기 평가를 수행합니다. 예:</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">선택적 '채우기'문자는 필드를 최소 너비로 채우는 데 사용되는 문자를 정의합니다. 채우기 문자 (있는 경우) 뒤에 정렬 플래그가 와야합니다.</target>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">선택적 align 플래그는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">(키, 값) 쌍의 순서가 유지되므로 &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; 과 같이 순서가 지정된 dict을 쉽게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">교체 순서는 중요합니다. 인수 목록에서 이후의 교체보다 이전의 교체가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">그러면 원래 모듈 이름에 액세스 할 수 없습니다. &lt;code&gt;path/to/module&lt;/code&gt; 또는 &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; 표기법을 사용하여 하위 디렉토리의 모듈을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;width&lt;/em&gt; 가 &lt;em&gt;s.len&lt;/em&gt; 보다 작거나 같은 경우 원래 문자열이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">또 다른 이유는 더티 파일이 디스크의 어느 위치 (예 : tmpfs)에도 나타날 수 있지만 상대 경로 등을 사용할 때 원래 모듈과 일치하는 경로를 갖는 것으로 간주해야합니다. 그러나 쿼리는 일반 파일 이름 대신 답변에 더티 모듈 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">HTML 및 LaTeX의 출력은 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 및 &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; 구성 파일에서 제공됩니다. 이러한 파일을 프로젝트에 추가하고 수정하여 docgen 출력의 모양을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">출력은 입력 길이의 두 배입니다. &lt;code&gt;0x&lt;/code&gt; 와 같은 접두사 는 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">테스트의 출력 상세도.</target>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">병렬 명령문은 Nim 프로그램에서 병렬 처리를 도입하기 위해 선호되는 메커니즘입니다. Nim 언어의 하위 세트는 &lt;code&gt;parallel&lt;/code&gt; 섹션 내에서 유효합니다 . 이 서브셋은 컴파일 타임에 데이터 레이스가 없는지 확인합니다. 정교한 &lt;span id=&quot;disjoint-checker_1&quot;&gt;분리형 검사기&lt;/span&gt; 는 공유 메모리가 광범위하게 지원 되더라도 데이터 레이스가 불가능하다는 것을 보장합니다!</target>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">매개 변수의 유형은 일반 유형 또는 메타 유형 &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 일 수 있습니다. &lt;code&gt;type&lt;/code&gt; 은 형식 기호 만 인수로 제공 될 수 있으며 &lt;code&gt;untyped&lt;/code&gt; 않음은식이 템플릿에 전달되기 전에 기호 조회 및 형식 확인이 수행되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">파서는 들여 쓰기 수준의 스택을 사용합니다. 스택은 공백을 세는 정수로 구성됩니다. 들여 쓰기 정보는 구문 분석기의 전략적 위치에서 조회되지만 그렇지 않으면 무시됩니다. 의사 터미널 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 는 스택 맨 위에있는 항목보다 많은 공간으로 구성된 들여 쓰기를 나타냅니다. 같은 수의 공백이있는 들여 쓰기를 &lt;code&gt;IND{=}&lt;/code&gt; 로 지정하십시오. &lt;code&gt;DED&lt;/code&gt; 는 스택에서 값을 팝하는 &lt;em&gt;동작&lt;/em&gt; 을 설명하는 또 다른 의사 터미널이며 , &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 는 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">경로 분석은 &lt;strong&gt;현재&lt;/strong&gt; 소리가 좋지 않지만 그것이 쓸모없는 것은 아닙니다. 두 경로가 구문 상 동일하면 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">심볼의 일반 이름은 완전히 내 보낸 서명의 단순화 된 버전입니다. 변수 또는 상수는 복잡한 이름과 동일한 일반 이름 기호를 갖습니다. procs, 템플릿 및 기타 호출 가능한 유형의 일반 이름은 매개 변수, 반환 유형 및 pragma를 제거한 후 인용되지 않은 값입니다. 일반 이름을 사용하면 과부하로 인해 충돌하는 모듈이없는 경우 작동하는 짧고 멋진 심볼 링크가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 와 일치하는 부분 은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">여기에 나열된 pragma는 컴파일시 -d /-define 옵션의 값을 선택적으로 승인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">여기서 문제는 컴파일러가 이미 &lt;code&gt;toSeq&lt;/code&gt; 가 시퀀스로 변환 할 수있는 기회를 얻기 전에이 컨텍스트에서 iterator로서 &lt;code&gt;something()&lt;/code&gt; 을 호출 할 수 없다고 결정했다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; 는 nim 프로그램이 예상되는 동작 인 플랫폼에 대해 사건없이 종료 될 때 암시 적으로 호출됩니다. 처리되지 않은 예외 예외는 &lt;code&gt;quit(QuitFailure)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">이 proc은 서버가 설정 한 &quot;Set-Cookie&quot;헤더가 아니라 클라이언트가 설정 한 Cookie 헤더를 구문 분석하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">이 프로시 저는 여러 다른 공통 구문에 대한 출력을 사용할 수 있도록 설계되었습니다. &lt;strong&gt;참고&lt;/strong&gt; : Ansi C 코드 생성에는 올바르지 않습니다!</target>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 또는 &lt;code&gt;retrFile&lt;/code&gt; 프로 시저에 &lt;code&gt;onProgressChanged&lt;/code&gt; 프로 시저를 지정하여 파일 업로드 또는 파일 다운로드의 진행 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">프로젝트는 더 이상 사용되지 않는 구성 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">그 이유는 컴파일러가 이미 &lt;code&gt;echo&lt;/code&gt; 문에 대해 1을 &quot;1&quot;로 변환했기 때문입니다 . 그러나 매크로 다시 쓰기라는 용어는 의미를 변경해서는 안됩니다. 실제로 &lt;code&gt;--patterns:off&lt;/code&gt; 명령 행 옵션으로 또는 일시적으로 &lt;code&gt;patterns&lt;/code&gt; pragma 로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">이 코드를 컴파일 타임 proc로 다시 구현 하면 바이너리를 따라 배포 해야하는 &lt;code&gt;data.cfg&lt;/code&gt; 파일을 제거 할 수 있으며 정보가 실제로 일정하면 논리적으로 볼 수 없습니다 전역 변수에서 &lt;em&gt;변경 가능&lt;/em&gt; 하도록하려면 상수이면 더 좋습니다. 마지막으로 가장 가치있는 기능인 컴파일 타임에 일부 검증을 구현할 수 있습니다. 모든 것이 정확하지 않으면 바이너리를 얻는 것이 불가능하기 때문에 이것을 &lt;em&gt;더 나은 단위 테스트&lt;/em&gt; 라고 생각할 수 있습니다. 작은 중요한 파일이 없거나 내용이 변경되어 시작되지 않는 손상된 프로그램을 사용자에게 제공 할 수 없습니다 잘못된 것으로 실수.</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">형식과 접미사 간의 관계 는 &lt;code&gt;compiler/docgen.nim&lt;/code&gt; 파일 의 proc &lt;code&gt;complexName&lt;/code&gt; 에 의해 이루어집니다 . 다음은 &lt;a href=&quot;system&quot;&gt;시스템 모듈&lt;/a&gt; 에서 복잡한 기호 이름의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">기존 파일 제거</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">바꾸기 필터는 각 줄의 하위 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">의 표현 &lt;code&gt;if&lt;/code&gt; 표현은 미묘하지만 통과하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">if 문의 표현은 미묘하지만 통과하기 쉽습니다. 어떤이없는 경우 &lt;code&gt;else&lt;/code&gt; 지점은, 더 &lt;code&gt;nnkElse&lt;/code&gt; 아이는 존재하지 않는다.</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">응답의 본문 스트림을 동 기적으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">나머지 줄은 &lt;a href=&quot;re&quot;&gt;정규식으로&lt;/a&gt; 취급 되므로 괄호와 같은 메타 문자를 이스케이프 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">결과 클라이언트 소켓은 디스패처에 자동으로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">결과 클라이언트는 서버 소켓의 모든 속성을 상속합니다. 예를 들어, 소켓이 버퍼링되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">결과 문자열은 항상 &lt;em&gt;len&lt;/em&gt; 문자입니다. 선행 &lt;code&gt;0b&lt;/code&gt; 접두사가 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">결과 문자열은 항상 &lt;em&gt;len&lt;/em&gt; 문자입니다. 선행 &lt;code&gt;0o&lt;/code&gt; 접두사가 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">결과 문자열 앞에 접두사가 &lt;em&gt;붙고&lt;/em&gt; 접미사가 &lt;em&gt;접미사로&lt;/em&gt; 붙습니다 . 둘 다 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">결과 문자열은 앞에 0이 없을 수 있습니다. 길이는 항상 정확히 3입니다.</target>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">결과 문자열은 정확히 &lt;em&gt;len&lt;/em&gt; 문자입니다. &lt;code&gt;0x&lt;/code&gt; 와 같은 접두사 는 생성 되지 않습니다 . &lt;em&gt;x&lt;/em&gt; 는 부호없는 값으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">결과 문자열은 최소한됩니다 &lt;em&gt;minchars&lt;/em&gt; 긴 문자. 앞에 0을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">호출 된 proc / iterator가 &lt;code&gt;discardable&lt;/code&gt; pragma 로 선언 된 경우 리턴 값을 내재적으로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">호출 된 proc / iterator가 &lt;span id=&quot;discardable_1&quot;&gt;폐기 가능한&lt;/span&gt; pragma 로 선언 된 경우 리턴 값을 내재적으로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">리턴 된 &lt;code&gt;StringTableRef&lt;/code&gt; 에는 HTML 엔진이 최종 출력을 빌드하는 데 사용하는 매개 변수가 포함됩니다. 이 매개 변수의 정의와 목적에 대한 정보 는 컴파일러와 함께 제공되는 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 파일을 찾아보십시오 .</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">모든 데이터가 지정된 파일에 기록되면 반환 된 Future는 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">컴파일 타임 계산에 대한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">동일한 작업을 비동기식으로 수행 할 수도 있습니다. 간단히 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">같은과 같은 &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; ,하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;joinPath(head, tail)&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">부모 디렉토리가 없으면 &lt;code&gt;parentDir(head) / tail&lt;/code&gt; 과 같습니다 . 그런 다음 &lt;code&gt;head / tail&lt;/code&gt; 가 대신 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">같은 &lt;em&gt;joinPath (머리, 꼬리)&lt;/em&gt; ,하지만 디렉토리 부품의 수와 함께 작동합니다. 최소한 하나의 요소를 전달해야합니다. 그렇지 않으면 proc이 디버그 빌드를 선언하고 릴리스 빌드에서 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; 반복자 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; 반복자 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">같은 구문에 적용 &lt;code&gt;iterator&lt;/code&gt; (와 &lt;code&gt;nnkIteratorTy&lt;/code&gt; ),하지만 &lt;em&gt;하지 않습니다&lt;/em&gt; 에 적용되는 &lt;code&gt;converter&lt;/code&gt; 또는 &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">scanp 매크로</target>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">&lt;em&gt;*&lt;/em&gt; 의 두 번째 연산자 는 매개 변수 여야합니다. 모든 논증을 모으는 데 사용됩니다. 표현 &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; 에 전달되는 &lt;code&gt;optConc&lt;/code&gt; 에 (가지 특별한 목록으로 &lt;code&gt;nkArgList&lt;/code&gt; 호출 식으로 평평) 따라서 &lt;code&gt;optConc&lt;/code&gt; 를 호출 하면 다음이 생성됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">시퀀스에는 최소한 하나의 요소가 있어야합니다. 이 상황에서는 프로그램의 디버그 버전이 표시되지만 릴리스 버전은 기꺼이 진행됩니다. 시퀀스에 단일 요소가있는 경우 &lt;code&gt;operation&lt;/code&gt; 을 적용하지 않고 반환 됩니다 .</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">집합 유형은 집합의 수학적 개념을 모델링합니다. 세트의 기본 유형은 특정 크기의 서수 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">setrlimit () 시스템 호출은 자원 제한을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">부울 유형의 크기는 1 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 가장 작은 양수 (0이 아닌) 수입니다.</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 가장 작은 양수 (0이 아닌) 수입니다.</target>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">해결책은 모듈의 최상위 문장을 &lt;strong&gt;재생&lt;/strong&gt; 하는 것입니다. 이는 pragma의 영향을받는 내부 시퀀스를 채우는 로직을 특수한 경우없이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">진단 메시지를 트리거 한 소스 라인.</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">특수 &lt;code&gt;result&lt;/code&gt; 변수</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">대괄호 &lt;code&gt;[]&lt;/code&gt; 는 선택적 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">표준 배포판에는 다음 도구가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">표준 오류 스트림.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">표준 입력 스트림</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">표준 라이브러리는 16 비트 마이크로 컨트롤러에 대한 C 코드 생성이 가능한 지점까지 피할 수 있습니다. OS 기능이없는 베어 본 표준 라이브러리에 &lt;span id=&quot;standalone_1&quot;&gt;독립형&lt;/span&gt; 대상 ( &lt;code&gt;--os:standalone&lt;/code&gt; )을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">표준 라이브러리는 일부 기능이 구현되는 방식에 영향을주는 &lt;code&gt;useX&lt;/code&gt; 조건부 정의 의 증가를 지원합니다 . 이 섹션은 완전한 목록을 제공하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">표준 출력 스트림</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 후 명령문 은 예외 &lt;code&gt;e&lt;/code&gt; 가 발생 하지 않는 한 순차적 인 순서로 실행됩니다 . &lt;code&gt;e&lt;/code&gt; 의 예외 유형이 &lt;code&gt;except&lt;/code&gt; 절에 나열된 항목과 일치하면 해당 명령문이 실행됩니다. &lt;code&gt;except&lt;/code&gt; 절 뒤에 나오는 문장을 &lt;span id=&quot;exception-handlers_1&quot;&gt;예외 처리기&lt;/span&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 이후의 명령문 은 예외가 발생하지 않는 한 실행됩니다. 그런 다음 적절한 &lt;code&gt;except&lt;/code&gt; 부분이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">진술은 새로운 범위를 열지 않습니다.</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">true로 평가 된 표현식에 속하는 명령문은 컴파일러에 의해 변환되고 다른 명령문은 시맨틱을 검사하지 않습니다! 그러나 각 조건의 의미가 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">브랜치 내의 명령문은 새로운 범위를 열지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">테스트가 완료되었을 때의 상태.</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">stdlib API는 &lt;strong&gt;사용하기 쉽고&lt;/strong&gt; 일관 되도록 설계되었습니다 . 사용의 용이성은 구체적인 높은 수준의 행동을 달성하기위한 호출 횟수로 측정됩니다. 궁극적 인 목표는 프로그래머 가 이름을 &lt;em&gt;추측&lt;/em&gt; 할 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">stdtmpl 필터는 Nim에 간단한 템플릿 엔진을 제공합니다. 이 필터는 행 기반 구문 분석기를 사용합니다. 접 두부 &lt;em&gt;메타 문자&lt;/em&gt; (기본값 : &lt;code&gt;#&lt;/code&gt; )가 Nim 코드를 포함하고 다른 행은 그대로 사용됩니다. 들여 쓰기 기반 구문 분석은 템플릿 엔진에 적합하지 않으므로 제어 흐름 설명에는 &lt;code&gt;end X&lt;/code&gt; 구분 기호 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; 에 전달 된 문자열 리터럴 은 형식 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; 에 전달 된 문자열 리터럴 은 형식 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">CString 인수에 대한 stringify 연산자입니다. 문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">부울 인수에 대한 stringify 연산자입니다. &quot;false&quot;또는 &quot;true&quot;문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">문자 인수에 대한 stringify 연산자입니다. 문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">float 인수의 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">문자열 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 그대로 반환 합니다. 이 연산자는 일반 코드에 유용하므로 &lt;code&gt;expr&lt;/code&gt; 이 이미 문자열 인 경우 &lt;code&gt;$expr&lt;/code&gt; 도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">열거 인수에 대한 stringify 연산자입니다. 컴파일러 매직 덕분에 모든 열거 유형에 사용할 수 있습니다. 경우 &lt;code&gt;$&lt;/code&gt; 의 구체적인 열거에 대한 운영자가 제공되며,이 대신 사용됩니다. (즉, &lt;em&gt;덮어 쓰기&lt;/em&gt; 가능)</target>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">정수 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">정수 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다. &lt;code&gt;$&lt;/code&gt; 는 Nim의 일반적인 맞춤법 &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">스트립 필터는 각 행에서 선행 및 후행 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">(콜론 뒤 표현식은 &lt;code&gt;arg&lt;/code&gt; 에 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; )로 전달하는 옵션 인수 인 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">실제로 하위 집합은 다음과 같은 제한 / 변경 사항이 포함 된 전체 언어입니다.</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">대체 문자 는 문자열 리터럴 내에 Nim 표현식 &lt;em&gt;e를&lt;/em&gt; 도입합니다 . &lt;em&gt;e&lt;/em&gt; 는 &lt;em&gt;toString&lt;/em&gt; 연산 을 사용하여 문자열로 변환되며 기본값은 &lt;code&gt;$&lt;/code&gt; 입니다. 강력한 유형 검사 를 수행하려면 &lt;code&gt;toString&lt;/code&gt; 을 빈 문자열로 설정하십시오. &lt;em&gt;e&lt;/em&gt; 는이 PEG 패턴과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">대체 변수 ( &lt;code&gt;$&lt;/code&gt; 뒤에 나오는 것 )는 1에서 &lt;code&gt;a.len&lt;/code&gt; 까지 열거됩니다 . 완전 &lt;code&gt;$&lt;/code&gt; 를 생성하려면 &lt;code&gt;$$&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;$#&lt;/code&gt; 표기법을 사용하여 다음 대체 변수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">스위트는 개별 테스트 케이스를 나열된 순서대로 실행합니다. 기본 전역 설정을 사용하면 위 코드가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">제공된 &lt;code&gt;fd&lt;/code&gt; 의 비 차단 상태는 암시 적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">제네릭의 심볼 바인딩 규칙은 약간 미묘합니다. &quot;열린&quot;및 &quot;닫힌&quot;심볼이 있습니다. 인스턴스화 컨텍스트에서 &quot;닫힌&quot;기호는 리 바인드 될 수 없으며 &quot;열린&quot;기호는 가능합니다. 기본적으로 오버로드 된 심볼은 열려 있고 다른 모든 심볼은 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">기호의 &lt;code&gt;ast&lt;/code&gt; 필드는 요청시 느리게로드됩니다. 이곳은 대부분의 저축에서 비롯되며 얕은 외부 AST 만 즉시 재구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">두 세트의 대칭 차이는 수학적으로 &lt;em&gt;A △ B&lt;/em&gt; 또는 &lt;em&gt;A ⊖ B로 표시&lt;/em&gt; 되며 &lt;em&gt;s1&lt;/em&gt; 또는 &lt;em&gt;s2의&lt;/em&gt; 멤버 이지만 동시에 두 가지가 아닌 모든 객체의 세트입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">&lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; 구문을 사용하여 동일한 디렉토리에서 여러 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">반복자의 구문은 procs와 비슷하지만 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 가 nnkProcDef를 대체 &lt;code&gt;nnkProcDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">다른 언어의 중첩 배열 (다차원) 구문은 일반적으로 각 차원이 다른 차원과 동일한 인덱스 유형으로 제한되므로 더 많은 괄호를 추가해야합니다. Nim에서는 색인 유형이 서로 다른 차원을 가질 수 있으므로 중첩 구문이 약간 다릅니다. 레벨이 또 다른 열거 형으로 색인화 된 열거 형 배열로 정의 된 이전 예제를 기반으로 다음 행을 추가하여 정수 색인을 통해 액세스되는 높이 레벨로 세분화 된 라이트 타워 유형을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">유형 변환 구문은 &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; 은 일반 호출과 같이 )입니다.</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">의 구문 &lt;code&gt;case&lt;/code&gt; 객체 선언은 밀접의 구문은 다음 &lt;code&gt;case&lt;/code&gt; A의 지점 : 문 &lt;code&gt;case&lt;/code&gt; 섹션은 너무 들여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">템플릿 을 &lt;em&gt;호출&lt;/em&gt; 하는 구문 은 프로 시저를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">구문 트리</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">구문 트리는 임의의 수의 자식을 가질 수있는 노드로 구성됩니다. 유형과 기호는주기를 포함 할 수 있으므로 다른 노드로 표시됩니다. 의미 확인 후 AST의 모양이 변경됩니다. 이것은 코드 생성기의 삶을 더 쉽게 만들기 위해 필요합니다. 타입 정의는 &quot;ast&quot;모듈을 참조하십시오. &lt;a href=&quot;macros&quot;&gt;매크로&lt;/a&gt; 모듈은 AST 각 구문 구조를 나타냅니다 얼마나 많은 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">syscall 규칙은 C의 &lt;code&gt;__syscall&lt;/code&gt; 과 동일 합니다. 인터럽트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">temp 명령은 Nim 컴파일러를 빌드하지만 다른 최종 이름 ( &lt;code&gt;nim_temp&lt;/code&gt; )을 사용하므로 일반 컴파일러를 덮어 쓰지 않습니다. 이 명령을 사용하여 &lt;a href=&quot;#boot-command&quot;&gt;boot 명령&lt;/a&gt; 과 동일한 옵션을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">템플릿 엔진은 매우 유연합니다. 템플릿 코드를 파일에 직접 쓰는 프로 시저를 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 표현식은 변경하려는 시퀀스와 동일한 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 당신은 또한으로 전달해야 &lt;em&gt;일반&lt;/em&gt; 새로운 반환 순서가 원본보다 다른 유형을 가질 수 있기 때문에, 표현의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">문자열이 먼저 &lt;code&gt;cstring&lt;/code&gt; 유형으로 변환되지 않으면 종료 0에 액세스 할 수 없습니다 . 종료 0은이 변환이 O (1)에서 할당없이 수행 될 수 있음을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">테스트 상태 및 이름은 출력 또는 역 추적 후에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">문자열 리터럴을 작성하는 세 번째이자 마지막 방법은 &lt;em&gt;긴 문자열 리터럴&lt;/em&gt; 입니다. 그들은 세 따옴표와 함께 기록됩니다 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; 여러 줄에 걸쳐있을 수 있으며 &lt;code&gt;\&lt;/code&gt; 도 이스케이프 문자가 아닙니다. 예를 들어 HTML 코드 템플릿을 포함하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">백 슬래시의 세 번째 용도는 &lt;span id=&quot;generic-character-types_1&quot;&gt;일반 문자 유형&lt;/span&gt; 을 지정하는 것 입니다. 다음은 항상 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">후행 줄 바꿈 문자는 반복 된 행에서 제거됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">coercion &lt;code&gt;static(x)&lt;/code&gt; 유형을 사용하여 주어진 표현식 &lt;code&gt;x&lt;/code&gt; 의 컴파일 타임 평가를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 L- 값이고 &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; 보유 하는 경우 유형 변환 &lt;code&gt;T(a)&lt;/code&gt; 는 L- 값 입니다.</target>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">매개 변수 유형은 &lt;code&gt;var&lt;/code&gt; 키워드 로 시작될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">파일 핸들을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">유형 접미사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">&lt;code&gt;var T&lt;/code&gt; 및 &lt;code&gt;typedesc[T]&lt;/code&gt; 유형 은 일반 인스턴스화에서 유추 할 수 없습니다. 다음은 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">일반적인 컴파일러 사용법은 &lt;code&gt;compile&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 명령을 사용하여 &lt;code&gt;.nim&lt;/code&gt; 파일을 하나 이상의 &lt;code&gt;.c&lt;/code&gt; 파일로 변환 한 다음 플랫폼의 C 컴파일러를 사용하여 정적 이진 파일로 컴파일하는 것입니다. 그러나 C ++, Objective-C 또는 Javascript로 컴파일하는 다른 명령이 있습니다. 자세한 내용은 &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">이 옵션의 일반적인 사용 시나리오는 사용자가 &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;객체 지향 호출 구문&lt;/a&gt; 의 점 문자를 입력 한 후 호출하는 것 입니다. Idetools는 범위 (가장 안쪽에서 바깥쪽으로)와 항목 이름별로 정렬 된 제안을 반환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">이 옵션의 일반적인 사용 시나리오는 사용자가 &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;객체 지향 호출 구문&lt;/a&gt; 의 점 문자를 입력 한 후 호출하는 것 입니다. Nimsuggest는 범위별로 (가장 안쪽에서 바깥쪽으로) 정렬 한 다음 항목 이름별로 제안을 반환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">두 세트의 합집합은 수학적으로 &lt;em&gt;A &amp;cup; B&lt;/em&gt; 로 표현되며 &lt;em&gt;s1&lt;/em&gt; , &lt;em&gt;s2&lt;/em&gt; 또는 둘 다의 구성원 인 모든 객체의 집합입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">&lt;code&gt;maxPauseInUs&lt;/code&gt; 및 &lt;code&gt;us&lt;/code&gt; 매개 변수의 단위 는 마이크로 초입니다.</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">unsafeAddr 연산자</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">새 파일 업로드</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 의 사용법 (실험)은 객체와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">사용 설명서에는 명령 줄 인수, 컴파일러의 특수 기능 등이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">using 문은 동일한 매개 변수 이름과 유형이 반복해서 사용되는 모듈에서 구문 편의성을 제공합니다. 대신에:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">반환 된 열거 형의 값은 매우 자명해야합니다.</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">var 문</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">var 문은 새로운 지역 또는 전역 변수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">변수 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;for&lt;/code&gt; 루프에 의해 암시 적으로 선언되며 &lt;code&gt;int&lt;/code&gt; 유형을 갖습니다 . 이것이 &lt;a href=&quot;system#countup&quot;&gt;countup이&lt;/a&gt; 리턴 하는 것이기 때문입니다 . &lt;code&gt;i&lt;/code&gt; 는 1, 2, .., 10 값을 통해 실행됩니다. 각 값은 &lt;code&gt;echo&lt;/code&gt; 입니다. 이 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">변수는 &lt;em&gt;cmpIgnoreStyle&lt;/em&gt; 과 비교됩니다 . 형식이 잘못된 형식 문자열이 &lt;em&gt;%&lt;/em&gt; 연산자에 전달 &lt;em&gt;되면 ValueError&lt;/em&gt; 가 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">while 문은 간단한 루핑 구문입니다.</target>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">패딩이없는 연도. 연도가 BC 인 경우에도 항상 긍정적입니다.</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">패딩이없는 연도. 연도가 BC 인 경우 음수입니다.</target>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">연도는 4 자리 이상으로 채워졌습니다. 연도가 BC 인 경우에도 항상 긍정적입니다. 연도가 4 자리를 초과하면 '+'가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">연도는 4 자리 이상으로 채워졌습니다. 연도가 BC 인 경우 음수입니다. 연도가 4 자리를 초과하면 연도가 BC가 아닌 한 '+'가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#readAll&quot;&gt;readAll을&lt;/a&gt; 호출 하고 나중에 파일을 닫습니다. 문자열을 반환합니다. 오류가 발생하면 IO 예외가 발생합니다. 컴파일 타임 매크로 내에서 이것을 호출 해야하는 경우 &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 모듈 &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 에 종 속됨 )가 컴파일되고 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 는 변경되지 않습니다. &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;G.P2&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;G.P1&lt;/code&gt; 이 필요한 모듈 &lt;code&gt;B&lt;/code&gt; 가 컴파일 됩니다. 문제 없습니다. &lt;code&gt;G.P1&lt;/code&gt; 이 심볼 파일에서로드되고 &lt;code&gt;G.c&lt;/code&gt; 이제 &lt;code&gt;G.P1&lt;/code&gt; 이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">그런 다음 C 코드와 컴파일 스크립트 &lt;code&gt;compile_myproject.sh&lt;/code&gt; 를 Linux i386 시스템으로 이동하고 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Nim에는 2 가지 종류의 반복자가 있습니다 : &lt;em&gt;인라인&lt;/em&gt; 및 &lt;em&gt;클로저&lt;/em&gt; 반복자. &lt;span id=&quot;inline-iterator_1&quot;&gt;인라인 반복자는&lt;/span&gt; 항상 추상화 제로 오버 헤드로 이어지는 컴파일러에 의해 인라인 것 반복자이지만, 코드 크기에 무거운 증가 될 수 있습니다. 인라인 반복자는 2 등 시민입니다. 템플릿, 매크로 및 기타 인라인 반복자와 같은 다른 인라인 코드 기능에만 매개 변수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">유형에 바인딩 된 3 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">DevkitPro 라이브러리가 지원하지 않기 때문에 작동하지 않는 몇 가지가 있습니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">또한 문자 &lt;code&gt;r&lt;/code&gt; (또는 &lt;code&gt;R&lt;/code&gt; ) 이 앞에 오는 원시 문자열 리터럴이 있으며 (일반 문자열 리터럴과 마찬가지로) 큰 따옴표로 일치하고 이스케이프 시퀀스를 해석하지 않습니다. 이는 정규식 또는 Windows 경로에 특히 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">현재 확인 모드에는 두 가지 옵션 만 있습니다. 하나는 &lt;code&gt;CVerifyNone&lt;/code&gt; 이고 인증서는 확인되지 않으며 다른 하나는 &lt;code&gt;CVerifyPeer&lt;/code&gt; 이며 인증서는 확인되며 &lt;code&gt;CVerifyPeer&lt;/code&gt; 가 가장 안전한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 사용을 포함하여 여러 가지 방법으로이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; AST에 대한 제약은 없으며 집합 배열의 중첩 된 튜플에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">의미 검사 또는 코드 생성에 사용되는 몇 가지 노드 종류가 있습니다. 이들은이 모듈에서 액세스 할 수 있지만 사용해서는 안됩니다. 다른 노드 종류는 특히 AST 조작을 쉽게하도록 설계되었습니다. 이것들은 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">메타 문자에는 두 가지 다른 세트가 있습니다. 대괄호를 제외하고 패턴의 어느 곳에서나 인식 할 수있는 문자와 대괄호로 인식되는 것입니다. 대괄호 외부에서 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">두 개의 의사 디렉토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">Nim 코드에서 PEG를 구성하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
