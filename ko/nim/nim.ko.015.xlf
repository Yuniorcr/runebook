<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="f2bfda7968a1eb32a2691114a507bde9911dd945" translate="yes" xml:space="preserve">
          <source>the set of hexadecimal digits</source>
          <target state="translated">16 진수 세트</target>
        </trans-unit>
        <trans-unit id="4f5ec72bc91c39a801c168c4fd870055b34b872b" translate="yes" xml:space="preserve">
          <source>the set of letters</source>
          <target state="translated">편지 세트</target>
        </trans-unit>
        <trans-unit id="fb2306e3243fe86370aa8b5d9c1aabd32b90b240" translate="yes" xml:space="preserve">
          <source>the strategy the GC should use for the application</source>
          <target state="translated">GC가 응용 프로그램에 사용해야하는 전략</target>
        </trans-unit>
        <trans-unit id="6a18fe8b3851fb0011d0d6ad2f5b889e5d4c366c" translate="yes" xml:space="preserve">
          <source>the string the substring is replaced with</source>
          <target state="translated">부분 문자열이 교체되는 문자열</target>
        </trans-unit>
        <trans-unit id="2d0622ec8cfcd05880394c2f59ee51fdb9a7d2fb" translate="yes" xml:space="preserve">
          <source>the substring that is searched for</source>
          <target state="translated">검색된 부분 문자열</target>
        </trans-unit>
        <trans-unit id="0d5c2c867f3d1cfa797d58059dc332d96a002355" translate="yes" xml:space="preserve">
          <source>the used request method</source>
          <target state="translated">사용 된 요청 방법</target>
        </trans-unit>
        <trans-unit id="89c2628bb09501d850a5e90294178c31c5acc221" translate="yes" xml:space="preserve">
          <source>third argument to &lt;em&gt;socket&lt;/em&gt; proc</source>
          <target state="translated">&lt;em&gt;소켓&lt;/em&gt; proc에 대한 세 번째 인수</target>
        </trans-unit>
        <trans-unit id="03da7fdb5bcbe273558acb16350f9d9f83e0afb0" translate="yes" xml:space="preserve">
          <source>this is an alias for &lt;code&gt;uint8&lt;/code&gt;, that is an unsigned int 8 bits wide.</source>
          <target state="translated">이것은 &lt;code&gt;uint8&lt;/code&gt; 의 별명 이며, 부호없는 int 8 비트 너비입니다.</target>
        </trans-unit>
        <trans-unit id="d605f52a9509b6f66c0b5e65827be72048a082ca" translate="yes" xml:space="preserve">
          <source>this module calls the C compiler and linker; interesting if you want to add support for a new C compiler</source>
          <target state="translated">이 모듈은 C 컴파일러와 링커를 호출합니다. 새로운 C 컴파일러에 대한 지원을 추가하려는 경우 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="5729fbbfa5e9f9e12d762e60bf56c14ff052b58a" translate="yes" xml:space="preserve">
          <source>this needs to be called to set &lt;em&gt;x&lt;/em&gt;'s runtime object type field.</source>
          <target state="translated">이것은 &lt;em&gt;x&lt;/em&gt; 의 런타임 객체 유형 필드 를 설정하기 위해 호출되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d207023adf43bb701b1f64b88c4db96f80a1b34d" translate="yes" xml:space="preserve">
          <source>this object implements the command line parser</source>
          <target state="translated">이 객체는 커맨드 라인 파서를 구현합니다</target>
        </trans-unit>
        <trans-unit id="79af1f61608dcb0051baae409727e0f65ac5267c" translate="yes" xml:space="preserve">
          <source>threadpool</source>
          <target state="translated">threadpool</target>
        </trans-unit>
        <trans-unit id="508fa634d8045fb01be9c5e937685e183d0e4232" translate="yes" xml:space="preserve">
          <source>threadpool.^</source>
          <target state="translated">threadpool.^</target>
        </trans-unit>
        <trans-unit id="c91e11a1f2a2f6f290fe5039f78f07f318049442" translate="yes" xml:space="preserve">
          <source>threads</source>
          <target state="translated">threads</target>
        </trans-unit>
        <trans-unit id="7196b5875f713c826bd279dbda843c897e2a60c2" translate="yes" xml:space="preserve">
          <source>times</source>
          <target state="translated">times</target>
        </trans-unit>
        <trans-unit id="2087f0002a85b5fe534837cc8696206ffebc529e" translate="yes" xml:space="preserve">
          <source>times.$</source>
          <target state="translated">times.$</target>
        </trans-unit>
        <trans-unit id="ac628c3dd03a733f41b8d8397cb04d1a72d24be4" translate="yes" xml:space="preserve">
          <source>times.&amp;lt;</source>
          <target state="translated">times.&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3466781775c44bc9c2b9b0b020195bc9e8972ecb" translate="yes" xml:space="preserve">
          <source>times.*</source>
          <target state="translated">times.*</target>
        </trans-unit>
        <trans-unit id="efd6d079454159fa4c32737147b86764bbb1d55e" translate="yes" xml:space="preserve">
          <source>times.*=</source>
          <target state="translated">times.*=</target>
        </trans-unit>
        <trans-unit id="5d0867948fa605b33486cb3ac7961a57cf7897eb" translate="yes" xml:space="preserve">
          <source>times.+</source>
          <target state="translated">times.+</target>
        </trans-unit>
        <trans-unit id="982e57c594c3c436b5116bc0a0b1334898723b30" translate="yes" xml:space="preserve">
          <source>times.+=</source>
          <target state="translated">times.+=</target>
        </trans-unit>
        <trans-unit id="1914f43d4b9661816259443161e9e88a0e9886d2" translate="yes" xml:space="preserve">
          <source>times.-</source>
          <target state="translated">times.-</target>
        </trans-unit>
        <trans-unit id="26485a2a2a1cad385b067d8d394e72a2e24ab536" translate="yes" xml:space="preserve">
          <source>times.-=</source>
          <target state="translated">times.-=</target>
        </trans-unit>
        <trans-unit id="33c4c6b630e87de8d044fa88c8a671902ca92bfa" translate="yes" xml:space="preserve">
          <source>times.==</source>
          <target state="translated">times.==</target>
        </trans-unit>
        <trans-unit id="bb326a42dcbb97915c3635d2d6ded55c37c2fcd8" translate="yes" xml:space="preserve">
          <source>times.Time</source>
          <target state="translated">times.Time</target>
        </trans-unit>
        <trans-unit id="ccf909f41569fca1dfca6fe3d505b3681efc48af" translate="yes" xml:space="preserve">
          <source>times.div</source>
          <target state="translated">times.div</target>
        </trans-unit>
        <trans-unit id="0daaa55873b9f53f9bdcc18b0e7b8a777a6c7e01" translate="yes" xml:space="preserve">
          <source>transf</source>
          <target state="translated">transf</target>
        </trans-unit>
        <trans-unit id="d00177f0a144cd530d95d358f3ab889969731ba9" translate="yes" xml:space="preserve">
          <source>transformations on the AST that need to be done before code generation</source>
          <target state="translated">코드 생성 전에 수행해야하는 AST 변환</target>
        </trans-unit>
        <trans-unit id="e82e23f51f0a004fcbbeb9426f09d1161588741b" translate="yes" xml:space="preserve">
          <source>treat &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as unsigned and compare</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 부호없는 것으로 취급 하고 비교</target>
        </trans-unit>
        <trans-unit id="33c519e230c7a1b6cbd1aad159d8cc6e7bb33086" translate="yes" xml:space="preserve">
          <source>treats &lt;code&gt;a&lt;/code&gt; as unsigned and converts it to an unsigned integer of 16 bits (but still the &lt;code&gt;int16&lt;/code&gt; type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e002f28bad29f68d77ac9e65b4a42bf9e294d184" translate="yes" xml:space="preserve">
          <source>treats &lt;code&gt;a&lt;/code&gt; as unsigned and converts it to an unsigned integer of 32 bits (but still the &lt;code&gt;int32&lt;/code&gt; type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47256719003b43ca58b00991711b6e19d6b6f486" translate="yes" xml:space="preserve">
          <source>treats &lt;code&gt;a&lt;/code&gt; as unsigned and converts it to an unsigned integer of 8 bits (but still the &lt;code&gt;int8&lt;/code&gt; type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59716e58ee079f3db5f7330e595545442a4fd81f" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9824fc65aab6f06514fc5666758d8387a2e228b8" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and compares them. Returns true iff &lt;code&gt;unsigned(x) &amp;gt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e667898a8218b61c8e793b10dc47190d18304067" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and compares them. Returns true iff &lt;code&gt;unsigned(x) &amp;gt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42421b8bbe3c8197c988bc8813e596704f9a24bc" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and compares them. Returns true iff &lt;code&gt;unsigned(x) &amp;lt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9710b6765c8773116d7e73253a2983946b9c38ac" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and compares them. Returns true iff &lt;code&gt;unsigned(x) &amp;lt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56515abdf6bbd5834be36f12a9e541ffaa799552" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and compute the modulo of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt;. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ff32e3ffbd094a506176085b094f176bdd74be" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ebc4f76f3ebc60ceaccf28fb092eab15d98b5e" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4191cdc9be3af957f2ebece6f18f33627cc2f429" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9662e306aa7cb2248d58871e2c939ade8a0bdf" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; as unsigned and converts it to a byte by taking the last 8 bits from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb899e429f447cf6215edb4d70aabd9dc59beb56" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; as unsigned and converts it to an &lt;code&gt;int16&lt;/code&gt; by taking the last 16 bits from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61374a2d6363bf333ce4b07b97db9ec17418b081" translate="yes" xml:space="preserve">
          <source>treats &lt;em&gt;x&lt;/em&gt; as unsigned and converts it to an &lt;code&gt;int32&lt;/code&gt; by taking the last 32 bits from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d7a4c1389cffecac2b41b4645a305dcc137e81" translate="yes" xml:space="preserve">
          <source>trees</source>
          <target state="translated">trees</target>
        </trans-unit>
        <trans-unit id="1e1c586524f2c231886db840c7da8be851f25f77" translate="yes" xml:space="preserve">
          <source>tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca3365d237d814de67a7685150e322562d9f867" translate="yes" xml:space="preserve">
          <source>true if the backend doesn't support &quot;fake variables&quot; like 'var EBADF {.importc.}: cint'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064eeb69888308fa853f99dc7f9ff9cacb68ecc0" translate="yes" xml:space="preserve">
          <source>true if the file system is case sensitive, false otherwise. Used by &lt;em&gt;cmpPaths&lt;/em&gt; to compare filenames properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1bdabef37d690a18ff40efc5bdfeac89fb6eec" translate="yes" xml:space="preserve">
          <source>try to find a better algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e02512e5c0b62849a898652ba3b0dd91c8e60eb" translate="yes" xml:space="preserve">
          <source>tuple[x: A, y: B, ...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791a7672f77b4930f2031e341d4208d16bdf9b86" translate="yes" xml:space="preserve">
          <source>turn Inf checks on|off</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034740a2e34088f565116370a6d18b63664c95a9" translate="yes" xml:space="preserve">
          <source>turn NaN checks on|off</source>
          <target state="translated">NaN 점검 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="46f6bd0e77a6fbf12d8b010ae9c8a1e9021e1bf1" translate="yes" xml:space="preserve">
          <source>turn all floating point (NaN/Inf) checks on|off</source>
          <target state="translated">모든 부동 소수점 (NaN / Inf) 검사 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="0d7673de665a7649a65e229fc12e1e5a1a6f0b8e" translate="yes" xml:space="preserve">
          <source>turn all hints on|off or list all available</source>
          <target state="translated">모든 힌트를 켜거나 끄거나 사용 가능한 모든 것을 나열하십시오</target>
        </trans-unit>
        <trans-unit id="57ca16236159de7ffa5a03d5cdf0e9ea7282164e" translate="yes" xml:space="preserve">
          <source>turn all runtime checks on|off</source>
          <target state="translated">모든 런타임 검사를 켭니다 | 끄기</target>
        </trans-unit>
        <trans-unit id="e63be904855bd0fd2458b4fc87df39dc8d1f71ad" translate="yes" xml:space="preserve">
          <source>turn all warnings on|off or list all available</source>
          <target state="translated">모든 경고를 켜거나 끄거나 가능한 모든 것을 나열하십시오</target>
        </trans-unit>
        <trans-unit id="cb992c73f24ec9bfc2a37af68e95c042a90604a7" translate="yes" xml:space="preserve">
          <source>turn assertions on|off</source>
          <target state="translated">어설 션 켜기 / 끄기</target>
        </trans-unit>
        <trans-unit id="64bdc16dbb770559159ab0071731fae5a840b237" translate="yes" xml:space="preserve">
          <source>turn bound checks on|off</source>
          <target state="translated">바운드 검사 켜기 / 끄기</target>
        </trans-unit>
        <trans-unit id="06edec037728ddc7f01a16baa5d35c504e7d4b21" translate="yes" xml:space="preserve">
          <source>turn case variant field checks on|off</source>
          <target state="translated">사례 변형 필드 확인 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="631c37660bab86dec89421045302180d81330f0d" translate="yes" xml:space="preserve">
          <source>turn compiler messages coloring on|off</source>
          <target state="translated">컴파일러 메시지 색상 표시 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="4b23968df812c9d231ebb8fda79ccba0ac756552" translate="yes" xml:space="preserve">
          <source>turn implicit compile time evaluation on|off</source>
          <target state="translated">암시 적 컴파일 시간 평가 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="d3dc59a91a195dac94031d9c5345d8686eb1373b" translate="yes" xml:space="preserve">
          <source>turn index file generation on|off</source>
          <target state="translated">인덱스 파일 생성 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="70c535a11cb62cc9abd315b8f1eeb99f507480fc" translate="yes" xml:space="preserve">
          <source>turn int over-/underflow checks on|off</source>
          <target state="translated">int 오버 / 언더 플로 검사 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="bbb760a7e8a12cf07546693daaf1555889738ad0" translate="yes" xml:space="preserve">
          <source>turn line tracing on|off</source>
          <target state="translated">회선 추적 설정 | 해제</target>
        </trans-unit>
        <trans-unit id="b2ecf2df9f54e6340ba3c891de2176a32ce29ed4" translate="yes" xml:space="preserve">
          <source>turn memory tracker on|off</source>
          <target state="translated">메모리 트래커를 켜십시오 |</target>
        </trans-unit>
        <trans-unit id="bc77a350809f8078993c86c3c1d754e69781b24d" translate="yes" xml:space="preserve">
          <source>turn nil checks on|off</source>
          <target state="translated">무효 점검 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="69e178f9106840516ac7f281b8779a3d2310fcd2" translate="yes" xml:space="preserve">
          <source>turn obj conversion checks on|off</source>
          <target state="translated">obj 변환 확인 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="612554c4d04eee3ec19224f3c1a9ed74aa11865f" translate="yes" xml:space="preserve">
          <source>turn on debugging info recording</source>
          <target state="translated">정보 기록 디버깅 켜기</target>
        </trans-unit>
        <trans-unit id="db58c4ebb9821dc5f3108c07c349f8fe29c3a2a4" translate="yes" xml:space="preserve">
          <source>turn on the optimizer and turn off runtime checks</source>
          <target state="translated">옵티 마이저를 켜고 런타임 점검을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="b79139afd409a801c64bafb631642bae72488e22" translate="yes" xml:space="preserve">
          <source>turn on|off the old behaviour of &quot;n&quot;</source>
          <target state="translated">&quot;n&quot;의 이전 동작을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="c83f04b1b53bddf50eb5fded42dc940360359ee8" translate="yes" xml:space="preserve">
          <source>turn pattern matching on|off</source>
          <target state="translated">패턴 일치 켜기 / 끄기</target>
        </trans-unit>
        <trans-unit id="67301da5b290441db9cee2529690269e46836e50" translate="yes" xml:space="preserve">
          <source>turn range checks on|off</source>
          <target state="translated">범위 확인 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="fae0655b11b611d29aefcd8ea33a3692e0dbfca5" translate="yes" xml:space="preserve">
          <source>turn specific hint X on|off</source>
          <target state="translated">특정 힌트 X 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="fcee718c331d44d87f5a9d536aa16248de754790" translate="yes" xml:space="preserve">
          <source>turn specific warning X on|off</source>
          <target state="translated">특정 경고 X 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="ebf5c00b8be857cb8a1cb29a60576c91b8abe83b" translate="yes" xml:space="preserve">
          <source>turn stack tracing on|off</source>
          <target state="translated">스택 추적 설정 | 해제</target>
        </trans-unit>
        <trans-unit id="7a6ba83d8e33aaa56155f3479a225fa179878864" translate="yes" xml:space="preserve">
          <source>turn support for hot code reloading on|off</source>
          <target state="translated">핫 코드 리로딩 지원 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="ceedec5b704caef189c467c29087afb35e74707b" translate="yes" xml:space="preserve">
          <source>turn support for multi-threading on|off</source>
          <target state="translated">멀티 스레딩 지원 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="0c99465881b32d0df551399540a690efc284e425" translate="yes" xml:space="preserve">
          <source>turn taint mode on|off</source>
          <target state="translated">테 인트 모드 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="5bc2ead9568e1e03ccb55c95db4ff05a620894b3" translate="yes" xml:space="preserve">
          <source>turn thread analysis on|off</source>
          <target state="translated">실 분석 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="cc7a3467a20d6d1ef58c8f4528fb690fd6860671" translate="yes" xml:space="preserve">
          <source>turn thread local storage emulation on|off</source>
          <target state="translated">스레드 로컬 스토리지 에뮬레이션 켜기 | 끄기</target>
        </trans-unit>
        <trans-unit id="712cbddc3b81e251579863cc6c33b392292fdb33" translate="yes" xml:space="preserve">
          <source>turns &lt;em&gt;c&lt;/em&gt; into a string representation. Example outputs: &lt;code&gt;{keyA: value, keyB: value}&lt;/code&gt;, &lt;code&gt;{:}&lt;/code&gt; If &lt;em&gt;T&lt;/em&gt; is void the outputs look like: &lt;code&gt;{keyA, keyB}&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 를 문자열 표현으로 바꿉니다 . 예제 출력 : &lt;code&gt;{keyA: value, keyB: value}&lt;/code&gt; , &lt;code&gt;{:}&lt;/code&gt; 경우 &lt;em&gt;T는&lt;/em&gt; : 무효 출력이 같을 &lt;code&gt;{keyA, keyB}&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f561e50a013c41565a2502f93d1fb158ee99752" translate="yes" xml:space="preserve">
          <source>turns a list into its string representation.</source>
          <target state="translated">리스트를 문자열 표현으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="492c95525814b5b5878b387edf22a30c891693c0" translate="yes" xml:space="preserve">
          <source>turns an array into a sequence. This most often useful for constructing sequences with the array constructor: &lt;code&gt;@[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;seq[int]&lt;/code&gt;, while &lt;code&gt;[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;array[0..2, int]&lt;/code&gt;.</source>
          <target state="translated">배열을 시퀀스로 바꿉니다. 대부분 유용한 배열 생성자 시퀀스를 구성하기위한 본 : &lt;code&gt;@[1, 2, 3]&lt;/code&gt; 타입 갖는 &lt;code&gt;seq[int]&lt;/code&gt; 하면서, &lt;code&gt;[1, 2, 3]&lt;/code&gt; 타입 가지고 &lt;code&gt;array[0..2, int]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3232af99db4fe02abd0ebeabed3f7c57b0a5fc94" translate="yes" xml:space="preserve">
          <source>turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">openarray를 시퀀스로 바꿉니다. 고정 길이 배열을 시퀀스로 바꾸는 것만 큼 효율적이지 않습니다. 항상의 모든 요소를 ​​복사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a5255c34647d8db613e585082f942ff4da1415ba" translate="yes" xml:space="preserve">
          <source>type class</source>
          <target state="translated">타입 클래스</target>
        </trans-unit>
        <trans-unit id="8f2f38522f68d54b7caff5db71724f55ffaae948" translate="yes" xml:space="preserve">
          <source>type class matching all floating point number types</source>
          <target state="translated">모든 부동 소수점 숫자 유형과 일치하는 유형 클래스</target>
        </trans-unit>
        <trans-unit id="0168425a72f7b8ba720a9fe0312ed348ea168b1f" translate="yes" xml:space="preserve">
          <source>type class matching all integer types</source>
          <target state="translated">모든 정수 유형과 일치하는 유형 클래스</target>
        </trans-unit>
        <trans-unit id="dbb5d49a3280c2058ae7a9d9fedc7886aa06bb7a" translate="yes" xml:space="preserve">
          <source>type class matching all number types</source>
          <target state="translated">모든 숫자 유형과 일치하는 유형 클래스</target>
        </trans-unit>
        <trans-unit id="d9106a1a8e5cfe2e5f56545fd45715dabfa7a77b" translate="yes" xml:space="preserve">
          <source>type class matching all ordinal types; however this includes enums with holes.</source>
          <target state="translated">모든 서수 유형과 일치하는 유형 클래스; 그러나 여기에는 구멍이있는 열거 형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6518e48ee8dad7d40f9cef91cf0a90a98fa2f7a2" translate="yes" xml:space="preserve">
          <source>type class matching all signed integer types</source>
          <target state="translated">부호있는 모든 정수 유형과 일치하는 유형 클래스</target>
        </trans-unit>
        <trans-unit id="24e8d3d42e5df6cb679aff7e32b2e8a7e711f71c" translate="yes" xml:space="preserve">
          <source>type class matching all unsigned integer types</source>
          <target state="translated">부호없는 모든 정수 유형과 일치하는 유형 클래스</target>
        </trans-unit>
        <trans-unit id="20f75de381552740638467931ba4a1496d3221c5" translate="yes" xml:space="preserve">
          <source>type definitions of the abstract syntax tree (AST) and node constructors</source>
          <target state="translated">AST (Abstract Syntax Tree) 및 노드 생성자의 유형 정의</target>
        </trans-unit>
        <trans-unit id="b9dcb6746941332c23533451df027907bbb202ed" translate="yes" xml:space="preserve">
          <source>type operator</source>
          <target state="translated">타입 연산자</target>
        </trans-unit>
        <trans-unit id="061ee47bffeb169a81df46dc273d5fe1a9050ca0" translate="yes" xml:space="preserve">
          <source>type that can hold any Unicode character</source>
          <target state="translated">모든 유니 코드 문자를 포함 할 수있는 유형</target>
        </trans-unit>
        <trans-unit id="0313bcc9ac9a02042490d9b3dca79d9b782d4838" translate="yes" xml:space="preserve">
          <source>type that is constructed by &lt;code&gt;^&lt;/code&gt; for reversed array accesses.</source>
          <target state="translated">역 배열 액세스를 위해 &lt;code&gt;^&lt;/code&gt; 로 구성된 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="4e6c886e0317f48b73f14b83939f1dcc2112de74" translate="yes" xml:space="preserve">
          <source>type that represents a PEG</source>
          <target state="translated">PEG를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="81da4742c99b55387c1240a56ce878b23ab451fa" translate="yes" xml:space="preserve">
          <source>type that represents an OS file handle; this is useful for low-level file access</source>
          <target state="translated">OS 파일 핸들을 나타내는 유형; 이것은 저수준 파일 액세스에 유용합니다</target>
        </trans-unit>
        <trans-unit id="e692d7ad128cf61431c997ad9eb463411a384715" translate="yes" xml:space="preserve">
          <source>type[T]</source>
          <target state="translated">type[T]</target>
        </trans-unit>
        <trans-unit id="85de7fd42ab4dcb24c0b6080e1e6e07a08df4a4d" translate="yes" xml:space="preserve">
          <source>typeinfo</source>
          <target state="translated">typeinfo</target>
        </trans-unit>
        <trans-unit id="20ba48d5984d4d7818969d950c0439a2dbd8c23e" translate="yes" xml:space="preserve">
          <source>typeinfo.Any</source>
          <target state="translated">typeinfo.Any</target>
        </trans-unit>
        <trans-unit id="f8794c20534f6edad3da643d5f1dba39b000ea2f" translate="yes" xml:space="preserve">
          <source>typeinfo.[]</source>
          <target state="translated">typeinfo.[]</target>
        </trans-unit>
        <trans-unit id="c6c2b044f9ee1fd0fd7ead2a04e4883d57bc0574" translate="yes" xml:space="preserve">
          <source>typeinfo.[]=</source>
          <target state="translated">typeinfo.[]=</target>
        </trans-unit>
        <trans-unit id="e7b1fff7007b635892a8f2c7c17f4fabc7aa2f8c" translate="yes" xml:space="preserve">
          <source>types</source>
          <target state="translated">types</target>
        </trans-unit>
        <trans-unit id="2d82506526223a138c21adaa304939f0e5c6d071" translate="yes" xml:space="preserve">
          <source>typetraits</source>
          <target state="translated">typetraits</target>
        </trans-unit>
        <trans-unit id="60dd2602a3993657192b847bf527d3ea002515f9" translate="yes" xml:space="preserve">
          <source>typetraits.$</source>
          <target state="translated">typetraits.$</target>
        </trans-unit>
        <trans-unit id="a5e3a82c0e57ccb31cd2ee63e96e04620da85a7a" translate="yes" xml:space="preserve">
          <source>ucontext. No headers for these either. No coroutines for now :(</source>
          <target state="translated">유콘. 이것들에 대한 헤더도 없습니다. 지금은 코 루틴이 없습니다 :(</target>
        </trans-unit>
        <trans-unit id="fcdbc880c3d7454f7aed7a672c34ebc2395648a2" translate="yes" xml:space="preserve">
          <source>uint</source>
          <target state="translated">uint</target>
        </trans-unit>
        <trans-unit id="6ffb20caf93251ba7e5c57f747ba85d7f5bc1c05" translate="yes" xml:space="preserve">
          <source>uint16</source>
          <target state="translated">uint16</target>
        </trans-unit>
        <trans-unit id="39bb8ef60f1cf53f2971710d976ccbfd8e46507f" translate="yes" xml:space="preserve">
          <source>uint32</source>
          <target state="translated">uint32</target>
        </trans-unit>
        <trans-unit id="ac3546a307e951676887648a4a034b9af273c1fc" translate="yes" xml:space="preserve">
          <source>uint64</source>
          <target state="translated">uint64</target>
        </trans-unit>
        <trans-unit id="e0c0463b32fc07d8d003fd3d7c2aafeee72b97c5" translate="yes" xml:space="preserve">
          <source>uint8</source>
          <target state="translated">uint8</target>
        </trans-unit>
        <trans-unit id="50a9f71b59f7b08e445b040d344a27ba16d6e468" translate="yes" xml:space="preserve">
          <source>uintXX</source>
          <target state="translated">uintXX</target>
        </trans-unit>
        <trans-unit id="e469a767411564b5b9d650855b1bf91f83b48ac9" translate="yes" xml:space="preserve">
          <source>unary &lt;code&gt;&amp;lt;&lt;/code&gt; that can be used for nice looking excluding ranges:</source>
          <target state="translated">단항 &lt;code&gt;&amp;lt;&lt;/code&gt; 범위를 제외하고 멋진 모양으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6a68502fa6a81f54ad2657a48449eff3fba21a" translate="yes" xml:space="preserve">
          <source>unary &lt;span id=&quot;slice_2&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[default(int), b]&lt;/code&gt;</source>
          <target state="translated">구간을 구성하는 단항 &lt;span id=&quot;slice_2&quot;&gt;슬라이스&lt;/span&gt; 연산자 &lt;code&gt;[default(int), b]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65083481972c5966f46928501345684b9bbb47f9" translate="yes" xml:space="preserve">
          <source>undefine a conditional symbol</source>
          <target state="translated">조건부 기호 정의</target>
        </trans-unit>
        <trans-unit id="f4e92031e68b30d29e2170e5f1aad9277f7807fa" translate="yes" xml:space="preserve">
          <source>unequals operator. This is a shorthand for &lt;code&gt;not (x == y)&lt;/code&gt;.</source>
          <target state="translated">연산자가 다릅니다. &lt;code&gt;not (x == y)&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="1d1e8914a3d46b4097dec7a7370a1cc102848137" translate="yes" xml:space="preserve">
          <source>unicode</source>
          <target state="translated">unicode</target>
        </trans-unit>
        <trans-unit id="503618d3b6fcd17029e7b41380db0b02837b850e" translate="yes" xml:space="preserve">
          <source>unicode.$</source>
          <target state="translated">unicode.$</target>
        </trans-unit>
        <trans-unit id="56252afe1230fbed22f4cf6f5b18c063f302992c" translate="yes" xml:space="preserve">
          <source>unicode.==</source>
          <target state="translated">unicode.==</target>
        </trans-unit>
        <trans-unit id="ba274afb58038b59b5fbafadb53196ee58564c34" translate="yes" xml:space="preserve">
          <source>unicode.Rune</source>
          <target state="translated">unicode.Rune</target>
        </trans-unit>
        <trans-unit id="6c52ef7ac6b05c18cfe8138a21e48574f5b10ae7" translate="yes" xml:space="preserve">
          <source>unicode.utf8</source>
          <target state="translated">unicode.utf8</target>
        </trans-unit>
        <trans-unit id="2bb4a41fcac214de6bc522587f14f73fae1500e7" translate="yes" xml:space="preserve">
          <source>union of two sets</source>
          <target state="translated">두 세트의 조합</target>
        </trans-unit>
        <trans-unit id="94e060874450b5ea724bb6ce5ca7be4f6a73416b" translate="yes" xml:space="preserve">
          <source>unittest</source>
          <target state="translated">unittest</target>
        </trans-unit>
        <trans-unit id="82120c8043e20e4f9106e4df9e3b4561f0329e81" translate="yes" xml:space="preserve">
          <source>unloads the library &lt;em&gt;lib&lt;/em&gt;</source>
          <target state="translated">라이브러리 언로드 &lt;em&gt;lib 디렉토리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2f1abd40d25cbbdaac72e7d61edf25744d885ae" translate="yes" xml:space="preserve">
          <source>unmaps the memory region &lt;code&gt;(p, &amp;lt;p+size)&lt;/code&gt; of the mapped file &lt;em&gt;f&lt;/em&gt;. All changes are written back to the file system, if &lt;em&gt;f&lt;/em&gt; was opened with write access.</source>
          <target state="translated">매핑 된 파일 &lt;em&gt;f&lt;/em&gt; 의 메모리 영역 &lt;code&gt;(p, &amp;lt;p+size)&lt;/code&gt; 을 매핑 해제합니다 . &lt;em&gt;f&lt;/em&gt; 가 쓰기 액세스로 열린 경우 모든 변경 사항이 파일 시스템에 다시 기록됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1401c550faf76a557d42f8d1f211ee78051734d1" translate="yes" xml:space="preserve">
          <source>unroll pragma</source>
          <target state="translated">프라그 마를 풀다</target>
        </trans-unit>
        <trans-unit id="4fb3922b7aa387738d8d5c16be9b1bd717112d36" translate="yes" xml:space="preserve">
          <source>unsigned 16 bit integer type</source>
          <target state="translated">부호없는 16 비트 정수 유형</target>
        </trans-unit>
        <trans-unit id="e3c488b568efe1647a4f2268bb023715ca337c55" translate="yes" xml:space="preserve">
          <source>unsigned 32 bit integer type</source>
          <target state="translated">부호없는 32 비트 정수 유형</target>
        </trans-unit>
        <trans-unit id="c167607e8e35223b59d51cbe950f67de50276f79" translate="yes" xml:space="preserve">
          <source>unsigned 64 bit integer type</source>
          <target state="translated">부호없는 64 비트 정수 유형</target>
        </trans-unit>
        <trans-unit id="f86cf449f28d09a4bc97db5ff99179b6f2d75822" translate="yes" xml:space="preserve">
          <source>unsigned 8 bit integer type</source>
          <target state="translated">부호없는 8 비트 정수 유형</target>
        </trans-unit>
        <trans-unit id="a26ae2d11b536e6ca5e5bd3cffc3603fd87dcae8" translate="yes" xml:space="preserve">
          <source>unsigned default integer type</source>
          <target state="translated">부호없는 기본 정수 유형</target>
        </trans-unit>
        <trans-unit id="c6a1c50fd03a763801014ba748a79a98fcd2a082" translate="yes" xml:space="preserve">
          <source>unsigned integer addition</source>
          <target state="translated">부호없는 정수 덧셈</target>
        </trans-unit>
        <trans-unit id="16f71369380a5dcf72d25f6ab9ed47b372d8b828" translate="yes" xml:space="preserve">
          <source>unsigned integer arithmetic</source>
          <target state="translated">부호없는 정수 산술</target>
        </trans-unit>
        <trans-unit id="68294b44ced422c9e53b8978341a9fed2b11e610" translate="yes" xml:space="preserve">
          <source>unsigned integer division</source>
          <target state="translated">부호없는 정수 나누기</target>
        </trans-unit>
        <trans-unit id="6aa06816bf3f9591f49ebec9de15afd317482977" translate="yes" xml:space="preserve">
          <source>unsigned integer modulo operation</source>
          <target state="translated">부호없는 정수 모듈로 연산</target>
        </trans-unit>
        <trans-unit id="2d39f06bbaa9551f731729c652d08ef2fd499f4c" translate="yes" xml:space="preserve">
          <source>unsigned integer multiplication</source>
          <target state="translated">부호없는 정수 곱셈</target>
        </trans-unit>
        <trans-unit id="113fc75b9c0c29b0bbb4bd48cd711261898ddf56" translate="yes" xml:space="preserve">
          <source>unsigned integer subtraction</source>
          <target state="translated">부호없는 정수 빼기</target>
        </trans-unit>
        <trans-unit id="31b56e5671409449f1668addf6277c6371be5c85" translate="yes" xml:space="preserve">
          <source>untyped base class for 'FlowVar[T]'</source>
          <target state="translated">'FlowVar [T]'에 대한 형식화되지 않은 기본 클래스</target>
        </trans-unit>
        <trans-unit id="4f1a611d26640457ac7826ce4e2efa600b6a0754" translate="yes" xml:space="preserve">
          <source>updates the MD5Context with the &lt;em&gt;input&lt;/em&gt; data of length &lt;em&gt;len&lt;/em&gt;</source>
          <target state="translated">길이 &lt;em&gt;len&lt;/em&gt; 의 &lt;em&gt;입력&lt;/em&gt; 데이터로 MD5Context를 업데이트합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c6d680f5c570ba21d22697cd028f230e9f4cd56" translate="yes" xml:space="preserve">
          <source>uri</source>
          <target state="translated">uri</target>
        </trans-unit>
        <trans-unit id="b2188175ea2a546be2c4765879802adaeec9aa4b" translate="yes" xml:space="preserve">
          <source>uri.$</source>
          <target state="translated">uri.$</target>
        </trans-unit>
        <trans-unit id="dea942e6be579f3a24f7475b2a6c42c83ec4fd95" translate="yes" xml:space="preserve">
          <source>uri./</source>
          <target state="translated">uri./</target>
        </trans-unit>
        <trans-unit id="747166929141ba532113afeb0bba5a66a7a135b0" translate="yes" xml:space="preserve">
          <source>uri.Uri</source>
          <target state="translated">uri.Uri</target>
        </trans-unit>
        <trans-unit id="fe40f87f21237477fe9c4e3e41a5baa516a2669d" translate="yes" xml:space="preserve">
          <source>uri.Url</source>
          <target state="translated">uri.Url</target>
        </trans-unit>
        <trans-unit id="88888b68d43872d087352b736ea2139236d61c3f" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;X = parseInt(arg[1])&lt;/code&gt; to determine which branch to use. If &lt;code&gt;X == 0&lt;/code&gt; the 'zero' branch is selected, if &lt;code&gt;X == 1&lt;/code&gt; the 'one' branch is selected, etc. Otherwise the 'def' branch is selected. &lt;code&gt;$x&lt;/code&gt; is interpreted in branches too. If a branch needs to contain &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; put them in single quotes. To produce a verbatim single quote, use &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">사용할 분기를 결정 하려면 &lt;code&gt;X = parseInt(arg[1])&lt;/code&gt; 를 사용하십시오. 경우 &lt;code&gt;X == 0&lt;/code&gt; 경우 '제로'분기가 선택되고, &lt;code&gt;X == 1&lt;/code&gt; '하나'분기가 선택되고 그렇지 않으면 'DEF'분기가 선택되는 등등. &lt;code&gt;$x&lt;/code&gt; 도 지점에서 해석됩니다. 분기에 포함해야하는 경우 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;]&lt;/code&gt; 작은 따옴표로 묶습니다. 완전 작은 따옴표를 생성하려면 &lt;code&gt;''&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e10422c3b84dbb6a6385cec763d1aaf3cbcefb19" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;add&lt;/code&gt; instead of &lt;code&gt;append&lt;/code&gt;</source>
          <target state="translated">사용은 &lt;code&gt;add&lt;/code&gt; 대신 &lt;code&gt;append&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d19d4e2993224cc29c2afc0fd9590f794b7ed34" translate="yes" xml:space="preserve">
          <source>use all arguments</source>
          <target state="translated">모든 논증을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d6541a10eede8f222405cc42d3cf6b5cfd5b7758" translate="yes" xml:space="preserve">
          <source>use all arguments (same as &lt;code&gt;${..}&lt;/code&gt;)</source>
          <target state="translated">모든 인수를 사용하십시오 ( &lt;code&gt;${..}&lt;/code&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="7609e3818920569b8c889ddf167ff6e9f767f5cc" translate="yes" xml:space="preserve">
          <source>use all arguments except the last argument</source>
          <target state="translated">마지막 인수를 제외한 모든 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b173f37b52cb1060085a79c2d0a1338159a78d54" translate="yes" xml:space="preserve">
          <source>use all arguments, join them with ','. Insert '\n' after every 8th item.</source>
          <target state="translated">모든 인수를 사용하고 ','로 결합하십시오. 8 번째 항목마다 '\ n'을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="0decaa9761ac88dfe134634b637b3946ae21986c" translate="yes" xml:space="preserve">
          <source>use all arguments, join them with ','. Insert '\n' before the resulting string exceeds 80 chars.</source>
          <target state="translated">모든 인수를 사용하고 ','로 결합하십시오. 결과 문자열이 80자를 초과하기 전에 '\ n'을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="e45bfb85ab40525ba50db1d972d8e6fe1f552337" translate="yes" xml:space="preserve">
          <source>use all remaining arguments</source>
          <target state="translated">나머지 모든 인수를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="adf9dca173039b3b2b235b0a2fae4d19791a9f19" translate="yes" xml:space="preserve">
          <source>use argument X where &lt;code&gt;X = parseInt(arg[1])&lt;/code&gt;</source>
          <target state="translated">인수 X를 사용하십시오. 여기서 &lt;code&gt;X = parseInt(arg[1])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddd48686f41b6936d3a313cf0707fccddb25038d" translate="yes" xml:space="preserve">
          <source>use arguments 1 to 3</source>
          <target state="translated">인수 1 ~ 3 사용</target>
        </trans-unit>
        <trans-unit id="a90c4d71a55fda400a412abb5ca98afc0a40f3b1" translate="yes" xml:space="preserve">
          <source>use arguments 1 to 3 and join them with ','</source>
          <target state="translated">인수 1 ~ 3을 사용하고 ','</target>
        </trans-unit>
        <trans-unit id="00ac3b5bcc98e06e930251cdcd143bf8bb8418be" translate="yes" xml:space="preserve">
          <source>use arguments 1 to 3 with a leading space if the concatenation of &lt;code&gt;1..3&lt;/code&gt; is not the empty string</source>
          <target state="translated">&lt;code&gt;1..3&lt;/code&gt; 의 연결 이 빈 문자열이 아닌 경우 선행 공백으로 인수 1-3을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2366473b1ac23a18331826eedba67eee883e3842" translate="yes" xml:space="preserve">
          <source>use arguments X to Y where &lt;code&gt;X = parseInt(arg[1])&lt;/code&gt; and &lt;code&gt;Y = parseInt(arg[2])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X = parseInt(arg[1])&lt;/code&gt; 이고 &lt;code&gt;Y = parseInt(arg[2])&lt;/code&gt; 경우 X에서 Y 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c3310ee0e6658938bd6e8f1fe2b042937cc8c32e" translate="yes" xml:space="preserve">
          <source>use default exception handling with C++ backend</source>
          <target state="translated">C ++ 백엔드와 함께 기본 예외 처리 사용</target>
        </trans-unit>
        <trans-unit id="46cfa6c85539a4631a467606c5c007ae31d5d96e" translate="yes" xml:space="preserve">
          <source>use first argument</source>
          <target state="translated">첫 번째 주장을 사용하다</target>
        </trans-unit>
        <trans-unit id="c57248b4da1c7c2c89dc53053bcfd294a3c76825" translate="yes" xml:space="preserve">
          <source>use first or next argument</source>
          <target state="translated">첫 번째 또는 다음 인수 사용</target>
        </trans-unit>
        <trans-unit id="ce2d7e63dc835de9d053aa23e035bbf3fb793a3b" translate="yes" xml:space="preserve">
          <source>use last argument</source>
          <target state="translated">마지막 논증을 사용하다</target>
        </trans-unit>
        <trans-unit id="84ef05a9b852055fef257b7db2366dbe6f39b98c" translate="yes" xml:space="preserve">
          <source>use named argument, you can wrap the named argument in curly braces (eg. &lt;code&gt;${name}&lt;/code&gt;) to separate it from the next characters.</source>
          <target state="translated">명명 된 인수를 사용하면 명명 된 인수를 중괄호 (예 : &lt;code&gt;${name}&lt;/code&gt; )로 묶어 다음 문자와 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="76d2597379d81e8f3abf7c6bbdeb0db592f83408" translate="yes" xml:space="preserve">
          <source>use native debugger (gdb) | ENDB (experimental)</source>
          <target state="translated">기본 디버거 (gdb) 사용 | ENDB (실험)</target>
        </trans-unit>
        <trans-unit id="d9867d42e08abc61a1b482ff6720c1db15af2f82" translate="yes" xml:space="preserve">
          <source>use the provided namespace for the generated C++ code, if no namespace is provided &quot;Nim&quot; will be used</source>
          <target state="translated">네임 스페이스가 제공되지 않은 경우 생성 된 C ++ 코드에 제공된 네임 스페이스를 사용하십시오. &quot;Nim&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c118b1cbeb1fe466931724b2e21942fb2327466d" translate="yes" xml:space="preserve">
          <source>use this instead of &lt;em&gt;=&lt;/em&gt; for a &lt;span id=&quot;shallow-copy_1&quot;&gt;shallow copy&lt;/span&gt;. The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.</source>
          <target state="translated">이 대신에 사용 &lt;em&gt;=을&lt;/em&gt; A에 대한 &lt;span id=&quot;shallow-copy_1&quot;&gt;얕은 복사&lt;/span&gt; . 얕은 사본은 시퀀스와 문자열 (및 그것들을 포함하는 유형)의 의미 만 변경합니다. 그래도 변경된 의미에주의하십시오! 기본 할당이 시퀀스 및 문자열의 딥 카피를 수행하는 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9674c457f7896d00df05d48c2f25af116179718" translate="yes" xml:space="preserve">
          <source>use this procedure to define a new XML tag</source>
          <target state="translated">이 절차를 사용하여 새 XML 태그를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="449a2b2ec92f41eec3d92a669b82d574e80e2716" translate="yes" xml:space="preserve">
          <source>use this type to declare string tables</source>
          <target state="translated">이 유형을 사용하여 문자열 테이블을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="4bcf7f9c585e4a96ac15f6860f9f5fd98e93b9f2" translate="yes" xml:space="preserve">
          <source>used pragma</source>
          <target state="translated">중고 프라 그마</target>
        </trans-unit>
        <trans-unit id="c3f7a8dbd542b879e3f0fcb1804ce6c25fb8948d" translate="yes" xml:space="preserve">
          <source>uses &lt;em&gt;fn&lt;/em&gt; to mix the colors &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. &lt;em&gt;fn&lt;/em&gt; is invoked for each component R, G, and B. This is a template because &lt;em&gt;fn&lt;/em&gt; should be inlined and the compiler cannot inline proc pointers yet. If &lt;em&gt;fn&lt;/em&gt;'s result is not in the range[0..255], it will be saturated to be so.</source>
          <target state="translated">&lt;em&gt;fn&lt;/em&gt; 을 사용 하여 색상 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 를 혼합합니다 . &lt;em&gt;fn&lt;/em&gt; 은 각 구성 요소 R, G 및 B에 대해 호출됩니다. 이는 &lt;em&gt;fn&lt;/em&gt; 이 인라인되어야하고 컴파일러가 아직 proc 포인터를 인라인 할 수 없기 때문에 템플리트 입니다. 경우 &lt;em&gt;FN&lt;/em&gt; 의 결과가 범위 [0..255] 아닌, 그렇게로 포화 될 것이다.</target>
        </trans-unit>
        <trans-unit id="7795f41a54a250368f19281b09958e0772f51136" translate="yes" xml:space="preserve">
          <source>val is preferred, inconsistent right now</source>
          <target state="translated">val이 선호되고 일관성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b901d69f20780be5e9b5f7af75416ae699c067c" translate="yes" xml:space="preserve">
          <source>validates data; raises &lt;em&gt;ECgi&lt;/em&gt; if this fails. This checks that each variable name of the CGI &lt;em&gt;data&lt;/em&gt; occurs in the &lt;em&gt;validKeys&lt;/em&gt; array.</source>
          <target state="translated">데이터를 검증합니다. 이것이 실패 하면 &lt;em&gt;ECgi를&lt;/em&gt; 올립니다 . CGI &lt;em&gt;데이터&lt;/em&gt; 의 각 변수 이름이 &lt;em&gt;validKeys&lt;/em&gt; 배열 에서 발생 &lt;em&gt;하는지 확인&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="dd6b95462d5144c3542c37580f6abfff0e062a75" translate="yes" xml:space="preserve">
          <source>value, val</source>
          <target state="translated">가치, 발</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="b46d0172433dd6895dac7544b9dacbb87b361e9f" translate="yes" xml:space="preserve">
          <source>variable</source>
          <target state="translated">variable</target>
        </trans-unit>
        <trans-unit id="e596b996f92d68200dc2e4a9011b6707b07b0ea0" translate="yes" xml:space="preserve">
          <source>variance</source>
          <target state="translated">variance</target>
        </trans-unit>
        <trans-unit id="dc90dd309c0924fe35459cd1ab25434c95b4aca5" translate="yes" xml:space="preserve">
          <source>varianceS (sample var)</source>
          <target state="translated">분산 (샘플 var)</target>
        </trans-unit>
        <trans-unit id="9a8f2f67905e73a4e28f01b4237c96e39f22331a" translate="yes" xml:space="preserve">
          <source>variant of select with a read list only</source>
          <target state="translated">읽기 목록 만있는 select의 변형</target>
        </trans-unit>
        <trans-unit id="acc96cf6ee8d9f53dc75abf2ec57b44cd8910859" translate="yes" xml:space="preserve">
          <source>waits for every thread in &lt;em&gt;t&lt;/em&gt; to finish.</source>
          <target state="translated">&lt;em&gt;t의&lt;/em&gt; 모든 스레드 가 완료 될 때까지 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="f2faac1e783c3cd87f996dd074f1b2ac5eb5cee8" translate="yes" xml:space="preserve">
          <source>waits for the process to finish and returns &lt;em&gt;p&lt;/em&gt;'s error code.</source>
          <target state="translated">프로세스가 완료 될 때까지 대기하고 &lt;em&gt;p&lt;/em&gt; 의 오류 코드를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f03359bfd5827973c8b92d037082ea764d9ac8e5" translate="yes" xml:space="preserve">
          <source>waits for the thread &lt;em&gt;t&lt;/em&gt; to finish.</source>
          <target state="translated">스레드 &lt;em&gt;t&lt;/em&gt; 가 끝나기를 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="1cced6bc1dde56be66e9caf848a09cab50b85c11" translate="yes" xml:space="preserve">
          <source>waits on the condition variable &lt;em&gt;cond&lt;/em&gt;.</source>
          <target state="translated">조건 변수 &lt;em&gt;cond를&lt;/em&gt; 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="0a608f47c9f7e8e04ef837e13cea1e0768ba02e5" translate="yes" xml:space="preserve">
          <source>waits until the value for the flowVar arrives. Usually it is not necessary to call this explicitly.</source>
          <target state="translated">flowVar 값이 도착할 때까지 기다립니다. 일반적으로 이것을 명시 적으로 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="91c6a162ab071b58481085fab3b4ab884b6d597e" translate="yes" xml:space="preserve">
          <source>walks over the directory &lt;em&gt;dir&lt;/em&gt; and yields for each directory or file in &lt;em&gt;dir&lt;/em&gt;. The component type and full path for each item is returned. Walking is not recursive. If &lt;code&gt;relative&lt;/code&gt; is true the resulting path is shortened to be relative to &lt;code&gt;dir&lt;/code&gt;. Example: This directory structure:</source>
          <target state="translated">디렉토리를 통해 산책 &lt;em&gt;디렉토리&lt;/em&gt; 에있는 각 디렉토리 또는 파일 및 수율 &lt;em&gt;디렉토리&lt;/em&gt; . 각 항목의 구성 요소 유형 및 전체 경로가 리턴됩니다. 걷기는 재귀 적이 지 않습니다. 경우 &lt;code&gt;relative&lt;/code&gt; 사실이다 결과 경로에 상대적으로 짧아 &lt;code&gt;dir&lt;/code&gt; . 예 :이 디렉토리 구조 :</target>
        </trans-unit>
        <trans-unit id="2321fe2a75f2da76448a8a5cc23615671f113634" translate="yes" xml:space="preserve">
          <source>warning pragma</source>
          <target state="translated">경고 pragma</target>
        </trans-unit>
        <trans-unit id="bd207fab08951eb6cee30e4969e79ca50d1f7c65" translate="yes" xml:space="preserve">
          <source>warnings</source>
          <target state="translated">warnings</target>
        </trans-unit>
        <trans-unit id="b66c4fd2c24f8163559e61667097cdc84e060cfa" translate="yes" xml:space="preserve">
          <source>we need to cache current threadId to not perform syscall all the time</source>
          <target state="translated">항상 syscall을 수행하지 않으려면 현재 threadId를 캐시해야합니다</target>
        </trans-unit>
        <trans-unit id="a8a2fd4f9541df534d203455e2de4b38da761cd1" translate="yes" xml:space="preserve">
          <source>web command</source>
          <target state="translated">웹 명령</target>
        </trans-unit>
        <trans-unit id="6cec29adc7cde62c433f88a777ff8263103b71cf" translate="yes" xml:space="preserve">
          <source>website of Nim; generated by &lt;code&gt;nimweb&lt;/code&gt; from the &lt;code&gt;*.txt&lt;/code&gt; and &lt;code&gt;*.tmpl&lt;/code&gt; files</source>
          <target state="translated">님의 웹 사이트; &lt;code&gt;*.txt&lt;/code&gt; 및 &lt;code&gt;*.tmpl&lt;/code&gt; 파일 에서 &lt;code&gt;nimweb&lt;/code&gt; 에 의해 생성</target>
        </trans-unit>
        <trans-unit id="c3bf045f89a694aaa2789a2534343365e443d9c5" translate="yes" xml:space="preserve">
          <source>what kind of &lt;code&gt;any&lt;/code&gt; it is</source>
          <target state="translated">어떤 종류의 &lt;code&gt;any&lt;/code&gt; 그것이</target>
        </trans-unit>
        <trans-unit id="acd6882f2ade352d6d220c23c08fdda10b5e5f21" translate="yes" xml:space="preserve">
          <source>what to do in case of an error</source>
          <target state="translated">오류 발생시해야 할 일</target>
        </trans-unit>
        <trans-unit id="c5fb20379915db7e8753adef13923f7c82add6f5" translate="yes" xml:space="preserve">
          <source>when turned on, accessing the zero terminator in strings is allowed; only for backwards compatibility</source>
          <target state="translated">켜면 문자열에서 제로 터미네이터에 액세스하는 것이 허용됩니다. 이전 버전과의 호환성을 위해서만</target>
        </trans-unit>
        <trans-unit id="3902d11445c87520bff59b3c2343e9a0e97db17f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;b[0..^1]&lt;/code&gt; is equivalent to &lt;code&gt;b[0..b.len-1]&lt;/code&gt; and &lt;code&gt;b[0..&amp;lt;b.len]&lt;/code&gt;, and it can be seen that the &lt;code&gt;^1&lt;/code&gt; provides a short-hand way of specifying the &lt;code&gt;b.len-1&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;b[0..^1]&lt;/code&gt; 은 &lt;code&gt;b[0..b.len-1]&lt;/code&gt; 및 &lt;code&gt;b[0..&amp;lt;b.len]&lt;/code&gt; 과 동일하며 &lt;code&gt;^1&lt;/code&gt; 은 짧은 방법을 제공함 을 알 수 있습니다. 시방의 &lt;code&gt;b.len-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ddd930f0de52bf103df0c3a15cb7f76e0add0aa" translate="yes" xml:space="preserve">
          <source>which document type to generate</source>
          <target state="translated">생성 할 문서 유형</target>
        </trans-unit>
        <trans-unit id="83aedd221dbb03cd848f5241744eb2db0cb001d6" translate="yes" xml:space="preserve">
          <source>which may otherwise confuse the c2nim parser.</source>
          <target state="translated">그렇지 않으면 c2nim 파서를 혼동시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4edde1176fb10f2e34b73dc187ed1ec87cc8fc25" translate="yes" xml:space="preserve">
          <source>will actually dump &lt;em&gt;x + y&lt;/em&gt;, but at the same time will print at compile time the expansion of the &lt;code&gt;dump&lt;/code&gt; macro, which in this case is &lt;code&gt;debugEcho [&quot;x + y&quot;, &quot; = &quot;, x + y]&lt;/code&gt;.</source>
          <target state="translated">실제로 &lt;em&gt;x + y를&lt;/em&gt; 덤프 하지만 동시에 컴파일 매크로 에서 &lt;code&gt;dump&lt;/code&gt; 매크로 의 확장을 인쇄합니다. 이 경우 &lt;code&gt;debugEcho [&quot;x + y&quot;, &quot; = &quot;, x + y]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc2d35f3fefee92931df69cf03019e6316ae4b5c" translate="yes" xml:space="preserve">
          <source>will generate this C code:</source>
          <target state="translated">이 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2d28b118c55b9db39a3b0f09569b3e4ed6e02f41" translate="yes" xml:space="preserve">
          <source>will generate this code:</source>
          <target state="translated">이 코드를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="420cf24972ade49d8fb295422f193d9f5094fb94" translate="yes" xml:space="preserve">
          <source>will print &lt;code&gt;x + y = 30&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x + y = 30&lt;/code&gt; 을 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="e0e1b21866cc2cb31a565ac4ac83c4be863e3d7b" translate="yes" xml:space="preserve">
          <source>winlean</source>
          <target state="translated">winlean</target>
        </trans-unit>
        <trans-unit id="0b5b960bb73142d0685d7917492b44c8f68e4d31" translate="yes" xml:space="preserve">
          <source>winlean.==</source>
          <target state="translated">winlean.==</target>
        </trans-unit>
        <trans-unit id="7b212f025fa6a783d31977faecf9131ecdd96a93" translate="yes" xml:space="preserve">
          <source>winlean.GUID</source>
          <target state="translated">winlean.GUID</target>
        </trans-unit>
        <trans-unit id="a0b55fe3245923432b48c11761c2e8adf820ec4d" translate="yes" xml:space="preserve">
          <source>winlean.HDC</source>
          <target state="translated">winlean.HDC</target>
        </trans-unit>
        <trans-unit id="496b016d48416c05dbaa91608baa9ed2158ab7d3" translate="yes" xml:space="preserve">
          <source>winlean.LONG</source>
          <target state="translated">winlean.LONG</target>
        </trans-unit>
        <trans-unit id="78ff5e2e70dfcfe9c24f6a0fc0e6f147ab8cfcb6" translate="yes" xml:space="preserve">
          <source>with 'getType' you can access the node's &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call &lt;em&gt;typeKind&lt;/em&gt; on getType's result.</source>
          <target state="translated">'getType'을 사용하면 노드의 &lt;span id=&quot;type_1&quot;&gt;type에&lt;/span&gt; 액세스 할 수 있습니다 . Nim 유형도 Nim AST에 매핑되므로 약간 혼란 스럽지만 동일한 API를 사용하여 유형을 탐색 할 수 있습니다. 재귀 유형은 평면화되므로 순회 중에 무한 재귀의 위험이 없습니다. 재귀 유형을 해결하려면 'getType'을 다시 호출해야합니다. 어떤 유형인지 확인하려면 getType 결과에서 &lt;em&gt;typeKind&lt;/em&gt; 를 호출 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0626af1802da304785bb81bc8065b951e6cc7bde" translate="yes" xml:space="preserve">
          <source>with this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If &lt;code&gt;globalRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="translated">이 후크를 사용하면 전역 수준에서 예외 처리에 영향을 줄 수 있습니다. nil이 아니라면, 모든 'raise'문은이 후크를 호출하게됩니다. 일반적인 응용 프로그램 코드는이 후크를 설정하지 않아야합니다! 이것을 설정할 때 무엇을하는지 더 잘 알 수 있습니다. 경우 &lt;code&gt;globalRaiseHook&lt;/code&gt; 는 false를 돌려줍니다 예외가 잡힌하고 호출 스택을 통해 더 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f171269ed122230ecda6c92327a726fdd508f259" translate="yes" xml:space="preserve">
          <source>with this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If &lt;code&gt;localRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="translated">이 후크를 사용하면 스레드 로컬 레벨에서 예외 처리에 영향을 줄 수 있습니다. nil이 아니라면, 모든 'raise'문은이 후크를 호출하게됩니다. 일반적인 응용 프로그램 코드는이 후크를 설정하지 않아야합니다! 이것을 설정할 때 수행하는 작업을 더 잘 알고 있습니다. 경우 &lt;code&gt;localRaiseHook&lt;/code&gt; 는 false를 돌려줍니다 예외가 잡힌하고 호출 스택을 통해 더 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d759de49949090271701f6ee7f496d7005c766a" translate="yes" xml:space="preserve">
          <source>writes a hint message at compile time</source>
          <target state="translated">컴파일 타임에 힌트 메시지를 쓴다</target>
        </trans-unit>
        <trans-unit id="55607cbc90ef967c59423056dfc5bc059e89e6b5" translate="yes" xml:space="preserve">
          <source>writes a rope to a file.</source>
          <target state="translated">파일에 로프를 씁니다.</target>
        </trans-unit>
        <trans-unit id="73c195c32ce6231f5f9524c41f5eab4dc571dd81" translate="yes" xml:space="preserve">
          <source>writes a rope to a stream.</source>
          <target state="translated">스트림에 로프를 씁니다.</target>
        </trans-unit>
        <trans-unit id="11de4af19a3070bb3085ef887c16df21670e1476" translate="yes" xml:space="preserve">
          <source>writes a warning message at compile time</source>
          <target state="translated">컴파일 타임에 경고 메시지를 씁니다.</target>
        </trans-unit>
        <trans-unit id="a9ff5e846a4546d0392b1848ba700412ecdee030" translate="yes" xml:space="preserve">
          <source>writes an error message at compile time</source>
          <target state="translated">컴파일 타임에 오류 메시지를 씁니다.</target>
        </trans-unit>
        <trans-unit id="649e2e963c823353901a16f81ff3e7280d16482b" translate="yes" xml:space="preserve">
          <source>writes one or more strings to the the stream &lt;em&gt;s&lt;/em&gt; followed by a new line. No length field or terminating zero is written.</source>
          <target state="translated">하여 스트림에 하나 이상의 문자열 기록 &lt;em&gt;의&lt;/em&gt; 새로운 라인으로 다음을. 길이 필드 나 종료 0이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f7f47bdfae9e6b7ea4a4eada91f91e879bf56c5" translate="yes" xml:space="preserve">
          <source>writes one or more strings to the the stream. No length fields or terminating zeros are written.</source>
          <target state="translated">하나 이상의 문자열을 스트림에 씁니다. 길이 필드 나 종료 0은 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="780a14af38f25752fb4b72d58d577e9c249f7005" translate="yes" xml:space="preserve">
          <source>writes the bytes of &lt;code&gt;a[start..start+len-1]&lt;/code&gt; to the file &lt;em&gt;f&lt;/em&gt;. Returns the number of actual written bytes, which may be less than &lt;em&gt;len&lt;/em&gt; in case of an error.</source>
          <target state="translated">&lt;code&gt;a[start..start+len-1]&lt;/code&gt; 의 바이트를 파일 &lt;em&gt;f에&lt;/em&gt; 씁니다 . 실제 기록 된 바이트 수를 리턴합니다 ( 오류의 경우 &lt;em&gt;len&lt;/em&gt; 보다 작을 수 있음) .</target>
        </trans-unit>
        <trans-unit id="1e666fcb61a6a79f93e04c08ee815844239c796a" translate="yes" xml:space="preserve">
          <source>writes the bytes of buffer pointed to by the parameter &lt;em&gt;buffer&lt;/em&gt; to the file &lt;em&gt;f&lt;/em&gt;. Returns the number of actual written bytes, which may be less than &lt;em&gt;len&lt;/em&gt; in case of an error.</source>
          <target state="translated">매개 변수 &lt;em&gt;버퍼&lt;/em&gt; 가 가리키는 버퍼의 바이트를 파일 &lt;em&gt;f에&lt;/em&gt; 씁니다 . 실제 기록 된 바이트 수를 리턴합니다 ( 오류의 경우 &lt;em&gt;len&lt;/em&gt; 보다 작을 수 있음) .</target>
        </trans-unit>
        <trans-unit id="ef6ce703f69d15b36a588f7263d17120505d53ee" translate="yes" xml:space="preserve">
          <source>writes the current stack trace to &lt;code&gt;stderr&lt;/code&gt;. This is only works for debug builds. Since it's usually used for debugging, this is proclaimed to have no IO effect!</source>
          <target state="translated">현재 스택 추적을 &lt;code&gt;stderr&lt;/code&gt; 에 씁니다 . 이것은 디버그 빌드에서만 작동합니다. 일반적으로 디버깅에 사용되므로 IO 효과가 없다고 선언됩니다!</target>
        </trans-unit>
        <trans-unit id="292f89820ccf79f329aa52604146e97f37252b7b" translate="yes" xml:space="preserve">
          <source>writes the string &lt;em&gt;x&lt;/em&gt; to the the stream &lt;em&gt;s&lt;/em&gt;. No length field or terminating zero is written.</source>
          <target state="translated">문자열 &lt;em&gt;x&lt;/em&gt; 를 스트림 &lt;em&gt;s에&lt;/em&gt; 씁니다 . 길이 필드 나 종료 0이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83e4e7a360989802d6b417849d6cb6743474afe" translate="yes" xml:space="preserve">
          <source>writes the values &lt;em&gt;x&lt;/em&gt; to &lt;em&gt;f&lt;/em&gt; and then writes &quot;\n&quot;. May throw an IO exception.</source>
          <target state="translated">값 &lt;em&gt;x&lt;/em&gt; 에 &lt;em&gt;f&lt;/em&gt; 를 쓴 다음 &quot;\ n&quot;을 씁니다. IO 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="116200232578e6c30ace7bab2ec2d49674dc8086" translate="yes" xml:space="preserve">
          <source>xmldom</source>
          <target state="translated">xmldom</target>
        </trans-unit>
        <trans-unit id="2a2cf40b92257e4d4c727b85085d1751f01d023b" translate="yes" xml:space="preserve">
          <source>xmldom.$</source>
          <target state="translated">xmldom.$</target>
        </trans-unit>
        <trans-unit id="79734e5a718215e64fa8329c216e995ca822b777" translate="yes" xml:space="preserve">
          <source>xmldomparser</source>
          <target state="translated">xmldomparser</target>
        </trans-unit>
        <trans-unit id="49f491079de0babb63b75ad3ff1dbe8082e7ad85" translate="yes" xml:space="preserve">
          <source>xmlparser</source>
          <target state="translated">xmlparser</target>
        </trans-unit>
        <trans-unit id="bbb6e25cf9d25d81088f1836ad8ca92f573de5c6" translate="yes" xml:space="preserve">
          <source>xmltree</source>
          <target state="translated">xmltree</target>
        </trans-unit>
        <trans-unit id="c82bbdab8475f5ed776f8c131dbbce1af14ad441" translate="yes" xml:space="preserve">
          <source>xmltree.$</source>
          <target state="translated">xmltree.$</target>
        </trans-unit>
        <trans-unit id="2a891c27909183e451521fd371f2ea7fc5287bdf" translate="yes" xml:space="preserve">
          <source>xmltree.[]</source>
          <target state="translated">xmltree.[]</target>
        </trans-unit>
        <trans-unit id="eb6b77bbe1db0c750d9014fe325b85f6b398b4e1" translate="yes" xml:space="preserve">
          <source>yield real directories</source>
          <target state="translated">실제 디렉토리를 생성</target>
        </trans-unit>
        <trans-unit id="306ea1d4d3cbcd9bd556181d42ae3c927698dff8" translate="yes" xml:space="preserve">
          <source>yield real files</source>
          <target state="translated">실제 파일을 생성</target>
        </trans-unit>
        <trans-unit id="3843ef5c41ea8b85d0db1bb517abc9b3476b5af9" translate="yes" xml:space="preserve">
          <source>yield symbolic links to directories</source>
          <target state="translated">디렉토리에 대한 심볼릭 링크 생성</target>
        </trans-unit>
        <trans-unit id="b8266ac81a02a0809dd97904f2dd3c71dae43d5b" translate="yes" xml:space="preserve">
          <source>yield symbolic links to files</source>
          <target state="translated">파일에 대한 심볼릭 링크 생성</target>
        </trans-unit>
        <trans-unit id="81054b99bab6975a45ed79b7bf6b908649522136" translate="yes" xml:space="preserve">
          <source>yieldFilter</source>
          <target state="translated">yieldFilter</target>
        </trans-unit>
        <trans-unit id="f9402e0185194f69facdfe96d8e36aef8169c31b" translate="yes" xml:space="preserve">
          <source>yields all (key, value)-pairs of &lt;em&gt;c&lt;/em&gt; starting with &lt;em&gt;prefix&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;prefix로&lt;/em&gt; 시작하는 &lt;em&gt;c의&lt;/em&gt; 모든 (키, 값) 쌍을 생성 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3dedf7e2db6acc7e2d7dc7a5d9f268ea982a00ec" translate="yes" xml:space="preserve">
          <source>yields all (key, value)-pairs of &lt;em&gt;c&lt;/em&gt; starting with &lt;em&gt;prefix&lt;/em&gt;. The yielded values can be modified.</source>
          <target state="translated">&lt;em&gt;prefix로&lt;/em&gt; 시작하는 &lt;em&gt;c의&lt;/em&gt; 모든 (키, 값) 쌍을 생성 &lt;em&gt;합니다&lt;/em&gt; . 산출 된 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3b8d6cc7fd9db0977ce03c20645e81972093e1" translate="yes" xml:space="preserve">
          <source>yields all (key, value)-pairs of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;c의&lt;/em&gt; 모든 (키, 값) 쌍을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="96f8e8df1614c55b54beed39bfd38dae8946f591" translate="yes" xml:space="preserve">
          <source>yields all (key, value)-pairs of &lt;em&gt;c&lt;/em&gt;. The yielded values can be modified.</source>
          <target state="translated">&lt;em&gt;c의&lt;/em&gt; 모든 (키, 값) 쌍을 생성합니다 . 산출 된 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4348915622d7354795b4771bf0ad0d20c31c3b" translate="yes" xml:space="preserve">
          <source>yields all keys in lexicographical order.</source>
          <target state="translated">사전 순으로 모든 키를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8391c66f3fc526d1c2a433ac6b7530894e242863" translate="yes" xml:space="preserve">
          <source>yields all keys starting with &lt;em&gt;prefix&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;prefix로&lt;/em&gt; 시작하는 모든 키를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="4d0ea719e0a10b0fb3b8f520818ddf2e0447d81f" translate="yes" xml:space="preserve">
          <source>yields all keys starting with &lt;em&gt;prefix&lt;/em&gt;. If &lt;em&gt;longestMatch&lt;/em&gt; is true, the longest match is returned, it doesn't have to be a complete match then.</source>
          <target state="translated">&lt;em&gt;prefix로&lt;/em&gt; 시작하는 모든 키를 생성합니다 . 경우 &lt;em&gt;longestMatch이&lt;/em&gt; 가장 긴 일치가 반환됩니다, 사실, 그 다음 완전한 일치 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="660d3b4309118215a1f623e8535c7614326ae998" translate="yes" xml:space="preserve">
          <source>yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pattern&lt;/em&gt; 과 일치 하는 &lt;em&gt;s의&lt;/em&gt; 일치하는 모든 &lt;em&gt;하위 문자열&lt;/em&gt; 을 생성합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d236a364b48a74a6b587cda41408d3bbde017ee" translate="yes" xml:space="preserve">
          <source>yields all values of &lt;em&gt;c&lt;/em&gt; in the lexicographical order of the corresponding keys.</source>
          <target state="translated">&lt;em&gt;c의&lt;/em&gt; 모든 값을 해당 키의 사전 순으로 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="a5faf4b57a869b9e69f091c925206f77b326dd59" translate="yes" xml:space="preserve">
          <source>yields all values of &lt;em&gt;c&lt;/em&gt; in the lexicographical order of the corresponding keys. The values can be modified.</source>
          <target state="translated">&lt;em&gt;c의&lt;/em&gt; 모든 값을 해당 키의 사전 순으로 산출 합니다. 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61885cd11e8dd3d41792a6157f8d52bf931e9dd9" translate="yes" xml:space="preserve">
          <source>yields all values of &lt;em&gt;c&lt;/em&gt; starting with &lt;em&gt;prefix&lt;/em&gt; of the corresponding keys.</source>
          <target state="translated">해당 키의 &lt;em&gt;접두사&lt;/em&gt; 로 시작하는 &lt;em&gt;c의&lt;/em&gt; 모든 값을 생성 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a23a68389d39688319c40513392aae0adec2f72" translate="yes" xml:space="preserve">
          <source>yields all values of &lt;em&gt;c&lt;/em&gt; starting with &lt;em&gt;prefix&lt;/em&gt; of the corresponding keys. The values can be modified.</source>
          <target state="translated">해당 키의 &lt;em&gt;접두사&lt;/em&gt; 로 시작하는 &lt;em&gt;c의&lt;/em&gt; 모든 값을 생성 합니다. 값을 수정할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4b99cac4fd1dcaabb3b807abdd1bc949aa5c69" translate="yes" xml:space="preserve">
          <source>yields every value of &lt;em&gt;L&lt;/em&gt; so that you can modify it.</source>
          <target state="translated">&lt;em&gt;L의&lt;/em&gt; 모든 값을 산출 하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6362098518ba9bb596ee497f8306af7d749e862d" translate="yes" xml:space="preserve">
          <source>yields every value of &lt;em&gt;L&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;L의&lt;/em&gt; 모든 값을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="e6120c18db03d1a34568465cdc605a358bd3d16f" translate="yes" xml:space="preserve">
          <source>zero extends a smaller integer type to &lt;code&gt;int64&lt;/code&gt;. This treats &lt;em&gt;x&lt;/em&gt; as unsigned.</source>
          <target state="translated">0은 더 작은 정수 유형을 &lt;code&gt;int64&lt;/code&gt; 로 확장합니다 . 이것은 &lt;em&gt;x&lt;/em&gt; 를 부호없는 것으로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8c14dc4de826f7105be88a3c2fd1072e1c81bf" translate="yes" xml:space="preserve">
          <source>zero extends a smaller integer type to &lt;code&gt;int64&lt;/code&gt;. This treats &lt;em&gt;x&lt;/em&gt; as unsigned. Does nothing if the size of an &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;int64&lt;/code&gt;. (This is the case on 64 bit processors.)</source>
          <target state="translated">0은 더 작은 정수 유형을 &lt;code&gt;int64&lt;/code&gt; 로 확장합니다 . 이것은 &lt;em&gt;x&lt;/em&gt; 를 부호없는 것으로 취급합니다 . &lt;code&gt;int&lt;/code&gt; 의 크기가 &lt;code&gt;int64&lt;/code&gt; 와 동일한 경우 아무 작업도 수행하지 않습니다 . (64 비트 프로세서의 경우입니다.)</target>
        </trans-unit>
        <trans-unit id="350a19de2e715a5a961d2760ce444d68068a970c" translate="yes" xml:space="preserve">
          <source>zero extends a smaller integer type to &lt;code&gt;int&lt;/code&gt;. This treats &lt;em&gt;x&lt;/em&gt; as unsigned.</source>
          <target state="translated">0은 더 작은 정수 유형을 &lt;code&gt;int&lt;/code&gt; 로 확장합니다 . 이것은 &lt;em&gt;x&lt;/em&gt; 를 부호없는 것으로 취급합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
