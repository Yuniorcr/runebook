<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="translated">매크로를 호출하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="translated">매크로를 작성하는 방법에는 Nim 소스 코드 를 &lt;em&gt;생성&lt;/em&gt; 하고 컴파일러가 구문 분석하도록하거나 컴파일러에 공급하는 추상 구문 트리 (AST)를 수동으로 작성하는 두 가지 방법 이 있습니다. AST를 빌드하려면 Nim 콘크리트 구문이 추상 구문 트리 (AST)로 어떻게 변환되는지 알아야합니다. AST는 &lt;a href=&quot;macros&quot;&gt;매크로&lt;/a&gt; 모듈에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="translated">&lt;code&gt;elif&lt;/code&gt; 부분은 0 개 이상있을 수 있으며 &lt;code&gt;else&lt;/code&gt; 부분은 선택 사항입니다. 키워드 &lt;code&gt;elif&lt;/code&gt; 대한 짧은 &lt;code&gt;else if&lt;/code&gt; , 과도한 들여 쓰기를 방지하는 데 유용합니다. (는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 빈 문자열입니다. 그것은 어떤 문자가 포함되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="translated">정의 된 각 숫자 유형에 대한 리터럴이 있습니다. 아포스트로피 ( '' ')로 시작하는 접미 부를 &lt;span id=&quot;type-suffix_1&quot;&gt;유형 접미사&lt;/span&gt; 라고합니다 . 리터럴에 접미사가없는 리터럴은 리터럴에 점 또는 &lt;code&gt;E|e&lt;/code&gt; 가 포함되어 있지 않은 경우 정수 유형이며 정수 유형 은 &lt;code&gt;float&lt;/code&gt; 유형 입니다. 리터럴이 &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; 범위에 있으면 이 정수 유형은 &lt;code&gt;int&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;int64&lt;/code&gt; 입니다. 표기법의 편의상, 형식 접미사의 아포스트로피는 모호하지 않은 경우 선택 사항입니다 (접미사가있는 16 진 부동 소수점 리터럴 만 모호 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">루틴 호출을위한 구문 설탕이 있습니다. &lt;code&gt;method(obj, args)&lt;/code&gt; 대신 구문 &lt;code&gt;obj.method(args)&lt;/code&gt; 사용할 수 있습니다 . 나머지 인수가 없으면 괄호를 생략 할 수 있습니다 : &lt;code&gt;obj.len&lt;/code&gt; ( &lt;code&gt;len(obj)&lt;/code&gt; 대신 ).</target>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;counters[i].L&lt;/code&gt; 이 보호 된 위치 &lt;code&gt;counters[i].v&lt;/code&gt; 해당하는 잠금 인지 확인하는 분석이 있습니다. 이 분석은 &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt; 와 같은 위치에 대한 경로를 처리하므로 &lt;span id=&quot;path-analysis_1&quot;&gt;경로 분석&lt;/span&gt; 이라고 &lt;span id=&quot;path-analysis_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="translated">다른 고려 사항이 있습니다. Nim은 프로세스에 대해 유연한 유형 식별 기능을 가지고 있습니다. 비록 &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; 및 &lt;code&gt;proc(a, b: int)&lt;/code&gt; 코드에 동등의 AST는 후자 조금 다르다.</target>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="translated">주요 유형 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="translated">이러한 어설 션은 문자 클래스에 나타나지 않을 수 있습니다 (그러나 &lt;code&gt;\b&lt;/code&gt; 는 문자 클래스 내부에서 백 스페이스 문자와 다른 의미를 갖습니다).</target>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="translated">이러한 문자 유형 순서는 내부 및 외부 문자 클래스 모두에 나타날 수 있습니다. 이들은 각각 적절한 유형의 한 문자와 일치합니다. 현재 일치 지점이 제목 문자열의 끝에 있으면 일치하는 문자가 없기 때문에 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="translated">이 지시어는 c2nim에게 &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; 호출 규칙으로 모든 proc (또는 proc 유형)에 주석을 달아야한다고 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; 와 같은 선언 및 이러한 선언의 부울 조합에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="translated">이 정수 유형은 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="translated">이 키워드는 또한 연산자입니다. &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">이러한 일치 범주는 우선 순위를 갖습니다. 정확히 일치하는 것이 리터럴 일치보다 낫고 일반 일치보다 낫습니다. 다음 &lt;code&gt;count(p, m)&lt;/code&gt; 에서 루틴 &lt;code&gt;p&lt;/code&gt; 에 대한 일치 범주 &lt;code&gt;m&lt;/code&gt; 의 일치 횟수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="translated">이러한 작업은 다음 세트에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="translated">&lt;em&gt;오버로드&lt;/em&gt; 대신 이러한 작업을 &lt;em&gt;재정의&lt;/em&gt; 할 수 있습니다 . 이는 구현이 자동으로 구조화 된 유형으로 해제됨을 의미합니다. 입력하는 경우 예를 들어 &lt;code&gt;T&lt;/code&gt; 가 재정의 할당 연산자를 가지고 &lt;code&gt;=&lt;/code&gt; 이 연산자는 유형의 할당에 사용되는 &lt;code&gt;seq[T]&lt;/code&gt; . 이러한 연산은 형식에 바인딩되어 있기 때문에 구현이 간단하기 때문에 공칭 형식에 바인딩되어야합니다. 이는 &lt;code&gt;ref T&lt;/code&gt; 대한 재정의 된 &lt;code&gt;deepCopy&lt;/code&gt; 가 실제로 T 에 바인딩되고 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;ref T&lt;/code&gt; 하지 않음을 의미 합니다. 이것은 또한 &lt;code&gt;ptr T&lt;/code&gt; 와 &lt;code&gt;ref T&lt;/code&gt; 모두에 대해 &lt;code&gt;deepCopy&lt;/code&gt; 를 무시할 수 없음을 의미합니다.&lt;em&gt;&lt;/em&gt;동시에; 대신 하나의 포인터 유형에 도우미 고유 또는 객체 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">이러한 프로세스는 &quot;최선의 노력&quot;실시간 보장을 제공합니다. 특히 사이클 수집기는 마감 기한을 아직 알지 못합니다. 더 예측 가능한 실시간 동작을 얻으려면 비활성화하십시오. 테스트 결과 최신 CPU의 거의 모든 경우 (사이클 컬렉터가 비활성화 된 상태) 최대 2ms의 일시 정지 시간이 충족되는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="translated">이 규칙은 구성이 변수에 연결되어 있고 범위 종료시 쉽게 파괴 될 수 있도록합니다. 이후 버전의 언어는 소멸자의 지원을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="translated">이러한 규칙은 Nim 코드베이스 및 Nim 컴파일러, 표준 라이브러리와 같은 공식 프로젝트 및 C2Nim과 같은 다양한 공식 도구에 대한 기여에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="translated">이 템플릿의 이름은 &lt;code&gt;atom&lt;/code&gt; 및 &lt;code&gt;nxt&lt;/code&gt; 여야 합니다. 단일 문자와 문자 세트를 모두 처리하려면 &lt;code&gt;atom&lt;/code&gt; 이 오버로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="translated">이 두 proc는 실시간 GC의 두 가지 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">이 HTTP 서버는 프로덕션 환경에서 사용하도록 설계되지 않았지만 응용 프로그램을 로컬에서 테스트하기 위해 설계되었습니다. 이 때문에 응용 프로그램을 배포 할 때 사용자가이 서버에 직접 연결할 수 있도록하는 대신 리버스 프록시 (예 : nginx)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="translated">이 모듈은 유형 및 매크로를 구현하여 자바 스크립트 라이브러리의 래핑 및 상호 작용을 용이하게합니다. 제공된 매크로와 함께 제공된 유형 &lt;code&gt;JsObject&lt;/code&gt; 및 &lt;code&gt;JsAssoc&lt;/code&gt; 을 사용하면 JavaScript와의 원활한 인터페이스가 가능하여 JavaScript 변수를 빠르고 쉽게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="translated">이것은 GC가 최대에 대한 몇 가지 작업을 수행 할 수 있습니다 &lt;code&gt;us&lt;/code&gt; 의 시간을. 이것은 GC가 작업을 수행 할 수 있도록 메인 루프를 호출하는 데 유용합니다. 모든 GC 활동을 &lt;code&gt;GC_step&lt;/code&gt; 호출에 바인드하려면 프로그램 시작시 &lt;code&gt;GC_disable&lt;/code&gt; 을 사용 하여 GC를 비활성화하십시오 . 경우 &lt;code&gt;strongAdvice&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , GC가 수집주기를 수행하도록 강요 당할 것이다. 그렇지 않으면 GC는 수집 할 쓰레기가 많지 않으면 아무것도하지 않기로 결정할 수 있습니다. &lt;code&gt;stackSize&lt;/code&gt; 매개 변수 를 통해 현재 스택 크기를 지정할 수도 있습니다 . 스택의 특정 지점 아래에 고유 한 Nim 참조가 없다는 것을 알고 있으면 성능을 향상시킬 수 있습니다. 지정한 크기가 최악의 잠재적 크기보다 큰지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="translated">이 호출은 &lt;code&gt;match&lt;/code&gt; 암시 적 선언과 &lt;code&gt;matches&lt;/code&gt; 의 범위에서 사용할 수있는 배열 &lt;code&gt;=~&lt;/code&gt; 전화 :</target>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;#discardableprefix&lt;/code&gt; 지시문을 사용하면 됩니다 . 이름에서 알 수 있듯이 비 반환 반환 유형이있는 주어진 접두사의 기능은 &lt;code&gt;.discardable&lt;/code&gt; 로 주석 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">SQL이 포함 된 문자열과 그렇지 않은 문자열을 구별하면이를 피할 수 있습니다. 구별 유형은 문자열 과 호환되지 않는 새 문자열 유형 &lt;code&gt;SQL&lt;/code&gt; 을 도입하는 수단을 제공 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="translated">존재하거나 존재하지 않는 값이있을 때 유용 할 수 있습니다. 값이없는 경우가 종종 &lt;code&gt;nil&lt;/code&gt; 로 표시되지만 항상 사용 가능한 것은 아니며 항상 좋은 솔루션도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="translated">0-9 ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">0-9 ASCII 문자 만 검사합니다. 진정한 반환의 모든 문자 경우 &lt;em&gt;들&lt;/em&gt; 숫자이며, 적어도 하나 개의 문자에있다 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="translated">ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="translated">이것은 z, AZ ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">이것은 z, AZ ASCII 문자 만 검사합니다. 진정한 반환의 모든 문자 경우 &lt;em&gt;들&lt;/em&gt; 알파벳이며, 적어도 하나 개의 문자에있다 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="translated">이것은 az, AZ, 0-9 ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">이것은 az, AZ, 0-9 ASCII 문자 만 검사합니다. 진정한 반환의 모든 문자 경우 &lt;em&gt;들&lt;/em&gt; alpanumeric하고 적어도 하나 개의 문자에있다 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="translated">이 코드는 HTML 파일의 모든 태그를 반복하고 수정 된 버전을 다시 쓰는 방법을 보여줍니다. 이 경우 확장자가 &lt;code&gt;.rst&lt;/code&gt; 로 끝나는 하이퍼 링크를 찾아 &lt;code&gt;.html&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="translated">이 코드에는 단점이 있습니다. 언젠가 &lt;code&gt;debug&lt;/code&gt; 를 false로 설정하면 상당히 비싼 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 작업이 계속 수행됩니다! (절차에 대한 논쟁 평가는 &lt;em&gt;열망이다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">이는 반대 작업을 수행하므로 &lt;a href=&quot;#escape&quot;&gt;이스케이프&lt;/a&gt; 를 보완 합니다.</target>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="translated">이 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="translated">이 상수는 대상 플랫폼이 &lt;code&gt;ioselectors&lt;/code&gt; 모듈에서 완전히 지원되는지 여부를 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="translated">이 편리한 프로시 저는 첫 번째 마크 업 (전체 문서 일 필요는 없음)을 사용하여 모든 입력 문자열을 구문 분석하고 포함 가능한 HTML 조각을 반환합니다. 발동 효과가에서 사용하기위한 것입니다 &lt;em&gt;온라인으로&lt;/em&gt; 의미있는 파일 시스템에 액세스하지 않고 환경 때문에 처음 &lt;code&gt;include&lt;/code&gt; 지시문을 좋아하지 않을 것이다 일을. &lt;code&gt;config&lt;/code&gt; 매개 변수에 대한 설명은 &lt;code&gt;initRstGenerator&lt;/code&gt; proc을 참조하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="translated">이 지시어는 c2nim에게 &lt;code&gt;dynlib&lt;/code&gt; pragma를 사용하여 C 함수 프로토 타입에서 생성 된 모든 proc에 주석을 달도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="translated">이 문서는 Nim의 표준 라이브러리에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="translated">이 문서는 GC 작동 방식과 ( &lt;span id=&quot;realtime-systems_1&quot;&gt;실시간&lt;/span&gt; ) &lt;span id=&quot;realtime-systems_1&quot;&gt;실시간 시스템&lt;/span&gt; 에 맞게 조정하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="translated">이 문서 는 &lt;a href=&quot;nimc&quot;&gt;Nim 컴파일러에&lt;/a&gt; 내장 된 &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;문서 생성 도구에&lt;/span&gt; 대해 설명합니다.이 &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;도구&lt;/span&gt; 는 입력 .nim 파일 및 프로젝트에서 HTML 및 JSON 출력은 물론 입력 RST (reStructuredText) 파일에서 HTML 및 LaTeX를 생성 할 수 있습니다. 출력 문서에는 모듈 종속성 ( &lt;code&gt;import&lt;/code&gt; ), 최상위 문서 주석 (##) 및 프로 시저, 유형 및 변수를 포함하여 내 보낸 기호 (*)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="translated">이 문서는 Nim의 어휘, 구문 및 의미를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">이 문서는 지원되는 다른 플랫폼 에서 &lt;em&gt;Nim 컴파일러&lt;/em&gt; 의 사용법을 설명합니다 . Nim 프로그래밍 언어의 정의가 아니므로 &lt;a href=&quot;manual&quot;&gt;매뉴얼이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="translated">이 문서는 &lt;em&gt;Nim&lt;/em&gt; 프로그래밍 언어 의 고급 구성에 대한 튜토리얼입니다 . &lt;a href=&quot;manual&quot;&gt;매뉴얼 &lt;/a&gt;&lt;strong&gt;에 고급 언어 기능에 대한 더 많은 예제가 포함되어 &lt;/strong&gt;&lt;strong&gt;있으므로이 문서는 다소 쓸모가 없습니다 &lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="translated">이 문서는 프로그래밍 언어 &lt;em&gt;Nim에&lt;/em&gt; 대한 튜토리얼입니다 . 이 학습서는 변수, 유형 또는 명령문과 같은 기본 프로그래밍 개념에 익숙하지만 매우 기본적인 것으로 가정합니다. 이 &lt;a href=&quot;manual&quot;&gt;설명서&lt;/a&gt; 에는 고급 언어 기능의 더 많은 예가 포함되어 있습니다. 이 튜토리얼의 모든 코드 예제와 나머지 Nim 문서에서 찾은 코드 예제는 &lt;a href=&quot;nep1&quot;&gt;Nim 스타일 안내서를&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">이 문서는 사용 가능한 옵션을 안내합니다. idetools 지원의 실제 예제를 보려면 &lt;a href=&quot;#test-suite&quot;&gt;테스트 스위트&lt;/a&gt; 에서 찾은 테스트 파일 또는 이미 사용 가능한 &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;다양한 편집기 통합&lt;/a&gt; 을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">이 문서는 사용 가능한 옵션을 안내합니다. 가장 강력한 지원의 실제 예를 보려면 이미 사용 가능한 &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;다양한 편집기 통합&lt;/a&gt; 을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 아무것도하지 않습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">&lt;em&gt;s에 &lt;/em&gt;&lt;em&gt;키&lt;/em&gt; 가 없으면 아무 것도 수행하지 않습니다 . 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="translated">이 예제는 W3 HTML Validator의 사용법을 보여줍니다. &lt;code&gt;multipart/form-data&lt;/code&gt; 를 &lt;code&gt;Content-Type&lt;/code&gt; 으로 사용 하여 검증 할 HTML을 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">이 예는 사용자에게 &lt;code&gt;question&lt;/code&gt; 하고 &quot;예&quot;(또는 비슷한 것)로 대답하면 true를 반환하고 &quot;아니오&quot;(또는 비슷한 것)로 대답하면 false를 반환 하는 &lt;code&gt;yes&lt;/code&gt; 라는 프로 시저를 보여줍니다 . &lt;code&gt;return&lt;/code&gt; 문은 즉시 절차 (따라서 while 루프)를 떠난다. &lt;code&gt;(question: string): bool&lt;/code&gt; 구문은 절차라는 이름의 매개 변수를 기대하는 설명 &lt;code&gt;question&lt;/code&gt; 형식의 &lt;code&gt;string&lt;/code&gt; 입력합니다 값 반환 &lt;code&gt;bool&lt;/code&gt; . &lt;code&gt;bool&lt;/code&gt; 유형은 내장되어에 대한 유효한 값 &lt;code&gt;bool&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; . if 또는 while 문의 조건은 &lt;code&gt;bool&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="translated">이 예는 HTTP GET을 사용하여 &lt;code&gt;http://google.com&lt;/code&gt; 을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="translated">이 예제는 포트 8080에서 HTTP 서버를 작성합니다. 서버는 &lt;code&gt;200 OK&lt;/code&gt; 응답 코드와 &quot;Hello World&quot;를 응답 본문으로 사용하여 모든 요청 에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="translated">문자열 매개 변수에 잘못된 문자가 포함 된 경우이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="translated">이 기능은 아직 개발 중입니다. 앞으로 IDE가 현재 실행중인 / 디버깅 된 사용자 프로젝트의 컨텍스트에서 표현식을 평가할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="translated">이 함수는 &lt;em&gt;PDispatcher의&lt;/em&gt; 모든 대리자에서 이벤트를 확인합니다 . 그런 다음 올바른 이벤트 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="translated">이 함수 는 여전히 열려있는 파일 디스크립터가 있으면 &lt;code&gt;True&lt;/code&gt; 를 리턴 하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴합니다 . 닫힌 파일 설명자는 즉시 디스패처에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="translated">이 기능은 호스트 이름의 IP 주소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="translated">이 기능은 IP 주소의 호스트 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="translated">이 함수는 소켓 오류가 발생하면 EOS 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="translated">이 함수는 기본 &lt;code&gt;FutureStream&lt;/code&gt; 에서 반환 된 데이터를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="translated">이 함수는 오류가 발생하면 EOS 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">이 함수는 오류가 발생하면 EOS 예외를 발생시킵니다. 0보다 작은 값은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">이 함수는 오류가 발생하면 OSError 예외를 발생시킵니다. 0보다 작은 값은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="translated">결과가 너무 커서 제공된 비트에 맞지 않는 계산에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="translated">이것은 Teradata, Oracle, Sybase, MSSqlvSvr 등의 ODBC 드라이버에 대해 아직 광범위하게 테스트되지 않았습니다. 알. 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="translated">이 구현 은 &lt;code&gt;genOid&lt;/code&gt; 의 첫 번째 호출에 대해 &lt;code&gt;math.randomize()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="translated">이것은 원시 POSIX 인터페이스 모듈입니다. 편의를 제공하지는 않습니다. 적절한 Nim 문자열 대신 cstring이 사용되며 리턴 코드는 오류를 나타냅니다. 예외와 적절한 Nim과 같은 인터페이스를 원하면 OS 모듈을 사용하거나 랩퍼를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="translated">이것은 다음과 같은 간단한 구문 변환입니다.</target>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">이 래퍼의 PROC입니다 &lt;a href=&quot;#copyFile&quot;&gt;CopyFile 수 ()&lt;/a&gt; , &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; 및 &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions ()&lt;/a&gt; 비 Windows 플랫폼에서. Windows에서이 proc은 &lt;a href=&quot;#copyFile&quot;&gt;copyFile ()&lt;/a&gt; 의 래퍼 일뿐 입니다. 해당 proc은 이미 속성을 복사하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="translated">이것은 모두 단일 스레드, 완전 비 블로킹이며 많은 제어 기능을 제공합니다. 이론적으로는 Windows 이외의 플랫폼에만 관심이있는 한 이러한 계층을 상호 교환하여 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="translated">이것은 명령 행 인수를 반복하기위한 편리한 반복기입니다. 새로운 OptParser가 생성됩니다. 기본 비어있는 &lt;code&gt;NoVal&lt;/code&gt; 매개 변수 사용에 대한 위의 &lt;code&gt;getopt(var OptParser)&lt;/code&gt; 예제를 참조하십시오 . 이 예제는 예제와 동일한 옵션 키에 대한 것이지만 여기서는 명령 키 사용자에게 옵션 키-값 구분 기호가 선택 사항이됩니다.</target>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="translated">주어진 OptParser 객체를 반복하기위한 편리한 반복자입니다. 예:</target>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="translated">이것은 구성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">이 유형에 바이너리 호환 &lt;code&gt;char**&lt;/code&gt; 에 &lt;em&gt;C&lt;/em&gt; . 배열의 높은 값은 실제로 범위 검사를 비활성화 할만큼 충분히 큽니다. &lt;em&gt;cstringArrayToSeq&lt;/em&gt; 를 사용 하여 &lt;code&gt;seq[string]&lt;/code&gt; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="translated">이것은을 사용하여 수행됩니다 &lt;code&gt;to&lt;/code&gt; 매크로. 한 번 봐 가지고 &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;그 문서&lt;/a&gt; 의 사용의 예를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="translated">이것은 사실상 &quot;Content-Length&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="translated">이것은 사실상 &quot;Content-Type&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="translated">이것은 &quot;마지막으로 수정 된&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 동일 하지만 &lt;code&gt;nnkLetSection&lt;/code&gt; 대신 &lt;code&gt;nnkVarSection&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;getpeername_1&quot;&gt;getpeername의&lt;/span&gt; 고급 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;getsockname_1&quot;&gt;getsockname의&lt;/span&gt; 고급 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">이것은 IOCP (Windows Completion Ports)를위한 &lt;code&gt;pure&lt;/code&gt; 메커니즘 이 아니므로 이를 피할 수 있다면 그렇게하십시오. 실제로 필요한 경우에만 &lt;em&gt;addRead를&lt;/em&gt; 사용하십시오 (주요 유스 케이스는 Windows에서 유닉스와 유사한 라이브러리를 비동기 적으로 조정하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">이것은 IOCP (Windows Completion Ports)를위한 &lt;code&gt;pure&lt;/code&gt; 메커니즘 이 아니므로 이를 피할 수 있다면 그렇게하십시오. 실제로 필요한 경우에만 &lt;em&gt;addWrite를&lt;/em&gt; 사용하십시오 (주요 유스 케이스는 Windows에서 유닉스와 유사한 라이브러리를 비동기 적으로 조정하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 의 모든 용도에 대해 동일한 AST는 아닙니다 . 자세한 내용은 [프로 시저 선언] ( &lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 와 결합 될 때 할당 구문이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="translated">이것은 모든 경고를 한 번에 비활성화하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="translated">이것은 종종 &lt;code&gt;splitPath&lt;/code&gt; 의 &lt;code&gt;head&lt;/code&gt; 결과와 동일 합니다. 부모가 없으면 &quot;&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">항목 을 &lt;em&gt;sep&lt;/em&gt; 로 &lt;em&gt;구분&lt;/em&gt; 해야하는 코드를 생성 할 때 유용합니다 . &lt;em&gt;sep&lt;/em&gt; 는 &lt;em&gt;dest&lt;/em&gt; 가 &lt;em&gt;startLen&lt;/em&gt; 보다 긴 경우에만 추가됩니다 . 다음 예제는 정수 배열을 설명하는 문자열을 만듭니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="translated">표준 형식 지정자를 지원해야하는 사용자 정의 &lt;code&gt;format&lt;/code&gt; proc 을 작성하려는 경우에만 관심이 있습니다 . 경우 &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; 이 사실은 이후에 알 수없는 접미사 &lt;code&gt;type&lt;/code&gt; 필드는 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="translated">&lt;code&gt;segfaults.nim&lt;/code&gt; 모듈을 가져온 경우에만 발생합니다 !</target>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="translated">이것은 &lt;code&gt;--app:lib&lt;/code&gt; 명령 줄 옵션을 통해 프로그램이 동적 라이브러리로 컴파일 된 경우에만 유용합니다 . 이 pragma는 Windows 대상에서의 코드 생성에만 영향을 미치므로이 pragma를 잊어 버리고 동적 라이브러리를 Mac 및 / 또는 Linux에서만 테스트하면 오류가 발생하지 않습니다. Windows에서이 pragma는 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 을 함수 선언에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="translated">이것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="translated">이것은 JavaScript 코드 의 &lt;code&gt;async&lt;/code&gt; 키워드 와 거의 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="translated">이것은 &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt; 합니다. 이 proc은 파이썬 에서 &lt;code&gt;%&lt;/code&gt; 연산자 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="translated">이것은 &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 하는 구체적인 조회 알고리즘입니다 .</target>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="translated">위의 &lt;code&gt;sendTo&lt;/code&gt; 함수 의 상위 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">이것은 발전기의 점프 기능입니다. next ()에 대한 2 ^ 64 호출과 같습니다. 병렬 계산을 위해 2 ^ 64 비 중첩 서브 시퀀스를 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="translated">이것이 주요 &lt;em&gt;프로젝트&lt;/em&gt; 파일 이름입니다. 대부분의 경우 &lt;strong&gt;FILE&lt;/strong&gt; 과 동일하게 전달 하지만 더 큰 프로젝트의 경우이 파일은 프로그램의 기본 진입 점으로 사용되는 파일이며 사용자가 컴파일하여 최종 바이너리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="translated">조회가 참조하는 모듈 또는 포함 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="translated">이것은 Microsoft에서 지정한 Safecall 규칙입니다. 생성 된 C 프로시 저는 &lt;code&gt;__safecall&lt;/code&gt; 키워드로 선언됩니다 . &lt;em&gt;safe&lt;/em&gt; 라는 단어 는 모든 하드웨어 레지스터가 하드웨어 스택으로 푸시되어야한다는 사실을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;formatstr % [a]&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="translated">자동 문자열 화를 지원한다는 점을 제외하면 &lt;code&gt;formatstr % a&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">이것은 &lt;code&gt;len(splitLines(s))&lt;/code&gt; 와 동일하지만 시간적 객체를 생성하는 문자열을 수정하지 않기 때문에 훨씬 더 효율적입니다. 모든 &lt;a href=&quot;manual#character-literals&quot;&gt;문자 리터럴&lt;/a&gt; 개행 조합 (CR, LF, CR-LF)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;char&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;double&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;float&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;int&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;long double&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; . 이 C 유형은 Nim의 코드 생성기에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;long long&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;long&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;short&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;signed char&lt;/code&gt; 에 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;size_t&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned char&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned int&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;unsigned long long&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;unsigned long&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned short&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="translated">이것은 다른 데이터베이스에 대해 구현 된 것과 동일한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">이것은 예를 들어 &lt;code&gt;bindSym&lt;/code&gt; 예제 [here] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt; )와 정규 표현식 모듈에서 &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; 과 함께 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="translated">이것은 매우 빠르지 만 잠재적으로 위험합니다. &lt;strong&gt;모든&lt;/strong&gt; 행 이 필요한 경우에만이 반복자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="translated">이 라이브러리는 C 컴파일러의 헤더 파일을 사용합니다. 결과 C 코드는 &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; 이며 여기에 선언 된 기호는 정의 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 생성 된 모든 파일을 쉽게 삭제할 수 있습니다. 이 디렉토리에서 생성 된 파일은 &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim 백엔드 통합 문서&lt;/a&gt; 에서 읽을 수있는 명명 논리를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="translated">이것은 모든 &lt;code&gt;'%xx'&lt;/code&gt; (여기서 &lt;code&gt;xx&lt;/code&gt; 는 16 진수 값을 나타냄)가 서수 &lt;code&gt;xx&lt;/code&gt; 의 문자로 변환되고 다른 모든 문자가 이어짐을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">이는 세트 &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; 문자를 의미합니다 . } 결과에 전달됩니다. 다른 모든 문자는 &lt;code&gt;''%xx'&lt;/code&gt; 로 인코딩되며 , 여기서 &lt;code&gt;xx&lt;/code&gt; 는 16 진수 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="translated">이는 참조 URI 경로뿐만 아니라 기본 URI 경로 내부의 슬래시가 결과 URI에 영향을 미침을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="translated">이것은 다음과 같이 컴파일되지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="translated">이 메커니즘은 스레드 안전 자동 메모리 관리를 구현하기 위해 채널과 같은 공유 메모리를 지원하는 대부분의 데이터 구조에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="translated">이 메소드 호출 구문은 객체로 제한되지 않으며 모든 유형에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="translated">이 메소드 호출 구문은 객체로 제한되지 않으며 프로 시저에 대한 모든 유형의 첫 번째 인수를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">이 수정 &lt;em&gt;의&lt;/em&gt; 자체, 그것은 사본을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="translated">이 모듈 은 &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959에서&lt;/a&gt; 지정한 FTP 클라이언트를 &lt;strong&gt;부분적으로&lt;/strong&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="translated">이 모듈은 높은 수준의 효율적인 I / O 멀티플렉싱을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="translated">이 모듈을 사용하면 구문 분석 된 JSON 객체의 필드에 두 가지 다른 방식으로 액세스 할 수 있습니다.이 중 하나가이 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="translated">이 모듈은 또한 &lt;code&gt;scanp&lt;/code&gt; 매크로를 구현하는데 ,이 구문은 Nim의 표현식 구문을 사용하므로 접미사 연산자 대신 접두사를 사용해야한다는 점을 제외하고는 EBNF 또는 PEG 문법과 다소 유사합니다.</target>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="translated">이 모듈은 또한 RFC 2822에 지정된 메시지를 형식화하는 데 사용되는 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="translated">이 모듈을 사용하여 &lt;em&gt;% *&lt;/em&gt; 연산자를 사용하여 JSON을 편안하게 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="translated">이 모듈에는 잠금 및 조건 변수에 대한 Nim의 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="translated">이 모듈에는 Nim의 재진입 잠금 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="translated">이 모듈에는 입력 문자열에서 하위 문자열을 추출하는 데 사용할 수 있는 &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; 매크로가 포함되어 있습니다 . 이것은 보통 정규식보다 쉽습니다. 전채로서의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="translated">이 모듈에는 &lt;em&gt;터미널&lt;/em&gt; ( &lt;em&gt;콘솔&lt;/em&gt; 이라고도 함 ) 을 제어하는 ​​몇 가지 절차가 포함되어 있습니다 . UNIX에서 구현은 단순히 ANSI 이스케이프 시퀀스를 사용하며 다른 모듈에 의존하지 않으며 Windows에서는 Windows API를 사용합니다. 프로그램 종료 후에도 스타일 변경은 영구적입니다! 코드 &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; 를 사용하여 기본값을 복원하십시오. 마찬가지로 커서를 숨기면 종료하기 전에 &lt;code&gt;showCursor&lt;/code&gt; 를 사용하여 커서를 숨기십시오 .</target>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="translated">이 모듈에는 환경 변수 검색, 명령 행 인수 읽기, 디렉토리 작업, 쉘 명령 실행 등과 같은 기본 운영 체제 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="translated">이 모듈에는 토큰, 숫자, 식별자 등을 구문 분석하기위한 헬퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="translated">이 모듈에는 다른 바이트 순서 ( &lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt; ) 를 처리하는 헬퍼가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="translated">이 모듈에는 임의의 Nim 데이터 구조의 &lt;span id=&quot;serialization_1&quot;&gt;직렬화&lt;/span&gt; 및 &lt;span id=&quot;deseralization_1&quot;&gt;역 &lt;/span&gt;&lt;span id=&quot;serialization_1&quot;&gt;직렬화를&lt;/span&gt; 위한 &lt;span id=&quot;deseralization_1&quot;&gt;프로세스&lt;/span&gt; 가 포함되어 있습니다 . 직렬화 형식은 &lt;span id=&quot;json_1&quot;&gt;JSON을&lt;/span&gt; 사용합니다 . 경고 : 직렬화 형식은 나중에 변경 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 그레고리력 달력을 사용하여 시간을 처리하기위한 루틴과 유형이 포함되어 있습니다. &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 대상&lt;/a&gt; 에도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="translated">이 모듈에는 &lt;span id=&quot;rope_1&quot;&gt;로프&lt;/span&gt; 데이터 유형 이 지원됩니다 . 로프는 매우 긴 줄을 효율적으로 표현할 수 있습니다. 특히 연결은 O (n) 대신 O (1)에서 수행됩니다. 그것들은 기본적으로 네이티브 Nim 문자열로 변환 할 때만 평평하게되는 연결 트리입니다. 빈 문자열은 &lt;code&gt;nil&lt;/code&gt; 로 표시됩니다 . 로프는 변경할 수 없으며 하위 트리는 복사하지 않고 공유 할 수 있습니다. 런타임 효율성을 유지하면서 메모리 효율성을 높이기 위해 잎을 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="translated">이 모듈에는 컴파일러의 추상 구문 트리 ( &lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt; )에 대한 인터페이스가 포함되어 있습니다 . 매크로는이 트리에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="translated">이 모듈은 이메일 주소 등에 대한 다양한 문자열 매처를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt; 와 비교하여 드물게 사용되는 다양한 문자열 유틸리티 루틴이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 다양한 문자열 유틸리티 루틴이 포함되어 있습니다. 정규식 지원에 대해서는 모듈 &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; 를 참조하십시오 . PEG 지원에 대해서는 모듈 &lt;a href=&quot;pegs&quot;&gt;페그&lt;/a&gt; 를 참조하십시오 . 이 모듈은 &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 대상에&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="translated">이 모듈은 유형 작업을위한 컴파일 타임 반영 프로세스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="translated">이 모듈은 RFC 3986에 지정된대로 URI 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="translated">이 모듈은 XML DOM Level 2 Core 사양을 구현합니다 ( &lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="translated">이 모듈 은 정렬 된 문자열 세트 또는 정렬 된 문자열 매핑을위한 효율적인 컨테이너 인 &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; 를 구현합니다 . Adam Langley의 우수한 논문을 기반으로합니다. 크리트 비트 트리는 &lt;span id=&quot;radix-tree_1&quot;&gt;기수&lt;/span&gt; 또는 &lt;span id=&quot;patricia-trie_1&quot;&gt;패트리샤 &lt;/span&gt;&lt;span id=&quot;radix-tree_1&quot;&gt;트리&lt;/span&gt; 의 한 형태입니다 .</target>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 파서를 구현합니다 . 큰 하위 집합이 구현되었습니다. &lt;span id=&quot;markdown_1&quot;&gt;마크 다운&lt;/span&gt; 위키 구문 의 일부 기능 도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="translated">이 모듈은 효율적인 버퍼 처리로 렉서의 기본 객체를 구현합니다. 버퍼를 다시 채워야하는 경우 줄 끝 점검 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="translated">이 모듈은 base64 인코더 및 디코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 에서 HTML / 라텍스 생성기를 구현하고 ( 이 마크 업 구문에 대한 정보는 &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; 참조 ) 컴파일러의 &lt;a href=&quot;docgen&quot;&gt;docgen 도구에서 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="translated">이 모듈은 스레드 풀의 헬퍼를 구현하여 스레드 작성이 좋은지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="translated">이 모듈은 고성능 비동기 HTTP 서버를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 &lt;code&gt;asyncdispatch&lt;/code&gt; 모듈에 정의 된 비동기 디스패처를 기반으로 상위 레벨 비동기 소켓 API를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 고급 크로스 플랫폼 소켓 인터페이스를 구현합니다. 이 모듈에서 구현 된 절차는 주로 소켓을 차단하기위한 것입니다. 비동기 비 블로킹 소켓을 위해 사용 &lt;code&gt;asyncnet&lt;/code&gt; 의 와 모듈 함께를 &lt;code&gt;asyncdispatch&lt;/code&gt; 의 모듈.</target>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="translated">이 모듈은 json 파서를 구현합니다. &lt;code&gt;json&lt;/code&gt; 표준 라이브러리 모듈에서 사용하고 내보내 지만 자체적으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="translated">이 모듈은 저수준 크로스 플랫폼 소켓 인터페이스를 구현합니다. 더 높은 수준의 버전을 보려면 &lt;code&gt;net&lt;/code&gt; 모듈을 보십시오 .</target>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="translated">이 모듈은 mimetypes 데이터베이스를 구현합니다</target>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 비트 조작을위한 일련의 저수준 방법을 구현합니다. 기본적으로이 모듈은 컴파일러 내장 함수를 사용하여 지원되는 컴파일러 ( &lt;code&gt;GCC&lt;/code&gt; , &lt;code&gt;LLVM_GCC&lt;/code&gt; , &lt;code&gt;CLANG&lt;/code&gt; , &lt;code&gt;VCC&lt;/code&gt; , &lt;code&gt;ICC&lt;/code&gt; )에서 성능을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="translated">이 모듈은 간단한 &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; 및 &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; 코드 생성기를 구현합니다 . 일반적으로 사용되는 각 HTML 태그에는 해당 HTML 표현으로 문자열을 생성하는 해당 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="translated">이 모듈은 웹 페이지 및 기타 데이터를 검색하는 데 사용할 수있는 간단한 HTTP 클라이언트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; ( &lt;span id=&quot;comma-separated-value_1&quot;&gt;쉼표로 구분 된 값&lt;/span&gt; ) 파서를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; 파서를 구현합니다 . JSON (JavaScript Object Notation)은 XML과 달리 사람이 읽고 쓸 수있는 간단한 데이터 교환 형식입니다. 기계가 구문 분석하고 생성하기 쉽습니다. JSON은 JavaScript 프로그래밍 언어, 표준 ECMA-262 3 판-1999 년 12 월의 일부를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; 파서를 구현합니다 . 지원되는 유일한 인코딩은 UTF-8입니다. 파서는 웹에서 발견 된 대부분의 &quot;와일드 HTML&quot;조차도 파싱 할 수 있도록 다소 오류를 수정하도록 설계되었습니다. &lt;strong&gt;참고 :&lt;/strong&gt; 이 파서는 각 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 에 해당 &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt; 이 있는지 확인하지 않습니다 ! 이러한 검사는 여러 가지 이유로 클라이언트 코드에 의해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="translated">이 모듈은 간단한 로거를 구현합니다. 이 라이브러리가 당신의 요구를 충족시키지 못하면, 자신의 글을 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="translated">이 모듈은 사용자의 기본 브라우저로 URL을 여는 간단한 절차를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="translated">이 모듈은 필요한 Win API 프로 시저에 대해 작은 래퍼를 구현하므로 Nim 컴파일러는 거대한 Windows 모듈에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 파서에 대한 AST를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="translated">이 모듈은 OS 프로세스 및 프로세스 통신을 실행하기위한 고급 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="translated">이 모듈은 비동기 FTP 클라이언트를 구현합니다. FTP 서버에 연결하여 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="translated">이 모듈은이 이벤트 루프를 사용하는 비동기 소켓과 함께 비동기 이벤트 루프를 구현합니다. 그것은 파이썬의 asyncore 모듈과 유사합니다. 소켓을 사용하는 많은 모듈은이 모듈에 대한 구현을 가지고 있으며, 이러한 모듈에는 모두 원하는 디스패처에 원하는 오브젝트를 추가하여 해당 모듈의 오브젝트와 연관된 이벤트를 수신 할 수 있도록 하는 &lt;code&gt;register&lt;/code&gt; 기능이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="translated">이 모듈은 Nim의 &lt;span id=&quot;runtime-type-information_1&quot;&gt;런타임 유형 정보&lt;/span&gt; ( &lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt; )에 대한 인터페이스를 구현합니다 . &lt;code&gt;Any&lt;/code&gt; 및 해당 작업이 클라이언트에서 불쾌한 낮은 수준의 세부 정보를 숨기 더라도 본질적으로 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">이 모듈은 비동기 IO를 구현합니다. 여기에는 디스패처, &lt;code&gt;Future&lt;/code&gt; 유형 구현 및 &lt;code&gt;await&lt;/code&gt; 키워드 와 함께 비동기 코드를 동기식 스타일로 작성할 수 있는 &lt;code&gt;async&lt;/code&gt; 매크로가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="translated">이 모듈은 비동기 파일 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="translated">이 모듈은 상용구 테스트를 위해 보일러 플레이트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 Nim의 색상 처리를 구현합니다. &lt;code&gt;graphics&lt;/code&gt; 모듈에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="translated">이 모듈은 복소수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="translated">이 모듈은 다양한 Nim 유형에 대한 해시 값의 효율적인 계산을 구현합니다. 모든 procs는 다음 두 가지 구성 요소를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="translated">이 모듈은 CGI 응용 프로그램을위한 도우미 프로세스를 구현합니다. 예:</target>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="translated">이 모듈은 SCGI 응용 프로그램을위한 도우미 프로세스를 구현합니다. 예:</target>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="translated">이 모듈은 쿠키 파싱을위한 헬퍼 프로세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="translated">이 모듈은 Nim의 매크로 시스템을 기반으로 멋진 구문 설탕을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="translated">이 모듈 은 기능적 프로그래밍 언어에서 영감을 얻은 내장 &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; 유형 에 대한 작업을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="translated">이 모듈은 휴대용 소켓을 구현하고 다양한 유형의 소켓을 혼합하여 지원합니다. 소켓은 데이터가 수신 될 것이라는 기본 의미에 의해 버퍼링하는 &lt;code&gt;BufferSize&lt;/code&gt; (4000) 크기의 덩어리, 버퍼링 동작은 설정하여 비활성화 할 수 있습니다 &lt;code&gt;buffered&lt;/code&gt; 호출 할 때 매개 변수를 &lt;code&gt;socket&lt;/code&gt; 에 기능 &lt;em&gt;거짓을&lt;/em&gt; . 일부 함수는 아직 버퍼 소켓 (주로 recvFrom 함수)을 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="translated">이 모듈은 프로세서를 구현하여 CPU / 코어 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">이 모듈 구현 유리수하는 분자로 구성된 &lt;em&gt;납입&lt;/em&gt; 와 분모의 &lt;em&gt;서재&lt;/em&gt; , int 형의 모두. 분모는 0 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="translated">이 모듈은 몇 가지 일반적인 일반 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="translated">이 모듈은 RFC 5321에 지정된 SMTP 클라이언트 프로토콜을 구현하며 SMTP 서버로 메일을 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 공유 라이브러리에서 심볼에 액세스하는 기능을 구현합니다. POSIX에서는 Windows &lt;code&gt;LoadLibrary&lt;/code&gt; 에서 &lt;code&gt;dlsym&lt;/code&gt; 메커니즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="translated">이 모듈은 Linux 배포 ( &quot;distro&quot;) 감지 및 OS 기본 패키지 관리자에 대한 기본 사항을 구현합니다. 주요 목적은 다음과 같은 Nimble 패키지의 출력을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="translated">이 모듈은 JS 백엔드에 대한 비동기 코드를 작성하기위한 유형 및 매크로를 구현합니다. JavaScript 비동기 API 및 라이브러리와의 상호 작용, Nim에서 비동기 프로 시저 작성 및 콜백 기반 코드를 약속으로 변환하는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="translated">이 모듈은 선택적 값을 캡슐화하는 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="translated">이 모듈은 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 다른 백엔드 ( &lt;code&gt;Javascript&lt;/code&gt; , &lt;code&gt;Nimscript&lt;/code&gt; 및 &lt;code&gt;compiletime VM&lt;/code&gt; 타임 VM ) 와도 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C 라이브러리 주위에 랩퍼를 제공하여 구현됩니다 . 이것은이 모듈을 사용할 때 응용 프로그램이 PCRE 라이브러리의 라이센스에 의존한다는 것을 의미하지만 문제는 아닙니다. PCRE의 라이센스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">이 모듈은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 및 비교 부동 소수점 / int 피연산자에 대해 작동하는 일반적인 이진 연산의 구현을 제공합니다 . 모든 연산은 정수 피연산자를 부동 피연산자의 유형으로 변환합니다. 숫자 식의 경우 반환 유형은 항상 표현에 관련된 부동 유형입니다. 즉 float32에서 float64로 자동 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="translated">이 모듈은 XML 문서를 XML DOM 문서 표현으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="translated">이 모듈은 HTML 문서를 구문 분석하고 XML 트리 표현을 만듭니다. 실제 세계에서 사용 하는 &lt;em&gt;와일드&lt;/em&gt; HTML 을 처리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="translated">이 모듈은 XML 문서를 구문 분석하고 XML 트리 표현을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">이 모듈은 Nim 파일 객체 ( &lt;em&gt;File&lt;/em&gt; )와 문자열에 대한 스트림 인터페이스를 구현하는 &lt;em&gt;FileStream&lt;/em&gt; 과 &lt;em&gt;StringStream&lt;/em&gt; 의 두 가지 구현을 제공합니다 . 다른 모듈은이 표준 스트림 인터페이스에 대한 다른 구현을 제공 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="translated">이 모듈은 OpenSSL 라이브러리에 사용하기 쉬운 소켓 스타일의 nim 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="translated">이 모듈은 동기 및 비동기 구현을 모두 제공합니다. 비동기 구현에서는 &lt;code&gt;asyncFTPClient&lt;/code&gt; 함수 를 사용해야합니다 . 그런 다음 등록해야 &lt;code&gt;AsyncFTPClient&lt;/code&gt; 을 사용하여 asyncio 디스패처와 &lt;code&gt;register&lt;/code&gt; 기능을. 자세한 내용은 asyncio 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="translated">이 모듈은 다른 운영 체제에서 &lt;span id=&quot;memory-mapped-files_1&quot;&gt;메모리 매핑 파일&lt;/span&gt; (Posix 's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt; )을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="translated">이 모듈은 유니 코드 UTF-8 인코딩 처리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="translated">이 모듈은 표준 Nim 명령 줄 파서를 제공합니다. 모든 명령 행 옵션과 일부 하위 레벨 기능에 대해 하나의 편의 반복자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="translated">이 모듈은 할당을 저장하기 위해 &lt;code&gt;cstring&lt;/code&gt; 을 &lt;code&gt;string&lt;/code&gt; 로 변환하지 않고 &lt;code&gt;cstring&lt;/code&gt; 에 대한 작업을위한 헬퍼 루틴을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="translated">이 모듈은 핵심 JavaScript 함수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="translated">이 모듈은 액세스 위반 / segfault를 &lt;code&gt;NilAccessError&lt;/code&gt; 예외 로 바꾸는 신호 핸들러를 등록합니다 . NilAccessError를 잡으려면이 모듈을 가져 오기만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="translated">연결되지 않은 소켓에서 호출해야합니다. 소켓이 연결되면 SSL 세션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 교집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="translated">이 연산자는 할당 연산자입니다. 컨텍스트 &lt;code&gt;result = expr&lt;/code&gt; , &lt;code&gt;parameter = defaultValue&lt;/code&gt; 또는 매개 변수 전달에 대해 지정이 수행되지 않습니다. 오버로드 된 할당 연산자가 있는 유형 &lt;code&gt;T&lt;/code&gt; 의 경우 &lt;code&gt;var v = T()&lt;/code&gt; 가 &lt;code&gt;var v: T; v = T()&lt;/code&gt; 로 다시 작성됩니다 . T; v = T () ; 즉, &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 컨텍스트가 할당으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="translated">이 연산자는 누락 된 필드에 대한 지정과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="translated">이 연산자는 필드 액세스 및 메소드 호출 모두와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">이 연산자는 메소드 호출과 독점적으로 일치합니다. 보다 우선 순위가 높습니다 &lt;em&gt;. &lt;/em&gt;예를 들어 스크립트 언어와 인터페이스하는 경우 &lt;em&gt;xy&lt;/em&gt; 및 &lt;em&gt;xy ()&lt;/em&gt; 와 같은 표현식을 다르게 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="translated">이것은 &lt;code&gt;x + y * z - x&lt;/code&gt; 표현식 을 다음을 포함 하는 &lt;code&gt;nnkArgList&lt;/code&gt; 노드 로 &lt;code&gt;optM&lt;/code&gt; 매크로에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="translated">이 pragma는 개발자에게 릴레이하기 위해 선택적 경고 문자열을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="translated">이 절차는 필요한 Content-Length 헤더를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="translated">이 프로세스는 리디렉션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="translated">이 proc도 리디렉션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="translated">이 proc을 사용하여 트리 구조를 즉석에서 만들 수 있습니다 (때때로 &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt; 이라고 &lt;span id=&quot;autovivification_1&quot;&gt;함&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="translated">이 proc은 현재 메타 데이터 (예 : &lt;code&gt;assert&lt;/code&gt; template)가 현재 파일 이름과 줄 번호에 대한 정보를 검색하는 데 유용합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">이 proc은 사용자 구성 파일에서 오는 경로 처리의 편의를 위해 expandTilde proc에 의해 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="translated">이 proc은 지정된 &lt;code&gt;address&lt;/code&gt; 로 &lt;code&gt;data&lt;/code&gt; 를 보냅니다 . IP 주소 또는 호스트 이름 일 수 있습니다. 호스트 이름이 지정된 경우이 함수는 해당 호스트 이름의 각 IP를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="translated">이 proc은 노드가 예상되는 유형이 아닌 경우에 주장합니다. 빈 문자열은 최소값으로 반환됩니다. 첫 번째 값은 선행 / 후행 공백에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">이 proc은 먼저 &lt;code&gt;--index:on&lt;/code&gt; 스위치 를 사용하는 &lt;code&gt;nim doc|rst2html&lt;/code&gt; 과 같은 명령에 의해 생성 된 &lt;code&gt;.idx&lt;/code&gt; 확장자를 가진 인덱스 파일에 대한 &lt;em&gt;dir&lt;/em&gt; 을 스캔 합니다. 이 색인 파일은 &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; 및 &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; 호출의 결과 이므로 탭으로 구분 된 간단한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="translated">이 proc은 동일한 파일 또는 디렉토리에 대한 두 개의 대체 하드 링크 또는 sym 링크 경로가 제공되면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="translated">이 절차는 문자열을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="translated">이 절차는 정수 또는 문자의 열린 배열 (배열 또는 시퀀스)을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="translated">이 절차는 메모리 낭비없이 파일에 스트리밍 된 데이터를 저장하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="translated">이 절차는 &lt;code&gt;Duration&lt;/code&gt; 값을 문자열 로 변환하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="translated">이 절차는 &lt;code&gt;TimeInterval&lt;/code&gt; 값을 문자열 로 변환하는 데 유용합니다 . 예를 들어 사용자 정의 간격 인쇄를 구현해야합니다</target>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="translated">이 절차는 클라이언트 소켓을 닫지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="translated">이 절차는 또한이 소켓에 대한 새로운 파일 디스크립터를 생성 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">이 절차는 &lt;code&gt;client.maxRedirects&lt;/code&gt; 에 지정된 최대 리디렉션 수까지 리디렉션을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="translated">이 절차는 즉시 반환되며 연결될 때까지 차단되지 않습니다. 소켓의 쓰기 가능 여부 를 확인 ( &lt;code&gt;select&lt;/code&gt; 사용 ) 하여 연결이 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="translated">이 절차는 심볼릭 링크를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="translated">결과 JSON을 사람이 읽을 수 있도록 형식화 하지 &lt;strong&gt;않기&lt;/strong&gt; 때문에 &lt;code&gt;pretty&lt;/code&gt; 프로 시저 보다 높은 효율성을 제공합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="translated">이것은 빠르게 지루해집니다. 구현은 사소한 컴파일러는 모든 코드는 나중에 그것을 멀리 최적화하기 위해 생성해서는 안 - 결국 &lt;code&gt;+&lt;/code&gt; 달러에 대한이 같은 바이너리 코드를 생성해야 &lt;code&gt;+&lt;/code&gt; 의 int합니다. pragma &lt;span id=&quot;borrow_1&quot;&gt;차용은&lt;/span&gt; 이 문제를 해결하도록 설계되었습니다. 원칙적으로 위의 간단한 구현을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">식별자 비교를 수행하는 다소 정통적인 방법을 &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;부분 대소 문자 구분&lt;/span&gt; 이라고 하며 기존 대소 문자 구분에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="translated">이를 위해서는 OpenSSL 라이브러리가 필요하지만 많은 운영 체제에서 널리 사용되고 사용됩니다. &lt;code&gt;https&lt;/code&gt; 스키마를 사용하여 함수에 URL을 제공하면 httpclient는 SSL을 자동으로 사용합니다 ( 예 : &lt;code&gt;https://github.com/&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="translated">행을 반복하기 전에 모든 행을 메모리로 검색합니다. 큰 데이터 집합 쿼리는 메모리 사용에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="translated">매개 변수 &lt;strong&gt;만&lt;/strong&gt; 리턴 &lt;strong&gt;합니다&lt;/strong&gt; . 응용 프로그램 실행 파일 이름을 얻으려면 &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename ()을&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="translated">이 섹션은 마지막 항목에만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7e30a1e9a0acdfc19a0c0083bbed66bee81f8c64" translate="yes" xml:space="preserve">
          <source>This section deals with the basic built-in types and the operations that are available for them in detail.</source>
          <target state="translated">이 섹션에서는 기본 내장 유형 및 해당 유형에 사용할 수있는 작업에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="39b66580a9224160aed4a56da61d43fa2a3bbf6f" translate="yes" xml:space="preserve">
          <source>This section describes Nim's additional features that are not listed in the Nim manual. Some of the features here only make sense for the C code generator and are subject to change.</source>
          <target state="translated">이 섹션에서는 Nim 매뉴얼에 나열되지 않은 Nim의 추가 기능에 대해 설명합니다. 여기의 일부 기능은 C 코드 생성기에만 해당되며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfa8ca764ad8bfb7ab8cb634f105e3b8af514a0" translate="yes" xml:space="preserve">
          <source>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</source>
          <target state="translated">이 섹션에서는 현재 Nim 구현이 지원하지만 언어 사양의 일부로 보여서는 안되는 추가 실습에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a3df74b1ff5eebb36ece2e259d2d5e805032af28" translate="yes" xml:space="preserve">
          <source>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (&lt;code&gt;NimNode&lt;/code&gt;) with a variable number of children. Each node has a field named &lt;code&gt;kind&lt;/code&gt; which describes what the node contains:</source>
          <target state="translated">이 섹션에서는 AST가 Nim 유형 시스템으로 모델링되는 방법을 설명합니다. AST는 가변 개수의 자식이있는 노드 ( &lt;code&gt;NimNode&lt;/code&gt; ) 로 구성됩니다 . 각 노드에는 노드에 포함 된 내용을 나타내는 &lt;code&gt;kind&lt;/code&gt; 라는 필드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28cfadb305f94e005219763b91c53ae1a57afd3" translate="yes" xml:space="preserve">
          <source>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the &lt;a href=&quot;#lexical-analysis&quot;&gt;Lexical Analysis&lt;/a&gt; section.</source>
          <target state="translated">이 섹션에는 Nim의 표준 구문이 나와 있습니다. 파서가 들여 쓰기를 처리하는 방법은 &lt;a href=&quot;#lexical-analysis&quot;&gt;사전 분석&lt;/a&gt; 섹션 에 이미 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd3a9a0b54b906c2f17ac03b05d99470504a894" translate="yes" xml:space="preserve">
          <source>This should be called on a connected socket, and will perform an SSL handshake immediately.</source>
          <target state="translated">연결된 소켓에서 호출되어야하며 SSL 핸드 셰이크를 즉시 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f33d2aee12f9e4445c80f6903f9125cbac15130e" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures.</source>
          <target state="translated">이것은 무효 선물 을 &lt;code&gt;discard&lt;/code&gt; 하기 위해 폐기 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79d43e8081cd2738e9c8a30d0556e7afa9f98284" translate="yes" xml:space="preserve">
          <source>This should produce roughly this code:</source>
          <target state="translated">이것은 대략 다음 코드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a4682779a113516e431fc633b78e3eb5afe0b69" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; to override the temporary directory returned by &lt;code&gt;os.getTempDir()&lt;/code&gt;. The value &lt;strong&gt;should&lt;/strong&gt; end with a directory separator character. (Relevant for the Android platform)</source>
          <target state="translated">이 기호는 &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; 와 같이 문자열을 값 으로 사용하여 &lt;code&gt;os.getTempDir()&lt;/code&gt; 의해 리턴 된 임시 디렉토리를 대체합니다 . 값 &lt;strong&gt;은&lt;/strong&gt; 디렉토리 구분 문자로 끝나야합니다. (Android 플랫폼과 관련 있음)</target>
        </trans-unit>
        <trans-unit id="9b990f66ca4d7aa57f0cf0dd33176a666917f9d2" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; to override the path for the &lt;code&gt;sh&lt;/code&gt; binary, in cases where it is not located in the default location &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">이 기호는 기본 위치 &lt;code&gt;/bin/sh&lt;/code&gt; 에 있지 않은 경우 &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; 와 같이 문자열을 값 으로 사용하여 &lt;code&gt;sh&lt;/code&gt; 바이너리 의 경로를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="beb8c91cc0539e7ac1fcb6913e444dfab0dfc651" translate="yes" xml:space="preserve">
          <source>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="translated">이것은 Microsoft에서 지정한 stdcall 규칙입니다. 생성 된 C 프로시 저는 &lt;code&gt;__stdcall&lt;/code&gt; 키워드로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="40a29bb19075988ba4154f245cf61264e6c3403b" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;em&gt;genericHead&lt;/em&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="translated">이 특성은 &lt;em&gt;genericHead&lt;/em&gt; 와 유사 하지만 제네릭이 아닌 유형에 오류를 생성하는 대신 수정되지 않은 상태로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31b73c4d12f30a07a08773a16f4683aba0e028b0" translate="yes" xml:space="preserve">
          <source>This trait returns true iff the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;. Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="translated">이 특성은 유형 &lt;code&gt;t&lt;/code&gt; 가 &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt; 에 사용하기에 안전한 경우 true를 리턴합니다 . 다른 언어의 이름은 이러한 &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt; 과 같은 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="3824e56a10ede7c713ffb39e26e88a788482118a" translate="yes" xml:space="preserve">
          <source>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</source>
          <target state="translated">이 변환은 varargs 매개 변수가 프로 시저 헤더의 마지막 매개 변수 인 경우에만 수행됩니다. 이 컨텍스트에서 유형 변환을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d1986229bd95fd619538b360b3cc3585eddf09" translate="yes" xml:space="preserve">
          <source>This type contains a description of a person</source>
          <target state="translated">이 유형에는 사람에 대한 설명이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="c4d9daad0926694b235ad99d9f58721fb3438862" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="translated">이것은 선형 메모리 오버 헤드만으로 &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; 거리 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4922584a12b79a219eaa16925bbb909743a91e2e" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;RFC 3986의 섹션 5.2.2에&lt;/a&gt; 지정된 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e216d34b156aa03e46b15d955959dbcd959d74" translate="yes" xml:space="preserve">
          <source>This uses the configuration defined in &lt;code&gt;config\nim.cfg&lt;/code&gt; for &lt;code&gt;lvm_gcc&lt;/code&gt;.</source>
          <target state="translated">이에 정의 된 구성을 사용하여 &lt;code&gt;config\nim.cfg&lt;/code&gt; 에 대한 &lt;code&gt;lvm_gcc&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5505a00f1063702f80a5818b1a5c8c32d61e3710" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="translated">이 버전의 &lt;code&gt;foldl&lt;/code&gt; 은 시작 매개 변수를 얻습니다. 이것에 의해, 시퀀스를 시퀀스 요소와 다른 타입으로 축적 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7bac1b6d0db41715df5581bb4825ea90b0b4190f" translate="yes" xml:space="preserve">
          <source>This will generate a file called &lt;code&gt;switchhomebrew.elf&lt;/code&gt; which can then be turned into an nro file with the &lt;code&gt;elf2nro&lt;/code&gt; tool in the DevkitPro release. Examples can be found at &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;the nim-libnx github repo&lt;/a&gt;.</source>
          <target state="translated">이것은라는 파일이 생성됩니다 &lt;code&gt;switchhomebrew.elf&lt;/code&gt; 그와 함께 NRO 파일로 전환 할 수 &lt;code&gt;elf2nro&lt;/code&gt; DevkitPro 릴리스 도구를. 예제는 &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;nim-libnx github repo&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26136905c2efd9e1d537dc87f61ea998287f6a6d" translate="yes" xml:space="preserve">
          <source>This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of &lt;code&gt;.idx&lt;/code&gt;. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the &lt;a href=&quot;#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; section for details.</source>
          <target state="translated">입력 Nim 모듈에서 내 보낸 모든 심볼의 인덱스를 생성하고 확장자가 &lt;code&gt;.idx&lt;/code&gt; 인 인접 파일에 넣습니다 . 색인 파일은 줄 지향적입니다 (줄 바꿈을 이스케이프해야 함). 각 줄은 여러 열의 탭으로 구분 된 레코드를 나타내며 처음 두 개는 필수이며 나머지는 선택 사항입니다. 자세한 내용은 &lt;a href=&quot;#index-idx-file-format&quot;&gt;색인 (idx) 파일 형식&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ead03785f5fb54bd6190bd855d00357524e06d3" translate="yes" xml:space="preserve">
          <source>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</source>
          <target state="translated">이것은 개념이 일치하지 않거나 특정 콜 사이트에서만 컴파일러 출력에 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa4705d432fb1b0185c67d13ccff0749b0afd34e" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;future&lt;/code&gt; is finished.</source>
          <target state="translated">이것은 올릴 &lt;code&gt;ValueError&lt;/code&gt; 하면 &lt;code&gt;future&lt;/code&gt; 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="77dd0890df14804d1f6f5c6ad7d8c663331e013e" translate="yes" xml:space="preserve">
          <source>This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that &lt;code&gt;filename.nim&lt;/code&gt; belongs to.</source>
          <target state="translated">&lt;code&gt;filename.nim&lt;/code&gt; 이 속한 Nimble 패키지에 속하는 입력 모듈로 가져온 모든 nim 모듈에 대한 문서를 반복적으로 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="01e5c517031f780132f7de304e80ce21fd6382d8" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;.</source>
          <target state="translated">이것은 문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cd34efcb73d9e9a4a38033e49417a668da60801" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">이것은 문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 . 유니 코드 문자에 사용할 수있는 버전 은 &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3189c7fd9700aaadbf4a4dd6af6df7937cf0b2d7" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">이것은 문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 . 유니 코드 문자에 사용할 수있는 버전 은 &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc168569a3d857e9b97041d394676d2e416f6807" translate="yes" xml:space="preserve">
          <source>This would be any of the other idetools available options, like &lt;code&gt;--def&lt;/code&gt; or &lt;code&gt;--suggest&lt;/code&gt; explained in the following sections.</source>
          <target state="translated">다음 절에서 설명하는 &lt;code&gt;--def&lt;/code&gt; 또는 &lt;code&gt;--suggest&lt;/code&gt; 와 같은 다른 idetools 사용 가능한 옵션 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="3974135028a38a44142b8af58d9f501e1acc3c71" translate="yes" xml:space="preserve">
          <source>This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).</source>
          <target state="translated">이 사본이없는 memchr- 제한된 인터페이스는 아마도 파일에서 줄 같은 레코드를 반복하는 가장 빠른 방법 일 것입니다. 그러나 반환 된 (데이터, 크기) 객체는 Nim 문자열이 아니거나, 검사 된 Nim 배열 또는 종료 된 C 문자열이 아닙니다. 따라서 데이터에 액세스하려면주의를 기울여야합니다 (예 : str * 함수가 아닌 C mem * 함수를 생각하십시오).</target>
        </trans-unit>
        <trans-unit id="3f848317832fae19e0085de9e23738862798395f" translate="yes" xml:space="preserve">
          <source>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</source>
          <target state="translated">프로그램이 무엇을하는지는 분명해야하지만, 프로그램이 시작될 때 들여 쓰기되지 않은 문장이 실행됩니다. 들여 쓰기는 님의 문장을 그룹화하는 방법입니다. 들여 쓰기는 공백으로 만 수행되며 테이블 작성기는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d02e1b27f5da6165217ae6af04fef8718253485" translate="yes" xml:space="preserve">
          <source>Though the Nim Standard Library is still evolving, it is already quite usable. It is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt; and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="translated">Nim 표준 라이브러리는 여전히 발전하고 있지만 이미 사용 가능합니다. &lt;em&gt;순수한 라이브러리&lt;/em&gt; , &lt;em&gt;불순한 라이브러리&lt;/em&gt; 및 &lt;em&gt;랩퍼&lt;/em&gt; 로 나뉩니다 .</target>
        </trans-unit>
        <trans-unit id="b4cc7e4d5579d2abc9a379f6ffd100e925cda3b1" translate="yes" xml:space="preserve">
          <source>Thread coordination</source>
          <target state="translated">스레드 조정</target>
        </trans-unit>
        <trans-unit id="59a7e2e5a99004361b87c2d5390e14c75d8f283e" translate="yes" xml:space="preserve">
          <source>Thread pragma</source>
          <target state="translated">스레드 프라 그마</target>
        </trans-unit>
        <trans-unit id="bb1d54b91c07f35c7604f3ddd4b6f833468ea9ba" translate="yes" xml:space="preserve">
          <source>Thread support for Nim. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">Nim에 대한 스레드 지원. &lt;strong&gt;참고&lt;/strong&gt; : 이것은 시스템 모듈의 일부입니다. 직접 가져 오지 마십시오. 스레드 지원을 활성화하려면 &lt;code&gt;--threads:on&lt;/code&gt; 명령 행 스위치 를 사용하여 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="efcacaedc288d5f1ee9e06293407eb061bd561ea" translate="yes" xml:space="preserve">
          <source>Threads and exceptions</source>
          <target state="translated">스레드와 예외</target>
        </trans-unit>
        <trans-unit id="9e9af3f7a423d176c8e989c93a406d4e77eaeeca" translate="yes" xml:space="preserve">
          <source>Threadvar pragma</source>
          <target state="translated">Threadvar Pragma</target>
        </trans-unit>
        <trans-unit id="7c599a1317d70c1913cfd27374ce0f1835f7e408" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. &lt;code&gt;def&lt;/code&gt; for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">반환 된 답변의 유형을 나타내는 세 문자 (예 : 정의의 &lt;code&gt;def&lt;/code&gt; , 제안의 &lt;code&gt;sug&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="cb0fdc12f844b31a8cf54439d51d7813e5ece7c9" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. def for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">반환 된 답변의 유형을 나타내는 세 문자 (예 : 정의의 def, 제안의 &lt;code&gt;sug&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="04a4b67d34c6ea267e9e2aa731f12d8004957357" translate="yes" xml:space="preserve">
          <source>Three letter string which indicates the day of the week.</source>
          <target state="translated">요일을 나타내는 3 글자 문자열.</target>
        </trans-unit>
        <trans-unit id="166b5ad7cdc1ddb77e376400c9f9b2e942b944d7" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where certain safety checks are omitted for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="translated">관통 &lt;code&gt;-d:x&lt;/code&gt; 또는 &lt;code&gt;--define:x&lt;/code&gt; 조건부 컴파일 시간을 컴파일 기호를 정의 할 수 있습니다 전환합니다. 정의 된 스위치는 함께 소스 코드에서 확인할 수 있습니다 &lt;a href=&quot;manual#when-statement&quot;&gt;때 문&lt;/a&gt; 및 &lt;a href=&quot;system#defined&quot;&gt;정의 PROC&lt;/a&gt; . 이 스위치의 일반적인 용도는 성능 향상을 위해 특정 안전 점검이 생략 된 릴리스 모드 ( &lt;code&gt;-d:release&lt;/code&gt; )에서 빌드를 활성화하는 것입니다 . 다른 일반적인 용도는 SSL 소켓을 활성화하기 위한 &lt;code&gt;-d:ssl&lt;/code&gt; 스위치입니다.</target>
        </trans-unit>
        <trans-unit id="053686996ea91f5f0bd8bfc5be9311b2dfb9563b" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">가장 &lt;code&gt;nimsuggest&lt;/code&gt; 도구를 통해 모든 IDE는 &lt;code&gt;.nim&lt;/code&gt; 소스 파일을 쿼리하고 심볼 정의 또는 완성 제안과 같은 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645311b7482290ae055f08a018122a58f2c3b9eb" translate="yes" xml:space="preserve">
          <source>Through the use of the optional &lt;code&gt;{.raises.}&lt;/code&gt; pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the &lt;code&gt;{.raises.}&lt;/code&gt; pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises &lt;code&gt;IOError&lt;/code&gt;, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</source>
          <target state="translated">선택적 &lt;code&gt;{.raises.}&lt;/code&gt; pragma를 사용하여 proc이 특정 예외 세트를 발생 시키거나 전혀 발생하지 않도록 지정할 수 있습니다. 는 IF &lt;code&gt;{.raises.}&lt;/code&gt; 프라그를 사용하는 컴파일러는이 사실임을 확인합니다. 예를 들어, proc이 &lt;code&gt;IOError&lt;/code&gt; 를 발생 시키도록 지정 하고 어느 시점에서 (또는 호출 하는 프로세서 중 하나) 새로운 예외가 발생하기 시작하면 컴파일러는 해당 proc이 컴파일되지 못하게합니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="7e4ee67f0e9e151a472bd4d369d44933d3da7821" translate="yes" xml:space="preserve">
          <source>Thrown in the &lt;code&gt;getContent&lt;/code&gt; proc and &lt;code&gt;postContent&lt;/code&gt; proc, when the server returns an error</source>
          <target state="translated">에 슬로우 &lt;code&gt;getContent&lt;/code&gt; PROC 및 &lt;code&gt;postContent&lt;/code&gt; 의 서버가 오류를 반환 PROC,</target>
        </trans-unit>
        <trans-unit id="37977e3077bc9851c1ffd00107b486f2f8f09038" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;em&gt;errorMsgExpected&lt;/em&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="translated">따라서 검사는 클라이언트에서 구현하기가 간단하기 때문에 이점이 거의없이 제대로 구현하기가 매우 어려웠습니다. 클라이언트는 &lt;em&gt;errorMsgExpected&lt;/em&gt; proc를 사용 하여이 라이브러리가 생성하는 다른 오류 메시지에 맞는 멋진 오류 메시지를 생성 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d39bb08fac5f6360feb78a680d458fc658579909" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">따라서 일반 식별자보다 키워드와 유사하게 작동합니다. A는 그러나 키워드 달리 재정의 할 수 &lt;span id=&quot;shadow_1&quot;&gt;그림자&lt;/span&gt; 의 정의 &lt;code&gt;system&lt;/code&gt; 모듈을. 이 목록에서 다음이로 작성해서는 안 점 표기법 &lt;code&gt;x.f&lt;/code&gt; 이후 &lt;code&gt;x&lt;/code&gt; 가 이 전달되기 전에 유형을 확인할 수 없습니다 &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0ee323ffc9625d6bc28b4f8cc717e26ebd77ac1a" translate="yes" xml:space="preserve">
          <source>Thus, north &amp;lt; east &amp;lt; south &amp;lt; west. The comparison operators can be used with enumeration types. Instead of &lt;code&gt;north&lt;/code&gt; etc, the enum value can also be qualified with the enum type that it resides in, &lt;code&gt;Direction.north&lt;/code&gt;.</source>
          <target state="translated">따라서 북쪽 &amp;lt;동쪽 &amp;lt;남쪽 &amp;lt;서쪽입니다. 비교 연산자는 열거 유형과 함께 사용할 수 있습니다. &lt;code&gt;north&lt;/code&gt; 등 대신에 열거 형 값을 &lt;code&gt;Direction.north&lt;/code&gt; 에있는 열거 형 유형으로 한정 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4b8a59ee4623c1899387bf6de6586afc3a5dc2" translate="yes" xml:space="preserve">
          <source>Time components are subtracted one-by-one, see output:</source>
          <target state="translated">시간 구성 요소는 하나씩 뺍니다 (출력 참조).</target>
        </trans-unit>
        <trans-unit id="3fb812b32f09c8031753f69acac0c61789f34460" translate="yes" xml:space="preserve">
          <source>Time effect.</source>
          <target state="translated">시간 효과.</target>
        </trans-unit>
        <trans-unit id="ec3ccfa05db1ce4bb37a133e936dac6618864488" translate="yes" xml:space="preserve">
          <source>Time measurement</source>
          <target state="translated">시간 측정</target>
        </trans-unit>
        <trans-unit id="f4fb52fb2152cd12040e0a822c3f35572a335a53" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;d&lt;/code&gt; days.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 일의 시간 간격</target>
        </trans-unit>
        <trans-unit id="45493a2f2864af1ad59f4e6002d36f0afb4f0012" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;h&lt;/code&gt; hours.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 시간 의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="48a2bec4e7d8f08615b4a69538e1d873fd8cabd4" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; minutes.</source>
          <target state="translated">의 TimeInterval이 &lt;code&gt;m&lt;/code&gt; 의 분.</target>
        </trans-unit>
        <trans-unit id="fd8b1b84cf164e73ebf16147dec8fe94eb87b149" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; months.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 개월의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="2e35c45093c4c75c76cc0ad1730384cf89bc1aab" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;micros&lt;/code&gt; microseconds.</source>
          <target state="translated">&lt;code&gt;micros&lt;/code&gt; 초의 TimeInterval .</target>
        </trans-unit>
        <trans-unit id="571851bb6763be044dfb20a43ad6453fa502f0ca" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;ms&lt;/code&gt; 간격 ( 밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="a0a7b6a6e6dabdcbf91694569154f0821829247a" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;nanos&lt;/code&gt; nanoseconds.</source>
          <target state="translated">&lt;code&gt;nanos&lt;/code&gt; 나노초 의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="843631ff0523a6f86df81cbca0448371ae88177c" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;s&lt;/code&gt; seconds.</source>
          <target state="translated">의 TimeInterval이 &lt;code&gt;s&lt;/code&gt; 초.</target>
        </trans-unit>
        <trans-unit id="bdc17d9ec9d80bdf5f4294a7ade05be0d237182e" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;w&lt;/code&gt; weeks.</source>
          <target state="translated">&lt;code&gt;w&lt;/code&gt; 주의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="77b05f6f1a5def9a860eb63a1be452d2e901c363" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;y&lt;/code&gt; years.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 년의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="49563f216566fe13f36b6d6f96d904d2f0012073" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;code&gt;DateTime&lt;/code&gt;'s of arbritary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="translated">임의 시간대의 &lt;code&gt;DateTime&lt;/code&gt; 을 지원하기위한 시간대 인터페이스 . &lt;code&gt;times&lt;/code&gt; 시스템 현지 시간과 UTC 만 공급 구현을 모듈.</target>
        </trans-unit>
        <trans-unit id="005f759cb3d18c4ae00a285a0712a53038aa8ad6" translate="yes" xml:space="preserve">
          <source>To &lt;em&gt;invoke&lt;/em&gt; a template, call it like a procedure.</source>
          <target state="translated">템플릿 을 &lt;em&gt;호출&lt;/em&gt; 하려면 프로 시저처럼 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6ce1339a3fbb20d91263c5b8ca905cfc7af9e20c" translate="yes" xml:space="preserve">
          <source>To access multiple values of a key, use the overloaded &lt;code&gt;[]&lt;/code&gt; below or to get all of them access the &lt;code&gt;table&lt;/code&gt; field directly.</source>
          <target state="translated">키의 여러 값에 액세스하려면 아래 의 오버로드 된 &lt;code&gt;[]&lt;/code&gt; 를 사용하거나 모든 값이 &lt;code&gt;table&lt;/code&gt; 필드에 직접 액세스하도록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a8854509b79b921922ff284c021ca2226c66887" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; has to be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The documentation of the system module contains further information.</source>
          <target state="translated">새로운 추적 객체를 할당하려면 내장 프로 시저 &lt;code&gt;new&lt;/code&gt; 를 사용해야합니다. 추적되지 않은 메모리를 처리하기 위해 &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; 및 &lt;code&gt;realloc&lt;/code&gt; 프로 시저를 사용할 수 있습니다. 시스템 모듈 설명서에는 추가 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b75bdb6d108ccec959da5a9406fd4ee6f129b2" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; must be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module's documentation contains further details.</source>
          <target state="translated">새로운 추적 오브젝트를 할당하려면 내장 프로 시저 &lt;code&gt;new&lt;/code&gt; 를 사용해야합니다. 추적되지 않은 메모리를 처리하기 위해 &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; 및 &lt;code&gt;realloc&lt;/code&gt; 프로 시저를 사용할 수 있습니다. &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈의 문서는 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e078eeb299e1530ea0a1c7ae42a41d998f5aecf7" translate="yes" xml:space="preserve">
          <source>To be documented.</source>
          <target state="translated">문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4aa18bea852a508605d53caeef9c5f926d90dc" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;em&gt;s&lt;/em&gt; is preallocated with an additional amount equal to the byte length of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="translated">가장 효율적으로 만들 려면 바이트 길이 &lt;em&gt;c&lt;/em&gt; 와 동일한 추가 양으로 &lt;em&gt;s&lt;/em&gt; 를 미리 할당해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2e8cced600feca55a223908d10e5130220dfada" translate="yes" xml:space="preserve">
          <source>To be used when diffing times. Consider using &lt;em&gt;between&lt;/em&gt; instead.</source>
          <target state="translated">디핑 시간에 사용됩니다. 대신 &lt;em&gt;사이&lt;/em&gt; 를 사용 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e63287bf2192ba9bdf47d785bd859bfea604a0" translate="yes" xml:space="preserve">
          <source>To call a procedure that returns a value just for its side effects and ignoring its return value, a &lt;code&gt;discard&lt;/code&gt; statement &lt;strong&gt;must&lt;/strong&gt; be used. Nim does not allow silently throwing away a return value:</source>
          <target state="translated">부작용에 대해서만 값을 리턴하고 리턴 값을 무시하는 프로 시저를 호출하려면 &lt;code&gt;discard&lt;/code&gt; 명령문을 &lt;strong&gt;사용해야&lt;/strong&gt; 합니다. Nim은 리턴 값을 자동으로 버릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbd6812cedca0f8d3ecee1c4880b1874c327d444" translate="yes" xml:space="preserve">
          <source>To change the compiler from the default compiler (at the command line):</source>
          <target state="translated">명령 행에서 기본 컴파일러에서 컴파일러를 변경하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="78e14482cffd7a387356de093fd85fe0f7385173" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="translated">Nim 모듈을 &lt;code&gt;.js&lt;/code&gt; 파일 로 컴파일하려면 &lt;code&gt;js&lt;/code&gt; 명령을 사용하십시오 . 기본값은 &lt;code&gt;.html&lt;/code&gt; 파일 에서 참조되어야 하는 &lt;code&gt;.js&lt;/code&gt; 파일입니다 . 그러나 &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; ( &lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt; )를 사용 하여 코드를 실행할 수도 있습니다 .&lt;span id=&quot;nodejs_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="94b72107dca9af29a5cf8e0cbfd67507a7bbcd4c" translate="yes" xml:space="preserve">
          <source>To compile a release version use:</source>
          <target state="translated">릴리스 버전을 컴파일하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50dace50e38237573560e76fd9fe662d2da1a4dc" translate="yes" xml:space="preserve">
          <source>To compute power between integers, use &lt;em&gt;^&lt;/em&gt; e.g. 2 ^ 6</source>
          <target state="translated">정수 사이의 거듭 제곱을 계산하려면 &lt;em&gt;^를&lt;/em&gt; 사용하십시오. 예 : 2 ^ 6</target>
        </trans-unit>
        <trans-unit id="40d351e4cf238073c675c29349e5026ed8e407aa" translate="yes" xml:space="preserve">
          <source>To create a new compiler for each run, use &lt;code&gt;koch temp&lt;/code&gt;:</source>
          <target state="translated">각 실행에 대해 새 컴파일러를 작성하려면 &lt;code&gt;koch temp&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="55053d7dbb6eec73712afca1d06925e6eb2fac3c" translate="yes" xml:space="preserve">
          <source>To cross compile, use for example:</source>
          <target state="translated">크로스 컴파일하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25e0b2d9936526053d98cae64c97e80a452c5953" translate="yes" xml:space="preserve">
          <source>To decode a base64 encoded data string simply call the &lt;code&gt;decode&lt;/code&gt; procedure:</source>
          <target state="translated">base64로 인코딩 된 데이터 문자열을 디코딩하려면 간단히 &lt;code&gt;decode&lt;/code&gt; 절차 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff5be3702ce16d9f83c4069146c2c5cbe57cdba3" translate="yes" xml:space="preserve">
          <source>To define a new operator enclose the operator in backticks &quot;``&quot;:</source>
          <target state="translated">새 연산자를 정의하려면 연산자를 백틱 &quot;&quot; &quot;으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="bb15e30b9d578a4da7a5878df01aeed724c88088" translate="yes" xml:space="preserve">
          <source>To define new commands like &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; and &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; in the examples, the concept of a &lt;em&gt;procedure&lt;/em&gt; is needed. (Some languages call them &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;.) In Nim new procedures are defined with the &lt;code&gt;proc&lt;/code&gt; keyword:</source>
          <target state="translated">예제에서 &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; 및 &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; 과 같은 새 명령을 정의하려면 &lt;em&gt;프로 시저&lt;/em&gt; 개념 이 필요합니다. (일부 언어 에서는이를 &lt;em&gt;메소드&lt;/em&gt; 또는 &lt;em&gt;함수&lt;/em&gt; 라고합니다 .) Nim에서 새 프로시 저는 &lt;code&gt;proc&lt;/code&gt; 키워드 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fb3cbb5f800fd3864fa68084a11d47c5e74ac25" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;em&gt;documentation&lt;/em&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;em&gt;generated API&lt;/em&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="translated">문서와 API 파일을 구별하기 위해 규칙이 사용됩니다. HTML 해시 문자 (#)없이 하나의 항목을 포함하는 색인은 &lt;em&gt;문서&lt;/em&gt; 로 간주됩니다. 이 해시리스 항목은 문서의 명시적인 제목이기 때문입니다. 이 명시적인 항목이없는 인덱스 는 소스 &lt;code&gt;.nim&lt;/code&gt; 파일에서 추출 된 &lt;em&gt;생성 된 API&lt;/em&gt; 로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="42c41b02b95231a84de881a8a918eb15cfd5edbe" translate="yes" xml:space="preserve">
          <source>To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor. By convention this entry without anchor is the &lt;em&gt;title entry&lt;/em&gt;, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word &lt;strong&gt;Module&lt;/strong&gt;.</source>
          <target state="translated">두 유형 (문서 및 API)을 구별하기 위해 색인 생성기는 문서 제목이있는 항목을 문서 색인에 추가합니다. 제목이 최상위 요소이므로 HTML 앵커없이 파일 이름 만 포함하는 두 번째 필드가 추가됩니다. 일반적으로 앵커가없는이 항목은 &lt;em&gt;제목 항목&lt;/em&gt; 이며 색인 파일의 항목이 스캔 될 때 추가되므로 제목 항목이 첫 번째 행이됩니다. 파일 이름을 &lt;strong&gt;Module&lt;/strong&gt; 단어에 연결하여 생성 할 수 있으므로 API 제목이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ee4e0702447b58e78b6bb613d5d237b6836e9f3" translate="yes" xml:space="preserve">
          <source>To enable realtime support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the GC supports the following operations:</source>
          <target state="translated">실시간 지원을 활성화하려면 &lt;span id=&quot;userealtimegc_1&quot;&gt;--define &lt;/span&gt; &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; 를 통해 &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; 심볼 을 정의해야합니다 (이를 구성 파일에도 넣을 수 있음). 이 스위치를 사용하여 GC는 다음 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7636be4ab67a90f1533c1be5ea8689d1d192cf03" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low level thread API. There are also high level parallelism constructs available. See &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="translated">스레드 지원을 활성화하려면 &lt;code&gt;--threads:on&lt;/code&gt; 명령 행 스위치를 사용해야합니다. &lt;code&gt;system&lt;/code&gt; 모듈은 여러 스레딩 기본 요소가 포함되어 있습니다. 저수준 스레드 API에 대해서는 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 및 &lt;a href=&quot;channels&quot;&gt;채널&lt;/a&gt; 모듈을 참조하십시오 . 높은 수준의 병렬 구조가 있습니다. 자세한 내용은 &lt;a href=&quot;#parallel-spawn&quot;&gt;스폰&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="eb0f5e0bd57a707dc272d6bdaa13536fe61b6dd8" translate="yes" xml:space="preserve">
          <source>To find the name of a nimble package the compiler searches for a &lt;code&gt;*.nimble&lt;/code&gt; file in the parent directory hierarchy of whatever module you are compiling. Even if you are in a subdirectory of your project, a parent &lt;code&gt;*.nimble&lt;/code&gt; file will influence the naming of the nimcache name. This means that on Unix systems creating the file &lt;code&gt;~/foo.nimble&lt;/code&gt; will automatically prefix all nimcache files not part of another package with the string &lt;code&gt;foo_&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 민첩 패키지의 이름을 찾기 위해 컴파일중인 모듈의 상위 디렉토리 계층에서 &lt;code&gt;*.nimble&lt;/code&gt; 파일을 검색합니다 . 프로젝트의 하위 디렉토리에 &lt;code&gt;*.nimble&lt;/code&gt; 상위 * .nimble 파일은 nimcache 이름의 이름에 영향을줍니다. 이것은 &lt;code&gt;~/foo.nimble&lt;/code&gt; 파일을 생성하는 Unix 시스템 에서 다른 패키지의 일부가 아닌 모든 nimcache 파일을 문자열 &lt;code&gt;foo_&lt;/code&gt; 로 자동 접두어로 사용함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="8ab93f39bb400a5b2494d8a733289a48baa43e8f" translate="yes" xml:space="preserve">
          <source>To force a full collection call &lt;code&gt;GC_fullCollect&lt;/code&gt;. Note that it is generally better to let the GC do its work and not enforce a full collection.</source>
          <target state="translated">전체 콜렉션을 강제 실행하려면 &lt;code&gt;GC_fullCollect&lt;/code&gt; 를 호출 하십시오 . 일반적으로 GC가 작업을 수행하고 전체 수집을 시행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83582671ff318357a306f2d73afcc6c6193db0e5" translate="yes" xml:space="preserve">
          <source>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;, which at first look seems a daunting task. But we can use as helper shortcut the &lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree macro&lt;/a&gt;, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of &lt;code&gt;const&lt;/code&gt; symbols we can create the following source file and compile it to see what the compiler &lt;em&gt;expects&lt;/em&gt; from us:</source>
          <target state="translated">AST를 생성하려면 &lt;a href=&quot;macros&quot;&gt;매크로 모듈에&lt;/a&gt; 노출 된 Nim 컴파일러가 사용하는 구조를 자세히 알아야합니다 . 처음에는 어려운 작업입니다. 그러나 &lt;a href=&quot;macros#dumpTree&quot;&gt;덤프 매크로&lt;/a&gt; 를 도우미 단축키로 사용할 수 있습니다. dumpTree 매크로 는 표현식 매크로 대신 명령문 매크로로 사용됩니다. 우리는 많은 &lt;code&gt;const&lt;/code&gt; 심볼 을 생성하고 싶다는 것을 알고 있으므로 다음 소스 파일을 생성하고 컴파일하여 컴파일러 가 우리에게 &lt;em&gt;기대&lt;/em&gt; 하는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48e80bf64e7a28669c506f4ab558d9ed800f9037" translate="yes" xml:space="preserve">
          <source>To get rid of hygiene in templates, one can use the &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; pragma for a template. &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; have no effect in &lt;code&gt;dirty&lt;/code&gt; templates.</source>
          <target state="translated">템플릿에서 위생을 제거하기 위해 템플릿에 대해 &lt;span id=&quot;dirty_1&quot;&gt;더티&lt;/span&gt; pragma를 사용할 수 있습니다 . &lt;code&gt;inject&lt;/code&gt; 및 &lt;code&gt;gensym&lt;/code&gt; 은 &lt;code&gt;dirty&lt;/code&gt; 템플릿에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="825f3a2ffb603c43346bb1ea2785b67acec3d702" translate="yes" xml:space="preserve">
          <source>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</source>
          <target state="translated">매크로 작성을 시작하기 위해 일반적인 동적 코드를 정적으로 컴파일되는 코드로 바꾸는 방법을 보여 드리겠습니다. 연습을 위해 다음 코드 스 니펫을 시작점으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="34a57ad28acbc5e4b10960f2e801cd4aa99747b3" translate="yes" xml:space="preserve">
          <source>To link against &lt;code&gt;nimrtl.dll&lt;/code&gt; use the command:</source>
          <target state="translated">&lt;code&gt;nimrtl.dll&lt;/code&gt; 에 연결하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2039b927dcf641bab171f78845015d45672f1c9e" translate="yes" xml:space="preserve">
          <source>To make the &lt;code&gt;createWindow&lt;/code&gt; proc easier to use it should provide &lt;em&gt;default values&lt;/em&gt;; these are values that are used as arguments if the caller does not specify them:</source>
          <target state="translated">&lt;code&gt;createWindow&lt;/code&gt; proc을 사용하기 쉽게 하려면 &lt;em&gt;기본값&lt;/em&gt; 을 제공해야 &lt;em&gt;합니다&lt;/em&gt; . 호출자가 지정하지 않은 경우 인수로 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="f8a5b8288b3fecf0f566c82b883159042530cd8e" translate="yes" xml:space="preserve">
          <source>To make the compiler output code for a 16bit target use the &lt;code&gt;--cpu:avr&lt;/code&gt; target.</source>
          <target state="translated">16 비트 대상에 대한 컴파일러 출력 코드를 만들려면 &lt;code&gt;--cpu:avr&lt;/code&gt; 대상을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="50bfd9dce33230fbb2c8127c3c5a8cde5dbf040a" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma block can be used:</source>
          <target state="translated">컴파일러의 gcsafety 분석을 무시하기 위해 &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd77706967ab0eca2f0aba7e8dc6a7369cc5358" translate="yes" xml:space="preserve">
          <source>To pass a block of statements to a template, use 'untyped' for the last parameter:</source>
          <target state="translated">문장 블록을 템플리트에 전달하려면 마지막 매개 변수에 'untyped'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae1d6bbadfa15e666e4a5bc97ac5b074bba176ef" translate="yes" xml:space="preserve">
          <source>To prevent confusing code there is a parsing limitation; if the &lt;code&gt;try&lt;/code&gt; follows a &lt;code&gt;(&lt;/code&gt; it has to be written as a one liner:</source>
          <target state="translated">혼동되는 코드를 방지하기 위해 구문 분석 제한이 있습니다. 경우 생성 &lt;code&gt;try&lt;/code&gt; 다음 &lt;code&gt;(&lt;/code&gt; 그것은 하나의 라이너로 쓸 수있다 :</target>
        </trans-unit>
        <trans-unit id="cee8374e17ee5570d2e73eb9424e263793331053" translate="yes" xml:space="preserve">
          <source>To produce a single &lt;code&gt;&quot;&lt;/code&gt; within a raw string literal, it has to be doubled:</source>
          <target state="translated">원시 문자열 리터럴 내 에서 단일 &lt;code&gt;&quot;&lt;/code&gt; 를 생성하려면 두 배가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a67c70af6b5e6b03d2581b5a5c05f83968ba3a74" translate="yes" xml:space="preserve">
          <source>To produce a single substitution character it has to be doubled: &lt;code&gt;$$&lt;/code&gt; produces &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">이 두 배로해야하는 하나의 대체 문자를 생성하려면 &lt;code&gt;$$&lt;/code&gt; 생산 &lt;code&gt;$&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="6149c77815fef9fc27e4a6217efcefadefe95220" translate="yes" xml:space="preserve">
          <source>To remove this event you should use the &lt;code&gt;delHandleWrite&lt;/code&gt; function. It is advised to use that function instead of just setting the event to &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; as that would mean that that function would be called constantly.</source>
          <target state="translated">이 이벤트를 제거하려면 &lt;code&gt;delHandleWrite&lt;/code&gt; 함수를 사용해야합니다 . 이벤트를 &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; 로 설정하는 대신 해당 함수를 사용하는 것이 좋습니다. 이는 해당 함수가 지속적으로 호출됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4dc2bd124108bb715e2125357f3ca8cff675a9b" translate="yes" xml:space="preserve">
          <source>To retrieve the value of &lt;code&gt;&quot;key&quot;&lt;/code&gt; you can do the following:</source>
          <target state="translated">&lt;code&gt;&quot;key&quot;&lt;/code&gt; 값을 검색하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2272069ae83ac24e5887939db19d33d7075a38" translate="yes" xml:space="preserve">
          <source>To see a list of Nimble's packages, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; or the &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages repos&lt;/a&gt; on GitHub.</source>
          <target state="translated">Nimble의 패키지 목록을 보려면 &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; 또는 GitHub 의 &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;패키지 저장소&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4bb591463a2bf5bfe74be5c756dd27d755e4b62" translate="yes" xml:space="preserve">
          <source>To specify the AST for the different Nim constructs, the notation &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; or &lt;code&gt;nodekind(value)&lt;/code&gt; or &lt;code&gt;nodekind(field=value)&lt;/code&gt; is used.</source>
          <target state="translated">다른 Nim 구문에 AST를 지정하려면 &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; 또는 &lt;code&gt;nodekind(value)&lt;/code&gt; 또는 &lt;code&gt;nodekind(field=value)&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b23947ec0494a83fa76619311a6fe3ef2b338db4" translate="yes" xml:space="preserve">
          <source>To the end of the tuple/object definition.</source>
          <target state="translated">튜플 / 객체 정의 끝.</target>
        </trans-unit>
        <trans-unit id="9f79e9096a797c7afc08420ab23a519537e4fb67" translate="yes" xml:space="preserve">
          <source>To understand some of the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</source>
          <target state="translated">문자열, 배열, 시퀀스 등의 인덱스를 지정하는 여러 가지 방법을 이해하려면 Nim은 0부터 시작하는 인덱스를 사용한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="596784d34744359d8630e6bf6d5a5b5ef239775c" translate="yes" xml:space="preserve">
          <source>To unpack raw bytes look at the &lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt; module.</source>
          <target state="translated">원시 바이트의 압축을 풀려면 &lt;a href=&quot;streams&quot;&gt;스트림&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="9dd0e4773e807b447d8759bcce32b13725171fb1" translate="yes" xml:space="preserve">
          <source>To use</source>
          <target state="translated">쓰다</target>
        </trans-unit>
        <trans-unit id="92fa9c66bf6fe6910167c4b6d93b8e2ef5d6e2c3" translate="yes" xml:space="preserve">
          <source>To use a filter for a source file the &lt;code&gt;#?&lt;/code&gt; notation is used:</source>
          <target state="translated">소스 파일에 필터를 사용하려면 &lt;code&gt;#?&lt;/code&gt; 표기법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd3786ffe14095836ecde08c5a7353e00f84790" translate="yes" xml:space="preserve">
          <source>To use threadsafe version of this module, it needs to be compiled with both &lt;code&gt;-d:threadsafe&lt;/code&gt; and &lt;code&gt;--threads:on&lt;/code&gt; options.</source>
          <target state="translated">이 모듈의 스레드 세이프 버전을 사용하려면 &lt;code&gt;-d:threadsafe&lt;/code&gt; 및 &lt;code&gt;--threads:on&lt;/code&gt; 옵션 으로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="31052631155b690d2c6d4d6d38ee09a1e1936e39" translate="yes" xml:space="preserve">
          <source>To verify that idetools is working properly there are files in the &lt;code&gt;tests/caas/&lt;/code&gt; directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</source>
          <target state="translated">idetools가 제대로 작동하는지 확인하기 위해 &lt;code&gt;tests/caas/&lt;/code&gt; 디렉토리에 유닛 테스트를 제공하는 파일이 있습니다 . 이상한 idetools 동작을 발견하고이를 재현 할 수 있으면 버그로보고하고 향후 회귀를 피하기 위해 스위트에 테스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e9f1bbe8f37ac15cd7d8886750a127655bd140" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;c2nim&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="translated">네이티브 코드를 래핑하려면 &lt;a href=&quot;c2nim&quot;&gt;c2nim 도구&lt;/a&gt; 를 살펴보고 헤더 파일을 스캔하고 Nim 인터페이스로 변환하는 프로세스를 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="c4b661fcccef784df68a5a22da94f9a1df408bd3" translate="yes" xml:space="preserve">
          <source>To write macros, one needs to know how the Nim concrete syntax is converted to an AST.</source>
          <target state="translated">매크로를 작성하려면 Nim 콘크리트 구문이 AST로 어떻게 변환되는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="5b94544fc25d4f617242b0db05703f0c24a3b42d" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings for interpolation purposes.</source>
          <target state="translated">보간을 위해 문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 토큰 화합니다 .</target>
        </trans-unit>
        <trans-unit id="9dabecffbc85d3462b703f6f51a8d742d3888dc3" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 토큰 화합니다 .</target>
        </trans-unit>
        <trans-unit id="4df68215c8e8bc621359763d151b72a86c6da974" translate="yes" xml:space="preserve">
          <source>Tools available with Nim</source>
          <target state="translated">Nim과 함께 사용 가능한 도구</target>
        </trans-unit>
        <trans-unit id="58446c7f2b2e4db0f99d43b03101c0a822d287a4" translate="yes" xml:space="preserve">
          <source>Tools documentation</source>
          <target state="translated">도구 문서</target>
        </trans-unit>
        <trans-unit id="1fe5db2636efc921cd0bb4e6546d660babab9b05" translate="yes" xml:space="preserve">
          <source>Top level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="translated">최고 수준의 &lt;code&gt;defer&lt;/code&gt; 이 같은 문을 참조해야하는지 불분명하기 때문에 문은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb14fa6e0884cf02668ea33f83561399f74d1358" translate="yes" xml:space="preserve">
          <source>Top level accesses to &lt;code&gt;gdata&lt;/code&gt; are always allowed so that it can be initialized conveniently. It is &lt;em&gt;assumed&lt;/em&gt; (but not enforced) that every top level statement is executed before any concurrent action happens.</source>
          <target state="translated">&lt;code&gt;gdata&lt;/code&gt; 에 대한 최상위 수준의 액세스 는 항상 허용되므로 편리하게 초기화 할 수 있습니다. 이되는 &lt;em&gt;것으로&lt;/em&gt; 어떤 동시 행동이 발생하기 전에 모든 최상위 명령문이 실행된다 (그러나 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="8aac1979dafc6f8136821295c2c76ca0331a0e00" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;em&gt;ptr T&lt;/em&gt; is implicitly convertible to the &lt;em&gt;pointer&lt;/em&gt; type.</source>
          <target state="translated">추적 된 참조는 &lt;strong&gt;ref&lt;/strong&gt; 키워드 로 선언되고 추적되지 않은 참조는 &lt;strong&gt;ptr&lt;/strong&gt; 키워드 로 선언됩니다 . 일반적으로, &lt;em&gt;ptr T&lt;/em&gt; 는 암시 적으로 &lt;em&gt;포인터&lt;/em&gt; 유형으로 변환 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0e0c2775cf7c51f8a1bb67ce0e0ab81a950538e4" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword; untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword.</source>
          <target state="translated">추적 된 참조는 &lt;strong&gt;ref&lt;/strong&gt; 키워드 로 선언됩니다 . 추적되지 않은 참조는 &lt;strong&gt;ptr&lt;/strong&gt; 키워드 로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc498182e45877c7d386bad77456516385d934" translate="yes" xml:space="preserve">
          <source>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. &lt;code&gt;Timeout&lt;/code&gt; is in milliseconds and -1 can be specified for no timeout.</source>
          <target state="translated">전통적인 선택 기능. 이 함수는 읽을 준비가되었거나 오류가있는 소켓의 수를 반환합니다. 없는 경우; 0이 반환됩니다. &lt;code&gt;Timeout&lt;/code&gt; 는 밀리 초이며 시간 초과없이 -1을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb7b92acc9a145b44981e2aafa578d392367d9b9" translate="yes" xml:space="preserve">
          <source>Transforms any iterator into a sequence.</source>
          <target state="translated">반복자를 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ab31ee25d07a8f9d5ddc9927e74c06ef43d27b4f" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;em&gt;replacements&lt;/em&gt; proc to substitute words inside &lt;em&gt;s&lt;/em&gt; with their replacements</source>
          <target state="translated">사용하여 문자열의 단어 번역 &lt;em&gt;교체의&lt;/em&gt; PROC 내부 단어로 대체합니다 &lt;em&gt;들&lt;/em&gt; 자신의 교체와 함께</target>
        </trans-unit>
        <trans-unit id="a7c36d78b13e6dda8f6d500d67c359740cbced46" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the indexes do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an array.</source>
          <target state="translated">노드를 순회하고 주어진 값을 얻습니다. 색인이 존재하지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 . 중간 데이터 구조 중 하나가 배열이 아닌 경우 에도 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3793e0cbf6a67e24ccddc9cfe73cf06db3bff8f2" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the keys do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an object.</source>
          <target state="translated">노드를 순회하고 주어진 값을 얻습니다. 키가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 중간 데이터 구조 중 하나가 오브젝트가 아닌 경우 에도 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9165124d411bbca6b0b36e2cf0040381f82a3771" translate="yes" xml:space="preserve">
          <source>Traverses the node and tries to set the value at the given location to &lt;code&gt;value&lt;/code&gt;. If any of the keys are missing, they are added.</source>
          <target state="translated">노드를 순회하고 지정된 위치의 값을 value로 설정하려고 &lt;code&gt;value&lt;/code&gt; . 누락 된 키가 있으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="156e25a6b8cf8a864963e049e7d35bac34d38d59" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;em&gt;true&lt;/em&gt; on success.</source>
          <target state="translated">주어진 잠금을 얻으려고 시도합니다. 성공하면 &lt;em&gt;true&lt;/em&gt; 를 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="468da52d5869ae376d9b95725718bd6ff03dd727" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="translated">쿼리 실행을 시도하고 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6f0489b14e1e492e61e5c98226d96a5ae8a905f" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;em&gt;c&lt;/em&gt;, but this can fail for all sort of reasons, including contention. If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="translated">채널 &lt;em&gt;c&lt;/em&gt; 에서 메시지를 받으려고 시도 하지만 경합을 포함하여 모든 종류의 이유로 실패 할 수 있습니다. 실패하면 &lt;code&gt;(false, default(msg))&lt;/code&gt; 반환하고 그렇지 않으면 &lt;code&gt;(true, msg)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="59e8185659254fff6635dee26e78e5d85bff42cc" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;em&gt;data&lt;/em&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="translated">브라우저 상태를 재설정하려고 시도하고 &amp;lt;plaintext&amp;gt; 태그에서 stdout에 &lt;em&gt;데이터&lt;/em&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1d1f450205803ed460a630c26002dda1d5353960" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread. &lt;em&gt;msg&lt;/em&gt; is deeply copied. Doesn't block. Returns &lt;em&gt;false&lt;/em&gt; if the message was not sent because number of pending items in the channel exceeded &lt;em&gt;maxItems&lt;/em&gt;.</source>
          <target state="translated">스레드에 메시지를 보내려고합니다. &lt;em&gt;msg&lt;/em&gt; 가 깊이 복사되었습니다. 차단하지 않습니다. 채널의 보류중인 항목 수가 &lt;em&gt;maxItems를&lt;/em&gt; 초과하여 메시지가 전송되지 않은 경우 &lt;em&gt;false를&lt;/em&gt; 리턴 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c7db82aabe0ec4b37ab6dba207f6dfa98f250d7" translate="yes" xml:space="preserve">
          <source>Trigger event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">트리거 이벤트 &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3c207482b9595dc0f6457a13d2f1e61c56e381" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value (&lt;em&gt;x&lt;/em&gt;). Modifies the passed value.</source>
          <target state="translated">형식이 지정된 부동 소수점 값 ( &lt;em&gt;x&lt;/em&gt; ) 에서 후행 0을 자릅니다 . 전달 된 값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="afddc6dcc2da91db52e6db34c078cda6ecf5a529" translate="yes" xml:space="preserve">
          <source>Triple quoted string literals</source>
          <target state="translated">삼중 인용 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="245ceee2586082dc5a73679c70b42d08a85510ee" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;x&lt;/em&gt; to the decimal point</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 소수점으로 자릅니다</target>
        </trans-unit>
        <trans-unit id="02715c4b7ff15274f4612905c77b4bda81876e45" translate="yes" xml:space="preserve">
          <source>Try can also be used as an expression; the type of the &lt;code&gt;try&lt;/code&gt; branch then needs to fit the types of &lt;code&gt;except&lt;/code&gt; branches, but the type of the &lt;code&gt;finally&lt;/code&gt; branch always has to be &lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">try는 표현식으로도 사용할 수 있습니다. &lt;code&gt;try&lt;/code&gt; 브랜치 의 타입은 브랜치를 &lt;code&gt;except&lt;/code&gt; 타입에 맞아야 하지만 &lt;code&gt;finally&lt;/code&gt; 브랜치 의 타입은 항상 &lt;code&gt;void&lt;/code&gt; 이어야합니다 :</target>
        </trans-unit>
        <trans-unit id="a7af062d7b75f8335dbdc49667ebc20f3bbd46f5" translate="yes" xml:space="preserve">
          <source>Try expression</source>
          <target state="translated">표현을 시도</target>
        </trans-unit>
        <trans-unit id="f526bd18e3a74520efcc9c43abfaeabfe401e20b" translate="yes" xml:space="preserve">
          <source>Try statement</source>
          <target state="translated">진술을보십시오</target>
        </trans-unit>
        <trans-unit id="8fb959bb7d8da3f5b1a99088eb043845c557941e" translate="yes" xml:space="preserve">
          <source>Tuple or object scope</source>
          <target state="translated">튜플 또는 객체 범위</target>
        </trans-unit>
        <trans-unit id="3f99aa09c1ddebfc55f57b61f023038ddf8cd672" translate="yes" xml:space="preserve">
          <source>Tuple unpacking</source>
          <target state="translated">튜플 포장 풀기</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="b3e2bebd3f6bc134f276b0e73ccd708819d73bd3" translate="yes" xml:space="preserve">
          <source>Tuples and object types</source>
          <target state="translated">튜플 및 객체 유형</target>
        </trans-unit>
        <trans-unit id="4591fb7e2e6af521b3d77017031f788c69e63561" translate="yes" xml:space="preserve">
          <source>Tuples can be &lt;em&gt;unpacked&lt;/em&gt; during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc from the &lt;a href=&quot;os&quot;&gt;os module&lt;/a&gt; which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! For example:</source>
          <target state="translated">변수 할당 중에 튜플의 &lt;em&gt;압축을 풀&lt;/em&gt; 수 있습니다 (그리고 나서야 !). 이것은 튜플의 필드를 개별적으로 명명 된 변수에 직접 할당하는 데 편리 할 수 ​​있습니다. 이에 대한 예제는 &lt;a href=&quot;os&quot;&gt;os 모듈&lt;/a&gt; 의 &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc 파일 로 경로, 디렉토리, 이름 및 확장자를 동시에 반환합니다. 튜플 포장 풀기 작업을 수행하려면 압축 풀기를 할당 할 값 주위에 괄호를 사용해야합니다. 그렇지 않으면 모든 개별 변수에 동일한 값을 할당하게됩니다! 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8352a113514bb2d5c1a998e7f4b0ab2c15a44826" translate="yes" xml:space="preserve">
          <source>Tuples which are longer than one line should indent their parameters to align with the parameters above it.</source>
          <target state="translated">한 줄보다 긴 튜플은 매개 변수를 들여 쓰기하여 그 위에있는 매개 변수와 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b346e4953356d44049c162bd3c503c985bc5b32" translate="yes" xml:space="preserve">
          <source>Turn a deque into its string representation.</source>
          <target state="translated">deque를 문자열 표현으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8743e385990daa129ed7fd77c0aab253383cfcf0" translate="yes" xml:space="preserve">
          <source>Turn a rational number into a string.</source>
          <target state="translated">유리수를 문자열로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="6530f1075ffd79f7adf57fbf48c454fea802b4a4" translate="yes" xml:space="preserve">
          <source>Turning the &lt;code&gt;log&lt;/code&gt; proc into a template solves this problem:</source>
          <target state="translated">회전 &lt;code&gt;log&lt;/code&gt; 템플릿에 PROC하면이 문제를 해결할 수 :</target>
        </trans-unit>
        <trans-unit id="8bcf0ab5d7d983b90173092de9a62442f37e633f" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;em&gt;new&lt;/em&gt; operator</source>
          <target state="translated">일반 함수 호출을 JavaScript의 &lt;em&gt;새&lt;/em&gt; 연산자 호출로 변환</target>
        </trans-unit>
        <trans-unit id="fd4a9c5e9fbeb1731e11e217df10a5e9df4c2462" translate="yes" xml:space="preserve">
          <source>Turns off runtime checks and turns on the optimizer.</source>
          <target state="translated">런타임 검사를 끄고 옵티 마이저를 켭니다.</target>
        </trans-unit>
        <trans-unit id="8f84b7302f8b2c0acedd7493fcbdb678ea820d7e" translate="yes" xml:space="preserve">
          <source>Turns the code generation for all runtime checks on or off.</source>
          <target state="translated">모든 런타임 검사에 대한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="8359c50c168a0d32c1676689b7b9be53909574c9" translate="yes" xml:space="preserve">
          <source>Turns the code generation for array bound checks on or off.</source>
          <target state="translated">배열 바운드 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="78de984f73e6a96b608abf84f509342b6416676c" translate="yes" xml:space="preserve">
          <source>Turns the code generation for assertions on or off.</source>
          <target state="translated">어설 션에 대한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="f85728da201c7e87406c7977edcd7efb848370e2" translate="yes" xml:space="preserve">
          <source>Turns the code generation for nil pointer checks on or off.</source>
          <target state="translated">nil 포인터 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="7443a6fe5c166cf5312e85d734da57674e23a9ea" translate="yes" xml:space="preserve">
          <source>Turns the code generation for over- or underflow checks on or off.</source>
          <target state="translated">오버 플로우 또는 언더 플로우 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="634d9e7817c9bcc8bdbbd8305a699f04a3c9ba2f" translate="yes" xml:space="preserve">
          <source>Turns the hint messages of the compiler on or off.</source>
          <target state="translated">컴파일러의 힌트 메시지를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="96dcbf296f2f4c34221163dd4a790e8efb28f099" translate="yes" xml:space="preserve">
          <source>Turns the term rewriting templates/macros on or off.</source>
          <target state="translated">템플릿 / 매크로 다시 쓰기 용어를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="f31cc462c8ec7105eb07e2c1b5bb943c21db3b4d" translate="yes" xml:space="preserve">
          <source>Turns the warning messages of the compiler on or off.</source>
          <target state="translated">컴파일러의 경고 메시지를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="779de5f9680bb0a0d05277f00d89d734c054b346" translate="yes" xml:space="preserve">
          <source>Tutorial (part I)</source>
          <target state="translated">튜토리얼 (1 부)</target>
        </trans-unit>
        <trans-unit id="e8a76eed53f23547280f2ddf6517628c83064326" translate="yes" xml:space="preserve">
          <source>Tutorial (part II)</source>
          <target state="translated">튜토리얼 (2 부)</target>
        </trans-unit>
        <trans-unit id="e5778f261d1733e81971ab8e088ac48fafe7c0eb" translate="yes" xml:space="preserve">
          <source>Tweaking the GC</source>
          <target state="translated">GC 조정</target>
        </trans-unit>
        <trans-unit id="778080b9d6142ab857443b50014ddb8d3ccd44e2" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Timezone&lt;/code&gt;'s are considered equal if their name is equal.</source>
          <target state="translated">이름이 같으면 두 개의 &lt;code&gt;Timezone&lt;/code&gt; 가 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6a865c6e91cc1b9c8041b930bdded2be0556b0e5" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equal if the following algorithm returns true:</source>
          <target state="translated">다음 알고리즘이 true를 반환하면 두 식별자가 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6298e080874877d7a98b594edb938f20831dfff6" translate="yes" xml:space="preserve">
          <source>Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.</source>
          <target state="translated">블록의 들여 쓰기에는 두 개의 공백이 사용되어야합니다. tabstop은 허용되지 않습니다 (컴파일러가이를 시행합니다). 공백을 사용한다는 것은 코드 전체가 편집기에서보다 일관되게 나타납니다. 공백과 달리 탭 스톱 너비는 편집기마다 다르며 모든 편집기가이 너비를 변경하는 수단을 제공하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="1e4286f84aa2ec1726d2f29d48fef0c9bf605e85" translate="yes" xml:space="preserve">
          <source>Type Classes</source>
          <target state="translated">타입 클래스</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eb387e477546545eec601f050672bd06c02038" translate="yes" xml:space="preserve">
          <source>Type Suffix</source>
          <target state="translated">접미사</target>
        </trans-unit>
        <trans-unit id="517963ffe8430bed0d4f132dcd51c0d4eb3001b7" translate="yes" xml:space="preserve">
          <source>Type bound operations</source>
          <target state="translated">타입 바운드 연산</target>
        </trans-unit>
        <trans-unit id="b2ce942200cd4ed497c93d87123ffa3584d50070" translate="yes" xml:space="preserve">
          <source>Type casts</source>
          <target state="translated">캐스트</target>
        </trans-unit>
        <trans-unit id="bf3e880739673e946c25d0dedcde2653a7c48216" translate="yes" xml:space="preserve">
          <source>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</source>
          <target state="translated">타입 캐스트는 표현식의 비트 패턴을 마치 다른 타입 인 것처럼 해석하는 조잡한 메커니즘입니다. 타입 캐스트는 저수준 프로그래밍에만 필요하며 본질적으로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f21eb352df05ecea6a3a588dc0c8590e21dbccc2" translate="yes" xml:space="preserve">
          <source>Type classes can be combined using the standard boolean operators to form more complex type classes:</source>
          <target state="translated">표준 부울 연산자를 사용하여 형식 클래스를 결합하여보다 복잡한 형식 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d7f20ec3a1f2c32685f21a24578ef7bfd33afb" translate="yes" xml:space="preserve">
          <source>Type conversions</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="7893cb518df1f3e86b37b8f2c89bf262fddc71ea" translate="yes" xml:space="preserve">
          <source>Type conversions are a much more polite way to convert a type into another: They preserve the abstract &lt;em&gt;value&lt;/em&gt;, not necessarily the &lt;em&gt;bit-pattern&lt;/em&gt;. If a type conversion is not possible, the compiler complains or an exception is raised.</source>
          <target state="translated">형식 변환은 형식을 다른 형식으로 변환하는 훨씬 더 정중 한 방법 &lt;em&gt;입니다&lt;/em&gt; . 반드시 &lt;em&gt;비트 패턴이&lt;/em&gt; 아닌 추상 &lt;em&gt;값을&lt;/em&gt; 유지합니다 . 유형 변환이 불가능하면 컴파일러가 불평하거나 예외가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d227e4926b1f493d28e95f292386e3a242d08693" translate="yes" xml:space="preserve">
          <source>Type conversions are compile-time computable.</source>
          <target state="translated">타입 변환은 컴파일 타임 계산 가능합니다.</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5ad7af6975f8633efeb665458c5b9ad70586b8" translate="yes" xml:space="preserve">
          <source>Type equality modulo type distinction</source>
          <target state="translated">타입 평등 모듈로 타입 구별</target>
        </trans-unit>
        <trans-unit id="c5a4537d409bc84d0e6885dd98224efa069a4125" translate="yes" xml:space="preserve">
          <source>Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which &lt;strong&gt;may&lt;/strong&gt; use PascalCase but are not required to.</source>
          <target state="translated">타입 식별자는 PascalCase에 있어야합니다. PascalCase를 사용할 &lt;strong&gt;수&lt;/strong&gt; 있지만 필수는 아닌 상수를 제외하고 다른 모든 식별자는 camelCase에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f50bbe8baba25a1929146d13b1d95279794e199" translate="yes" xml:space="preserve">
          <source>Type of the symbol. This can be &lt;code&gt;skProc&lt;/code&gt;, &lt;code&gt;skLet&lt;/code&gt;, and just about any of the enums defined in the module &lt;code&gt;compiler/ast.nim&lt;/code&gt;.</source>
          <target state="translated">심볼의 유형입니다. 이것은 &lt;code&gt;skProc&lt;/code&gt; , &lt;code&gt;skLet&lt;/code&gt; 일 수 있으며 모듈 &lt;code&gt;compiler/ast.nim&lt;/code&gt; 에 정의 된 열거 형 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b2d40508694dd4577a697d9c6b4c5f2e3511da" translate="yes" xml:space="preserve">
          <source>Type section</source>
          <target state="translated">유형 섹션</target>
        </trans-unit>
        <trans-unit id="19ed3f78d17ddb423376e5e7d24d9be0086053f6" translate="yes" xml:space="preserve">
          <source>Type sections</source>
          <target state="translated">유형 섹션</target>
        </trans-unit>
        <trans-unit id="a919a22549142ebb39423637cf5e8cc1b5dc6cbb" translate="yes" xml:space="preserve">
          <source>Type that describes &quot;standard format specifiers&quot;.</source>
          <target state="translated">&quot;표준 형식 지정자&quot;를 설명하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="33ed1febf2dc93666a9e94d3bca2653e2f2eba89" translate="yes" xml:space="preserve">
          <source>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. &lt;code&gt;proc (File)&lt;/code&gt;).</source>
          <target state="translated">타입 / 서명. 변수 및 열거 형의 경우 여기에는 기호 유형이 포함되며, 프로세스, 메소드 및 템플릿의 경우 완전한 고유 서명 (예 : &lt;code&gt;proc (File)&lt;/code&gt; )이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5204c9867a362caf0bea9525b902dfe2dc066c0b" translate="yes" xml:space="preserve">
          <source>Typed future.</source>
          <target state="translated">미래를 입력했습니다.</target>
        </trans-unit>
        <trans-unit id="a1cf3d18ff7e16dcb6cdb495e43f6f5c061a5575" translate="yes" xml:space="preserve">
          <source>Typed vs untyped parameters</source>
          <target state="translated">유형화되지 않은 매개 변수</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5720ec6d00feb96f366d8679918ecb98f50f66f7" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;code&gt;connect&lt;/code&gt; procedure. They can simply start sending data immediately.</source>
          <target state="translated">UDP는 비 연결 프로토콜이므로 UDP 소켓은 &lt;code&gt;connect&lt;/code&gt; 절차 를 명시 적으로 호출 할 필요가 없습니다 . 그들은 단순히 데이터를 즉시 보내기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9248393d371f6ac0d6c435085d705c597add4700" translate="yes" xml:space="preserve">
          <source>UNIX domain socket.</source>
          <target state="translated">UNIX 도메인 소켓</target>
        </trans-unit>
        <trans-unit id="5994d61577cd9a76d59a20c617c73875837d1477" translate="yes" xml:space="preserve">
          <source>UNIX specific</source>
          <target state="translated">유닉스 전용</target>
        </trans-unit>
        <trans-unit id="d9b8776f6733aef4d62e2f6de4be839fb81aa572" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;+&lt;/em&gt; operator for an integer. Has no effect.</source>
          <target state="translated">정수에 대한 단항 &lt;em&gt;+&lt;/em&gt; 연산자. 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb73268790c9b1bb4d1863a2400ec7e0bd4b9f82" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;-&lt;/em&gt; operator for an integer. Negates &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">단항 &lt;em&gt;-&lt;/em&gt; 정수 연산자. &lt;em&gt;x를&lt;/em&gt; 부정 합니다.</target>
        </trans-unit>
        <trans-unit id="70afc8908f864590618bb835ddbe12b01425b489" translate="yes" xml:space="preserve">
          <source>Unary minus for complex numbers.</source>
          <target state="translated">복소수에 대한 단항 빼기.</target>
        </trans-unit>
        <trans-unit id="2b26f2db358e2b9c8ee6c1ec77a16447b17be07f" translate="yes" xml:space="preserve">
          <source>Unary minus for rational numbers.</source>
          <target state="translated">유리수에 대한 단항 빼기.</target>
        </trans-unit>
        <trans-unit id="26886835eb6cc81330ad426b552f908727e34bfa" translate="yes" xml:space="preserve">
          <source>Unary operators always bind stronger than any binary operator: &lt;code&gt;$a + b&lt;/code&gt; is &lt;code&gt;($a) + b&lt;/code&gt; and not &lt;code&gt;$(a + b)&lt;/code&gt;.</source>
          <target state="translated">단항 연산자는 항상 이항 연산자보다 강력하게 바인딩됩니다. &lt;code&gt;$a + b&lt;/code&gt; 는 &lt;code&gt;$(a + b)&lt;/code&gt; 아니라 &lt;code&gt;($a) + b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15caf31c9aaa57bf878b33c847d4e21c87bdd599" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;em&gt;==&lt;/em&gt; operator and also when types dependent on them are being matched:</source>
          <target state="translated">바인딩되지 않은 정적 매개 변수는 &lt;em&gt;==&lt;/em&gt; 연산자를 포함하는 표현식과 해당 유형에 종속 된 유형이 일치 할 때 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="3eb24ca63e88421d2f543a770d935d8deff96d75" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;em&gt;s.push(T)&lt;/em&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;em&gt;x.pop is T&lt;/em&gt; and &lt;em&gt;x.data is seq[T]&lt;/em&gt;.</source>
          <target state="translated">언 바운드 유형은 &lt;em&gt;.s.push (T)&lt;/em&gt; 와 같은 호출에 대한 매개 변수 와 &lt;em&gt;x.pop이 T&lt;/em&gt; 이고 &lt;em&gt;x.data가 seq [T] 인&lt;/em&gt; 경우 &lt;code&gt;is&lt;/code&gt; 연산자 의 오른쪽에 모두 표시 될 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a277ebe87b91b0033079926c198a2b95dd5a89ed" translate="yes" xml:space="preserve">
          <source>Unchecked pragma</source>
          <target state="translated">확인되지 않은 pragma</target>
        </trans-unit>
        <trans-unit id="780b27a9e0cd026ae3df440893ad4cc13c021cef" translate="yes" xml:space="preserve">
          <source>Under Windows, &lt;code&gt;ShellExecute&lt;/code&gt; is used. Under Mac OS X the &lt;code&gt;open&lt;/code&gt; command is used. Under Unix, it is checked if &lt;code&gt;xdg-open&lt;/code&gt; exists and used if it does. Otherwise the environment variable &lt;code&gt;BROWSER&lt;/code&gt; is used to determine the default browser to use.</source>
          <target state="translated">Windows에서는 &lt;code&gt;ShellExecute&lt;/code&gt; 가 사용됩니다. Mac OS X에서는 &lt;code&gt;open&lt;/code&gt; 명령이 사용됩니다. 유닉스에서는 &lt;code&gt;xdg-open&lt;/code&gt; 이 존재 하는지 검사 하고 존재한다면 사용합니다. 그렇지 않으면 환경 변수 &lt;code&gt;BROWSER&lt;/code&gt; 를 사용하여 사용할 기본 브라우저를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="edbf8b89716eab57348a639af00765efe9e3f101" translate="yes" xml:space="preserve">
          <source>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</source>
          <target state="translated">언더 플로 : 연산은 너무 작아서 일반 숫자로 표현하기에 너무 작습니다 (예 : MINDOUBLE * MINDOUBLE).</target>
        </trans-unit>
        <trans-unit id="9ec38b8f74e8905e6cb3c56b8e4d8603f3e7c7d9" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;s를&lt;/em&gt; 이스케이프 해제 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b681f3dab8eeb99f700c878d07af066931b521" translate="yes" xml:space="preserve">
          <source>Unfortunately optimizations are hard to get right and even the tiny example is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">불행히도 최적화는 올바르게 수행하기가 어렵고 작은 예제조차 &lt;strong&gt;잘못되었습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="979fe2a9e37e36b1d1a6a4517ab5b601b5d48fdb" translate="yes" xml:space="preserve">
          <source>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</source>
          <target state="translated">불행히도 try 문의 의미가 항상 정확하지 않을 수도 있고 컴파일이 완전히 실패 할 수도 있습니다. 따라서 가능하면 전자를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fab317435de1ae8699f1bac973f0926492ea1744" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;d + 12.Dollar&lt;/code&gt; is not allowed either, because &lt;code&gt;+&lt;/code&gt; is defined for &lt;code&gt;int&lt;/code&gt; (among others), not for &lt;code&gt;Dollar&lt;/code&gt;. So a &lt;code&gt;+&lt;/code&gt; for dollars needs to be defined:</source>
          <target state="translated">불행히도, &lt;code&gt;d + 12.Dollar&lt;/code&gt; 때문에, 어느 허용되지 &lt;code&gt;+&lt;/code&gt; 가 정의되어 &lt;code&gt;int&lt;/code&gt; 아닌 다른 사람 () &lt;code&gt;Dollar&lt;/code&gt; . 따라서 달러 에 &lt;code&gt;+&lt;/code&gt; 를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="257828b764d9609e93e07a012bbe1f755b3e4143" translate="yes" xml:space="preserve">
          <source>Unicast link-local address.</source>
          <target state="translated">유니 캐스트 링크 로컬 주소</target>
        </trans-unit>
        <trans-unit id="db89ced902c1b469d3ee6d37350cad15573da1b7" translate="yes" xml:space="preserve">
          <source>Unicast site-local address.</source>
          <target state="translated">유니 캐스트 사이트 로컬 주소</target>
        </trans-unit>
        <trans-unit id="20432d22d5eb062ea9c2106c1c80aefa6d897164" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">각 행 Unindents &lt;code&gt;s&lt;/code&gt; 에 의해 &lt;code&gt;count&lt;/code&gt; 량 &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924d62607597504901be1ad3edea9517a5c76a1f" translate="yes" xml:space="preserve">
          <source>Union pragma</source>
          <target state="translated">연합 프라 그마</target>
        </trans-unit>
        <trans-unit id="9fa0003b8a6b26c8afe5d3f50a8127082e93fdb8" translate="yes" xml:space="preserve">
          <source>Unknown file type.</source>
          <target state="translated">알 수없는 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="60d54b69a2b42e57628182cdd2fb4ccd4dc4e49e" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;em&gt;{.pure.}&lt;/em&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="translated">&lt;em&gt;{.pure.}&lt;/em&gt; pragma 로 표시되지 않은 경우 열거 형 멤버에는 열거 형 이름의 약어와 같이 식별 접두사가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d1db02d8fefccbf077d86e2884c344faded7045" translate="yes" xml:space="preserve">
          <source>Unless you explicitly use the &lt;code&gt;-o:filename.js&lt;/code&gt; switch as mentioned in the previous examples, the compiler will create a &lt;code&gt;filename.js&lt;/code&gt; file in the &lt;code&gt;nimcache&lt;/code&gt; directory using the name of your input nim file. There are no other temporary files generated, the output is always a single self contained &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">이전 예제에서 언급 한대로 &lt;code&gt;-o:filename.js&lt;/code&gt; 스위치 를 명시 적으로 사용하지 않으면 컴파일러는 입력 nim 파일의 이름을 사용하여 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리 에 &lt;code&gt;filename.js&lt;/code&gt; 파일을 만듭니다 . 다른 임시 파일이 생성되지 않으며 출력은 항상 하나의 자체 포함 된 &lt;code&gt;.js&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="555ac3aebe10e2203997f49b6308860e82f3cf38" translate="yes" xml:space="preserve">
          <source>Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;times&lt;/code&gt; stdlib modules instead.</source>
          <target state="translated">응용 프로그램에 매우 특정한 요구 사항이 있고 JavaScript 만 대상으로하지 않는 한 &lt;code&gt;math&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;times&lt;/code&gt; stdlib 모듈 의 관련 함수를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8a103bee5df59c3c762061b4c9d13541d1ab2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, this function will not raise an exception if the Future has not been finished.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 와 달리 ,이 함수는 Future가 완료되지 않은 경우 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86d3c06510e1a9b072a372d11ed5099a19477622" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;sockets.recvLine&lt;/code&gt; this function will raise an EOS or ESSL exception if an error occurs.</source>
          <target state="translated">&lt;code&gt;sockets.recvLine&lt;/code&gt; 과 달리이 함수는 오류가 발생하면 EOS 또는 ESSL 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e750c92c37341f3392054d626734256f8a0787c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual paramater with &lt;a href=&quot;#paramStr&quot;&gt;paramStr()&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">C의 &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; 와 달리 바이너리가 매개 변수없이 호출되면 0이 반환됩니다. &lt;a href=&quot;#paramStr&quot;&gt;paramStr ()을 사용&lt;/a&gt; 하여 각 개별 매개 변수를 쿼리 하거나 &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams ()&lt;/a&gt; 을 사용하여 모든 매개 변수를 한 번에 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="834e7e344f224920e087953eb402fca07a2f1f3c" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="translated">다른 IO 작업과 달리 &lt;code&gt;echo&lt;/code&gt; 는 디버깅 편의를 위해 자주 사용 되므로 스레드로부터 안전 합니다. 당신이 사용하려는 경우 &lt;code&gt;echo&lt;/code&gt; 돌며 &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;부작용없이 PROC&lt;/a&gt; 당신이 사용할 수있는 &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="22870d2d3c9ed068f87598a420f675c1914b8e0c" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;em&gt;PROC의&lt;/em&gt; 버전 술어가 필요하여 표현 될 &lt;code&gt;it&lt;/code&gt; : 같은 테스트를 위해 변수 &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7abf83a8fb810b07df5666c0186be330c1d74dbb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;proc&lt;/em&gt; 버전 과 달리 술어는 테스트 를 위해 &lt;code&gt;it&lt;/code&gt; 변수를 사용하는 표현식이어야합니다 . &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21aec3b4730e3f9365e0105b5ee932445d7a6ca" translate="yes" xml:space="preserve">
          <source>Unmarshalling JSON into a type</source>
          <target state="translated">JSON을 형식으로 비 정렬 화</target>
        </trans-unit>
        <trans-unit id="274fd6abb97e41f164eb1ef8fe9181521b3bcfb9" translate="yes" xml:space="preserve">
          <source>Unregisters &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; 등록을 취소 합니다.</target>
        </trans-unit>
        <trans-unit id="cc5d6ca9aa56c6378bdd4192beb1a23d43d8436b" translate="yes" xml:space="preserve">
          <source>Unregisters deleg &lt;code&gt;deleg&lt;/code&gt; from dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">디스패처 &lt;code&gt;d&lt;/code&gt; 에서 위임 &lt;code&gt;deleg&lt;/code&gt; 을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="da32f8ccff4f9629c24e55368ee80c187804e943" translate="yes" xml:space="preserve">
          <source>Unregisters event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">이벤트 &lt;code&gt;ev&lt;/code&gt; 를 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="fcde071a887a5fe31b2a030c3e5fa7b13b8951b5" translate="yes" xml:space="preserve">
          <source>Unregisters file/socket descriptor &lt;code&gt;fd&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">선택기 &lt;code&gt;s&lt;/code&gt; 에서 파일 / 소켓 디스크립터 &lt;code&gt;fd&lt;/code&gt; 를 등록 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="289ac9aad529193af73566b90baf875386cf6586" translate="yes" xml:space="preserve">
          <source>Unregisters user-defined event &lt;code&gt;ev&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">등록을 해제 사용자 정의 이벤트 &lt;code&gt;ev&lt;/code&gt; 선택에서 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce62d653fe1244a4a172cf34cf9ff901d873cb95" translate="yes" xml:space="preserve">
          <source>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</source>
          <target state="translated">서명되지 않은 작업은 모두 마무리됩니다. 오버플로 또는 언더 플로 오류가 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="793e97a099a191f13d3623cc72e9fcc4ea98314f" translate="yes" xml:space="preserve">
          <source>Unspecified address.</source>
          <target state="translated">지정되지 않은 주소</target>
        </trans-unit>
        <trans-unit id="c2eed1f531c71d473a16fbfc4bdc992980d7fde4" translate="yes" xml:space="preserve">
          <source>Untyped future.</source>
          <target state="translated">형식화되지 않은 미래.</target>
        </trans-unit>
        <trans-unit id="338a06f904b267724d0e4a6607e91229e8bd5122" translate="yes" xml:space="preserve">
          <source>Unused symbols in the code.</source>
          <target state="translated">코드에서 사용되지 않은 기호.</target>
        </trans-unit>
        <trans-unit id="b761e5e6e2982b87d1d1ce7451421af2e056fcdd" translate="yes" xml:space="preserve">
          <source>Update file/socket descriptor &lt;code&gt;fd&lt;/code&gt;, registered in selector &lt;code&gt;s&lt;/code&gt; with new events set &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">업데이트 파일 / 소켓 기술자 &lt;code&gt;fd&lt;/code&gt; , 셀렉터에 등록 &lt;code&gt;s&lt;/code&gt; 새로운 이벤트 세트 &lt;code&gt;event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90ac74192ba332a2e96c10e6e3a98aa5ef90a38c" translate="yes" xml:space="preserve">
          <source>Uploading a new file</source>
          <target state="translated">새 파일 업로드</target>
        </trans-unit>
        <trans-unit id="8437e83622dcd6616eee43bc0f900abcc44066bc" translate="yes" xml:space="preserve">
          <source>Uploads &lt;code&gt;file&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvStore&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the upload is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">원격 FTP 서버 에서 &lt;code&gt;dest&lt;/code&gt; 으로 &lt;code&gt;file&lt;/code&gt; 을 업로드 합니다. 다운로드 진행 상황을 보려면이 기능을 비동기 적으로 사용하는 것이 좋습니다. &lt;code&gt;EvStore&lt;/code&gt; 의 이벤트는 지정된에 전달 &lt;code&gt;handleEvent&lt;/code&gt; 업로드가 완료 될 때 기능과 &lt;code&gt;filename&lt;/code&gt; 필드와 동일합니다 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37b7ab0e221278f7b19c0e2120c647473f14e9c5" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;shallow&lt;/code&gt; is always safe once you know the string won't be modified anymore, similar to Ruby's &lt;span id=&quot;freeze_1&quot;&gt;freeze&lt;/span&gt;.</source>
          <target state="translated">의 사용 &lt;code&gt;shallow&lt;/code&gt; 루비의 유사, 문자열이 더 이상 수정되지 않습니다 알면 항상 안전 &lt;span id=&quot;freeze_1&quot;&gt;동결&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="e50c56f66708798022fbc1f1eb983ee9aeeb0b23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initSet&quot;&gt;initSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">사용 &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;의 init ()&lt;/a&gt; 또는 &lt;a href=&quot;#initSet&quot;&gt;initSet [유형] ()&lt;/a&gt; 이 다른 발동를 호출하기 전에.</target>
        </trans-unit>
        <trans-unit id="c1b9c2cf3847d0d4137fb09319498c7a48280b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">사용 &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;의 init ()&lt;/a&gt; 또는 &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet [유형] ()&lt;/a&gt; 이 다른 발동를 호출하기 전에.</target>
        </trans-unit>
        <trans-unit id="069c6a70b51730b216fe49517948e5c25ee3f68d" translate="yes" xml:space="preserve">
          <source>Use CamelCase, not underscored_identifiers.</source>
          <target state="translated">밑줄 _ 식별자가 아닌 CamelCase를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0419552b8b43316dc697b19a811e19aebbdcdf2" translate="yes" xml:space="preserve">
          <source>Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.</source>
          <target state="translated">가능한 경우보다 강력한 매크로, 템플릿, 반복자 및 변환기 기능 만 사용하여 proc을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee29cb81b4a1c27e3913f57892fcf63971ad6672" translate="yes" xml:space="preserve">
          <source>Use a space after a colon, but not before it.</source>
          <target state="translated">콜론 뒤에는 사용하지만 그 앞에는 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6eaeb50702c4af6019f309c53108d48c5e121d67" translate="yes" xml:space="preserve">
          <source>Use an ordinary proc/iterator, if possible.</source>
          <target state="translated">가능하면 일반적인 proc / iterator를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18016a67bd4f948da9845d49f07cb8371b4ab483" translate="yes" xml:space="preserve">
          <source>Use setjmp backend.</source>
          <target state="translated">setjmp 백엔드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f72ae5e3053e46a037835089c157a676efe9253b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;let&lt;/code&gt; statement (not the &lt;code&gt;var&lt;/code&gt; statement) when declaring variables that do not change within their scope. Using the &lt;code&gt;let&lt;/code&gt; statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.</source>
          <target state="translated">해당 범위 내에서 변경되지 않는 변수를 선언 할 때는 &lt;code&gt;let&lt;/code&gt; 문 ( &lt;code&gt;var&lt;/code&gt; 문이 아님)을 사용하십시오 . &lt;code&gt;let&lt;/code&gt; 문을 사용하면 변수를 변경할 수 없으며 코드를 읽는 사람들에게 코드의 목적을 더 잘 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66274d10986776dc87f06f202d0f3cb8c3fe3937" translate="yes" xml:space="preserve">
          <source>Use the linenoise library for interactive mode (not needed on Windows).</source>
          <target state="translated">대화식 모드에 대해서는 Linenoise 라이브러리를 사용하십시오 (Windows에서는 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="fa6549bd6999bce5cb0be51276ff5b08c60300d9" translate="yes" xml:space="preserve">
          <source>Use this if you want to use asyncio's dispatcher.</source>
          <target state="translated">asyncio의 디스패처를 사용하려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc79ccd7635f50d22e57841cdbe2adc22f78a697" translate="yes" xml:space="preserve">
          <source>Use this overload if one of the enums specified above does not contain what you need.</source>
          <target state="translated">위에 지정된 열거 중 하나에 필요한 내용이 포함되어 있지 않으면이 과부하를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="865aa831216ca96d4d105c4dd19b7daa3f190a58" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.</source>
          <target state="translated">'스폰'또는 직접 통화가 바람직한 지 여부를 빠르게 결정하려면이 절차를 사용하십시오. 'true'를 반환하면 'spawn'이 의미가있을 수 있습니다. 일반적으로 이것을 직접 호출 할 필요는 없습니다. 대신 'spawnX'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61bc2b4499c7c25fe666bf75531910175755c00e" translate="yes" xml:space="preserve">
          <source>Use uClibc instead of libc. (Relevant for Unix-like OSes)</source>
          <target state="translated">libc 대신 uClibc를 사용하십시오. (유닉스 계열 OS 관련)</target>
        </trans-unit>
        <trans-unit id="5f211d2e480794537e3020e2cfb5c46539ca8d42" translate="yes" xml:space="preserve">
          <source>Use ucontext backend.</source>
          <target state="translated">ucontext 백엔드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e128770cbe82e55e9551991395c199aea047021" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;asynchttpserver&lt;/code&gt; and &lt;code&gt;httpclient&lt;/code&gt; internally and should not be used by you.</source>
          <target state="translated">내부적 으로 &lt;code&gt;asynchttpserver&lt;/code&gt; 및 &lt;code&gt;httpclient&lt;/code&gt; 에서 사용되며 사용자가 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ff8732bc6e9c0c3e17ad4cc39e7b18e2c8e01853" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars).</source>
          <target state="translated">원자 (보통 문자)의 일치를 위해 scanp에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b02c3c02a1cba6f1b623a143ee4ff49577aeda10" translate="yes" xml:space="preserve">
          <source>Useful if performing parallel analysis of data series and need to re-combine parallel result sets</source>
          <target state="translated">데이터 계열의 병렬 분석을 수행하고 병렬 결과 세트를 다시 조합해야하는 경우 유용</target>
        </trans-unit>
        <trans-unit id="d51e8109e780dfdf6a418dbd0475739d284873d7" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:</source>
          <target state="translated">현재 반복 값으로 로컬 루프 변수를 캡처하기 위해 루프에서 클로저를 작성할 때 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="e62ab5dd60dc7797b971e6696b18be2c527a419c" translate="yes" xml:space="preserve">
          <source>User definable matchers</source>
          <target state="translated">사용자 정의 가능 매처</target>
        </trans-unit>
        <trans-unit id="cdb81abb7fd49094ec59b4c3147077b637691ca6" translate="yes" xml:space="preserve">
          <source>User defined matcher. Uses the proc &lt;code&gt;foo&lt;/code&gt; to perform the match. See below for more details.</source>
          <target state="translated">사용자 정의 매처. proc &lt;code&gt;foo&lt;/code&gt; 를 사용하여 일치를 수행합니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b935fbc2614493a2c4b14ccf26901cbcb010eb56" translate="yes" xml:space="preserve">
          <source>User defined operators are allowed. Nothing stops you from defining your own &lt;code&gt;@!?+~&lt;/code&gt; operator, but doing so may reduce readability.</source>
          <target state="translated">사용자 정의 연산자가 허용됩니다. 자신 만의 &lt;code&gt;@!?+~&lt;/code&gt; 연산자 를 정의 할 수있는 것은 없지만 가독성을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8f45c91aea8077d8fc0d06a397a16ed0dc1c79" translate="yes" xml:space="preserve">
          <source>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier &lt;code&gt;in&lt;/code&gt; to a parameter to make it contravariant or &lt;code&gt;out&lt;/code&gt; to make it covariant:</source>
          <target state="translated">사용자 정의 제네릭 형식은 일부 매개 변수와 관련하여 공변량 일 수도 있습니다. 기본적으로 모든 일반적인 PARAMS는 불변으로 간주됩니다,하지만 당신은 접두사 수정을 적용 할 수도 있습니다 &lt;code&gt;in&lt;/code&gt; 이 contravariant 또는 확인하기 위해 매개 변수 &lt;code&gt;out&lt;/code&gt; 확인하는 것이 공변 :</target>
        </trans-unit>
        <trans-unit id="cce325aeace53a2b93d052357d730389323d4341" translate="yes" xml:space="preserve">
          <source>UserRaw</source>
          <target state="translated">UserRaw</target>
        </trans-unit>
        <trans-unit id="e300487a9b9ba07551dbd02395ad2f5ceb2cd7ff" translate="yes" xml:space="preserve">
          <source>Uses &lt;em&gt;default&lt;/em&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 에서 유효하지 않은 값 &lt;em&gt;으로 기본값&lt;/em&gt; 을 사용합니다 . 비교는 스타일을 구분하지 않는 방식으로 수행됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91247aefaea76611ed3be253ec73d5452247797e" translate="yes" xml:space="preserve">
          <source>Uses the state to compute a new &lt;code&gt;uint64&lt;/code&gt; random number.</source>
          <target state="translated">상태를 사용하여 새로운 &lt;code&gt;uint64&lt;/code&gt; 난수 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82312a15160a4eb2e934bf4a7bfbfafc8e93262e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from math as m import pow&lt;/code&gt; works identically to the &lt;code&gt;as&lt;/code&gt; modifier with the &lt;code&gt;import&lt;/code&gt; statement, but wrapped in &lt;code&gt;nnkFromStmt&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;from math as m import pow&lt;/code&gt; 받는 동일하게 작동 &lt;code&gt;as&lt;/code&gt; 와 수정 &lt;code&gt;import&lt;/code&gt; 문, 그러나에 싸여 &lt;code&gt;nnkFromStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434eb8681f8aae0fc0009510a5ce82ae4ac62f77" translate="yes" xml:space="preserve">
          <source>Using HTTP POST</source>
          <target state="translated">HTTP POST 사용</target>
        </trans-unit>
        <trans-unit id="597d5caf1abedf8be885d6b02a498c8313c21cab" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;enum&lt;/code&gt; is similar to using an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">사용하여 &lt;code&gt;enum&lt;/code&gt; 사용하는 것과 비슷 &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2077b1edc67aa09ddf48ed8fc866598362c96a" translate="yes" xml:space="preserve">
          <source>Using statement</source>
          <target state="translated">성명서 사용</target>
        </trans-unit>
        <trans-unit id="9c0ffb656f43cb27f5cdd45b79d0245f11508098" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;#assert&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#assert&quot;&gt;assert () 템플릿&lt;/a&gt; 을 사용한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="c8b613dc5bf77d7eebd40398bbfcda8a848bcf8f" translate="yes" xml:space="preserve">
          <source>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type &lt;code&gt;untyped&lt;/code&gt;. Because symbol lookups are then delayed until template instantiation time:</source>
          <target state="translated">일반적으로 코드 블록을 템플리트에 전달하려면 블록을 승인하는 매개 변수 유형이 &lt;code&gt;untyped&lt;/code&gt; 이어야 합니다. 그러면 템플릿 인스턴스화 시간까지 심볼 조회가 지연되기 때문에 :</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="94caea3c7c64ca00d9ac21ea83a77703d0e697ae" translate="yes" xml:space="preserve">
          <source>Var parameters</source>
          <target state="translated">Var 파라미터</target>
        </trans-unit>
        <trans-unit id="f94fe3891ba9b2a70b6f7c93dcf19ff406473182" translate="yes" xml:space="preserve">
          <source>Var return type</source>
          <target state="translated">Var 반환 유형</target>
        </trans-unit>
        <trans-unit id="ed0b2dfd47bbac896a3b7fa7c65e08461b5b0de0" translate="yes" xml:space="preserve">
          <source>Var section</source>
          <target state="translated">Var 섹션</target>
        </trans-unit>
        <trans-unit id="914863c14c6479013852278b1f8b3334db12b752" translate="yes" xml:space="preserve">
          <source>Var statement</source>
          <target state="translated">Var 문</target>
        </trans-unit>
        <trans-unit id="add491eaab149ea45f6c1fe0151b0684f58a9169" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</source>
          <target state="translated">Var 문은 새로운 지역 및 전역 변수를 선언하고 초기화합니다. 쉼표로 구분 된 변수 목록을 사용하여 동일한 유형의 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a8aad770addffb7c9ee321a2ae20d74343b6752" translate="yes" xml:space="preserve">
          <source>Varargs</source>
          <target state="translated">Varargs</target>
        </trans-unit>
        <trans-unit id="7d9fcf6d5d84f212e746c0dd60f0871afacbb237" translate="yes" xml:space="preserve">
          <source>Varargs matching</source>
          <target state="translated">Varargs 매칭</target>
        </trans-unit>
        <trans-unit id="1e1a470ac65b2238b82d8d8713eb8a548a3249ba" translate="yes" xml:space="preserve">
          <source>Varargs of untyped</source>
          <target state="translated">형식화되지 않은 바라 그</target>
        </trans-unit>
        <trans-unit id="77559312e7c433e8e5ee29c1bb6cbeca9a08ec04" translate="yes" xml:space="preserve">
          <source>Varargs pragma</source>
          <target state="translated">바라크 프라 그마</target>
        </trans-unit>
        <trans-unit id="805fa97816cdbe137bc65aece5e19b6969589e6d" translate="yes" xml:space="preserve">
          <source>Variables can also be reordered as well. Variables that are &lt;em&gt;initialized&lt;/em&gt; (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</source>
          <target state="translated">변수도 재정렬 할 수 있습니다. 하는 변수 &lt;em&gt;초기화&lt;/em&gt; 그들의 전체 초기화 문을 다시 정렬 할 수 있습니다 (자신의 선언과 하나의 문장으로 결합 할당을 즉, 변수). 최상위 레벨에서 어떤 코드가 실행되는지주의하십시오.</target>
        </trans-unit>
        <trans-unit id="f285e0b395df604d798c7e2bb2b23e2eae4f1e8f" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;recvFrom&lt;/code&gt; for non-blocking sockets. Unlike &lt;code&gt;recvFrom&lt;/code&gt;, this function will raise an EOS error whenever a socket error occurs.</source>
          <target state="translated">비 블로킹 소켓 의 &lt;code&gt;recvFrom&lt;/code&gt; 변형 . &lt;code&gt;recvFrom&lt;/code&gt; 과 달리이 함수는 소켓 오류가 발생할 때마다 EOS 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="37a9cbeb25f6e324f126507ad323389964644919" translate="yes" xml:space="preserve">
          <source>Variant of select with only a read and write list.</source>
          <target state="translated">읽기 및 쓰기 목록 만있는 선택의 변형</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="c0e92bae9fcb6a7281bd801df9748260bc15749f" translate="yes" xml:space="preserve">
          <source>Verbatim string match for back reference.</source>
          <target state="translated">역 참조를위한 완전 문자열 일치.</target>
        </trans-unit>
        <trans-unit id="be6cf59698ac3aaae8c44d3c15b6e3e4cda4c5a2" translate="yes" xml:space="preserve">
          <source>Verbatim string match: Use this to override a global &lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\y&lt;/code&gt; modifier.</source>
          <target state="translated">완전 문자열 일치 : 전역 &lt;code&gt;\i&lt;/code&gt; 또는 &lt;code&gt;\y&lt;/code&gt; 수정자를 재정의하려면이 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f86f02d25018ae2892b7bd1afddf0b541788d2" translate="yes" xml:space="preserve">
          <source>Verbosity levels</source>
          <target state="translated">상세 수준</target>
        </trans-unit>
        <trans-unit id="c12b4e999b16e9b02d25b9fcdd67d4fd655e16ae" translate="yes" xml:space="preserve">
          <source>Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if &lt;code&gt;outputLevel&lt;/code&gt; is not &lt;code&gt;PRINT_NONE&lt;/code&gt;). Example:</source>
          <target state="translated">명령문 또는 명령문 목록이 참인지 확인하십시오. 유용한 오류 메시지 및 설정 체크 포인트가 실패시 출력됩니다 ( &lt;code&gt;outputLevel&lt;/code&gt; 이 &lt;code&gt;PRINT_NONE&lt;/code&gt; 이 아닌 경우 ). 예:</target>
        </trans-unit>
        <trans-unit id="bf92590226e4f935af31645efa1ac42d722021ca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeImpl&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 를 취하는 &lt;code&gt;getTypeImpl&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="57aa9247bf27c4880a6334aaec93af41db7006d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeInst&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 를 취하는 &lt;code&gt;getTypeInst&lt;/code&gt; 버전 .</target>
        </trans-unit>
        <trans-unit id="858b1e6c9eca4cf7c78fcd8fab9318b40196ab03" translate="yes" xml:space="preserve">
          <source>Viceversa, one can also use &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; to declare that &lt;code&gt;SYMBOL&lt;/code&gt; should be considered not defined, and hence skip &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; sections.</source>
          <target state="translated">viceversa에, 하나는 또한 사용할 수 있습니다 &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; 선언하는 &lt;code&gt;SYMBOL&lt;/code&gt; 정의되지 고려되어야한다, 따라서 생략 &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; 섹션.</target>
        </trans-unit>
        <trans-unit id="f9b4a6297c88554060939c3b1d4cb2536eb7bee3" translate="yes" xml:space="preserve">
          <source>Void context</source>
          <target state="translated">공허한 맥락</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962f34b2afbbced77fbbf76af036107dbe53ad9d" translate="yes" xml:space="preserve">
          <source>Volatile pragma</source>
          <target state="translated">휘발성 프라 그마</target>
        </trans-unit>
        <trans-unit id="a1c74f4c3dc47b71577d22318b41d7984b1abbb7" translate="yes" xml:space="preserve">
          <source>Waiting for a subprocess to finish. A subprocess can be started, but right now it can't be waited on, which sort of makes subprocesses a bit hard to use</source>
          <target state="translated">서브 프로세스가 완료되기를 기다리는 중입니다. 하위 프로세스를 시작할 수는 있지만 지금은 기다릴 수 없으므로 하위 프로세스를 사용하기가 조금 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e74d0d5b2aa91ca4f2eda490c658dd7df90ccca2" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available.</source>
          <target state="translated">완료 이벤트를 대기하고 처리합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 대기중인 작업이없는 경우. &lt;code&gt;poll&lt;/code&gt; 과 달리이 프로세스는 사용 가능한 많은 이벤트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8c6c37027d7f2e6c6ab4b80a9728bdfd41e4de6e" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. This runs the underlying OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; or &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; primitive only once.</source>
          <target state="translated">완료 이벤트를 대기하고 처리합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 대기중인 작업이없는 경우. 기본 OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; 또는 &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; 프리미티브를 한 번만 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="7309ba8763f2cd6a0b2e52be4a1bdf5400867492" translate="yes" xml:space="preserve">
          <source>Waits for events registered in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">셀렉터에 등록 이벤트에 대한 대기 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a009040341eedf69627aff9b5c29bf4b8425403d" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;em&gt;filters&lt;/em&gt; controls the behaviour of the iterator:</source>
          <target state="translated">걷기는 재귀 적입니다. &lt;em&gt;필터&lt;/em&gt; 는 반복자의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="8fd311d8cb591a6fc0622efcf10ea3ea470116f2" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;em&gt;path&lt;/em&gt;</source>
          <target state="translated">주어진 &lt;em&gt;경로&lt;/em&gt; 의 모든 부모 디렉토리를 걷는다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f61ac580a8669e5f5ddb85827db56efd269d4d4" translate="yes" xml:space="preserve">
          <source>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</source>
          <target state="translated">경고 :이 기능은 차단 될 수 있습니다. 전체 파일 이름 목록을 검색해야하기 때문에 특히 많은 파일이있는 디렉토리에서.</target>
        </trans-unit>
        <trans-unit id="99a2a483409f9e01cee9aa93831fe0f06d054b92" translate="yes" xml:space="preserve">
          <source>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="translated">경고 : 이것은 실제로 'for'를 변형시키고 루프를 풀어줍니다. 현재 구현에는 루프 본문의 심볼 바인딩에 영향을주는 버그도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7412166e831c66d50243ea6b997febce22e1c0db" translate="yes" xml:space="preserve">
          <source>Warning: URL-encoded and Unicode attempts at directory traversal are not detected. Triple dot is not handled.</source>
          <target state="translated">경고 : 디렉토리 순회에서 URL 인코딩 및 유니 코드 시도가 감지되지 않습니다. 트리플 도트는 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0e0c14f084e128be516580f7f46caa6b881111d" translate="yes" xml:space="preserve">
          <source>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file &lt;code&gt;lib/system/hti.nim&lt;/code&gt; for more information.</source>
          <target state="translated">우리는 이미 컴파일러에서 타입 정보를 그래프로 알고 있습니다. 따라서이 코드를 C 코드 생성을위한 RTTI로 직렬화해야합니다. 자세한 정보는 &lt;code&gt;lib/system/hti.nim&lt;/code&gt; 파일을보십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2d825d8ef9b527c8f3ffcca749e04b73530ffc" translate="yes" xml:space="preserve">
          <source>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the &lt;code&gt;PSym&lt;/code&gt; datastructure, it should work without any special logic.</source>
          <target state="translated">일반 인스턴스를 캐시하고이 캐싱이 증분 컴파일 기능과 제대로 작동하는지 확인해야합니다. 캐시는 &lt;code&gt;PSym&lt;/code&gt; 데이터 구조에 연결되므로 특별한 논리없이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf6af0d4d4b7bb7491ad339f0cd6b4eecccde3c" translate="yes" xml:space="preserve">
          <source>We call a proc &lt;code&gt;p&lt;/code&gt;&lt;span id=&quot;gc-safe_1&quot;&gt;GC safe&lt;/span&gt; when it doesn't access any global variable that contains GC'ed memory (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or a closure) either directly or indirectly through a call to a GC unsafe proc.</source>
          <target state="translated">&lt;span id=&quot;gc-safe_1&quot;&gt;GC 안전&lt;/span&gt; 하지 않은 프로 시저에 대한 호출을 통해 GC의 메모리 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; 또는 클로저)를 직접 또는 간접적으로 포함하는 전역 변수에 액세스하지 않으면 proc &lt;code&gt;p&lt;/code&gt; &lt;span id=&quot;gc-safe_1&quot;&gt;GC safe를&lt;/span&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ba455d231bded2509ebd8f9d1e8763309c843c4f" translate="yes" xml:space="preserve">
          <source>We can &quot;replay&quot; &lt;code&gt;stCode.add&lt;/code&gt; only if the values of &lt;code&gt;st&lt;/code&gt; and &lt;code&gt;apicall&lt;/code&gt; are known. And even then a hash table's &lt;code&gt;add&lt;/code&gt; with its hashing mechanism is too hard to replay.</source>
          <target state="translated">&lt;code&gt;st&lt;/code&gt; 및 &lt;code&gt;apicall&lt;/code&gt; 의 값을 &lt;code&gt;stCode.add&lt;/code&gt; 있는 경우에만 stCode.add를 &quot;재생&quot;할 수 있습니다 . 그리고 해시 메커니즘 으로 해시 테이블을 &lt;code&gt;add&lt;/code&gt; 해도 재생하기가 너무 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="f6c15cc4bcae38711205717122d00cbaec2e62f3" translate="yes" xml:space="preserve">
          <source>We can achieve this using the &lt;code&gt;bindMethod&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;bindMethod&lt;/code&gt; 매크로를 사용하여이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31fc4caa6ec680ff0de718216907b6b39698fd69" translate="yes" xml:space="preserve">
          <source>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</source>
          <target state="translated">부작용이있는 표현식을 나타내는 경우 'a'를 복제 할 수 없습니다! 다행히 Nim은 부작용 분석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cc498265cc3ceafbd88456ff11eb0a32bb180e8f" translate="yes" xml:space="preserve">
          <source>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</source>
          <target state="translated">항상 내부 anon procs를 인라인하여 중첩 환경을 제거 할 수 있습니다. 그러나 환경의 이스케이프 분석 및 스택 할당이 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e11914dec9459002787db2ce90468c35fd15a6ab" translate="yes" xml:space="preserve">
          <source>We have already seen the simple &lt;code&gt;import&lt;/code&gt; statement that just imports all exported symbols. An alternative that only imports listed symbols is the &lt;code&gt;from import&lt;/code&gt; statement:</source>
          <target state="translated">우리는 이미 내 보낸 모든 심볼을 &lt;code&gt;import&lt;/code&gt; 간단한 import 문을 보았습니다 . 나열된 기호 만 가져 오는 대안은 &lt;code&gt;from import&lt;/code&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="59c4a855c5c497242383a03a1f691a7e5a85ba0a" translate="yes" xml:space="preserve">
          <source>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</source>
          <target state="translated">런타임에 참조가 스택에 있는지 여부를 결정해야합니다. 생성 된 코드는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf92005b68f4a7df3a08d2ee2fa3d3d923557d80" translate="yes" xml:space="preserve">
          <source>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</source>
          <target state="translated">Nim의 전역 변수에 의존하지 않음으로써 복잡한 앨리어싱 문제를 숨기는 API가 필요합니다. 확실한 해결책은 전역 변수 대신 문자열 키를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c36085b01e4f6e8f59835097cfb83f524dc4b57" translate="yes" xml:space="preserve">
          <source>We start the tour with a modified &quot;hello world&quot; program:</source>
          <target state="translated">수정 된 &quot;hello world&quot;프로그램으로 둘러보기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="41e38ed24e3a1be9264a0daea556df68c3aba5e6" translate="yes" xml:space="preserve">
          <source>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</source>
          <target state="translated">우리는 성공적인 의미 검사의 모듈의 AST를 SQLite 데이터베이스에 저장합니다. 하위 시퀀스를 다시 적용해야하는 많은 기능이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a8ba9ee33c2a6fb270c2b9858e20ee9e6e1de37" translate="yes" xml:space="preserve">
          <source>We use a mixture of bitset and hash table for this. The hash table maps &lt;em&gt;pages&lt;/em&gt; to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</source>
          <target state="translated">이를 위해 비트 셋과 해시 테이블을 혼합하여 사용합니다. 해시 테이블은 &lt;em&gt;페이지&lt;/em&gt; 를 페이지 디스크립터에 맵핑 &lt;em&gt;합니다&lt;/em&gt; . 페이지 디스크립터는이 페이지 내에서 가능한 모든 셀 주소에 대한 비트를 포함합니다. 따라서 셀 포함은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="aab20012d1620f5b85c5c37ea977935d4f505aea" translate="yes" xml:space="preserve">
          <source>We want to generate roughly this JavaScript:</source>
          <target state="translated">우리는 대략이 JavaScript를 생성하고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="113b69b591d6182bb037d0575303c945f53858ae" translate="yes" xml:space="preserve">
          <source>What is happening here is that the types used for table keys require to have a &lt;code&gt;hash()&lt;/code&gt; proc which will convert them to a &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; value, and the compiler is listing all the hash functions it knows. Additionally there has to be a &lt;code&gt;==&lt;/code&gt; operator that provides the same semantics as its corresponding &lt;code&gt;hash&lt;/code&gt; proc.</source>
          <target state="translated">여기서 발생하는 일은 테이블 키에 사용되는 형식 에 &lt;a href=&quot;hashes#Hash&quot;&gt;해시&lt;/a&gt; 값으로 변환 하는 &lt;code&gt;hash()&lt;/code&gt; proc이 있어야하며 컴파일러가 알고있는 모든 해시 함수를 나열한다는 것입니다. 또한 해당 &lt;code&gt;hash&lt;/code&gt; 프로세스 와 동일한 의미를 제공 하는 &lt;code&gt;==&lt;/code&gt; 연산자가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7366e079f6ffab6bc9ad768b8631449c4256e61f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="translated">대부분의 프로그래밍 언어에서 &lt;span id=&quot;methods_1&quot;&gt;메소드&lt;/span&gt; 또는 &lt;span id=&quot;functions_1&quot;&gt;함수&lt;/span&gt; 를 호출 하는 것을 Nim에서 &lt;span id=&quot;procedures_1&quot;&gt;프로 시저&lt;/span&gt; 라고 &lt;span id=&quot;procedures_1&quot;&gt;합니다&lt;/span&gt; . 프로 시저 선언은 식별자, 0 개 이상의 형식 매개 변수, 반환 값 유형 및 코드 블록으로 구성됩니다. 공식 매개 변수는 쉼표 또는 세미콜론으로 구분 된 식별자 목록으로 선언됩니다. 매개 변수는 &lt;code&gt;: typename&lt;/code&gt; 유형으로 제공됩니다 . 유형은 매개 변수 목록의 시작, 세미콜론 구분 기호 또는 이미 입력 된 매개 변수에 도달 할 때까지 모든 매개 변수에 바로 적용됩니다. 세미콜론을 사용하면 유형과 후속 식별자를보다 명확하게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dcfff2350bc510e79fd004ac68bd4cb1f311382" translate="yes" xml:space="preserve">
          <source>What optimizers really need to do is a &lt;em&gt;canonicalization&lt;/em&gt;:</source>
          <target state="translated">옵티마이 저가 실제로해야하는 것은 &lt;em&gt;정규화입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93ccfee40ae325efd18fb6ffe045c18cb229f18f" translate="yes" xml:space="preserve">
          <source>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to &lt;code&gt;cint&lt;/code&gt;. Testing without the &lt;code&gt;-w&lt;/code&gt; option helps!</source>
          <target state="translated">C 코드 생성 문제인 것처럼 보이는 것은 종종 프로토 타입을 생성하지 않아 발생하는 버그이므로 일부 유형은 기본적으로 &lt;code&gt;cint&lt;/code&gt; 입니다. &lt;code&gt;-w&lt;/code&gt; 옵션 없이 테스트 하면 도움이됩니다!</target>
        </trans-unit>
        <trans-unit id="06f4a3ec696cf15db4c5199b757938fbcc68be19" translate="yes" xml:space="preserve">
          <source>When 0 is returned the socket's connection has been closed.</source>
          <target state="translated">0이 반환되면 소켓의 연결이 종료 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5309ac6e6a926e840908775be647c2028a478adb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned the socket's connection has been closed.</source>
          <target state="translated">때 &lt;code&gt;&quot;&quot;&lt;/code&gt; 반환되는 소켓의 연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="017a1cdbf43acad895afedf8019b709fbd1b8c09" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a ref type then the resulting type will be &lt;code&gt;T&lt;/code&gt;, otherwise it will be &lt;code&gt;ref T&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;T&lt;/code&gt; 가 의 Ref 타입 후 얻어진 타입 것이다 &lt;code&gt;T&lt;/code&gt; , 그렇지 않으면 것이다 &lt;code&gt;ref T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a82a67761bf009b1ccc17019d024dead497b2c8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importcpp&lt;/code&gt; is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt;. (This turned out to be the simplest way to implement it.)</source>
          <target state="translated">&lt;code&gt;importcpp&lt;/code&gt; 가 열거 형에 적용될 때 숫자 열거 형 값은 다음 예제에서와 같이 C ++ 열거 형으로 주석이 추가됩니다 : &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt; . (이를 구현하는 가장 간단한 방법으로 밝혀졌습니다.)</target>
        </trans-unit>
        <trans-unit id="46a139f37abab95c9bed1e71a37e9ff86bb1b47c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt; are non-empty then the ':' and '=' above are still accepted, but become optional. Note that these option key sets must be updated along with the set of option keys taking no value, but keys which do take values need no special updates as their set evolves.</source>
          <target state="translated">때 &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; 는 ':'와 '='위에서 여전히 허용됩니다,하지만 선택 사항이 될 수있는 다음 비 웁니다. 이러한 옵션 키 세트는 값을 가지지 않는 옵션 키 세트와 함께 업데이트해야하지만 값을 취하는 키는 세트가 진화함에 따라 특별한 업데이트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c515c96ec96f99594496b1328f30048f3de0cd1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;followSymlink&lt;/em&gt; is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="translated">때 &lt;em&gt;followSymlink는&lt;/em&gt; 사실, 심볼릭 링크는 다음과 검색된 정보는 심볼릭 링크의 대상에 관한 정보입니다 있습니다. 그렇지 않으면 심볼릭 링크 자체에 대한 정보가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="de4680275e7c901d5f3833c727cc99c5fb135e40" translate="yes" xml:space="preserve">
          <source>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an &lt;code&gt;untyped&lt;/code&gt; parameter:</source>
          <target state="translated">Nim에서 표준 과부하 해결 규칙으로 확인할 수없는 표현식이 발견되면 현재 범위에서 알 수없는 필드 또는 프로 시저 이름이 전달 된 표현식의 다시 작성된 양식과 일치 할 수있는 도트 연산자를 검색합니다. &lt;code&gt;untyped&lt;/code&gt; 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="e2eaaa4e3170b1469cf0690081d49d1771a1d85a" translate="yes" xml:space="preserve">
          <source>When OpenSSL is dynamically linked, the wrapper provides partial forward and backward compatibility for OpenSSL versions above and below 1.1.0</source>
          <target state="translated">OpenSSL이 동적으로 연결되면 래퍼는 Open1.0 버전 1.1.0 이상에서 부분적인 앞뒤 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9ae81d2c9c4d1fafceab9a15e0a86562d3247333" translate="yes" xml:space="preserve">
          <source>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</source>
          <target state="translated">일반 유형이 구체적 유형이 아닌 유형 클래스로 인스턴스화되면보다 구체적인 유형 클래스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b7ee84914a1420903931986e31a5241d62b138" translate="yes" xml:space="preserve">
          <source>When a procedure uses the special &lt;code&gt;var&lt;/code&gt; type return variable, the result is different from that of a var section.</source>
          <target state="translated">프로 시저가 특수 &lt;code&gt;var&lt;/code&gt; 유형 리턴 변수를 사용하는 경우 결과는 var 섹션의 결과와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="97b4b802a770e586e56855a558c28871a136f5e3" translate="yes" xml:space="preserve">
          <source>When a request is made by a client the specified callback will be called.</source>
          <target state="translated">클라이언트가 요청하면 지정된 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c1a7a3d1dd71e0b4cf302372876e2f1c5cc12058" translate="yes" xml:space="preserve">
          <source>When a request is made to a different hostname, the current connection will be closed.</source>
          <target state="translated">다른 호스트 이름으로 요청하면 현재 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c3a07f0075ab0a45bf34eaf52dac74c940e4d650" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which can be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readfds&lt;/code&gt; 의 소켓을 읽을 준비가되면 읽을 수있는 소켓 수를 지정하여 0이 아닌 값이 리턴됩니다. 읽을 수있는 소켓도 &lt;code&gt;readfds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2377e8684393b2ce892159f2a4e80c538b1e3d8" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which &lt;strong&gt;cannot&lt;/strong&gt; be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;writefds&lt;/code&gt; 의 소켓에 쓸 준비가되면 쓸 수있는 소켓 수를 지정하여 0이 아닌 값이 반환됩니다. 쓸 &lt;strong&gt;수없는&lt;/strong&gt; 소켓 도 &lt;code&gt;writefds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="43add50714f33e02f97cb791ebd99cd5319627ba" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;writefds&lt;/code&gt; 의 소켓에 쓸 준비가되면 쓸 수있는 소켓 수를 지정하여 0이 아닌 값이 반환됩니다. 쓸 수있는 소켓도 &lt;code&gt;writefds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="39bcbf0203513201bce5ea953d3b4e8ffa73d031" translate="yes" xml:space="preserve">
          <source>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify.</source>
          <target state="translated">테스트 케이스를 스위트에 추가 할 때 테스트의 의미에 대한 몇 가지 의견을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc850e7757d223791640269bd02d07871233442e" translate="yes" xml:space="preserve">
          <source>When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:</source>
          <target state="translated">인플레 이스 돌연변이와 '반환 변환 된 사본'을 모두 사용할 수있는 경우 후자는 전자의 과거 분사입니다.</target>
        </trans-unit>
        <trans-unit id="8d7871f40dcafcdf1db9af282909ed84f0a0d5c2" translate="yes" xml:space="preserve">
          <source>When expression</source>
          <target state="translated">표현할 때</target>
        </trans-unit>
        <trans-unit id="5390519091e9974a31ed036eaeb0253339bd37ca" translate="yes" xml:space="preserve">
          <source>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</source>
          <target state="translated">여러 유형의 매개 변수가 있으면 다른 유형에 자유롭게 바인딩됩니다. 한 번만 바인딩 동작을 수행하려면 명시적인 일반 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020893f63cc1aaaba0f76060df95101dd9c22483" translate="yes" xml:space="preserve">
          <source>When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a &quot;Obj&quot;, &quot;Ref&quot;, or &quot;Ptr&quot; suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.</source>
          <target state="translated">값, 포인터 및 참조 품종으로 이름이 지정된 유형의 이름을 지정할 때는 가장 많이 사용되는 품종의 정규 이름을 사용하고 다른 품종에 대해 &quot;Obj&quot;, &quot;Ref&quot;또는 &quot;Ptr&quot;접미사를 추가하십시오. 가장 많이 사용되는 품종이 하나도없는 경우 접미사를 포인터 변형에만 추가하십시오. C / C ++ 랩퍼에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1225645594c00f94369b8ea3ee23053edbf83ba3" translate="yes" xml:space="preserve">
          <source>When nimvm statement</source>
          <target state="translated">언제 nimvm 문</target>
        </trans-unit>
        <trans-unit id="fda49f871e7ef45866bd4f710af7f4927e2c1a8d" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=' they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="translated">옵션 값이 ':'또는 '='로 시작하면 옵션은 &lt;code&gt;--delim::&lt;/code&gt; 에서와 같이 두 배로 증가 하거나 &lt;code&gt;--delim=:&lt;/code&gt; 에서와 같이 대체 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4bbb0504613b19518d968c26eceaaa8391745e36" translate="yes" xml:space="preserve">
          <source>When socket is non-blocking and no data is available on the socket, &lt;code&gt;-1&lt;/code&gt; will be returned and &lt;code&gt;data&lt;/code&gt; will be &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">socket이 비 블로킹이고 소켓에서 사용 가능한 데이터가 없으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c99b697aa205b3dce70845af926b4da0b0718d3" translate="yes" xml:space="preserve">
          <source>When statement</source>
          <target state="translated">언제 진술</target>
        </trans-unit>
        <trans-unit id="bd80507fb2abefe95238353b2a9a7cfba726d9d1" translate="yes" xml:space="preserve">
          <source>When the 'returns transformed copy' version already exists like &lt;code&gt;strutils.replace&lt;/code&gt; an in-place version should get an &lt;code&gt;-In&lt;/code&gt; suffix (&lt;code&gt;replaceIn&lt;/code&gt; for this example).</source>
          <target state="translated">'returns transformed copy'버전이 &lt;code&gt;strutils.replace&lt;/code&gt; 와 같이 이미 존재 하는 경우 전체 버전은 &lt;code&gt;-In&lt;/code&gt; 접미사 ( 이 예제의 &lt;code&gt;replaceIn&lt;/code&gt; ) 를 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="ee41ae36de358d86d21ea16751455620675ba69a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;NimMain()&lt;/code&gt; function is called Nim initializes the garbage collector to the current thread, which is usually the main thread of your application. If your C code later spawns a different thread and calls Nim code, the garbage collector will fail to work properly and you will crash.</source>
          <target state="translated">&lt;code&gt;NimMain()&lt;/code&gt; 함수가 호출 되면 Nim은 가비지 수집기를 현재 스레드 (일반적으로 응용 프로그램의 기본 스레드)로 초기화합니다. C 코드가 나중에 다른 스레드를 생성하고 Nim 코드를 호출하면 가비지 수집기가 제대로 작동하지 않아 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="daad49e43f5115581c4b76d4a507c298160c9cb2" translate="yes" xml:space="preserve">
          <source>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</source>
          <target state="translated">개념 유형이 구체적 유형과 일치하는 경우, 호출 가능 심볼의 일반 매개 변수가 호출 사이트에서 유추되는 방식과 매우 유사한 방식으로 개념 본문에서 언 바운드 유형 매개 변수가 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="cd24854ac2b1bea3f20fcea6158974c3a2524eb3" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;em&gt;AnnotatedPtr&lt;/em&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="translated">위 의 &lt;em&gt;AnnotatedPtr&lt;/em&gt; 의 경우와 같이 지정된 제네릭 매개 변수를 사용하여 포인터와 같은 유형을 인스턴스화 하면 결과 제네릭 유형에도 포인터와 같은 공분산이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c835f980849f2df2e29fb8df8dab183460e5e580" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. You can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="translated">내 보낸 심볼이 다른 모듈 인 경우 모든 정의가 전달됩니다. &lt;code&gt;except&lt;/code&gt; 목록을 사용하여 일부 기호를 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf92696d3f2ea1ae3634b81406709cbcffab8999" translate="yes" xml:space="preserve">
          <source>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the &lt;code&gt;of&lt;/code&gt; keyword:</source>
          <target state="translated">개념 내에서 일치하는 유형이 다른 개념에 대해 직접 테스트되면 외부 개념이 내부 개념의 개선이므로 더 구체적입니다. 과부하 해결 중 통화에서 두 개념이 일치하면 Nim은 가장 구체적인 개념에 우선 순위를 더 높게 지정합니다. 개념 구체화를 정의하는 다른 방법으로 &lt;code&gt;of&lt;/code&gt; 키워드를 포함하는 객체 상속 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="254e2ddbd3dd05fc683e34f1716f23a33c331fe1" translate="yes" xml:space="preserve">
          <source>When the process has finished executing, cleanup related handles.</source>
          <target state="translated">프로세스 실행이 완료되면 정리 관련 핸들.</target>
        </trans-unit>
        <trans-unit id="efe7cb68f3a591e4c2d4dcbbc522f1614fc7e0f0" translate="yes" xml:space="preserve">
          <source>When used as a table constructor, the syntax is different.</source>
          <target state="translated">테이블 생성자로 사용하면 구문이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aaaf6332aae7b182e062b2664c8075404ebd76b7" translate="yes" xml:space="preserve">
          <source>When used for matching, keep in mind that likewise scanf, no backtracking is performed.</source>
          <target state="translated">일치를 위해 사용될 때, 마찬가지로 scanf, 역 추적은 수행되지 않는다는 것을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="5f917a7650b1a36cb2a4a1c6a6acf808f3f394e5" translate="yes" xml:space="preserve">
          <source>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</source>
          <target state="translated">일반 proc 내에서 사용될 때, proc의 각 인스턴스화마다 별도의 고유 전역 변수가 작성됩니다. 모듈 내에서 생성 된 전역 변수의 초기화 순서는 정의되어 있지 않지만 모든 변수는 원래 모듈에서 최상위 변수 다음에 그리고 모듈을 가져 오는 모듈에서 변수 전에 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="56d07aa5bc818ad3ec9bad7f3accf7a490ff3025" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header (requires a C compiler with _Static_assert support, like any C11 compiler)</source>
          <target state="translated">C 헤더의 유형을 사용할 때 Nim 파일의 내용과 C 헤더의 내용을 비교하는 검사를 추가하십시오 (C11 컴파일러와 같이 _Static_assert 지원이있는 C 컴파일러 필요)</target>
        </trans-unit>
        <trans-unit id="54f14056818f81ec01f7058b5fdd03ac34cc67b2" translate="yes" xml:space="preserve">
          <source>When you are making an imported module accessible by modules that import yours, the &lt;code&gt;export&lt;/code&gt; syntax is pretty straightforward.</source>
          <target state="translated">가져온 모듈에서 가져온 모듈에 액세스 할 수있게하면 &lt;code&gt;export&lt;/code&gt; 구문이 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="08835fa964ca44a302c76938b48f30469a0f0a5b" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Example:</source>
          <target state="translated">당신으로 반복이 끝난 다른 필드 유형의 개체를 할 때 당신은 컴파일 시간을 사용 할 &lt;code&gt;when&lt;/code&gt; 대신 런타임의 &lt;code&gt;if&lt;/code&gt; 각 유형에 대해 실행할 코드를 선택할 수 있습니다. 비교를 수행하려면 &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is 연산자를&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="3c6b91dbf30c6480d506d993a62a2e5ede60b7e6" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;docSeeSrcUrl&lt;/code&gt; switch to docgen, after each documented item in your source code the hyper link &lt;em&gt;See source&lt;/em&gt; will appear pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.</source>
          <target state="translated">&lt;code&gt;docSeeSrcUrl&lt;/code&gt; 스위치를 docgen으로 전달하면 소스 코드의 각 문서화 된 항목 후에 하이퍼 링크 &lt;em&gt;참조 소스&lt;/em&gt; 가 GitHub 저장소에서 해당 항목의 구현을 가리키는 것으로 나타납니다. 링크를 클릭하면 항목의 구현을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18a97667681fbb7bac72211a2b07123eb883bd7" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;rst2html&lt;/code&gt; command, all sections in the RST document will get an anchor you can hyper link to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the &lt;code&gt;doc&lt;/code&gt; or &lt;code&gt;doc2&lt;/code&gt; commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.</source>
          <target state="translated">&lt;code&gt;rst2html&lt;/code&gt; 명령 을 실행하면 RST 문서의 모든 섹션에 하이퍼 링크로 연결할 수있는 앵커가 생깁니다. 일반적으로 앵커가 섹션 제목을 케이싱하고 공백을 대시로 바꾸는 것을 짐작할 수 있으며 어쨌든 목차에서 얻을 수 있습니다. 그러나 &lt;code&gt;doc&lt;/code&gt; 또는 &lt;code&gt;doc2&lt;/code&gt; 명령을 실행하여 API 문서를 생성 할 때 일부 기호는 동시에 하나 또는 두 개의 앵커 (숫자 식별자 또는 일반 이름과 복잡한 이름)를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1ce4c6ad2b222c2702bd12ce14dc109cc99b9422" translate="yes" xml:space="preserve">
          <source>Whenever a user creates a specialized object, implementation of this procedure provides for &lt;code&gt;string&lt;/code&gt; representation.</source>
          <target state="translated">사용자가 특수 객체를 만들 때마다이 절차의 구현은 &lt;code&gt;string&lt;/code&gt; 표현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4e4cc3bb373e7618b80ba75c42e4df4653d3d72e" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same html file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="translated">이러한 pragma를 사용할 때마다 기본 코드를 최종 바이너리에 통합해야합니다. JavaScript의 경우, 이것은 전혀 문제가되지 않습니다. 생성 된 JavaScript를 호스팅하는 동일한 html 파일은 &lt;code&gt;importc&lt;/code&gt; 로 가져 오는 다른 JavaScript 함수를 제공 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="aeeaa58356082edb9c3248aa2f5880d152480e90" translate="yes" xml:space="preserve">
          <source>Where we are currently connected.</source>
          <target state="translated">우리가 현재 연결된 곳.</target>
        </trans-unit>
        <trans-unit id="46461b4ca7f105357f8fd52e913f10563d7fe3fd" translate="yes" xml:space="preserve">
          <source>Whether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</source>
          <target state="translated">확인 된 런타임 오류로 인해 예외가 발생하는지 또는 런타임시 치명적인 오류가 발생하는지 여부는 구현에 따라 다릅니다. 따라서 다음 프로그램은 항상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7602811bf6ae08bd5e22293258701c16580af8be" translate="yes" xml:space="preserve">
          <source>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the &lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt; and &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragmas: gensym'ed symbols are not exposed but inject'ed are.</source>
          <target state="translated">템플릿에 선언 된 기호가 인스턴스화 범위에 노출되는지 여부는 &lt;span id=&quot;inject_1&quot;&gt;주입&lt;/span&gt; 및 &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragma에 의해 제어됩니다 . gensym'ed 기호는 노출되지 않지만 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="855714febc5eeb00b339faa0d12bd25d89659cb1" translate="yes" xml:space="preserve">
          <source>Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="translated">연산자가 접두사 연산자인지 여부는 선행 공백의 영향을받습니다 (이 구문 분석 변경 사항은 버전 0.13.0에서 도입되었습니다).</target>
        </trans-unit>
        <trans-unit id="6d41ff5608431c17e7d0fc23a167d921f5683a39" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$p.name&lt;/code&gt; can also be used, the &lt;code&gt;$&lt;/code&gt; operation on a string does nothing. Note that we cannot rely on automatic conversion from an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt; like we can for the &lt;code&gt;echo&lt;/code&gt; proc.</source>
          <target state="translated">&lt;code&gt;$p.name&lt;/code&gt; 도 사용할 수 있지만 문자열에 대한 &lt;code&gt;$&lt;/code&gt; 작업은 아무 것도 수행하지 않습니다. &lt;code&gt;echo&lt;/code&gt; proc 과 같이 &lt;code&gt;int&lt;/code&gt; 에서 &lt;code&gt;string&lt;/code&gt; 로의 자동 변환에 의존 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="837197cffaa6ba949530b17e33bcba42ef50a34d" translate="yes" xml:space="preserve">
          <source>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as &lt;em&gt;one&lt;/em&gt; way to design a program, not &lt;em&gt;the only&lt;/em&gt; way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</source>
          <target state="translated">객체 지향 프로그래밍 (OOP)에 대한 Nim의 지원은 최소한이지만 강력한 OOP 기술을 사용할 수 있습니다. OOP는 다음과 같이 볼 수 있습니다 &lt;em&gt;하나의&lt;/em&gt; 프로그램이 아닌 설계 방법 &lt;em&gt;유일한&lt;/em&gt; 방법. 절차 적 접근 방식은 종종 더 간단하고 효율적인 코드로 이어집니다. 특히 상속보다 구성을 선호하는 것이 종종 더 나은 디자인입니다.</target>
        </trans-unit>
        <trans-unit id="3fff640cbdad99fe09274abee24df7bbf25d0561" translate="yes" xml:space="preserve">
          <source>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</source>
          <target state="translated">언어 수준에서 메서드는 매개 변수와 반환 값으로 다른 메서드와 차별화되지만 idetools에서 반환하는 메서드의 서명은 메서드에 대한 pragma도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="562bd6173e445712f1af66a953e8986ba0c2374d" translate="yes" xml:space="preserve">
          <source>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</source>
          <target state="translated">언어 수준에서 proc은 매개 변수와 반환 값으로 다른 것과 구별되지만 idetools가 반환 한 proc의 서명은 proc에 대한 pragma도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="daec9332bd403083c7c81ec7ddda4c8cfb83913d" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</source>
          <target state="translated">매크로는 고급 컴파일 타임 코드 변환을 가능하게하지만 Nim의 구문을 변경할 수는 없습니다. 그러나 Nim의 구문이 충분히 유연하기 때문에 이것은 실제 제한이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2ec95ebb740e8da659961135df7e65656f864a68" translate="yes" xml:space="preserve">
          <source>While similar to the &lt;span id=&quot;caller-info_1&quot;&gt;caller info&lt;/span&gt; of other languages, it is determined at compile time.</source>
          <target state="translated">다른 언어 의 &lt;span id=&quot;caller-info_1&quot;&gt;발신자 정보&lt;/span&gt; 와 비슷하지만 컴파일 타임에 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab874ba2e993f09c0db307995f9d97ec18bcd164" translate="yes" xml:space="preserve">
          <source>While statement</source>
          <target state="translated">성명서</target>
        </trans-unit>
        <trans-unit id="441460d8bae7a87fe7d9e0c8e6f1dc6c4fb048ac" translate="yes" xml:space="preserve">
          <source>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</source>
          <target state="translated">pragma 표기법을 통해 전체 루틴 (프로 시저, 반복자 등)을 템플릿 또는 매크로로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="455cc265958fecb1e713d605b1e591a53e7b0eb7" translate="yes" xml:space="preserve">
          <source>Whole routines can also be annotated with a &lt;code&gt;locks&lt;/code&gt; pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">전체 루틴은 잠금 레벨을 취하는 &lt;code&gt;locks&lt;/code&gt; 프라그 마로 주석을 달 수 있습니다 . 이것은 루틴이이 레벨까지의 잠금을 획득 할 수 있음을 의미합니다. &lt;code&gt;locks&lt;/code&gt; 섹션 내에서 procs를 호출 할 수 있도록하기 위해 필수적입니다 .</target>
        </trans-unit>
        <trans-unit id="34796431c4136a13fc1a272537e43a27d56433b1" translate="yes" xml:space="preserve">
          <source>Windows specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f082c74fae11cd24ce038c421b38da0f7f03aa4d" translate="yes" xml:space="preserve">
          <source>Windows: this is still supported despite Windows platform not having this convention; also, both &lt;code&gt;~/&lt;/code&gt; and &lt;code&gt;~\&lt;/code&gt; are handled.</source>
          <target state="translated">Windows :이 규칙이없는 Windows 플랫폼에도 불구하고 여전히 지원됩니다. 또한 &lt;code&gt;~/&lt;/code&gt; 와 &lt;code&gt;~\&lt;/code&gt; 가 모두 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b10d3f7f20c0f9046a906444b8a60a2f35498a01" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;except&lt;/code&gt;, we get &lt;code&gt;nnkImportExceptStmt&lt;/code&gt;.</source>
          <target state="translated">를 &lt;code&gt;except&lt;/code&gt; &lt;code&gt;nnkImportExceptStmt&lt;/code&gt; 를 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="b4974a309f4c94a4f9d5a2467682e0908cb7a682" translate="yes" xml:space="preserve">
          <source>With parenthesis and semicolons &lt;code&gt;(;)&lt;/code&gt; you can use statements where only an expression is allowed:</source>
          <target state="translated">괄호와 세미콜론 &lt;code&gt;(;)&lt;/code&gt; 을 사용하면 표현식 만 허용되는 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d171ddc79243587420ce2e420c38a86ca6d787e" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--run&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;switch&lt;/a&gt; Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename:</source>
          <target state="translated">&lt;code&gt;--run&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;스위치를&lt;/a&gt; 사용하면 Nim은 컴파일 후 파일을 자동으로 실행합니다. 파일 이름 뒤에 추가하여 프로그램 명령 줄 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd482d4d9faa3aac000c3242487f0f59daaef12" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the &lt;code&gt;exportc&lt;/code&gt; pragma:</source>
          <target state="translated">으로 &lt;code&gt;dynlib&lt;/code&gt; 의 프라그 절차는 동적 라이브러리로 내보낼 수 있습니다. 그런 다음 pragma는 인수가 없으며 &lt;code&gt;exportc&lt;/code&gt; pragma 와 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="023454d8e1cf65bbb06463e1b3d0c36017c3e388" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure or a variable can be imported from a dynamic library (&lt;code&gt;.dll&lt;/code&gt; files for Windows, &lt;code&gt;lib*.so&lt;/code&gt; files for UNIX). The non-optional argument has to be the name of the dynamic library:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; pragma를 사용하면 동적 라이브러리 ( Windows의 경우 &lt;code&gt;.dll&lt;/code&gt; 파일, UNIX의 경우 &lt;code&gt;lib*.so&lt;/code&gt; 파일) 에서 프로 시저 또는 변수를 가져올 수 있습니다 . 선택 사항이 아닌 인수는 동적 라이브러리의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d9ed0ac91dffc6d43c92455d3eaf4fb792201cb9" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="translated">대신에이 두 파일을 사용하면 실행할 수 있습니다 &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; 과 님 컴파일러는 컴파일 &lt;code&gt;logic.c&lt;/code&gt; 의 뿐만 아니라 파일을 &lt;code&gt;calculator.nim&lt;/code&gt; 및 출력 실행으로 모두 연결 &lt;code&gt;10&lt;/code&gt; 때 실행. C 파일을 정적으로 링크하고 동일한 효과를 얻는 또 다른 방법은 &lt;code&gt;compile&lt;/code&gt; pragma로 줄을 제거 하고 다음과 같은 일반적인 Unix 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32f010be8a21b14dff05310dc71f698e090ed9c5" translate="yes" xml:space="preserve">
          <source>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):</source>
          <target state="translated">이 표기법을 사용하여 문법의 핵심을 쉽게 정의 할 수 있습니다. 문장 블록 (단순화 된 예) :</target>
        </trans-unit>
        <trans-unit id="0036fe9e484a381c94e7a2817c459b4a03ab955b" translate="yes" xml:space="preserve">
          <source>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a &lt;code&gt;ConstSection&lt;/code&gt; and a &lt;code&gt;ConstDef&lt;/code&gt;. If we were to move all the constants to a single &lt;code&gt;const&lt;/code&gt; block we would see only a single &lt;code&gt;ConstSection&lt;/code&gt; with three children.</source>
          <target state="translated">이 출력을 통해 컴파일러가 어떤 종류의 입력을 기대할 수 있는지 더 잘 알 수 있습니다. 진술 목록을 생성해야합니다. 각각의 상수에 대한 소스 코드가 생성 &lt;code&gt;ConstSection&lt;/code&gt; 및 &lt;code&gt;ConstDef&lt;/code&gt; 를 . 모든 상수를 단일 &lt;code&gt;const&lt;/code&gt; 블록으로 &lt;code&gt;ConstSection&lt;/code&gt; 세 개의 자식이 있는 하나의 ConstSection 만 보입니다 .</target>
        </trans-unit>
        <trans-unit id="fae6de82250865ee469a39f7ecbc1836e2a60ef6" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;parallel&lt;/code&gt; section sometimes the &lt;code&gt;FlowVar[T]&lt;/code&gt; is eliminated to &lt;code&gt;T&lt;/code&gt;. This happens when &lt;code&gt;T&lt;/code&gt; does not contain any GC'ed memory. The compiler can ensure the location in &lt;code&gt;location = spawn f(...)&lt;/code&gt; is not read prematurely within a &lt;code&gt;parallel&lt;/code&gt; section and so there is no need for the overhead of an indirection via &lt;code&gt;FlowVar[T]&lt;/code&gt; to ensure correctness.</source>
          <target state="translated">내에서 &lt;code&gt;parallel&lt;/code&gt; 섹션 때때로 &lt;code&gt;FlowVar[T]&lt;/code&gt; 로 제거 &lt;code&gt;T&lt;/code&gt; . 이것은 &lt;code&gt;T&lt;/code&gt; 에 GC 메모리가 없을 때 발생 합니다. 컴파일러는 &lt;code&gt;location = spawn f(...)&lt;/code&gt; 가 &lt;code&gt;parallel&lt;/code&gt; 섹션 내에서 조기에 읽히지 않도록하여 &lt;code&gt;FlowVar[T]&lt;/code&gt; 를 통한 간접비의 오버 헤드가 없어도 정확성을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f36950618b8748e3741661dd8fec794ecb08261" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 절 내에서 &lt;code&gt;getCurrentException&lt;/code&gt; 을 사용 하여 발생한 예외를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ae57f97edbcd123ef0194b0d49cf9ec52d7039" translate="yes" xml:space="preserve">
          <source>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</source>
          <target state="translated">개념 본문 내에서 유형은 일반적인 값과 매개 변수가 필요한 위치에 나타날 수 있습니다. 이를 통해 특정 서명이있는 호출 가능한 기호가 있는지보다 편리하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7765888ff783f01e496adca7f847d2e186e708cb" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;GCunref&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="translated">&lt;code&gt;GCunref&lt;/code&gt; 호출이 없으면 &lt;code&gt;d.s&lt;/code&gt; 문자열에 할당 된 메모리 가 해제되지 않습니다. 이 예제는 또한 저수준 프로그래밍의 두 가지 중요한 기능을 보여줍니다. &lt;code&gt;sizeof&lt;/code&gt; proc는 유형 또는 값의 크기를 바이트 단위로 반환합니다. &lt;code&gt;cast&lt;/code&gt; 연산자는 타입 시스템을 우회 할 수 있습니다 컴파일러는 결과 치료하기 위해 강제로 &lt;code&gt;alloc0&lt;/code&gt; 의 이 유형 것처럼 (지정되지 않은 포인터를 반환) 호출 &lt;code&gt;ptr Data&lt;/code&gt; . 주조는 불가피한 경우에만 수행해야합니다. 유형 안전을 깨뜨리고 버그로 인해 신비한 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39a9ca07a5dddf13d83fab735c567da3357a0bf" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">단어는 &lt;em&gt;s를&lt;/em&gt; 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="6962ff8c9e27a68a644675d133701514aae2e762" translate="yes" xml:space="preserve">
          <source>Would output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="436516f371b709f69cf997c54adc4f028f9eebcd" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="translated">순서화 된 해시 세트의 초기화를위한 &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; 주위의 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="aef47240f283c974795c0afe97ed4a86669acef1" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of hash sets.</source>
          <target state="translated">해시 세트의 초기화를위한 &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="0d365d3fa59d526a0f2809a9f61b0028c5e94b10" translate="yes" xml:space="preserve">
          <source>Wrappers</source>
          <target state="translated">Wrappers</target>
        </trans-unit>
        <trans-unit id="533cb09f4efea84d68d3be20e42d0338fe89c618" translate="yes" xml:space="preserve">
          <source>Wrapping constructors</source>
          <target state="translated">래핑 생성자</target>
        </trans-unit>
        <trans-unit id="11cdbcadb273848cfeb799098c4c21e8db2e9d40" translate="yes" xml:space="preserve">
          <source>Wrapping destructors</source>
          <target state="translated">포장 소멸자</target>
        </trans-unit>
        <trans-unit id="9c3c9e84480e553d08468d0746063eeb3c7f119f" translate="yes" xml:space="preserve">
          <source>Wraps a connected socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket. &lt;code&gt;hostname&lt;/code&gt; should be specified so that the client knows which hostname the server certificate should be validated against.</source>
          <target state="translated">연결된 소켓을 SSL 컨텍스트로 래핑합니다. 이 기능은 &lt;code&gt;socket&lt;/code&gt; 을 SSL 소켓으로 효과적으로 전환 합니다. 클라이언트가 서버 인증서의 유효성을 검증 할 호스트 이름을 알 수 있도록 &lt;code&gt;hostname&lt;/code&gt; 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ddc5519e19aff7c9640076ae420da42486453ed" translate="yes" xml:space="preserve">
          <source>Wraps a socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket.</source>
          <target state="translated">소켓을 SSL 문맥으로 랩합니다. 이 기능은 &lt;code&gt;socket&lt;/code&gt; 을 SSL 소켓으로 효과적으로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="02cc7fed3b72e2c8ac3c8047c2bf9e4c909ccdc0" translate="yes" xml:space="preserve">
          <source>Wraps an already initialized &lt;code&gt;Socket&lt;/code&gt; into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.</source>
          <target state="translated">이미 초기화 된 &lt;code&gt;Socket&lt;/code&gt; 을 AsyncSocket에 래핑합니다. 이것은 이미 연결된 소켓을 asyncio의 이벤트 루프에서 비동기 AsyncSocket으로 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f942433295c32b403eab1ccdf7cdbcb2774f2494" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">비동기 적으로 지정된 파일에 &lt;code&gt;data&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7c97819e5811aa1e2b05fd1d97141d7dc4900644" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;buf&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 에서 &lt;code&gt;size&lt;/code&gt; 바이트를 비동기 적으로 지정된 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="897e1a9e1ed791afbff422f3f8123f94d65ede78" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;data&lt;/em&gt; to the socket.</source>
          <target state="translated">소켓에 &lt;em&gt;데이터&lt;/em&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="90e3f5c8aacd0969383d67b232c4242e0fbab6cf" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;em&gt;f&lt;/em&gt;. May throw an IO exception.</source>
          <target state="translated">파일 &lt;em&gt;f에&lt;/em&gt; 값을 씁니다 . IO 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b82505d585d59b7b931841c5790d2d061a18cf" translate="yes" xml:space="preserve">
          <source>Writes and flushes the parameters to the standard output.</source>
          <target state="translated">매개 변수를 표준 출력에 쓰고 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="9fe62811850204f6989910a722d883718ece800c" translate="yes" xml:space="preserve">
          <source>Writes data to the specified future stream as the file is read.</source>
          <target state="translated">파일을 읽을 때 지정된 미래 스트림에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b92242dea02e29327d993eb1cc3297777dff63be" translate="yes" xml:space="preserve">
          <source>Writes into &lt;code&gt;result&lt;/code&gt; the rst ast &lt;code&gt;n&lt;/code&gt; using the &lt;code&gt;d&lt;/code&gt; configuration.</source>
          <target state="translated">에 기록이 &lt;code&gt;result&lt;/code&gt; RST AST &lt;code&gt;n&lt;/code&gt; 은 USING &lt;code&gt;d&lt;/code&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="8f25f4df96580649fbf61c73bf96f72aec9e3b5f" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to string. Note: Comment statement will be ignored.</source>
          <target state="translated">테이블의 내용을 문자열에 씁니다. 참고 : 설명문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ba6e3b9c400f1eef44b307552759341bc86ee5ce" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified configuration file. Note: Comment statement will be ignored.</source>
          <target state="translated">테이블의 내용을 지정된 구성 파일에 씁니다. 참고 : 설명문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="943a3e5523074ab2149addf7bbeb0fa3c3bf1c09" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified stream</source>
          <target state="translated">테이블의 내용을 지정된 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="6cd9e881510f9be093ebe517fe9b4aa83cc82a0a" translate="yes" xml:space="preserve">
          <source>Writes the current index buffer to the specified output file.</source>
          <target state="translated">현재 색인 버퍼를 지정된 출력 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="4dd32587819be16f41963d9f477e3a15c30356f1" translate="yes" xml:space="preserve">
          <source>Writes the given RST node as JSON that is in the form</source>
          <target state="translated">주어진 RST 노드를 JSON 형식으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbda5ef7f0ace5ebf184908b2e7da636d8527f" translate="yes" xml:space="preserve">
          <source>Writes the list of registered foreign deps to stdout.</source>
          <target state="translated">등록 된 외부 뎁 목록을 stdout에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0cfd7a39f362d2a77758e5c07bcd311bfabd3290" translate="yes" xml:space="preserve">
          <source>Writes the specified value inside the specified future stream.</source>
          <target state="translated">지정된 미래 스트림 내에 지정된 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="b8255ac21cf77099d0f6ff9ac6e846fb5cdb0fda" translate="yes" xml:space="preserve">
          <source>Writes the string:</source>
          <target state="translated">문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="2914acbe1102d062a4f2393594889f72ba0c206e" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;em&gt;txt&lt;/em&gt; in a given &lt;em&gt;style&lt;/em&gt; to stdout.</source>
          <target state="translated">주어진 &lt;em&gt;스타일&lt;/em&gt; 의 텍스트 &lt;em&gt;txt&lt;/em&gt; 를 stdout 에 씁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="273726bd38de7eff2c09ffae11f809aa1fb0834f" translate="yes" xml:space="preserve">
          <source>Written by Philip Hazel</source>
          <target state="translated">필립 헤이젤</target>
        </trans-unit>
        <trans-unit id="f7b03e2f61abd9d04fffa15c8355e3436931a0ae" translate="yes" xml:space="preserve">
          <source>XDeclaredButNotUsed</source>
          <target state="translated">XDeclaredButNotUsed</target>
        </trans-unit>
        <trans-unit id="d647f348ffbbc7a4d48d8ae4bec579637ae0ee51" translate="yes" xml:space="preserve">
          <source>XML Processing</source>
          <target state="translated">XML 처리</target>
        </trans-unit>
        <trans-unit id="d850dd17ecf96df39630839c6d073caf7cb5fb52" translate="yes" xml:space="preserve">
          <source>Yield every (position, value) of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq의&lt;/em&gt; 모든 (위치, 값)을 &lt;em&gt;산출&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="755dd97240e42a3dc4431ff54cbcde0d38f93331" translate="yes" xml:space="preserve">
          <source>Yield every element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq의&lt;/em&gt; 모든 요소를 &lt;em&gt;산출하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ca75af94090e37bbf9398ee1de83cc580bdc1c" translate="yes" xml:space="preserve">
          <source>Yield statement</source>
          <target state="translated">수율 진술</target>
        </trans-unit>
        <trans-unit id="d4f3a56dbd00c322681bd3d8cb3a2e92bba08be1" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치 하는 &lt;code&gt;s&lt;/code&gt; 의 일치하는 모든 &lt;em&gt;하위 문자열&lt;/em&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="5dbe19c48460bbfdb0a7ecb4ffe08a0ee9cd8526" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pattern&lt;/em&gt; 과 일치 하는 &lt;em&gt;s의&lt;/em&gt; 일치하는 모든 &lt;em&gt;하위 문자열&lt;/em&gt; 을 생성 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26171d2547797d7b792e1c5b0afcc0cbe263ef92" translate="yes" xml:space="preserve">
          <source>Yields each key, value pair.</source>
          <target state="translated">각 키, 값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d7e3fc8749812999838907214d1eb8450309265" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;keys&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">JsAssoc 의 &lt;em&gt;키&lt;/em&gt; 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a2417d997628d8ba1aefeea2d89fe75654c22728" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;names&lt;/em&gt; of each field in a JsObject.</source>
          <target state="translated">JsObject에서 각 필드 의 &lt;em&gt;이름&lt;/em&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93956d196d887cc0861e43d2a531388eaa74a029" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">JsAssoc 의 &lt;em&gt;값&lt;/em&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f1a656995365fee941d9a0f7f934014284b0f0a" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="translated">수율 &lt;em&gt;값&lt;/em&gt; JSObject가로 싸서 JSObject를 각 필드의이.</target>
        </trans-unit>
        <trans-unit id="3fe8766634b03a0c571dde2851555af85b82423a" translate="yes" xml:space="preserve">
          <source>Yields the child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">&lt;em&gt;Peg&lt;/em&gt; 변형 오브젝트 의 하위 노드가있는 경우이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d8ec21b096062ab66fc1c72aaf6915c5df074b73" translate="yes" xml:space="preserve">
          <source>Yields the indices and child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">&lt;em&gt;Peg&lt;/em&gt; 변형 오브젝트 의 인덱스 및 하위 노드가있는 경우이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9787a201226a9a90fb295daca65242e9806ef392" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;em&gt;key&lt;/em&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="translated">&lt;code&gt;(K, V)&lt;/code&gt; 유형의 튜플을 생성 합니다. 첫 번째 항목 은 JsAssoc 의 &lt;em&gt;키&lt;/em&gt; 이고 두 번째 항목은 해당 값입니다.</target>
        </trans-unit>
        <trans-unit id="0d5fe99d112e72e96635690ca13742e71ee3b251" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;em&gt;name&lt;/em&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="translated">&lt;code&gt;(cstring, JsObject)&lt;/code&gt; 유형의 튜플을 생성 합니다. 첫 번째 항목 은 JsObject의 필드 &lt;em&gt;이름&lt;/em&gt; 이고 두 번째 항목 은 JsObject에 래핑 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="e0096f64ab9c850e6d8688547c2fb784796e80a1" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;RstGenerator&lt;/code&gt; structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX documents&lt;/a&gt; too.</source>
          <target state="translated">&lt;code&gt;RstGenerator&lt;/code&gt; 구조를 작성 하고 다른 하위 레벨 메소드로 채워서 최종 문서를 빌드 할 수도 있습니다. 여기에는 많은 옵션과 조정이 필요하지만 스 니펫에만 국한되지 않고 &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX 문서&lt;/a&gt; 도 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d188ca0a71a4ddf286451e750b7f8f446c7afd4" translate="yes" xml:space="preserve">
          <source>You can also make post requests with custom headers. This example sets &lt;code&gt;Content-Type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt; and uses a json object for the body</source>
          <target state="translated">사용자 정의 헤더를 사용하여 게시 요청을 할 수도 있습니다. 이 예에서는 &lt;code&gt;Content-Type&lt;/code&gt; 을 &lt;code&gt;application/json&lt;/code&gt; 으로 설정 하고 본문에 json 객체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7714759afec1609cb47128c6129eb72d509b791d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; together with &lt;em&gt;long string literals&lt;/em&gt; to create block comments:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;#procedures-discard-statement&quot;&gt;폐기 문을&lt;/a&gt; 함께 &lt;em&gt;긴 문자열 리터럴&lt;/em&gt; 블록 주석을 만들 수 :</target>
        </trans-unit>
        <trans-unit id="97084a1faa8455f2406ffb033740ec1bfec72684" translate="yes" xml:space="preserve">
          <source>You can also use the convenience procedures called &lt;code&gt;milliseconds&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;months&lt;/code&gt;, and &lt;code&gt;years&lt;/code&gt;.</source>
          <target state="translated">또한라는 편리한 절차를 사용할 수 &lt;code&gt;milliseconds&lt;/code&gt; , &lt;code&gt;seconds&lt;/code&gt; , &lt;code&gt;minutes&lt;/code&gt; , &lt;code&gt;hours&lt;/code&gt; , &lt;code&gt;days&lt;/code&gt; , &lt;code&gt;months&lt;/code&gt; 및 &lt;code&gt;years&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3b8da731d961b104b75c9c69b89b7521fd2d57" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered GC run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the GC and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="translated">프로그램 시작시 &lt;code&gt;GC_SetMaxPause&lt;/code&gt; 를 호출 하면 트리거 된 각 GC 실행이 &lt;code&gt;maxPause&lt;/code&gt; 시간 보다 오래 걸리지 않습니다 . 그러나 &lt;code&gt;new&lt;/code&gt; 호출 이 GC를 트리거 할 수 있으므로 &lt;code&gt;maxPause&lt;/code&gt; 시간 이 걸리므 로 작업이 균등하게 분배되지 않을 수 있습니다 (그리고 일반적입니다) .</target>
        </trans-unit>
        <trans-unit id="409fedb343fbf4112734b304e207a767c54d9c6f" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them. Example:</source>
          <target state="translated">이전에 초기화 된 해시 세트에서이 proc을 호출하면 모든 값이 삭제됩니다. 기존 값을 반복하고 &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; 을 호출하는 것보다 편리 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="b94d52a9f40f9d3456df4a8df7e7eb81a57a523b" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</source>
          <target state="translated">이전에 초기화 된 순서화 된 해시 세트에서이 proc을 호출하여 해당 값을 버릴 수 있습니다. 현재 순서가 지정된 해시 세트에서 요소를 제거하는 유일한 방법입니다. 예:</target>
        </trans-unit>
        <trans-unit id="d5a15a89c8527958b5725cea61c34db20ebbeafb" translate="yes" xml:space="preserve">
          <source>You can find examples of client/server communication in the idetools tests found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#test-suite&quot;&gt;테스트 스위트&lt;/a&gt; 에있는 idetools 테스트에서 클라이언트 / 서버 통신의 예제를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d157a3f2f7ccab099eb8d42373b8eee643ec59fc" translate="yes" xml:space="preserve">
          <source>You can force the evaluation of a certain expression at compile-time by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="translated">컴파일 타임에 특정 &lt;code&gt;static&lt;/code&gt; 표현식을 해당 정적 유형으로 강제 변환하여 강제로 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fbd4752c2519417bd7580131c8b434b52acfe30" translate="yes" xml:space="preserve">
          <source>You can generate HTML output through the convenience proc &lt;code&gt;rstToHtml&lt;/code&gt;, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; parts.</source>
          <target state="translated">편의 proc &lt;code&gt;rstToHtml&lt;/code&gt; 을 통해 HTML 출력을 생성 할 수 있습니다. 첫 번째 마크 업이있는 입력 문자열은 생성 된 HTML이있는 문자열을 리턴합니다. 최종 결과물은 사용자가 직접 제공 한 전체 문서에 포함되므로 일반적인 &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 부분 은 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db428874c2fa95de5693e83c0a003d99482e25e7" translate="yes" xml:space="preserve">
          <source>You can import the &lt;a href=&quot;rstgen&quot;&gt;packages/docutils/rstgen module&lt;/a&gt; in your programs if you want to reuse the compiler's documentation generation procs.</source>
          <target state="translated">컴파일러의 문서 생성 &lt;a href=&quot;rstgen&quot;&gt;프로세스&lt;/a&gt; 를 재사용하려는 경우 프로그램에서 패키지 / docutils / rstgen 모듈 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26dd058177b18bbce0e1976ca233b4444e8bfaa9" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do 표기법으로&lt;/a&gt; adhoc 비교 procs를 인라인 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="f9ee456de749cd07f777df2dbfca526efcaac8de" translate="yes" xml:space="preserve">
          <source>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</source>
          <target state="translated">하나의 과부하가 구속 조건과 일치하고 다른 하나는 구속 조건없이 일치 할 수 있으며 제약 조건이있는 과부하가 우선하므로 두 경우를 다르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a3e0b3e912356fd0eb7d1dfb77943e7ce6efb8f9" translate="yes" xml:space="preserve">
          <source>You can obtain the type of a given expression by constructing a &lt;code&gt;type&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="translated">주어진 식의 &lt;code&gt;type&lt;/code&gt; 값을 구성하여 주어진 식의 형식을 얻을 수 있습니다 (다른 많은 언어에서는 &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; 연산자 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="fef0a20f2b09c4d9edfa4d02db9759a10ded5a2e" translate="yes" xml:space="preserve">
          <source>You can of course use GDB or Visual Studio to debug the compiler (via &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt;). However, there are also lots of procs that aid in debugging:</source>
          <target state="translated">물론 GDB 또는 Visual Studio를 사용하여 &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt; 을 통해 컴파일러를 디버깅 할 수 있습니다 . 그러나 디버깅에 도움이되는 많은 프로세스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1dcc44050776a85f416ff13b391cd7420a7ea6" translate="yes" xml:space="preserve">
          <source>You can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="translated">special &lt;code&gt;:&lt;/code&gt; 구문에 따라 템플릿에 마지막 인수로 문장 블록을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3235ae291f967014004169d6dd7919accac84950" translate="yes" xml:space="preserve">
          <source>You can then begin accepting connections using the &lt;code&gt;accept&lt;/code&gt; procedure.</source>
          <target state="translated">그런 다음 &lt;code&gt;accept&lt;/code&gt; 절차를 사용하여 연결 수락을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="229f698a5d2a1c44c1f9b047aaac16d395d3ac54" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; to &lt;em&gt;always&lt;/em&gt; add the &lt;code&gt;.discardable&lt;/code&gt; pragma since every name starts with the empty string prefix.</source>
          <target state="translated">모든 이름은 빈 문자열 접두어로 시작하므로 &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; 를 사용 하여 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;.discardable&lt;/code&gt; pragma를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="522e6e68fd4224a4e7b5d122bef202f975c7268d" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;fmt&lt;/code&gt; or the unary &lt;code&gt;&amp;amp;&lt;/code&gt; operator for formatting. The difference between them is subtle but important.</source>
          <target state="translated">당신도 사용할 수 있습니다 &lt;code&gt;fmt&lt;/code&gt; 또는 단항 &lt;code&gt;&amp;amp;&lt;/code&gt; 포맷에 대한 연산자를. 그들 사이의 차이점은 미묘하지만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f6db4f8bc927328b58f5dd31eba7cffedc758cc6" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</source>
          <target state="translated">이를 Nim의 추상 구문 트리를 탐색하고 특정 표현 / 문을 나타 내기 위해 어떤 종류의 노드를 작성해야하는지 발견하는 도구로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddf568174dd61d7a80305dc0a3e7df19330c174" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</source>
          <target state="translated">예제 출력을 작성한 다음 스 니펫을 매크로에 복사하여 매크로를 더 빨리 작성하는 도구로 이것을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c2d59459a913b746b98925a2a3fc29f24dc533" translate="yes" xml:space="preserve">
          <source>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">이 절차를 사용하여 분기 조건을 꾸밀 수 있습니다. 특정 플랫폼에서는 프로세서가 어떤 분기를 실행할지 더 잘 예측할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a34048e340fae2cd8a9b340afd693e3e0e20b294" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set. Example:</source>
          <target state="translated">이 proc을 사용하여 세트에서 요소를 변환 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a91b944ee43ceb5d18d013c159338cbb935b2855" translate="yes" xml:space="preserve">
          <source>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">이 템플릿을 사용하여 분기 조건을 꾸밀 수 있습니다. 특정 플랫폼에서는 프로세서가 어떤 분기를 실행할지 더 잘 예측할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="786f4a9c940aa7c5a0838e96623ddf57a6935a80" translate="yes" xml:space="preserve">
          <source>You can verify this yourself adding the line &lt;code&gt;echo source&lt;/code&gt; somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; to abort (which we could still call) this version calls the &lt;a href=&quot;macros#error&quot;&gt;error proc&lt;/a&gt; (line 14). The &lt;code&gt;error&lt;/code&gt; proc has the same behavior as &lt;code&gt;quit&lt;/code&gt; but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but &lt;strong&gt;not&lt;/strong&gt; the line of &lt;code&gt;data.cfg&lt;/code&gt; we are processing, that's something the macro itself would need to control.</source>
          <target state="translated">매크로 끝에 어딘가에 라인 &lt;code&gt;echo source&lt;/code&gt; 추가 하고 프로그램을 컴파일하여 직접 확인할 수 있습니다 . 또 다른 차이점은 일반적인 &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; 을 중단 ( 대신 호출 할 수 있음)하는 대신 &lt;a href=&quot;macros#error&quot;&gt;오류 proc&lt;/a&gt; (14 행)을 호출한다는 것 입니다. &lt;code&gt;error&lt;/code&gt; 로 PROC는 같은 동작을 가지고 &lt;code&gt;quit&lt;/code&gt; 뿐만 아니라 오류가 발생 소스 및 파일 라인 정보를 덤프, 쉽게 컴파일이 실패 곳 프로그래머가 찾을 수 있도록. 이 상황에서는 매크로를 호출하는 행을 &lt;code&gt;data.cfg&lt;/code&gt; 만 처리 중인 data.cfg 행은 나타내지 &lt;strong&gt;않습니다&lt;/strong&gt; . 즉, 매크로 자체가 제어해야하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b1927317fdc7e6a2effb5166b6eaa7c316bb014" translate="yes" xml:space="preserve">
          <source>You may add a constraint to the resulting type to trigger a compile-time error if the expression doesn't have the expected type:</source>
          <target state="translated">식에 예상 형식이없는 경우 결과 형식에 제약 조건을 추가하여 컴파일 타임 오류를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f30ee997aa1c1a9a827cafb053cce15b31f0463" translate="yes" xml:space="preserve">
          <source>You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.</source>
          <target state="translated">HTTP 요청 중에 호출 할 콜백 프로 시저를 지정할 수 있습니다. 이 콜백은 1 초마다 HTTP 요청 진행에 대한 정보와 함께 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5dd8d98d03acf607976a61f844d04f595a458ee9" translate="yes" xml:space="preserve">
          <source>You must create a new SSL context with the &lt;code&gt;newContext&lt;/code&gt; function defined in the &lt;code&gt;net&lt;/code&gt; module. You may then call &lt;code&gt;wrapSocket&lt;/code&gt; on your socket using the newly created SSL context to get an SSL socket.</source>
          <target state="translated">&lt;code&gt;net&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;newContext&lt;/code&gt; 함수를 사용하여 새 SSL 컨텍스트를 작성해야합니다 . 그런 다음 새로 작성된 SSL 컨텍스트를 사용하여 소켓에서 &lt;code&gt;wrapSocket&lt;/code&gt; 을 호출 하여 SSL 소켓을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b36e9e49af8f68c7f3865ace300bab1eeae94fdd" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;em&gt;config&lt;/em&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;em&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/em&gt; proc.</source>
          <target state="translated">이 모듈의 다른 &lt;code&gt;RstGenerator&lt;/code&gt; 와 함께 RstGenerator 를 사용하기 전에 이것을 호출해야 합니다. HTML 출력 생성기에서 사용하는 매개 변수를 사용하여 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;StringTableRef&lt;/code&gt; 값을 &lt;em&gt;구성&lt;/em&gt; 으로 전달하십시오. 무엇을 사용해야할지 모르는 경우 &lt;em&gt;defaultConfig () &amp;lt;#defaultConfig&amp;gt; _&lt;/em&gt; proc 의 결과를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6aec2725098b8ffc1761bd9c7f7b9f1682bf6e2" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="translated">이전에는 &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; proc 을 사용하여 색인에 항목을 추가해야합니다 . 색인이 비어 있으면 파일이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d047869868e7ac2dd137df50888c63412be12d0" translate="yes" xml:space="preserve">
          <source>You should send this before sending your HTML page, for example.</source>
          <target state="translated">예를 들어 HTML 페이지를 보내기 전에이를 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="3d103567ee18cb5218c37709ddcec0d6177298f4" translate="yes" xml:space="preserve">
          <source>You will also have to compile with &lt;code&gt;ssl&lt;/code&gt; defined like so: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt;.</source>
          <target state="translated">또한 컴파일해야합니다 &lt;code&gt;ssl&lt;/code&gt; 과 같이 정의 : &lt;code&gt;nim c -d:ssl ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="058062ffe3d7415398c63db4c4c474b3de0c89a9" translate="yes" xml:space="preserve">
          <source>Zero or One</source>
          <target state="translated">0 또는 1</target>
        </trans-unit>
        <trans-unit id="42ff50143f9dda79f19f7750e8d1e6ebfb6a9117" translate="yes" xml:space="preserve">
          <source>Zero or more</source>
          <target state="translated">0 이상</target>
        </trans-unit>
        <trans-unit id="5a0e6558a1175af4a938d82662dd24b2fa417681" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="translated">0 이상 : 성공하는 한 텍스트 &lt;em&gt;E&lt;/em&gt; 와 일치하도록 식 &lt;em&gt;E를&lt;/em&gt; 반복해서 적용 합니다. 일치하는 텍스트를 사용하십시오 (있는 경우). 항상 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88a721c45ae571dec5e2aa89e2c4b85966c95f70" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;em&gt;E&lt;/em&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="translated">0 또는 1 : 식 &lt;em&gt;E&lt;/em&gt; 가 앞의 텍스트와 일치하면 소비하십시오. 항상 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2af78455018bdfce1224f9a413429c8d1cf682b3" translate="yes" xml:space="preserve">
          <source>Zero value for durations. Useful for comparisons.</source>
          <target state="translated">지속 기간에 대한 값이 없습니다. 비교에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6060a4786b6be76ff108ebceec44d2daa4c15f06" translate="yes" xml:space="preserve">
          <source>Zero-indexed counting have two shortcuts &lt;code&gt;..&amp;lt;&lt;/code&gt; and &lt;code&gt;..^&lt;/code&gt; to simplify counting to one less than the higher index:</source>
          <target state="translated">제로 인덱싱 카운팅에는 더 높은 인덱스보다 1보다 적은 카운팅을 단순화하기 위해 두 개의 바로 가기 &lt;code&gt;..&amp;lt;&lt;/code&gt; 및 &lt;code&gt;..^&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be19fd422dffae7a0636938f97b2aa24b5cb13a9" translate="yes" xml:space="preserve">
          <source>[default(T), ...]</source>
          <target state="translated">[default(T), ...]</target>
        </trans-unit>
        <trans-unit id="a6181759dbfbc1d13cea8897bba860e1cd1f1b7f" translate="yes" xml:space="preserve">
          <source>a channel for thread communication</source>
          <target state="translated">스레드 통신을위한 채널</target>
        </trans-unit>
        <trans-unit id="ceb1c4b07f128179a3a629f3d8297730fe20d8c2" translate="yes" xml:space="preserve">
          <source>a color stored as RGB</source>
          <target state="translated">RGB로 저장된 색상</target>
        </trans-unit>
        <trans-unit id="d0b439a1db8b1636f87a882db4e959779e8dfe6b" translate="yes" xml:space="preserve">
          <source>a compiled regular expression</source>
          <target state="translated">컴파일 된 정규식</target>
        </trans-unit>
        <trans-unit id="446a499c83ee189e881728b9614bb1c610b42820" translate="yes" xml:space="preserve">
          <source>a complex number, consisting of a real and an imaginary part</source>
          <target state="translated">실수 부와 허수 부로 구성된 복소수</target>
        </trans-unit>
        <trans-unit id="d4c0dd8cbb911234aafd65e42ebe2e16d8dd9a13" translate="yes" xml:space="preserve">
          <source>a convenience proc that runs the &lt;em&gt;command&lt;/em&gt;, grabs all its output and exit code and returns both.</source>
          <target state="translated">&lt;em&gt;명령&lt;/em&gt; 을 실행하고 모든 출력 및 종료 코드를 잡고 둘 다 리턴 하는 편리한 proc .</target>
        </trans-unit>
        <trans-unit id="3d1d312821fd56659d05a796c0721e1a9ac1ecd1" translate="yes" xml:space="preserve">
          <source>a convenience procedure for:</source>
          <target state="translated">다음에 대한 편의 절차 :</target>
        </trans-unit>
        <trans-unit id="697ab90ee8ea779b4e9d7e4d582cc0de7bbcb857" translate="yes" xml:space="preserve">
          <source>a data flow variable</source>
          <target state="translated">데이터 흐름 변수</target>
        </trans-unit>
        <trans-unit id="236302a21803b39674181eb1c1e1dad827d987da" translate="yes" xml:space="preserve">
          <source>a distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="translated">하는 고유 한 문자열 유형 &lt;span id=&quot;tainted_1&quot;&gt;오염은&lt;/span&gt; 참조 &lt;a href=&quot;manual#taint-mode&quot;&gt;더러운 모드에&lt;/a&gt; 대한 자세한 내용을. 오염 모드가 켜져 있지 않으면 &lt;code&gt;string&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="24c60b77672236b3310392791c9159e7da691559" translate="yes" xml:space="preserve">
          <source>a doubly linked list</source>
          <target state="translated">이중 연결 목록</target>
        </trans-unit>
        <trans-unit id="92f8d2cb7eddeae18a8926cceebe9ab14e904d46" translate="yes" xml:space="preserve">
          <source>a doubly linked ring</source>
          <target state="translated">이중 연결 고리</target>
        </trans-unit>
        <trans-unit id="9667a5641fafbc88c7babe208bd484588610acb6" translate="yes" xml:space="preserve">
          <source>a handle that can be</source>
          <target state="translated">될 수있는 손잡이</target>
        </trans-unit>
        <trans-unit id="c673f94589cd025a94f4df85ea7cbc620e46a6b6" translate="yes" xml:space="preserve">
          <source>a handle that can be used to get a row's column text on demand</source>
          <target state="translated">요청시 행의 열 텍스트를 얻는 데 사용할 수있는 핸들</target>
        </trans-unit>
        <trans-unit id="9e35a0ed419e04673fabc57db7de755c9a5158d9" translate="yes" xml:space="preserve">
          <source>a handle to a dynamically loaded library</source>
          <target state="translated">동적으로로드 된 라이브러리에 대한 핸들</target>
        </trans-unit>
        <trans-unit id="727eb5fb1890186a7705b301c37bcb5a3a011c04" translate="yes" xml:space="preserve">
          <source>a hash value; hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="translated">해시 값; 이 값을 사용하는 해시 테이블의 크기는 항상 2의 거듭 제곱이어야 하며 해시 값을 자르기 위해 &lt;code&gt;mod&lt;/code&gt; 대신 &lt;code&gt;and&lt;/code&gt; 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb7c3a20e1c58ee4786768f999120ebe9f74132e" translate="yes" xml:space="preserve">
          <source>a identifier for the prepared queries</source>
          <target state="translated">준비된 쿼리의 식별자</target>
        </trans-unit>
        <trans-unit id="e15266dcad2adbaa4f2ad63108ef729cf76beda5" translate="yes" xml:space="preserve">
          <source>a node a doubly linked list consists of</source>
          <target state="translated">이중 연결리스트로 구성된 노드</target>
        </trans-unit>
        <trans-unit id="5ba782577875c08c01d890dce7e8dd4aecffd0bd" translate="yes" xml:space="preserve">
          <source>a node a singly linked list consists of</source>
          <target state="translated">단독으로 연결된 목록으로 구성된 노드</target>
        </trans-unit>
        <trans-unit id="c5092df10e1c3e85e7d83e22f3d8ff19de9aee98" translate="yes" xml:space="preserve">
          <source>a parallel section can be used to execute a block in parallel. &lt;code&gt;body&lt;/code&gt; has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.</source>
          <target state="translated">병렬 섹션은 블록을 병렬로 실행하는 데 사용될 수 있습니다. &lt;code&gt;body&lt;/code&gt; 는 언어의 특정 하위 집합 인 DSL에 있어야합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b464620548b26647c2039d50b3534a202b2e5405" translate="yes" xml:space="preserve">
          <source>a rational number, consisting of a numerator and denominator</source>
          <target state="translated">분자와 분모로 구성된 유리수</target>
        </trans-unit>
        <trans-unit id="69540ea7fe9bd9fdc5e24939d260de6bfcf3083e" translate="yes" xml:space="preserve">
          <source>a row in a CSV file</source>
          <target state="translated">CSV 파일의 행</target>
        </trans-unit>
        <trans-unit id="a5ec37625145ddf6373e511cf4b862af7fe73b7a" translate="yes" xml:space="preserve">
          <source>a row of a dataset. NULL database values will be converted to nil.</source>
          <target state="translated">데이터 세트의 행 NULL 데이터베이스 값은 nil로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="db9fa41fb39e8c2391daf5b73b38611f05be5128" translate="yes" xml:space="preserve">
          <source>a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="translated">'..'와 '^'사이에 공백이 필요하다는 일반적인 문제를 피하기 위해 '.. ^'에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="302bd8c00ad8f3e86bc63558821e98698620a746" translate="yes" xml:space="preserve">
          <source>a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.</source>
          <target state="translated">'a .. (b가 BackwardsIndex 인 경우 succ (b) else : pred (b))'에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="440e2c2edfe2d93548694539384ebaec70e26a08" translate="yes" xml:space="preserve">
          <source>a shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt; 의 줄임말 ; quit (errorcode) .</target>
        </trans-unit>
        <trans-unit id="f1ea92069e80f9a3e02b527138ba54f9fbd0ee56" translate="yes" xml:space="preserve">
          <source>a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="translated">스폰 된 모든 작업을 기다리는 간단한 장벽. 좀 더 정교한 대기가 필요한 경우, 명시적인 장벽을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c6d3caa14558753d210d77ea2d36fd6a1513d28" translate="yes" xml:space="preserve">
          <source>a single backslash</source>
          <target state="translated">단일 백 슬래시</target>
        </trans-unit>
        <trans-unit id="837f51c3591f8b2d4452f90b5ddbc53e912a5c22" translate="yes" xml:space="preserve">
          <source>a singly linked list</source>
          <target state="translated">단독으로 연결된 목록</target>
        </trans-unit>
        <trans-unit id="216912de21be007513f346fea51719c0bc9710bb" translate="yes" xml:space="preserve">
          <source>a singly linked ring</source>
          <target state="translated">단일 연결 고리</target>
        </trans-unit>
        <trans-unit id="fca33daf462dcc183c16697e01011fdb26d89e19" translate="yes" xml:space="preserve">
          <source>a standard ASCII identifier: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</source>
          <target state="translated">표준 ASCII 식별자 : &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d78f86643008d4db0ec1bb8602ad193b2839d13" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;File&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 을 캡슐화하는 스트림&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c6c55b76ac43aa1bd1841c6cca1606179fd844" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;MemFile&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MemFile&lt;/em&gt; 을 캡슐화하는 스트림&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86e6a991d0bca4656b36ada97342374f6e9a343" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a string</source>
          <target state="translated">문자열을 캡슐화하는 스트림</target>
        </trans-unit>
        <trans-unit id="43bd8c81bc8b1cc0db1629419cf49867fb9cbc47" translate="yes" xml:space="preserve">
          <source>a string that describes the application type. Possible values: &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;.</source>
          <target state="translated">응용 프로그램 유형을 설명하는 문자열 가능한 값은 &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="78097f72ab7bfacc92af44cb293dd8fef3e05b08" translate="yes" xml:space="preserve">
          <source>a string that describes the host CPU. Possible values: &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot;, &quot;mips64el&quot;, &quot;riscv64&quot;.</source>
          <target state="translated">호스트 CPU를 설명하는 문자열 가능한 값 : &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot; , &quot;mips64el&quot;, &quot;riscv64&quot;.</target>
        </trans-unit>
        <trans-unit id="2904b6a5abddd9d8deb65901f6588cd84e307512" translate="yes" xml:space="preserve">
          <source>a string that describes the host operating system. Possible values: &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;.</source>
          <target state="translated">호스트 운영 체제를 설명하는 문자열 가능한 값은 &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5c43be61e01495675e75b60bd73d6e649f9ba570" translate="yes" xml:space="preserve">
          <source>a superset of datatypes that might be supported.</source>
          <target state="translated">지원 될 수있는 데이터 유형의 상위 집합</target>
        </trans-unit>
        <trans-unit id="dd596fb483edcb41239e2551baec03a2edb03189" translate="yes" xml:space="preserve">
          <source>abstract logger; the base type of all loggers</source>
          <target state="translated">추상 로거; 모든 로거의 기본 유형</target>
        </trans-unit>
        <trans-unit id="4731f8a1ebe230c0bedc849397e5106693c2e5fe" translate="yes" xml:space="preserve">
          <source>accepts a single string argument and treats it as nim code that should be inserted verbatim in the program Example:</source>
          <target state="translated">단일 문자열 인수를 허용하고 프로그램에 그대로 삽입해야하는 nim 코드로 처리합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f104b049910f12d603b0f4b7c5560b09c7ab62fa" translate="yes" xml:space="preserve">
          <source>accepts node of kind nnkSym and returns its owner's symbol. result is also mnde of kind nnkSym if owner exists otherwise nnkNilLit is returned</source>
          <target state="translated">nnkSym 종류의 노드를 허용하고 소유자의 기호를 반환합니다. 소유자가 존재하는 경우 결과는 nnkSym 종류의 mnde입니다. 그렇지 않으면 nnkNilLit가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="beb500ee45bc07d7f3123c3ca655180cc9023baf" translate="yes" xml:space="preserve">
          <source>accessor for an any &lt;em&gt;x&lt;/em&gt; that represents an array or a sequence.</source>
          <target state="translated">배열 또는 시퀀스를 나타내는 모든 &lt;em&gt;x에&lt;/em&gt; 대한 접근 자입니다 .</target>
        </trans-unit>
        <trans-unit id="3641386853a01ac8136dde5cb98616d8122c4f64" translate="yes" xml:space="preserve">
          <source>activate 'see source' for doc and doc2 commands (see doc.item.seesrc in config/nimdoc.cfg)</source>
          <target state="translated">doc 및 doc2 명령에 대해 '소스 참조'를 활성화하십시오 (config / nimdoc.cfg의 doc.item.seesrc 참조)</target>
        </trans-unit>
        <trans-unit id="b2f4817d8ea2f060465d17fd1e0c9621ca128ab6" translate="yes" xml:space="preserve">
          <source>acyclic pragma</source>
          <target state="translated">비 환식 프라 그마</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="be654d44da0556a5cfc0c3960f4b0e5d8c7691a8" translate="yes" xml:space="preserve">
          <source>add RunningRegress &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="translated">RunningRegress &lt;em&gt;b&lt;/em&gt; 를 &lt;em&gt;a에&lt;/em&gt; 추가&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38f3963a1c27dc57f14b32ec31702841246839ac" translate="yes" xml:space="preserve">
          <source>add a path for Nimble support</source>
          <target state="translated">민첩한 지원을위한 경로 추가</target>
        </trans-unit>
        <trans-unit id="e52b43b0c3ff4c80cba13b5fbe245ef430bb9267" translate="yes" xml:space="preserve">
          <source>add a second RunningStats &lt;em&gt;b&lt;/em&gt; to &lt;em&gt;a&lt;/em&gt;</source>
          <target state="translated">제 RunningStats 추가 &lt;em&gt;b를&lt;/em&gt; 행&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c15cd5c97ee3e7837ac1a6c57b0ec58e743aa0cf" translate="yes" xml:space="preserve">
          <source>add an automatically imported module</source>
          <target state="translated">자동으로 가져온 모듈 추가</target>
        </trans-unit>
        <trans-unit id="d006e72468553c812ce58018ffee86b98a1de727" translate="yes" xml:space="preserve">
          <source>add an automatically included module</source>
          <target state="translated">자동으로 포함 된 모듈 추가</target>
        </trans-unit>
        <trans-unit id="1a8ccf0416a8d5978779e3ecf6029e129bf6622d" translate="yes" xml:space="preserve">
          <source>add path to search paths</source>
          <target state="translated">검색 경로에 경로 추가</target>
        </trans-unit>
        <trans-unit id="00ff37c92cbfa69ed6d8a1ee9a213181f165d944" translate="yes" xml:space="preserve">
          <source>additional packages for the distribution</source>
          <target state="translated">배포를위한 추가 패키지</target>
        </trans-unit>
        <trans-unit id="6743cab27b3049919b02e0ba0d3ffe4227363a60" translate="yes" xml:space="preserve">
          <source>additional signed integer types of XX bits use this naming scheme (example: int16 is a 16 bit wide integer). The current implementation supports &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Literals of these types have the suffix 'iXX.</source>
          <target state="translated">XX 비트의 추가 부호있는 정수 유형은이 이름 지정 체계를 사용합니다 (예 : int16은 16 비트 폭의 정수임). 현재 구현은 &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; 를 지원합니다 . 이러한 유형의 리터럴에는 접미사 'iXX가 있습니다.</target>
        </trans-unit>
        <trans-unit id="635d7e51a3815812414d121a44ae70a4032af75d" translate="yes" xml:space="preserve">
          <source>additional unsigned integer types of XX bits use this naming scheme (example: uint16 is a 16 bit wide unsigned integer). The current implementation supports &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. Literals of these types have the suffix 'uXX. Unsigned operations all wrap around; they cannot lead to over- or underflow errors.</source>
          <target state="translated">추가 부호없는 정수 유형 XX 비트는이 이름 지정 체계를 사용합니다 (예 : uint16은 16 비트 너비의 부호없는 정수임). 현재 구현은 &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;uint32&lt;/code&gt; , &lt;code&gt;uint64&lt;/code&gt; 를 지원합니다 . 이러한 유형의 리터럴에는 접미사 'uXX가 있습니다. 서명되지 않은 작업은 모두 마무리됩니다. 오버플로 또는 언더 플로 오류가 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38c0eb29005c66f68f255094fa7f2452b189e538" translate="yes" xml:space="preserve">
          <source>adds &lt;em&gt;b&lt;/em&gt; to the rope &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">로프 &lt;em&gt;a에 b&lt;/em&gt; 를 추가 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a82969e97be5f2882f61b8d06bb03c94458061e4" translate="yes" xml:space="preserve">
          <source>adds the child &lt;em&gt;son&lt;/em&gt; to &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">아이 &lt;em&gt;아들&lt;/em&gt; 을 &lt;em&gt;아버지&lt;/em&gt; 에게 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="aeb5b52f9e214a298005774ba529cab866982f54" translate="yes" xml:space="preserve">
          <source>adds the textual representation of &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;result&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 의 텍스트 표현 을 &lt;em&gt;result에&lt;/em&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="93091c2d09b2ad7ca8e9bacf9c97757310394cf5" translate="yes" xml:space="preserve">
          <source>adds two colors: This uses saturated artithmetic, so that each color component cannot overflow (255 is used as a maximum).</source>
          <target state="translated">두 가지 색상을 추가합니다. 포화 관절을 사용하므로 각 색상 구성 요소가 오버플로 할 수 없습니다 (255가 최대 값으로 사용됨).</target>
        </trans-unit>
        <trans-unit id="70b840f37b0e8955863eaaf0c39b4e8bc2494a84" translate="yes" xml:space="preserve">
          <source>after lookup pass: &lt;code&gt;nnkSym(strVal = &quot;myIdentifier&quot;, ...)&lt;/code&gt;</source>
          <target state="translated">조회 후 : &lt;code&gt;nnkSym(strVal = &quot;myIdentifier&quot;, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e108a968cadd854d13bc3b3948ea2ed2074a6ca1" translate="yes" xml:space="preserve">
          <source>alarm, that is, the BEL character (hex 07)</source>
          <target state="translated">알람, 즉 BEL 문자 (16 진 07)</target>
        </trans-unit>
        <trans-unit id="9a53b0819e7b65cebdd2f94ad43011ac678d3fc3" translate="yes" xml:space="preserve">
          <source>algorithm</source>
          <target state="translated">algorithm</target>
        </trans-unit>
        <trans-unit id="6bcdc475a77368f9553c2f9b16d757fb113a0b27" translate="yes" xml:space="preserve">
          <source>algorithm.*</source>
          <target state="translated">algorithm.*</target>
        </trans-unit>
        <trans-unit id="eed67bfcd90ff2bde24b027a916e8dc6179bc669" translate="yes" xml:space="preserve">
          <source>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</source>
          <target state="translated">AST 노드의 컨테이너에 대한 알고리즘; AST를 YAML로 변환하는 단계; 심볼 테이블</target>
        </trans-unit>
        <trans-unit id="e6d0b03f10de095d5459cdb68303b689612deebd" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="c337d5a49dab1e36919aec1df636ec82dc97cc9d" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="132044e5591404c5419f7b9d0b83a9c482aa7d34" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;contains&lt;/em&gt;.</source>
          <target state="translated">별칭이 &lt;em&gt;포함되어 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b9d18988fa4de8a2b53ca8aa8f2745d9d349db6f" translate="yes" xml:space="preserve">
          <source>alias for &lt;em&gt;len() &amp;lt;#len&amp;gt;&lt;/em&gt; _.</source>
          <target state="translated">&lt;em&gt;len () &amp;lt;#len&amp;gt;&lt;/em&gt; _의 별명 .</target>
        </trans-unit>
        <trans-unit id="52c4fff4212b87f102c0a1b2e9144a46079b9947" translate="yes" xml:space="preserve">
          <source>alias of &lt;em&gt;hasKey&lt;/em&gt; for use with the &lt;em&gt;in&lt;/em&gt; operator.</source>
          <target state="translated">&lt;em&gt;in&lt;/em&gt; 연산자 와 함께 사용하기위한 &lt;em&gt;hasKey의&lt;/em&gt; 별명 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dcb694c7648187b986a6c25cb54ec3810cea88e" translate="yes" xml:space="preserve">
          <source>all of the expressions within the body can be compiled for the tested type</source>
          <target state="translated">본문 내 모든 표현식을 테스트 된 유형에 맞게 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d63dd6433be0a0577b6741e68292848325c9c42" translate="yes" xml:space="preserve">
          <source>all statically evaluable boolean expressions in the body must be true</source>
          <target state="translated">본문에서 정적으로 평가 가능한 모든 부울 표현식은 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1ec845402601c65b31a01099140d022e5011c2c8" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createSharedU&lt;/code&gt;.</source>
          <target state="translated">최소 &lt;code&gt;T.sizeof * size&lt;/code&gt; 바이트 를 사용하여 공유 힙에 새 메모리 블록을 할당 합니다. 블록은 &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; 또는 &lt;code&gt;freeShared(block)&lt;/code&gt; 으로 해제되어야 합니다. 블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;code&gt;createSharedU&lt;/code&gt; 보다 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="e189b8a859afa5cb84762353f1f6ad86c61ac06e" translate="yes" xml:space="preserve">
          <source>allocates a new memory block on the shared heap with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; or &lt;code&gt;freeShared(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">최소 &lt;code&gt;T.sizeof * size&lt;/code&gt; 바이트 를 사용하여 공유 힙에 새 메모리 블록을 할당 합니다. 블록은 &lt;code&gt;resizeShared(block, 0)&lt;/code&gt; 또는 &lt;code&gt;freeShared(block)&lt;/code&gt; 으로 해제되어야 합니다. 블록이 초기화되지 않았으므로 쓰기 전에 블록에서 읽는 것은 정의되지 않은 동작입니다!</target>
        </trans-unit>
        <trans-unit id="f51a8d093a0a153f627e0b13d8e7a71628d6e3e9" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;code&gt;createU&lt;/code&gt;. The allocated memory belongs to its allocating thread! Use &lt;em&gt;createShared&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="translated">최소 &lt;code&gt;T.sizeof * size&lt;/code&gt; 바이트 로 새 메모리 블록을 할당 합니다. 블록은 &lt;code&gt;resize(block, 0)&lt;/code&gt; 또는 &lt;code&gt;dealloc(block)&lt;/code&gt; 으로 해제되어야 합니다. 블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;code&gt;createU&lt;/code&gt; 보다 안전 합니다. 할당 된 메모리는 할당 스레드에 속합니다! &lt;em&gt;createShared&lt;/em&gt; 를 사용 하여 공유 힙에서 할당 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7137e112b520cb32d8116151366b12c17c968247" translate="yes" xml:space="preserve">
          <source>allocates a new memory block with at least &lt;code&gt;T.sizeof * size&lt;/code&gt; bytes. The block has to be freed with &lt;code&gt;resize(block, 0)&lt;/code&gt; or &lt;code&gt;dealloc(block)&lt;/code&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use &lt;em&gt;createSharedU&lt;/em&gt; to allocate from a shared heap.</source>
          <target state="translated">최소 &lt;code&gt;T.sizeof * size&lt;/code&gt; 바이트 로 새 메모리 블록을 할당 합니다. 블록은 &lt;code&gt;resize(block, 0)&lt;/code&gt; 또는 &lt;code&gt;dealloc(block)&lt;/code&gt; 으로 해제되어야 합니다. 블록이 초기화되지 않았으므로 쓰기 전에 블록에서 읽는 것은 정의되지 않은 동작입니다! 할당 된 메모리는 할당 스레드에 속합니다! &lt;em&gt;createSharedU&lt;/em&gt; 를 사용 하여 공유 힙에서 할당 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9815fc8c2a8f4e1b35d4236d3fae99d3efd09869" translate="yes" xml:space="preserve">
          <source>allow 'nil' for strings/seqs for backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해 문자열 / seq에 'nil'허용</target>
        </trans-unit>
        <trans-unit id="0c910f64af961b17f44fd191ab90b296114ff3dc" translate="yes" xml:space="preserve">
          <source>allowed values</source>
          <target state="translated">허용되는 값</target>
        </trans-unit>
        <trans-unit id="22f4fb40fbecf39d7d66ff344324ffd2846591d9" translate="yes" xml:space="preserve">
          <source>allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.</source>
          <target state="translated">Ctrl + C를 누르면 응용 프로그램의 동작을 무시할 수 있습니다. 이러한 후크는 하나만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2aa389cc2795b6479735978661974371833e7c52" translate="yes" xml:space="preserve">
          <source>also used for &lt;em&gt;number of elements&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;요소 수&lt;/em&gt; 에도 사용&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c561cc052fbc5ffee282dada5fc957da9fd5710" translate="yes" xml:space="preserve">
          <source>always spawns a new task on the worker thread with &lt;code&gt;id&lt;/code&gt;, so that the 'call' is &lt;strong&gt;always&lt;/strong&gt; executed on the thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;id&lt;/code&gt; 로 작업자 스레드에서 새 작업을 생성 하므로 스레드에서 &lt;strong&gt;항상&lt;/strong&gt; '호출'이 실행됩니다. 'call'은 proc call 'p (...)'이어야합니다. 여기서 'p'는 gcsafe이며 'void'이거나 &lt;code&gt;FlowVar[T]&lt;/code&gt; 와 호환되는 반환 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e037d1639b289c4e26bbc0c30ba6c431ce37c71" translate="yes" xml:space="preserve">
          <source>always spawns a new task, so that the 'call' is never executed on the calling thread. 'call' has to be proc call 'p(...)' where 'p' is gcsafe and has a return type that is either 'void' or compatible with &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">항상 새로운 작업을 생성하므로 호출 스레드에서 '호출'이 실행되지 않습니다. 'call'은 proc call 'p (...)'이어야합니다. 여기서 'p'는 gcsafe이며 'void'이거나 &lt;code&gt;FlowVar[T]&lt;/code&gt; 와 호환되는 반환 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="151cee3c709c4d5822ef05a1ddc9a86502399266" translate="yes" xml:space="preserve">
          <source>an OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="73b05bc5523a49f0f729d013bc15436c3ee98c1f" translate="yes" xml:space="preserve">
          <source>an RST node</source>
          <target state="translated">RST 노드</target>
        </trans-unit>
        <trans-unit id="8967ed81f37b78d187297570cfc0e002da7729e1" translate="yes" xml:space="preserve">
          <source>an RST node's description</source>
          <target state="translated">RST 노드의 설명</target>
        </trans-unit>
        <trans-unit id="71f5a9f32717a289921a20d9fc40fd3c347dad8b" translate="yes" xml:space="preserve">
          <source>an SQL abstract syntax tree node</source>
          <target state="translated">SQL 추상 구문 트리 노드</target>
        </trans-unit>
        <trans-unit id="12310d9e38855a443de673725c022b73aa6accc6" translate="yes" xml:space="preserve">
          <source>an SQL query string</source>
          <target state="translated">SQL 쿼리 문자열</target>
        </trans-unit>
        <trans-unit id="58be42ab5ccf2b1d725354c664c1c9d1a049d853" translate="yes" xml:space="preserve">
          <source>an XML tree consists of &lt;code&gt;XmlNode&lt;/code&gt;'s.</source>
          <target state="translated">XML 트리는 &lt;code&gt;XmlNode&lt;/code&gt; 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5805b81014eb065b07422ecce776bf0b349369e" translate="yes" xml:space="preserve">
          <source>an accumulator for regression calculations</source>
          <target state="translated">회귀 계산을위한 누산기</target>
        </trans-unit>
        <trans-unit id="bf87688aab1c6a062b31f453c9e7a123a6caf3f9" translate="yes" xml:space="preserve">
          <source>an accumulator for statistical data</source>
          <target state="translated">통계 데이터를위한 누산기</target>
        </trans-unit>
        <trans-unit id="a6e3ed0ced08ee631b0c37319f38559b39c3d487" translate="yes" xml:space="preserve">
          <source>an alias for 'send'.</source>
          <target state="translated">'보내기'의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="17954bd5b900ea1471af9e6fe5da9f60619dfdcd" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;HSlice[T, T]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HSlice[T, T]&lt;/code&gt; 의 별명 [T, T]</target>
        </trans-unit>
        <trans-unit id="a019f449e8c64bbc587d53abf7ab099d0b97f6df" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr float32&lt;/code&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="5e2bb9d99dad820df32fdfaf8060a4fd7276110f" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr float64&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr float64&lt;/code&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="359d828cee8b2007c3b07024f2b7d2dc9826bae9" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr int32&lt;/code&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="7d65af0e89de7e9f7a3b4e8b4b9ff1129722fe22" translate="yes" xml:space="preserve">
          <source>an alias for &lt;code&gt;ptr int64&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr int64&lt;/code&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="7403e6d178a09880f3e0b23ff146897e53d7b447" translate="yes" xml:space="preserve">
          <source>an alias for &lt;em&gt;renderSQL&lt;/em&gt;.</source>
          <target state="translated">별칭 &lt;em&gt;renderSQL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa0108528af89e539fdd667d14f686cfe81e4f7" translate="yes" xml:space="preserve">
          <source>an alias for a string to string mapping</source>
          <target state="translated">문자열 대 문자열 맵핑의 별명</target>
        </trans-unit>
        <trans-unit id="d8fe8bbb61c09319ee708a5efe7f650df5413428" translate="yes" xml:space="preserve">
          <source>an efficient set of 'int' implemented as a sparse bit set</source>
          <target state="translated">희소 비트 세트로 구현 된 효율적인 'int'세트</target>
        </trans-unit>
        <trans-unit id="1a1e58ab7b0394cdaa4e08d47a7393a2573f3745" translate="yes" xml:space="preserve">
          <source>an implementation may define additional floating point types of XX bits using this naming scheme (example: float64 is a 64 bit wide float). The current implementation supports &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;. Literals of these types have the suffix 'fXX.</source>
          <target state="translated">구현은이 이름 지정 체계를 사용하여 XX 비트의 추가 부동 소수점 유형을 정의 할 수 있습니다 (예 : float64는 64 비트 너비 float). 현재 구현은 &lt;code&gt;float32&lt;/code&gt; 및 &lt;code&gt;float64&lt;/code&gt; 를 지원합니다 . 이러한 유형의 리터럴에는 접미사 'fXX가 있습니다.</target>
        </trans-unit>
        <trans-unit id="13eb2e0ea344dca8fcab57fcf80481e8456bdaa0" translate="yes" xml:space="preserve">
          <source>and this code:</source>
          <target state="translated">그리고이 코드 :</target>
        </trans-unit>
        <trans-unit id="773bac1f038c7261c06dd562d3e88c52d6186053" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character</source>
          <target state="translated">&quot;단어가 아닌&quot;문자</target>
        </trans-unit>
        <trans-unit id="a5b4f6becbf49b5f440097b76eb71086cbdb2a8c" translate="yes" xml:space="preserve">
          <source>any &quot;non-word&quot; character: &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="translated">&quot;단어가 아닌&quot;문자 : &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbb1ab3493a026534f33f9de86e501fbba10bf1d" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character</source>
          <target state="translated">&quot;단어&quot;문자</target>
        </trans-unit>
        <trans-unit id="0fb3dd67a147ef444359e89f1fc469598768826b" translate="yes" xml:space="preserve">
          <source>any &quot;word&quot; character: &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;</source>
          <target state="translated">&quot;단어&quot;문자 : &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2af7fa85d682cfca6869619ab12b089bbedc11f" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ptr&lt;/code&gt; type</source>
          <target state="translated">모든 &lt;code&gt;ptr&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="d2a9ba0f67e27b921ff5c5a3f8c8c8532b81e663" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;ref&lt;/code&gt; type</source>
          <target state="translated">모든 &lt;code&gt;ref&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="c7f1406c1ae257c6a54cb24a67577fb91c8f2c42" translate="yes" xml:space="preserve">
          <source>any &lt;code&gt;var&lt;/code&gt; type</source>
          <target state="translated">모든 &lt;code&gt;var&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="45fb85b69ad14c45a89c623c70f23fe60fc970f3" translate="yes" xml:space="preserve">
          <source>any Unicode letter</source>
          <target state="translated">모든 유니 코드 문자</target>
        </trans-unit>
        <trans-unit id="2b58475581e603ea596720d3da0600db8eac7452" translate="yes" xml:space="preserve">
          <source>any Unicode lowercase letter</source>
          <target state="translated">유니 코드 소문자</target>
        </trans-unit>
        <trans-unit id="82a7803e43dc40a6d18691e4eb445841b8f4c29b" translate="yes" xml:space="preserve">
          <source>any Unicode title letter</source>
          <target state="translated">모든 유니 코드 제목</target>
        </trans-unit>
        <trans-unit id="1e096fd7f4d038d278b9e42fe47340a4ac798fe8" translate="yes" xml:space="preserve">
          <source>any Unicode uppercase letter</source>
          <target state="translated">모든 유니 코드 대문자</target>
        </trans-unit>
        <trans-unit id="02c23e11023caa64175fc2b4a61c25bfa1946f6c" translate="yes" xml:space="preserve">
          <source>any Unicode whitespace character</source>
          <target state="translated">모든 유니 코드 공백 문자</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">모든 배열 유형</target>
        </trans-unit>
        <trans-unit id="3dab8eeada09e9b30b6ff5265a5dbaa8bead2a0b" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit</source>
          <target state="translated">10 진수가 아닌 문자</target>
        </trans-unit>
        <trans-unit id="a1d38d834aca2863b3c8638b5d1049f11e10d0fe" translate="yes" xml:space="preserve">
          <source>any character that is not a decimal digit: &lt;code&gt;[^0-9]&lt;/code&gt;</source>
          <target state="translated">10 진수가 아닌 문자 : &lt;code&gt;[^0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05628852de66b9fc9ab7ccc2a7684852507b683f" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character</source>
          <target state="translated">공백 문자가 아닌 문자</target>
        </trans-unit>
        <trans-unit id="aeda72fde51bc293b14210dc49ac340fc60f0430" translate="yes" xml:space="preserve">
          <source>any character that is not a whitespace character: &lt;code&gt;[^ \9-\13]&lt;/code&gt;</source>
          <target state="translated">공백 문자가 아닌 문자 : &lt;code&gt;[^ \9-\13]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6634b62c48237338c00b5331263af4c43b87aa5" translate="yes" xml:space="preserve">
          <source>any decimal digit</source>
          <target state="translated">십진수</target>
        </trans-unit>
        <trans-unit id="a67f2ee53694f9eaecce9d4b927adc516269ad42" translate="yes" xml:space="preserve">
          <source>any decimal digit: &lt;code&gt;[0-9]&lt;/code&gt;</source>
          <target state="translated">소수점 이하 자릿수 : &lt;code&gt;[0-9]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1baab2f1eb74d608d7489859dab98499b03128ba" translate="yes" xml:space="preserve">
          <source>any distinct type</source>
          <target state="translated">다른 유형</target>
        </trans-unit>
        <trans-unit id="0cfd2075dc39382d468083735e1e4b96a0c2fe87" translate="yes" xml:space="preserve">
          <source>any enumeration</source>
          <target state="translated">모든 열거</target>
        </trans-unit>
        <trans-unit id="632b027e713f7c77c2851530c3e2eb699d27fabb" translate="yes" xml:space="preserve">
          <source>any float</source>
          <target state="translated">어떤 플로트</target>
        </trans-unit>
        <trans-unit id="0516ce3580fe749675be3f049693cbea215fb083" translate="yes" xml:space="preserve">
          <source>any integer type</source>
          <target state="translated">모든 정수 유형</target>
        </trans-unit>
        <trans-unit id="ab2a2e239e83a015601c8e253eccb6d928207ec2" translate="yes" xml:space="preserve">
          <source>any newline combination: &lt;code&gt;\10 / \13\10 / \13&lt;/code&gt;</source>
          <target state="translated">모든 줄 바꿈 조합 : &lt;code&gt;\10 / \13\10 / \13&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4743987c929c0cf7879ba69db4234c28b1936fe3" translate="yes" xml:space="preserve">
          <source>any object type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51da33275128bfada93b7fe172db417cdf661eec" translate="yes" xml:space="preserve">
          <source>any proc type</source>
          <target state="translated">모든 proc 유형</target>
        </trans-unit>
        <trans-unit id="d1ef1ac0f2fbb95f7d03f6c0575d2f6dd7cd44f5" translate="yes" xml:space="preserve">
          <source>any seq type</source>
          <target state="translated">어떤 seq 유형</target>
        </trans-unit>
        <trans-unit id="0ca9d57461d96f1e214aceba70e2030f0db409c0" translate="yes" xml:space="preserve">
          <source>any set type</source>
          <target state="translated">모든 세트 유형</target>
        </trans-unit>
        <trans-unit id="389a6d11b9875f6eb40c37282ad62cbe5608844a" translate="yes" xml:space="preserve">
          <source>any tuple type</source>
          <target state="translated">어떤 튜플 유형</target>
        </trans-unit>
        <trans-unit id="a28c54bd6aac059f8e4c1e9241bd9772b3d2a3a4" translate="yes" xml:space="preserve">
          <source>any type</source>
          <target state="translated">어떤 유형</target>
        </trans-unit>
        <trans-unit id="c9d581aa43044fba53f841ae21b312c1199cc2b2" translate="yes" xml:space="preserve">
          <source>any whitespace character</source>
          <target state="translated">공백 문자</target>
        </trans-unit>
        <trans-unit id="cbf727596d66c6d08060fb873659c9e83d971bd3" translate="yes" xml:space="preserve">
          <source>any whitespace character: &lt;code&gt;[ \9-\13]&lt;/code&gt;</source>
          <target state="translated">공백 문자 : &lt;code&gt;[ \9-\13]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d1043473d55bfa90e8530d35801d4e381bc69f0" translate="yes" xml:space="preserve">
          <source>app</source>
          <target state="translated">app</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="cf3ddbcb7cec2d2b9107f401606a80be88e173b3" translate="yes" xml:space="preserve">
          <source>appends a node &lt;em&gt;n&lt;/em&gt; to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="translated">노드 &lt;em&gt;n&lt;/em&gt; 을 &lt;em&gt;L에&lt;/em&gt; 추가합니다 . 효율 : O (1).</target>
        </trans-unit>
        <trans-unit id="394e90fc9086476ea2cc168904377cfdcaa95a5d" translate="yes" xml:space="preserve">
          <source>appends a value to &lt;em&gt;L&lt;/em&gt;. Efficiency: O(1).</source>
          <target state="translated">&lt;em&gt;L에&lt;/em&gt; 값을 추가합니다 . 효율 : O (1).</target>
        </trans-unit>
        <trans-unit id="d2005cc206ccbfdedf2be43a200cb050c538bdb5" translate="yes" xml:space="preserve">
          <source>application</source>
          <target state="translated">application</target>
        </trans-unit>
        <trans-unit id="06f720f81922363e28ffa5b9ea6b297a7c4ab084" translate="yes" xml:space="preserve">
          <source>applies &lt;code&gt;op&lt;/code&gt; to each of the &lt;strong&gt;atomic&lt;/strong&gt; literals like &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;&quot;abc&quot;&lt;/code&gt; in the specified &lt;code&gt;constructor&lt;/code&gt; AST. This can be used to map every array element to some target type:</source>
          <target state="translated">지정된 &lt;code&gt;constructor&lt;/code&gt; AST 에서 &lt;code&gt;3&lt;/code&gt; 또는 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 와 같은 각 &lt;strong&gt;원자&lt;/strong&gt; 리터럴에 &lt;code&gt;op&lt;/code&gt; 를 적용 합니다 . 모든 배열 요소를 대상 유형에 매핑하는 데 사용할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="601e3eae2caedfbe9867984df72affd5041c6f4a" translate="yes" xml:space="preserve">
          <source>argument - everything else</source>
          <target state="translated">논쟁-그 밖의 모든 것</target>
        </trans-unit>
        <trans-unit id="f8e5f3a667a852442823e459834bf798ce874870" translate="yes" xml:space="preserve">
          <source>arguments are passed to the program being run (if --run option is selected)</source>
          <target state="translated">인수는 실행중인 프로그램으로 전달됩니다 (--run 옵션이 선택된 경우)</target>
        </trans-unit>
        <trans-unit id="4390dce9df5136301038fcbfda456cfcefc40c26" translate="yes" xml:space="preserve">
          <source>array[0..., T]</source>
          <target state="translated">배열 [0 ..., T]</target>
        </trans-unit>
        <trans-unit id="bb9cf9882aa44ffb9a28e49e4ea13eac493f1cf0" translate="yes" xml:space="preserve">
          <source>asmNoStackFrame pragma</source>
          <target state="translated">asmNoStackFrame pragma</target>
        </trans-unit>
        <trans-unit id="e4a3803e63cafb4f45ce4da3b304606b0fb38156" translate="yes" xml:space="preserve">
          <source>assert end of string (or line, in multiline mode)</source>
          <target state="translated">문자열의 끝 (또는 여러 줄 모드에서 줄)</target>
        </trans-unit>
        <trans-unit id="2ab20e2dbc2d81949482cd67a19fb67418198995" translate="yes" xml:space="preserve">
          <source>assert start of string (or line, in multiline mode)</source>
          <target state="translated">문자열 시작 (또는 여러 줄 모드에서 줄)</target>
        </trans-unit>
        <trans-unit id="60544f107576aa75a3a16e2a4d455e8086f18203" translate="yes" xml:space="preserve">
          <source>assertion</source>
          <target state="translated">assertion</target>
        </trans-unit>
        <trans-unit id="120d25e6303ae7ca2cb354c13abcd5b71dbbd209" translate="yes" xml:space="preserve">
          <source>assertions</source>
          <target state="translated">assertions</target>
        </trans-unit>
        <trans-unit id="c24c0248770ae98831f8a654310d4c2e07514c61" translate="yes" xml:space="preserve">
          <source>ast</source>
          <target state="translated">ast</target>
        </trans-unit>
        <trans-unit id="7df52e645ceca43324a23db842d9058d2f5b083c" translate="yes" xml:space="preserve">
          <source>astalgo</source>
          <target state="translated">astalgo</target>
        </trans-unit>
        <trans-unit id="d59f43e7438cb25036fc655f0b8670b2f9530645" translate="yes" xml:space="preserve">
          <source>asyncdispatch</source>
          <target state="translated">asyncdispatch</target>
        </trans-unit>
        <trans-unit id="f3ccc3ccdfaaada264ca2c52da2860d14a1e629f" translate="yes" xml:space="preserve">
          <source>asyncdispatch.==</source>
          <target state="translated">asyncdispatch.==</target>
        </trans-unit>
        <trans-unit id="a4ab9637ac3aba19be3efe076a9fd74a9d4bf5ae" translate="yes" xml:space="preserve">
          <source>asyncfile</source>
          <target state="translated">asyncfile</target>
        </trans-unit>
        <trans-unit id="f215ff0b50d562a4f699305c138254c53a7e4e76" translate="yes" xml:space="preserve">
          <source>asyncftpclient</source>
          <target state="translated">asyncftpclient</target>
        </trans-unit>
        <trans-unit id="912d9cb1030b5696868d7cd061a1f1913fd22e54" translate="yes" xml:space="preserve">
          <source>asyncftpclient.cd()</source>
          <target state="translated">asyncftpclient.cd()</target>
        </trans-unit>
        <trans-unit id="7f9858036c96a49dead41c657601f55292eeb21b" translate="yes" xml:space="preserve">
          <source>asyncfutures</source>
          <target state="translated">asyncfutures</target>
        </trans-unit>
        <trans-unit id="6fac5c1c38ee66b71705a8698bdb25cd0c55009b" translate="yes" xml:space="preserve">
          <source>asyncfutures.$</source>
          <target state="translated">asyncfutures.$</target>
        </trans-unit>
        <trans-unit id="3e25c511c4dd4dd67c7bb70f3470a114aca1109f" translate="yes" xml:space="preserve">
          <source>asyncfutures.and</source>
          <target state="translated">asyncfutures.and</target>
        </trans-unit>
        <trans-unit id="b3959400d1c4f914e1d0d15e24d018f0b4bcd01d" translate="yes" xml:space="preserve">
          <source>asyncfutures.or</source>
          <target state="translated">asyncfutures.or</target>
        </trans-unit>
        <trans-unit id="16b484f4702399914b9685ac4a149df758f56412" translate="yes" xml:space="preserve">
          <source>asynchttpserver</source>
          <target state="translated">asynchttpserver</target>
        </trans-unit>
        <trans-unit id="4f5a0f016913fc4a169af7be4ea530a3a7d60ba2" translate="yes" xml:space="preserve">
          <source>asyncio</source>
          <target state="translated">asyncio</target>
        </trans-unit>
        <trans-unit id="df0aa08a1e718db729ddd29b35fcf08213931136" translate="yes" xml:space="preserve">
          <source>asyncjs</source>
          <target state="translated">asyncjs</target>
        </trans-unit>
        <trans-unit id="d7be09696c087802d819cf4a88b019da986579ce" translate="yes" xml:space="preserve">
          <source>asyncnet</source>
          <target state="translated">asyncnet</target>
        </trans-unit>
        <trans-unit id="f336018a344567452110d592d1db5dbd92b0c34e" translate="yes" xml:space="preserve">
          <source>asyncstreams</source>
          <target state="translated">asyncstreams</target>
        </trans-unit>
        <trans-unit id="d22d106d3ca7becc36b58971d80a432e61af2893" translate="yes" xml:space="preserve">
          <source>atomic decrement of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="translated">&lt;em&gt;memLoc의&lt;/em&gt; 원자 감소 . 작업 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cb8bb6a0a59b21438db5000a63cc7abf3e9ce50" translate="yes" xml:space="preserve">
          <source>atomic increment of &lt;em&gt;memLoc&lt;/em&gt;. Returns the value after the operation.</source>
          <target state="translated">&lt;em&gt;memLoc의&lt;/em&gt; 원자 적 증분 . 작업 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4e16c009563ab7ba71f544cdf093ed49bacede5" translate="yes" xml:space="preserve">
          <source>awaits any of the given flowVars. Returns the index of one flowVar for which a value arrived. A flowVar only supports one call to 'blockUntilAny' at the same time. That means if you blockUntilAny([a,b]) and blockUntilAny([b,c]) the second call will only blockUntil 'c'. If there is no flowVar left to be able to wait on, -1 is returned. &lt;strong&gt;Note&lt;/strong&gt;: This results in non-deterministic behaviour and should be avoided.</source>
          <target state="translated">주어진 flowVars를 기다립니다. 값이 도달 한 하나의 flowVar의 색인을 리턴합니다. flowVar는 'blockUntilAny'에 대한 한 번의 호출 만 동시에 지원합니다. 즉, UntilAny ([a, b]) 및 blockUntilAny ([b, c])를 차단하면 두 번째 호출은 'c'만 차단합니다. 기다릴 수있는 flowVar가 남아 있지 않으면 -1이 리턴됩니다. &lt;strong&gt;참고&lt;/strong&gt; : 이로 인해 비 결정적 동작이 발생하지 않으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="7090537b7970d7792c2dede512e03be486ed1bbd" translate="yes" xml:space="preserve">
          <source>base effect class; each effect should inherit from &lt;em&gt;RootEffect&lt;/em&gt; unless you know what you doing.</source>
          <target state="translated">기본 효과 클래스; 자신이하는 일을 알지 &lt;em&gt;못하면&lt;/em&gt; 각 효과는 &lt;em&gt;RootEffect&lt;/em&gt; 에서 상속되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ee727532b654c2d8318a0ca08971ba3017603d9" translate="yes" xml:space="preserve">
          <source>base name of $app</source>
          <target state="translated">$ app의 기본 이름</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="933558877f8bde9f7da0e625bdd25791b3547276" translate="yes" xml:space="preserve">
          <source>be case insensitive</source>
          <target state="translated">대소 문자를 구분하지 마십시오</target>
        </trans-unit>
        <trans-unit id="dbb99f9bee10af60b73c09287e19cf7ad76dc789" translate="yes" xml:space="preserve">
          <source>be style insensitive</source>
          <target state="translated">스타일에 둔감하다</target>
        </trans-unit>
        <trans-unit id="801fe5e4f0fe1c70c018f3c5364c1f0b8fcf0a8a" translate="yes" xml:space="preserve">
          <source>be verbose: list every processed file</source>
          <target state="translated">자세한 정보 : 처리 된 모든 파일 나열</target>
        </trans-unit>
        <trans-unit id="3077737626efcafd4a2545cfe7e2173b4b04bc26" translate="yes" xml:space="preserve">
          <source>binary &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[a, b]&lt;/code&gt;, both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.</source>
          <target state="translated">이진 &lt;span id=&quot;slice_1&quot;&gt;슬라이스&lt;/span&gt; 간격 구축 연산자 &lt;code&gt;[a, b]&lt;/code&gt; 모두 및 &lt;em&gt;B가&lt;/em&gt; 포함된다. 슬라이스는 set 생성자 및 순서 case 문에서도 사용할 수 있지만 컴파일러에서 특수한 경우입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94314a375a1c191f6ec01cc5b56e090a1db926cd" translate="yes" xml:space="preserve">
          <source>binary search for &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt;. Returns -1 if not found.</source>
          <target state="translated">이진 &lt;em&gt;키&lt;/em&gt; 를 검색 &lt;em&gt;합니다&lt;/em&gt; . 찾지 못하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09f0ceb4bf6383ebb1575eaa16ca08001738d7ed" translate="yes" xml:space="preserve">
          <source>binds an address/port number to a socket. Use address string in dotted decimal form like &quot;a.b.c.d&quot; or leave &quot;&quot; for any address.</source>
          <target state="translated">주소 / 포트 번호를 소켓에 바인딩합니다. 주소 문자열은 &quot;abcd&quot;와 같이 점으로 구분 된 10 진수 형식으로 사용하거나 주소에 &quot;&quot;를 그대로 두십시오.</target>
        </trans-unit>
        <trans-unit id="261e13cf94256fe14fb6c0700e4c3d15134a8a30" translate="yes" xml:space="preserve">
          <source>bitops</source>
          <target state="translated">bitops</target>
        </trans-unit>
        <trans-unit id="7ad3fef702b9b384e080a1dce5ae02d05c8c779a" translate="yes" xml:space="preserve">
          <source>bitwise OR of all supported exceptions</source>
          <target state="translated">지원되는 모든 예외의 비트 단위 OR</target>
        </trans-unit>
        <trans-unit id="b3bba832afd7bfee6a1ca7c4f0b72b17cde4452a" translate="yes" xml:space="preserve">
          <source>blocks until the &lt;code&gt;fv&lt;/code&gt; is available and then passes its value to &lt;code&gt;action&lt;/code&gt;. Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied and so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fv&lt;/code&gt; 를 사용할 수 있을 때까지 차단 한 다음 해당 값을 &lt;code&gt;action&lt;/code&gt; 에 전달합니다 . Nim의 매개 변수 전달 의미로 인해 &lt;code&gt;T&lt;/code&gt; 를 복사 할 필요가 없으므로 &lt;code&gt;awaitAndThen&lt;/code&gt; 이 &lt;code&gt;^&lt;/code&gt; 보다 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78af78bb4f4770be9ef1a285ca4b35516a2d260f" translate="yes" xml:space="preserve">
          <source>blocks until the value is available and then returns this value.</source>
          <target state="translated">값을 사용할 수있을 때까지 차단 한 다음이 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="3daef215d98d13fb11fb7258f01189d95d388907" translate="yes" xml:space="preserve">
          <source>boot command</source>
          <target state="translated">부팅 명령</target>
        </trans-unit>
        <trans-unit id="8e0e7d8f03334fea42f0fb9d4b102d890dd2bfeb" translate="yes" xml:space="preserve">
          <source>boundChecks</source>
          <target state="translated">boundChecks</target>
        </trans-unit>
        <trans-unit id="e7ab5809a76e914befcdd4f875ea24d6858e2e97" translate="yes" xml:space="preserve">
          <source>browsers</source>
          <target state="translated">browsers</target>
        </trans-unit>
        <trans-unit id="ab4c6d55c9b8536daa06dcfdad3b709bba8cfcf9" translate="yes" xml:space="preserve">
          <source>buffer handling of the lexical analyser</source>
          <target state="translated">어휘 분석기의 버퍼 처리</target>
        </trans-unit>
        <trans-unit id="3df0e93dd5f8bcbff09fd72f31c5b11e2f8df128" translate="yes" xml:space="preserve">
          <source>build an index for the whole documentation</source>
          <target state="translated">전체 문서에 대한 색인 작성</target>
        </trans-unit>
        <trans-unit id="c1d8fc3d3a068b5b94c44c9da7a309885eca0117" translate="yes" xml:space="preserve">
          <source>buildIndex</source>
          <target state="translated">buildIndex</target>
        </trans-unit>
        <trans-unit id="7899851775abcb391fbb3611e14c5806b38f217d" translate="yes" xml:space="preserve">
          <source>built-in 8 bit character type (unsigned)</source>
          <target state="translated">내장 8 비트 문자 유형 (서명되지 않음)</target>
        </trans-unit>
        <trans-unit id="3a8158c3d07cf2a1168a5614f07c2fd4e364863c" translate="yes" xml:space="preserve">
          <source>built-in boolean type</source>
          <target state="translated">내장형 부울 타입</target>
        </trans-unit>
        <trans-unit id="bdd6c8ca21c7bae842be59eef266709361858cd3" translate="yes" xml:space="preserve">
          <source>built-in cstring (&lt;em&gt;compatible string&lt;/em&gt;) type</source>
          <target state="translated">내장 cstring ( &lt;em&gt;호환 가능한 문자열&lt;/em&gt; ) 유형</target>
        </trans-unit>
        <trans-unit id="a744f5b9df007ccb6c80b67e250a9db549faa597" translate="yes" xml:space="preserve">
          <source>built-in generic traced pointer type</source>
          <target state="translated">내장 된 일반 추적 포인터 유형</target>
        </trans-unit>
        <trans-unit id="e977564d9044849b00d8e6d8f43daedcb02c9365" translate="yes" xml:space="preserve">
          <source>built-in generic untraced pointer type</source>
          <target state="translated">내장 된 일반 추적되지 않은 포인터 유형</target>
        </trans-unit>
        <trans-unit id="7492624ece266053123dd38ceccde7c465df2727" translate="yes" xml:space="preserve">
          <source>built-in pointer type, use the &lt;code&gt;addr&lt;/code&gt; operator to get a pointer to a variable</source>
          <target state="translated">내장 포인터 유형, &lt;code&gt;addr&lt;/code&gt; 연산자를 사용하여 변수에 대한 포인터 가져 오기</target>
        </trans-unit>
        <trans-unit id="6ffd7b6d3b34b66311cba6e4f638cbd97cdde3e8" translate="yes" xml:space="preserve">
          <source>built-in string type</source>
          <target state="translated">내장 문자열 유형</target>
        </trans-unit>
        <trans-unit id="2ba10a874b60e75db318a913365334b1eb96194b" translate="yes" xml:space="preserve">
          <source>builtin &lt;span id=&quot;roof_1&quot;&gt;roof&lt;/span&gt; operator that can be used for convenient array access. &lt;code&gt;a[^x]&lt;/code&gt; is a shortcut for &lt;code&gt;a[a.len-x]&lt;/code&gt;.</source>
          <target state="translated">편리한 어레이 액세스를 위해 사용할 수있는 내장 &lt;span id=&quot;roof_1&quot;&gt;루프&lt;/span&gt; 연산자. &lt;code&gt;a[^x]&lt;/code&gt; 는 &lt;code&gt;a[a.len-x]&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="3426efad09c70f3da2870ce5a1d60001e80166ec" translate="yes" xml:space="preserve">
          <source>c2nim</source>
          <target state="translated">c2nim</target>
        </trans-unit>
        <trans-unit id="56aa317711bf6e70a709f0b77b32eb3731f7f2b7" translate="yes" xml:space="preserve">
          <source>c2nim &lt;em&gt;processes&lt;/em&gt;&lt;code&gt;#ifdef C2NIM&lt;/code&gt; and &lt;code&gt;#ifndef C2NIM&lt;/code&gt; directives, but other &lt;code&gt;#if[def]&lt;/code&gt; directives are &lt;em&gt;translated&lt;/em&gt; into Nim's &lt;code&gt;when&lt;/code&gt; construct:</source>
          <target state="translated">c2nim &lt;em&gt;은 &lt;/em&gt; &lt;code&gt;#ifdef C2NIM&lt;/code&gt; 및 &lt;code&gt;#ifndef C2NIM&lt;/code&gt; 지시문을 처리하지만 다른 &lt;code&gt;#if[def]&lt;/code&gt; 지시문은 구성 &lt;code&gt;when&lt;/code&gt; Nim 으로 &lt;em&gt;변환&lt;/em&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb1aa66b99c882e1d48f845dbf6ed8a475c6027f" translate="yes" xml:space="preserve">
          <source>c2nim User's manual</source>
          <target state="translated">c2nim 사용자 매뉴얼</target>
        </trans-unit>
        <trans-unit id="8db503e64e7c067961c76a4f4ace96ea232a5bac" translate="yes" xml:space="preserve">
          <source>c2nim can be configured to skip certain &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; sections. If a directive &lt;code&gt;#assumedef SYMBOL``is found, c2nim will assume that the symbol ``SYMBOL&lt;/code&gt; is defined, and thus skip &lt;code&gt;#ifndef SYMBOL&lt;/code&gt; sections. The same happens if &lt;code&gt;SYMBOL&lt;/code&gt; is actually defined with a &lt;code&gt;#def&lt;/code&gt; directive.</source>
          <target state="translated">c2nim은 특정 &lt;code&gt;#ifdef&lt;/code&gt; 또는 &lt;code&gt;#ifndef&lt;/code&gt; 섹션 을 건너 뛰도록 구성 할 수 있습니다 . 지시문 &lt;code&gt;#assumedef SYMBOL``is found, c2nim will assume that the symbol ``SYMBOL&lt;/code&gt; 이 정의되어 있다고 가정 하여 &lt;code&gt;#ifndef SYMBOL&lt;/code&gt; 섹션 을 건너 뜁니다 . &lt;code&gt;SYMBOL&lt;/code&gt; 이 실제로 &lt;code&gt;#def&lt;/code&gt; 지시문으로 정의 된 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="ef0874a87826f5ff53f6c6bf9ffc5cfffc28c348" translate="yes" xml:space="preserve">
          <source>c2nim does not do any name mangling by default. However the &lt;code&gt;#prefix&lt;/code&gt; and &lt;code&gt;#suffix&lt;/code&gt; directives can be used to strip prefixes and suffixes from the identifiers in the C code:</source>
          <target state="translated">c2nim은 기본적으로 이름 맹 글링을 수행하지 않습니다. 그러나 &lt;code&gt;#prefix&lt;/code&gt; 및 &lt;code&gt;#suffix&lt;/code&gt; 지시문을 사용하면 C 코드의 식별자에서 접두사와 접미사를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99da162adf79f0a46dd9c3d7234d5d0ec8a77afe" translate="yes" xml:space="preserve">
          <source>c2nim is a tool to translate Ansi C code to Nim. The output is human-readable Nim code that is meant to be tweaked by hand after the translation process. c2nim is no real compiler!</source>
          <target state="translated">c2nim은 Ansi C 코드를 Nim으로 변환하는 도구입니다. 출력은 사람이 읽을 수있는 Nim 코드이며 번역 프로세스 후에 직접 수정해야합니다. c2nim은 실제 컴파일러가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="8088a888559eda6c07415159a9479d5d21a3cce5" translate="yes" xml:space="preserve">
          <source>c2nim is meant to translate fragments of C code and thus does not follow include files. c2nim cannot parse all of Ansi C and many constructs cannot be represented in Nim: for example &lt;span id=&quot;duff-s-device_1&quot;&gt;duff's device&lt;/span&gt; cannot be translated to Nim.</source>
          <target state="translated">c2nim은 C 코드 조각을 번역하기위한 것으로 include 파일을 따르지 않습니다. c2nim은 모든 Ansi C를 구문 분석 할 수 없으며 많은 구문을 Nim으로 표현할 수 없습니다. 예를 들어 &lt;span id=&quot;duff-s-device_1&quot;&gt;더프의 장치&lt;/span&gt; 를 Nim으로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b902834ab99b1e7d9ffa6d4609d2deeb057ee1ea" translate="yes" xml:space="preserve">
          <source>c2nim is preliminary meant to translate C header files. Because of this, the preprocessor is part of the parser. For example:</source>
          <target state="translated">c2nim은 C 헤더 파일을 번역하기위한 예비입니다. 이 때문에 전처리 기는 파서의 일부입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e09728599d3a33821bbaf9009c7a4ce84e73c3f8" translate="yes" xml:space="preserve">
          <source>c2nim's preprocessor supports special directives that affect how the output is generated. They should be put into a &lt;code&gt;#ifdef C2NIM&lt;/code&gt; section so that ordinary C compilers ignore them.</source>
          <target state="translated">c2nim의 전처리 기는 출력 생성 방법에 영향을주는 특수 지시문을 지원합니다. 일반 C 컴파일러가 무시하도록 &lt;code&gt;#ifdef C2NIM&lt;/code&gt; 섹션에 넣어야 합니다.</target>
        </trans-unit>
        <trans-unit id="04fbf5840ac1e9a5a1ceabb535b114715c54e34e" translate="yes" xml:space="preserve">
          <source>call this before starting to send your HTML data to &lt;em&gt;stdout&lt;/em&gt;. This implements this part of the CGI protocol:</source>
          <target state="translated">HTML 데이터를 &lt;em&gt;stdout&lt;/em&gt; 으로 보내기 전에 이것을 호출하십시오 . 이것은 CGI 프로토콜의이 부분을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="76c6e4c322f4edd978f4612f2138812be9dde505" translate="yes" xml:space="preserve">
          <source>callconv</source>
          <target state="translated">callconv</target>
        </trans-unit>
        <trans-unit id="acd79879f7dc678d227bb41344bcf33ae5d53c48" translate="yes" xml:space="preserve">
          <source>can be used in a &lt;code&gt;try&lt;/code&gt; statement to setup a Lisp-like &lt;span id=&quot;condition-system_1&quot;&gt;condition system&lt;/span&gt;: This prevents the 'raise' statement to raise an exception but instead calls &lt;code&gt;action&lt;/code&gt;. If &lt;code&gt;action&lt;/code&gt; returns false, the exception has been handled and does not propagate further through the call stack.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문에서 Lisp와 같은 &lt;span id=&quot;condition-system_1&quot;&gt;조건 시스템&lt;/span&gt; 을 설정하는 데 사용할 수 있습니다 . 이렇게하면 'raise'문이 예외를 발생시키지 않지만 대신 &lt;code&gt;action&lt;/code&gt; 을 호출 합니다 . 경우 &lt;code&gt;action&lt;/code&gt; false를 반환 예외가 처리 된 호출 스택을 통해 더 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64a41c147d5237aaf5ea8d854a3e539b0855f6c2" translate="yes" xml:space="preserve">
          <source>can be used to determine an enum compile-time option. Example:</source>
          <target state="translated">열거 형 컴파일 타임 옵션을 결정하는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="61bb814d0133b5fa4ff07d98a4f44ea9363df079" translate="yes" xml:space="preserve">
          <source>can be used to determine an on|off compile-time option. Example:</source>
          <target state="translated">on | off 컴파일 타임 옵션을 결정하는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="97f7f9e367f1d1a60f63849acd516acbb9199cfe" translate="yes" xml:space="preserve">
          <source>can be used to determine if a first class iterator has finished.</source>
          <target state="translated">첫 번째 클래스 반복자가 완료되었는지 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f22b9fbdbfca494dfb5fb443b40304f53942dc" translate="yes" xml:space="preserve">
          <source>can be used to ignore the whole code block</source>
          <target state="translated">전체 코드 블록을 무시하는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4de80ae5dfae7c9854dc8a8f5fc199837369b492" translate="yes" xml:space="preserve">
          <source>can represent any nim value; NOTE: the wrapped value can be modified with its wrapper! This means that &lt;code&gt;Any&lt;/code&gt; keeps a non-traced pointer to its wrapped value and &lt;strong&gt;must not&lt;/strong&gt; live longer than its wrapped value.</source>
          <target state="translated">모든 nim 값을 나타낼 수 있습니다. 참고 : 래핑 된 값은 래퍼로 수정할 수 있습니다! 즉, &lt;code&gt;Any&lt;/code&gt; 는 래핑되지 않은 포인터를 래핑 된 값으로 유지하며 래핑 된 값 보다 오래 살아서 &lt;strong&gt;는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4be5ac63e1ea62640409f639b010b9fb479c5b" translate="yes" xml:space="preserve">
          <source>cap</source>
          <target state="translated">cap</target>
        </trans-unit>
        <trans-unit id="7cb1f56d3fbe09e809244fc8e13671cd876e3860" translate="yes" xml:space="preserve">
          <source>capacity</source>
          <target state="translated">capacity</target>
        </trans-unit>
        <trans-unit id="0f2ba5867e198e37d5e93f508ce79d5a1539c992" translate="yes" xml:space="preserve">
          <source>carriage return (hex 0D)</source>
          <target state="translated">캐리지 리턴 (16 진 0D)</target>
        </trans-unit>
        <trans-unit id="00d49cc01704e5289e3b5794a9e5737d299ed928" translate="yes" xml:space="preserve">
          <source>cast[T](0); this may be an invalid value</source>
          <target state="translated">캐스트 [T] (0); 이것은 유효하지 않은 값일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="066cf57dd5805ecd80ecc03cc26eb4b65a6ce47f" translate="yes" xml:space="preserve">
          <source>casting and other unsafe operations (&lt;code&gt;cast&lt;/code&gt; operator, &lt;code&gt;zeroMem&lt;/code&gt;, etc.)</source>
          <target state="translated">캐스팅 및 기타 안전하지 않은 작업 ( &lt;code&gt;cast&lt;/code&gt; 연산자, &lt;code&gt;zeroMem&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="6ed337e48425488d145f2d21babd664982100114" translate="yes" xml:space="preserve">
          <source>ccgexprs</source>
          <target state="translated">ccgexprs</target>
        </trans-unit>
        <trans-unit id="a44bb7c205ea7486d510ad850c061dbe6beb50e4" translate="yes" xml:space="preserve">
          <source>ccgstmts</source>
          <target state="translated">ccgstmts</target>
        </trans-unit>
        <trans-unit id="d918fc219f81cb04127cae18afe532825260c4f8" translate="yes" xml:space="preserve">
          <source>ccgtypes</source>
          <target state="translated">ccgtypes</target>
        </trans-unit>
        <trans-unit id="956d838ceaa5b452bd3b5c3f5e88f3843af0a219" translate="yes" xml:space="preserve">
          <source>ccgutils</source>
          <target state="translated">ccgutils</target>
        </trans-unit>
        <trans-unit id="4cbc897d2b77bba922b5e4a4b6494b5592aecb7b" translate="yes" xml:space="preserve">
          <source>cdecl|...</source>
          <target state="translated">cdecl|...</target>
        </trans-unit>
        <trans-unit id="6ed7efe0ffdee78d655e5ad60691472f0fb43b1c" translate="yes" xml:space="preserve">
          <source>cfg</source>
          <target state="translated">cfg</target>
        </trans-unit>
        <trans-unit id="8f3d60cfea547e1e20ad21fbc5cec120d1862ae2" translate="yes" xml:space="preserve">
          <source>cgen</source>
          <target state="translated">cgen</target>
        </trans-unit>
        <trans-unit id="27b4d0f8ee1e61a07904f1afd558aa878973f2d1" translate="yes" xml:space="preserve">
          <source>cgi</source>
          <target state="translated">cgi</target>
        </trans-unit>
        <trans-unit id="3536f72ac0ec1d785e357fed37a3e83c4bc651e2" translate="yes" xml:space="preserve">
          <source>channels</source>
          <target state="translated">channels</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="48236e5e509429b8fc8cd4a0ae77085dbfcc11bf" translate="yes" xml:space="preserve">
          <source>character type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b61a14ecbe64faf1953c4b4664c690480394da" translate="yes" xml:space="preserve">
          <source>character with hex code hh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013c472ea5d09f54bdfb3cde32d29f19d9443d0d" translate="yes" xml:space="preserve">
          <source>character with octal code ddd, or backreference</source>
          <target state="translated">8 진 코드 ddd를 가진 문자 또는 역 참조</target>
        </trans-unit>
        <trans-unit id="d56d985300d4b52eb6e189be006f44f8d23c5ec9" translate="yes" xml:space="preserve">
          <source>check</source>
          <target state="translated">check</target>
        </trans-unit>
        <trans-unit id="7354fb826ffdc2403867a40dc983e0214220b565" translate="yes" xml:space="preserve">
          <source>checks</source>
          <target state="translated">checks</target>
        </trans-unit>
        <trans-unit id="e7a6d680b00692d32ffb421968f88c3acd4d4604" translate="yes" xml:space="preserve">
          <source>checks if more data can be read from &lt;em&gt;f&lt;/em&gt;. Returns true if all data has been read.</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; 에서 더 많은 데이터를 읽을 수 있는지 확인합니다 . 모든 데이터를 읽은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="177feaf5a875f904bbb216efc1577b958b584596" translate="yes" xml:space="preserve">
          <source>checks if two MD5Digest values are identical</source>
          <target state="translated">두 MD5Digest 값이 동일한 지 확인</target>
        </trans-unit>
        <trans-unit id="d25b4520323ca9a79f3b710c170ab0e174922924" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has a number of children in the range &lt;code&gt;min..max&lt;/code&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">&lt;em&gt;n에 &lt;/em&gt; &lt;code&gt;min..max&lt;/code&gt; 범위의 자식 수가 있는지 확인합니다 . 그렇지 않은 경우 오류 메시지와 함께 컴파일이 중단됩니다. 인수 개수를 확인하는 매크로를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="098639b92545c1cc7038eba5da7047eed275e435" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has at least &lt;em&gt;min&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">검사는 &lt;em&gt;, n은&lt;/em&gt; 적어도 갖는 &lt;em&gt;분&lt;/em&gt; 어린이. 그렇지 않은 경우 오류 메시지와 함께 컴파일이 중단됩니다. 인수 개수를 확인하는 매크로를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5b1353b044cd6fe2ded4431b6429efece035e17d" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; has exactly &lt;em&gt;len&lt;/em&gt; children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 에 정확히 &lt;em&gt;len 개의&lt;/em&gt; 자식 이 있는지 확인합니다 . 그렇지 않은 경우 오류 메시지와 함께 컴파일이 중단됩니다. 인수 개수를 확인하는 매크로를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="639633341d390ded8cc566e2bd59883ca9297e04" translate="yes" xml:space="preserve">
          <source>checks that &lt;em&gt;n&lt;/em&gt; is of kind &lt;em&gt;k&lt;/em&gt;. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 이 &lt;em&gt;k&lt;/em&gt; 인지 확인합니다 . 그렇지 않은 경우 오류 메시지와 함께 컴파일이 중단됩니다. 전달 된 AST를 확인하는 매크로를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="17a80360b0c2de946b73432febb8a8236386a56f" translate="yes" xml:space="preserve">
          <source>checks the project for syntax and semantic</source>
          <target state="translated">구문과 의미를 위해 프로젝트를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e1d05dd5fd34693c4c55667580ded2aa7a8d5750" translate="yes" xml:space="preserve">
          <source>closes a channel &lt;em&gt;c&lt;/em&gt; and frees its associated resources.</source>
          <target state="translated">채널 &lt;em&gt;c를&lt;/em&gt; 닫고 연관된 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5eb3e1e39f61035591b3e8c17ebf406a1739f2b7" translate="yes" xml:space="preserve">
          <source>closes a socket.</source>
          <target state="translated">소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="8e46f7c4a19cd40725edd182f3cd8f28ae9a059a" translate="yes" xml:space="preserve">
          <source>closes the base lexer. This closes &lt;em&gt;L&lt;/em&gt;'s associated stream too.</source>
          <target state="translated">기본 어휘 분석기를 닫습니다. 이렇게하면 &lt;em&gt;L&lt;/em&gt; 의 관련 스트림도 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="77d4c6e46a63f2ddf2ac5a0df3677c8d62a6a9d2" translate="yes" xml:space="preserve">
          <source>closes the connection.</source>
          <target state="translated">연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="26adbf3fe5e8990bfd8ef4e529580b38a378a37e" translate="yes" xml:space="preserve">
          <source>closes the database connection.</source>
          <target state="translated">데이터베이스 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="4120af6f6fd3307319d8128138e2d5a62e11a37b" translate="yes" xml:space="preserve">
          <source>closes the memory mapped file &lt;em&gt;f&lt;/em&gt;. All changes are written back to the file system, if &lt;em&gt;f&lt;/em&gt; was opened with write access.</source>
          <target state="translated">메모리 매핑 된 파일 &lt;em&gt;f를&lt;/em&gt; 닫습니다 . &lt;em&gt;f&lt;/em&gt; 가 쓰기 액세스로 열린 경우 모든 변경 사항이 파일 시스템에 다시 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="beffe895fa1092a7b803bd012ab87b6a4c03d2fd" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;c&lt;/em&gt; and its associated input stream.</source>
          <target state="translated">파서 &lt;em&gt;c&lt;/em&gt; 와 관련 입력 스트림을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="11ebaec8140d9f72f4fe56335e3b4891498ef0ed" translate="yes" xml:space="preserve">
          <source>closes the parser &lt;em&gt;my&lt;/em&gt; and its associated input stream.</source>
          <target state="translated">파서 &lt;em&gt;my&lt;/em&gt; 및 관련 입력 스트림을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="a547a7b24d66447bd198c99f42ae102ec2439542" translate="yes" xml:space="preserve">
          <source>closes the stream &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">스트림 종료 &lt;em&gt;S&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="abac36149cf8b0e18d680ad240a392fc875517bc" translate="yes" xml:space="preserve">
          <source>cmd</source>
          <target state="translated">cmd</target>
        </trans-unit>
        <trans-unit id="ba6c06e4be30524ef0009a48aabf7d270581932f" translate="yes" xml:space="preserve">
          <source>cmp</source>
          <target state="translated">cmp</target>
        </trans-unit>
        <trans-unit id="46f0655e0e5194dcf502c9a8497c27816f875ba0" translate="yes" xml:space="preserve">
          <source>col is preferred, inconsistent right now</source>
          <target state="translated">col이 선호되고 일관성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="250140b29dbd97cfe8b655b2383464509f00c6c2" translate="yes" xml:space="preserve">
          <source>col, column</source>
          <target state="translated">열, 열</target>
        </trans-unit>
        <trans-unit id="f8bd696759805b9098f9e13be67d2b248c7619d0" translate="yes" xml:space="preserve">
          <source>colors</source>
          <target state="translated">colors</target>
        </trans-unit>
        <trans-unit id="f6b885e57915547b46349da5eefcd8162aa0866f" translate="yes" xml:space="preserve">
          <source>colors.$</source>
          <target state="translated">colors.$</target>
        </trans-unit>
        <trans-unit id="5e51764cc9d08861492f3fb1123a9530f62d59ad" translate="yes" xml:space="preserve">
          <source>colors.+</source>
          <target state="translated">colors.+</target>
        </trans-unit>
        <trans-unit id="a1a8cffa299a42401148e5848a3c6c1a3b78afb3" translate="yes" xml:space="preserve">
          <source>colors.-</source>
          <target state="translated">colors.-</target>
        </trans-unit>
        <trans-unit id="fb154583fb54c6f87d3d451d313d8be3a9e052bc" translate="yes" xml:space="preserve">
          <source>colors.==</source>
          <target state="translated">colors.==</target>
        </trans-unit>
        <trans-unit id="aa60230ab00282b5a1f3f1993b2d1c503e7d15a5" translate="yes" xml:space="preserve">
          <source>column</source>
          <target state="translated">column</target>
        </trans-unit>
        <trans-unit id="0d87d4fd5d052a9ff08c67b6976edc291f8ed99a" translate="yes" xml:space="preserve">
          <source>combine two &lt;em&gt;RunningRegress&lt;/em&gt; objects.</source>
          <target state="translated">두 개의 &lt;em&gt;RunningRegress&lt;/em&gt; 객체를 결합 합니다.</target>
        </trans-unit>
        <trans-unit id="a280c806fc0084662fe9dca88f44bbf8cf35fd56" translate="yes" xml:space="preserve">
          <source>combine two RunningStats.</source>
          <target state="translated">두 개의 RunningStats를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="1925f793093581c47a5c6b2e414506b1cbae280d" translate="yes" xml:space="preserve">
          <source>command</source>
          <target state="translated">command</target>
        </trans-unit>
        <trans-unit id="f0461049bdae4983b14331cd824bc8faf678eada" translate="yes" xml:space="preserve">
          <source>commands that can be expressed as arguments</source>
          <target state="translated">인수로 표현할 수있는 명령</target>
        </trans-unit>
        <trans-unit id="b64ca250f492e3f0444ad32b68be5f60a163bede" translate="yes" xml:space="preserve">
          <source>compare</source>
          <target state="translated">compare</target>
        </trans-unit>
        <trans-unit id="7e5186f1a9bd2895ed93cde0ae3e0ec0ee7ebb52" translate="yes" xml:space="preserve">
          <source>compares the memory blocks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;size&lt;/code&gt; bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is &lt;em&gt;unsafe&lt;/em&gt;.</source>
          <target state="translated">메모리 블록 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 비교합니다 . &lt;code&gt;size&lt;/code&gt; 바이트가 비교됩니다. 블록이 같으면 true가 반환되고 그렇지 않으면 false가 반환됩니다. 원시 메모리를 다루는 다른 절차와 마찬가지로 이것은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="094f6cd976e09fdf5710aaa012b7929b4e78b25a" translate="yes" xml:space="preserve">
          <source>compares two Nim identifiers &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;==&lt;/code&gt; on &lt;code&gt;NimNode&lt;/code&gt; instead.</source>
          <target state="translated">두 개의 Nim 식별자를 비교합니다 . &lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;NimNode&lt;/code&gt; 에서 &lt;code&gt;==&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ed73a329c036ce3614aca85e565d7d2fa0479e4" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes</source>
          <target state="translated">두 개의 Nim 노드를 비교</target>
        </trans-unit>
        <trans-unit id="cbc77019ddb9328367826ce155ee14c3fd23e382" translate="yes" xml:space="preserve">
          <source>compares two Nim nodes' types. Return true if the types are the same, eg. true when comparing alias with original type.</source>
          <target state="translated">두 개의 Nim 노드 유형을 비교합니다. 타입이 같은 경우에 true를 돌려줍니다. 별명을 원래 유형과 비교할 때 true입니다.</target>
        </trans-unit>
        <trans-unit id="0dada719b7810e8fcd804a5047d3800c1e54b166" translate="yes" xml:space="preserve">
          <source>compares two Nim symbols &lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use ```==`(NimNode,NimNode)`` instead.</source>
          <target state="translated">두 개의 Nim 기호를 비교합니다 . &lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신```==`(NimNode, NimNode)``를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0270a597009f086e4304658a9db86f15ed03e1cd" translate="yes" xml:space="preserve">
          <source>compares two colors.</source>
          <target state="translated">두 가지 색상을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="aa49b126d01b5a52b6416ad070faca0bf610e606" translate="yes" xml:space="preserve">
          <source>compilation option pragmas</source>
          <target state="translated">컴파일 옵션 pragmas</target>
        </trans-unit>
        <trans-unit id="41b955d23f05ae5bdd0badb05a3faaf15c898d9f" translate="yes" xml:space="preserve">
          <source>compile Nim and generated files but do not link</source>
          <target state="translated">Nim 및 생성 된 파일을 컴파일하지만 링크하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae36f560a64362393c0fb549afa5f8cdb5c4ba64" translate="yes" xml:space="preserve">
          <source>compile Nim files only; do not assemble or link</source>
          <target state="translated">Nim 파일 만 컴파일하십시오. 조립하거나 연결하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e87b469fe2f2263e06847de7d293924f49076024" translate="yes" xml:space="preserve">
          <source>compile project to C++ code</source>
          <target state="translated">프로젝트를 C ++ 코드로 컴파일</target>
        </trans-unit>
        <trans-unit id="be598bb766c710b889d68de039dbe949bb919e59" translate="yes" xml:space="preserve">
          <source>compile project to Javascript</source>
          <target state="translated">프로젝트를 자바 스크립트로 컴파일</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
