<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="1e8e7ed4df7e1d79df73533103355f606bd486f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allowRemap&lt;/code&gt; only needs to be true if you want to call &lt;code&gt;mapMem&lt;/code&gt; on the resulting MemFile; else file handles are not kept open.</source>
          <target state="translated">&lt;code&gt;allowRemap&lt;/code&gt; 은 결과 MemFile에서 &lt;code&gt;mapMem&lt;/code&gt; 을 호출하려는 경우에만 true 여야합니다. 그렇지 않으면 파일 핸들이 열린 상태로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51fff43aca9a3f3d76b1af35103a5af6f22e4951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncdispatch&lt;/code&gt; module (event loop)</source>
          <target state="translated">&lt;code&gt;asyncdispatch&lt;/code&gt; 모듈 (이벤트 루프)</target>
        </trans-unit>
        <trans-unit id="8fee4462a1fc6f7ca065434924f5269dc4e549ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncnet&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;asyncnet&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="498123f82aff644359d1fd4cd6bfb34e823defde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b[11..^2]&lt;/code&gt; is the portion &quot;useless&quot;, and &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; replaces the &quot;useless&quot; portion with &quot;useful&quot;, giving the result &quot;Slices are useful.&quot;</source>
          <target state="translated">&lt;code&gt;b[11..^2]&lt;/code&gt; 는 &quot;쓸모없는&quot;부분이고 &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; 은 &quot;쓸모없는&quot;부분을 &quot;유용한&quot;으로 대체하여 &quot;슬라이스가 유용합니다&quot;라는 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d2ea31cf1c26dd26b1244e5ffea23471a18ded80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast[T](x)&lt;/code&gt; in JavaScript is translated to &lt;code&gt;(x)&lt;/code&gt;, except for casting between signed/unsigned ints, in which case it behaves as static cast in C language.</source>
          <target state="translated">&lt;code&gt;cast[T](x)&lt;/code&gt; JavaScript의 cast [T] (x) 는 부호있는 / 서명되지 않은 정수 사이의 캐스트를 제외하고는 &lt;code&gt;(x)&lt;/code&gt; 로 변환되며 ,이 경우 C 언어에서 정적 캐스트로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="78e583a6ca5943602d2fea749731670fb16ec519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61889a3978487883ade1aa88a933aede33e10d71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cstring&lt;/code&gt; in JavaScript means JavaScript string. It is a good practice to use &lt;code&gt;cstring&lt;/code&gt; only when it is semantically appropriate. E.g. don't use &lt;code&gt;cstring&lt;/code&gt; as a binary data buffer.</source>
          <target state="translated">&lt;code&gt;cstring&lt;/code&gt; JavaScript의 cstring 은 JavaScript 문자열을 의미합니다. 의미 적으로 적절한 경우에만 &lt;code&gt;cstring&lt;/code&gt; 을 사용하는 것이 좋습니다 . 예를 들어 &lt;code&gt;cstring&lt;/code&gt; 을 이진 데이터 버퍼로 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="ac407e594720119511a2dff99e2c8cb540795818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them. In calls using the command syntax, the do block will bind to the immediately preceeding expression, transforming it in a call.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 는 일반 proc 매개 변수를 묶는 괄호 뒤에 쓰여집니다. do 블록으로 표시되는 proc 표현식이 추가됩니다. 명령 구문을 사용하는 호출에서 do 블록은 바로 앞에 오는 표현식에 바인딩하여 호출에서 변환합니다.</target>
        </trans-unit>
        <trans-unit id="560a65c3942b87610678dbe71906d997387954ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; with parentheses is an anonymous &lt;code&gt;proc&lt;/code&gt;; however a &lt;code&gt;do&lt;/code&gt; without parentheses is just a block of code. The &lt;code&gt;do&lt;/code&gt; notation can be used to pass multiple blocks to a macro:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 괄호하는 것은 익명 &lt;code&gt;proc&lt;/code&gt; ; 그러나 괄호가없는 &lt;code&gt;do&lt;/code&gt; 은 코드 블록 일뿐입니다. &lt;code&gt;do&lt;/code&gt; 표기법은 매크로에 여러 블록을 전달하는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f8bfd3653988749a0a70c5e576012e23dd595dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must be &lt;code&gt;gcsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;gcsafe&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d47873c2e8cae488fed6cb4e83f288d75cc0a265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not have the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 호출 규칙 &lt;code&gt;closure&lt;/code&gt; 이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc4e09f9db81a165920ce36aaee0a3d848f2fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;'s parameters may not be of type &lt;code&gt;var&lt;/code&gt;. This means one has to use raw &lt;code&gt;ptr&lt;/code&gt;'s for data passing reminding the programmer to be careful.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 매개 변수는 &lt;code&gt;var&lt;/code&gt; 유형이 아닐 수 있습니다 . 이것은 프로그래머에게주의를 상기시키는 데이터 전달 을 위해 raw &lt;code&gt;ptr&lt;/code&gt; 을 사용해야한다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="a0a3e940e2d69b10dcd7b011d95e7e271faec390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findFile&lt;/code&gt; is a proc used by the rst &lt;code&gt;include&lt;/code&gt; directive among others. The purpose of this proc is to mangle or filter paths. It receives paths specified in the rst document and has to return a valid path to existing files or the empty string otherwise. If you pass &lt;code&gt;nil&lt;/code&gt;, a default proc will be used which given a path returns the input path only if the file exists. One use for this proc is to transform relative paths found in the document to absolute path, useful if the rst file and the resources it references are not in the same directory as the current working directory.</source>
          <target state="translated">&lt;code&gt;findFile&lt;/code&gt; 은 첫 번째 &lt;code&gt;include&lt;/code&gt; 지시문에서 사용되는 proc 입니다. 이 프로세스의 목적은 경로를 맹 글링하거나 필터링하는 것입니다. 첫 번째 문서에 지정된 경로를 받고 기존 파일에 대한 유효한 경로를 반환하거나 그렇지 않으면 빈 문자열을 반환해야합니다. &lt;code&gt;nil&lt;/code&gt; 을 전달 하면 파일이 존재하는 경우에만 경로가 입력 경로를 반환하는 기본 proc이 사용됩니다. 이 프로세스의 한 가지 용도는 문서에서 찾은 상대 경로를 절대 경로로 변환하는 것입니다. 첫 번째 파일과이 파일이 참조하는 리소스가 현재 작업 디렉토리와 동일한 디렉토리에없는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8300161461027b1d236fc8fcb5051bea30977ff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fmt&lt;/code&gt; vs. &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; 대 &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7037da41cd9a367dd5a1197389e84235b7fd299" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; is syntactic sugar for a proc with no side effects:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 는 부작용이없는 proc의 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="924aa797cc590677bd14ef7705744856d8172a99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getTime&lt;/code&gt; should generally be prefered over this proc.</source>
          <target state="translated">&lt;code&gt;getTime&lt;/code&gt; 이 일반적으로이 프로세스보다 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d638e902f126f0c7aa4a0463f14fc91aa6e101cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gettimeofday&lt;/code&gt; on Posix systems.</source>
          <target state="translated">&lt;code&gt;gettimeofday&lt;/code&gt; Posix 시스템에서 gettimeofday .</target>
        </trans-unit>
        <trans-unit id="d5b46867399a3ebc590baf66c27020db2279084c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; 는 &lt;code&gt;hash(myBuf)&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="45dddddd2bbfedd088d7b3c125dbef25e0d38ba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myStr)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; 는 &lt;code&gt;hash(myStr)&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d09d0789db01f5a9c05f92add326a6c6418fad63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; 는 &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="539893790133747c72f0c3d326648e951cd62455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; 은 &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a6dad588628bbfdda78e877da81dc4063efbca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpMethod&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;httpMethod&lt;/code&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="446c4e7001b764a870cc632382c962e1c7846115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&lt;/code&gt; is used to create a value type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 는 값 유형 &lt;code&gt;T&lt;/code&gt; 를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bac1f760d92cd7667c1edcfeeb152b5ca3e42fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4bbdf85817b62fc87718830d3fcc8142efb089" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;items&lt;/code&gt; and &lt;code&gt;mitems&lt;/code&gt;, which provides immutable and mutable elements respectively, and</source>
          <target state="translated">&lt;code&gt;items&lt;/code&gt; 불변 및 가변 요소를 각각 제공하는 items 및 &lt;code&gt;mitems&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d080c7c8dc2ed97f395585da2bba25e2810e6a4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;#pairs.i,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;# pairs.i, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db0b9a7913713991512790ae51161be2f487b7b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - the current key, if it exists, or the key passed to &lt;code&gt;withKey&lt;/code&gt; otherwise;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; - 현재 키가 존재, 또는 경우에 전달 된 키 &lt;code&gt;withKey&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="137d632b8d1a56e511b10636ac245a0a4100b468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; creates a debug build of the compiler, which is useful to create stacktraces for compiler debugging.</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; 는 컴파일러의 디버그 빌드를 작성하는데, 이는 컴파일러 디버깅을위한 스택 추적을 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b79b05bec9bfe83a19a391ff0202f6c5f735d0bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; returns 125 as the exit code in case the compiler compilation fails. This exit code tells &lt;code&gt;git bisect&lt;/code&gt; to skip the current commit.:</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; 는 컴파일러 컴파일에 실패한 경우 종료 코드로 125를 리턴합니다. 이 종료 코드는 &lt;code&gt;git bisect&lt;/code&gt; 가 현재 커밋을 건너 뛰도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="1e569b2cd12fd789d91b613969201b1b396b9248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mach_absolute_time&lt;/code&gt; on Mac OS X.</source>
          <target state="translated">&lt;code&gt;mach_absolute_time&lt;/code&gt; Mac OS X의 mach_absolute_time</target>
        </trans-unit>
        <trans-unit id="7edfc1fd9a182aafc615613438430cf9ea485a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; can be used to map only a slice of the file.</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 을 사용하여 파일 조각 만 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa96a3fe1f430f3bd1fcff24de7ff608b318637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; of &lt;code&gt;-1&lt;/code&gt; maps to the whole file, and &lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; &lt;code&gt;-1&lt;/code&gt; 의mappingSize 는 전체 파일에 매핑되며 &lt;code&gt;offset&lt;/code&gt; 은 OS의 PAGE SIZE의 배수 여야합니다</target>
        </trans-unit>
        <trans-unit id="7df7743ccba4158e36f639a44a77c1c52f23d01c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match&lt;/code&gt; macros are subject to overload resolution. First the &lt;code&gt;case&lt;/code&gt;'s selector expression is used to determine which &lt;code&gt;match&lt;/code&gt; macro to call. To this macro is then passed the complete &lt;code&gt;case&lt;/code&gt; statement body and the macro is evaluated.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 매크로는 과부하 해결에 영향을받습니다. 먼저 &lt;code&gt;case&lt;/code&gt; 의 셀렉터 표현식을 사용 하여 호출 할 &lt;code&gt;match&lt;/code&gt; 매크로를 결정 합니다. 그런 다음이 매크로에 완전한 &lt;code&gt;case&lt;/code&gt; statement 본문이 전달 되고 매크로가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="33681e35af54b0be5e86cbe9c5c3384c078bfb89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxRedirects&lt;/code&gt; specifies the maximum amount of redirects to follow, default is 5.</source>
          <target state="translated">&lt;code&gt;maxRedirects&lt;/code&gt; 는 따라야 할 최대 리디렉션 수를 지정합니다. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="a63e991a055d70ba87b68410a67988fbb7f80b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is used to create a reference type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 는 참조 유형 &lt;code&gt;P&lt;/code&gt; 를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a602be3b30c82cb1f34df2de16159935bf9ca5cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newFileSize&lt;/code&gt; can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite).</source>
          <target state="translated">&lt;code&gt;newFileSize&lt;/code&gt; 는 파일이 존재하지 않고 쓰기 액세스 (예 : fmReadWrite)로 열린 경우에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33624742e3075a81ef915e9323ccf924f4d420e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nim dump&lt;/code&gt; shows the contents of the PATH.</source>
          <target state="translated">&lt;code&gt;nim dump&lt;/code&gt; 는 PATH의 내용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1d05d87869603b415dc3e7648e8e314e881eaa16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nimvm&lt;/code&gt; is a special symbol, that may be used as expression of &lt;code&gt;when nimvm&lt;/code&gt; statement to differentiate execution path between runtime and compile time.</source>
          <target state="translated">&lt;code&gt;nimvm&lt;/code&gt; 은 특수 기호로, 런타임과 컴파일 시간 간의 실행 경로를 구별하기 위해 &lt;code&gt;when nimvm&lt;/code&gt; 문을 표현할 때 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6d0deed51af5627d170be866f9c9b832e859b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="eaef4608c727f153577ce8477a94c4a41016aa3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkIdentDefs&lt;/code&gt; need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the &lt;code&gt;kind&lt;/code&gt; node and &lt;code&gt;default&lt;/code&gt; (value) nodes may be empty depending on where the &lt;code&gt;nnkIdentDefs&lt;/code&gt; appears: tuple or object definitions will have an empty &lt;code&gt;default&lt;/code&gt; node, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt; blocks may have an empty &lt;code&gt;kind&lt;/code&gt; node if the identifier is being assigned a value. Example:</source>
          <target state="translated">&lt;code&gt;nnkIdentDefs&lt;/code&gt; 에는 최소한 3 개의 자식이 있어야하지만 더 많은 자식이있을 수 있습니다. 먼저 식별자 목록과 유형 및 값 노드가옵니다. 이 헬퍼 프록은 세 개의 노드 서브 트리를 작성하는데, 첫 번째 서브 노드는 단일 식별자 이름입니다. 양쪽 &lt;code&gt;kind&lt;/code&gt; 노드와 &lt;code&gt;default&lt;/code&gt; (값) 노드는 위치에 따라 비어있을 수 있습니다 &lt;code&gt;nnkIdentDefs&lt;/code&gt; 가 나타납니다 튜플 또는 개체 정의가 비어있는 것입니다 &lt;code&gt;default&lt;/code&gt; 노드를 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;var&lt;/code&gt; 블록이 비어있을 수 있습니다 &lt;code&gt;kind&lt;/code&gt; 식별자 값이 할당되는 경우 노드를. 예:</target>
        </trans-unit>
        <trans-unit id="23cb81755297bb91f875d58a64e51a11f3bb1bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="d979bfd7809af3f787da470102b84296dc43dee7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notin&lt;/code&gt; and &lt;code&gt;isnot&lt;/code&gt; have the obvious meanings.</source>
          <target state="translated">&lt;code&gt;notin&lt;/code&gt; 및 &lt;code&gt;isnot&lt;/code&gt; 명백한 의미를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="b733da2df93ef65b306bd9461fe3ea6457795e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS (usually 4K or 8K but is unique to your OS)</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 은 OS의 PAGE SIZE의 배수 여야합니다 (일반적으로 4K 또는 8K이지만 OS에 고유함)</target>
        </trans-unit>
        <trans-unit id="8fb1b7b67c3dc439712f44d89e4d717f52f04357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairExists&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; if the key exists, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pairExists&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; , 키가 존재하는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="0e50d29d3877d70186a81b4d6f92422034d6a8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;mpairs&lt;/code&gt; which provides the element and an index number (immutable and mutable respectively)</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 과 &lt;code&gt;mpairs&lt;/code&gt; (각각 가변 및 불변) 요소와 인덱스 번호를 제공한다</target>
        </trans-unit>
        <trans-unit id="46fd512967085e03b5725fc1b1c542ab6c02be40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="196f6343dc5b835d948b2f0d904b1e516670f218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;#len,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;# len, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5660e0b3db81a363a41e94bcdc8ef2c68d94a1ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc&lt;/code&gt; types are currently always invariant, but future versions of Nim may relax this rule.</source>
          <target state="translated">&lt;code&gt;proc&lt;/code&gt; 유형은 현재 항상 변하지 않지만 이후 버전의 Nim은이 규칙을 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028210015ead3722db469fae99b22a73fd0cebdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy&lt;/code&gt; specifies an HTTP proxy to use for this HTTP client's connections.</source>
          <target state="translated">&lt;code&gt;proxy&lt;/code&gt; 는이 HTTP 클라이언트의 연결에 사용할 HTTP 프록시를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4959eb23bdd78e53cb8af81bc9bb9ebcd2e0f5fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; since triple quoted string literals do not interpret escape sequences either.</source>
          <target state="translated">&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; 는이 표기법으로는 사용할 수 없습니다. 세 개의 선행 인용 부호는 삼중 인용 문자열 리터럴을 도입하기 때문입니다. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; 동일하다 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 트리플 인용 문자열 리터럴 중 이스케이프 시퀀스를 해석하지 않기 때문에.</target>
        </trans-unit>
        <trans-unit id="2b075aac17257f2359ad806b6183d04e910a5afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via &lt;code&gt;system.deepCopy&lt;/code&gt; and so can be overridden.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 매개 변수는 깊이 복사되어 미묘한 의미 변경으로 성능 문제를 일으킬 수 있지만 메모리 안전을 보장합니다. 이 깊은 복사는 &lt;code&gt;system.deepCopy&lt;/code&gt; 를 통해 수행 되므로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d9f8b60195dac2076797c209d92497e8a52809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; is allowed in a closure iterator (but rarely useful) and ends iteration.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 클로저 이터레이터에서 리턴 이 허용되지만 (드물게 유용하지는 않음) 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c6eb664148a5a03959b583e8dd19730950f68b68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; without an expression is a short notation for &lt;code&gt;return result&lt;/code&gt; if the proc has a return type. The &lt;span id=&quot;result_1&quot;&gt;result&lt;/span&gt; variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, &lt;code&gt;result&lt;/code&gt; is initialized to (binary) zero:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; proc에 리턴 유형이있는 경우 표현식없는 return 은 &lt;code&gt;return result&lt;/code&gt; 대한 짧은 표기법입니다 . &lt;span id=&quot;result_1&quot;&gt;결과&lt;/span&gt; 변수는 항상 프로 시저의 리턴 값이다. 컴파일러가 자동으로 선언합니다. 모든 변수와 같이 &lt;code&gt;result&lt;/code&gt; 는 (이진) 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="113c74a3fd2826389685dc9b0cc688a75bb22a6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanf&lt;/code&gt; returns true if the input string &lt;strong&gt;starts with&lt;/strong&gt; the specified pattern. If instead it should only return true if there is also nothing left in the input, append &lt;code&gt;$.&lt;/code&gt; to your pattern.</source>
          <target state="translated">&lt;code&gt;scanf&lt;/code&gt; 는 입력 문자열 &lt;strong&gt;이&lt;/strong&gt; 지정된 패턴으로 &lt;strong&gt;시작&lt;/strong&gt; 하면 true를 반환합니다 . 입력에 아무것도 남지 않은 경우에만 true를 반환해야하는 경우 &lt;code&gt;$.&lt;/code&gt; 추가하십시오 . 당신의 패턴에.</target>
        </trans-unit>
        <trans-unit id="b10ad8ca26a39b5bc50703ca1825380095c2b3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;selectors&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;selectors&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="414b4c694a3b05d8c88e89f76d20d0406356c388" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; must be of exactly the size that was requested via &lt;code&gt;mapMem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 는 &lt;code&gt;mapMem&lt;/code&gt; 을 통해 요청한 크기와 정확히 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7428fa040024da68196dbad3f187333725a9111f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; executes the passed expression on the thread pool and returns a &lt;span id=&quot;data-flow-variable_1&quot;&gt;data flow variable&lt;/span&gt;&lt;code&gt;FlowVar[T]&lt;/code&gt; that can be read from. The reading with the &lt;code&gt;^&lt;/code&gt; operator is &lt;strong&gt;blocking&lt;/strong&gt;. However, one can use &lt;code&gt;blockUntilAny&lt;/code&gt; to wait on multiple flow variables at the same time:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 은 스레드 풀에서 전달 된 식을 실행하고 읽을 수 있는 &lt;span id=&quot;data-flow-variable_1&quot;&gt;데이터 흐름 변수 &lt;/span&gt; &lt;code&gt;FlowVar[T]&lt;/code&gt; 를 반환합니다 . &lt;code&gt;^&lt;/code&gt; 연산자를 사용한 읽기 가 &lt;strong&gt;차단되었습니다&lt;/strong&gt; . 그러나 &lt;code&gt;blockUntilAny&lt;/code&gt; 를 사용 하여 여러 흐름 변수를 동시에 기다릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6a078341ec3b81c9830d57f0b0899663805e59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; within a &lt;code&gt;parallel&lt;/code&gt; section has special semantics.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; &lt;code&gt;parallel&lt;/code&gt; 섹션 내에 스폰 되는 것은 특별한 의미를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a237f056e6830032577998fb90190fdcae2b2f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sslContext&lt;/code&gt; specifies the SSL context to use for HTTPS requests.</source>
          <target state="translated">&lt;code&gt;sslContext&lt;/code&gt; 는 HTTPS 요청에 사용할 SSL 컨텍스트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="14ce006a57832b51af0da0a7cc6741ef70d10283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stackTrace&lt;/code&gt; is provided only if the failure occurred due to an exception. &lt;code&gt;checkpoints&lt;/code&gt; is never &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stackTrace&lt;/code&gt; 는 예외로 인해 실패가 발생한 경우에만 제공됩니다. &lt;code&gt;checkpoints&lt;/code&gt; 는 절대로 &lt;code&gt;nil&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="cb4fe14b57e46dc6a68b8b91ce1197bfba9b9fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; may be overriden, i.e. if &lt;code&gt;sock&lt;/code&gt; is not connected it should be adjusted properly. By default it will be assumed that the socket is connected. Please note this is only applicable to TCP client sockets, if &lt;code&gt;sock&lt;/code&gt; is a different type of socket &lt;code&gt;state&lt;/code&gt; needs to be adjusted!!!</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 가 무시 될 수 있습니다. 즉, &lt;code&gt;sock&lt;/code&gt; 이 연결되어 있지 않으면 적절히 조정해야합니다. 기본적으로 소켓이 연결되어 있다고 가정합니다. &lt;code&gt;sock&lt;/code&gt; 이 다른 유형의 소켓 &lt;code&gt;state&lt;/code&gt; 를 조정해야하는 경우 TCP 클라이언트 소켓에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e674b50eb18e2a7db0371aad81cb1f5762665b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;#newException.t,type,string&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;# newException.t, type, string&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bb140ccbc87a6b939e9e3439c2e3cc8632b83d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - timeout value in milliseconds.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; - 밀리 초 단위의 시간 초과 값.</target>
        </trans-unit>
        <trans-unit id="96b9adea7cc07edd40eb34f2988f6e65b0f32008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 밀리 초로 지정되며 무제한 시간 동안 &lt;code&gt;-1&lt;/code&gt; 을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd67e5934c954c7a83cd4b013bf93f8697e48fe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time. &lt;strong&gt;Warning:&lt;/strong&gt; This is deprecated since version 0.16.2. Use the &lt;code&gt;selectRead&lt;/code&gt; procedure instead.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 밀리 초로 지정되며 무제한 시간 동안 &lt;code&gt;-1&lt;/code&gt; 을 지정할 수 있습니다. &lt;strong&gt;경고 :&lt;/strong&gt; 버전 0.16.2부터 사용되지 않습니다. 대신 &lt;code&gt;selectRead&lt;/code&gt; 프로 시저를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="47d67af238e56b35260c7cf302090a09b5d4e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; specifies the number of milliseconds to allow before a &lt;code&gt;TimeoutError&lt;/code&gt; is raised.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 &lt;code&gt;TimeoutError&lt;/code&gt; 가 발생 하기 전에 허용 할 시간 (밀리 초)을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3d983ab412f774a2d43a7773e59264a9986835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36800177ee2b92e4b74725a1b76cc86e80ecbacc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; acts like a generic type. For instance, the type of the symbol &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;type[int]&lt;/code&gt;. Just like with regular generic types, when the generic param is ommited, &lt;code&gt;type&lt;/code&gt; denotes the type class of all types. As a syntactic convenience, you can also use &lt;code&gt;type&lt;/code&gt; as a modifier. &lt;code&gt;type int&lt;/code&gt; is considered the same as &lt;code&gt;type[int]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 은 일반 유형처럼 작동합니다. 예를 들어, 기호 &lt;code&gt;int&lt;/code&gt; 의 &lt;code&gt;type[int]&lt;/code&gt; 은 type [int] 입니다. 일반 제네릭 형식과 마찬가지로 제네릭 매개 변수가 생략되면 &lt;code&gt;type&lt;/code&gt; 은 모든 유형의 형식 클래스를 나타냅니다. 구문상의 편의를 위해 &lt;code&gt;type&lt;/code&gt; 을 수정 자로 사용할 수도 있습니다 . &lt;code&gt;type int&lt;/code&gt; 은 &lt;code&gt;type[int]&lt;/code&gt; 와 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad64a4834d20179ee6e4e81e9e9cec9447164baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5524951be56e32fd2f7b7e27e9fb8dc263ca8215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;untyped&lt;/code&gt; and &lt;code&gt;varargs[untyped]&lt;/code&gt; are the only metatype that are lazy in this sense, the other metatypes &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not lazy.</source>
          <target state="translated">&lt;code&gt;untyped&lt;/code&gt; 및 &lt;code&gt;varargs[untyped]&lt;/code&gt; 이런 의미에서 게으른 유일한 메타 타입이며, 다른 metatypes는 &lt;code&gt;typed&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 게으른 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd2e83eaaa4d30da3388fb06180b2d9cdc38b178" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userAgent&lt;/code&gt; specifies the user agent that will be used when making requests.</source>
          <target state="translated">&lt;code&gt;userAgent&lt;/code&gt; 는 요청을 할 때 사용될 사용자 에이전트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6e8057947b214078488d318b597d51c19c74bced" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; - the current value, if the key exists, or default value of the type otherwise;</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; - 키가 존재하는 경우, 현재의 값. 그렇지 않은 경우는 디폴트의 값.</target>
        </trans-unit>
        <trans-unit id="70bd849b02a91f69a4faafb3130dd3312083ca7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fa91fdb54c79794b9a602441c5470976dba8159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;varargs[typed]&lt;/code&gt; is treated specially: It matches a variable list of arguments of arbitrary type but &lt;em&gt;always&lt;/em&gt; constructs an implicit array. This is required so that the builtin &lt;code&gt;echo&lt;/code&gt; proc does what is expected:</source>
          <target state="translated">&lt;code&gt;varargs[typed]&lt;/code&gt; 는 다음과 같이 특별하게 취급됩니다. 임의 유형의 변수 인수 목록과 일치하지만 &lt;em&gt;항상&lt;/em&gt; 암시 적 배열을 구성합니다. 내장 &lt;code&gt;echo&lt;/code&gt; 프로세스가 예상 한대로 수행 하려면 다음이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cfb3b8046a3ab81ffe6881ac3de26835854c0b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when nimvm&lt;/code&gt; statement must meet the following requirements:</source>
          <target state="translated">&lt;code&gt;when nimvm&lt;/code&gt; 문이 다음 요구 사항을 충족 해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="67ac27b54addce5df88f6ce1de6ac4b1806d80c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; in a closure iterator can not occur in a &lt;code&gt;try&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; &lt;code&gt;try&lt;/code&gt; 문 에서는 클로저 반복자에서 yield를 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b17d688332fc513102b8bb34b3b994661a671d9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; is used as the underlying implementations for &lt;code&gt;zonedTimeFromTime&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; 및 &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; 을 위한 기본 구현 예로서 사용된다 &lt;code&gt;zonedTimeFromTime&lt;/code&gt; 및 &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de7681dca8728ba640e9addf663d66eea92586e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%&lt;/em&gt; substitution operator for ropes. Does not support the &lt;code&gt;$identifier&lt;/code&gt; nor &lt;code&gt;${identifier}&lt;/code&gt; notations.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt; substitution operator for ropes. Does not support the &lt;code&gt;$identifier&lt;/code&gt; nor &lt;code&gt;${identifier}&lt;/code&gt; notations.</target>
        </trans-unit>
        <trans-unit id="703376a559c520d84ae5746f8f84e6453c7ecbf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated since version 0.18.1&lt;/em&gt;: No good usages of this feature are known.</source>
          <target state="translated">&lt;em&gt;버전 0.18.1부터 사용되지&lt;/em&gt; 않음 :이 기능의 적절한 사용법은 알려져 &lt;em&gt;있지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e021efea2e75524a8b29d10b025f45cf8dcb6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expressions&lt;/em&gt; are parts of a statement which usually result in a value. The condition in an if statement is an example for an expression. Expressions can contain indentation at certain places for better readability:</source>
          <target state="translated">&lt;em&gt;표현식&lt;/em&gt; 은 일반적으로 값을 생성하는 명령문의 일부입니다. if 문의 조건은 표현식의 예입니다. 가독성을 높이기 위해 표현식에는 특정 위치에 들여 쓰기가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e3cb0560107f66918fa3aedb67fc091d9d49443" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;일부 파일 시스템은 다른 문자를 사용할 수 있으므로 선행 '.'없이 &lt;em&gt;Ext를 제공&lt;/em&gt; 해야합니다. (나는 그런 짐승은 아무도 모른다.)</target>
        </trans-unit>
        <trans-unit id="00e5801a705eb26208dbadfb059011bb00f52b91" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Runtime type information&lt;/em&gt; (RTTI) is needed for several aspects of the Nim programming language:</source>
          <target state="translated">&lt;em&gt;런타임 유형 정보&lt;/em&gt; (RTTI)는 Nim 프로그래밍 언어의 여러 측면에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="17f8a43b2c8fe38ae5080e22a567a4a144d535c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arrow like operator&lt;/em&gt; (like &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;=&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;연산자와 같은 화살표&lt;/em&gt; (예 : &lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;=&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd27f1fe3eae5b9a898f8a1ee22d88a9fa597511" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;assignment operator&lt;/em&gt; (like &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;대입 연산자&lt;/em&gt; (예 : &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f7455f98c99e60e6bbeb9b3baae8878c758ba3c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt; is the comparator function to use, the expected return values are the same as that of system.cmp.</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt; 는 사용할 비교기 함수이며 예상 반환 값은 system.cmp와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d07d1bc0c8a2aa1948c3ee05610a44eaacab87f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;decimalSep&lt;/em&gt; is used as the decimal separator.</source>
          <target state="translated">&lt;em&gt;decimalSep&lt;/em&gt; 은 소수점 구분 기호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92cefe4d7882c47f6678d2ec5886a3672b587367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;empty string&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;빈 문자열&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8f65828700fd66a8e7a7fd5be187238ed98013b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;escape&lt;/em&gt;: removes any special meaning from the following character; '0' disables escaping; if escaping is disabled and &lt;em&gt;quote&lt;/em&gt; is not '0', two &lt;em&gt;quote&lt;/em&gt; characters are parsed one literal &lt;em&gt;quote&lt;/em&gt; character.</source>
          <target state="translated">&lt;em&gt;escape&lt;/em&gt; : 다음 문자에서 특별한 의미를 제거합니다. '0'은 이스케이프를 비활성화합니다. 이스케이프를 사용하지 않고 &lt;em&gt;따옴표&lt;/em&gt; 가 '0'이 아닌 경우 두 &lt;em&gt;따옴표&lt;/em&gt; 문자는 하나의 리터럴 &lt;em&gt;따옴표&lt;/em&gt; 문자 로 구문 분석 됩니다.</target>
        </trans-unit>
        <trans-unit id="db614d277a70f95c2f6d4d36c543390ce136c5ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;false&lt;/em&gt; - generate timeout events periodically</source>
          <target state="translated">&lt;em&gt;false-&lt;/em&gt; 주기적으로 시간 종료 이벤트 생성</target>
        </trans-unit>
        <trans-unit id="8e307a213a9d0cd9087e4fab61d048d2e75d42ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt; should be in the range &lt;em&gt;1..paramCount()&lt;/em&gt;, the &lt;em&gt;IndexError&lt;/em&gt; exception will be raised for invalid values. Instead of iterating over &lt;a href=&quot;#paramCount&quot;&gt;paramCount()&lt;/a&gt; with this proc you can call the convenience &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;전&lt;/em&gt; 범위에 있어야 &lt;em&gt;1..paramCount ()&lt;/em&gt; 은 &lt;em&gt;IndexError의&lt;/em&gt; 예외는 잘못된 값에 대해 발생한다. 이 proc로 &lt;a href=&quot;#paramCount&quot;&gt;paramCount ()&lt;/a&gt; 를 반복하는 대신 편의 &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams ()를&lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f4bf9334d2490f523b663af6901783da21ac6a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;includeSpace&lt;/em&gt; can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</source>
          <target state="translated">&lt;em&gt;includeSpace&lt;/em&gt; 는 숫자와 단위 사이의 (SI 선호) 공간을 포함하도록 true로 설정 될 수 있습니다 (예 : 1 KiB).</target>
        </trans-unit>
        <trans-unit id="e71266691c1695dc862a4187873f4eb27e421c29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; method in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; 는 2의 거듭 제곱이어야합니다. 이를 위해 런타임 값을 승인해야하는 경우 &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; 모듈 의 &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc 또는 이 모듈 의 &lt;code&gt;rightSize&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00959dbd3dd10aad40ca8d5088bb831b41a7779c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc from this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; 는 2의 거듭 제곱이어야합니다. 이에 대한 런타임 값을 허용해야하는 경우에는 사용할 수 &lt;code&gt;nextPowerOfTwo&lt;/code&gt; 의 으로부터 시저를 &lt;a href=&quot;math&quot;&gt;수학&lt;/a&gt; 모듈 또는 &lt;code&gt;rightSize&lt;/code&gt; 의 이 모듈에서 PROC.</target>
        </trans-unit>
        <trans-unit id="ea4791fbf3e42731dc51d96cd68f2db285a8f167" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; 는 2의 거듭 제곱이어야합니다. 이를 위해 런타임 값을 승인해야하는 경우 &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; 모듈의 &lt;code&gt;rightSize&lt;/code&gt; proc 또는 이 모듈 의 &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a840e66e23dce5bbe529077fe70ae32ae27b78c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; 는 2의 거듭 제곱이어야합니다. 이를 위해 런타임 값을 승인해야하는 경우 &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; 모듈 에서 &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7472432b84a3a2eab38f2db62373daa9e022086e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;isNil&lt;/em&gt; for an any &lt;em&gt;x&lt;/em&gt; that represents a sequence, string, cstring, proc or some pointer type.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;시퀀스, 문자열, cstring, proc 또는 일부 포인터 유형을 나타내는 모든 &lt;em&gt;x에&lt;/em&gt; 대해 &lt;em&gt;isNil&lt;/em&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f70ae80be2c58fd29de80509ed00d5e2c9f1f429" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added after &lt;em&gt;s&lt;/em&gt; resulting in left alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to right align a string use the &lt;a href=&quot;#align&quot;&gt;align proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;패딩&lt;/em&gt; 문자 (기본적으로 공백)는 &lt;em&gt;s&lt;/em&gt; 뒤에 추가 되어 왼쪽 정렬이됩니다. 경우 &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , 공백이 추가되지 않고, &lt;em&gt;s는&lt;/em&gt; 그대로 리턴된다. 문자열을 오른쪽 정렬해야하는 경우 &lt;a href=&quot;#align&quot;&gt;align proc을&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="8672d4b2f28ca97d242b9f9940ce8d1789ba04fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added before &lt;em&gt;s&lt;/em&gt; resulting in right alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to left align a string use the &lt;a href=&quot;#alignLeft&quot;&gt;alignLeft proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;패딩&lt;/em&gt; 문자 (기본적으로 공백)가 올바른 정렬을 위해 &lt;em&gt;s&lt;/em&gt; 앞에 추가 됩니다. 경우 &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , 공백이 추가되지 않고, &lt;em&gt;s는&lt;/em&gt; 그대로 리턴된다. 문자열을 왼쪽 정렬해야하는 경우 &lt;a href=&quot;#alignLeft&quot;&gt;alignLeft proc을&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="8247e0fd6fcaa06e3944fbde836de9960b4b141c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;pattern&lt;/em&gt; is OS dependent, but at least the &quot;*.ext&quot; notation is supported.</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 은 OS에 따라 다르지만 최소한 &quot;* .ext&quot;표기법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="75461844b2cd9f0f721ba3326b4f70c797e25d69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;precision&lt;/em&gt; can be used to set the number of digits to be shown after the decimal point or (if &lt;em&gt;trim&lt;/em&gt; is true) the maximum number of digits to be shown.</source>
          <target state="translated">&lt;em&gt;정밀도&lt;/em&gt; (경우 자릿수 소수점 이후 또는 도시되도록 설정하는데 사용될 수있다 &lt;em&gt;트림&lt;/em&gt; 참) 숫자의 최대 수를 도시한다.</target>
        </trans-unit>
        <trans-unit id="617209c0ac1f0365ddc9daa8adb400efad149a99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quote&lt;/em&gt;: Used to quote fields containing special characters like &lt;em&gt;separator&lt;/em&gt;, &lt;em&gt;quote&lt;/em&gt; or new-line characters. '0' disables the parsing of quotes.</source>
          <target state="translated">&lt;em&gt;quote&lt;/em&gt; : &lt;em&gt;separator&lt;/em&gt; , &lt;em&gt;quote&lt;/em&gt; 또는 개행 문자 와 같은 특수 문자가 포함 된 필드를 인용하는 데 사용됩니다 . '0'은 따옴표의 구문 분석을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f3dae05aba49b918194a9396a45aa3565615f037" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;replacements&lt;/em&gt; is any proc that takes a word and returns a new word to fill it's place.</source>
          <target state="translated">&lt;em&gt;replacements&lt;/em&gt; 는 단어를 가져 와서 새 단어를 반환하여 해당 위치를 채우는 모든 proc입니다.</target>
        </trans-unit>
        <trans-unit id="fbc817a3080e1b6882164dc8caf322799358d878" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;select&lt;/em&gt; with a sensible Nim interface. &lt;em&gt;timeout&lt;/em&gt; is in milliseconds. Specify -1 for no timeout. Returns the number of processes that are ready to read from. The processes that are ready to be read from are removed from &lt;em&gt;readfds&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;현명한 Nim 인터페이스로 &lt;em&gt;선택하십시오&lt;/em&gt; . &lt;em&gt;제한 시간&lt;/em&gt; 은 밀리 초입니다. 시간 종료없이 -1을 지정하십시오. 읽을 준비가 된 프로세스 수를 리턴합니다. 읽을 준비가 된 프로세스는 &lt;em&gt;readfds&lt;/em&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7f259f2477167c821ca25fa51730ed7960a70b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;separator&lt;/em&gt;: character used to separate fields</source>
          <target state="translated">&lt;em&gt;separator&lt;/em&gt; : 필드를 구분하는 데 사용되는 문자</target>
        </trans-unit>
        <trans-unit id="208edbd229c8eae9f5eb36df289548d5304b4d7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;skipInitialSpace&lt;/em&gt;: If true, whitespace immediately following the &lt;em&gt;separator&lt;/em&gt; is ignored.</source>
          <target state="translated">&lt;em&gt;skipInitialSpace&lt;/em&gt; : true 인 경우 &lt;em&gt;구분 기호&lt;/em&gt; 바로 다음에 오는 공백 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="273a15cf374a6c4f49fed8d98b7d8b9586b0faaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;true&lt;/em&gt; - generate only one timeout event</source>
          <target state="translated">&lt;em&gt;true-&lt;/em&gt; 하나의 시간 종료 이벤트 만 생성</target>
        </trans-unit>
        <trans-unit id="14ee562aca33dc19b06533f7cf5920a2b50148e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 는 &lt;code&gt;float&lt;/code&gt; 으로 변환되고 다른 푸시 작업이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="783ab28443368da5d8b24739fb4554949b0f9f72" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; is simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 는 단순히 &lt;code&gt;float&lt;/code&gt; 로 변환되고 다른 푸시 작업이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fae64b6ebd8e2c7bcc575d125a2000abb729e3ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; raised to the power &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 제곱을 올림 &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="12323c312fd7de0e4ef8b6a4ab533d557d68adc8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="56d285c47b35312e64820df42bf3a87fd1b7b319" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8e48b403bc73650b187c7f7e7ea88d6cb233c6" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="aa4c0ec53f4daba1b0ecbab22044a4b311fd35ea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="489a12332aa212cc707a62ebb576449c73813d0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used: the smaller type is converted to the larger.</source>
          <target state="translated">&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;자동 유형 변환&lt;/span&gt; 은 다른 종류의 정수 유형이 사용되는 표현식에서 수행됩니다. 더 작은 유형은 더 큰 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef114326cdf7ec64073b8d5c70949a59e4d16784" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="654a8f7f92faee492756a045bc4a4f5716bafc9a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b344cba5f1b85d441c18840ce9f4242eff677927" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="3ef60dc7d037ac085bdffe500a7612d735b0c712" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="fc49500076e57365e635056cd3b75868d666ab71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_1&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_1&quot;&gt;캐리지 리턴&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8ab206963e8b4940d40701cfc51c0f7e1851ffeb" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_2&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_2&quot;&gt;캐리지 리턴&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1cf7c76a0ff63e90fbc9727aa4db16092702311a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0733a6e3e51ba48347bd816e4d97acf3dbb10225" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;10 진수 값을 가진 문자 d&lt;/span&gt; ; 바로 뒤에 오는 모든 십진수가 문자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d33b972e48200cc4a6a49329f9bd2b0b86e9d179" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;10 진수 값을 가진 문자 d&lt;/span&gt; ; 바로 뒤에 오는 모든 십진수가 문자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="598b3bddfa5c5d0fa5a106b08f17b0cd0a6928c4" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;16 진 값을 가진 문자 HH&lt;/span&gt; ; 정확히 두 개의 16 진수가 허용됩니다</target>
        </trans-unit>
        <trans-unit id="899d46bdef3da49bf9a47052252021471e9deca1" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;16 진 값을 가진 문자 HH&lt;/span&gt; ; 정확히 두 개의 16 진수가 허용됩니다</target>
        </trans-unit>
        <trans-unit id="06eb32c5efe204f53b8a3e469a651a6422b0ecef" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="69035165c7fe56ca0f544baab5f7ca6b3bb23e5f" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;constants_1&quot;&gt;Constants&lt;/span&gt; are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time.</source>
          <target state="translated">&lt;span id=&quot;constants_1&quot;&gt;상수&lt;/span&gt; 는 값에 바인딩 된 기호입니다. 상수 값은 변경할 수 없습니다. 컴파일러는 컴파일 타임에 상수 선언으로 표현식을 평가할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc7dc406312d3d989f8fded7366dc2a2ca439dfc" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;documentation-comments_1&quot;&gt;Documentation comments&lt;/span&gt; are comments that start with two &lt;code&gt;##&lt;/code&gt;. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!</source>
          <target state="translated">&lt;span id=&quot;documentation-comments_1&quot;&gt;문서 주석은&lt;/span&gt; 두 개의 &lt;code&gt;##&lt;/code&gt; 으로 시작하는 주석입니다 . 문서 주석은 토큰입니다. 그것들은 구문 트리에 속하기 때문에 입력 파일의 특정 위치에서만 허용됩니다!</target>
        </trans-unit>
        <trans-unit id="c983afd465ba80d2147e0b70ee70ed5b594ffd0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="23e3ae456032cf7bfe12b54d4c30ef515b7e5769" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1f0669c885766923e22bc3a0cf1a25ecf09a7e71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61df4a1c082aef5508a11aa5f32360878c832316" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_1&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_1&quot;&gt;사료 공급&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c83e42d1968c9f81163b17f1f1a97a7f750bcc7b" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_2&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_2&quot;&gt;사료 공급&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="24ef9584feba6e596a828184a0614706f20342a7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="97eb508c4f7e0532dda34314f3114ac62db38999" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="bf681f8157045b76a5b5cca6556c710b3d31af04" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_1&quot;&gt;line feed&lt;/span&gt; (often called &lt;span id=&quot;newline_1&quot;&gt;newline&lt;/span&gt;)</source>
          <target state="translated">&lt;span id=&quot;line-feed_1&quot;&gt;줄 바꿈&lt;/span&gt; ( &lt;span id=&quot;newline_1&quot;&gt;줄 바꾸기&lt;/span&gt; )</target>
        </trans-unit>
        <trans-unit id="f069e5dc4bd5128fe57f984b98f0d1df33905e6c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_2&quot;&gt;line feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;line-feed_2&quot;&gt;줄 바꿈&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="370fea44cd56e7d13668a1518c6ed3e2793cd844" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="386493dc5a93f6552eed5a0c301e509bae171c3a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0d18cc4b434985ecdfad600d62beb278d037bd02" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;operators_1&quot;&gt;Operators&lt;/span&gt; are procedures with a special operator symbol as identifier:</source>
          <target state="translated">&lt;span id=&quot;operators_1&quot;&gt;연산자&lt;/span&gt; 는 특수 연산자 기호를 식별자로 사용하는 절차입니다.</target>
        </trans-unit>
        <trans-unit id="dd7a03ff3abf42e8baa1ecc1fffb484ad21a23af" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_1&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_1&quot;&gt;인용 부호&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c6aabef76f9a817672169780852e677ea046add2" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_2&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_2&quot;&gt;인용 부호&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c37b02a49dcefbd3153898422e9bb9a58594c0f5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9075773ca58649470612eb72f9b476282ba11426" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;spawn_1&quot;&gt;spawn&lt;/span&gt; can be used to pass a task to the thread pool:</source>
          <target state="translated">&lt;span id=&quot;spawn_1&quot;&gt;스폰&lt;/span&gt; 은 작업을 스레드 풀에 전달하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f768c26556a449ea02596d87572b18bde70355d0" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="459d1365b562550b27ebf6a8974dd5ae8b46a70a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f2149f636a8a39166b70a1e1b85797ae880037d8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;structured_1&quot;&gt;Structured&lt;/span&gt; parallelism via the &lt;code&gt;parallel&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;structured_1&quot;&gt;&lt;/span&gt; &lt;code&gt;parallel&lt;/code&gt; 문을 통한 &lt;span id=&quot;structured_1&quot;&gt;구조적&lt;/span&gt; 병렬성 .</target>
        </trans-unit>
        <trans-unit id="906052db691f512b87e944c4fa7ae79175ea0c21" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="2fce4fa4dbb6e8e47310c53145477e8e7e68ebe3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b6b9690fa127b5c41c7a6608abe780996467b339" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a0e78449bd2f86ea69106414c3a2d0d1430a9b77" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unmarshals_1&quot;&gt;Unmarshals&lt;/span&gt; the specified node into the object type specified.</source>
          <target state="translated">&lt;span id=&quot;unmarshals_1&quot;&gt;&lt;/span&gt;지정된 노드를 지정된 객체 유형으로 &lt;span id=&quot;unmarshals_1&quot;&gt;마샬링 해제&lt;/span&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="daac7f50d202881a5d6ee0367a0863d7aebf95c3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unstructured_1&quot;&gt;Unstructured&lt;/span&gt; parallelism via the standalone &lt;code&gt;spawn&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;unstructured_1&quot;&gt;&lt;/span&gt;독립형 &lt;code&gt;spawn&lt;/code&gt; 명령문을 통한 &lt;span id=&quot;unstructured_1&quot;&gt;구조화되지 않은&lt;/span&gt; 병렬 처리 .</target>
        </trans-unit>
        <trans-unit id="d57fe270428bde77daa75ade4ed835d70900fc90" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_1&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_1&quot;&gt;수직 테이블&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cc1eadaa9721d4034ad25e0a89c479254a832df" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_2&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_2&quot;&gt;수직 테이블&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="162d657293056b3b52f778e7e2ab66fe5d304524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$MODULE&lt;/strong&gt;: like $TESTNIM but without extension, useful for expected output.</source>
          <target state="translated">&lt;strong&gt;$MODULE&lt;/strong&gt;: like $TESTNIM but without extension, useful for expected output.</target>
        </trans-unit>
        <trans-unit id="0f7f0e7e27fe39d47b743d1865954b56a2c07fd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$TESTNIM&lt;/strong&gt;: filename specified in the first line of the script.</source>
          <target state="translated">&lt;strong&gt;$TESTNIM&lt;/strong&gt;: filename specified in the first line of the script.</target>
        </trans-unit>
        <trans-unit id="a839ade11ae6dd196f2a9173f8f1d634964f9d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;가용성&lt;/strong&gt; : Posix에서는 DLL에서 명령 행을 가져 오는 이식 가능한 방법이 없으므로이 환경에서 proc이 정의되지 않습니다. &lt;a href=&quot;system#declared&quot;&gt;declaration ()으로&lt;/a&gt; 가용성을 테스트 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="654a21dac651772b23f95ecd2222feacad79471f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: When generating a dynamic library (see --app:lib) on Posix this proc is not defined. Test for availability using &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;가용성&lt;/strong&gt; : Posix에서 동적 라이브러리 (--app : lib 참조)를 생성 할 때이 proc은 정의되지 않습니다. &lt;a href=&quot;system#declared&quot;&gt;declaration ()&lt;/a&gt; 을 사용하여 가용성을 테스트하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="fcbe823732d2c9972cd2868d10967de104d96e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocks&lt;/strong&gt; the current thread until the specified future completes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 미래가 완료 될 때까지 현재 스레드를 &lt;strong&gt;차단&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ade01956444b2bedb6ba0ce473524e122c45ab36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEPRECATED&lt;/strong&gt; as it was confused for shell quoting function. For this application use &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;쉘 인용 기능이 혼동되어 &lt;strong&gt;사용&lt;/strong&gt; 되지 않습니다. 이 응용 프로그램에는 &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f9bcec4d297aa8b62e7707f49f12d5b91ee3e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since 0.9.6&lt;/strong&gt;: Use &lt;code&gt;Uri&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;0.9.6부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음&lt;/strong&gt; : &lt;code&gt;Uri&lt;/code&gt; 를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0edc0ae576cbf1405d25d406473d00a29f1efad5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.14.0부터 더 이상&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;toTime&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64a9b956a337527118896d06cbe9ae7f050d636f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.14.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;toTimeInterval&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d42b15a342ba8260b2d18fb84c9410a31da17af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;createNativeSocket&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;createNativeSocket&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="07e0d4b10a5b7a0a71d906084234d0680ca5563e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;registerHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;registerHandle&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1129f505c350479aaa022b8a8003b02d2ff1812a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;trigger&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;trigger&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="df4c00b11b4bf37dc2f6430219a81fef666c3077" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;updateHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;updateHandle&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fd9c517dc50477a5fbd53eadca39aa342cacc15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;fromUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;fromUnix&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb78393c2152a466222fd3a7fb4214ff908ccea1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 &lt;/strong&gt; &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a648b574225c4c5297a7b9e6a179de1fa70405ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;initTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;initTimeInterval&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b650e97ba36dce981193da56e9d3e90303aa2415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;local&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;local&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="be21164252193e55e3a53ee4fd307e3bd091719f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;now().utcOffset&lt;/code&gt; to get the current utc offset (including DST).</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 : &lt;/strong&gt; &lt;code&gt;now().utcOffset&lt;/code&gt; 을 사용하여 현재 utc 오프셋 (DST 포함)을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="7093a6b25b775ae7f81736fede1917ea4a624cb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;toUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;toUnix&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5bfa49165457523fa77a7619996190f331b5e0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;utc&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;v0.18.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;utc&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a2f96fe2ad51bd3c2f12b80acad9b57384ced284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getBool&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.2부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;getBool&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="df0e7fcddc8c3387b9579f61dc61f253f5817870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getFloat&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.2부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;getFloat&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b0c3af938100bdf91557ac9b93edb506162843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getInt&lt;/code&gt; or &lt;code&gt;getBiggestInt&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.18.2부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;getInt&lt;/code&gt; 또는 &lt;code&gt;getBiggestInt&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ff84ca124aa9ac594837f7d32a1435e66e43f038" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use &lt;code&gt;zonedTimeFromTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.19.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;zonedTimeFromTime&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="595283a18cec59736002f87447f03a29696e5825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;time&lt;/code&gt; field instead.</source>
          <target state="translated">&lt;strong&gt;v0.19.0부터 더 이상&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;time&lt;/code&gt; 필드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5295b91fb2f0e30f39313327d56ecb8a32c45919" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.19.0부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 : &lt;/strong&gt; &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; 을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="abdd1f4767c098ae47e6067b7b37ea7d137a5e30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.8.10:&lt;/strong&gt; use &lt;code&gt;epochTime&lt;/code&gt; or &lt;code&gt;cpuTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;v0.8.10부터&lt;/strong&gt; 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;epochTime&lt;/code&gt; 또는 &lt;code&gt;cpuTime&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="baa9f17ac8b7f5e394f4f3c35b922f174fd2bf83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;apply&lt;/code&gt; proc instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.12.0부터 사용되지 않음 :&lt;/strong&gt; 대신 &lt;code&gt;apply&lt;/code&gt; proc을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="813f61ed56bd8727049251f3d658b7107660c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;버전 0.12.0부터 사용되지 않습니다 :&lt;/strong&gt; 사용 &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f28367f57c9f2614afb958138d03a3bf3142b6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: Use &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않음&lt;/strong&gt; : 대신 &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2d7de988f2acf5e38494443df673fdfae41dc37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.get&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.get&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="299961d38c046d81a057b39c87e1ea3541f2bbbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.getContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.getContent&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="50ec41efadd97988380f7499bf68d5ceb1b22a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.post&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.post&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="7c32a49f3f9d3f8d7e600b14dd15502686a235da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.postContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.postContent&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="ed96372a5060ce286aef82b0d3c6ae674a124053" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.request&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.15.0부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.request&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="813b7f383169e8184fc6c9b0e28773046ac68201" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.16.2&lt;/strong&gt;: use &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.16.2부터 사용되지 않습니다&lt;/strong&gt; : 사용 &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="23834ea822e2c6d9726d7ec8d8695d7fb373d3c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.17.0&lt;/strong&gt;: This procedure isn't cross-platform and so should not be used in newly written code.</source>
          <target state="translated">&lt;strong&gt;버전 0.17.0부터 사용되지 않음&lt;/strong&gt; :이 절차는 크로스 플랫폼이 아니므로 새로 작성된 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4df24020923200ebb62009aa073b6e02140c4500" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.0&lt;/strong&gt;. For the common excluding range write &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; instead of &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (look at the spacing). For &lt;code&gt;&amp;lt;x&lt;/code&gt; write &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.0부터 사용되지 않습니다&lt;/strong&gt; . 기록 범위를 제외한 일반적인 옵션 &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; 대신 &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (간격 봐). 들면 &lt;code&gt;&amp;lt;x&lt;/code&gt; 라이트 &lt;code&gt;pred(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c7818b422a258b46806f0eafceaa44f6c79aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;. Use len() instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 len ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7ef1cf4f5f7fc799e0b35914ada5c795f1cd5725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; All functionality is defined on &lt;code&gt;NimNode&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 모든 기능은 &lt;code&gt;NimNode&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e84173b0ac9d2fd4420a0991936918f4ee1a8ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;genSym&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;genSym&lt;/code&gt; 을 사용 하여 새 &lt;code&gt;NimNode&lt;/code&gt; 를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="16653bf53256723a0cc8002763700158bb2a42ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;ident(string)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;ident(string)&lt;/code&gt; 사용 하여 새 &lt;code&gt;NimNode&lt;/code&gt; 를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7fca1a76838f997b6b479a7049316d7b71e5d23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;binarySearch&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;binarySearch&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="07febc28bfa9d03d0fa4ee192105ba5a7d71b5d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use one of &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.18.1부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b359efb52a169b0f8e2ad570667904d89cf4c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.8.12&lt;/strong&gt;: Use &lt;code&gt;parseWhile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;버전 0.8.12부터 사용되지 않음&lt;/strong&gt; : 대신 &lt;code&gt;parseWhile&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd66fa6e9cfcab65583dfb8b55c8ca91df2a0525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use &lt;code&gt;existsFile&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;버전 0.9.0부터 사용되지 않습니다 : &lt;/strong&gt; &lt;code&gt;existsFile&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="52c46f664e9ddbfa0ff79f37fc44b94ec7d81f29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use the function above.</source>
          <target state="translated">&lt;strong&gt;버전 0.9.0부터 사용되지 않음 :&lt;/strong&gt; 위의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97dff7a47c48bdad8d984c2e2262de3696009ba8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLine.</source>
          <target state="translated">&lt;strong&gt;버전 0.9.2부터 사용되지 않음&lt;/strong&gt; :이 함수는 readLine을 위해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f68edfa8278ec5885de09d908256c4b49e8634f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLineAsync.</source>
          <target state="translated">&lt;strong&gt;버전 0.9.2부터 사용되지 않음&lt;/strong&gt; :이 함수는 readLineAsync를 위해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4af36b03e871c9cae4428903b9bca8534e6953e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function is not safe for use.</source>
          <target state="translated">&lt;strong&gt;버전 0.9.2부터 사용되지 않음&lt;/strong&gt; :이 기능은 사용하기에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fface47b088c778a2f4e77c02bf19ee55d18a8e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 : &lt;/strong&gt; &lt;code&gt;fromWinTime&lt;/code&gt; 을 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06ec99b3afe2ae2cbe0edda32125eccea758f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;사용되지 않는 :&lt;/strong&gt; 사용 &lt;code&gt;toWinTime&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="3a884be761dae54201f8aa530278b417918acce3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; instead.</source>
          <target state="translated">&lt;strong&gt;사용되지 않는 :&lt;/strong&gt; 사용 &lt;em&gt;hasKey을&lt;/em&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a22c0c29442195e4011e17d60edeee2f5d85fcea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</source>
          <target state="translated">&lt;strong&gt;면책 조항&lt;/strong&gt; :이 코드는 테스트가 잘되지 않았으며 매우 안전하지 않으며 보안 취약점이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ffe4dc5c4fc52ea3ea1e3a20dd64567380feece" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this module for cryptographic purposes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;암호화 목적으로이 모듈을 사용하지 마십시오!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f928ed32bee5c29af52b00bc30f99ce156242335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : 항상 빈 문자열.</target>
        </trans-unit>
        <trans-unit id="d4209dbb40d9185067bcb8ce189cd1c6eed7f25e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: docstring if available.</source>
          <target state="translated">&lt;strong&gt;Docstring&lt;/strong&gt; : 가능한 경우 docstring.</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73e5c6a20cafb8203519ae745e546e8bb3f10e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 항상 빈 문자열.</target>
        </trans-unit>
        <trans-unit id="160ef9d36bed422272b88e68bd931cde20c08000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: enum type grouping other enum fields.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 다른 열거 형 필드를 그룹화하는 열거 형 유형.</target>
        </trans-unit>
        <trans-unit id="be7ebe20c5b6aef98f77a13140c9b09bb67359f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the iterator including return type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 반환 유형을 포함한 반복자의 서명.</target>
        </trans-unit>
        <trans-unit id="c6c20f7dbb204753d2338c8585a984c7c7fa8c25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the macro including return type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 반환 유형을 포함한 매크로의 서명.</target>
        </trans-unit>
        <trans-unit id="b6771fb30bab96fd8cf5d95cfd5b7411f13b3c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the method including return type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 반환 유형을 포함한 메서드의 서명.</target>
        </trans-unit>
        <trans-unit id="8779f27a30500300592c1fbc44c5a869259d7284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the proc including return type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 반환 유형을 포함한 proc의 서명.</target>
        </trans-unit>
        <trans-unit id="5b4c52d33a04c0f32a87d9b5783e815726a1d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the template including return type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 반환 유형을 포함한 템플릿의 서명.</target>
        </trans-unit>
        <trans-unit id="4dfd102fd6fbe96ece65dd9c1d384e0f16912006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the const value.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : const 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="63fb555122e12cadcd219b4c04854752ec0ed9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the let variable.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : let 변수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="20edb7c031a399a27ff6ff092cecc38f0cd151a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the parameter.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 매개 변수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d1c0d7dfb4af3e8e26314132e3d53473279ebfe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the result.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 결과 유형.</target>
        </trans-unit>
        <trans-unit id="c558e48e401e6265a17ebeab90f8b20f1f7e1e47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the var.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : var의 유형</target>
        </trans-unit>
        <trans-unit id="9384cc6e440487319d842110001333299d831093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : 유형.</target>
        </trans-unit>
        <trans-unit id="329b7e3326c98503c949ca9d39330b0e1c6794bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: type of the var.</source>
          <target state="translated">&lt;strong&gt;네 번째 열&lt;/strong&gt; : var의 유형</target>
        </trans-unit>
        <trans-unit id="978f10cfc82df92effeee967159555f49c21c819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</source>
          <target state="translated">&lt;strong&gt;향후 지침&lt;/strong&gt; : 검사되지 않은 배열에는 GC 메모리가 허용되어야하며 GC가 배열의 런타임 크기를 결정하는 방법에 대한 명시적인 주석이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="150871409dc1ef45a59e74d4be5900fd8cf45ddc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</source>
          <target state="translated">&lt;strong&gt;향후 지시 사항&lt;/strong&gt; : GC 메모리는 노동 조합에서 허용되어야하며 GC는 노동 조합을 보수적으로 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f1330a349c9dedfd2b8b17d35746d232592d00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: The &lt;code&gt;acyclic&lt;/code&gt; pragma may become a property of a &lt;code&gt;ref&lt;/code&gt; type:</source>
          <target state="translated">&lt;strong&gt;미래 방향&lt;/strong&gt; : &lt;code&gt;acyclic&lt;/code&gt; 주기적 프라그 마는 &lt;code&gt;ref&lt;/code&gt; 유형 의 속성이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="75d19ae59ec3e06e328ace922bad09261db8a6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;향후 지침&lt;/strong&gt; : 압축 pragma에서 GC 메모리를 사용하면 컴파일 타임 오류가 발생합니다. 상속이있는 사용법을 정의하고 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b59417140c3fc6f7e2c17f2c777a2f509360e62e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (or higher) Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;힌트 :&lt;/strong&gt; 함께 &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (또는 그 이상)의 NIM은 각 필터 적용 후 처리 코드.</target>
        </trans-unit>
        <trans-unit id="f555042911466061dac7f6fee69c396fc92108dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known limitations:&lt;/strong&gt; In the JavaScript target, global variables using the &lt;code&gt;codegenDecl&lt;/code&gt; pragma will be re-initialized on each reload. Please guard the initialization with a &lt;em&gt;once&lt;/em&gt; block to work-around this.</source>
          <target state="translated">&lt;strong&gt;알려진 제한 사항 :&lt;/strong&gt; JavaScript 대상에서 &lt;code&gt;codegenDecl&lt;/code&gt; pragma를 사용하는 전역 변수 는 다시로드 할 때마다 다시 초기화됩니다. 이 문제를 해결하려면 &lt;em&gt;한 번의&lt;/em&gt; 블록으로 초기화를 지키십시오 .</target>
        </trans-unit>
        <trans-unit id="5911ff88eb68bebee7d71b3a0d7b01ad6e208cea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 님은 현재 이것을 감지하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="140047e96ac4c58f01e73270812c9a51624feb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; At the moment hot code reloading is supported only in JavaScript projects.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 핫 코드 재로드는 JavaScript 프로젝트에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ae990ae2793f586640459d0853bfff28f07ff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Comment statement will be ignored.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 설명문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b69032440a3760c06332bd2946743c6dc04769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to &lt;code&gt;-1&lt;/code&gt; the tasks will only be executed after one or more file descriptors becomes readable or writeable.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 각 대리인에게는 이와 관련된 작업이 있습니다. 이것은 각 select () 호출 후에 호출됩니다. 시간 종료를 &lt;code&gt;-1&lt;/code&gt; 로 설정하면 하나 이상의 파일 디스크립터가 읽거나 쓸 수있게 된 후에 만 ​​태스크가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7f378938581797df4e574611774903888f75a977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 윤년의 경우 시작 날짜는 AD 1로 가정합니다. 주어진 연도의 1 월 1 일까지 윤년 수를 계산합니다. 지정된 연도가 윤년 인 경우 해당 연도의 1 월 1 일 이전에는 윤일이 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8234ec32d945f2b0f03239d1b0eaae84f70df2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to provide async ability to your module please do not use the &lt;code&gt;Delegate&lt;/code&gt; object, instead use &lt;code&gt;AsyncSocket&lt;/code&gt;. It is possible that in the future this type's fields will not be exported therefore breaking your code.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모듈에 비동기 기능을 제공하려면 &lt;code&gt;Delegate&lt;/code&gt; 객체를 사용하지 말고 &lt;code&gt;AsyncSocket&lt;/code&gt; 을 사용 하십시오 . 앞으로이 유형의 필드를 내 보내지 않아 코드가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6066c5e1dbc1c07031004fde7afa16f36e8afe0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most modules have tasks which need to be ran regularly, this is why you should not call &lt;code&gt;poll&lt;/code&gt; with a infinite timeout, or even a very long one. In most cases the default timeout is fine.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 대부분의 모듈에는 정기적으로 실행해야하는 작업이 있으므로 무한 시간 초과 또는 매우 긴 시간으로 &lt;code&gt;poll&lt;/code&gt; 을 호출해서는 안됩니다 . 대부분의 경우 기본 시간 초과가 정상입니다.</target>
        </trans-unit>
        <trans-unit id="4f92aa536204e6eaef641a2e69451b390e74e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;em&gt;프로젝트 파일 이름&lt;/em&gt; 의 이름입니다 &lt;code&gt;.nim&lt;/code&gt; 컴파일러의 명령 행 인수로 전달되는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2a72b0f5ef54ecdf16cb26a40bdbef5872800692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The API of FutureStream is still new and so has a higher likelihood of changing in the future.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; FutureStream의 API는 여전히 새 버전이므로 향후 변경 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="fe5b130db131453d8df37e590c01fe6f08bec9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the &lt;code&gt;-d:nimJsonGet&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 절차의 동작은 버전 0.14.0에서 변경되었습니다. 사용법 목록을 &lt;code&gt;-d:nimJsonGet&lt;/code&gt; 프로 시저의 이전 동작을 복원하려면 -d : nimJsonGet 플래그를 사용하여 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="c072da5e00ce440c3b93018b2a1ef17e9ee5503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures. &lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;em&gt;ptr&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 메시지 전달 구현은 순환 데이터 구조에서 작동하지 않습니다. &lt;strong&gt;참고 :&lt;/strong&gt; 스레드간에 채널을 전달할 수 없습니다. 전역을 사용하거나 &lt;em&gt;ptr로&lt;/em&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="b999dbe7ed39e219e124bd0949367e2e3d56fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The resulting &lt;code&gt;XmlNode&lt;/code&gt; already uses the &lt;code&gt;clientData&lt;/code&gt; field, so it cannot be used by clients of this library.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 결과 &lt;code&gt;XmlNode&lt;/code&gt; 는 이미 &lt;code&gt;clientData&lt;/code&gt; 필드를 사용 하므로이 라이브러리의 클라이언트가 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb469a558a1fb80f9ffa7a37d87dd2f9adc314d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The server may return multiple lines of coded replies.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 서버는 여러 줄의 코드화 된 응답을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1eacb2a91de8906a2993f50f4d1523095b2af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; There are no postfix operators in Nim. However, the &lt;code&gt;nnkPostfix&lt;/code&gt; node is used for the &lt;em&gt;asterisk export marker&lt;/em&gt;&lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Nim에는 접미사 연산자가 없습니다. 그러나 &lt;code&gt;nnkPostfix&lt;/code&gt; 노드는 &lt;em&gt;별표 내보내기 마커 &lt;/em&gt; &lt;code&gt;*&lt;/code&gt; 에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f905a6d385133393b2c96347260edc54f46375a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This does not preserve the new line characters used in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;s&lt;/code&gt; 에 사용 된 줄 바꾸기 문자는 유지되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b7811fa53cf7abdc675dfee2447ec973dd431ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is not supported on &lt;code&gt;Windows&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 &lt;code&gt;Windows&lt;/code&gt; 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10e606a3da78b8e2b189b92aa03f1f5e54c1d549" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is supported only by BSD and MacOSX.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 BSD 및 MacOSX에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b24c06d6eed7edbd4cef00490b4db7c0ca199c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module currently only supports select(), this is limited by FD_SETSIZE, which is usually 1024. So you may only be able to use 1024 sockets at a time.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 모듈은 현재 select () 만 지원하며 FD_SETSIZE (일반적으로 1024)에 의해 제한됩니다. 따라서 한 번에 1024 개의 소켓 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be757c0b40131a488a140d8d6a5f654644bde753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for SSL sockets.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 프로세스는 SSL 소켓에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8996a73c32006599330b4aacfeffcd8eabd847e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; POSIX OS에서 리턴되는 시간은 실제로 파일 속성이 마지막으로 수정 된 시간 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4326e562047392c7a998b1d78e1b1453866d2345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You may wish to use the high-level version of this function which is defined below.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 아래에 정의 된이 기능의 고급 버전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f7852fedb7919a22f8ce639864908dfafb58b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You will need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 비동기 프로세스에서 비동기 예제를 실행해야합니다. 그렇지 않으면 &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e153549d82bb0553e51565bc85af72f16648f194" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; 은 C ++의 큰 부분 집합을 구문 분석 할 수 있으며 &lt;code&gt;importcpp&lt;/code&gt; pragma 패턴 언어에 대해 알고 있습니다. 여기에 설명 된 모든 세부 사항을 알 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="752ddb5d050c961f8013cbe90d4ad9d26a7ee13a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; must be initialised (with &lt;code&gt;new&lt;/code&gt;), this function makes no effort to initialise the &lt;code&gt;client&lt;/code&gt; variable.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;client&lt;/code&gt; 를 초기화해야합니다 ( &lt;code&gt;new&lt;/code&gt; 사용 ).이 함수는 &lt;code&gt;client&lt;/code&gt; 변수 를 초기화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="449eaada440261e910e8e598da9c4ed1cfb68e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; needs to be initialised.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;client&lt;/code&gt; 를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed6c907ecc726f3524b1431bfea1378d7d591f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;data&lt;/code&gt; must be initialised.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;data&lt;/code&gt; 를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="79f23d79481e20b54cf233e31f8767bbf0d80411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;var&lt;/code&gt; parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 효율적인 매개 변수 전달에는 &lt;code&gt;var&lt;/code&gt; 매개 변수가 필요하지 않습니다. 비 Var 매개 변수는 수정할 수 없으므로 컴파일러는 실행 속도를 높일 수 있다고 생각되면 항상 참조로 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917b6bc95e7e2268d07e2f344f8fb05732bc1b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--dynlibOverride:name&lt;/code&gt; 명령 줄 옵션을 사용하여 &lt;code&gt;dynlib&lt;/code&gt; 가져 오기를 재정의 할 수 있습니다 . 컴파일러 사용 설명서에 추가 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c0c0109f9323e091c1b8f19f86e88886ea759e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: An &lt;span id=&quot;unresolved_1&quot;&gt;unresolved&lt;/span&gt; expression is an expression for which no symbol lookups and no type checking have been performed.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;span id=&quot;unresolved_1&quot;&gt;해결되지 않은&lt;/span&gt; 표현식은 기호 조회가없고 유형 검사가 수행 &lt;span id=&quot;unresolved_1&quot;&gt;되지 않은&lt;/span&gt; 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="19158a8ced28ef096d6d098faea99e938f8aea45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 전체 PEG가 단일 표현식 일 경우 특수 구문 확장으로 식별자는 비 터미널로 해석되지 않고 그대로 문자열로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="394b8821bf33b16092eceec91b4261c0182b2ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Code reordering is experimental and must be enabled via the &lt;code&gt;{.experimental.}&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 코드 재정렬은 실험적이며 &lt;code&gt;{.experimental.}&lt;/code&gt; pragma 를 통해 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="15d3410cbe9aaa0f2ff2edaf757af2c7376b1329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile time evaluation is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 컴파일 시간 평가는 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ec4927b4c9fc829236a51cac7723591db8396a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Composition (&lt;em&gt;has-a&lt;/em&gt; relation) is often preferable to inheritance (&lt;em&gt;is-a&lt;/em&gt; relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 간단한 코드 재사용을 위해 구성 ( &lt;em&gt;has-a&lt;/em&gt; relation)이 상속 ( &lt;em&gt;is-a&lt;/em&gt; relation) 보다 선호되는 경우가 많습니다 . 객체는 Nim의 값 유형이므로 구성은 상속만큼 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="0f588e4000ab499174937baf99ba9de907f81477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Concepts are still in development.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 컨셉은 아직 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="af0cb2698b6f62001c812557400b5666b24c541b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently exceptions are not propagated between &lt;code&gt;spawn&lt;/code&gt;'ed tasks!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 예외는 &lt;code&gt;spawn&lt;/code&gt; 작업 간에 전파되지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="e593de705b48a873244d353e72e0630bbbf7e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the compiler recognizes but ignores this pragma.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 컴파일러는이 pragma를 인식하지만 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1b2d5b76dbe4b87b85248e2c9cb6a142ec8c770f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the creation of &lt;code&gt;nimrtl.dll&lt;/code&gt; with thread support has never been tested and is unlikely to work!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 스레드 지원 으로 &lt;code&gt;nimrtl.dll&lt;/code&gt; 생성은 테스트 된 적이 없으며 작동하지 않을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fb2822c93615d44b3b3cc5966ff533ff418b8724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 소멸자는 여전히 실험 중이며 탈출 분석을 통합하기 위해 사양이 크게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1ed6db845c184364f8097a01163d56d39e9c4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Dot operators are still experimental and so need to be enabled via &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 도트 연산자는 아직 실험 단계이므로 &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt; 를 통해 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="76687951273781b82f6f05a64604534fc897b54a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For SSL sockets, the &lt;code&gt;handshake&lt;/code&gt; procedure must be called whenever the socket successfully connects to a server.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : SSL 소켓의 경우 소켓이 서버에 성공적으로 연결될 때마다 &lt;code&gt;handshake&lt;/code&gt; 절차를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="91e3db899bae0bbfb9a7d3d39b2d7c168b6e2d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; is an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; an alias for &lt;code&gt;untyped&lt;/code&gt;, but new code should use the newer, clearer names.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 역사적인 이유 &lt;code&gt;stmt&lt;/code&gt; 를 위한 별칭 &lt;code&gt;typed&lt;/code&gt; 및 &lt;code&gt;expr&lt;/code&gt; 의 별칭을 &lt;code&gt;untyped&lt;/code&gt; , 그러나 새로운 코드가 새로운, 깨끗한 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="35fa8c02b68bd348136724f65366d5d42363838f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;varargs[expr]&lt;/code&gt; is not equivalent to &lt;code&gt;varargs[untyped]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 역사적인 이유로 &lt;code&gt;varargs[expr]&lt;/code&gt; 은 &lt;code&gt;varargs[untyped]&lt;/code&gt; 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9cc5314fa7beb1755c498007976fd6bffd4a8741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the &lt;code&gt;-f&lt;/code&gt; command line option to force recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Nim은 SHA1 체크섬을 계산하고 파일이 변경된 경우에만 다시 컴파일합니다. &lt;code&gt;-f&lt;/code&gt; 명령 행 옵션을 사용 하여 파일을 강제로 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1271bb2722e7587eff37d0ec7806e796871dfb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Openarrays can only be used for parameters.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Openarray는 매개 변수에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69090e5eea8eeff4b4d6ed39bda4ed8ea1e00303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing variables to the &lt;code&gt;dynlib&lt;/code&gt; pragma will fail at runtime because of order of initialization problems.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 초기화 문제로 인해 런타임에 &lt;code&gt;dynlib&lt;/code&gt; pragma에 변수를 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d949419e5e8c75fc524d73127b46fd0d96b06e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Patterns like &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; are only supported in constant strings, because they are precompiled.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; 와 같은 패턴 은 사전 컴파일되므로 상수 문자열에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c87c54173a7af7c54802abf0f3667ebc67c0bd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Read/write tracking is not yet implemented!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 읽기 / 쓰기 추적은 아직 구현되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="935e75468fab30bc8f181842cd16bcdfa062c5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.this&lt;/code&gt; pragma is deprecated and should not be used anymore.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;.this&lt;/code&gt; pragma는 더 이상 사용되지 않으며 더 이상 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e111e86a91d15663eda5e4e58e22260484c13d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; operations are available at compile-time!</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;to&lt;/code&gt; 및 &lt;code&gt;$$&lt;/code&gt; 작업은 컴파일 타임에 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="1f9fdb234ef8ab9ea0cd0ee243a725c77f4c3646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The asynchronous implementation is only asynchronous for long file transfers, calls to functions which use the command socket will block.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 비동기 구현은 긴 파일 전송에 대해서만 비동기식이며 명령 소켓을 사용하는 함수에 대한 호출은 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="21b5006b1c5b3e0551182aafd1ac04017eed31d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 여기에 선언 된 데이터 유형에는 &lt;em&gt;값 의미가 있습니다&lt;/em&gt; . 이는 &lt;code&gt;=&lt;/code&gt; 가 세트의 사본을 수행함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="280898b023d47a8c9d92f2a9764ba5070e544d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 메모리가 0으로 초기화 되었기 때문에 작동합니다 ( &lt;code&gt;alloc&lt;/code&gt; 대신 &lt;code&gt;alloc0&lt;/code&gt; 이이를 수행함 ). 따라서 &lt;code&gt;d.s&lt;/code&gt; 는 2 진 0으로 초기화되어 문자열 할당이 처리 할 수 ​​있습니다. 가비지 수집 된 데이터를 관리되지 않는 메모리와 혼합 할 때 이와 같은 낮은 수준의 세부 정보를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="47964f4e63f9364071ab4aeb6d699ff7f8c08bcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--assumedef&lt;/code&gt; and &lt;code&gt;--assumendef&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수있는 &lt;code&gt;--assumedef&lt;/code&gt; 및 &lt;code&gt;--assumendef&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="beec5a850cfc6f7745e1b0ecb5a58d4d3717ffad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--suffix&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수있는 &lt;code&gt;--prefix&lt;/code&gt; 및 &lt;code&gt;--suffix&lt;/code&gt; 명령 행 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ba15cf193dfbb62171a2742d239684c78daa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--stdcall&lt;/code&gt; and &lt;code&gt;--cdecl&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 목적으로 사용할 수있는 &lt;code&gt;--stdcall&lt;/code&gt; 및 &lt;code&gt;--cdecl&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eae5a3b83fbed6b6c57ab8bbef30bd246b16faa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two approaches to parameter substitution support by this module.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 모듈의 매개 변수 대체 지원에는 두 가지 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a42997a6733b871213621a8b95f824a807c7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--dynlib&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수 있는 &lt;code&gt;--dynlib&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af996a9b1410d0551b826fcf6f31d2982be4597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--header&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수 있는 &lt;code&gt;--header&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6e6a5551e301a9206be409821f73e8efe724ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipcomments&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수 있는 &lt;code&gt;--skipcomments&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="24001770e3fa5f62c6de4221e4016da922b0b6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipinclude&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수 있는 &lt;code&gt;--skipinclude&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3d0067cf0a534d5914217a3b18410a03771aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--typeprefixes&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 동일한 용도로 사용할 수 있는 &lt;code&gt;--typeprefixes&lt;/code&gt; 명령 줄 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e18e21cf48841adbc9777187ae8968f7fba53e98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 문서는 초안입니다! Nim의 여러 기능에는보다 정확한 문구가 필요할 수 있습니다. 이 매뉴얼은 지속적으로 적절한 사양으로 발전하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="054e7ea2fe4b0d2089c5eb61f38663920957149a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level function, you may be interested in the higher level versions of this function which are also named &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 기능은 하위 수준 기능이므로 &lt;code&gt;recv&lt;/code&gt; 라는이 기능의 고급 버전에 관심이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5282ba94e7660dfc3a29bcd1eed3c48d245d27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level version of &lt;code&gt;send&lt;/code&gt;. You likely should use the version below.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 &lt;code&gt;send&lt;/code&gt; 의 저수준 버전입니다 . 아래 버전을 사용해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a69e35e7b9f3081695456106f46697c03ffedd82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This module is deprecated since version 0.11.3. You should use the async version of this module &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 모듈은 0.11.3 버전부터 사용되지 않습니다. 이 모듈 &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt; 의 비동기 버전을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2aa27f677d4a034cdeb59f9e8f5be392614db71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma should only be used by procs which consist solely of assembler statements.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 pragma는 어셈블러 명령문으로 만 구성된 proc 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3942176661636505e686cd1e170c9c2c66c7838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma will not exist for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 pragma는 LLVM 백엔드에는 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e370238e58db64e0d5e09298f252112f6df12b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure is mostly used for testing. You likely want to use &lt;code&gt;asyncnet.recvLine&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 절차는 주로 테스트에 사용됩니다. 대신 &lt;code&gt;asyncnet.recvLine&lt;/code&gt; 을 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="322b2c09d6ee80b4e8d9ee5e387bb8ede9f8c9b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure will &lt;strong&gt;NOT&lt;/strong&gt; register &lt;code&gt;fd&lt;/code&gt; with the global async dispatcher. You need to do this manually. If you have used &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; to create &lt;code&gt;fd&lt;/code&gt; then it's already registered.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 절차는 전역 비동기 디스패처에 &lt;code&gt;fd&lt;/code&gt; 를 등록 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 이 작업을 수동으로 수행해야합니다. 당신이 사용하는 경우 &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; 을 만들 &lt;code&gt;fd&lt;/code&gt; 후 이미 등록되어.</target>
        </trans-unit>
        <trans-unit id="d932869f99df24b8242ec488c4a11db3770fcfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will not work for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : LLVM 백엔드에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36372381e9ac840b308a26506bae63970c747486" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will set &lt;code&gt;sock&lt;/code&gt; to be non-blocking.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;sock&lt;/code&gt; 은 비 차단으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1223df2703569d7a264f78da6a04381483fe3ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: static[T] is still in development.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : static [T]는 아직 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="cfc7fae090374e3f5581cc6d980013b1b5608dd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this proc does not exist while using the JS backend.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 프로세스는 JS 백엔드를 사용하는 동안 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3999835082895c400051c08efff687fac9d5116a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance note&lt;/strong&gt;: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</source>
          <target state="translated">&lt;strong&gt;성능 정보&lt;/strong&gt; : Nim은 가상 메소드 테이블을 생성하지 않지만 디스패치 트리를 생성합니다. 이것은 메소드 호출을위한 비싼 간접 브랜치를 피하고 인라이닝을 가능하게합니다. 그러나 컴파일 시간 평가 또는 데드 코드 제거와 같은 다른 최적화는 메소드에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23e826b6b4ecba08efbc3138c61cefb888e1c674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invokation.</source>
          <target state="translated">&lt;strong&gt;사용하지 마십시오&lt;/strong&gt; : Android에서는 현재 &lt;code&gt;getHomeDir()&lt;/code&gt; 반환 하며 다른 Unix 기반 시스템에서는 보안 문제가 발생할 수 있습니다. 즉, 컴파일러 호출에 &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; 을 추가하여이 구현을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af53126db5be4c8aab90d27d5734b3708b192d3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type:</source>
          <target state="translated">&lt;strong&gt;제한 사항&lt;/strong&gt; : 오브젝트의 유형이 직렬화 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 이것은 객체에 컴파일 타임 유형과 다른 런타임 유형이있는 경우 본질적으로 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="92e0079e41a5b0f8de60d18697948189f4c07fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Style note&lt;/strong&gt;: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</source>
          <target state="translated">&lt;strong&gt;스타일 노트&lt;/strong&gt; : 코드 가독성을 위해 여전히 가장 강력한 프로그래밍 구성을 사용하는 것이 가장 좋습니다. &quot;체크리스트&quot;는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe1515dd837d06ebdfb95963f4b433b9a9c3985a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + const name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + const 이름.</target>
        </trans-unit>
        <trans-unit id="89fa1ce97e4b1a8bbc8a7bdf79f0c84b5531d6c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + enum type + enum field name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + enum type + enum 필드 이름.</target>
        </trans-unit>
        <trans-unit id="44cc69c566e0009f6ccc0fbac4d3567a0268b727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + iterator name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 반복자 이름.</target>
        </trans-unit>
        <trans-unit id="821988216adbe7cd1954ec0da5648027ef8dc44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + let name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + let name.</target>
        </trans-unit>
        <trans-unit id="57a25e461776b40d157a649de93257f5fe549d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + macro name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 매크로 이름.</target>
        </trans-unit>
        <trans-unit id="3166d2d68e6f9702d538e16e0e365a37f0f31329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + method name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 메서드 이름</target>
        </trans-unit>
        <trans-unit id="061167cd91100dd105e9d11351199c7b83c16430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 이름.</target>
        </trans-unit>
        <trans-unit id="acf85825d2dfb7a2233737f8ada9679976415f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + param name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + param name.</target>
        </trans-unit>
        <trans-unit id="546e3a8202699c79b7b925592249d4072a1845aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + proc name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + proc name.</target>
        </trans-unit>
        <trans-unit id="e1aaee074e6af2e4ed1a60de85b378cc36322c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + result.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 결과.</target>
        </trans-unit>
        <trans-unit id="ca9583e48baa25b1239a744bd75804685b9425dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + template name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 템플릿 이름.</target>
        </trans-unit>
        <trans-unit id="e445dd6209bef0d057963888553bf05a22332bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + type name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : 모듈 + [n 범위 중첩] + 유형 이름.</target>
        </trans-unit>
        <trans-unit id="0e96cb006b66e97d61d546d8e4a627270ae7af33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + var name.</source>
          <target state="translated">&lt;strong&gt;세 번째 열&lt;/strong&gt; : module + [n scope nesting] + var name.</target>
        </trans-unit>
        <trans-unit id="96622873fb587ed595611ae4d0e283ece6697a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is deprecated and should not be used&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;이 기능은 더 이상 사용되지 않으며 사용해서는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9df7eca11b12855add51f036ea9d3d1ea8ae1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage in JavaScript projects:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript 프로젝트에서의 사용법 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4316d6405c9f4c9d98f6e1f272b469fd25904ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Use it with caution. If &lt;code&gt;buf&lt;/code&gt; refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :주의해서 사용하십시오. &lt;code&gt;buf&lt;/code&gt; 가 GC의 객체를 참조하는 경우 버퍼 를 일찍 해제하지 않으려면 GC_ref / GC_unref 호출을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f8f9514a22b55ff9c78136da9ef8a81f67b0108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 프로세스 실행이 완료되지 않으면 프로세스가 강제로 종료됩니다. 그렇게하면 좀비 프로세스와 &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty 누수&lt;/a&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7648a978c3c5b08aa7a942fe439314fcbbd9e17c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It's not recommended to use &lt;code&gt;between&lt;/code&gt; for &lt;code&gt;DateTime's&lt;/code&gt; in different &lt;code&gt;TimeZone's&lt;/code&gt;. &lt;code&gt;a + between(a, b) == b&lt;/code&gt; is only guaranteed when &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in UTC.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 다른 &lt;code&gt;TimeZone's&lt;/code&gt; 에서 &lt;code&gt;DateTime's&lt;/code&gt; &lt;code&gt;between&lt;/code&gt; 에 사용하지 않는 것이 좋습니다 . &lt;code&gt;a + between(a, b) == b&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 UTC 인 경우에만 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0a52c8fdc83d67244f36d1e45904b31b08be93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since version 0.10.2 this module is deprecated. Use the &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; or the &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 버전 0.10.2부터이 모듈은 더 이상 사용되지 않습니다. 사용 &lt;a href=&quot;net&quot;&gt;그물을&lt;/a&gt; 하거나 &lt;a href=&quot;nativesockets&quot;&gt;nativesockets는&lt;/a&gt; 대신 모듈.</target>
        </trans-unit>
        <trans-unit id="9968b14e6044d19bea13d96a6048dbd5746bc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The &lt;code&gt;total&lt;/code&gt; reported by httpclient may be 0 in some cases.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;code&gt;total&lt;/code&gt; HttpClient를에 의해보고 된 것은 어떤 경우에는 0이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b0c00e568f6b8e8da0f3bc2db0c76c857a200b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The API of this module is unstable, and therefore is subject to change.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 모듈의 API가 불안정하므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d0af0517916216290aedd9e00253fb0aa629d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;em&gt;a&lt;/em&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 버퍼 &lt;em&gt;a&lt;/em&gt; 는 미리 할당되어야합니다. 예를 들어 &lt;code&gt;newString&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0520baa64a72e7ee0281b0ddd067f506549b20a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global list of handlers is a thread var, this means that the handlers must be re-added in each thread. &lt;strong&gt;Warning:&lt;/strong&gt; When logging on disk or console, only error and fatal messages are flushed out immediately. Use flushFile() where needed.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 전체 핸들러 목록은 스레드 var이므로 각 스레드에서 핸들러를 다시 추가해야합니다. &lt;strong&gt;경고 :&lt;/strong&gt; 디스크 나 콘솔에 로그온하면 오류 및 치명적인 메시지 만 즉시 플러시됩니다. 필요한 곳에 flushFile ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1de5e055501cd9543ed70f0688cbf30ac70cdc1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This function does not yet have a buffered implementation, so when &lt;code&gt;socket&lt;/code&gt; is buffered the non-buffered implementation will be used. Therefore if &lt;code&gt;socket&lt;/code&gt; contains something in its buffer this function will make no effort to return it.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 함수에는 아직 버퍼링 된 구현이 없으므로 &lt;code&gt;socket&lt;/code&gt; 이 버퍼링되면 버퍼되지 않은 구현이 사용됩니다. 따라서 &lt;code&gt;socket&lt;/code&gt; 에 버퍼에 무언가가 포함되어 있으면 이 함수는 반환하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="854f87e513637b6e9a5ac650c51cff41b8f768e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.10.2. Use the brand new &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; module together with the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 모듈은 0.10.2 버전부터 사용되지 않습니다. 아주 새로운 사용 &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch의&lt;/a&gt; 와 모듈 함께를 &lt;a href=&quot;asyncnet&quot;&gt;asyncnet의&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="aa0b3c2a66d1cb7f1d4a063b94c4ce6ca1f2543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.14.0.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 모듈은 0.14.0 버전부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7eb0dfd155d4b6f3b53e214b0ecc3fdf13f08633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated, use the SSL procedures defined in the &lt;code&gt;net&lt;/code&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 모듈은 더 이상 사용되지 않습니다 . 대신 &lt;code&gt;net&lt;/code&gt; 모듈에 정의 된 SSL 절차를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c5666a07ce3875934c4c4fc973b2a781936f5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module only supports the old asynchronous interface. You may wish to use the &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; instead for web applications.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 모듈은 이전 비동기 인터페이스 만 지원합니다. 웹 애플리케이션 대신 &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53266ecbd11ce935a7868dc21f59beb46ccb3aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 비 차단 소켓과 함께 SSL을 사용하는 경우이 절차가 차단 될 수 있으므로 acceptAddrSSL 절차를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="808a8a1028dc1fed134e205c55ec27d7dd5b23fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLine&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 버퍼되지 않은 소켓의 &lt;code&gt;recvLine&lt;/code&gt; 은 프로토콜이 &lt;code&gt;\r\L&lt;/code&gt; 을 사용하여 새 줄을 구분 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ac11ca7b54f8ac76331d539b39687d412032a370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLineInto&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 버퍼되지 않은 소켓에서 &lt;code&gt;recvLineInto&lt;/code&gt; 는 프로토콜이 &lt;code&gt;\r\L&lt;/code&gt; 을 사용하여 새 줄을 구분 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="5d163b20a95cadf02bed8abe7ed680f87b2b48bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : poParentStreams없이 생성 된 프로세스에 대해 waitForExit를 사용하면 출력 버퍼가 채워져 교착 상태가 발생할 수 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="0163b79bd484845ef77cdbb23264a20232b50266" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If &lt;code&gt;state&lt;/code&gt; is set incorrectly the resulting &lt;code&gt;AsyncSocket&lt;/code&gt; object may not work properly.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;state&lt;/code&gt; 가 잘못 설정되면 결과 &lt;code&gt;AsyncSocket&lt;/code&gt; 객체가 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f6766ee200b64744878c681dde8b968c6f670b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is currently supported.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 현재 &lt;code&gt;SafeDisconn&lt;/code&gt; 플래그 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5179a287236e2707d51c8ae92986184ef63e00df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only use this if you know what you are doing.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 수행중인 작업을 알고있는 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8ef80f1f143a1f7de2004bb4e9cee1fed78e787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 일부 OS (예 : Microsoft Windows)는 루트 사용자 (관리자)에게 심볼릭 링크 생성을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1f61c1a4fea430f13537ed29d0765d587962a8f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's restrict the creation of hard links to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 일부 OS는 루트 사용자 (관리자)에 대한 하드 링크 생성을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f9012f1b5937f6027293c08f92583d61921af08c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; flag is not yet implemented.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;Peek&lt;/code&gt; 플래그는 아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e86c259d83ff7290e4d751971a6fa6a8870f2e71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; socket flag is not supported on Windows.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;Peek&lt;/code&gt; 소켓 플래그는 Windows에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67b4583abc34f87fcf6eff4869eef2bfd28629d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;em&gt;tmpl&lt;/em&gt; argument is written to by &lt;em&gt;mkstemp&lt;/em&gt; and thus can't be a string literal. If in doubt copy the string before passing it.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;em&gt;tmpl&lt;/em&gt; 인수는 &lt;em&gt;mkstemp&lt;/em&gt; 에 의해 작성 되므로 문자열 리터럴이 될 수 없습니다. 확실하지 않은 경우 전달하기 전에 문자열을 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="eae8834fd1ff75f9c078051184e01727261e31cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The resulting &lt;code&gt;ptr AddrInfo&lt;/code&gt; must be freed using &lt;code&gt;freeAddrInfo&lt;/code&gt;!</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 결과 &lt;code&gt;ptr AddrInfo&lt;/code&gt; 사용하여 해제해야 &lt;code&gt;freeAddrInfo&lt;/code&gt; 을 !</target>
        </trans-unit>
        <trans-unit id="9e788c203930a853b492baa9fb790e0baaa6f689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;FileHandle&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 반환 된 &lt;em&gt;FileHandle&lt;/em&gt; 은 프로세스 &lt;code&gt;p&lt;/code&gt; 를 닫을 때 닫히므로 수동으로 닫아서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="35816baa23c24b5f9e80530b286a99de07763458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;Stream&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 반환 된 &lt;em&gt;스트림&lt;/em&gt; 은 프로세스 &lt;code&gt;p&lt;/code&gt; 를 닫을 때 닫히므로 수동으로 닫아서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="070d8f77f83eff23785cd22229e7c7593a9f015a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This assumes that lines are delimited by &lt;code&gt;\r\L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 이것은 라인이 &lt;code&gt;\r\L&lt;/code&gt; 로 구분된다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a9df6a23fa581b51ba2e0e996ce854f48568ec52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This function may give unexpected or completely wrong results on Windows.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :이 기능은 Windows에서 예기치 않거나 완전히 잘못된 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016fcff66b49f260c1c428fc4a770e9ba587d905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This module uses &lt;code&gt;immediate&lt;/code&gt; macros which are known to cause problems. Do yourself a favor and import the module as &lt;code&gt;from htmlgen import nil&lt;/code&gt; and then fully qualify the macros.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :이 모듈은 문제를 일으키는 것으로 알려진 &lt;code&gt;immediate&lt;/code&gt; 매크로를 사용 합니다 . &lt;code&gt;from htmlgen import nil&lt;/code&gt; 와 같이 모듈을 가져오고 매크로를 완전히 규정하십시오.</target>
        </trans-unit>
        <trans-unit id="1ee8bac63489b4b65f1d77d36e0156115bbf2067" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr_FR&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by &lt;code&gt;\w&lt;/code&gt;.</source>
          <target state="translated">&quot;단어&quot;문자는 밑줄 또는 문자 또는 숫자 인 256 미만의 문자입니다. 문자 및 숫자의 정의는 PCRE의 값이 낮은 문자표로 제어되며 로케일 별 일치가 발생하는 경우 다를 수 있습니다 (pcreapi 페이지의 &quot;로케일 지원&quot;참조). 예를 들어, &quot;fr_FR&quot;(프랑스어) 로켈에서 128보다 큰 일부 문자 코드는 악센트 부호 문자에 사용되며 &lt;code&gt;\w&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="aaba2403682a17469ecab3c6f2cc502e7be26d2b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HttpRequestError&lt;/code&gt; will be raised if the server responds with a client error (status code 4xx) or a server error (status code 5xx).</source>
          <target state="translated">&lt;code&gt;HttpRequestError&lt;/code&gt; 이 제기 될 경우 클라이언트 오류 (상태 코드 4XX) 또는 서버 오류 (상태 코드 5XX)로 서버 응답.</target>
        </trans-unit>
        <trans-unit id="d81d68641d8bf3ceba1aef0cf067b5ab815956a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ValueError&lt;/code&gt; exception will be raised if the value is not an integer.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; 값이 정수가 아닌 경우 예외가 발생한다.</target>
        </trans-unit>
        <trans-unit id="49a6495aba25fcc0345009a64738a98f0c760abf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block&lt;/code&gt; doesn't need an name, in which case &lt;code&gt;nnkEmpty&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;block&lt;/code&gt; 이 경우에 이름을 필요로하지 않는다 &lt;code&gt;nnkEmpty&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bde4d27b77941b8a2e8d7b668c0d8b482525e40c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;closure&lt;/code&gt; proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a &lt;code&gt;tuple[prc, env]&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; can be nil implying a call without a closure. This means that a call through a closure generates an &lt;code&gt;if&lt;/code&gt; but the interoperability is worth the cost of the &lt;code&gt;if&lt;/code&gt;. Thunk generation would be possible too, but it's slightly more effort to implement.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; 시저의 VAR는 기본 님의 호출 규칙의 일반 발동를 호출 할 수 있습니다. 그러나 다른 방법은 아닙니다! 클로저는 &lt;code&gt;tuple[prc, env]&lt;/code&gt; 로 구현됩니다 . &lt;code&gt;env&lt;/code&gt; 는 폐쇄없이 전화를 암시하지 않을 수 있습니다. 이는 클로저를 통한 호출이 &lt;code&gt;if&lt;/code&gt; 를 생성 하지만 상호 운용성은 &lt;code&gt;if&lt;/code&gt; 의 비용 가치가 있음을 의미합니다 . 썽크 생성도 가능하지만 구현하는 데 약간의 노력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="46ca6bf4504c12b38f73b70158bd4cc5686ceec6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;continue&lt;/code&gt; statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</source>
          <target state="translated">A는 &lt;code&gt;continue&lt;/code&gt; 주변 루프 구조의 바로 다음 반복에 문 리드. 루프 내에서만 허용됩니다. continue 문은 중첩 된 블록에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="fa532fc8ce7dbe2864f24cd2a27ac73e6fc36afd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; 유형은로부터 유도 된 새로운 유형의 &lt;span id=&quot;base-type_1&quot;&gt;기본 유형&lt;/span&gt; 의 기본 유형과 호환된다. 특히, 고유 한 유형의 필수 특성으로 기본 유형과 하위 유형 관계를 암시 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 고유 한 유형에서 기본 유형으로 또는 그 반대로 명시 적 유형 변환이 허용됩니다. 역방향 조작을 얻으려면 &lt;code&gt;distinctBase&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fec0b8e4f99548ff52eae3d0e8ec4be16fcde6a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; statement declares new local and global &lt;span id=&quot;single-assignment_1&quot;&gt;single assignment&lt;/span&gt; variables and binds a value to them. The syntax is the same as that of the &lt;code&gt;var&lt;/code&gt; statement, except that the keyword &lt;code&gt;var&lt;/code&gt; is replaced by the keyword &lt;code&gt;let&lt;/code&gt;. Let variables are not l-values and can thus not be passed to &lt;code&gt;var&lt;/code&gt; parameters nor can their address be taken. They cannot be assigned new values.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문은 새 로컬 및 글로벌 선언 &lt;span id=&quot;single-assignment_1&quot;&gt;한 할당&lt;/span&gt; 변수를 그들에게 값을 결합한다. 키워드 &lt;code&gt;var&lt;/code&gt; 가 &lt;code&gt;let&lt;/code&gt; 키워드로 대체 된다는 점을 제외하면 구문은 &lt;code&gt;var&lt;/code&gt; 문의 구문과 동일합니다 . 변수가 l 값이 아니므로 &lt;code&gt;var&lt;/code&gt; 매개 변수 로 전달 되거나 주소를 가져올 수 없습니다. 새로운 값을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8fe78b3a2821fa1451c04e1ee9b03eb161700c9d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;raises&lt;/code&gt; list can also be attached to a proc type. This affects type compatibility:</source>
          <target state="translated">&lt;code&gt;raises&lt;/code&gt; 목록은 발동 유형에 부착 될 수있다. 이것은 유형 호환성에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="c8cb08453579d0f15d45b19ab781ad1eab51f587" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</source>
          <target state="translated">A는 &lt;code&gt;varargs&lt;/code&gt; 파라미터는 별도로 절차에 가변 인자의 수를 전달할 수 있다는 openarray 파라미터이다. 컴파일러는 인수 목록을 내재적으로 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9932ed67f0c5e1f713b0339fd155b7567d8b4c9b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</source>
          <target state="translated">A는 &lt;code&gt;varargs&lt;/code&gt; 매개 변수가 openarray 매개 변수와 같습니다. 그러나 이는 또한 가변 개수의 인수를 프로 시저에 전달하는 것을 구현하는 수단이기도합니다. 컴파일러는 인수 목록을 배열로 자동 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e982b06375e4d6cb9864cbab229ee93da8102df8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;$&lt;/em&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">&lt;em&gt;$의&lt;/em&gt; 시저는 문자열을 반환 cstrings 정의됩니다. 따라서 cstring에서 nim 문자열을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="4924981c6cf86467817a6848ae253feb1dd3d357" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Source Code Filter&lt;/em&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">&lt;em&gt;소스 코드 필터&lt;/em&gt; 분석 전에 메모리 출력 스트림 입력 문자 스트림을 변환한다. 템플릿 시스템 또는 전처리기를 제공하는 데 필터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="787f1149d9267dbcf887509536779010033aad01" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subex&lt;/em&gt; (&lt;em&gt;Substitution Expression&lt;/em&gt;) represents an advanced string substitution. In contrast to a &lt;span id=&quot;regex_1&quot;&gt;regex&lt;/span&gt; which deals with string analysis, a &lt;em&gt;subex&lt;/em&gt; deals with string synthesis.</source>
          <target state="translated">&lt;em&gt;subex&lt;/em&gt; ( &lt;em&gt;대체 식&lt;/em&gt; ) 고급 문자열 대체를 나타냅니다. 문자열 분석을 다루는 &lt;span id=&quot;regex_1&quot;&gt;정규 표현식&lt;/span&gt; 과 달리 &lt;em&gt;하위 표현식&lt;/em&gt; 은 문자열 합성을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="889eb097f34d2cb2326af79e37dd19352cd4b767" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;checked-runtime-error_1&quot;&gt;checked runtime error&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these runtime checks. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">A는 &lt;span id=&quot;checked-runtime-error_1&quot;&gt;런타임 오류가 확인&lt;/span&gt; 오류입니다 구현 탐지하고 런타임에보고합니다. 이러한 오류를보고하는 방법은 &lt;em&gt;예외를 발생&lt;/em&gt; 시키거나 &lt;em&gt;치명적인 오류로 죽는 것입니다&lt;/em&gt; . 그러나 구현시 이러한 런타임 검사를 비활성화하는 방법이 제공됩니다. 자세한 내용은 &lt;a href=&quot;#pragmas&quot;&gt;pragma&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31c99118ea561948c45f870ebd2c2cce4b7b646d" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;guard_1&quot;&gt;guard&lt;/span&gt; annotation is introduced to prevent data races.</source>
          <target state="translated">&lt;span id=&quot;guard_1&quot;&gt;가드&lt;/span&gt; 주석은 데이터 레이스를 방지하기 위해 도입된다.</target>
        </trans-unit>
        <trans-unit id="386e659d1429b589f185720a9d5bf0ba95205db0" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;narrowing type conversion&lt;/span&gt; converts a larger to a smaller type (for example &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt;. A &lt;span id=&quot;widening-type-conversion_1&quot;&gt;widening type conversion&lt;/span&gt; converts a smaller type to a larger type (for example &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt;). In Nim only widening type conversions are &lt;em&gt;implicit&lt;/em&gt;:</source>
          <target state="translated">&lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;축소 형 전환은&lt;/span&gt; 예를위한 작은 유형 (에 큰 변환 &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt; 를했다. &lt;span id=&quot;widening-type-conversion_1&quot;&gt;형식 변환 넓히는&lt;/span&gt; 예에 대한 변환 큰 유형 작은 유형 ( &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt; )에서 님 만 확대 형식 변환이다. &lt;em&gt;내재적&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="387048b351545e7cdb57e945c46d2fba04806529" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt; is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</source>
          <target state="translated">&lt;span id=&quot;static-error_1&quot;&gt;정적 에러&lt;/span&gt; 구현 프로그램 실행 전에 감지 한 오류이다. 명시 적으로 분류되지 않은 한 오류는 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="130e98a36d1ad0d5fa779c624d02b3795704ff33" translate="yes" xml:space="preserve">
          <source>A Distinct type allows for the creation of new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must &lt;strong&gt;explicitly&lt;/strong&gt; define all behaviour for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">구별 유형을 사용하면 &quot;이 유형과 기본 유형 간의 하위 유형 관계를 암시하지 않는&quot;새로운 유형을 작성할 수 있습니다. 고유 한 유형에 대한 모든 동작을 &lt;strong&gt;명시 적으로&lt;/strong&gt; 정의 해야합니다 . 이를 돕기 위해 고유 한 유형과 기본 유형 모두 한 유형에서 다른 유형으로 캐스트 할 수 있습니다. 예제는 &lt;a href=&quot;manual#types-distinct-type&quot;&gt;매뉴얼에&lt;/a&gt; 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="79b065193cd9e9953658e8235e333843b91d5cf1" translate="yes" xml:space="preserve">
          <source>A Nim &lt;code&gt;string&lt;/code&gt; is implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to &lt;code&gt;cstring&lt;/code&gt; too:</source>
          <target state="translated">Nim &lt;code&gt;string&lt;/code&gt; 은 편의상 &lt;code&gt;cstring&lt;/code&gt; 으로 암시 적으로 변환 가능합니다. Nim 문자열이 C 스타일의 가변 프로 시저로 전달되면 암시 적으로 &lt;code&gt;cstring&lt;/code&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="69460fedc7d49aa8bfd391ea3c8be3ae26318394" translate="yes" xml:space="preserve">
          <source>A Nim procedure is asynchronous when it includes the &lt;code&gt;{.async.}&lt;/code&gt; pragma. It should always have a &lt;code&gt;Future[T]&lt;/code&gt; return type or not have a return type at all. A &lt;code&gt;Future[void]&lt;/code&gt; return type is assumed by default.</source>
          <target state="translated">Nim 프로시 저는 &lt;code&gt;{.async.}&lt;/code&gt; pragma를 포함 할 때 비동기 적 입니다. 항상 &lt;code&gt;Future[T]&lt;/code&gt; 반환 유형이 있거나 반환 유형 이 없어야 합니다. &lt;code&gt;Future[void]&lt;/code&gt; 반환 형식은 기본적으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="0bd52730a119bb22be3969f6811e2133725811be" translate="yes" xml:space="preserve">
          <source>A Nim program specifies a computation that acts on a memory consisting of components called &lt;span id=&quot;locations_1&quot;&gt;locations&lt;/span&gt;. A variable is basically a name for a location. Each variable and location is of a certain &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. The variable's type is called &lt;span id=&quot;static-type_1&quot;&gt;static type&lt;/span&gt;, the location's type is called &lt;span id=&quot;dynamic-type_1&quot;&gt;dynamic type&lt;/span&gt;. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</source>
          <target state="translated">Nim 프로그램은 &lt;span id=&quot;locations_1&quot;&gt;location&lt;/span&gt; 이라는 구성 요소로 구성된 메모리에서 작동하는 계산을 지정합니다 . 변수는 기본적으로 위치의 이름입니다. 각 변수 및 위치는 특정 &lt;span id=&quot;type_1&quot;&gt;유형&lt;/span&gt; 입니다. 변수 유형은 &lt;span id=&quot;static-type_1&quot;&gt;정적 유형&lt;/span&gt; 이고 위치 유형은 &lt;span id=&quot;dynamic-type_1&quot;&gt;동적 유형&lt;/span&gt; 입니다. 정적 유형이 동적 유형과 동일하지 않으면 동적 유형의 수퍼 유형 또는 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4d649a9b73eb1b75df006205a78131f546ab13c9" translate="yes" xml:space="preserve">
          <source>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</source>
          <target state="translated">PEG (Parsing expression grammar)는 파싱에 직접 사용될 수있는 간단한 결정 론적 문법입니다. 현재 구현은 정규식을보다 강력하게 대체하도록 설계되었습니다. UTF-8이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="33b07af826ffc1642e9db6c9aa9ff6e43b9cc68a" translate="yes" xml:space="preserve">
          <source>A application-level error condition. For example, some user input generated an exception. The application will continue to run, but functionality or data was impacted, possibly visible to users.</source>
          <target state="translated">응용 프로그램 수준 오류 조건 예를 들어 일부 사용자 입력에서 예외가 발생했습니다. 응용 프로그램은 계속 실행되지만 기능이나 데이터가 영향을 받아 사용자에게 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9beef18f6feec8ed926e501f6bc8ef50b29384" translate="yes" xml:space="preserve">
          <source>A application-level fatal condition. FATAL usually means that the application cannot go on and will exit (but this logging event will not do that for you).</source>
          <target state="translated">응용 프로그램 수준의 치명적 조건. 치명적은 일반적으로 응용 프로그램이 계속 진행되지 않고 종료됨을 의미합니다 (그러나이 로깅 이벤트는이를 수행하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0bc66569c7f749a991c86255655ab99ac30e86d5" translate="yes" xml:space="preserve">
          <source>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</source>
          <target state="translated">백 슬래시 뒤에 문자가 오는 것은 내장 매크로입니다. 그렇지 않으면 일반 이스케이프에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="519b373c181ee8d4be473dddf120c85a8c41428c" translate="yes" xml:space="preserve">
          <source>A block can be left prematurely with a &lt;code&gt;break&lt;/code&gt; statement. The break statement can leave a &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; statement. It leaves the innermost construct, unless a label of a block is given:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 문으로 블록을 조기에 남겨 둘 수 있습니다 . break 문은 &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;block&lt;/code&gt; 문 을 남길 수 있습니다 . 블록의 레이블이 제공되지 않는 한 가장 안쪽 구성을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="8018e99c199800e7c1d485e8e8e1d2de44558695" translate="yes" xml:space="preserve">
          <source>A call to an asynchronous procedure usually needs &lt;code&gt;await&lt;/code&gt; to wait for the completion of the &lt;code&gt;Future&lt;/code&gt;.</source>
          <target state="translated">비동기 프로 시저 호출은 일반적으로 필요로 &lt;code&gt;await&lt;/code&gt; 를 의 완성을 기다리는 &lt;code&gt;Future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd1dcf8b598ce13fe780f11e538b4c3679116e3" translate="yes" xml:space="preserve">
          <source>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">문자는 유니 코드 문자가 아니라 단일 바이트입니다. 그 이유는 효율성입니다. 압도적 인 대다수의 유스 케이스의 경우 UTF-8이 특별히 설계되었으므로 결과 프로그램은 여전히 ​​UTF-8을 올바르게 처리합니다. 또 다른 이유는 Nim 이 많은 알고리즘이이 기능에 의존 할 때 효율적으로 &lt;code&gt;array[char, int]&lt;/code&gt; 또는 &lt;code&gt;set[char]&lt;/code&gt; 를 지원할 수 있기 때문입니다 . &lt;em&gt;룬의&lt;/em&gt; 유형이 유니 코드 문자에 사용되는, 어떤 유니 코드 문자를 나타낼 수 있습니다. &lt;code&gt;Rune&lt;/code&gt; 은 &lt;a href=&quot;unicode&quot;&gt;유니 코드 모듈&lt;/a&gt; 에서 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="27a21ba557cb1102184eb887daf5fb2f0ee516b2" translate="yes" xml:space="preserve">
          <source>A compile-time error will be produced if the supplied type is not generic.</source>
          <target state="translated">제공된 유형이 일반이 아닌 경우 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e63142b740226a78a46d8a1af8bf22743ac95c8" translate="yes" xml:space="preserve">
          <source>A config file was loaded.</source>
          <target state="translated">구성 파일이로드되었습니다.</target>
        </trans-unit>
        <trans-unit id="9d676346fde6cb6856b2edfe8fcc862ca9818983" translate="yes" xml:space="preserve">
          <source>A contains element e</source>
          <target state="translated">A는 요소 e를 포함</target>
        </trans-unit>
        <trans-unit id="cd669926d307684088d5ef478be7b22480b9a5f4" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">&lt;code&gt;startProcess&lt;/code&gt; 와 함께 &lt;code&gt;command&lt;/code&gt; 을 실행 하고 출력을 문자열로 반환 하는 편리한 절차입니다 . 경고 :이 기능은 이전 버전과의 호환성을 위해 기본적으로 poEvalCommand를 사용합니다. 옵션을 명시 적으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d5eda57047be93a6d8ede446c939b622a61fcad5" translate="yes" xml:space="preserve">
          <source>A convention is that exceptions should be raised in &lt;em&gt;exceptional&lt;/em&gt; cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</source>
          <target state="translated">&lt;em&gt;예외적 인&lt;/em&gt; 경우 예외가 발생해야한다는 규칙이 있습니다 . 예를 들어, 파일을 열 수없는 경우, 파일이 존재하지 않기 때문에 예외가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9dc4e7e8a36779be1253db430e17a3ece42f97f6" translate="yes" xml:space="preserve">
          <source>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</source>
          <target state="translated">가독성을 높이기 위해 변환기를 명시 적으로 호출 할 수도 있습니다. 암시 적 변환기 체인은 지원되지 않습니다. A 형에서 B 형으로, B에서 C 형으로의 변환기가있는 경우 A에서 C 로의 내재적 변환은 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fabf98da32833f2ac2d72c57027f686f2dbd28b" translate="yes" xml:space="preserve">
          <source>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;):</source>
          <target state="translated">변환기는 &quot;암시 적으로 변환 가능&quot;유형 관계를 향상 시킨다는 점을 제외하고는 일반적인 프로세스와 같습니다 ( &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;변환 가능 관계&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ff0115af818672bc6f62e11d492d4642e32f4663" translate="yes" xml:space="preserve">
          <source>A converter is similar to a proc.</source>
          <target state="translated">변환기는 proc과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="95b68e940e0a6eefa4655d5db413050f4aee06c6" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">&lt;code&gt;{x, argA, argB}&lt;/code&gt; 와 같이 쉼표가있는 곱슬 표현식 은 사용자 정의 언어 내에서 사용자 정의 언어를 구문 분석 할 필요는 없지만 대신 선호하는 포맷터를 지원하기 위해 &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; 로 변환 될 수 있습니다. Nim의 기존 구문을 사용합니다. 또한 단일 문자 DSL에 넣을 수있는 것이 너무 많기 때문에 가독성에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="af339bf252ebc6686a22fa957452c6666fabae1d" translate="yes" xml:space="preserve">
          <source>A destructible context is currently only the following:</source>
          <target state="translated">파괴 가능한 컨텍스트는 현재 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4828b4e1e76af08cdc61d3da41001844c8e7647" translate="yes" xml:space="preserve">
          <source>A destructor is attached to the type it destructs; expressions of this type can then only be used in &lt;em&gt;destructible contexts&lt;/em&gt; and as parameters:</source>
          <target state="translated">소멸자는 소멸 된 유형에 연결됩니다. 이 유형의 표현식은 &lt;em&gt;파괴 가능한 컨텍스트&lt;/em&gt; 및 매개 변수 로만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5433f8711be01e7d00dc897cddea4967983783a7" translate="yes" xml:space="preserve">
          <source>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">소멸자는 구체적 유형의 단일 매개 변수를 가져야합니다 (일반 유형의 이름도 허용됨). 소멸자의 이름은 &lt;code&gt;=destroy&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b51be317d37d0d9e5679921ffa2c4f39470a9227" translate="yes" xml:space="preserve">
          <source>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">디렉토리는 &quot;의사 디렉토리&quot;라고도합니다. 경로가 같은 모듈이 여러 개인 경우 모호성을 피하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2010acb176bc59e66e9596fccd16c6be234aa62b" translate="yes" xml:space="preserve">
          <source>A distinct type can be used to model different physical &lt;span id=&quot;units_1&quot;&gt;units&lt;/span&gt; with a numerical base type, for example. The following example models currencies.</source>
          <target state="translated">예를 들어, 고유 한 유형을 사용하여 숫자 기본 유형으로 다른 물리적 &lt;span id=&quot;units_1&quot;&gt;단위&lt;/span&gt; 를 모델링 할 수 있습니다 . 다음 예제는 통화를 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="0dcbf503ecd251b550b20573f306de222e9f6e39" translate="yes" xml:space="preserve">
          <source>A does not contain element e</source>
          <target state="translated">A는 요소 e를 포함하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7339291827f4b694e439170ba77d07b22a6ba2d9" translate="yes" xml:space="preserve">
          <source>A dot following the hash &lt;code&gt;#.&lt;/code&gt; indicates that the call should use C++'s dot or arrow notation.</source>
          <target state="translated">해시 &lt;code&gt;#.&lt;/code&gt; 다음에 나오는 점 . 호출이 C ++의 점 또는 화살표 표기법을 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91daa2e8d1d787e2cb1cebec501d70a447fbdd47" translate="yes" xml:space="preserve">
          <source>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</source>
          <target state="translated">백 슬래시 ( &quot;)가 앞에 오는 큰 따옴표는 리터럴 큰 따옴표 (&quot;)로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5b983689cc856655c0945357d3fc5752f335fd52" translate="yes" xml:space="preserve">
          <source>A double-ended queue backed with a ringed seq buffer.</source>
          <target state="translated">링된 seq 버퍼로 백업 된 이중 엔드 큐.</target>
        </trans-unit>
        <trans-unit id="01ed7c56b187204e313f1f9d97ebfebcc0fecee3" translate="yes" xml:space="preserve">
          <source>A for loop variable.</source>
          <target state="translated">for 루프 변수.</target>
        </trans-unit>
        <trans-unit id="7d654b825945bd5f2a34963e2ce499f362a2a00c" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;em&gt;initRational&lt;/em&gt;. Example usage:</source>
          <target state="translated">친숙한 버전의 &lt;em&gt;initRational&lt;/em&gt; . 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="d411518da35d7d553e49043b1323d3beb87db97b" translate="yes" xml:space="preserve">
          <source>A generic hash set that remembers insertion order.</source>
          <target state="translated">삽입 순서를 기억하는 일반 해시 세트.</target>
        </trans-unit>
        <trans-unit id="e82bc7694d12c8d0a1eda93534f23d36363f6058" translate="yes" xml:space="preserve">
          <source>A generic hash set.</source>
          <target state="translated">일반 해시 세트.</target>
        </trans-unit>
        <trans-unit id="9e98d244bf1a5c7aeeae52fd19acf41b5eb1f418" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;#&lt;/code&gt; symbol is replaced by the first or next argument.</source>
          <target state="translated">해시 &lt;code&gt;#&lt;/code&gt; 기호는 첫 번째 또는 다음 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a53f6ddc26d79601afed6742fbd39fc945dc2d24" translate="yes" xml:space="preserve">
          <source>A helper for wrapping callback-based functions into promises and async procedures</source>
          <target state="translated">콜백 기반 함수를 약속 및 비동기 프로 시저로 래핑하는 도우미</target>
        </trans-unit>
        <trans-unit id="8f2cac0c1f19b93707af84e96c8e8344199be1d8" translate="yes" xml:space="preserve">
          <source>A higher level &lt;em&gt;ODBC&lt;/em&gt; database wrapper.</source>
          <target state="translated">상위 레벨 &lt;em&gt;ODBC&lt;/em&gt; 데이터베이스 랩퍼.</target>
        </trans-unit>
        <trans-unit id="d7086b8bccfe459c43887557d6fccf6aaa7324be" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; database wrapper. The same interface is implemented for other databases too.</source>
          <target state="translated">상위 레벨 &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; 데이터베이스 랩퍼. 다른 데이터베이스에도 동일한 인터페이스가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed449265b711e313a4301b54cee15ef550acdbf" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; database wrapper. This interface is implemented for other databases also.</source>
          <target state="translated">더 높은 수준의 &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; 데이터베이스 래퍼. 이 인터페이스는 다른 데이터베이스에도 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="18d9c046b2d8f8fc8c6daccb16db460900a01a66" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; database wrapper. This interface is implemented for other databases too.</source>
          <target state="translated">더 높은 수준의 &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; 데이터베이스 래퍼. 이 인터페이스는 다른 데이터베이스에도 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="17cc08bc05f9e3c22bbf4a01b73d4951016af63c" translate="yes" xml:space="preserve">
          <source>A label (used in &lt;code&gt;block&lt;/code&gt; statements).</source>
          <target state="translated">레이블 ( &lt;code&gt;block&lt;/code&gt; 설명에 사용)</target>
        </trans-unit>
        <trans-unit id="89265eb4f02e06930cfb5c35dd5f76b04d9c0a16" translate="yes" xml:space="preserve">
          <source>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the &lt;code&gt;dumpTree&lt;/code&gt; macro. But you can't use it &lt;em&gt;inside&lt;/em&gt; the macro you are writting/debugging. Instead &lt;code&gt;echo&lt;/code&gt; the string generated by &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;. If at the end of the this example you add &lt;code&gt;echo treeRepr(result)&lt;/code&gt; you should get the same output as using the &lt;code&gt;dumpTree&lt;/code&gt; macro, but of course you can call that at any point of the macro where you might be having troubles.</source>
          <target state="translated">매크로 작성시 마지막 팁 : 빌드중인 AST가 제대로 표시되는지 확실하지 않으면 &lt;code&gt;dumpTree&lt;/code&gt; 매크로 를 사용하고 싶을 수도 있습니다 . 그러나 쓰기 / 디버깅중인 매크로 &lt;em&gt;내&lt;/em&gt; 에서는 사용할 수 없습니다 . 대신 &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr에&lt;/a&gt; 의해 생성 된 문자열을 &lt;code&gt;echo&lt;/code&gt; 하십시오 . 이 예제의 끝에서 &lt;code&gt;echo treeRepr(result)&lt;/code&gt; 를 추가 하면 &lt;code&gt;dumpTree&lt;/code&gt; 매크로 를 사용하는 것과 동일한 출력을 얻을 수 있지만 물론 문제가 발생할 수있는 매크로의 어느 지점에서나 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62c0496669da44a5936805a3cdfee1fe957384a" translate="yes" xml:space="preserve">
          <source>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default &lt;code&gt;float&lt;/code&gt; in Nim maps to &lt;code&gt;float64&lt;/code&gt; such that the default AST for a float is &lt;code&gt;nnkFloat64Lit&lt;/code&gt; as below.</source>
          <target state="translated">AST의 잎은 종종 구체적인 구문의 터미널 기호에 해당합니다. Nim 의 기본 &lt;code&gt;float&lt;/code&gt; 는 &lt;code&gt;float64&lt;/code&gt; 에 매핑되어 float 의 기본 AST는 &lt;code&gt;nnkFloat64Lit&lt;/code&gt; 같이 nnkFloat64Lit 입니다.</target>
        </trans-unit>
        <trans-unit id="af284b25e3830a68d5e3016b0dc1d22187bec97a" translate="yes" xml:space="preserve">
          <source>A local variable shadows another local variable of an outer scope.</source>
          <target state="translated">지역 변수는 외부 범위의 다른 지역 변수를 음영 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d15ac9d0ba716c535ed2ce2885c3b9d90285db47" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile-time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. The transformed AST is then passed to the compiler as if the macro invocation would have been replaced by its result in the source code. This can be used to implement &lt;span id=&quot;domain-specific-languages_1&quot;&gt;domain specific languages&lt;/span&gt;.</source>
          <target state="translated">매크로는 컴파일 타임에 실행되는 특수 함수입니다. 일반적으로 매크로의 입력은 전달 된 코드의 추상 구문 트리 (AST)입니다. 그런 다음 매크로는 변환을 수행하고 변환 된 AST를 반환 할 수 있습니다. 변환 된 AST는 마치 매크로 호출이 소스 코드의 결과로 대체 된 것처럼 컴파일러에 전달됩니다. 이것은 &lt;span id=&quot;domain-specific-languages_1&quot;&gt;도메인 특정 언어&lt;/span&gt; 를 구현하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2320939f622f35d906ef2dffec7b8d388f8158e3" translate="yes" xml:space="preserve">
          <source>A macro that needs to be called &lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; can be used to rewrite &lt;code&gt;case&lt;/code&gt; statements in order to implement &lt;span id=&quot;pattern-matching_1&quot;&gt;pattern matching&lt;/span&gt; for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in &lt;code&gt;system.==&lt;/code&gt;):</source>
          <target state="translated">&lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; 라고하는 매크로를 사용하여 특정 유형에 대한 &lt;span id=&quot;pattern-matching_1&quot;&gt;패턴 일치&lt;/span&gt; 를 구현하기 위해 &lt;code&gt;case&lt;/code&gt; 문 을 다시 작성할 수 있습니다 . 다음 예제는 &lt;code&gt;system.==&lt;/code&gt; 제공된 기존 튜플에 대한 기존 등식 연산자를 활용하여 튜플에 대한 단순한 패턴 일치 양식을 구현합니다 ( == ).&lt;span id=&quot;pattern-matching_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c4a6d2ce7ae67ff08002aecf71f9b696f9005b38" translate="yes" xml:space="preserve">
          <source>A macro that takes as its only input parameter an expression of the special type &lt;code&gt;system.ForLoopStmt&lt;/code&gt; can rewrite the entirety of a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">유일한 입력 매개 변수로 특수 유형 &lt;code&gt;system.ForLoopStmt&lt;/code&gt; 의 표현식을 취하는 매크로 . ForLoopStmt 는 &lt;code&gt;for&lt;/code&gt; 루프 전체를 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8df2d80cd89e184b1f75f28697093931c58d398" translate="yes" xml:space="preserve">
          <source>A module alias can be introduced via the &lt;code&gt;as&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 키워드 를 통해 모듈 별칭을 도입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4afefca445f32ee9a9bac5a6c407d25bf9bc289" translate="yes" xml:space="preserve">
          <source>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</source>
          <target state="translated">모듈의 최상위 문장은 프로그램 시작시 실행됩니다. 예를 들어 복잡한 데이터 구조를 초기화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a99c0a025e79be3ef687fadc0cc6086e9682f6fb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;main&lt;/code&gt; async procedure must be declared to allow the use of the &lt;code&gt;await&lt;/code&gt; keyword. The connection will complete asynchronously and the client will be connected after the &lt;code&gt;await ftp.connect()&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; 키워드를 사용할 수 있도록 새로운 &lt;code&gt;main&lt;/code&gt; 비동기 프로 시저를 선언해야합니다 . 연결은 비동기 적으로 완료되며 &lt;code&gt;await ftp.connect()&lt;/code&gt; 호출 후 클라이언트가 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4f09c089b0b64dd84f87655d31d40b67c7f610c" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;em&gt;htmlFile&lt;/em&gt; parameter.</source>
          <target state="translated">&lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; 형식을 사용하여 색인에 새 항목이 추가됩니다 . 파일 부분은 &lt;em&gt;htmlFile&lt;/em&gt; 매개 변수 에서 &lt;em&gt;가져&lt;/em&gt; 옵니다.</target>
        </trans-unit>
        <trans-unit id="fc67102da94ccd07b62bc7ef2e58c87c378eee76" translate="yes" xml:space="preserve">
          <source>A non-error message that may indicate a potential problem rising or impacted performance.</source>
          <target state="translated">잠재적 인 문제가 발생하거나 성능에 영향을 줄 수 있음을 나타내는 오류가 아닌 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="911a5ad83db128f4812253b45faa46d98027ca72" translate="yes" xml:space="preserve">
          <source>A parameter &lt;code&gt;p&lt;/code&gt; in a template is even substituted in the expression &lt;code&gt;x.p&lt;/code&gt;. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</source>
          <target state="translated">템플릿 의 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 표현식 &lt;code&gt;x.p&lt;/code&gt; 대체됩니다 . 따라서 템플릿 인수를 필드 이름으로 사용할 수 있으며 정규화 된 경우에도 동일한 인수 이름으로 전역 기호를 음영 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b19cf459adbb632e3345bc4ce82a5563aa028fe2" translate="yes" xml:space="preserve">
          <source>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</source>
          <target state="translated">호출자가 인수 값을 제공하지 않으면 사용되는 기본값을 사용하여 매개 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0e5a46bea204df5866abc8071f4ce20c751ed1" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;untyped&lt;/code&gt; always matches any argument (as long as there is any argument passed to it).</source>
          <target state="translated">유형이 &lt;code&gt;untyped&lt;/code&gt; 유형의 매개 변수는 인수가 전달되는 한 항상 모든 인수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dbc7adf040bff90855d92e494801c3ab8308d57e" translate="yes" xml:space="preserve">
          <source>A pattern expression can be bound to a pattern parameter via the &lt;code&gt;expr{param}&lt;/code&gt; notation:</source>
          <target state="translated">패턴 표현식은 &lt;code&gt;expr{param}&lt;/code&gt; 표기법을 통해 패턴 매개 변수에 바인드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84dbef3c0526b967ebfd2aa664f1b6a0e87d7f54" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;em&gt;rsplit&lt;/em&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">&lt;em&gt;rsplit&lt;/em&gt; 의 가능한 일반적인 사용 사례 는 경로 조작, 특히 공통 구분 기호를 사용하지 않는 시스템에서입니다.</target>
        </trans-unit>
        <trans-unit id="468ffea579d79393dcb2eb8fd23d5f70574b0406" translate="yes" xml:space="preserve">
          <source>A proc can be marked with the &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like &lt;code&gt;return result;&lt;/code&gt; generated and the generated C function is declared as &lt;code&gt;__declspec(naked)&lt;/code&gt; or &lt;code&gt;__attribute__((naked))&lt;/code&gt; (depending on the used C compiler).</source>
          <target state="translated">proc에는 &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma 가 표시되어 컴파일러에게 proc의 스택 프레임을 생성해서는 안된다고 알릴 수 있습니다 . &lt;code&gt;return result;&lt;/code&gt; 와 같은 종료 명령문도 없습니다 . 생성되고 생성 된 C 함수는 &lt;code&gt;__declspec(naked)&lt;/code&gt; 또는 &lt;code&gt;__attribute__((naked))&lt;/code&gt; 로 선언됩니다 ( 사용 된 C 컴파일러에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="451fbc26f5ae1ee9316fb78b0e6ca76aa2f9e794" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</source>
          <target state="translated">새로운 실행 스레드로 실행되는 proc 은 가독성을 위해 &lt;code&gt;thread&lt;/code&gt; pragma 로 표시해야합니다 . 컴파일러는 &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;힙 공유 제한 없음&lt;/span&gt; 위반을 점검합니다 .이 제한은 다른 (스레드 로컬) 힙에서 할당 된 메모리로 구성된 데이터 구조를 구성하는 것이 유효하지 &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;않음을&lt;/span&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8f7a283eb6acfde98dfa18ad4771346a71dcb69" translate="yes" xml:space="preserve">
          <source>A proc, converter or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">proc, converter 또는 iterator는 &lt;code&gt;var&lt;/code&gt; 유형을 리턴 할 수 있습니다. 이는 리턴 된 값이 l 값이며 호출자가 수정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4ba9d6d1f4765955e60cabd2afda1cfb0cacfe70" translate="yes" xml:space="preserve">
          <source>A procedural type is a (somewhat abstract) pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">절차 적 유형은 절차에 대한 (약간 추상적 인) 포인터입니다. &lt;code&gt;nil&lt;/code&gt; 은 절차 유형의 변수에 허용되는 값입니다. Nim은 절차 적 유형을 사용하여 &lt;span id=&quot;functional_1&quot;&gt;기능적&lt;/span&gt; 프로그래밍 기술 을 달성 &lt;span id=&quot;functional_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="dbca622df4cb9e116b8115ae0a141864eed44cd7" translate="yes" xml:space="preserve">
          <source>A procedural type is internally a pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for variables of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">절차 유형은 내부적으로 프로 시저에 대한 포인터입니다. &lt;code&gt;nil&lt;/code&gt; 은 절차 유형의 변수에 허용되는 값입니다. Nim은 절차 적 유형을 사용하여 &lt;span id=&quot;functional_1&quot;&gt;기능적&lt;/span&gt; 프로그래밍 기술 을 달성 &lt;span id=&quot;functional_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="bf770f6e5979c1f778e9340dd0cdb848252fa2f0" translate="yes" xml:space="preserve">
          <source>A procedure may call itself recursively.</source>
          <target state="translated">프로시 저는 재귀 적으로 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="198d46da979417aa29b92d0cafdd5b26b6aa26bb" translate="yes" xml:space="preserve">
          <source>A procedure that returns a value has an implicit &lt;code&gt;result&lt;/code&gt; variable declared that represents the return value. A &lt;code&gt;return&lt;/code&gt; statement with no expression is a shorthand for &lt;code&gt;return result&lt;/code&gt;. The &lt;code&gt;result&lt;/code&gt; value is always returned automatically at the end of a procedure if there is no &lt;code&gt;return&lt;/code&gt; statement at the exit.</source>
          <target state="translated">값을 반환하는 프로 시저에는 반환 값을 나타내는 암시 적 &lt;code&gt;result&lt;/code&gt; 변수가 선언되어 있습니다. &lt;code&gt;return&lt;/code&gt; 없는 표정으로 문을위한 속기 &lt;code&gt;return result&lt;/code&gt; . &lt;code&gt;result&lt;/code&gt; 에는 존재하지 않는 경우 값은 항상 절차의 끝에서 자동으로 반환 &lt;code&gt;return&lt;/code&gt; 출구에서 문.</target>
        </trans-unit>
        <trans-unit id="4479e2a3631b65d0dd4c690b9db368a8f3b1652a" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">프로젝트는 명명 된 프로젝트의 특정 구성 파일 수 &lt;code&gt;$project.nim.cfg&lt;/code&gt; 그 같은 디렉토리에 상주 &lt;code&gt;$project.nim&lt;/code&gt; . 이 파일은 &lt;code&gt;--skipProjCfg&lt;/code&gt; 명령 행 옵션 으로 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e60afd1721ef96b7c6739e2759b02cb38c2c2d8c" translate="yes" xml:space="preserve">
          <source>A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the &lt;code&gt;newProxy&lt;/code&gt; constructor. Unfortunately, only basic authentication is supported at the moment.</source>
          <target state="translated">프록시는이 모듈에 정의 된 모든 절차에 대한 매개 변수로 지정할 수 있습니다. 이렇게하려면 &lt;code&gt;newProxy&lt;/code&gt; 생성자를 사용하십시오 . 불행히도 현재 기본 인증 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="eac1d47b4a0730fb9551845dd67bf5ea00259685" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</source>
          <target state="translated">정규식은 왼쪽에서 오른쪽으로 제목 문자열과 일치하는 패턴입니다. 대부분의 문자는 패턴으로 표시되며 주제의 해당 문자와 ​​일치합니다. 사소한 예로서 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df947512d73d9e3cb7375e44d4a39fd584e964d" translate="yes" xml:space="preserve">
          <source>A routine &lt;code&gt;p&lt;/code&gt; matches better than a routine &lt;code&gt;q&lt;/code&gt; if the following algorithm returns true:</source>
          <target state="translated">다음 알고리즘이 true를 리턴하면 루틴 &lt;code&gt;p&lt;/code&gt; 가 루틴 &lt;code&gt;q&lt;/code&gt; 보다 더 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="fdff97566890f772e04c8438a24bb2cbb00af4bb" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</source>
          <target state="translated">백 슬래시를 두 번째로 사용하면 인쇄 할 수없는 문자를 패턴으로 시각적으로 인코딩하는 방법이 제공됩니다. 패턴을 종료하는 2 진 0을 제외하고 비 인쇄 문자의 모양에는 제한이 없지만 텍스트 편집으로 패턴을 준비하는 경우 일반적으로 2 진 문자보다 다음 이스케이프 시퀀스 중 하나를 사용하는 것이 더 쉽습니다. 그것은 다음을 나타냅니다 ::</target>
        </trans-unit>
        <trans-unit id="3eac564020abe821a021c684a0c7e182c5615b2f" translate="yes" xml:space="preserve">
          <source>A section you should use to mark &lt;span id=&quot;runnable-example_1&quot;&gt;runnable example&lt;/span&gt; code with.</source>
          <target state="translated">&lt;span id=&quot;runnable-example_1&quot;&gt;실행 가능한 예제&lt;/span&gt; 코드 를 표시하는 데 사용해야하는 섹션 입니다.</target>
        </trans-unit>
        <trans-unit id="d3b57f32de0396cba5ad9e9d00b3af349a475164" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to a parameter that is of type &lt;em&gt;open array&lt;/em&gt;.</source>
          <target state="translated">시퀀스는 &lt;em&gt;open array&lt;/em&gt; 유형의 매개 변수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42f4d3d39137f32b8ca5b909c4ff4309a61d6eac" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to an openarray parameter.</source>
          <target state="translated">시퀀스는 openarray 매개 변수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9939043c42e4aaaff588930f28e3fb87a4c1d18" translate="yes" xml:space="preserve">
          <source>A set with all the possible characters.</source>
          <target state="translated">가능한 모든 문자가 포함 된 세트.</target>
        </trans-unit>
        <trans-unit id="13fa5f0ea96be473acaa7e27bc838b91426d27e9" translate="yes" xml:space="preserve">
          <source>A shared GC'ed heap might be provided.</source>
          <target state="translated">공유 GC의 힙이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af38f1c5146159966de284e8a35e5d86d3ab12b9" translate="yes" xml:space="preserve">
          <source>A shorthand for:</source>
          <target state="translated">속기 :</target>
        </trans-unit>
        <trans-unit id="dac4b4b7dce5d63bf65005785b5b8b3dd2313f8a" translate="yes" xml:space="preserve">
          <source>A similar thing happens with C code invoking Nim code which returns a &lt;code&gt;cstring&lt;/code&gt;. Consider the following proc:</source>
          <target state="translated">&lt;code&gt;cstring&lt;/code&gt; 을 반환하는 Nim 코드를 호출하는 C 코드에서도 비슷한 일이 발생합니다 . 다음 절차를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a48f6996b6131883f1b9650bc68f70d8d02303fe" translate="yes" xml:space="preserve">
          <source>A simple XML tree. More efficient and simpler than the DOM.</source>
          <target state="translated">간단한 XML 트리 DOM보다 더 효율적이고 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b881695a1cfe6f9170c0ac327d2994cb87b8beb2" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;&quot;*&quot;&lt;/code&gt; can be used for globbing.</source>
          <target state="translated">글 로빙 에는 단일 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17eb06b5b98ef723497f736d4beb2106d493fd2b" translate="yes" xml:space="preserve">
          <source>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</source>
          <target state="translated">정적 명령문 / 표현식을 사용하여 컴파일 시간 평가를 명시 적으로 시행 할 수 있습니다. 강제 컴파일 시간 평가는 부작용이있는 코드도 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793061e8f68073a7cc2b6e8e7cb7430e9cb435af" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; but &lt;em&gt;t&lt;/em&gt; has more elements than &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">엄격한 또는 부분 집합 &lt;em&gt;들&lt;/em&gt; 에 모든 회원을 가지고 &lt;em&gt;t&lt;/em&gt; 만 &lt;em&gt;t은&lt;/em&gt; 보다 많은 요소가 &lt;em&gt;들&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="692f4550479e6001b1a436a04309e4819905d924" translate="yes" xml:space="preserve">
          <source>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</source>
          <target state="translated">큰 따옴표 ( &quot;string&quot;)로 묶인 문자열은 포함 된 공백에 관계없이 단일 인수로 해석됩니다. 인용 된 문자열을 인수에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebec3b61b900cc32aa099451f2c6e12dd07c334c" translate="yes" xml:space="preserve">
          <source>A string variable is initialized with the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">문자열 변수는 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3a00e56e1710bd679d0173c57dab6fbeebbe31b" translate="yes" xml:space="preserve">
          <source>A subrange type has the same size as its base type (&lt;code&gt;int&lt;/code&gt; in the Subrange example).</source>
          <target state="translated">하위 범위 유형은 기본 유형과 동일한 크기를 갖습니다 ( 하위 범위 예제에서 &lt;code&gt;int&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a08933979326f8850950a1173db1b99805f1785" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</source>
          <target state="translated">하위 범위 유형은 정수 또는 열거 유형 (기본 유형)의 값 범위입니다. 예:</target>
        </trans-unit>
        <trans-unit id="5216761dae1ae277a963814830873f1da9e08d5b" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</source>
          <target state="translated">하위 범위 유형은 서수 또는 부동 소수점 유형 (기본 유형)의 값 범위입니다. 하위 범위 유형을 정의하려면 제한 값을 지정해야합니다. 유형의 가장 낮은 값과 가장 높은 값 :</target>
        </trans-unit>
        <trans-unit id="05319ab331bb8be9fb80a1ea2da5bff936f37a01" translate="yes" xml:space="preserve">
          <source>A subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; and &lt;em&gt;t&lt;/em&gt; doesn't necessarily have more members than &lt;em&gt;s&lt;/em&gt;. That is, &lt;em&gt;s&lt;/em&gt; can be equal to &lt;em&gt;t&lt;/em&gt;. Example:</source>
          <target state="translated">부분 집합 &lt;em&gt;들&lt;/em&gt; 에서 모든 회원이 &lt;em&gt;t를&lt;/em&gt; 하고 &lt;em&gt;t은&lt;/em&gt; 필요 이상의 회원이 없습니다 &lt;em&gt;들&lt;/em&gt; . 즉, &lt;em&gt;s&lt;/em&gt; 는 &lt;em&gt;t와&lt;/em&gt; 같습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="23fcaa56fd8e693a2e943e96baf6a166ee24925f" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention &lt;code&gt;nimcall&lt;/code&gt; can be passed to a parameter that expects a proc of the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">절차 유형의 미묘한 문제는 프로 시저의 호출 규칙이 유형 호환성에 영향을 미친다는 것입니다. 절차 유형은 동일한 호출 규칙이있는 경우에만 호환됩니다. 특별 연장으로, 호출 컨벤션의 절차 &lt;code&gt;nimcall&lt;/code&gt; 는 호출 컨벤션의 PROC 예상하는 매개 변수에 전달 될 수 &lt;code&gt;closure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ba9ca12af44d34318811768b34fc09edc238c4" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">절차 유형의 미묘한 문제는 프로 시저의 호출 규칙이 유형 호환성에 영향을 미친다는 것입니다. 절차 유형은 동일한 호출 규칙이있는 경우에만 호환됩니다. 다른 호출 규칙은 &lt;a href=&quot;manual#types-procedural-type&quot;&gt;매뉴얼에&lt;/a&gt; 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a98d0d55b4f56cd1973186508a85d670c67f313d" translate="yes" xml:space="preserve">
          <source>A symbol can be forced to be open by a &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; declaration:</source>
          <target state="translated">&lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; 선언으로 심볼을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0462b1952d8449154ce73caf7ef4db9422926829" translate="yes" xml:space="preserve">
          <source>A symbol of a module &lt;em&gt;can&lt;/em&gt; be &lt;em&gt;qualified&lt;/em&gt; with the &lt;code&gt;module.symbol&lt;/code&gt; syntax. And if a symbol is ambiguous, it &lt;em&gt;must&lt;/em&gt; be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</source>
          <target state="translated">모듈의 기호 는 &lt;code&gt;module.symbol&lt;/code&gt; 구문 으로 &lt;em&gt;규정&lt;/em&gt; 될 &lt;em&gt;수&lt;/em&gt; 있습니다 . 심볼이 모호한 경우 자격 이 &lt;em&gt;있어야&lt;/em&gt; 합니다. 두 개 이상의 다른 모듈에 정의되어 있고 두 모듈을 세 번째 모듈로 가져 오면 기호가 모호합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3a7ad38688e4496bf760973d6609aeb8d3bfad8" translate="yes" xml:space="preserve">
          <source>A symbol which is a &lt;code&gt;let&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 변수 인 기호입니다 .</target>
        </trans-unit>
        <trans-unit id="25afae3a203b27eb5151fb8ba040656c33e3555a" translate="yes" xml:space="preserve">
          <source>A symbol which is a constant.</source>
          <target state="translated">상수 인 기호.</target>
        </trans-unit>
        <trans-unit id="18336a58e1597be288809ec54b26b76e902b5f18" translate="yes" xml:space="preserve">
          <source>A symbol which is a converter.</source>
          <target state="translated">변환기 인 기호.</target>
        </trans-unit>
        <trans-unit id="34e5a133463d35676b1ce7b0d26dcb4084186353" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in a tuple or an object.</source>
          <target state="translated">튜플 또는 객체의 필드 인 심볼입니다.</target>
        </trans-unit>
        <trans-unit id="dbc7ff0193694a8a6df3edaa4feafaf08a548d9c" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in an enumeration.</source>
          <target state="translated">열거 형의 필드 인 기호입니다.</target>
        </trans-unit>
        <trans-unit id="b0f4c02b65e3aca97fa198aef1b1d7f8f50540e1" translate="yes" xml:space="preserve">
          <source>A symbol which is a generic parameter.</source>
          <target state="translated">일반 매개 변수 인 기호입니다.</target>
        </trans-unit>
        <trans-unit id="cee1e54f067d3a3df195ebd26b86fefccf9d512a" translate="yes" xml:space="preserve">
          <source>A symbol which is a macro.</source>
          <target state="translated">매크로 인 심볼.</target>
        </trans-unit>
        <trans-unit id="8ba65c84aa50b6b4fa8d3cfd3055d6bba8e59df2" translate="yes" xml:space="preserve">
          <source>A symbol which is a method.</source>
          <target state="translated">방법 인 심볼.</target>
        </trans-unit>
        <trans-unit id="397a59c937f508b55f4f508768e9f30b05e604a7" translate="yes" xml:space="preserve">
          <source>A symbol which is a module.</source>
          <target state="translated">모듈 인 심볼.</target>
        </trans-unit>
        <trans-unit id="2ebe7a11b22366113570683c1b68d2ed707218ec" translate="yes" xml:space="preserve">
          <source>A symbol which is a parameter.</source>
          <target state="translated">매개 변수 인 기호입니다.</target>
        </trans-unit>
        <trans-unit id="28496412faf0d454dab9dc1a6af576954c0a1ed5" translate="yes" xml:space="preserve">
          <source>A symbol which is a proc.</source>
          <target state="translated">proc 인 심볼.</target>
        </trans-unit>
        <trans-unit id="b83a50e7c38bef4fa30f012bba6b90bc90afc9ea" translate="yes" xml:space="preserve">
          <source>A symbol which is a template.</source>
          <target state="translated">템플릿 인 심볼.</target>
        </trans-unit>
        <trans-unit id="3462dea1dd2d1f68df6439bcca6ca7bca98f2daf" translate="yes" xml:space="preserve">
          <source>A symbol which is a type.</source>
          <target state="translated">유형 인 기호입니다.</target>
        </trans-unit>
        <trans-unit id="2a1357b126b87914b1b6f8a549043e8db1b4ede2" translate="yes" xml:space="preserve">
          <source>A symbol which is a variable.</source>
          <target state="translated">변수 인 기호.</target>
        </trans-unit>
        <trans-unit id="2d0634ee6e934140b8250f79b8ba8901843ddbb9" translate="yes" xml:space="preserve">
          <source>A symbol which is an iterator.</source>
          <target state="translated">반복자 인 심볼입니다.</target>
        </trans-unit>
        <trans-unit id="4e393c2bf071d79fe321a01e0a6eea1010d9f40a" translate="yes" xml:space="preserve">
          <source>A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls</source>
          <target state="translated">장치 별 입 / 출력 조작 및 일반 시스템 호출로 표현할 수없는 기타 조작에 대한 시스템 호출</target>
        </trans-unit>
        <trans-unit id="fc9ce8dd56e57484f7771a0858bc6ea64b79d22b" translate="yes" xml:space="preserve">
          <source>A table constructor is syntactic sugar for an array constructor:</source>
          <target state="translated">테이블 생성자는 배열 생성자에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="4a7a5f8021ef6500926b1cb58e60a0f63620d3dd" translate="yes" xml:space="preserve">
          <source>A table literal can be put into a &lt;code&gt;const&lt;/code&gt; section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</source>
          <target state="translated">테이블 리터럴은 &lt;code&gt;const&lt;/code&gt; 섹션에 넣을 수 있으며 컴파일러는 배열에 대한 것과 마찬가지로 실행 가능 데이터 섹션에 쉽게 넣을 수 있으며 생성 된 데이터 섹션에는 최소한의 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cfef19ba2df017b1840fca787af14959a3b9fbf8" translate="yes" xml:space="preserve">
          <source>A tag has to be a type name. A &lt;code&gt;tags&lt;/code&gt; list - like a &lt;code&gt;raises&lt;/code&gt; list - can also be attached to a proc type. This affects type compatibility.</source>
          <target state="translated">태그는 유형 이름이어야합니다. &lt;code&gt;tags&lt;/code&gt; 목록 - 유사한 &lt;code&gt;raises&lt;/code&gt; 목록 - 또한 PROC 유형에 부착 될 수있다. 이것은 형식 호환성에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c7c12a1bbcf06851adacdd13e78109f4548a353d" translate="yes" xml:space="preserve">
          <source>A template is a &lt;span id=&quot;hygienic_1&quot;&gt;hygienic&lt;/span&gt; macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</source>
          <target state="translated">템플릿은 &lt;span id=&quot;hygienic_1&quot;&gt;위생적인&lt;/span&gt; 매크로이므로 새로운 범위를 엽니 다. 대부분의 심볼은 템플릿의 정의 범위에서 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0909aebdac7146ab483112e0cffc46ee0650d8" translate="yes" xml:space="preserve">
          <source>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</source>
          <target state="translated">템플릿은 간단한 매크로 형태입니다. Nim의 추상 구문 트리에서 작동하는 간단한 대체 메커니즘입니다. 컴파일러의 시맨틱 패스에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4957f2f98151d72020ad997ae5b0177dbfe8bd70" translate="yes" xml:space="preserve">
          <source>A template where every parameter is &lt;code&gt;untyped&lt;/code&gt; is called an &lt;span id=&quot;immediate_1&quot;&gt;immediate&lt;/span&gt; template. For historical reasons templates can be explicitly annotated with an &lt;code&gt;immediate&lt;/code&gt; pragma and then these templates do not take part in overloading resolution and the parameters' types are &lt;em&gt;ignored&lt;/em&gt; by the compiler. Explicit immediate templates are now deprecated.</source>
          <target state="translated">모든 매개 변수의 &lt;code&gt;untyped&lt;/code&gt; 이 지정되지 않은 템플리트를 &lt;span id=&quot;immediate_1&quot;&gt;즉시&lt;/span&gt; 템플리트 라고합니다 . 역사적 이유로 템플릿에는 &lt;code&gt;immediate&lt;/code&gt; pragma 로 명시 적으로 주석을 달 수 있으며 이러한 템플릿은 오버로드 해상도에 참여하지 않으며 매개 변수 유형은 컴파일러에서 &lt;em&gt;무시&lt;/em&gt; 됩니다. 명시 적 즉시 템플릿은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c5c46bd6cd44a46ae88e10ca57070a21a6c5dbc" translate="yes" xml:space="preserve">
          <source>A test suite is a series of one or more related tests sharing a common fixture (&lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt;). The fixture is executed for EACH test.</source>
          <target state="translated">테스트 스위트는 공통 설비 ( &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;teardown&lt;/code&gt; )를 공유하는 일련의 하나 이상의 관련 테스트 입니다. 고정구는 각 테스트를 위해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31bf8aebbb82c9b930fd2c075ab23a6c84bd7bab" translate="yes" xml:space="preserve">
          <source>A thread proc is passed to &lt;code&gt;createThread&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; and invoked indirectly; so the &lt;code&gt;thread&lt;/code&gt; pragma implies &lt;code&gt;procvar&lt;/code&gt;.</source>
          <target state="translated">스레드 &lt;code&gt;createThread&lt;/code&gt; 는 createThread 또는 &lt;code&gt;spawn&lt;/code&gt; 전달되어 간접적으로 호출됩니다. 그래서 &lt;code&gt;thread&lt;/code&gt; pragma는 의미 &lt;code&gt;procvar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="41bb5d8b499e01e5a1190386e45f8f1ab3dfd432" translate="yes" xml:space="preserve">
          <source>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an &lt;em&gt;additional&lt;/em&gt; closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic &lt;code&gt;ref&lt;/code&gt; type.</source>
          <target state="translated">썽 크는 어떻게 든 'returnsDefaultCC [i]'를 호출해야하며 &lt;em&gt;추가&lt;/em&gt; 클로저 생성 이 필요합니다 ... 실제로는 아니지만 호출 할 함수를 전달해야합니다. 그래서 우리는 하나가 아닌 두 개의 간접 호출로 끝났습니다. 이 솔루션의 또 다른 훨씬 더 심각한 문제는 일반 &lt;code&gt;ref&lt;/code&gt; 유형을 통해 proc 포인터를 전달하는 것이 GC 안전하지 않다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a71df16ade8aee765ef43a13e09747416cdfc482" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</source>
          <target state="translated">지정된 시간 내에 데이터가 수신되지 않으면 ETimeout 예외가 발생하여 시간 초과를 밀리 초 단위로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5284b25f36831bd8cd3b0848696b52af7ef955" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</source>
          <target state="translated">지정된 시간 내에 충분한 데이터가 수신되지 않으면 시간 초과가 밀리 초로 지정 될 수 있습니다. ETimeout 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b206d5f711dced99df1aa8e9ea0d1479edc748b9" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</source>
          <target state="translated">지정된 시간 내에 충분한 데이터가 수신되지 않으면 TimeoutError 예외가 발생하여 시간 초과가 밀리 초로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a5e0bec046a288f45da3539bee961bd4b7e1bc5" translate="yes" xml:space="preserve">
          <source>A tuple type defines various named &lt;em&gt;fields&lt;/em&gt; and an &lt;em&gt;order&lt;/em&gt; of the fields. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify fields of the same type and of the same name in the same order.</source>
          <target state="translated">튜플 형식은 다양한 명명 된 &lt;em&gt;필드&lt;/em&gt; 와 &lt;em&gt;필드 &lt;/em&gt;&lt;em&gt;순서&lt;/em&gt; 를 정의 합니다. 생성자 &lt;code&gt;()&lt;/code&gt; 를 사용하여 튜플을 구성 할 수 있습니다. 생성자의 필드 순서는 튜플 정의의 순서와 일치해야합니다. 동일한 유형과 동일한 이름의 필드를 동일한 순서로 지정하면 다른 튜플 유형이 &lt;em&gt;동일&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5e6444b3f99eb953e87888c66966bcbc524ea4f4" translate="yes" xml:space="preserve">
          <source>A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:</source>
          <target state="translated">이름이없는 필드가 하나 인 튜플은 괄호와 후행 쉼표로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14170c2ff1e7de54f4e2348d1e871df1403c7064" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;explicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; 것입니다 &lt;strong&gt;명시 적으로&lt;/strong&gt; 형에 변환 가능한 &lt;code&gt;b&lt;/code&gt; 사실 다음의 알고리즘을 반환 IFF에 :</target>
        </trans-unit>
        <trans-unit id="0e266a33b4be68e2d75b658bf09d5fcd023a82b7" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;implicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; 는 이다 &lt;strong&gt;암시 적&lt;/strong&gt; 형에 변환 가능한 &lt;code&gt;b&lt;/code&gt; 사실 다음의 알고리즘을 반환 IFF에 :</target>
        </trans-unit>
        <trans-unit id="506a88b6ff206893ad4b7e57e9c4e7e99b518ff4" translate="yes" xml:space="preserve">
          <source>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the &lt;code&gt;is&lt;/code&gt; operator. Nim supports the following built-in type classes:</source>
          <target state="translated">타입 클래스는 특수한 의사 타입으로 과부하 해결 또는 &lt;code&gt;is&lt;/code&gt; 연산자 와 관련하여 타입과 일치하는 데 사용할 수 있습니다 . Nim은 다음과 같은 내장 유형 클래스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ec2661446eb8287aeb52ad012da364775c3dbaac" translate="yes" xml:space="preserve">
          <source>A type section begins with the &lt;code&gt;type&lt;/code&gt; keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single &lt;code&gt;type&lt;/code&gt; section. Nominal types like &lt;code&gt;objects&lt;/code&gt; or &lt;code&gt;enums&lt;/code&gt; can only be defined in a &lt;code&gt;type&lt;/code&gt; section.</source>
          <target state="translated">유형 섹션은 &lt;code&gt;type&lt;/code&gt; 키워드로 시작 합니다. 여러 유형 정의가 포함되어 있습니다. 유형 정의는 유형을 이름에 바인딩합니다. 타입 정의는 재귀 적이거나 상호 재귀적일 수 있습니다. 상호 재귀 유형은 단일 &lt;code&gt;type&lt;/code&gt; 섹션 내에서만 가능 합니다. &lt;code&gt;objects&lt;/code&gt; 또는 &lt;code&gt;enums&lt;/code&gt; 과 같은 명목 유형 은 &lt;code&gt;type&lt;/code&gt; 섹션 에서만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0511cf3cc72e09256f19cf736ca74f42546431bf" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types work better.</source>
          <target state="translated">정수 유형을 더 잘 혼합 할 수 있도록 편의를위한 유형 특수 버전 &lt;code&gt;..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1aca1ed394a97d0358e43ad02e64f2e9f0dad035" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;em&gt;IdentStartChars&lt;/em&gt; and is followed by any number of characters of the set &lt;em&gt;IdentChars&lt;/em&gt;.</source>
          <target state="translated">유효한 식별자는 세트 &lt;em&gt;IdentStartChars&lt;/em&gt; 의 문자로 시작하고 세트 &lt;em&gt;IdentChars&lt;/em&gt; 의 문자 수만큼 이어 &lt;em&gt;집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d0abd94780a5ea8e9be893452be742a7ec90a256" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;em&gt;x&lt;/em&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Option[T]&lt;/code&gt; 유형의 값은 값 &lt;em&gt;x&lt;/em&gt; ( &lt;code&gt;some(x)&lt;/code&gt; 표시됨)를 포함하거나 비어 있습니다 ( &lt;code&gt;none(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="061691c897942e6f7639e5b9fc01836fcff953a0" translate="yes" xml:space="preserve">
          <source>A variable can be marked with the &lt;code&gt;threadvar&lt;/code&gt; pragma, which makes it a &lt;span id=&quot;threadminuslocal_1&quot;&gt;thread-local&lt;/span&gt; variable; Additionally, this implies all the effects of the &lt;code&gt;global&lt;/code&gt; pragma.</source>
          <target state="translated">변수는 &lt;code&gt;threadvar&lt;/code&gt; pragma 로 표시 될 수 있으며 , 이는 &lt;span id=&quot;threadminuslocal_1&quot;&gt;스레드 로컬&lt;/span&gt; 변수가됩니다. 또한 이것은 &lt;code&gt;global&lt;/code&gt; pragma 의 모든 영향을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6cf2d03ae6a2d13d0af73951ec3e536467f5ec85" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</source>
          <target state="translated">구조화 된 유형의 변수는 동시에 여러 값을 보유 할 수 있습니다. 구조화 된 유형은 무제한 레벨로 중첩 될 수 있습니다. 배열, 시퀀스, 튜플, 객체 및 집합은 구조화 된 유형에 속합니다.</target>
        </trans-unit>
        <trans-unit id="c3f3d14f490e58bdf5285ce0bef4d7745002ec1a" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines an &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">튜플 또는 객체 유형의 변수는 이기종 스토리지 컨테이너입니다. 튜플 또는 객체는 유형의 다양한 명명 된 &lt;em&gt;필드&lt;/em&gt; 를 정의 합니다. 튜플은 또한 필드 의 &lt;em&gt;순서&lt;/em&gt; 를 정의 합니다. 튜플은 오버 헤드가없고 추상화 가능성이 거의없는 이기종 스토리지 유형을위한 것입니다. 생성자 &lt;code&gt;()&lt;/code&gt; 를 사용하여 튜플을 구성 할 수 있습니다. 생성자의 필드 순서는 튜플 정의 순서와 일치해야합니다. 동일한 유형의 동일한 필드를 동일한 순서로 지정하면 다른 튜플 유형이 &lt;em&gt;동일&lt;/em&gt; 합니다. &lt;em&gt;이름&lt;/em&gt; 필드는 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bdc1f89d378b40222906883361628b1181e0aa3" translate="yes" xml:space="preserve">
          <source>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. For example:</source>
          <target state="translated">열거 형 변수에는 열거 형의 지정된 값 중 하나만 할당 할 수 있습니다. 이 값은 순서가 지정된 기호 세트입니다. 각 기호는 내부적으로 정수 값에 매핑됩니다. 첫 번째 기호는 런타임에 0으로 표시되고 두 번째 기호는 1로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03eb03003aebc272b7eb136b33ffcf55da04a588" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;connect&lt;/code&gt; for non-blocking sockets.</source>
          <target state="translated">비 차단 소켓 &lt;code&gt;connect&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="71ed9093f7d2c5cbb9aa8a3933ec4cb522e39e48" translate="yes" xml:space="preserve">
          <source>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The &lt;code&gt;block&lt;/code&gt; statement can be used to open a new block explicitly:</source>
          <target state="translated">while (for) 문은 암시 적 블록을 소개합니다. 식별자는 선언 된 블록 내에서만 볼 수 있습니다. &lt;code&gt;block&lt;/code&gt; 문을 명시 적으로 새로운 블록을 열 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bc56783853877b4342018f4f4752a7c166237a4d" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; (i.e. one matches &lt;code&gt;\w&lt;/code&gt; and the other matches &lt;code&gt;\W&lt;/code&gt;), or the start or end of the string if the first or last character matches &lt;code&gt;\w&lt;/code&gt;, respectively.</source>
          <target state="translated">현재 문자와 이전 문자가 일치하지 둘 다 할 경우 단어 경계는 목표 문자열의 위치입니다 &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;\W&lt;/code&gt; (즉, 하나의 일치 &lt;code&gt;\w&lt;/code&gt; 와 다른 경기 &lt;code&gt;\W&lt;/code&gt; ) 또는 문자열 경우의 시작 또는 끝을 첫 번째 또는 마지막 문자는 각각 &lt;code&gt;\w&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="469aae2fa20a5b364724db93849620fbab87ad21" translate="yes" xml:space="preserve">
          <source>API naming design</source>
          <target state="translated">API 명명 디자인</target>
        </trans-unit>
        <trans-unit id="6e86868dfa064831def0a9a32949fcd3f02c8b05" translate="yes" xml:space="preserve">
          <source>AST based overloading</source>
          <target state="translated">AST 기반 과부하</target>
        </trans-unit>
        <trans-unit id="b08670d9d509dc53f0d69a06ccafcdfc0680021a" translate="yes" xml:space="preserve">
          <source>AST:</source>
          <target state="translated">AST:</target>
        </trans-unit>
        <trans-unit id="ed89ae3b78e13637e55b85c4b03f6daaccfcbc6b" translate="yes" xml:space="preserve">
          <source>Abbreviated three-letter form of the month.</source>
          <target state="translated">이 달의 약식 3 글자 형식입니다.</target>
        </trans-unit>
        <trans-unit id="02befbd420c9754ded8c9a688a174615ddafd2a6" translate="yes" xml:space="preserve">
          <source>About this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="1b33443d15e91efce2e27797d2c769792a4be765" translate="yes" xml:space="preserve">
          <source>Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operation.</source>
          <target state="translated">Nim의 런타임에서 발생하지만 &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; 작업에 매핑 될 수 있으므로 엄격하게 잠금 해제 할 수있는 모든 예외에 대한 추상 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="07ade5cd2426cf2d96d9f115a542fdf23ea73fb2" translate="yes" xml:space="preserve">
          <source>Abstract class for all exceptions that are catchable.</source>
          <target state="translated">잡을 수있는 모든 예외에 대한 추상 클래스.</target>
        </trans-unit>
        <trans-unit id="1cf35ec1eeb0cdf41c798e53ae7c4bdbcf3c6e03" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;astGenRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">nim 코드 블록을 승인하고 &lt;em&gt;astGenRepr&lt;/em&gt; 함수를 사용하여 구문 분석 된 추상 구문 트리를 인쇄합니다 . &lt;em&gt;컴파일 타임에&lt;/em&gt; 인쇄가 완료 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6e301f36546045d51728adbff6b973b0918094" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;lispRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">nim 코드 블록을 승인하고 &lt;em&gt;lispRepr&lt;/em&gt; 함수를 사용하여 구문 분석 된 추상 구문 트리를 인쇄합니다 . &lt;em&gt;컴파일 타임에&lt;/em&gt; 인쇄가 완료 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb919c05e9f3591e4b18f0af2d7cce492e0545f" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;treeRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">nim 코드 블록을 승인하고 &lt;em&gt;treeRepr&lt;/em&gt; 함수를 사용하여 구문 분석 된 추상 구문 트리를 인쇄합니다 . &lt;em&gt;컴파일 타임에&lt;/em&gt; 인쇄가 완료 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce207f0652d5a79c6fb92d9892844f64c3c7bc7f" translate="yes" xml:space="preserve">
          <source>Accepts a new client connection.</source>
          <target state="translated">새로운 클라이언트 연결을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="0612c97d4b20e5af1b9ee2e86992dd16c29c8cbf" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">새로운 연결을 수락합니다. 해당 연결 및 클라이언트의 원격 주소에 해당하는 클라이언트 소켓이 포함 된 미래를 반환합니다. 연결이 성공적으로 수락되면 미래가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="bb38da96bcf63ef07293cca8f7fae610327e435b" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">새로운 연결을 수락합니다. 해당 연결에 해당하는 클라이언트 소켓이 포함 된 미래를 반환합니다. 연결이 성공적으로 수락되면 미래가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="6813381cdc37c15725205e39fd4619d20653f02f" translate="yes" xml:space="preserve">
          <source>Accepts an instantiated generic type and returns its uninstantiated form.</source>
          <target state="translated">인스턴스화 된 제네릭 형식을 받아들이고 인스턴스화되지 않은 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="faf4ef0e56229453f96a306fcf1a0f1923d413de" translate="yes" xml:space="preserve">
          <source>Acceses a specified &lt;em&gt;entry&lt;/em&gt; from the current row.</source>
          <target state="translated">현재 행에서 지정된 &lt;em&gt;항목&lt;/em&gt; 을 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="f9e9dd7a48db03f7a1f9615c265496ab948af3da" translate="yes" xml:space="preserve">
          <source>Access the currently matched character</source>
          <target state="translated">현재 일치하는 캐릭터에 액세스</target>
        </trans-unit>
        <trans-unit id="9e2f25bad75994a6d0402acd174ffe98487bb1e8" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; and returns a mutable reference to it.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 i 번째 요소에 &lt;em&gt;액세스&lt;/em&gt; 하고 이에 대한 변경 가능한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b235504e101d141812cbd31b5736348cbd949d54" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; by order from first to last. deq[0] is the first, deq[^1] is the last.</source>
          <target state="translated">처음부터 끝까지 순서대로 &lt;em&gt;deq&lt;/em&gt; 의 i 번째 요소에 액세스하십시오 . deq [0]이 첫 번째이고 deq [^ 1]이 마지막입니다.</target>
        </trans-unit>
        <trans-unit id="c47d1e40dccddf8bf9622ec7b3c9e44c4af97584" translate="yes" xml:space="preserve">
          <source>Accumulator</source>
          <target state="translated">Accumulator</target>
        </trans-unit>
        <trans-unit id="737a162e2ca0961109be76dcbc40928b7272da0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock and then executes the code.</source>
          <target state="translated">주어진 잠금을 획득 한 다음 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e94c5bb8f50ed78a7cd750db454d2af3ae23df56" translate="yes" xml:space="preserve">
          <source>Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing.</source>
          <target state="translated">주어진 잠금을 획득하고 명령문을 본문에서 실행하고 명령문 실행이 완료된 후 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="1a3e3046bdb90198f8603411233d3c6451ca3f0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock.</source>
          <target state="translated">주어진 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="d2f9d48fe60d96f7c86fe92fea51a30eef86ea2a" translate="yes" xml:space="preserve">
          <source>Acts in a similar fashion to the &lt;em&gt;recvLine&lt;/em&gt; in the sockets module. Returns false when no data is available to be read. &lt;em&gt;Line&lt;/em&gt; must be initialized and not nil!</source>
          <target state="translated">소켓 모듈 의 &lt;em&gt;recvLine&lt;/em&gt; 과 비슷한 방식으로 작동합니다 . 읽을 수있는 데이터가 없으면 false를 반환합니다. &lt;em&gt;라인&lt;/em&gt; 은 반드시 초기화되어야하며 nil이 아니어야합니다!</target>
        </trans-unit>
        <trans-unit id="b05779dfde7404de32c688c1c9a48959dd22bdd2" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x에 &lt;/em&gt;&lt;em&gt;y&lt;/em&gt; 를 더 하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4feee750a058b68182288ba271fbda6845aca1fd" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">추가 &lt;em&gt;Y를&lt;/em&gt; 복소수에 &lt;em&gt;X&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c680f465bd9dc1e03f6e6d6ea7255c81ff7a44a5" translate="yes" xml:space="preserve">
          <source>Add a duration of time to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">A와 시간의 지속 시간을 추가 &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0329e59f93f564c5dfc0e70569d15fb9e15a73e3" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;em&gt;p&lt;/em&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">파일 이름, contentType 및 content를 수동으로 지정 하여 멀티 파트 데이터 &lt;em&gt;p에&lt;/em&gt; 파일을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="eec5847211247b4fd74ccdc819e2406c975b05b5" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;em&gt;p&lt;/em&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">멀티 파트 데이터 &lt;em&gt;p&lt;/em&gt; 에 멀티 파트 항목 목록을 추가하십시오 . 모든 값은 파일 이름과 컨텐츠 유형없이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="798a336ba2abb70a55f061577e20dced31fde63c" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;em&gt;p&lt;/em&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">멀티 파트 데이터 &lt;em&gt;p에&lt;/em&gt; 멀티 파트 항목을 추가하십시오 . 파일 이름과 내용 유형없이 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f04550fc57e117bf8d9e7db6f83bdeafaba0d38d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data. Raises a &lt;em&gt;ValueError&lt;/em&gt; exception if &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;contentType&lt;/em&gt; contain newline characters.</source>
          <target state="translated">멀티 파트 데이터에 값을 추가하십시오. 발생시킵니다 &lt;em&gt;는 ValueError&lt;/em&gt; 경우 예외 &lt;em&gt;이름&lt;/em&gt; , &lt;em&gt;파일 이름&lt;/em&gt; 또는 &lt;em&gt;contentType이가&lt;/em&gt; 개행 문자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="772b15743a6941c602fc6966a8c9ad76de348c4b" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the beginning of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 시작 부분에 &lt;em&gt;항목&lt;/em&gt; 을 추가하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f6d2bfa601515402b5cd9a27e6de27a42f1ae49" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the end of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 끝에 &lt;em&gt;항목&lt;/em&gt; 을 추가하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="804dca14340f9191ea44cbc9a5b612d3b7b60531" translate="yes" xml:space="preserve">
          <source>Add complex &lt;em&gt;x&lt;/em&gt; to float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;y&lt;/em&gt; 를 플로팅하려면 복소수 &lt;em&gt;x&lt;/em&gt; 를 더 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91af401e69eb5db85492da365b587bfdcdd3c94f" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an &lt;em&gt;IOError&lt;/em&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;em&gt;[]=&lt;/em&gt; instead.</source>
          <target state="translated">다중 파트 데이터 오브젝트에 파일을 추가하십시오. 파일이 디스크에서 열리고 자동으로 결정된 MIME 유형으로 읽고 전송됩니다. 발생시킵니다 &lt;em&gt;IO 오류를&lt;/em&gt; 파일을 열거 나 읽기가 실패 할 수없는 경우. 파일 내용, 파일 이름 및 MIME 형식을 수동으로 지정하려면 &lt;em&gt;[] =를&lt;/em&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="406ccec3a46c7096b360cd3465737a8b535aea4c" translate="yes" xml:space="preserve">
          <source>Add float &lt;em&gt;x&lt;/em&gt; to complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">복소수 &lt;em&gt;y에&lt;/em&gt; float &lt;em&gt;x&lt;/em&gt; 를 더 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="505c6693913fe1565ef1c731c3ebc737609d4c48" translate="yes" xml:space="preserve">
          <source>Add ident to dest if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">존재하지 않으면 dest에 ident를 추가하십시오. 이것은 pragma와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b50017805b1b6fc4f451182d9127fec897f8b761" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;x&lt;/em&gt; to rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;y에&lt;/em&gt; int &lt;em&gt;x&lt;/em&gt; 를 더 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fd52413273ba8dedf3c71352a83c577246c8699" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x에&lt;/em&gt; int &lt;em&gt;y&lt;/em&gt; 를 더 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f18a8ab635db264a0fe3a0922ec6560932edcddf" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;x&lt;/em&gt; to int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">int &lt;em&gt;y에&lt;/em&gt; 유리수 &lt;em&gt;x&lt;/em&gt; 를 더 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2aa6c134ddb31344adb0018507fd22c268b0cb12" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">합리적인 추가 &lt;em&gt;Y를&lt;/em&gt; 합리적으로 &lt;em&gt;X&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1747c4bec3777bff15f92b0cac11995facbb754" translate="yes" xml:space="preserve">
          <source>Add two complex numbers.</source>
          <target state="translated">복소수 두 개를 더합니다.</target>
        </trans-unit>
        <trans-unit id="10e886ac53c1940ea63eb1399092efb3e0175be5" translate="yes" xml:space="preserve">
          <source>Add two durations together.</source>
          <target state="translated">두 개의 지속 시간을 더하십시오.</target>
        </trans-unit>
        <trans-unit id="918bdd0b6e0ab8c7e512d1c14637656e65c676d4" translate="yes" xml:space="preserve">
          <source>Add two rational numbers.</source>
          <target state="translated">유리수 두 개를 더하십시오.</target>
        </trans-unit>
        <trans-unit id="f9f4e2a4ee342e53c003797651594c460da995fd" translate="yes" xml:space="preserve">
          <source>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</source>
          <target state="translated">프로그래머가 제어 할 수없는 클래스에 메소드를 추가하는 것은 불가능하거나 추악한 해결 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">추가 기능</target>
        </trans-unit>
        <trans-unit id="050d53ae9db89d00328e7590301c21bc8b18552a" translate="yes" xml:space="preserve">
          <source>Additional compilation switches</source>
          <target state="translated">추가 컴파일 스위치</target>
        </trans-unit>
        <trans-unit id="40896bd1d7fb4e2d2b859f8c06ae9aa5ebd3ac5f" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's GC and how to operate it in a</source>
          <target state="translated">Nim의 GC에 대한 추가 문서 및이를 관리하는 방법</target>
        </trans-unit>
        <trans-unit id="a15fa56393dfeea6e8ddbb0e0c2a6f3cc24b93de" translate="yes" xml:space="preserve">
          <source>Additional resources</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="683593bbc9f4d0095e1a329b2a170a4f6b64749a" translate="yes" xml:space="preserve">
          <source>Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">또한 encosed 텍스트를 색인에 용어로 추가합니다. 동일한 용어의 서로 다른 인스턴스에 다른 항목을 사용하는 데 관심이 있으므로, 테이블은 용어가 이전에 각각 다른 식별자 값을 제공하는 것으로 나타난 횟수를 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83025bdbec6a244fe913cb7d0ff67dac39e81e46" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;compile time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">또한 &lt;code&gt;-d:x=y&lt;/code&gt; 기호와 함께 값을 전달할 수 있습니다. -d : x = y : &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;컴파일 시간&lt;/a&gt; 과 함께 사용하여 빌드 시간 동안 기호를 재정의하도록 pragma 를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9cc91072a9c61406bb688685c655da8fcf1e11e" translate="yes" xml:space="preserve">
          <source>Addr operator</source>
          <target state="translated">주소 연산자</target>
        </trans-unit>
        <trans-unit id="e6513e72133cdea4324350e6d4ade50552f0fa2a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;arg&lt;/code&gt; as a &lt;code&gt;Node&lt;/code&gt; to the &lt;code&gt;NList&lt;/code&gt; If a node with the same name is already present in this map, it is replaced by the new one.</source>
          <target state="translated">&lt;code&gt;NList&lt;/code&gt; 에 &lt;code&gt;Node&lt;/code&gt; 로 &lt;code&gt;arg&lt;/code&gt; 를 추가합니다 . 동일한 이름을 가진 노드가이 맵에 이미 있으면 새 노드로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c0973ea96bcd93e616194aea6ada7ee253f95770" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;handler&lt;/code&gt; to the list of handlers.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 목록에 처리기 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="09af7b91c6e7df51cd37d298bdc37f650d040831" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 에 &lt;code&gt;interval&lt;/code&gt; 을 추가합니다 . &lt;code&gt;interval&lt;/code&gt; 구성 요소는 크기 순서대로 추가됩니다 (예 : 첫 번째 &lt;code&gt;years&lt;/code&gt; 구성 요소, 그런 다음 &lt;code&gt;months&lt;/code&gt; 구성 요소 등). 반환 된 &lt;code&gt;DateTime&lt;/code&gt; 은 입력과 동일한 시간대를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b3703e66f4731d1cd49994e51655ed816fcd0462" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">추가 &lt;code&gt;mimetype&lt;/code&gt; 받는 &lt;code&gt;mimedb&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d55bd8510c4909907c3b0b1b51f22ef8bfe1dc23" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initalized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 아직 초기화되지 않은 경우를 제외 하고 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; 에 추가합니다 . 이 경우 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;y&lt;/code&gt; 가됩니다</target>
        </trans-unit>
        <trans-unit id="08dd7691271b1b3cf31cdaad9abf0dd1ed892c5b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initialized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;@[y]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 아직 초기화되지 않은 경우 &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에 추가합니다 . 이 경우 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;@[y]&lt;/code&gt; 가됩니다 .</target>
        </trans-unit>
        <trans-unit id="910ee17a6a799e67a937708e73b9aedb33f3b0aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; it is initialized to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; 에 더 합니다 . 경우 &lt;code&gt;x&lt;/code&gt; 것입니다 &lt;code&gt;nil&lt;/code&gt; 가 초기화됩니다 &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d013d42946fcbe3af0f01b7362386e1eb7f928" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a JArray node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">JArray 노드 &lt;em&gt;father에 &lt;/em&gt;&lt;em&gt;자식&lt;/em&gt; 을 추가합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="277d7264e0b31954fb3f91658c21ef53fbc9f98b" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a SList node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">SList 노드 &lt;em&gt;father에 &lt;/em&gt;&lt;em&gt;자식&lt;/em&gt; 을 추가합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="282a03494ac60232eca16c10011aa2a3e77244c0" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;interval&lt;/em&gt; to &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">&lt;em&gt;시간 &lt;/em&gt;&lt;em&gt;간격&lt;/em&gt; 을 추가합니다 . 경우 &lt;em&gt;간격이&lt;/em&gt; 어떤 년, 월, 주 또는 일을 포함하는 작업이 로컬 시간대에 수행됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="168959e8e3da827112e6480f035af90769452610" translate="yes" xml:space="preserve">
          <source>Adds a &lt;em&gt;term&lt;/em&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">지정된 하이퍼 링크 식별자를 사용하여 색인에 &lt;em&gt;용어&lt;/em&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="46517870669c98767730789efc1c2a63afe0fd37" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;em&gt;s&lt;/em&gt; and applies the following escaping:</source>
          <target state="translated">문자열 &lt;em&gt;s에&lt;/em&gt; 문자를 추가 하고 다음 이스케이프를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="1f8aac4240d0d2f3105af4d844dbcb2abbdecf97" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the localName and namespaceURI of &lt;code&gt;newAttr&lt;/code&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">localName 및 namespaceURI가 &lt;code&gt;newAttr&lt;/code&gt; 인 속성이 있으면 새 속성 노드를 추가하고 새 속성 노드 로 대체하고 대체 된 속성이 리턴되고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="49966f2ea34f557267d410935160fd5454f498db" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the same &lt;em&gt;nodeName&lt;/em&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">동일한 &lt;em&gt;nodeName을&lt;/em&gt; 가진 속성 이 존재 하면 새로운 속성 노드를 추가하고 새로운 속성 노드 로 대체하고 대체 된 속성이 리턴되고 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8d941c7f90a962f0302be00a817bf48658be8c09" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified &lt;code&gt;name&lt;/code&gt; contains illegal characters</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 으로 지정된대로 새 속성을 추가합니다. 해당 이름을 가진 속성이 요소에 이미 존재하면 해당 값이 값 매개 변수의 값으로 변경됩니다. 지정된 &lt;code&gt;name&lt;/code&gt; 에 잘못된 문자가 포함되어 있으면 EInvalidCharacterErr이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="70b9921234cbd8dc467e865419512e1db5aa80e1" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;namespaceURI&lt;/code&gt;, &lt;code&gt;localName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;namespaceURI&lt;/code&gt; , &lt;code&gt;localName&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 로 지정된 새 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="175780a3fa3d64a9dc7aa37e3d80ca0adc76b294" translate="yes" xml:space="preserve">
          <source>Adds a node using its &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespaceURI&lt;/code&gt; 및 &lt;code&gt;localName&lt;/code&gt; 을 사용하여 노드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="71b9366e5b895a616623ffad66668f7f54484c12" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;em&gt;dest&lt;/em&gt; only if its length is bigger than &lt;em&gt;startLen&lt;/em&gt;.</source>
          <target state="translated">길이가 &lt;em&gt;startLen&lt;/em&gt; 보다 큰 경우에만 &lt;em&gt;dest&lt;/em&gt; 에 구분 기호를 추가합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="719fea5dd090dc5f35241a78b628149a3f6e753c" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;em&gt;children&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the &lt;em&gt;father&lt;/em&gt; node so that calls can be nested.</source>
          <target state="translated">각 자녀 추가 &lt;em&gt;자녀를&lt;/em&gt; 받는 &lt;em&gt;아버지&lt;/em&gt; 노드입니다. 통화가 중첩 될 수 있도록 &lt;em&gt;아버지&lt;/em&gt; 노드를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="77594e2b861c1fa8f8e68498df51e03371d37a9b" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition</source>
          <target state="translated">일상적인 정의에 pragma를 추가합니다</target>
        </trans-unit>
        <trans-unit id="392b56977e8236b6698f4ca58ac6c2f28d25c68f" translate="yes" xml:space="preserve">
          <source>Adds the &lt;em&gt;child&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">추가 &lt;em&gt;아이를&lt;/em&gt; 받는 &lt;em&gt;아버지&lt;/em&gt; 노드입니다. 통화가 중첩 될 수 있도록 아버지 노드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4be1f166b02d308f1b99389ad08b9ecee806fca1" translate="yes" xml:space="preserve">
          <source>Adds the callbacks proc to be called when the future completes.</source>
          <target state="translated">미래가 완료 될 때 호출 될 콜백 proc을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="087cbeb9fcc85f71b469524d8a7510230c6f6abc" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;em&gt;ext&lt;/em&gt; to &lt;em&gt;filename&lt;/em&gt;, unless &lt;em&gt;filename&lt;/em&gt; already has an extension.</source>
          <target state="translated">&lt;em&gt;filename에&lt;/em&gt; 이미 확장자가 없는 경우 파일 확장자 &lt;em&gt;ext&lt;/em&gt; 를 &lt;em&gt;filename에&lt;/em&gt; 추가합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38e43d237023eab5acc2b848d42530e464a0a37f" translate="yes" xml:space="preserve">
          <source>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.</source>
          <target state="translated">이 노드의 자식 목록 끝에 newChild 노드를 추가합니다. newChild가 이미 트리에있는 경우 먼저 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2a72a2ff357c75992d2d25db54f40e31c444189e" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the specified key. Appends to any existing values associated with the key.</source>
          <target state="translated">지정된 값을 지정된 키에 추가합니다. 키와 관련된 기존 값에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dcb76173f8b3f736f04cf7a85a76442e3061c9f2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;TimeInterval&lt;/code&gt; objects together.</source>
          <target state="translated">두 개의 &lt;code&gt;TimeInterval&lt;/code&gt; 객체를 함께 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0cd028f03aa8100d6b3d714eae3d5348fe823a2f" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure.</source>
          <target state="translated">종료 절차를 추가 / 등록합니다.</target>
        </trans-unit>
        <trans-unit id="5090ef07df2944062324712ca6950298e056c7f1" translate="yes" xml:space="preserve">
          <source>Adopting type for gui inspector in a game engine:</source>
          <target state="translated">게임 엔진에서 GUI 검사기의 유형 채택 :</target>
        </trans-unit>
        <trans-unit id="cd58779782de2792380285200da5a98425f86d02" translate="yes" xml:space="preserve">
          <source>Advanced command line switches are:</source>
          <target state="translated">고급 명령 행 스위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a3a43835953e413f721f837036117df744dbd00" translate="yes" xml:space="preserve">
          <source>Advanced commands:</source>
          <target state="translated">고급 명령 :</target>
        </trans-unit>
        <trans-unit id="21604196a5b5f020863aebeb14786b98a2ec02e1" translate="yes" xml:space="preserve">
          <source>Advanced options:</source>
          <target state="translated">고급 옵션:</target>
        </trans-unit>
        <trans-unit id="f1c748b61ceca05da788dea58f761592f09389bc" translate="yes" xml:space="preserve">
          <source>Advanced types</source>
          <target state="translated">고급 유형</target>
        </trans-unit>
        <trans-unit id="4eaa54faaeebcdcf16ca6cecc39180523a7c29ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\0&lt;/code&gt; up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence &lt;code&gt;\0\x\07&lt;/code&gt; specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 이후에 최대 두 개의 8 진수를 더 읽습니다. 두 경우 모두 두 자리 미만의 숫자 만 있으면 존재하는 숫자 만 사용됩니다. 따라서 &lt;code&gt;\0\x\07&lt;/code&gt; 시퀀스는 2 개의 이진수 0과 BEL 문자 (코드 값 7)를 차례로 지정합니다. 뒤 따르는 패턴 문자가 8 진수 인 경우 초기 0 다음에 2 자리를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c71390a639ed6627641b3cfd1f9a329a5cc9c625" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\x&lt;/code&gt;, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, or if there is no terminating &lt;code&gt;}&lt;/code&gt;, this form of escape is not recognized. Instead, the initial &lt;code&gt;\x&lt;/code&gt; will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 후에 는 0에서 2 개의 16 진수를 읽습니다 (문자는 대문자 또는 소문자 일 수 있음). UTF-8 모드에서는 &lt;code&gt;\x{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 사이에 16 진수 숫자가 표시 될 수 있지만 문자 코드 값은 2 ** 31보다 작아야합니다 (즉, 최대 16 진수 값은 7FFFFFFF입니다). 16 진수 이외의 문자가 &lt;code&gt;\x{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 사이에 나타나 거나 종료 &lt;code&gt;}&lt;/code&gt; 가 없으면 이스케이프 형식이 인식되지 않습니다. 대신, 초기 &lt;code&gt;\x&lt;/code&gt; 는 기본 16 진수 이스케이프로 해석되며 다음 숫자는없고 값이 0 인 문자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="622cf30c89947b71767229b80f2f6c86dfa76768" translate="yes" xml:space="preserve">
          <source>After a connection is made you can use the &lt;code&gt;store&lt;/code&gt; procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the &lt;code&gt;pwd&lt;/code&gt; procedure, you can also instead specify an absolute path.</source>
          <target state="translated">연결이 완료되면 &lt;code&gt;store&lt;/code&gt; 절차를 사용하여 새 파일을 FTP 서버에 업로드 할 수 있습니다 . &lt;code&gt;pwd&lt;/code&gt; 프로 시저를 사용하기 전에 올바른 작업 디렉토리에 있는지 확인하고 대신 절대 경로를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73d43ab167cd4ac21b418e91451904852662e79" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the &lt;a href=&quot;#install-command&quot;&gt;install command&lt;/a&gt; to place it where it will be found.</source>
          <target state="translated">컴파일이 끝나면 &lt;code&gt;bin&lt;/code&gt; 디렉토리 의 nim 컴파일러로 끝날 것입니다 . Nim의 &lt;code&gt;bin&lt;/code&gt; 디렉토리를 &lt;code&gt;$PATH&lt;/code&gt; 하거나 &lt;a href=&quot;#install-command&quot;&gt;install 명령&lt;/a&gt; 을 사용하여 디렉토리를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e10a07a137ad912e35e4faef7ca70acb747eef5" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">애프터 &lt;code&gt;from&lt;/code&gt; 모듈 이름가 다음에 다음과 문 &lt;code&gt;import&lt;/code&gt; 하나가 명시 적으로 전체 자격없이 사용 좋아하는 기호를 나열합니다 :</target>
        </trans-unit>
        <trans-unit id="4f797b80df1f8d64852f55b778851d191514b53d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;import&lt;/code&gt; statement a list of module names can follow or a single module name followed by an &lt;code&gt;except&lt;/code&gt; list to prevent some symbols to be imported:</source>
          <target state="translated">애프터 &lt;code&gt;import&lt;/code&gt; 다음에 모듈 이름의 목록이 따를 수 있습니다 문 또는 하나의 모듈 이름 &lt;code&gt;except&lt;/code&gt; 목록을 가져올 일부 기호를 방지하기 위해 :</target>
        </trans-unit>
        <trans-unit id="ee8f6842719daac0ef2d06cdb2e7fa5bd3d11c84" translate="yes" xml:space="preserve">
          <source>After the execution of &lt;code&gt;handleRequest&lt;/code&gt; the client socket will be closed automatically unless it has already been closed.</source>
          <target state="translated">&lt;code&gt;handleRequest&lt;/code&gt; 를 실행 한 후 클라이언트 소켓은 이미 닫히지 않으면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="cf6dcadff9cc79e46d3555b76c916fb3ed022d34" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently however &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">사용자 정의 유형 에 &lt;code&gt;hash&lt;/code&gt; 와 &lt;code&gt;==&lt;/code&gt; 를 추가하면 모든 것이 작동합니다. 그러나 현재 객체에 대한 &lt;code&gt;hash&lt;/code&gt; 는 정의되어 있지 않지만, 객체에 대한 &lt;code&gt;system.==&lt;/code&gt; 는 존재하며 일반적으로 원하는 &quot;심층&quot;비교 (모든 필드가 비교됨)를 수행합니다. 따라서 다음 예제에서는 &lt;code&gt;hash&lt;/code&gt; 만 구현 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c3ae9a42c0ef5d71d82ed6ff94ea44fa57d69eaa" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can create a TCP server by calling the &lt;code&gt;bindAddr&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;newSocket&lt;/code&gt; 프로 시저 로 소켓을 작성한 후 &lt;code&gt;bindAddr&lt;/code&gt; 및 &lt;code&gt;listen&lt;/code&gt; 프로 시저를 호출하여 TCP 서버를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19f5c4359047c1c4029762b09cefac6ce55773f8" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</source>
          <target state="translated">&lt;code&gt;newSocket&lt;/code&gt; 프로 시저 를 사용하여 소켓을 작성한 후 알려진 호스트 이름 (또는 IP 주소) 및 포트에서 실행중인 서버에 소켓을 쉽게 연결할 수 있습니다. TCP를 통해 그렇게하려면 아래 예를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5458c4cb0f05f3f6ed419b885d419d370bdf563e" translate="yes" xml:space="preserve">
          <source>Again, if you are wrapping a library which &lt;em&gt;mallocs&lt;/em&gt; and &lt;em&gt;frees&lt;/em&gt; data structures, you need to expose the appropriate &lt;em&gt;free&lt;/em&gt; function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own &lt;code&gt;malloc_structure&lt;/code&gt; and &lt;code&gt;free_structure&lt;/code&gt; specific functions, so wrapping these for the Nim side should be enough.</source>
          <target state="translated">다시 말하지만, 데이터 구조 를 &lt;em&gt;malloc&lt;/em&gt; 하고 &lt;em&gt;해제&lt;/em&gt; 하는 라이브러리를 래핑하는 경우 적절한 &lt;em&gt;자유&lt;/em&gt; 함수를 Nim 에 노출하여 정리할 수 있어야합니다. 물론 일단 청소 한 후에는 Nim (또는 해당 문제의 경우 C)에서 액세스하지 않아야합니다. 일반적으로 C 데이터 구조에는 자체 &lt;code&gt;malloc_structure&lt;/code&gt; 및 &lt;code&gt;free_structure&lt;/code&gt; 고유 함수가 있으므로 Nim 측에 래핑하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="2def8d1f86d78a731890a66e16deb2b5e1ea4254" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difference&quot;&gt;차이에&lt;/a&gt; 대한 별명 (s1, s2) .</target>
        </trans-unit>
        <trans-unit id="f4a02e1746a71e7fb0864cabf7b39376b3a63a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#intersection&quot;&gt;교차점&lt;/a&gt; 별명 (s1, s2) .</target>
        </trans-unit>
        <trans-unit id="7e2391f38322eb20263936b3bfa8fc3471e6b69b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;LEN ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d86fe62b7538063ec7bfae9f6c08a83088df2cff" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;LEN ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41b739a23c6fc05ac36095d9dd959eb84d6a5a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference (s1, s2)의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f3db9334116c6d200d159599181aa97f7e9eee70" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#union&quot;&gt;union (s1, s2)의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="8b5be6f17bdfd8cbcd14d0c4aa54788e9e3d34a0" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;none(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;none(T)&lt;/code&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="880b74f9b1a7d4cf4585f8c8f387bcb20192549a" translate="yes" xml:space="preserve">
          <source>Alias for for countSetBits (Hamming weight.)</source>
          <target state="translated">countSetBits의 별칭 (해밍 무게)</target>
        </trans-unit>
        <trans-unit id="2feaf49576ccc73f2b86d27faa6075fa943090f4" translate="yes" xml:space="preserve">
          <source>Aligns &lt;code&gt;s&lt;/code&gt; using &lt;code&gt;fill&lt;/code&gt; char. This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers.</source>
          <target state="translated">&lt;code&gt;fill&lt;/code&gt; 문자를 사용하여 &lt;code&gt;s&lt;/code&gt; 를 정렬합니다 . 표준 형식 지정자를 지원해야하는 사용자 정의 &lt;code&gt;format&lt;/code&gt; proc 을 작성하려는 경우에만 관심이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a373b51ddb20415acc6f2cab49e7a886d4418f7" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">문자열 정렬 &lt;em&gt;이야&lt;/em&gt; 와 &lt;em&gt;패딩&lt;/em&gt; , 그래서 길이의 것을 &lt;em&gt;계산&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="18f77fc6c5026c1d2d103f3b97daf7c1dbd054f5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;db_*&lt;/code&gt; modules support the same form of parameter substitution. That is, using the &lt;code&gt;?&lt;/code&gt; (question mark) to signify the place where a value should be placed. For example:</source>
          <target state="translated">모든 &lt;code&gt;db_*&lt;/code&gt; 모듈은 동일한 형식의 매개 변수 대체를 지원합니다. 즉, &lt;code&gt;?&lt;/code&gt; (물음표)는 값을 배치해야하는 장소를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9552063c6dac2a0b2b6f80dd47ebd5c82800945e" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</source>
          <target state="translated">모든 Nim 소스 파일은 UTF-8 인코딩 (또는 ASCII 서브 세트)으로되어 있습니다. 다른 인코딩은 지원되지 않습니다. 표준 플랫폼 라인 종료 시퀀스 중 하나를 사용할 수 있습니다-ASCII LF (줄 바꿈)를 사용하는 Unix 형식, ASCII 시퀀스 CR LF (줄 바꿈 다음에 줄 바꾸기)를 사용하는 Windows 형식 또는 ASCII CR (return)을 사용하는 이전 Macintosh 형식 캐릭터. 이 모든 형태는 플랫폼에 관계없이 동일하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c0abd1c94e3986f0fc217d43c9ce2e325e352e8" translate="yes" xml:space="preserve">
          <source>All asynchronous functions returning a &lt;code&gt;Future&lt;/code&gt; will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</source>
          <target state="translated">&lt;code&gt;Future&lt;/code&gt; 를 반환하는 모든 비동기 함수 는 차단되지 않습니다. 그러나 그들은 즉시 돌아 오지 않습니다. 비동기 함수에는 비동기 요청을하기 전에 실행될 코드가 있으며 대부분의 경우이 코드는 요청을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="987c15958bc12d3f55c911e8dc5fec4777c6bc5e" translate="yes" xml:space="preserve">
          <source>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">모든 표현식에는 컴파일 타임에 알려진 유형이 있습니다. Nim은 정적으로 입력됩니다. 새로운 유형을 선언 할 수 있으며, 본질적으로이 사용자 정의 유형을 나타내는 데 사용할 수있는 식별자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f984cab28f61b914c2bd533b03fae6756c4294ad" translate="yes" xml:space="preserve">
          <source>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are &lt;em&gt;not&lt;/em&gt; available. The &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt; module is automatically imported in every module.</source>
          <target state="translated">모듈의 모든 식별자는 선언 시점부터 모듈 끝까지 유효합니다. 간접적으로 의존 모듈의 식별자는 &lt;em&gt;하지&lt;/em&gt; 가능합니다. &lt;span id=&quot;system_1&quot;&gt;시스템&lt;/span&gt; 모듈은 자동으로 모든 모듈에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cded9aa9ab6801c06f94e1f6e9e5425ed01952a5" translate="yes" xml:space="preserve">
          <source>All of the available idetools commands require you to specify a query location through the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--trackDirty&lt;/code&gt; switches. The general idetools invocations are:</source>
          <target state="translated">사용 가능한 모든 idetools 명령을 사용하려면 &lt;code&gt;--track&lt;/code&gt; 또는 &lt;code&gt;--trackDirty&lt;/code&gt; 스위치를 통해 쿼리 위치를 지정해야 합니다. 일반적인 idetools 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96cbbecb3e99c48c7b4fe7081d99be9e034325bf" translate="yes" xml:space="preserve">
          <source>All string literals are of the type &lt;code&gt;string&lt;/code&gt;. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero.</source>
          <target state="translated">모든 문자열 리터럴은 유형의이다 &lt;code&gt;string&lt;/code&gt; . Nim의 문자열은 일련의 문자와 매우 유사합니다. 그러나 Nim의 문자열은 모두 0으로 끝나고 길이 필드가 있습니다. 빌트인 &lt;code&gt;len&lt;/code&gt; 프로 시저로 길이를 검색 할 수 있습니다 . 길이는 종료 0을 계산하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6b1a1f14d43339564b33e2a129f631ca1f3956e" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;tests/caas/*.txt&lt;/code&gt; files encode a session with the compiler:</source>
          <target state="translated">모든 &lt;code&gt;tests/caas/*.txt&lt;/code&gt; 파일은 컴파일러와의 세션을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="d7d265f3de6bf8deede109e19dc230beea86f266" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace.</source>
          <target state="translated">공백으로 계산되는 모든 문자</target>
        </trans-unit>
        <trans-unit id="0858ffb5249b4b454db4fc31e3311bb8f257c071" translate="yes" xml:space="preserve">
          <source>All the comparison operators can be used with enumeration types.</source>
          <target state="translated">모든 비교 연산자를 열거 형과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c891dcf4573456ce1e2da5262b50d0a08307027" translate="yes" xml:space="preserve">
          <source>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</source>
          <target state="translated">모든 작업이 효율적으로 수행되어야합니다. 셀셋이 커질 수 있기 때문에 해시 테이블만으로는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7919c15f302a782639503db1ddcfd789a925698" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence &lt;code&gt;\b&lt;/code&gt; is interpreted as the backspace character (hex 08), and the sequence &lt;code&gt;\X&lt;/code&gt; is interpreted as the character &quot;X&quot;. Outside a character class, these sequences have different meanings (see below).</source>
          <target state="translated">단일 바이트 값 또는 단일 UTF-8 문자 (UTF-8 모드)를 정의하는 모든 시퀀스는 내부 및 외부 문자 클래스 모두에서 사용될 수 있습니다. 또한 문자 클래스 내에서 시퀀스 &lt;code&gt;\b&lt;/code&gt; 는 백 스페이스 문자 (16 진 08) 로 해석되고 시퀀스 &lt;code&gt;\X&lt;/code&gt; 는 문자 &quot;X&quot;로 해석됩니다. 문자 클래스 외부에서이 시퀀스는 다른 의미를 갖습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="169951f4b6d1d7f1a4b31b9a082c85cf7bcb2136" translate="yes" xml:space="preserve">
          <source>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</source>
          <target state="translated">개념 본문에 나타나는 모든 최상위 상수 또는 유형은 개념이 구체적 유형에 성공적으로 일치 한 procs의 도트 연산자를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c975cb1e2ba6e75d38b206700dca326fdb354fc" translate="yes" xml:space="preserve">
          <source>All types for that &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value with the &lt;code&gt;not nil&lt;/code&gt; annotation:</source>
          <target state="translated">그 모든 종류의 &lt;code&gt;nil&lt;/code&gt; 유효한 값은 제외 주석 할 수있다 &lt;code&gt;nil&lt;/code&gt; 있는 유효한 값으로 &lt;code&gt;not nil&lt;/code&gt; 주석 :</target>
        </trans-unit>
        <trans-unit id="029f6357cfa5fa54f588a79c60e26072ee6dc04a" translate="yes" xml:space="preserve">
          <source>Also, you won't find raw &lt;code&gt;\n&lt;/code&gt; characters breaking the one answer per line format. Instead you will need to parse sequences in the form &lt;code&gt;\xHH&lt;/code&gt;, where &lt;em&gt;HH&lt;/em&gt; is a hexadecimal value (e.g. newlines generate the sequence &lt;code&gt;\x0A&lt;/code&gt;).</source>
          <target state="translated">또한 줄 당 하나의 답변을 깨는 원시 &lt;code&gt;\n&lt;/code&gt; 문자를 찾을 수 없습니다 . 대신 &lt;code&gt;\xHH&lt;/code&gt; 형식의 시퀀스를 구문 분석해야합니다 . 여기서 &lt;em&gt;HH&lt;/em&gt; 는 16 진수 값입니다 (예 : 개행은 &lt;code&gt;\x0A&lt;/code&gt; 시퀀스를 생성합니다 ).</target>
        </trans-unit>
        <trans-unit id="4521b364cb9ce19f839632eb99d99bb31f52f57b" translate="yes" xml:space="preserve">
          <source>Alternate version of the above.</source>
          <target state="translated">위의 대체 버전.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="24a6f9561b6fb31bcce22dd9eefb7cb23c8efb12" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;distinct&lt;/code&gt; type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called &lt;span id=&quot;bind-many_1&quot;&gt;bind many&lt;/span&gt; types.</source>
          <target state="translated">또는, &lt;code&gt;distinct&lt;/code&gt; 유형 수정자를 유형 클래스에 적용하여 유형 클래스와 일치하는 각 매개 변수가 다른 유형에 바인드 될 수 있습니다. 이러한 유형 클래스는 &lt;span id=&quot;bind-many_1&quot;&gt;여러&lt;/span&gt; 유형을 &lt;span id=&quot;bind-many_1&quot;&gt;바인드&lt;/span&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c5c9b8d75bae0a4e7883c1afe39fba029a2a402f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;em&gt;type&lt;/em&gt; operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</source>
          <target state="translated">대안 적으로, &lt;em&gt;입력&lt;/em&gt; 익명 또는 구별 타입 클래스를 사용하는 경우 운전자는 유사한 효과 proc 디렉토리 PARAMS 위에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="5b30b701e37924ad0c27b052555995c52f8814d1" translate="yes" xml:space="preserve">
          <source>Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.</source>
          <target state="translated">Nim은 다양한 코드 및 서식 스타일을 지원하지만 표준 라이브러리와 같은 특정 커뮤니티 노력이 적절한 경우 일관된 스타일 지침을 따라야한다는 것이 유리합니다. 이 개선 제안은 표준 라이브러리가 따라야하는 일련의 지침을 나열하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="e818f14ba9bbedb672b0a658dcc233bb37218e4d" translate="yes" xml:space="preserve">
          <source>Although the types use nanosecond time resolution, the underlying resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">유형은 나노초 시간 해상도를 사용하지만 &lt;code&gt;getTime()&lt;/code&gt; 에 사용되는 기본 해상도 는 플랫폼 및 백엔드에 따라 다릅니다 (JS는 밀리 초 정밀도로 제한됨).</target>
        </trans-unit>
        <trans-unit id="d3c0c9ff9b3e9a28a9649fc31261da1cd44edd57" translate="yes" xml:space="preserve">
          <source>Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.</source>
          <target state="translated">이 안내서에서 승인 한 것 이외의 문체 적 이유로 공백을 사용할 수는 있지만 그러한 관행에 신중하게 고려해야합니다. 모든 편집자가 코드 섹션의 자동 정렬을 지원하는 것은 아니며 긴 코드 섹션을 수동으로 다시 정렬하면 지루해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="614ddcbf931903423c230b8f0212d11059c5ec82" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ValueError&lt;/code&gt; exception will be thrown if no exception exists in the specified Future.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; 예외가 지정된 미래에 존재하지 않는 경우는 예외가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="ef24e3c1b8f7b901d42c45e46f29ceddb0745dc1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export&lt;/code&gt; statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 해당 클라이언트 모듈은 모듈의 종속성을 가져올 필요가 없습니다 문은 기호의 전달에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="73a35d34d5220f34295669a5c8b933dc1ceedeca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;untyped&lt;/code&gt; parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example &lt;em&gt;undeclared&lt;/em&gt; identifiers can be passed to the template:</source>
          <target state="translated">&lt;code&gt;untyped&lt;/code&gt; 이 지정되지 않은 매개 변수는 표현식이 템플릿으로 전달되기 전에 심볼 조회 및 유형 확인이 수행되지 않음을 의미합니다. 예를 들어 &lt;em&gt;선언되지 않은&lt;/em&gt; 식별자를 템플릿에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae34c49da483225476ede34178ee0a4cd7dbb4e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;if expression&lt;/em&gt; is almost like an if statement, but it is an expression. Example:</source>
          <target state="translated">&lt;em&gt;경우 표현은&lt;/em&gt; 거의 문 경우와 비슷하지만 표현이다. 예:</target>
        </trans-unit>
        <trans-unit id="6913655373469dbc7b3bf423a90b3116ade5a64c" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;identifier_1&quot;&gt;identifier&lt;/span&gt; is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the &lt;span id=&quot;scope_1&quot;&gt;scope&lt;/span&gt; of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</source>
          <target state="translated">&lt;span id=&quot;identifier_1&quot;&gt;식별자&lt;/span&gt; 등의 변수를 입력, 프로 시저 이름, 선언은 호출이 적용되는 동안 프로그램의 영역으로서 선언 상징 &lt;span id=&quot;scope_1&quot;&gt;범위&lt;/span&gt; 선언. 범위는 중첩 될 수 있습니다. 식별자의 의미는 과부하 해결 규칙이 달리 제안하지 않는 한 식별자가 선언되는 가장 작은 엔 클로징 범위에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="27d850be93dc755d2b65d8e923239958da9648c2" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used.</source>
          <target state="translated">&lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;체크 런타임 오류&lt;/span&gt; 검출이 보장되지 않고, 임의의 수의 연산 이후의 동작이 발생할 수있는 오차이다. &lt;span id=&quot;safe_1&quot;&gt;안전한&lt;/span&gt; 언어 기능 만 사용 하면 확인되지 않은 런타임 오류가 발생할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d086f48ed32221353a34e9e09e19fc50d2b08517" translate="yes" xml:space="preserve">
          <source>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</source>
          <target state="translated">오류가 발생하면 EOS (또는 소켓이 SSL 소켓 인 경우 ESSL) 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fad595a4ff6c034a05915aa77a9cf525f3217cd5" translate="yes" xml:space="preserve">
          <source>An EOS exception will be raised in the case of a socket error.</source>
          <target state="translated">소켓 오류가 발생하면 EOS 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3690729b1f993aa06abd14818e2a3ebd8ae6f4b1" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string; &lt;em&gt;` on Windows and `/&lt;/em&gt; on all other OSs.</source>
          <target state="translated">OS 종속적 후행 슬래시는 항상 리턴 된 문자열의 끝에 존재합니다. &lt;em&gt;Windows에서는`,&lt;/em&gt; 다른 모든 OS에서는 &lt;em&gt;`/&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb3c7dd4ccfc76b560ed8bea7cb91f6e590b5de7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">Nim에서 SQL 데이터베이스로 전달되는 SQL 문은 문자열로 모델링 될 수 있습니다. 그러나 문자열 템플릿을 사용하고 값을 채우는 것은 유명한 &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL 주입 공격에&lt;/span&gt; 취약합니다 .</target>
        </trans-unit>
        <trans-unit id="d6b5b2a52bea6b4b6255ab33c977d4534669e142" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="544692451d460228f4efd605a86e7c0dab8a35ee" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;countup(a, b, 1)&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;countup (a, b, 1)&lt;/em&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="936583901537efa6474af706c7cbc7258cf9502a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d96ad4829046669ed22f88ed72333f46e46f422a" translate="yes" xml:space="preserve">
          <source>An alias for copyNimTree().</source>
          <target state="translated">copyNimTree ()의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="2bb4f7d6ba1dc1ca472b28bc42274504e162f7f7" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;em&gt;DirSep&lt;/em&gt; if only one separator character exists. This is set to '/' on Windows systems where &lt;em&gt;DirSep&lt;/em&gt; is a backslash.</source>
          <target state="translated">경로 이름 구성 요소를 구분하기 위해 운영 체제에서 사용하는 대체 문자이거나 하나의 구분 문자 만있는 경우 &lt;em&gt;DirSep&lt;/em&gt; 와 동일 합니다. &lt;em&gt;DirSep&lt;/em&gt; 가 백 슬래시 인 Windows 시스템에서는 '/'로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b10f9786df0315b28bef975ab41acecfb36800af" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">아포스트로피 &lt;code&gt;'&lt;/code&gt; 다음에 0..9 범위 의 정수 &lt;code&gt;i&lt;/code&gt; 가 i 번째 매개 변수 &lt;em&gt;유형으로&lt;/em&gt; 대체됩니다 . 0 번째 위치는 결과 유형입니다. 이것은 타입을 C ++ 함수 템플릿으로 전달하는데 사용될 수 있습니다. &lt;code&gt;'&lt;/code&gt; 와 숫자 사이에 별표를 사용하여 유형의 기본 유형을 얻을 수 있습니다. (따라서 유형에서 &quot;별을 빼앗기고&quot; &lt;code&gt;T*&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 가됩니다 .) 두 개의 별을 사용하여 요소 유형 등의 요소 유형에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf4f417901eafdc569fc787f5454f9027073421" translate="yes" xml:space="preserve">
          <source>An array is a simple fixed length container. Each element in an array has the same type. The array's index type can be any ordinal type.</source>
          <target state="translated">배열은 간단한 고정 길이 컨테이너입니다. 배열의 각 요소는 동일한 유형을 갖습니다. 배열의 색인 유형은 서수 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d1d57ff3f35fb4d74599ef1b920f45e23521b6" translate="yes" xml:space="preserve">
          <source>An asynchronous procedure is marked using the &lt;code&gt;{.async.}&lt;/code&gt; pragma. When marking a procedure with the &lt;code&gt;{.async.}&lt;/code&gt; pragma it must have a &lt;code&gt;Future[T]&lt;/code&gt; return type or no return type at all. If you do not specify a return type then &lt;code&gt;Future[void]&lt;/code&gt; is assumed.</source>
          <target state="translated">비동기 프로시 저는 &lt;code&gt;{.async.}&lt;/code&gt; pragma를 사용하여 표시됩니다 . &lt;code&gt;{.async.}&lt;/code&gt; pragma 로 프로 시저를 표시 할 때 &lt;code&gt;Future[T]&lt;/code&gt; 리턴 유형이 있거나 리턴 유형이 전혀 없어야합니다. 리턴 유형을 지정하지 않으면 &lt;code&gt;Future[void]&lt;/code&gt; 로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="00cfb3b823850859ac087c9650335459fba3693e" translate="yes" xml:space="preserve">
          <source>An at symbol &lt;code&gt;@&lt;/code&gt; is replaced by the remaining arguments, separated by commas.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 기호 는 쉼표로 구분 된 나머지 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e0a7ceb8146505e07f088182b71243011ca4cc3a" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;discard&lt;/code&gt; statement is often used as a null statement:</source>
          <target state="translated">빈 &lt;code&gt;discard&lt;/code&gt; 명령문은 종종 널 명령문으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63b984f97355b1726a5cf0fa4b3612ccc2253bdc" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;raises&lt;/code&gt; list (&lt;code&gt;raises: []&lt;/code&gt;) means that no exception may be raised:</source>
          <target state="translated">비어있는 &lt;code&gt;raises&lt;/code&gt; 목록 ( &lt;code&gt;raises: []&lt;/code&gt; )은 예외가 발생하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03f5c98cab13364c0bdb7873271e1f3fbcb787f2" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to derefer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">빈 첨자 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용하여 참조를 연기 할 수 있으며, &lt;code&gt;addr&lt;/code&gt; 프로시 저는 항목의 주소를 리턴합니다. 주소는 항상 추적되지 않은 참조입니다. 따라서의 사용 &lt;code&gt;addr&lt;/code&gt; 입니다 &lt;em&gt;안전하지 않은&lt;/em&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="fd0163ff197f89984c82c49af75d8bfe8b3b9a66" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">열거 형은 &lt;code&gt;pure&lt;/code&gt; pragma 로 표시 될 수 있으므로 필드는 마지막 시도로만 쿼리되는 특수 모듈 특정 숨겨진 범위에 추가됩니다. 이 범위에는 모호하지 않은 기호 만 추가됩니다. 그러나 하나의 항상으로 작성 유형 자격을 통해 이들에 액세스 할 수 있습니다 &lt;code&gt;MyEnum.value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="390d5ff2cbaae78dc0fa4290b4e9610666cc8fdf" translate="yes" xml:space="preserve">
          <source>An enum type can be marked as &lt;code&gt;pure&lt;/code&gt;. Then access of its fields always requires full qualification.</source>
          <target state="translated">열거 형은 &lt;code&gt;pure&lt;/code&gt; 로 표시 될 수 있습니다 . 그런 다음 해당 필드에 액세스하려면 항상 완전한 자격이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="367c78270c2f231073a0357927182872afdf0f63" translate="yes" xml:space="preserve">
          <source>An enum which hold event types</source>
          <target state="translated">이벤트 유형을 보유하는 열거 형</target>
        </trans-unit>
        <trans-unit id="4dcfd8f767ff68c968ba90d84fa6dca78b2ac575" translate="yes" xml:space="preserve">
          <source>An enumeration's symbol can be qualified to avoid ambiguities: &lt;code&gt;Direction.south&lt;/code&gt;.</source>
          <target state="translated">열거의 심볼은 모호성을 피하기 위해 규정 될 수 있습니다 : &lt;code&gt;Direction.south&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83a58494419b1a3e524ebfb95e03913553034371" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;handleAccept&lt;/code&gt; follows:</source>
          <target state="translated">&lt;code&gt;handleAccept&lt;/code&gt; 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="993744896fbb24a8143d61db93a5b797f2af5f88" translate="yes" xml:space="preserve">
          <source>An explicit ordered enum can have &lt;em&gt;holes&lt;/em&gt;:</source>
          <target state="translated">명시 적 순서의 열거 형에는 &lt;em&gt;구멍&lt;/em&gt; 이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5f3c80df868038bd59209ddaecef0136b0eb492" translate="yes" xml:space="preserve">
          <source>An exported helper proc that parses the &quot;standard format specifiers&quot;, as specified by the grammar:</source>
          <target state="translated">문법으로 지정된 &quot;표준 형식 지정자&quot;를 구문 분석하는 내 보낸 도우미 프로 시저 :</target>
        </trans-unit>
        <trans-unit id="129cc9980afbc0b6d02dd90e59a7e2eac8eb8d2f" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;em&gt;l-value&lt;/em&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">발현 &lt;code&gt;b&lt;/code&gt; 발현에 할당 될 수 IFF에 &lt;code&gt;a&lt;/code&gt; 인 &lt;em&gt;L 값&lt;/em&gt; 과 &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; 보유하고있다. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d2a0ca1f92482471cb1498e046b1a61df5075bd" translate="yes" xml:space="preserve">
          <source>An expression like &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; is transformed into:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; 와 같은 표현식 은 {value : arg} {{z}}&quot; 로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf1e65690ce8b0321d174674e5faf95e0f45bd9" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called &lt;span id=&quot;constant-expressions_1&quot;&gt;constant expressions&lt;/span&gt;; they are never l-values.</source>
          <target state="translated">표현식은 값 또는 위치를 생성하는 계산을 지정합니다. 위치를 생성하는 표현식을 &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt; 라고 &lt;span id=&quot;lminusvalues_1&quot;&gt;합니다&lt;/span&gt; . l- 값은 상황에 따라 위치 또는 위치에 포함 된 값을 나타낼 수 있습니다. 정적으로 값을 결정할 수있는 &lt;span id=&quot;constant-expressions_1&quot;&gt;표현식을 상수 표현식&lt;/span&gt; 이라고 &lt;span id=&quot;constant-expressions_1&quot;&gt;합니다&lt;/span&gt; . 그것들은 결코 l- 값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1e306939f1b61ed5f05365a4a82b6e0e9f803e5d" translate="yes" xml:space="preserve">
          <source>An if expression always results in a value, so the &lt;code&gt;else&lt;/code&gt; part is required. &lt;code&gt;Elif&lt;/code&gt; parts are also allowed.</source>
          <target state="translated">if 식은 항상 값을 가지므로 &lt;code&gt;else&lt;/code&gt; 부분이 필요합니다. &lt;code&gt;Elif&lt;/code&gt; 부품도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="55f00c59e69693d5b27bf05aeea67c1b5656b713" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; are true.</source>
          <target state="translated">구현시 항상 컴파일시 부동 포인터 값을 평가할 수있는 최대 정밀도를 사용해야합니다. 이것은 &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; 와 같은 표현식이 참 임을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="4faf8ef86d99d8f87188a85418d2cafbed7c672a" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">쿼리 할 열이있는 정수입니다. 컴파일러 열의 경우 &lt;strong&gt;0&lt;/strong&gt; 에서 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="7140df7bbe5e3e07dff6576529cef23b438e6cf3" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be &lt;strong&gt;0&lt;/strong&gt; and the last in an 80 column terminal will be &lt;strong&gt;79&lt;/strong&gt;.</source>
          <target state="translated">쿼리 할 열이있는 정수입니다. 컴파일러 열의 경우 0에서 시작하므로 첫 번째 열은 &lt;strong&gt;0&lt;/strong&gt; 이고 80 열 터미널의 마지막 열은 &lt;strong&gt;79&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58c18cab7c4720f0e3aa95f69ca0b844006c41f0" translate="yes" xml:space="preserve">
          <source>An integer with the line you are going to query. For the compiler lines start at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">쿼리 할 줄이있는 정수입니다. 컴파일러 라인의 경우 &lt;strong&gt;1&lt;/strong&gt; 에서 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd63b4dca2c3b56a63f528ea8506804126dab43c" translate="yes" xml:space="preserve">
          <source>An iterator is similar to a procedure, except that it can be called in the context of a &lt;code&gt;for&lt;/code&gt; loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a &lt;code&gt;for&lt;/code&gt; loop plays the &lt;code&gt;yield&lt;/code&gt; statement in the called iterator. Whenever a &lt;code&gt;yield&lt;/code&gt; statement is reached the data is bound to the &lt;code&gt;for&lt;/code&gt; loop variables and control continues in the body of the &lt;code&gt;for&lt;/code&gt; loop. The iterator's local variables and execution state are automatically saved between calls. Example:</source>
          <target state="translated">반복자는 &lt;code&gt;for&lt;/code&gt; 루프 와 관련하여 호출 될 수 있다는 점을 제외하고 프로 시저와 유사합니다 . 반복자는 추상 유형에 대한 반복을 지정하는 방법을 제공합니다. &lt;code&gt;for&lt;/code&gt; 루프 실행의 주요 역할 은 호출 된 반복자에서 &lt;code&gt;yield&lt;/code&gt; 문을 재생 합니다. 마다 &lt;code&gt;yield&lt;/code&gt; 문이 바인딩되는 데이터 도달 &lt;code&gt;for&lt;/code&gt; 루프 제어 변수와의 체내에서 지속적 &lt;code&gt;for&lt;/code&gt; 루프. 반복자의 로컬 변수와 실행 상태는 호출간에 자동으로 저장됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="1f5ff3abd757e3cba00a39f18b56b5fb6446a8c0" translate="yes" xml:space="preserve">
          <source>An object type can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</source>
          <target state="translated">런타임 유형 식별에 사용되는 유형 필드가 생략되도록 &lt;code&gt;pure&lt;/code&gt; pragma 로 오브젝트 유형을 표시 할 수 있습니다 . 이것은 다른 컴파일 언어와의 바이너리 호환성을 위해 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="2e8278ca51d6d95aa64a5e6c057a546e2ca28c42" translate="yes" xml:space="preserve">
          <source>An object which holds descriptors to be checked for read/write status</source>
          <target state="translated">읽기 / 쓰기 상태를 검사 할 설명자를 보유하는 객체</target>
        </trans-unit>
        <trans-unit id="3274465cde86ef19fbd6e85a8dde25fac63bf653" translate="yes" xml:space="preserve">
          <source>An object which holds result for descriptor</source>
          <target state="translated">기술자의 결과를 보관 유지하는 객체</target>
        </trans-unit>
        <trans-unit id="e62ca354a533c308819dea987dbbf454b1323735" translate="yes" xml:space="preserve">
          <source>An object which holds user defined event</source>
          <target state="translated">사용자 정의 이벤트를 보유하는 객체</target>
        </trans-unit>
        <trans-unit id="004526c446f1ac6d78516b74ee9cfa40b5941993" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if reading from the</source>
          <target state="translated">옵션에서 시간 초과를 읽을 경우 밀리 초로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0cf6034a987ab54cdc28a91621a1407148ad61" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</source>
          <target state="translated">바이트를 건너 뛰는 데 지정된 시간보다 오래 걸리면 선택적 시간 초과가 밀리 초로 지정 될 수 있습니다. ETimeout 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1436ea667171f8c043927d94a1771aba02c31130" translate="yes" xml:space="preserve">
          <source>An optional type that stores its value and state separately in a boolean.</source>
          <target state="translated">값과 상태를 부울에 별도로 저장하는 선택적 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1492892ce7573ee3544c47d10217feac9a1ffe27" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the end of the input. No character is consumed. Same as &lt;code&gt;!.&lt;/code&gt;.</source>
          <target state="translated">앵커 : 입력 끝에서 일치합니다. 캐릭터가 소비되지 않습니다. &lt;code&gt;!.&lt;/code&gt; 와 동일합니다 . .</target>
        </trans-unit>
        <trans-unit id="28501d5ba1b7346ee45610593888631bf0f75364" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the start of the input. No character is consumed.</source>
          <target state="translated">앵커 : 입력 시작시 일치합니다. 캐릭터가 소비되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b80e8f8af7973d49e632e415ee520559b6880c" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match and so the compiler should reject it. Currently however this check is not implemented and instead the first matching file is used.</source>
          <target state="translated">그리고 &lt;code&gt;main&lt;/code&gt; 수입품 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;foo/x&lt;/code&gt; 를 수입합니다. 경우 &lt;code&gt;other&lt;/code&gt; 수입은 &lt;code&gt;x&lt;/code&gt; 다음 모두 &lt;code&gt;$lib/x.nim&lt;/code&gt; 및 &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; 일치하고, 그래서 컴파일러는 그것을 거부한다. 그러나 현재이 검사는 구현되지 않고 대신 첫 번째 일치 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="242f34bf16bfc5e83d5742e55f63b87c019f679a" translate="yes" xml:space="preserve">
          <source>And copy the executable somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;$PATH&lt;/code&gt; 어딘가에 실행 파일을 복사하십시오 .</target>
        </trans-unit>
        <trans-unit id="83dda4bc1c55dc87decca365a7ad42665d8106b1" translate="yes" xml:space="preserve">
          <source>And for a debug version compatible with GDB:</source>
          <target state="translated">그리고 GDB와 호환되는 디버그 버전의 경우 :</target>
        </trans-unit>
        <trans-unit id="4e8296500ed287ca2f86dd1c2fab187b68fe5d29" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;em&gt;E&lt;/em&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">그리고 술어 : 식 &lt;em&gt;E&lt;/em&gt; 가 앞의 텍스트와 일치하면 성공을 나타냅니다 . 그렇지 않으면 실패를 나타냅니다. 텍스트를 소비하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dd21179e471067255e31c8a35037ea42bc51b5d1" translate="yes" xml:space="preserve">
          <source>And the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529975d2ca1b9c8b1f9dc8715723302d776e3685" translate="yes" xml:space="preserve">
          <source>Annotating procs with raised exceptions</source>
          <target state="translated">예외 발생으로 주석 처리</target>
        </trans-unit>
        <trans-unit id="1372df72c3414caae306a6854fbd73da2739c232" translate="yes" xml:space="preserve">
          <source>Anonymous Procs</source>
          <target state="translated">익명 프로세스</target>
        </trans-unit>
        <trans-unit id="fc69ddcac99b9b9a8d29c74edd5dd97109c0f888" translate="yes" xml:space="preserve">
          <source>Another common example is this:</source>
          <target state="translated">또 다른 일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46de23dafaa5135d298c4e6932bfd58f0a55fcd3" translate="yes" xml:space="preserve">
          <source>Another way is to make Nim invoke a cross compiler toolchain:</source>
          <target state="translated">또 다른 방법은 Nim이 크로스 컴파일러 툴체인을 호출하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="220b3fd15cb7730c1f91330b6bd071c4acf9137b" translate="yes" xml:space="preserve">
          <source>Another way to branch is provided by the case statement. A case statement is a multi-branch:</source>
          <target state="translated">case 문에서 분기하는 또 다른 방법이 제공됩니다. 사례 진술은 다중 지점입니다.</target>
        </trans-unit>
        <trans-unit id="b109a7f72d501d6581c64b2e20010ee624b143d1" translate="yes" xml:space="preserve">
          <source>Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;em&gt;value&lt;/em&gt; to.</source>
          <target state="translated">또 다른 방법은없는 같은 수행 할 &lt;code&gt;when&lt;/code&gt; 각 필드 종류에 과부하 보조 시저에 적절한 코드를 따기의 작업을두고 전달하는 &lt;em&gt;값&lt;/em&gt; 으로한다.</target>
        </trans-unit>
        <trans-unit id="cdcc64fe4174864c656f8d5ecbd49e1c1178af4e" translate="yes" xml:space="preserve">
          <source>Another way to look at the method call syntax is that it provides the missing postfix notation.</source>
          <target state="translated">메소드 호출 구문을 보는 또 다른 방법은 누락 된 접미사 표기법을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a741689c8b0db1dc353a46642a34688e7e01c9fe" translate="yes" xml:space="preserve">
          <source>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">모든 유니 코드 문자 : UTF-8 문자가 앞에 있으면이를 소비하고 성공을 나타냅니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5778ef8422665afffa8cd59a1ebfe6af7a70d367" translate="yes" xml:space="preserve">
          <source>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</source>
          <target state="translated">모든 캐릭터 : 전방에 캐릭터가 있다면 그것을 소비하고 성공을 나타냅니다. 그렇지 않으면 (즉, 입력 끝에서) 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7358bbc6ca3777f85150f64affeb40b274702a17" translate="yes" xml:space="preserve">
          <source>Any comments which are preceded by a double-hash (##), are interpreted as documentation. Comments are parsed as RST (see &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;reference&lt;/a&gt;), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.</source>
          <target state="translated">이중 해시 (##)가 앞에 오는 주석은 문서로 해석됩니다. 주석은 RST (참조 &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;참조&lt;/a&gt; ) 로 구문 분석되어 Nim 모듈 작성자는 잘 문서화 된 코드만으로 다양한 형식의 문서를 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e820fd709a7f87728034af624c9132692282ae" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;em&gt;opr&lt;/em&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">모든 연산자는 ' &lt;em&gt;opr&lt;/em&gt; '표기법을 사용하여 일반 proc처럼 호출 할 수 있습니다 . (따라서 운영자는 둘 이상의 매개 변수를 가질 수 있습니다) :</target>
        </trans-unit>
        <trans-unit id="28a8d44708b00ee5f8ab5f8950f4590e672372e9" translate="yes" xml:space="preserve">
          <source>Any previously stored value will be overwritten.</source>
          <target state="translated">이전에 저장된 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="85cdc7b1f239ca6691d5ad4bd7ee32149be2368a" translate="yes" xml:space="preserve">
          <source>Any statements following the &lt;code&gt;defer&lt;/code&gt; in the current block will be considered to be in an implicit try block:</source>
          <target state="translated">현재 블록에서 &lt;code&gt;defer&lt;/code&gt; 이후의 모든 문장 은 암시 적 try 블록에있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f6cede9c40103cfeb38206a514d0e207b6286657" translate="yes" xml:space="preserve">
          <source>Any user defined destructors</source>
          <target state="translated">모든 사용자 정의 소멸자</target>
        </trans-unit>
        <trans-unit id="474bae604f6e9971bd49456c68cefe4610021141" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;spawn&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 및 &lt;code&gt;parallel&lt;/code&gt; 외에도 Nim은 잠금, 원자 내장 또는 조건 변수와 같은 모든 공통 저수준 동시성 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="562f1ef0862bc54a9d91c121544eee328c801e91" translate="yes" xml:space="preserve">
          <source>Apart from a few built-in keyword operators such as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, operators always consist of these characters: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; 과 같은 내장 키워드 연산자 외에도 연산자는 항상 다음 문자로 구성됩니다. &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe80b93d1b3cc277c929cdfd0838f7556135094" translate="yes" xml:space="preserve">
          <source>Apart from built-in operations like array indexing, memory allocation, etc. the &lt;code&gt;raise&lt;/code&gt; statement is the only way to raise an exception.</source>
          <target state="translated">배열 인덱싱, 메모리 할당 등과 같은 기본 제공 작업 외에도 &lt;code&gt;raise&lt;/code&gt; 문은 예외를 발생시키는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7dc1626458ca624671bbd7eb79e937465433fdf8" translate="yes" xml:space="preserve">
          <source>Apart from strings you can also encode lists of integers or characters:</source>
          <target state="translated">문자열 외에도 정수 또는 문자 목록을 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aafd7f63cf0cf31a35bff642569ecbe5c87f627c" translate="yes" xml:space="preserve">
          <source>Apart from the minimal syntactic sugar the language core does not need to know about tables.</source>
          <target state="translated">최소한의 구문 설탕 외에도 언어 핵심은 테이블에 대해 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="86d0496a927c4a27939c0fe3200738c8416afc23" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;x&lt;/em&gt; to string &lt;em&gt;s&lt;/em&gt; in place, applying quoting and escaping if &lt;em&gt;x&lt;/em&gt; is a string or char. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; for the escaping scheme. When &lt;em&gt;x&lt;/em&gt; is a string, characters in the range &lt;code&gt;{\128..\255}&lt;/code&gt; are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from &lt;code&gt;addEscapedChar&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 가 문자열 또는 char 이면 인용 부호를 적용하고 &lt;em&gt;x&lt;/em&gt; 를 문자열 &lt;em&gt;s&lt;/em&gt; 에 추가 합니다. 이스케이프 체계에 대해서는 &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; 를 참조하십시오 . 때 &lt;em&gt;x는&lt;/em&gt; 범위의 문자열 자 &lt;code&gt;{\128..\255}&lt;/code&gt; 이 멀티 바이트 UTF-8 문자 그대로 (이 동작은 다릅니다 그래서 탈출되지 않습니다 &lt;code&gt;addEscapedChar&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="646ba0c86d2da62ac809b41c7876c8d4d437f4fd" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt; in place</source>
          <target state="translated">추가 &lt;em&gt;예를&lt;/em&gt; 로 &lt;em&gt;(X)&lt;/em&gt; 대신에</target>
        </trans-unit>
        <trans-unit id="621c0cff6d7cb368d8e84f223d0bb258c1851898" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence. Requires copying of the sequence</source>
          <target state="translated">시퀀스의 끝에 요소 y를 추가합니다. 시퀀스 복사 필요</target>
        </trans-unit>
        <trans-unit id="4b93e2750d5e019c95354307daa55b9ae9ae1eb1" translate="yes" xml:space="preserve">
          <source>Appends url to url.</source>
          <target state="translated">url을 url에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8b39b7cf4b0a60e8defe6d54cb8868dcdb0f1e4b" translate="yes" xml:space="preserve">
          <source>Applies &lt;em&gt;op&lt;/em&gt; to every item in &lt;em&gt;s&lt;/em&gt; modifying it directly.</source>
          <target state="translated">적용 &lt;em&gt;영업 이익&lt;/em&gt; 의 모든 항목에 &lt;em&gt;의&lt;/em&gt; 직접 수정.</target>
        </trans-unit>
        <trans-unit id="47c68a697222d8231db69fecdc76aa3f8118fca0" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option</source>
          <target state="translated">이 옵션의 값에 콜백을 적용합니다</target>
        </trans-unit>
        <trans-unit id="1f6c6510cdda5cd1b191679d2ebcc3574091831b" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned</source>
          <target state="translated">이 옵션의 값에 콜백을 적용하고 새 값을 포함하는 옵션을 반환합니다. 이 옵션이 None이면 None이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4405334856a221170be55f8b9f5688d6a0be9c57" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned. Similar to &lt;code&gt;map&lt;/code&gt;, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (including A = B) to be chained together.</source>
          <target state="translated">이 옵션의 값에 콜백을 적용하고 새 값을 포함하는 옵션을 반환합니다. 이 옵션이 None이면 None이 반환됩니다. 콜백이 원시 값이 아닌 옵션을 반환한다는 차이점이있는 &lt;code&gt;map&lt;/code&gt; 과 유사 합니다. 이를 통해 &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (A = B 포함) 서명을 가진 여러 개의 프록을 함께 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="465dd40623dd93f42a5f03dcd0c6972a66643b81" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option. If the callback returns &lt;em&gt;true&lt;/em&gt;, the option is returned as a Some. If it returns false, it is returned as a None.</source>
          <target state="translated">이 옵션의 값에 콜백을 적용합니다. 콜백이 &lt;em&gt;true를&lt;/em&gt; 반환 하면 옵션이 Some로 반환됩니다. false를 반환하면 None으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">인수는 공백 또는 탭인 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="401bb179f3db6b973c284e019e2540619d382218" translate="yes" xml:space="preserve">
          <source>Arguments that are passed to a &lt;code&gt;varargs&lt;/code&gt; parameter are wrapped in an array constructor expression. This is why &lt;code&gt;debug&lt;/code&gt; iterates over all of &lt;code&gt;n&lt;/code&gt;'s children.</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; 매개 변수에 전달 된 인수 는 배열 생성자 식으로 래핑됩니다. 이것이 &lt;code&gt;debug&lt;/code&gt; 가 &lt;code&gt;n&lt;/code&gt; 의 모든 하위 항목을 반복하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="52bae2349fbad4ef35978d796cfe4b7d32461d9e" translate="yes" xml:space="preserve">
          <source>Array access operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">배열 액세스 연산자 &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935c34e59be520dab8667587be24775c6b59c8e5" translate="yes" xml:space="preserve">
          <source>Array and sequence types</source>
          <target state="translated">배열 및 시퀀스 유형</target>
        </trans-unit>
        <trans-unit id="b66b4ebd826229d404911b2c9ca9b59007c74879" translate="yes" xml:space="preserve">
          <source>Array with no bounds checking</source>
          <target state="translated">경계 검사가없는 배열</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7c78840740ada4caee391a3c7d72b96b3524a2c8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertable to this type.</source>
          <target state="translated">배열은 동종 유형이므로 배열의 각 요소는 동일한 유형을 갖습니다. 배열은 항상 컴파일 타임에 지정된 고정 길이를 갖습니다 (개방형 배열 제외). 서수 유형별로 색인을 생성 할 수 있습니다. 매개 변수 &lt;code&gt;A&lt;/code&gt; 는 &lt;em&gt;개방형 배열&lt;/em&gt; 일 수 있으며 ,이 경우 0에서 &lt;code&gt;len(A)-1&lt;/code&gt; 까지의 정수로 색인화됩니다 . 배열 표현식은 배열 생성자 &lt;code&gt;[]&lt;/code&gt; 로 구성 될 수 있습니다 . 이 배열 표현식의 요소 유형은 첫 번째 요소의 유형에서 유추됩니다. 다른 모든 요소는이 유형으로 암시 적으로 변환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="07316b5238311cac8e4fe1961ee02c15801cb68e" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">배열은 항상 바운드 검사됩니다 (컴파일 타임 또는 런타임시). pragma를 통해 또는 &lt;code&gt;--boundChecks:off&lt;/code&gt; 명령 행 스위치로 컴파일러를 호출하여 이러한 검사를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f5ec03ff46845d078f8cf64b1238f79972295a5" translate="yes" xml:space="preserve">
          <source>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</source>
          <target state="translated">배열은 다른 Nim 유형과 마찬가지로 값 유형입니다. 할당 연산자는 전체 배열 내용을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="025a9e98dcb0da2dd59c51da809f12fce4980b2a" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed using &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 를 사용하여 배열을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c735544485e105956e388f5a452d2502051ca6e1" translate="yes" xml:space="preserve">
          <source>Artifact being compiled.</source>
          <target state="translated">아티팩트가 컴파일되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2681d14f693853cb31e8a490d26bf55ce9311d0e" translate="yes" xml:space="preserve">
          <source>As a regular expression &lt;code&gt;\[.*\]&lt;/code&gt; matches the longest possible text between &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;. As a PEG it never matches anything, because a PEG is deterministic: &lt;code&gt;.*&lt;/code&gt; consumes the rest of the input, so &lt;code&gt;\]&lt;/code&gt; never matches. As a PEG this needs to be written as: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (or &lt;code&gt;\[ @ \]&lt;/code&gt;).</source>
          <target state="translated">정규식으로 &lt;code&gt;\[.*\]&lt;/code&gt; 는 &lt;code&gt;'['&lt;/code&gt; 와 &lt;code&gt;']'&lt;/code&gt; 사이에서 가능한 가장 긴 텍스트와 일치합니다 . PEG는 결정론 적이므로 PEG와는 전혀 일치하지 않습니다 &lt;code&gt;.*&lt;/code&gt; 는 나머지 입력을 소비하므로 &lt;code&gt;\]&lt;/code&gt; 는 절대 일치하지 않습니다. PEG는 &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (또는 &lt;code&gt;\[ @ \]&lt;/code&gt; )로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d98662c0a3a8c4fd899d63977fd61a1ce489676" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">최적화 된 함수 / 내재를 사용한 결과 입력이 유효하지 않은 경우 일부 함수는 정의되지 않은 결과를 반환 할 수 있습니다. &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; 플래그를 사용하여 모든 입력에 대해 예측 가능한 동작을 강제 실행하여 약간의 성능 저하를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1664c8e0b3003ab199f6ca491156febd8a7827ee" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</source>
          <target state="translated">경험상 표현식 내 들여 쓰기는 연산자, 열린 괄호 및 쉼표 뒤에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bbf2a9820bf41bcc3ae860ff3066a54791d55a8" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a [parenthetical function call](./macros.html#calls-expressions-call-with) with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">참고로 접두사 형태로 접두사 연산자를 사용하도록 선택하면 AST 는 다음과 같이 &lt;code&gt;nnkAccQuoted&lt;/code&gt; 와 함께 [괄호 함수 호출] (./ macros.html # calls-expressions-call-with)로 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="15211f47465417179a8c67c3321dc2d1d401fb39" translate="yes" xml:space="preserve">
          <source>As a special more convenient notation, proc expressions involved in procedure calls can use the &lt;code&gt;do&lt;/code&gt; keyword:</source>
          <target state="translated">보다 편리한 특수 표기법으로 프로 시저 호출과 관련된 proc 표현식은 &lt;code&gt;do&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce683dd181064064b72fd86d9d3e2b66acc2d7ce" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backwards compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">&lt;code&gt;importcpp&lt;/code&gt; pragma 의 이전 버전과의 호환성을 유지하기위한 특별한 규칙으로 , 특별한 패턴 문자 ( &lt;code&gt;# ' @&lt;/code&gt; 중 하나)가 전혀 없으면 C ++의 점 또는 화살표 표기법이 가정되므로 위의 예제는 다음과 같이 작성할 수 있습니다. :</target>
        </trans-unit>
        <trans-unit id="afa79fbae0eabebb420b9fe3f09c01088cf66351" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;'+'&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">특별한 규칙으로, &lt;code&gt;decodePlus&lt;/code&gt; 값 이 true 인 경우 &lt;code&gt;'+'&lt;/code&gt; 문자는 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1b120a7d9f07026a29d56a412d87eb19ed8fa37b" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;'+'&lt;/code&gt; instead of &lt;code&gt;'%20'&lt;/code&gt;.</source>
          <target state="translated">특별한 규칙으로 &lt;code&gt;usePlus&lt;/code&gt; 값 이 true 인 경우 공백은 &lt;code&gt;'%20'&lt;/code&gt; 대신 &lt;code&gt;'+'&lt;/code&gt; 로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="babff93920d51965108f37a93de33ae42b21d0fb" translate="yes" xml:space="preserve">
          <source>As a special semantic extension, an expression in an &lt;code&gt;of&lt;/code&gt; branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</source>
          <target state="translated">특별한 의미 확장 같이,의 표현식 &lt;code&gt;of&lt;/code&gt; 경우 문 지점 세트 또는 배열 생성자로 평가 할 수있다; 그런 다음 세트 또는 배열은 해당 요소의 목록으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d6a828142c8108ac0deb4cc6c8484c64faae27" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">특수한 의미 규칙으로서 내장 된 &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; 는 부작용이없는 것으로 가장하여 &lt;code&gt;noSideEffect&lt;/code&gt; 로 표시된 루틴을 디버깅하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71489e93932a05f2ea411285eaceb3bbe24614d1" translate="yes" xml:space="preserve">
          <source>As a syntactical extension &lt;code&gt;object&lt;/code&gt; types can be anonymous if declared in a type section via the &lt;code&gt;ref object&lt;/code&gt; or &lt;code&gt;ptr object&lt;/code&gt; notations. This feature is useful if an object should only gain reference semantics:</source>
          <target state="translated">&lt;code&gt;ref object&lt;/code&gt; 또는 &lt;code&gt;ptr object&lt;/code&gt; 표기법을 통해 유형 섹션에서 선언 된 경우 구문 확장 &lt;code&gt;object&lt;/code&gt; 유형은 익명 일 수 있습니다 . 이 기능은 객체가 참조 의미 만 가져야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7859c8bf7a7bf8df21005d62f29109f1c4a9707d" translate="yes" xml:space="preserve">
          <source>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">최상위 수준 진술로, 실험용 pragma는 활성화 된 나머지 모듈에 대해 기능을 활성화합니다. 이는 모듈 범위를 넘는 매크로 및 일반 인스턴스화에 문제가 있습니다. 현재 이러한 사용법은 &lt;code&gt;.push/pop&lt;/code&gt; 환경에 배치해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1cc9ba3f444ef5f2a70c370287d23a7b3c9d81c8" translate="yes" xml:space="preserve">
          <source>As an example,</source>
          <target state="translated">예로서,</target>
        </trans-unit>
        <trans-unit id="4faf2cad17e66616bc46eb370913033cba7d7ffe" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, C's macros with parameters are mapped to Nim's templates. This mapping is the best one can do, but it is of course not accurate: Nim's templates operate on syntax trees whereas C's macros work on the token level. c2nim cannot translate any macro that contains the &lt;code&gt;##&lt;/code&gt; token concatenation operator.</source>
          <target state="translated">예제에서 볼 수 있듯이 매개 변수가있는 C의 매크로는 Nim의 템플릿에 매핑됩니다. 이 매핑은 최선의 방법이지만, 정확하지는 않습니다. Nim의 템플릿은 구문 트리에서 작동하지만 C의 매크로는 토큰 수준에서 작동합니다. c2nim은 &lt;code&gt;##&lt;/code&gt; 토큰 연결 연산자 를 포함하는 매크로를 번역 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="033710d5a2d1054844b9448ca63a783fde847ed0" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</source>
          <target state="translated">예제에서 볼 수 있듯이 튜플을 사용하여 필드의 서수 값과 문자열 값을 모두 지정할 수 있습니다. 그들 중 하나만 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33db679c8421cd1a5bcfed816339b58d55a90cf0" translate="yes" xml:space="preserve">
          <source>As can be seen from the examples, strings are matched verbatim except for substrings starting with &lt;code&gt;$&lt;/code&gt;. These constructions are available:</source>
          <target state="translated">예제에서 볼 수 있듯이 문자열은 &lt;code&gt;$&lt;/code&gt; 로 시작하는 하위 문자열을 제외하고는 그대로 사용됩니다 . 다음과 같은 구성이 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="3690ed0de51a088f748c4a5d9756e00f903b6456" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, base methods have to be annotated with the &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; pragma. The &lt;code&gt;base&lt;/code&gt; pragma also acts as a reminder for the programmer that a base method &lt;code&gt;m&lt;/code&gt; is used as the foundation to determine all the effects that a call to &lt;code&gt;m&lt;/code&gt; might cause.</source>
          <target state="translated">예제에서 볼 수 있듯이 기본 메소드에는 &lt;span id=&quot;base_1&quot;&gt;기본&lt;/span&gt; pragma 가 주석으로 표시되어야합니다 . &lt;code&gt;base&lt;/code&gt; 프라그는베이스 메소드 것을 프로그래머 알림 역할 &lt;code&gt;m&lt;/code&gt; 은 호출하는 모든 효과를 결정하는 기초로 사용되는 &lt;code&gt;m&lt;/code&gt; 이 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="a5a364bd18b5eaef7b5722d6cd78c85c92bfa5dd" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;) and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">프로덕션에서 볼 수 있듯이 수치 상수에는 가독성을 위해 밑줄이 포함될 수 있습니다. 정수 및 부동 소수점 리터럴은 10 진수 (접두사 없음), 이진 (접두사 &lt;code&gt;0b&lt;/code&gt; ), 8 진수 (접두사 &lt;code&gt;0o&lt;/code&gt; ) 및 16 진수 (접두사 &lt;code&gt;0x&lt;/code&gt; ) 표기법으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad921df2b5a3cd443f8e5461c7a9ccced2c050" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">예제에서 알 수 있듯이 객체 계층 구조의 장점은 서로 다른 객체 유형간에 캐스팅이 필요하지 않다는 것입니다. 그러나 유효하지 않은 개체 필드에 액세스하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86acee0719e4df42b833d89f9ce00671880b3bee" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">예제에서 볼 수 있듯이 개체 계층 구조의 장점은 다른 개체 유형 간의 변환이 필요하지 않다는 것입니다. 그러나 유효하지 않은 개체 필드에 액세스하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8bd2dc16961a30c8b20a5aa5ef6562993b9d9ea9" translate="yes" xml:space="preserve">
          <source>As case statements perform compile-time exhaustiveness checks, the value in every &lt;code&gt;of&lt;/code&gt; branch must be known at compile time. This fact is also exploited to generate more performant code.</source>
          <target state="translated">case 문은 컴파일 시간, 포괄 성 검사를 수행 할 때, 모든의 값 &lt;code&gt;of&lt;/code&gt; 지점은 컴파일시에 알려 져야한다. 이 사실은 또한 더 성능이 좋은 코드를 생성하기 위해 활용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3cf4fdd8a46537cb17ba2fc74bca88aa30a4384" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">일반적으로이 proc은 인덱스 파일을 문서와 API의 두 범주로 나눕니다. API 인덱스는 모두 하나의 큰 정렬 인덱스로 결합되어 최종 인덱스의 대부분을 만듭니다. 많은 심볼이 다른 모듈에 표시되므로 API 문서에 유용합니다. 반면, 문서 색인은 본질적으로 목차와 몇 가지 특수 마커입니다. 이 문서는 인덱스 파일에서 심볼의 순서와 계층을 유지하려고하는 별도의 섹션으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="e35fce15f7b6d0e8ddfe4a222398b9462fecc9a2" translate="yes" xml:space="preserve">
          <source>As in generics symbol binding can be influenced via &lt;code&gt;mixin&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt; statements.</source>
          <target state="translated">제네릭에서와 같이 심볼 바인딩은 &lt;code&gt;mixin&lt;/code&gt; 또는 &lt;code&gt;bind&lt;/code&gt; 문 을 통해 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0887bf802c49a565d93917f60c9350172010518c" translate="yes" xml:space="preserve">
          <source>As it can be seen, for an &lt;code&gt;of&lt;/code&gt; branch a comma separated list of values is also allowed.</source>
          <target state="translated">이 알 수있는 바와 같이,에 대한 &lt;code&gt;of&lt;/code&gt; 분기 쉼표 값리스트는 허용 분리 하였다.</target>
        </trans-unit>
        <trans-unit id="026e19060b7027adb0d7fdc31274d77b9a547e42" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete &lt;code&gt;sizeof(T)&lt;/code&gt; or &quot;runtime type information&quot; for &lt;code&gt;T&lt;/code&gt; is not available.</source>
          <target state="translated">한 타입으로 &lt;code&gt;T&lt;/code&gt; 가 불완전 &lt;code&gt;sizeof(T)&lt;/code&gt; 또는 대한 &quot;런타임 타입 정보&quot; &lt;code&gt;T&lt;/code&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dca63b7a6f1fd2e2ca6e65f781d803b65614773" translate="yes" xml:space="preserve">
          <source>As long as you don't use the threadvar emulation Nim uses native thread variables, of which you get a fresh version whenever you create a thread. You can then attach a GC to this thread via</source>
          <target state="translated">threadvar 에뮬레이션을 사용하지 않는 한 Nim은 네이티브 스레드 변수를 사용하며 스레드를 만들 때마다 새로운 버전을 얻습니다. 그런 다음 GC를이 스레드에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26a74fa3cef27390dd0524bd6f48c70bfa5b9b01" translate="yes" xml:space="preserve">
          <source>As many &lt;code&gt;nnkIdent&lt;/code&gt; appear as there are pragmas between &lt;code&gt;{..}&lt;/code&gt;. Note that the declaration of new pragmas is essentially the same:</source>
          <target state="translated">&lt;code&gt;{..}&lt;/code&gt; 사이에 pragma가있는 것처럼 많은 &lt;code&gt;nnkIdent&lt;/code&gt; 가 나타납니다 . 새로운 pragma의 선언은 본질적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="45b0ed81197cf305d45603349a135b9f85fd6ed7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, the built-in &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) operator turns any basic type into a string, which you can then print to the console using the &lt;code&gt;echo&lt;/code&gt; proc. However, advanced types, and your own custom types, won't work with the &lt;code&gt;$&lt;/code&gt; operator until you define it for them. Sometimes you just want to debug the current value of a complex type without having to write its &lt;code&gt;$&lt;/code&gt; operator. You can use then the &lt;a href=&quot;system#repr&quot;&gt;repr&lt;/a&gt; proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;repr&lt;/code&gt; outputs:</source>
          <target state="translated">앞에서 언급했듯이 내장 &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) 연산자는 기본 유형을 문자열로 변환 한 다음 &lt;code&gt;echo&lt;/code&gt; proc를 사용하여 콘솔에 인쇄 할 수 있습니다 . 그러나 고급 유형 및 사용자 정의 유형은 사용자가 정의 할 때까지 &lt;code&gt;$&lt;/code&gt; 연산자 와 함께 작동하지 않습니다 . 때로는 &lt;code&gt;$&lt;/code&gt; 연산자 를 쓰지 않고도 복잡한 유형의 현재 값을 디버깅하려고합니다 . 그런 다음 &lt;a href=&quot;system#repr&quot;&gt;repr&lt;/a&gt; proc을 사용 하여 모든 유형 및 사이클이있는 복잡한 데이터 그래프에서도 작동합니다. 다음 예는 기본 유형의 경우에도 &lt;code&gt;$&lt;/code&gt; 와 &lt;code&gt;repr&lt;/code&gt; 출력 간에 차이가 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5c0e6c3f6dc802ee854147fa74a0509740327d59" translate="yes" xml:space="preserve">
          <source>As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an &lt;em&gt;expr&lt;/em&gt; template.</source>
          <target state="translated">위의 예에서 볼 수 있듯이, 사례 표현식은 부작용을 유발할 수도 있습니다. 브랜치에 대해 여러 문장이 주어지면 Nim은 &lt;em&gt;expr&lt;/em&gt; 템플릿 에서와 같이 마지막 표현식을 결과 값으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="439f48dfdc54a1d1cb2592abb741204d4e9306e5" translate="yes" xml:space="preserve">
          <source>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the &lt;em&gt;any&lt;/em&gt; type class and thus they will match anything without discrimination.</source>
          <target state="translated">앞의 예에서 볼 수 있듯이, 그러한 인스턴스화에서는 일반 유형의 모든 유형 매개 변수를 제공 할 필요가 없습니다. 누락 된 유형 은 &lt;em&gt;모든&lt;/em&gt; 유형 클래스와 동등한 것으로 간주 되므로 차별없이 모든 항목과 일치하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b6e6a7e96d415104630cd8f0ead0c140e77a0902" translate="yes" xml:space="preserve">
          <source>As seen in the previous examples, you can refer to generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; just by their short name. Much like the regular generic types, the concept will be automatically instantiated with the bind once auto type in the place of each missing generic param.</source>
          <target state="translated">이전 예에서 볼 수 있듯이 &lt;em&gt;Enumerable [T]&lt;/em&gt; 와 같은 일반적인 개념을 짧은 이름으로 만 참조 할 수 있습니다 . 일반 제네릭 형식과 마찬가지로 개념은 누락 된 각 제네릭 매개 변수 대신 한 번만 바인드 자동 형식으로 자동으로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c1fc890399facee98adf935d7347503148926c" translate="yes" xml:space="preserve">
          <source>As such it supports a resolution of nanoseconds internally; however the API uses microseconds for convenience.</source>
          <target state="translated">따라서 내부적으로 나노초의 해상도를 지원합니다. 그러나 API는 편의상 마이크로 초를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01367ae653af83b7f5aec2955cfd950745102be9" translate="yes" xml:space="preserve">
          <source>As such, a check to see if the deque is empty is needed before any access, unless your program logic guarantees it indirectly.</source>
          <target state="translated">따라서 프로그램 로직이 간접적으로 보증하지 않는 한 액세스 전에 deque가 비어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="286afc9752bec98ed25f43fb3fd09c91c5151ede" translate="yes" xml:space="preserve">
          <source>As the above example shows, Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">위의 예에서 볼 수 있듯이 Nim은 &lt;em&gt;get-properties&lt;/em&gt; 가 필요하지 않습니다 . &lt;em&gt;메소드 호출 구문으로 호출&lt;/em&gt; 되는 일반 get-procedures도 동일한 결과를 얻습니다. 그러나 값을 설정하는 것은 다릅니다. 이를 위해 특별한 세터 구문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e739d8d09978b2dcb0c312361958c802f83a064a" translate="yes" xml:space="preserve">
          <source>As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">예제에서 알 수 있듯이 다중 메서드 호출은 모호 할 수 없습니다. 해상도가 왼쪽에서 오른쪽으로 작동하기 때문에 충돌 1이 충돌 1보다 선호됩니다. 따라서 &lt;code&gt;Unit, Thing&lt;/code&gt; 은 &lt;code&gt;Thing, Unit&lt;/code&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb5ab0367cdd1ab709d3f90ffd6f79cf740c8bc" translate="yes" xml:space="preserve">
          <source>As the example shows &lt;code&gt;computedGoto&lt;/code&gt; is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</source>
          <target state="translated">예제에서 &lt;code&gt;computedGoto&lt;/code&gt; 이 계산 된 Goto 는 대부분 통역사에게 유용합니다. 기본 백엔드 (C 컴파일러)가 계산 된 goto 확장을 지원하지 않으면 pragma는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6410949c68317244c63b45dcd8f86123a06792" translate="yes" xml:space="preserve">
          <source>As the example shows, passing arguments to a filter can be done just like an ordinary procedure call with named or positional arguments. The available parameters depend on the invoked filter. Before version 0.12.0 of the language &lt;code&gt;#!&lt;/code&gt; was used instead of &lt;code&gt;#?&lt;/code&gt;.</source>
          <target state="translated">예제에서 알 수 있듯이 명명 된 또는 위치 인수를 사용하는 일반 프로 시저 호출처럼 필터에 인수를 전달할 수 있습니다. 사용 가능한 매개 변수는 호출 된 필터에 따라 다릅니다. 언어 버전 0.12.0 이전 &lt;code&gt;#!&lt;/code&gt; &lt;code&gt;#?&lt;/code&gt; 대신에 사용 되었습니까? .</target>
        </trans-unit>
        <trans-unit id="27d5a0e7057a8c33abd1db459e64ad340a213114" translate="yes" xml:space="preserve">
          <source>As the regular expressions supported by this module are enormous, the reader is referred to &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; for the full documentation of Perl's regular expressions.</source>
          <target state="translated">이 모듈이 지원하는 정규 표현식은 엄청 나기 때문에, Perl의 정규 표현식에 대한 전체 설명서는 &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="868dd43083390b7b1e29d7736d8260c51c9f2330" translate="yes" xml:space="preserve">
          <source>As their name suggests, static parameters must be known at compile-time:</source>
          <target state="translated">이름에서 알 수 있듯이 정적 매개 변수는 컴파일 타임에 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="62dcfc00fb0387dbffe758f0f4162e7a2adedb56" translate="yes" xml:space="preserve">
          <source>As usual &lt;code&gt;locks&lt;/code&gt; is an inferred effect and there is a subtype relation: &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; is a subtype of &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N).</source>
          <target state="translated">일반적인 &lt;code&gt;locks&lt;/code&gt; 은 유추 된 효과이며 하위 유형 관계가 있습니다. &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; 은 &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N) 의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bb6749711a6c6662b3a9fd807816e9e50ff52d" translate="yes" xml:space="preserve">
          <source>Assembler statement</source>
          <target state="translated">어셈블러 문</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="d726d517f001352072c6361a864be12f97f89db4" translate="yes" xml:space="preserve">
          <source>Assignment compatibility</source>
          <target state="translated">할당 호환성</target>
        </trans-unit>
        <trans-unit id="d9203ef0427904fd0cb4f5281674fd37cff746c1" translate="yes" xml:space="preserve">
          <source>Assignments are not special, the left-hand-side expression is evaluated before the right-hand side:</source>
          <target state="translated">할당은 특별하지 않으며 왼쪽 식은 오른쪽보다 먼저 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1091ff5f3536a87992e1a98e7fdf3572d7d495bf" translate="yes" xml:space="preserve">
          <source>Associate application-defined &lt;code&gt;data&lt;/code&gt; with descriptor &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">애플리케이션 정의 &lt;code&gt;data&lt;/code&gt; 를 디스크립터 &lt;code&gt;fd&lt;/code&gt; 와 연관 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="c10e87299448214997c9ba36a197edc020ad8d7c" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; has already been called.</source>
          <target state="translated">&lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; 가 이미 호출되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="464eb5858db553f9a4e084882b2d692e14f18a75" translate="yes" xml:space="preserve">
          <source>Async IO in Nim consists of multiple layers (from highest to lowest):</source>
          <target state="translated">Nim의 비동기 IO는 여러 계층으로 구성됩니다 (최고에서 최하로).</target>
        </trans-unit>
        <trans-unit id="d57562f32a2344e4a892e8ad77de461a0dddac00" translate="yes" xml:space="preserve">
          <source>Async alternative to TFTPClient.</source>
          <target state="translated">TFTPClient의 비동기 대안.</target>
        </trans-unit>
        <trans-unit id="61a0af2d907e2fd6001d764ad03dc8d1c0e711f3" translate="yes" xml:space="preserve">
          <source>Async await</source>
          <target state="translated">비동기 대기</target>
        </trans-unit>
        <trans-unit id="bb9065007b1394a4c890c8c730359a31cd3d4af2" translate="yes" xml:space="preserve">
          <source>Async version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="48e12dfeb54ee671e650066950d5a652045b9307" translate="yes" xml:space="preserve">
          <source>AsyncDispatch</source>
          <target state="translated">AsyncDispatch</target>
        </trans-unit>
        <trans-unit id="8b371c51c3d43e683cda1ca13b2b61e13b7f6e7b" translate="yes" xml:space="preserve">
          <source>Asynchronous IO in Nim</source>
          <target state="translated">Nim의 비동기 IO</target>
        </trans-unit>
        <trans-unit id="7b9ef39877db01dd17657705a2bbb4a6bc49d720" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures</source>
          <target state="translated">비동기 절차</target>
        </trans-unit>
        <trans-unit id="c80b1fc2540985a4b46e1a0759e789f85aac96b9" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.</source>
          <target state="translated">비동기 프로시 저는 콜백 작업의 어려움을 제거합니다. 동기 코드를 작성할 때와 같은 방식으로 비동기 코드를 작성할 수 있도록하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b4324fe839ee2fc80392c528dbb2288500cc3cc5" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets</source>
          <target state="translated">비동기 소켓</target>
        </trans-unit>
        <trans-unit id="04fc05d16ff1681dbd084361e286ad3b082b3c13" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets are supported, however a better alternative is to use the &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; module.</source>
          <target state="translated">비동기 소켓이 지원되지만 &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; 모듈 을 사용하는 것이 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6c54cd214970569c34b0894bafdff80b326240d3" translate="yes" xml:space="preserve">
          <source>At runtime the dynamic library is searched for (in this order):</source>
          <target state="translated">런타임시 동적 라이브러리가 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0afa779399055030a34271b80bf03107242a5a" translate="yes" xml:space="preserve">
          <source>At the moment idetools support is still in development so the test suite is not integrated with the main test suite and you have to run it manually. First you have to compile the tester:</source>
          <target state="translated">현재 idetools 지원은 아직 개발 중이므로 테스트 스위트는 기본 테스트 스위트와 통합되지 않으므로 수동으로 실행해야합니다. 먼저 테스터를 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f92987b2f51905d6ac8ecf565a309b7358bafb43" translate="yes" xml:space="preserve">
          <source>At this time only &lt;em&gt;fastLog2&lt;/em&gt;, &lt;em&gt;firstSetBit, `countLeadingZeroBits&lt;/em&gt;, &lt;em&gt;countTrailingZeroBits&lt;/em&gt; may return undefined and/or platform dependant value if given invalid input.</source>
          <target state="translated">현재 &lt;em&gt;fastLog2&lt;/em&gt; , &lt;em&gt;firstSetBit,`countLeadingZeroBits&lt;/em&gt; , &lt;em&gt;countTrailingZeroBits 만&lt;/em&gt; 유효하지 않은 입력이 주어지면 정의되지 않은 및 / 또는 플랫폼 종속 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc088b4a46ed03929326ec3129e2350a99f0a990" translate="yes" xml:space="preserve">
          <source>Auto type</source>
          <target state="translated">자동 타입</target>
        </trans-unit>
        <trans-unit id="9e0bd780b5a4993d6aec3f619069ec9a81419d34" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing</source>
          <target state="translated">자동 역 참조</target>
        </trans-unit>
        <trans-unit id="b34f3f41021aba6582ca800065938665aaa25537" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing is also performed for the first argument of a routine call. But currently this feature has to be only enabled via &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt;:</source>
          <target state="translated">루틴 호출의 첫 번째 인수에 대해서도 자동 역 참조가 수행됩니다. 그러나 현재이 기능은 &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt; 를 통해서만 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f2f8a2fddb2e537990a2864cb34d8eee2d1446d" translate="yes" xml:space="preserve">
          <source>Automatic self insertions</source>
          <target state="translated">자동 자기 삽입</target>
        </trans-unit>
        <trans-unit id="d489cd84b7c72c977a3c1f79e61d852ca4f5fd46" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: See &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt; for further details. Arithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.</source>
          <target state="translated">부동 소수점 유형이 다른 표현식에서 자동 유형 변환이 수행됩니다. 자세한 내용은 &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;변환 가능한 관계&lt;/a&gt; 를 참조 하십시오. 부동 소수점 유형에서 수행되는 산술은 IEEE 표준을 따릅니다. 정수 유형은 부동 소수점 유형으로 자동 변환되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b64d4599316074da7ef005b5cd10b87308f8b012" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: the smaller type is converted to the larger. Integer types are &lt;strong&gt;not&lt;/strong&gt; converted to floating point types automatically, nor vice versa. Use the &lt;a href=&quot;system#toInt&quot;&gt;toInt&lt;/a&gt; and &lt;a href=&quot;system#toFloat&quot;&gt;toFloat&lt;/a&gt; procs for these conversions.</source>
          <target state="translated">부동 소수점 유형이 다른 표현식에서 자동 유형 변환이 수행됩니다. 더 작은 유형이 더 큰 유형으로 변환됩니다. 정수 유형은 부동 소수점 유형으로 자동 변환 &lt;strong&gt;되지&lt;/strong&gt; 않으며 그 반대도 마찬가지입니다. 이러한 변환 에는 &lt;a href=&quot;system#toInt&quot;&gt;toInt&lt;/a&gt; 및 &lt;a href=&quot;system#toFloat&quot;&gt;toFloat 프로세스를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc40764f7876b20ac068b0f8a1ac400c090ad482" translate="yes" xml:space="preserve">
          <source>Available filters</source>
          <target state="translated">사용 가능한 필터</target>
        </trans-unit>
        <trans-unit id="48dc005192dc15899b10a69113ce172a5a8e8e1d" translate="yes" xml:space="preserve">
          <source>Avoiding SQL injection attacks</source>
          <target state="translated">SQL 인젝션 공격 방지</target>
        </trans-unit>
        <trans-unit id="ed59754f17e7c2d9945cda54ca5d2aa1dec958df" translate="yes" xml:space="preserve">
          <source>Back reference to the &lt;code&gt;i``th capture. ``i&lt;/code&gt; counts from 1.</source>
          <target state="translated">&lt;code&gt;i``th capture. ``i&lt;/code&gt; 에 대한 역 참조 . ``나는 1부터 센다.</target>
        </trans-unit>
        <trans-unit id="c1b87da997dc3c85ddc08c2e6d0f37c746574592" translate="yes" xml:space="preserve">
          <source>Backend code calling Nim</source>
          <target state="translated">Nim을 호출하는 백엔드 코드</target>
        </trans-unit>
        <trans-unit id="d2d1e1c764fd65afb7dd5b1cfc7187320a368f3d" translate="yes" xml:space="preserve">
          <source>Backend code can interface with Nim code exposed through the &lt;a href=&quot;manual#exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt;. The &lt;code&gt;exportc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making Nim symbols available to the backends. By default the Nim compiler will mangle all the Nim symbols to avoid any name collision, so the most significant thing the &lt;code&gt;exportc&lt;/code&gt; pragma does is maintain the Nim symbol name, or if specified, use an alternative symbol for the backend in case the symbol rules don't match.</source>
          <target state="translated">백엔드 코드는 &lt;a href=&quot;manual#exportc-pragma&quot;&gt;exportc pragma를&lt;/a&gt; 통해 노출 된 Nim 코드와 인터페이스 할 수 있습니다 . &lt;code&gt;exportc&lt;/code&gt; 프라 그마는이다 &lt;em&gt;일반적인&lt;/em&gt; 백엔드 사용할 수 님 기호를 만드는 방법입니다. 기본적으로 Nim 컴파일러는 이름 충돌을 피하기 위해 모든 Nim 기호를 &lt;code&gt;exportc&lt;/code&gt; 합니다. 따라서 exportc pragma가 수행 하는 가장 중요한 것은 Nim 기호 이름을 유지하거나 지정된 경우 기호 규칙이없는 경우 백엔드에 대체 기호를 사용하는 것입니다 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4409ab544e7304fef23a5593b1e7c39ba4acd8f5" translate="yes" xml:space="preserve">
          <source>Backend issues</source>
          <target state="translated">백엔드 문제</target>
        </trans-unit>
        <trans-unit id="b76b69c33162b1653a17f2c6f93e78edc8380818" translate="yes" xml:space="preserve">
          <source>Backend language options</source>
          <target state="translated">백엔드 언어 옵션</target>
        </trans-unit>
        <trans-unit id="b3776d63ad7b7a84bfe20d9c6d4a53a2b25d0e43" translate="yes" xml:space="preserve">
          <source>Backends</source>
          <target state="translated">Backends</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="d761e5a62561f09ed0d44ad1cb46328e1f217a6f" translate="yes" xml:space="preserve">
          <source>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</source>
          <target state="translated">백 슬래시는 큰 따옴표가 바로 앞에 오지 않는 한 문자 그대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="927ec03da92f02ddd56de8e2adaa715fed9bcf2d" translate="yes" xml:space="preserve">
          <source>Base class for floating point exceptions.</source>
          <target state="translated">부동 소수점 예외의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c01b2a5ff5b7f9aeb57693046b04a30f8f31374f" translate="yes" xml:space="preserve">
          <source>Base exception class.</source>
          <target state="translated">기본 예외 클래스.</target>
        </trans-unit>
        <trans-unit id="a7eab2acbe559b446c1a8d7cd0fa8164b769b943" translate="yes" xml:space="preserve">
          <source>Base exception object for all DOM Exceptions</source>
          <target state="translated">모든 DOM 예외에 대한 기본 예외 객체</target>
        </trans-unit>
        <trans-unit id="83973edfe760182bfdbc649edc3760f5c0702635" translate="yes" xml:space="preserve">
          <source>Base filename plus anchor hyper link (eg. &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt;).</source>
          <target state="translated">기본 파일 이름과 앵커 하이퍼 링크 (예 : &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="18bb69613ad5672181aef86b3bcfc02639a73650" translate="yes" xml:space="preserve">
          <source>Basic command line switches are:</source>
          <target state="translated">기본 명령 행 스위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65e84bd37e76307cd618b3b242847f165ff6ea89" translate="yes" xml:space="preserve">
          <source>Basic math routines for Nim. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">Nim의 기본 수학 루틴. 이 모듈은 &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 대상에&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc3f098aacbac78663d7394b49aef616d056323" translate="yes" xml:space="preserve">
          <source>Be aware that destructors are not called for objects allocated with &lt;code&gt;new&lt;/code&gt;. This may change in future versions of language, but for now the &lt;span id=&quot;finalizer_1&quot;&gt;finalizer&lt;/span&gt; parameter to &lt;code&gt;new&lt;/code&gt; has to be used.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 로 할당 된 객체에 대해서는 소멸자가 호출되지 않습니다 . 이는 향후 언어 버전에서 변경 될 수 있지만 현재는 &lt;span id=&quot;finalizer_1&quot;&gt;finalizer&lt;/span&gt; 매개 변수를 &lt;code&gt;new&lt;/code&gt; 로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3e15a7b46caea989a1213b44375d001f13628fc" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;read&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">&lt;em&gt;읽기&lt;/em&gt; 알림 감시를 제거하려면 콜백 &lt;code&gt;cb&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 , 알림 을 계속 수신하려면 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는지 확인하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8fba0a783eb77900741ec80cede356c924d6db33" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;write&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">&lt;em&gt;쓰기&lt;/em&gt; 알림 감시를 제거하려면 콜백 &lt;code&gt;cb&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 , 알림 을 계속 수신하려면 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는지 확인하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4102f62e5cacc86882ccbd463d607ec09aa3efa" translate="yes" xml:space="preserve">
          <source>Because the backslash &lt;code&gt;\&lt;/code&gt; is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the &lt;em&gt;raw&lt;/em&gt; strings of Nim, so that backslashes are interpreted by the regular expression engine:</source>
          <target state="translated">백 슬래시 &lt;code&gt;\&lt;/code&gt; 는 Nim 프로그래밍 언어와 정규식 모두에서 메타 문자 이므로 백 슬래시가 정규식 엔진에 의해 해석되도록 &lt;em&gt;원시&lt;/em&gt; 문자열을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9712a92a80197b448150bfcf6e22b8f9c9c72490" translate="yes" xml:space="preserve">
          <source>Because the literal is a raw string literal, the &lt;code&gt;\n&lt;/code&gt; is not interpreted as an escape sequence.</source>
          <target state="translated">리터럴은 원시 문자열 리터럴이므로 &lt;code&gt;\n&lt;/code&gt; 은 이스케이프 시퀀스로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8fb87298b9236d186e536c812e43df39ea168a6" translate="yes" xml:space="preserve">
          <source>Because the underlying &lt;code&gt;cmp()&lt;/code&gt; is defined for tuples you can do a nested sort like in the following example:</source>
          <target state="translated">기본 &lt;code&gt;cmp()&lt;/code&gt; 는 튜플에 대해 정의되므로 다음 예제와 같이 중첩 정렬을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d168f46ea8f3c36c56fc3253836f0e10427b1e" translate="yes" xml:space="preserve">
          <source>Before stopping the program the &quot;quit procedures&quot; are called in the opposite order they were added with &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt;. &lt;code&gt;quit&lt;/code&gt; never returns and ignores any exception that may have been raised by the quit procedures. It does &lt;em&gt;not&lt;/em&gt; call the garbage collector to free all the memory, unless a quit procedure calls &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect&lt;/a&gt;.</source>
          <target state="translated">프로그램을 중지하기 전에 &quot;quit procedure&quot;는 &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt; 와 함께 추가 된 반대 순서로 호출됩니다 . &lt;code&gt;quit&lt;/code&gt; 은 quit 프로 시저에 의해 발생 된 예외를 리턴하지 않고 무시합니다. 종료 프로 시저가 &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect를&lt;/a&gt; 호출하지 않으면 모든 메모리를 해제하기 위해 가비지 콜렉터를 호출 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="43d498bdad3123202c81edb42a89596ea2e8269d" translate="yes" xml:space="preserve">
          <source>Before the line is processed as a regular expression, some basic variables are searched for and replaced in the tests. The variables which will be replaced are:</source>
          <target state="translated">행이 정규식으로 처리되기 전에 일부 기본 변수가 검색되어 테스트에서 대체됩니다. 대체 될 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0e4a0c03109bf4544e258937ad71acfe78c0f79" translate="yes" xml:space="preserve">
          <source>Before the thread exits, you should tear down the thread's GC to prevent memory leaks by calling</source>
          <target state="translated">스레드가 종료되기 전에 호출하여 메모리 누수를 방지하기 위해 스레드의 GC를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="310e2e763625e5d6d59dce2240ea063af385856f" translate="yes" xml:space="preserve">
          <source>Before using this proc you need to initialise a &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and parse a rst file with &lt;code&gt;rstParse&lt;/code&gt; from the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. Example:</source>
          <target state="translated">이 proc을 사용하기 전에 &lt;code&gt;RstGenerator&lt;/code&gt; 로 &lt;code&gt;initRstGenerator&lt;/code&gt; 를 초기화 하고 &lt;a href=&quot;rst&quot;&gt;packages / docutils / rst 모듈&lt;/a&gt; 에서 &lt;code&gt;rstParse&lt;/code&gt; 로 첫 번째 파일을 구문 분석해야 합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="966b254aa9447e510a7ca9c23d5f788a878f610b" translate="yes" xml:space="preserve">
          <source>Begins a never ending global dispatcher poll loop.</source>
          <target state="translated">끝없는 글로벌 디스패처 폴링 루프를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="700e73def7ceec3f6434ea58699b8763915742e0" translate="yes" xml:space="preserve">
          <source>Begins connecting &lt;code&gt;sock&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sock&lt;/code&gt; 을 &lt;code&gt;name&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; 에 연결 하기 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="3b6ca901e484b0f0288a15e878ab0c9feab7a2af" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.readLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved, when this happens False will be returned. True will only be returned if a full line has been retrieved or the socket has been disconnected in which case &lt;code&gt;line&lt;/code&gt; will be set to &quot;&quot;.</source>
          <target state="translated">&lt;code&gt;sockets.readLine&lt;/code&gt; 과 유사 하지만 비 차단 소켓을 올바르게 처리합니다. 이 함수 는 일부 데이터 만 검색 할 수있는 경우 &lt;code&gt;line&lt;/code&gt; 이 전체 행 임을 보장합니다 . 전체 데이터를 검색 할 때이 데이터를 저장하고 결과에 추가합니다.이 경우 False가 반환됩니다. 전체 라인을 검색했거나 소켓을 분리 한 경우 에만 &lt;code&gt;line&lt;/code&gt; 이 &quot;&quot;로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c4326a5636a46dcb618755741f866f4b972d0a19" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.recvLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved.</source>
          <target state="translated">&lt;code&gt;sockets.recvLine&lt;/code&gt; 과 유사 하지만 비 차단 소켓을 올바르게 처리합니다. 이 함수 는 일부 데이터 만 검색 할 수있는 경우 &lt;code&gt;line&lt;/code&gt; 이 전체 행 임을 보장합니다 . 전체 데이터를 검색 할 때이 데이터를 저장하고 결과에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="265943f4fdc43174a25de385d384224b6714c3a1" translate="yes" xml:space="preserve">
          <source>Better serialization/deserialization control:</source>
          <target state="translated">더 나은 직렬화 / 직렬화 제어 :</target>
        </trans-unit>
        <trans-unit id="2f93848862aa5b35417b63e68af291d5b94657ce" translate="yes" xml:space="preserve">
          <source>Beware of nesting:</source>
          <target state="translated">중첩에주의하십시오 :</target>
        </trans-unit>
        <trans-unit id="79d0274d51b13cfe02935327c0fc3f6297737534" translate="yes" xml:space="preserve">
          <source>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</source>
          <target state="translated">주의 : 이로 인해 코드가 최적화되지 않고 실행 속도가 느려질 수 있습니다! 대부분의 문제는 반복자를 사용하거나 Rune 시퀀스로 변환하여보다 효율적으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="07e70f2fb17a35e7addfb3cce97a4c40deb42dbf" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for an integer.</source>
          <target state="translated">정수에 대한 이진 &lt;em&gt;*&lt;/em&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="b4d78a434e47f392f05a75db91b17acd6fe4fa07" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">부호없는 정수에 대한 이진 &lt;em&gt;*&lt;/em&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="26698f4bdcaf441cc8334749d82e3e3d352fb191" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*=&lt;/em&gt; operator for ordinals</source>
          <target state="translated">이항 &lt;em&gt;* =&lt;/em&gt; 서수에 대한 연산자</target>
        </trans-unit>
        <trans-unit id="330bd303262cb5101ce0efe34c05186ca99997f7" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for an integer.</source>
          <target state="translated">정수에 대한 이진 &lt;em&gt;+&lt;/em&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="38c5372d40da823748edf7ea2383e6eece6eff5b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">부호없는 정수에 대한 이진 &lt;em&gt;+&lt;/em&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="af8d9afe7721543aea25b34b98173554127fcd0b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for an integer.</source>
          <target state="translated">이진 &lt;em&gt;-&lt;/em&gt; 정수 연산자.</target>
        </trans-unit>
        <trans-unit id="8ccf951823bb2d33004b173d71cc94c3047b4785" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">이진 &lt;em&gt;-&lt;/em&gt; 부호없는 정수의 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="560f98c3ead9f955754deb12fba064845d75b979" translate="yes" xml:space="preserve">
          <source>Binary operators whose first character is &lt;code&gt;^&lt;/code&gt; are right-associative, all other binary operators are left-associative.</source>
          <target state="translated">첫 문자가 &lt;code&gt;^&lt;/code&gt; 인 이진 연산자 는 오른쪽 연결이고 다른 모든 이진 연산자는 왼쪽 연결입니다.</target>
        </trans-unit>
        <trans-unit id="360d45a25b59088bfa51b40dd2c0ffd7a2333f6c" translate="yes" xml:space="preserve">
          <source>Binary. Outputs the number in base 2.</source>
          <target state="translated">이진. 밑이 2 인 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d087993ff800b452527c7966565ad3f6a2e4d837" translate="yes" xml:space="preserve">
          <source>Bind matching to some action</source>
          <target state="translated">일부 작업에 일치하는 바인딩</target>
        </trans-unit>
        <trans-unit id="af1a43872e0146a37b3fc6fec03f088b6f0c7d84" translate="yes" xml:space="preserve">
          <source>Bind statement</source>
          <target state="translated">바인드 진술</target>
        </trans-unit>
        <trans-unit id="d59366ada08751ecfdb863b4a3641304d02f31a6" translate="yes" xml:space="preserve">
          <source>BindSym</source>
          <target state="translated">BindSym</target>
        </trans-unit>
        <trans-unit id="e09df968e0a484a9efbeb94427ec16a9be185b7d" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt; to the socket.</source>
          <target state="translated">바인드 &lt;code&gt;address&lt;/code&gt; : 소켓에 &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="659ea289b78cfbcca53efa111220718b2e750524" translate="yes" xml:space="preserve">
          <source>Binds Unix socket to &lt;em&gt;path&lt;/em&gt;. This only works on Unix-style systems: Mac OS X, BSD and Linux</source>
          <target state="translated">Unix 소켓을 &lt;em&gt;path에&lt;/em&gt; 바인딩 &lt;em&gt;합니다&lt;/em&gt; . 이것은 유닉스 스타일 시스템에서만 작동합니다 : Mac OS X, BSD 및 Linux</target>
        </trans-unit>
        <trans-unit id="8e8aaeecce239b0f06469ead101c23881541a5d5" translate="yes" xml:space="preserve">
          <source>Bits for which fields are set</source>
          <target state="translated">필드가 설정되는 비트</target>
        </trans-unit>
        <trans-unit id="cd3e66f022e12b57b1f5fe62492942f67ba04841" translate="yes" xml:space="preserve">
          <source>Bitsize pragma</source>
          <target state="translated">비트 사이즈 프라 그마</target>
        </trans-unit>
        <trans-unit id="234ac99e0a5dfd13079331f5a645966c4b4a76a7" translate="yes" xml:space="preserve">
          <source>Blank lines are skipped.</source>
          <target state="translated">빈 줄은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="40f4277d9e2e9642b7c7082b91e613d62eab845f" translate="yes" xml:space="preserve">
          <source>Block device.</source>
          <target state="translated">장치를 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">블록 범위</target>
        </trans-unit>
        <trans-unit id="d900d959e6c700afd03ab9e7a37649c54ebba876" translate="yes" xml:space="preserve">
          <source>Block statement</source>
          <target state="translated">블록 진술</target>
        </trans-unit>
        <trans-unit id="f5b504d04d5a39d2d24b7595634cf4c7ea12b1e0" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. If &lt;code&gt;server&lt;/code&gt; is non-blocking then this function returns immediately, and if there are no connections queued the returned socket will be &lt;code&gt;InvalidSocket&lt;/code&gt;. This function will raise EOS if an error occurs.</source>
          <target state="translated">클라이언트에서 연결될 때까지 차단합니다. 연결되면 &lt;code&gt;client&lt;/code&gt; 를 클라이언트 소켓 으로 설정 하고 &lt;code&gt;address&lt;/code&gt; 를 연결 클라이언트의 주소로 설정합니다. 경우 &lt;code&gt;server&lt;/code&gt; 즉시 다음이 함수가 반환을 비 차단하고있는 경우에는 연결이 반환 된 소켓이 될 것입니다 대기하지 &lt;code&gt;InvalidSocket&lt;/code&gt; . 이 기능은 오류가 발생하면 EOS를 높입니다.</target>
        </trans-unit>
        <trans-unit id="6d6f90513642da6009f2dec4733272a1e46e96f3" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. This function will raise EOS if an error occurs.</source>
          <target state="translated">클라이언트에서 연결될 때까지 차단합니다. 연결되면 &lt;code&gt;client&lt;/code&gt; 를 클라이언트 소켓 으로 설정 하고 &lt;code&gt;address&lt;/code&gt; 를 연결 클라이언트의 주소로 설정합니다. 이 기능은 오류가 발생하면 EOS를 높입니다.</target>
        </trans-unit>
        <trans-unit id="70bf1baa003257ad55f9ad962d42ef3e987cd33e" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;and&lt;/code&gt;; returns true iff &lt;code&gt;x == y == true&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is false, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">부울 &lt;code&gt;and&lt;/code&gt; ; iff &lt;code&gt;x == y == true&lt;/code&gt; 반환합니다 . 평가가 게으름 : &lt;code&gt;x&lt;/code&gt; 가 거짓이면 &lt;code&gt;y&lt;/code&gt; 도 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a3c45029fde7152ef764416ecfd26148ba5b9ad" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;or&lt;/code&gt;; returns true iff &lt;code&gt;not (not x and not y)&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is true, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">부울 &lt;code&gt;or&lt;/code&gt; ; &lt;code&gt;not (not x and not y)&lt;/code&gt; true iff를 반환합니다 . 평가가 게으르다 : &lt;code&gt;x&lt;/code&gt; 가 참이면, &lt;code&gt;y&lt;/code&gt; 도 평가되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="02bbffdde9a8f3f92162c50254a83eda75717823" translate="yes" xml:space="preserve">
          <source>Boolean &lt;em&gt;exclusive or&lt;/em&gt;; returns true iff &lt;code&gt;x != y&lt;/code&gt;.</source>
          <target state="translated">부울 &lt;em&gt;독점 또는&lt;/em&gt; ; true iff &lt;code&gt;x != y&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e4f6a62c295e099a6e5cc6ca486fd23a80fe9b9d" translate="yes" xml:space="preserve">
          <source>Boolean flag that indicates if the system supports nanosecond time resolution in the fields of &lt;code&gt;Stat&lt;/code&gt;. Note that the nanosecond based fields (&lt;code&gt;Stat.st_atim&lt;/code&gt;, &lt;code&gt;Stat.st_mtim&lt;/code&gt; and &lt;code&gt;Stat.st_ctim&lt;/code&gt;) can be accessed without checking this flag, because this module defines fallback procs when they are not available.</source>
          <target state="translated">시스템이 &lt;code&gt;Stat&lt;/code&gt; 필드에서 나노초 시간 해상도를 지원하는지 여부를 나타내는 부울 플래그입니다 . 나노초 기반 필드 ( &lt;code&gt;Stat.st_atim&lt;/code&gt; , &lt;code&gt;Stat.st_mtim&lt;/code&gt; 및 &lt;code&gt;Stat.st_ctim&lt;/code&gt; )는이 플래그를 확인하지 않고 액세스 할 수 있습니다.이 모듈은 사용할 수없는 폴백 프로 시저를 정의하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="20ba3c881998fa4098ce5ba4cafd77d368e565ad" translate="yes" xml:space="preserve">
          <source>Boolean not; returns true iff &lt;code&gt;x == false&lt;/code&gt;.</source>
          <target state="translated">부울이 아닙니다. iff &lt;code&gt;x == false&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cad44960020fa76bebce8ad95937acc2bd15d81f" translate="yes" xml:space="preserve">
          <source>Boolean socket options.</source>
          <target state="translated">부울 소켓 옵션.</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="0add89edb9f4ac0882e5974a2ed406404a13002f" translate="yes" xml:space="preserve">
          <source>Bootstrapping the compiler</source>
          <target state="translated">컴파일러 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="bd4dea3d9dc65cab9bb66d4cc6a6ce01c2e41ab8" translate="yes" xml:space="preserve">
          <source>Both parts have the same sign as &lt;em&gt;x&lt;/em&gt;. Analogous to the &lt;em&gt;modf&lt;/em&gt; function in C.</source>
          <target state="translated">두 부분 모두 &lt;em&gt;x&lt;/em&gt; 와 같은 부호를 갖습니다 . C 의 &lt;em&gt;modf&lt;/em&gt; 함수 와 유사</target>
        </trans-unit>
        <trans-unit id="35a56c974fb1825347f0fe1529b19d7c99f2d402" translate="yes" xml:space="preserve">
          <source>Both the multi method and the type converter problems are solved by the AST replay implementation.</source>
          <target state="translated">다중 방법 및 유형 변환기 문제는 모두 AST 재생 구현으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="19ab36d21e3e2bca80b33ef2b7f048e8235fb8c0" translate="yes" xml:space="preserve">
          <source>Brackets</source>
          <target state="translated">Brackets</target>
        </trans-unit>
        <trans-unit id="c53284da9f760cfe1b6f6b9f75108f3e5f34245e" translate="yes" xml:space="preserve">
          <source>Brackets are used as the array constructor.</source>
          <target state="translated">대괄호는 배열 생성자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f1e60578f3cd76d5527fed043c9442139cd2cd3" translate="yes" xml:space="preserve">
          <source>Break statement</source>
          <target state="translated">브레이크 선언</target>
        </trans-unit>
        <trans-unit id="d1d87f5d380c5544ae2b99408021a09200064c57" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop may cause a driver error for subsequenct queries</source>
          <target state="translated">루프 중에 fastRows () 반복자를 중단하면 하위 시퀀스 쿼리에 대한 드라이버 오류가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ec4a222af9465c04b4a8d052175ff58043442831" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise a DbError exception &lt;code&gt;unable to close due to ...&lt;/code&gt;.</source>
          <target state="translated">루프 중에 fastRows () 반복자를 중단하면 다음 데이터베이스 쿼리로 &lt;code&gt;unable to close due to ...&lt;/code&gt; DbError 예외 를 닫을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2c7a0ef890af1a51c57cdb3dba04d6c6a9bbd34e" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise an [EDb] exception &lt;code&gt;Commands out of sync&lt;/code&gt;.</source>
          <target state="translated">루프 중에 fastRows () 반복자를 중단하면 다음 데이터베이스 쿼리에서 [EDb] 예외 &lt;code&gt;Commands out of sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9c84b3329de1f9c1a856698aa2ec5cff34e5ad" translate="yes" xml:space="preserve">
          <source>Breaks &lt;em&gt;x&lt;/em&gt; into an integral and a fractional part.</source>
          <target state="translated">나누기 &lt;em&gt;X&lt;/em&gt; 정수 및 분수 부분에.</target>
        </trans-unit>
        <trans-unit id="8b6724e85f24d7713d447fc9d1ecbadafa7df149" translate="yes" xml:space="preserve">
          <source>Breaks this node into two nodes at the specified offset, keeping both in the tree as siblings.</source>
          <target state="translated">이 노드를 지정된 오프셋에서 두 개의 노드로 나누고 두 노드를 모두 형제로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="425b1ac3be0544ab3f6c956fa14370b9d4fb8322" translate="yes" xml:space="preserve">
          <source>Build and test examples:</source>
          <target state="translated">빌드 및 테스트 예제 :</target>
        </trans-unit>
        <trans-unit id="6239081298122df79f8acd6439e80ca8b6b91469" translate="yes" xml:space="preserve">
          <source>Building your first macro</source>
          <target state="translated">첫 번째 매크로 만들기</target>
        </trans-unit>
        <trans-unit id="646a6e4f96059c15c08aa818c66b65c410dfb9b2" translate="yes" xml:space="preserve">
          <source>Built-in macro for a longer expression.</source>
          <target state="translated">더 긴 표현을위한 내장 매크로.</target>
        </trans-unit>
        <trans-unit id="4d613da9be22e4083b43024dca2bbeaca3d83302" translate="yes" xml:space="preserve">
          <source>Built-in macros</source>
          <target state="translated">내장 매크로</target>
        </trans-unit>
        <trans-unit id="b5a84b589b9501cdc3df0931004c7cc42b59cde3" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.</source>
          <target state="translated">메모리 위치의 주소를 가져 오는 내장 'addr'연산자 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c463568500df5b37582c13d23e61bcb20c8accaa" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. This works even for &lt;code&gt;let&lt;/code&gt; variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary &lt;code&gt;addr&lt;/code&gt;. When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure. Cannot be overloaded.</source>
          <target state="translated">메모리 위치의 주소를 가져 오는 내장 'addr'연산자 이에 대해서도 작동 &lt;code&gt;let&lt;/code&gt; C와 더 나은 상호 운용성에 대한 변수 나 매개 변수 그리고 그것은 훨씬 더 안전하지 않은 보통 이상으로 간주되도록 &lt;code&gt;addr&lt;/code&gt; . 이를 사용하여 C 라이브러리의 랩퍼를 작성할 때 항상 원래 라이브러리가이 프로 시저에서 리턴 된 포인터 뒤의 데이터에 쓰지 않는지 항상 확인해야합니다. 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8ca99ea406ea54b032b966a06afdbf917b785d6" translate="yes" xml:space="preserve">
          <source>But a &lt;code&gt;bind&lt;/code&gt; is rarely useful because symbol binding from the definition scope is the default.</source>
          <target state="translated">그러나 정의 범위의 심볼 바인딩이 기본값이므로 &lt;code&gt;bind&lt;/code&gt; 는 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3a68bc3de013b49eccd2fd19fb51ef8acfea012" translate="yes" xml:space="preserve">
          <source>But it seems all this boilerplate code needs to be repeated for the &lt;code&gt;Euro&lt;/code&gt; currency. This can be solved with &lt;a href=&quot;#templates&quot;&gt;templates&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;Euro&lt;/code&gt; 대해서는이 상용구 코드를 모두 반복해야합니다 . 이것은 &lt;a href=&quot;#templates&quot;&gt;템플릿&lt;/a&gt; 으로 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b442f85caf3d7cde4cea2e5e9eb91a280936441" translate="yes" xml:space="preserve">
          <source>But one has to watch out because other overloads might trigger the argument's resolution:</source>
          <target state="translated">그러나 다른 과부하로 인해 인수가 해결 될 수 있으므로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c53e0632274551f5aa1f6a36373db50475b33d38" translate="yes" xml:space="preserve">
          <source>But the global symbol can properly be captured by a &lt;code&gt;bind&lt;/code&gt; statement:</source>
          <target state="translated">그러나 글로벌 심볼은 &lt;code&gt;bind&lt;/code&gt; 명령문으로 올바르게 캡처 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="527742dcc91f3b4388a5222a890c0118d3a5e0d7" translate="yes" xml:space="preserve">
          <source>But this rule does not apply to procedures or iterators. Here the overloading rules apply:</source>
          <target state="translated">그러나이 규칙은 프로 시저 또는 반복자에는 적용되지 않습니다. 여기에 과부하 규칙이 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="9250d320cadcddd0ef262bd8559df915bc7e0bc6" translate="yes" xml:space="preserve">
          <source>By default Nim's &lt;code&gt;dynlib&lt;/code&gt; pragma causes the compiler to generate &lt;code&gt;GetProcAddress&lt;/code&gt; (or their Unix counterparts) calls to bind to a DLL. With the &lt;code&gt;dynlibOverride&lt;/code&gt; command line switch this can be prevented and then via &lt;code&gt;--passL&lt;/code&gt; the static library can be linked against. For instance, to link statically against Lua this command might work on Linux:</source>
          <target state="translated">기본적으로 Nim의 &lt;code&gt;dynlib&lt;/code&gt; pragma는 컴파일러가 DLL에 바인딩 할 &lt;code&gt;GetProcAddress&lt;/code&gt; (또는 해당 Unix 대응) 호출을 생성 하도록합니다. 으로 &lt;code&gt;dynlibOverride&lt;/code&gt; 의 커맨드 라인이 방지하고 통해 전환 될 수 &lt;code&gt;--passL&lt;/code&gt; 정적 라이브러리에 링크 될 수있다. 예를 들어, Lua에 정적으로 연결하려면이 명령이 Linux에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d02d9c4acff9cf60b68f15e507f7e43cd5939742" translate="yes" xml:space="preserve">
          <source>By default a debug version is created, passing this option will force a release build, which is much faster and should be preferred unless you are debugging the compiler.</source>
          <target state="translated">기본적으로 디버그 버전이 생성되며이 옵션을 전달하면 릴리스 빌드가 훨씬 빨라지며 컴파일러를 디버깅하지 않는 한 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="48b684a5792df5c5364095950ec05af76390e113" translate="yes" xml:space="preserve">
          <source>By default c2nim marks every top level identifier (proc name, variable, etc.) as exported (the export marker is &lt;code&gt;*&lt;/code&gt; in Nim). With the &lt;code&gt;#private&lt;/code&gt; directive identifiers can be marked as private so that the resulting Nim module does not export them. The &lt;code&gt;#private&lt;/code&gt; directive takes a PEG pattern:</source>
          <target state="translated">기본 c2nim 마크 보낸으로 모든 최상위 식별자 (PROC 이름, 변수 등) (수출 마커는 &lt;code&gt;*&lt;/code&gt; 님에). 으로 &lt;code&gt;#private&lt;/code&gt; 지시 식별자는 결과 님 모듈을 수출하지 않는 개인도록 표시 할 수 있습니다. &lt;code&gt;#private&lt;/code&gt; 의 지시어는 PEG 패턴을합니다 :</target>
        </trans-unit>
        <trans-unit id="0de21675c01f240e6592367c51b6d906f03a3d78" translate="yes" xml:space="preserve">
          <source>By default the Nim compiler generates a large amount of runtime checks aiming for your debugging pleasure. With &lt;code&gt;-d:release&lt;/code&gt; these checks are &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;turned off and optimizations are turned on&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Nim 컴파일러는 디버깅의 즐거움을 목표로 많은 런타임 검사를 생성합니다. &lt;code&gt;-d:release&lt;/code&gt; 를 사용하면 이러한 검사가 &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;꺼지고 최적화가 켜집니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53714c20b023fb0e9acbdf38f380565e04810da2" translate="yes" xml:space="preserve">
          <source>By default the documentation will be built in parallel using the number of available CPU cores. If any documentation build sub commands fail, they will be rerun in serial fashion so that meaninful error output can be gathered for inspection. The &lt;code&gt;--parallelBuild:n&lt;/code&gt; switch or configuration option can be used to force a specific number of parallel jobs or run everything serially from the start (&lt;code&gt;n == 1&lt;/code&gt;).</source>
          <target state="translated">기본적으로 설명서는 사용 가능한 CPU 코어 수를 사용하여 병렬로 빌드됩니다. 문서 빌드 하위 명령이 실패하는 경우 검사를 위해 의미있는 오류 출력을 수집 할 수 있도록 직렬 방식으로 다시 실행됩니다. &lt;code&gt;--parallelBuild:n&lt;/code&gt; 스위치 또는 구성 옵션은 병렬 작업의 특정 번호를 사용하도록 강제 또는 시작 (직렬에서 모두 실행될 수 &lt;code&gt;n == 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a12f023f59a39b1f378be96457f00762035b5df" translate="yes" xml:space="preserve">
          <source>By default, c2nim translates an &lt;code&gt;#include&lt;/code&gt; that is not followed by &lt;code&gt;&amp;lt;&lt;/code&gt; (like in &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt;) to a Nim &lt;code&gt;import&lt;/code&gt; statement. This directive tells c2nim to just skip any &lt;code&gt;#include&lt;/code&gt;.</source>
          <target state="translated">기본적으로 c2nim은 &lt;code&gt;#include&lt;/code&gt; 다음에 &lt;code&gt;&amp;lt;&lt;/code&gt; 가 아닌 &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt; ( #include &amp;lt;stdlib&amp;gt; 와 같이 )를 Nim &lt;code&gt;import&lt;/code&gt; 문으로 변환합니다. 이 지시어는 c2nim에게 &lt;code&gt;#include&lt;/code&gt; 를 건너 뛰도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="5fae71acbfd2891a1634971f65ec8cdeff58500b" translate="yes" xml:space="preserve">
          <source>By default, during overload resolution each named type class will bind to exactly one concrete type. We call such type classes &lt;span id=&quot;bind-once_1&quot;&gt;bind once&lt;/span&gt; types. Here is an example taken directly from the system module to illustrate this:</source>
          <target state="translated">기본적으로 과부하 해결 중에는 명명 된 각 유형 클래스가 정확히 하나의 콘크리트 유형에 바인딩됩니다. 이러한 유형 클래스 &lt;span id=&quot;bind-once_1&quot;&gt;는 한 번&lt;/span&gt; 유형을 &lt;span id=&quot;bind-once_1&quot;&gt;바인딩&lt;/span&gt; 합니다. 다음은이를 설명하기 위해 시스템 모듈에서 직접 가져온 예입니다.</target>
        </trans-unit>
        <trans-unit id="73cb09bc05777230e6e5fe1e7143a2c142ee2d0d" translate="yes" xml:space="preserve">
          <source>By default, the compiler will report the matching errors in concepts only when no other overload can be selected and a normal compilation error is produced. When you need to understand why the compiler is not matching a particular concept and, as a result, a wrong overload is selected, you can apply the &lt;code&gt;explain&lt;/code&gt; pragma to either the concept body or a particular call-site.</source>
          <target state="translated">기본적으로 컴파일러는 다른 과부하를 선택할 수없고 정상적인 컴파일 오류가 발생하는 경우에만 개념에서 일치하는 오류를보고합니다. 컴파일러가 특정 개념과 일치하지 않는 이유를 이해해야하며 결과적으로 잘못된 과부하가 선택되면 &lt;code&gt;explain&lt;/code&gt; pragma를 개념 본문 또는 특정 콜 사이트에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80f5e65dfa0cd584e698223d82de76d94317241e" translate="yes" xml:space="preserve">
          <source>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to &lt;em&gt;bpColloquial&lt;/em&gt; to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</source>
          <target state="translated">기본적으로 IEC / ISO 표준 이진 접두사를 사용하므로 1024는 1KiB로 형식이 지정됩니다. SI 표준의 구어체 이름을 사용하려면 접두어를 &lt;em&gt;bpColloquial&lt;/em&gt; 로 설정하십시오 (예 : 1000의 경우 k는 1024 로 &lt;em&gt;재 사용됨&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc61bfc923f0134f76f08848fd47d85a5225ef86" translate="yes" xml:space="preserve">
          <source>Bycopy pragma</source>
          <target state="translated">Bycopy pragma</target>
        </trans-unit>
        <trans-unit id="dc786d2e8550e65dba6f478b2c981035a039ff49" translate="yes" xml:space="preserve">
          <source>Byref pragma</source>
          <target state="translated">바이 레프 프라 그마</target>
        </trans-unit>
        <trans-unit id="e373e36949fb915e82bd278056c90511b6ce4a56" translate="yes" xml:space="preserve">
          <source>C implementation: &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</source>
          <target state="translated">C 구현 : &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbf459b1966378eb6b198b4db1484574fc622a26" translate="yes" xml:space="preserve">
          <source>C invocation example</source>
          <target state="translated">C 호출 예제</target>
        </trans-unit>
        <trans-unit id="cef9b186930ae3fbcdf84f2ca1df6e923c10face" translate="yes" xml:space="preserve">
          <source>C to Nim source converter. Translates C header files to Nim.</source>
          <target state="translated">C에서 Nim 소스 변환기. C 헤더 파일을 Nim으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="aa0b476ef445e23e653ff55250eadd2a609d86ee" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;,&lt;/code&gt; operator (comma operator) is not supported.</source>
          <target state="translated">C &lt;code&gt;,&lt;/code&gt; 연산자 (쉼표 연산자)는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e567e8ea65384f4c7990dd6fd015e5dc179fcdc" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;union&lt;/code&gt; are translated to Nim's objects and only the first field is included in the object type. This way there is a high chance that it is binary compatible to the union.</source>
          <target state="translated">C의 &lt;code&gt;union&lt;/code&gt; 는 Nim의 객체로 변환되며 첫 번째 필드 만 객체 유형에 포함됩니다. 이렇게하면 공용체와 바이너리 호환 가능할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="8f522347c60c0922b17da1143403e53d860a58d2" translate="yes" xml:space="preserve">
          <source>C2nim</source>
          <target state="translated">C2nim</target>
        </trans-unit>
        <trans-unit id="f30d6a6fe6e12777a78cd63942d1e0466d7744a4" translate="yes" xml:space="preserve">
          <source>CANNOT BE int64 BECAUSE OF ALIGNMENT</source>
          <target state="translated">정렬 때문에 int64 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="dfa0a6adb0d6b924e9559526a04fdb494693340f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; 의 아크 탄젠트 계산&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5de1a650a2f08daab441e97db705f2a8290b44f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;atan2&lt;/em&gt; returns the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (&lt;em&gt;x&lt;/em&gt; near 0).</source>
          <target state="translated">&lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; 의 아크 탄젠트를 계산합니다 . &lt;em&gt;atan2&lt;/em&gt; 는 &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; 의 아크 탄젠트를 반환합니다 . 결과 각도가 pi / 2 또는 -pi / 2 ( &lt;em&gt;x&lt;/em&gt; near 0)에 가까울 때도 올바른 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="56ec6774caee72173cca3d600df6df4ad5cea2f4" translate="yes" xml:space="preserve">
          <source>Calculate the bit parity in integer. If number of 1-bit is odd parity is 1, otherwise 0.</source>
          <target state="translated">정수로 비트 패리티를 계산하십시오. 1 비트 수가 홀수 패리티이면 1이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="24670fb674da2394dd2a0f4959fd3a294516adae" translate="yes" xml:space="preserve">
          <source>Calculate the reciprocal of &lt;em&gt;x&lt;/em&gt;. (1/x)</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역수를 계산합니다 . (1 / x)</target>
        </trans-unit>
        <trans-unit id="932f4eb5f8468f8594b47ae0aae880a0c60dbe3e" translate="yes" xml:space="preserve">
          <source>Calculates the best rational numerator and denominator that approximates to &lt;em&gt;x&lt;/em&gt;, where the denominator is smaller than &lt;em&gt;n&lt;/em&gt; (default is the largest possible int to give maximum resolution).</source>
          <target state="translated">&lt;em&gt;x에&lt;/em&gt; 근사한 최적의 분자와 분모를 계산합니다 . 여기서 분모는 &lt;em&gt;n&lt;/em&gt; 보다 작습니다 (기본값은 최대 해상도를 제공 할 수있는 가장 큰 정수입니다).</target>
        </trans-unit>
        <trans-unit id="3010c6d2f4fa47d3ebb08435fd6265b2c82ae435" translate="yes" xml:space="preserve">
          <source>Calculates the next lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 직접 수정하여 다음 사전 편법 순열을 계산합니다 . 결과는 순열이 발생했는지 여부이며, 그렇지 않으면 마지막으로 정렬 된 순열에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="926f466377c398ffb795b1c416217100d99d20d7" translate="yes" xml:space="preserve">
          <source>Calculates the previous lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 직접 수정하여 이전 사전 편법 순열을 계산합니다 . 결과는 순열이 발생했는지 여부입니다. 그렇지 않으면 1 차 순열에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="f5b27c0795360d24a64c7b68bf2cc3b1338d3199" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;cbproc&lt;/code&gt; &quot;soon&quot;.</source>
          <target state="translated">&lt;code&gt;cbproc&lt;/code&gt; 를 &quot;곧&quot; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ced0e76c83f56c5d573ca3272434ebf912be391" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'L' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'L'.</source>
          <target state="translated">버퍼에서 'L'을 스캔 한 경우이를 호출하십시오. 스캔을 계속할 위치를 반환합니다. &lt;em&gt;pos&lt;/em&gt; 는 'L'의 위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="77d5fa0614be1a0c2dc98ca10137b9644cb75099" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'c' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'c'.</source>
          <target state="translated">버퍼에서 'c'를 스캔 한 경우이를 호출하십시오. 스캔을 계속할 위치를 반환합니다. &lt;em&gt;pos&lt;/em&gt; 는 'c'의 위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1ef18f3ccda6fa4b7049be2ee5f84665bbb0ce03" translate="yes" xml:space="preserve">
          <source>Call user defined proc &lt;code&gt;foo&lt;/code&gt; to &lt;strong&gt;skip&lt;/strong&gt; some optional parts in the input string. See below for more details.</source>
          <target state="translated">입력 문자열에서 일부 선택적 부분 을 &lt;strong&gt;건너 뛰&lt;/strong&gt; 려면 사용자 정의 proc &lt;code&gt;foo&lt;/code&gt; 를 호출하십시오 . 자세한 내용은 아래를 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02241663160dcc2a31527f886c0c708b65f901d7" translate="yes" xml:space="preserve">
          <source>Call with &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 으로 전화</target>
        </trans-unit>
        <trans-unit id="da6c999c007bfe15edd1f0f081d6f9072a370ddb" translate="yes" xml:space="preserve">
          <source>Call with named arguments</source>
          <target state="translated">명명 된 인수로 호출</target>
        </trans-unit>
        <trans-unit id="4f1be644dd81e7d1af3decb76997fc722787c242" translate="yes" xml:space="preserve">
          <source>Call with raw string literal</source>
          <target state="translated">원시 문자열 리터럴로 호출</target>
        </trans-unit>
        <trans-unit id="bfcb7c395fc4a2662bfef50abfeba239833faf54" translate="yes" xml:space="preserve">
          <source>Callable type</source>
          <target state="translated">호출 가능 유형</target>
        </trans-unit>
        <trans-unit id="d6a9bd6a90d6905593fcbe3587fd9fc40af85f67" translate="yes" xml:space="preserve">
          <source>Calling a procedure can be done in many different ways:</source>
          <target state="translated">프로 시저 호출은 여러 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f026609c17e6af082dd6bc47161a40d8bcada7a1" translate="yes" xml:space="preserve">
          <source>Calling ordinary Nim procs inside the macro is possible:</source>
          <target state="translated">매크로 내부에서 일반적인 Nim proc 호출이 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="a6642199094bd906db4fb13f403e5d9864fe5992" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;styledWrite&lt;/code&gt; and appends a newline at the end.</source>
          <target state="translated">&lt;code&gt;styledWrite&lt;/code&gt; 를 호출 하고 끝에 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7e723e08242f8573f5209a7864aabe4641ef9035" translate="yes" xml:space="preserve">
          <source>Calls/expressions</source>
          <target state="translated">Calls/expressions</target>
        </trans-unit>
        <trans-unit id="cfe2ed24a31b4d3b922301946dba17cf4d7769e4" translate="yes" xml:space="preserve">
          <source>Can a &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; proc be written that supports this loop? Lets try:</source>
          <target state="translated">이 루프를 지원 하는 &lt;a href=&quot;system#countup&quot;&gt;카운트 업&lt;/a&gt; 프로 시저를 작성할 수 있습니까 ? 해보자:</target>
        </trans-unit>
        <trans-unit id="311200cff08c958701bc83ae616b08935d475e3d" translate="yes" xml:space="preserve">
          <source>Can be used to convert a pointer type to an option type. It converts &lt;code&gt;nil&lt;/code&gt; to the none-option.</source>
          <target state="translated">포인터 유형을 옵션 유형으로 변환하는 데 사용할 수 있습니다. &lt;code&gt;nil&lt;/code&gt; 을 none 옵션으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="73a3789c9cc42ae286b2bc07d22e73c5d6441a2b" translate="yes" xml:space="preserve">
          <source>CannotOpenFile</source>
          <target state="translated">CannotOpenFile</target>
        </trans-unit>
        <trans-unit id="a4b36f5e09cea9865cb6993e0accb43f1789f9cd" translate="yes" xml:space="preserve">
          <source>Capture: Apply expression &lt;em&gt;E&lt;/em&gt; and store the substring that matched &lt;em&gt;E&lt;/em&gt; into a &lt;em&gt;capture&lt;/em&gt; that can be accessed after the matching process.</source>
          <target state="translated">캡처 : 표현 적용 &lt;em&gt;E를&lt;/em&gt; 하고 일치하는 문자열 저장 &lt;em&gt;E를&lt;/em&gt; 로 &lt;em&gt;캡처&lt;/em&gt; 일치 처리 후 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dada321496f3f4fb22895c4b7cd0802a93ca5d72" translate="yes" xml:space="preserve">
          <source>Captured Search: Shorthand for &lt;code&gt;{(!E .)*} E&lt;/code&gt;. (Search loop for the pattern &lt;em&gt;E&lt;/em&gt;.) Everything until and exluding &lt;em&gt;E&lt;/em&gt; is captured.</source>
          <target state="translated">캡처 된 검색 : &lt;code&gt;{(!E .)*} E&lt;/code&gt; 속기입니다 . (패턴에 대한 루프 검색 &lt;em&gt;E를&lt;/em&gt; .) 모든 및 exluding 때까지 &lt;em&gt;E하는 것은&lt;/em&gt; 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="58721ba126309ca208430cd499d98df05aa97730" translate="yes" xml:space="preserve">
          <source>Card stands for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;cardinality&lt;/a&gt; of a set.</source>
          <target state="translated">카드는 세트 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;카디널리티&lt;/a&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f3a52f7d1133fe19bed724efe1bcc5b99763e6ec" translate="yes" xml:space="preserve">
          <source>Case expression</source>
          <target state="translated">사례 표현</target>
        </trans-unit>
        <trans-unit id="ca901f84d981e4405cbb31e5c66f958f39995d61" translate="yes" xml:space="preserve">
          <source>Case statement</source>
          <target state="translated">사례 진술</target>
        </trans-unit>
        <trans-unit id="67a5699f66f3a4d73b5d418a7b08b0c7350d984e" translate="yes" xml:space="preserve">
          <source>Case statement macros</source>
          <target state="translated">사례 설명 매크로</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b883b50cc0a7ec97e8c1c6aa366453f73a26413f" translate="yes" xml:space="preserve">
          <source>Change current implementation of &lt;code&gt;callSoon&lt;/code&gt;. This is normally called when dispatcher from &lt;code&gt;asyncdispatcher&lt;/code&gt; is initialized.</source>
          <target state="translated">&lt;code&gt;callSoon&lt;/code&gt; 의 현재 구현을 변경하십시오 . 이것은 일반적으로 &lt;code&gt;asyncdispatcher&lt;/code&gt; 의 디스패처 가 초기화 될 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5a7e15fb6b1d9ffe60a97b971875a5fd14c3986" translate="yes" xml:space="preserve">
          <source>Change the i-th element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 i 번째 요소를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a378d275114814e060b77abd531dd213c169f954" translate="yes" xml:space="preserve">
          <source>Changes permission of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">의 허가를 변경 &lt;code&gt;path&lt;/code&gt; 에 대한 &lt;code&gt;permissions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bc9d87771e5da3b869e9e85828f5d8bc801b455" translate="yes" xml:space="preserve">
          <source>Changes the current directory on the remote FTP server to &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">원격 FTP 서버의 현재 디렉토리를 &lt;code&gt;dir&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="c055bf809996f18dce65f9e3f155faf78c41dcc7" translate="yes" xml:space="preserve">
          <source>Changes the current directory to the parent of the current directory.</source>
          <target state="translated">현재 디렉토리를 현재 디렉토리의 상위로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="a9e433ae359b493762f4f0a4bb510351b98a08de" translate="yes" xml:space="preserve">
          <source>Changes the file extension to &lt;em&gt;ext&lt;/em&gt;.</source>
          <target state="translated">파일 확장자를 &lt;em&gt;ext로&lt;/em&gt; 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="3ca5b74490314ec55a9cac4706975c4e89ff805e" translate="yes" xml:space="preserve">
          <source>Changing of files' permissions.</source>
          <target state="translated">파일 권한 변경</target>
        </trans-unit>
        <trans-unit id="419e96b941fe3d26a3baefa01150ca56eff780d7" translate="yes" xml:space="preserve">
          <source>Channel support for threads. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">스레드에 대한 채널 지원 &lt;strong&gt;참고&lt;/strong&gt; : 이것은 시스템 모듈의 일부입니다. 직접 가져 오지 마십시오. 스레드 지원을 활성화하려면 &lt;code&gt;--threads:on&lt;/code&gt; 명령 행 스위치 를 사용하여 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0abdb5ab8a3afbc3386522492aae1bd812508530" translate="yes" xml:space="preserve">
          <source>Character class: If the character ahead appears in the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">캐릭터 클래스 : 캐릭터가 문자열 &lt;em&gt;s에&lt;/em&gt; 나타나면 , 그것을 소비하고 성공을 나타냅니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ce4e1be05a213a12afbc5b91825b11c73d700b6" translate="yes" xml:space="preserve">
          <source>Character device.</source>
          <target state="translated">캐릭터 장치.</target>
        </trans-unit>
        <trans-unit id="b86bbfa9fed7ada0a389375eb5146d27ca6ab1fb" translate="yes" xml:space="preserve">
          <source>Character literals</source>
          <target state="translated">문자 리터럴</target>
        </trans-unit>
        <trans-unit id="7e96bdb902b32980dacb34ac72b2007caf92e425" translate="yes" xml:space="preserve">
          <source>Character literals are enclosed in single quotes &lt;code&gt;''&lt;/code&gt; and can contain the same escape sequences as strings - with one exception: the platform dependent &lt;span id=&quot;newline_2&quot;&gt;newline&lt;/span&gt; (&lt;code&gt;\p&lt;/code&gt;) is not allowed as it may be wider than one character (often it is the pair CR/LF for example). Here are the valid &lt;span id=&quot;escape-sequences_2&quot;&gt;escape sequences&lt;/span&gt; for character literals:</source>
          <target state="translated">문자 리터럴은 작은 따옴표로 묶고 &lt;code&gt;''&lt;/code&gt; 문자열과 동일한 이스케이프 시퀀스를 포함 할 수 있습니다. 단 하나의 예외는 다음과 같습니다. 플랫폼 종속 &lt;span id=&quot;newline_2&quot;&gt;개행 문자&lt;/span&gt; ( &lt;code&gt;\p&lt;/code&gt; )는 한 문자보다 넓을 수 있으므로 허용되지 않습니다 (종종 CR / 예를 들어 LF). 문자 리터럴에 유효한 &lt;span id=&quot;escape-sequences_2&quot;&gt;이스케이프 시퀀스&lt;/span&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed1a1da8d910c3e98f7e3471a4032afafec5eb29" translate="yes" xml:space="preserve">
          <source>Character range: If the character ahead is one from the range &lt;em&gt;a&lt;/em&gt; through &lt;em&gt;b&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">문자 범위 : 앞의 문자가 &lt;em&gt;a&lt;/em&gt; ~ &lt;em&gt;b&lt;/em&gt; 범위의 문자 인 경우 소비하고 성공을 나타냅니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b6a6c483aae1575a0185147caca2a33f4a949438" translate="yes" xml:space="preserve">
          <source>Character type</source>
          <target state="translated">캐릭터 타입</target>
        </trans-unit>
        <trans-unit id="d50cd4e4889823f54696871b43521ee7b2cd7335" translate="yes" xml:space="preserve">
          <source>Character with decimal code &lt;em&gt;ddd&lt;/em&gt;.</source>
          <target state="translated">진수 코드 문자 &lt;em&gt;ddd를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="bf30516c00576762fbbb621668144d424821087b" translate="yes" xml:space="preserve">
          <source>Chars can be compared with the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. The &lt;code&gt;$&lt;/code&gt; operator converts a &lt;code&gt;char&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;. Chars cannot be mixed with integers; to get the ordinal value of a &lt;code&gt;char&lt;/code&gt; use the &lt;code&gt;ord&lt;/code&gt; proc. Converting from an integer to a &lt;code&gt;char&lt;/code&gt; is done with the &lt;code&gt;chr&lt;/code&gt; proc.</source>
          <target state="translated">문자는 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자 와 비교할 수 있습니다 . &lt;code&gt;$&lt;/code&gt; 의 연산자는 변환 &lt;code&gt;char&lt;/code&gt; A와 &lt;code&gt;string&lt;/code&gt; . 문자는 정수와 혼합 될 수 없습니다. &lt;code&gt;char&lt;/code&gt; 의 서수 값을 얻으려면 &lt;code&gt;ord&lt;/code&gt; proc을 사용하십시오 . 정수에서 &lt;code&gt;char&lt;/code&gt; 변환하는 것은 &lt;code&gt;chr&lt;/code&gt; proc로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="68664dd02e350ea5073e0ae4aa9b4b05b3c91960" translate="yes" xml:space="preserve">
          <source>Chat server</source>
          <target state="translated">채팅 서버</target>
        </trans-unit>
        <trans-unit id="929ff11e672655b0a3b8087213ef8d4a743bae97" translate="yes" xml:space="preserve">
          <source>Check if &lt;em&gt;s&lt;/em&gt; matches Nim's &quot;while&quot; keyword:</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 Nim의 &quot;while&quot;키워드와 일치 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cf370f6b8ec38a29e2432bba075fad77aab417e" translate="yes" xml:space="preserve">
          <source>Check if a &lt;code&gt;FutureStream&lt;/code&gt; is finished. &lt;code&gt;true&lt;/code&gt; value means that no more data will be placed inside the stream _&lt;a href=&quot;#and&quot;&gt;and&lt;/a&gt; that there is no data waiting to be retrieved.</source>
          <target state="translated">&lt;code&gt;FutureStream&lt;/code&gt; 이 완료 되었는지 확인하십시오 . &lt;code&gt;true&lt;/code&gt; 더 많은 데이터 스트림 _ 내부에 배치되지 않는다는 값 수단 &lt;a href=&quot;#and&quot;&gt;과&lt;/a&gt; 데이터가 검색 될 기다리고 있다는 것을.</target>
        </trans-unit>
        <trans-unit id="f166d2a8f7a171d1bb127378eb23732d41da0d11" translate="yes" xml:space="preserve">
          <source>Check if a &lt;span id=&quot;directory_1&quot;&gt;directory&lt;/span&gt;&lt;em&gt;dir&lt;/em&gt; exists, and create it otherwise.</source>
          <target state="translated">&lt;span id=&quot;directory_1&quot;&gt;디렉토리 &lt;/span&gt;&lt;em&gt;디렉토리&lt;/em&gt; 가 존재 하는지 확인 하고 그렇지 않으면 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="984fcebb18e75b7e703ed2015d054cab99f8aaec" translate="yes" xml:space="preserve">
          <source>Check two nodes for equality</source>
          <target state="translated">두 노드가 동일한 지 확인</target>
        </trans-unit>
        <trans-unit id="da7416e40baa75d7c56d32d6f86dd948f4e19c78" translate="yes" xml:space="preserve">
          <source>Checking the progress of a file transfer</source>
          <target state="translated">파일 전송 진행 상태 확인</target>
        </trans-unit>
        <trans-unit id="132dba3d8ecc2f1b5ab2812aeccdc98f5e82e566" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;osLastError&lt;/code&gt; for a valid error. If it has been reset it uses the last error stored in the socket object.</source>
          <target state="translated">유효한 오류가 &lt;code&gt;osLastError&lt;/code&gt; 를 확인 하십시오 . 재설정 된 경우 소켓 객체에 저장된 마지막 오류를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cc61b0718a3e619d1bd3a5d9f1cd5caf0d888789" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;bool&lt;/em&gt; variables</source>
          <target state="translated">두 &lt;em&gt;부울&lt;/em&gt; 변수 사이의 동등성을 확인 합니다</target>
        </trans-unit>
        <trans-unit id="6f860c207f2a11f0e1a3d019e6937c4ffa577ce1" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;char&lt;/em&gt; variables</source>
          <target state="translated">두 &lt;em&gt;문자&lt;/em&gt; 변수 사이의 동등성을 확인 합니다</target>
        </trans-unit>
        <trans-unit id="fb71cf56026acbd41603489b57883dd164a92da2" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;cstring&lt;/em&gt; variables.</source>
          <target state="translated">두 &lt;em&gt;cstring&lt;/em&gt; 변수가 &lt;em&gt;동일한 지 확인&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6693c72afaf2ac68bebd9822b5f0ce79ca5dfcae" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;string&lt;/em&gt; variables</source>
          <target state="translated">두 &lt;em&gt;문자열&lt;/em&gt; 변수 사이의 동등성을 확인 합니다</target>
        </trans-unit>
        <trans-unit id="5987179982937ecdc2f511a6d1b5e95c1f8fd6e8" translate="yes" xml:space="preserve">
          <source>Checks for equality between two variables of type &lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">유형 &lt;em&gt;집합의&lt;/em&gt; 두 변수가 동일한 지 확인&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99503e3efa2622079cb2940b4767dc3ac6ea82f5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;key&lt;/em&gt; exists in &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 &lt;em&gt;node에&lt;/em&gt; 있는지 확인 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a8474632e4fae06f8ce5b7c82b1279000374e87d" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or consists entirely of whitespace characters.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 nil인지 또는 공백 문자로만 구성되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c736c01c5bfa8a1c6f5bac3b24beb2893e45e7de" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or empty.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 nil인지 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="59f775bd733836ecb4200f87a57e67e9cfc67799" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;val&lt;/em&gt; exists in array &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">배열 &lt;em&gt;노드에 &lt;/em&gt;&lt;em&gt;val&lt;/em&gt; 이 있는지 확인 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f46cbda82eb5e9585af47785b7a218005abe05c4" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;value&lt;/em&gt; is within the range of &lt;em&gt;s&lt;/em&gt;; returns true iff &lt;em&gt;value &amp;gt;= s.a and value &amp;lt;= s.b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;값&lt;/em&gt; 이 &lt;em&gt;s&lt;/em&gt; 범위 내에 있는지 확인합니다 . iff &lt;em&gt;value&amp;gt; = sa 및 value &amp;lt;= sb를&lt;/em&gt; 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f0ff90bf51c73226b0a0ba5e93e479486fcfc7a" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;x&lt;/em&gt; has a type of &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">검사하는 경우 &lt;em&gt;, X는&lt;/em&gt; 일종의 가지고 &lt;em&gt;예를&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daf104d7238ae02de9f7b8d4b2ef3a9d0dd7836c" translate="yes" xml:space="preserve">
          <source>Checks if T is of the same type as S</source>
          <target state="translated">T가 S와 동일한 유형인지 확인</target>
        </trans-unit>
        <trans-unit id="3e2a37d26b80f14b9376ff0970807fa4ec421d07" translate="yes" xml:space="preserve">
          <source>Checks if a cookie of &lt;em&gt;name&lt;/em&gt; exists.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 쿠키가 존재 하는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="44e4d80ce5f7a1e55199005e073fe653afa2fabc" translate="yes" xml:space="preserve">
          <source>Checks if a string is an IP address Returns true if it is, false otherwise</source>
          <target state="translated">문자열이 IP 주소인지 확인합니다. 문자열이면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91fcb8e30c84d0132cb566b30317c70326d854cb" translate="yes" xml:space="preserve">
          <source>Checks if every item fulfills the predicate.</source>
          <target state="translated">모든 항목이 술어를 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af2565e07778c49efe297f906f075760048c0b14" translate="yes" xml:space="preserve">
          <source>Checks if some item fulfills the predicate.</source>
          <target state="translated">일부 항목이 술어를 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="239c89279a3bce5516e0481e4f55258a02a144dd" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;proc&lt;/em&gt; variables refer to the same procedure</source>
          <target state="translated">두 개의 &lt;em&gt;proc&lt;/em&gt; 변수가 동일한 프로 시저를 참조하는지 확인</target>
        </trans-unit>
        <trans-unit id="ca5e50261c267853c17b8d0483f9eeeb373544ad" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ptr&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">두 개의 &lt;em&gt;ptr&lt;/em&gt; 변수가 동일한 항목을 참조하는지 확인</target>
        </trans-unit>
        <trans-unit id="e8feb74c6a474812ed4a3894be2a37759dfadb64" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ref&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">두 개의 &lt;em&gt;ref&lt;/em&gt; 변수가 동일한 항목을 참조하는지 확인</target>
        </trans-unit>
        <trans-unit id="2efb60769de3f5e8c0d857e5d64a4a1d598026d9" translate="yes" xml:space="preserve">
          <source>Checks to see whether &lt;em&gt;a&lt;/em&gt; is already sorted in &lt;em&gt;order&lt;/em&gt; using &lt;em&gt;cmp&lt;/em&gt; for the comparison. Parameters identical to &lt;em&gt;sort&lt;/em&gt;</source>
          <target state="translated">점검 여부를 확인하기 위해 &lt;em&gt;A가&lt;/em&gt; 이미 정렬 &lt;em&gt;순서&lt;/em&gt; 사용하여 &lt;em&gt;CMP를&lt;/em&gt; 비교합니다. &lt;em&gt;정렬&lt;/em&gt; 과 동일한 매개 변수&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0fddbd515d81fc29a204bb7d47e5506b13b3dc" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is lower case.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 소문자 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a95f9a2833efadf810a077d161631c3c1a37d62b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is upper case.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 대문자 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c19cc9513c0bf1c1425112be49c299ffd561ef33" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is a root directory</source>
          <target state="translated">주어진 &lt;em&gt;경로&lt;/em&gt; 가 루트 디렉토리 인지 확인</target>
        </trans-unit>
        <trans-unit id="2b2e978aedf3c96424b9cc68407ee36744d6e1fe" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is absolute.</source>
          <target state="translated">주어진 &lt;em&gt;경로&lt;/em&gt; 가 절대 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ee4c2aa7f06d4dab8347c552766eb0e82241c0bc" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a lower case character.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 소문자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e62669610340d11599af3c49e990b8563987c907" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a number.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 숫자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dec21879462a972a9215d78983d9622f9e614ece" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a whitespace character.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 공백 문자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="66ef64629cfaff59e4dda1f006a57dd1a8b7a659" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphabetical.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 알파벳 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8bbff5e8bf3937ea9eac7179b7b1803460bcfd4b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 영숫자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="783f60adb58a778d0bdcb0ed1f898546ed698d6c" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is an upper case character.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 가 대문자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="96e7693a15498ac9fcc81a271241dceee25a1fa0" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a numeric value.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 숫자 값 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bdff523a789009cf024b82e48a29ed38f90b665d" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a unicode title.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 유니 코드 제목 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e633a4c42c8c1c1a6b480f4086e931c947915d1a" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphabetical.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 알파벳 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="05a69f1cbe4ef4451b315649a574990d236315ae" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 영숫자 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a4cb2611d9b736cb54c98723c01635d46689fc8b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is completely whitespace.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 완전히 공백 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5589a38b0e9e9fce2e0e9bb1532225529e28fbfc" translate="yes" xml:space="preserve">
          <source>Checks whether values within the &lt;em&gt;same enum&lt;/em&gt; have the same underlying value</source>
          <target state="translated">&lt;em&gt;동일한 열거 형&lt;/em&gt; 내의 값 이 동일한 기본 값을 갖는지 확인</target>
        </trans-unit>
        <trans-unit id="60654a8d0b43196c10e1df25c6c3376b674ea1de" translate="yes" xml:space="preserve">
          <source>Checks, whether &lt;em&gt;x&lt;/em&gt; has a property of name &lt;em&gt;prop&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 에 name &lt;em&gt;prop&lt;/em&gt; 속성이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8a71440783140db7ed4f5845038e0d0ef495c4b8" translate="yes" xml:space="preserve">
          <source>Classifies a floating point value. Returns &lt;em&gt;x&lt;/em&gt;'s class as specified by &lt;em&gt;FloatClass&lt;/em&gt;.</source>
          <target state="translated">부동 소수점 값을 분류합니다. &lt;em&gt;FloatClass에&lt;/em&gt; 의해 지정된 &lt;em&gt;x&lt;/em&gt; 의 클래스를 리턴 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0676a856119b9f43d3b722b7e1f13d155840cdb" translate="yes" xml:space="preserve">
          <source>Clear the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;excepts로&lt;/em&gt; 표시되는 지원되는 예외를 &lt;em&gt;지우십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bbdc3e1cf1b38d523d6171b4db601a4ff9f5cdbb" translate="yes" xml:space="preserve">
          <source>Clears the HashSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">기존 스토리지를 축소하지 않고 HashSet을 다시 빈 상태로 지 웁니다. O (n) 여기서 n은 해시 버킷의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="500eb6a58ee99ed5a10bac0307d2399525789e8b" translate="yes" xml:space="preserve">
          <source>Clears the OrderedSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">기존 스토리지를 축소하지 않고 OrderedSet을 다시 빈 상태로 지 웁니다. O (n) 여기서 n은 해시 버킷의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3253f000f2b69e9ea7ef993e1158952274e09f15" translate="yes" xml:space="preserve">
          <source>Clears the list of callbacks and sets the callback proc to be called when the future completes.</source>
          <target state="translated">콜백 목록을 지우고 향후 완료시 콜백 proc이 호출되도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="507ebd324f496a23794692a20495953cda164297" translate="yes" xml:space="preserve">
          <source>Clients can also use Postgres keyword/value connection strings to connect.</source>
          <target state="translated">클라이언트는 Postgres 키워드 / 값 연결 문자열을 사용하여 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9cbac01b8a8251fed166d82028202652414e266" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;sock&lt;/code&gt;. Terminates any current connections.</source>
          <target state="translated">&lt;code&gt;sock&lt;/code&gt; 닫습니다 . 현재 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a734b28e01c24d279132bdbcfaf68f5165797f44" translate="yes" xml:space="preserve">
          <source>Closes a socket and ensures that it is unregistered.</source>
          <target state="translated">소켓을 닫고 등록되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="caf7e77bedd43df5afff7efafdc353d87046a94d" translate="yes" xml:space="preserve">
          <source>Closes a socket.</source>
          <target state="translated">소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="1ced522c89f62b7dce08c4647da6d4cf514e789f" translate="yes" xml:space="preserve">
          <source>Closes any connections held by the HTTP client.</source>
          <target state="translated">HTTP 클라이언트가 보유한 모든 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="6e4ad07cceacc544c46a9fcbeb6a76c8d0de27a4" translate="yes" xml:space="preserve">
          <source>Closes event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">이벤트 &lt;code&gt;ev&lt;/code&gt; 를 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="33c90fcaa7ffb78d8a27467591953ef2c7afae9a" translate="yes" xml:space="preserve">
          <source>Closes the &lt;code&gt;AsyncScgiState&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AsyncScgiState&lt;/code&gt; 를 닫습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
