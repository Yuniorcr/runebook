<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">그러나 효율적인 작업은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">그러나 이후 버전의 언어는이를 &quot;본문에서 매개 변수 유형 유추&quot;를 의미하도록 변경할 수 있습니다. 그런 다음 위의 &lt;code&gt;foo&lt;/code&gt; 는 빈 &lt;code&gt;discard&lt;/code&gt; 명령문 에서 매개 변수의 유형을 유추 할 수 없으므로 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">그러나 이러한 기능은 문맥에 민감하지 않으며 단순히 문자열 일치에서만 작동합니다. 이는 특히 언어의 대소 문자를 구분하지 않기 때문에 Nim에서 문제가 될 수 있습니다 (더하기 기호는 구분 기호입니다!).</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">그러나 가장 큰 문제는 데드 코드 제거가 모듈성을 손상 시킨다는 것입니다! 이유를 확인하려면 다음 시나리오를 고려하십시오. 모듈 &lt;code&gt;G&lt;/code&gt; (예 : 거대한 Gtk2 모듈 ...)는 데드 코드 제거가 켜진 상태로 컴파일됩니다. 따라서 &lt;code&gt;G&lt;/code&gt; 의 procs는 전혀 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">그러나 반드시 형식 패턴을 분리 할 필요는 없습니다. &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; 와 같은 모호하지 않은 형식 문자열도 유효합니다 (1.9999 범위의 연도).</target>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">그러나 리터럴 값이이 작은 유형에 적합하고 이러한 변환이 다른 암시 적 변환보다 비용이 덜 드는 경우 &lt;code&gt;int&lt;/code&gt; 리터럴은 더 작은 정수 유형으로 암시 적으로 변환 가능하므로 &lt;code&gt;myInt16 + 34&lt;/code&gt; 는 &lt;code&gt;int16&lt;/code&gt; 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">그러나 일반 코드 에서는 &lt;code&gt;void&lt;/code&gt; 유형을 유추 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">그러나 사용 사례에 따라 &lt;code&gt;new Foo&lt;/code&gt; 를 대신 다음과 같이 포장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">그러나 C like 대상의 경우 외부 코드를 정적으로 또는 동적으로 연결해야합니다. 네이티브 코드를 통합하는 기본 방법은 관련 개발 라이브러리를 설치하지 않아도 Nim 프로그램을 컴파일 할 수 있도록 동적 링크를 사용하는 것입니다. 이것은 &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma를&lt;/a&gt; 통해 가져 오기 위해 수행 되지만 &lt;a href=&quot;dynlib&quot;&gt;dynlib 모듈&lt;/a&gt; 을 사용하면 더 구체적인 제어를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">그러나 하나 이상의 통계 계산이 필요한 경우 데이터를 RunningStat 개체로 한 번 푸시하고 RunningStat 개체에 대한 수많은 통계 프로세스를 호출하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">그러나 이제는 더 이상 서 수가 아니므로 이러한 열거 형을 배열의 인덱스 유형으로 사용할 수 없습니다. &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; , &lt;code&gt;succ&lt;/code&gt; 및 &lt;code&gt;pred&lt;/code&gt; 프로시 저도 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">그러나 템플릿은 varargs를 반복 할 수 없으므로이 기능은 일반적으로 매크로에 훨씬 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">그러나 때로는 최적화해야합니다. 다음 순서로 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">그러나 &lt;code&gt;header&lt;/code&gt; pragma가 종종 더 나은 대안입니다.</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">그러나 위의 코드는 컴파일되지 않습니다. 그 이유는 &lt;code&gt;n&lt;/code&gt; 에 포함될 수있는 모든 값을 포함해야하지만 코드는 &lt;code&gt;0..8&lt;/code&gt; 값만 처리하기 때문입니다. 입니다. 다른 모든 가능한 정수를 나열하는 것은 실용적이지 않기 때문에 (범위 표기법 덕분에 가능하지만) 컴파일러에게 다른 모든 값에 대해 아무것도 수행하지 말 것을 지시하여이를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">그러나, 제약 &lt;code&gt;alias&lt;/code&gt; 과 &lt;code&gt;noalias&lt;/code&gt; 는 일반 루틴에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">그러나 생성 된 C 코드는 플랫폼 독립적이지 않습니다. 예를 들어 Linux 용으로 생성 된 C 코드는 Windows에서 컴파일되지 않습니다. C 파일 위에 주석은 파일이 컴파일 된 OS, CPU 및 CC를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">그러나 &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt; , &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; 및 &lt;a href=&quot;times&quot;&gt;time&lt;/a&gt; 모듈 을 사용할 수 있습니다! DOM에 액세스하려면 &lt;a href=&quot;dom&quot;&gt;dom을&lt;/a&gt; 사용하십시오. JavaScript 플랫폼에서만 사용 가능한 모듈을 .</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">그러나 &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 기호 는 이미 바인드되어 다시 조회되지 않습니다. 예제에서 볼 수 &lt;code&gt;bindSym&lt;/code&gt; 은 오버로드 된 심볼에 대해 암시 적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">그러나, 문자열 / JSON되는 값은 매우 문제가있다 : 컴파일 타임 임베드에 내장되어 많은 룩업 테이블 &lt;em&gt;PROC은 바르&lt;/em&gt; 와 뚜렷한 캐릭터 라인 표현이없는 유형 ... AST가 diffing의 것 같다 여전히 사용이 필요하지 않으므로 좋은 생각이다 외계인 API이며 적어도 일부 기존 Nimble 패키지와 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">그러나 이것은 작동하지 않습니다. 문제는 프로 시저가 &lt;code&gt;return&lt;/code&gt; 뿐만 아니라 반복이 완료된 후에도 리턴하고 &lt;strong&gt;계속&lt;/strong&gt; 해야한다는 것 입니다. 이 &lt;em&gt;반환 및 계속을 &lt;/em&gt;&lt;em&gt;수익률&lt;/em&gt; 계산서 라고합니다 . 이제 남은 것은 &lt;code&gt;proc&lt;/code&gt; 키워드를 &lt;code&gt;iterator&lt;/code&gt; 로 바꾸는 것입니다. 여기 첫 번째 이터레이터가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">그러나 이것은 거의 필요하지 않습니다. 가장 일반적인 경우는 &lt;code&gt;e&lt;/code&gt; 에서 오류 메시지를 추출하는 것이며, 이러한 상황에서는 &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; 를 사용하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;closure&lt;/code&gt; 반복자를 사용 하여 다른 제한 집합을 얻을 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;퍼스트 클래스 반복자&lt;/a&gt; 를 참조하십시오. 반복자는 기본적으로 자체 네임 스페이스가 있으므로 proc과 동일한 이름 및 매개 변수를 가질 수 있습니다. 따라서 반복자의 결과를 누적 하고 &lt;a href=&quot;strutils&quot;&gt;strutils 모듈&lt;/a&gt; 에서 &lt;code&gt;split&lt;/code&gt; 과 같은 순서로 리턴하는 동일한 이름의 procs로 반복자를 랩핑하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 의 인간 친화적 인 문자열 표현 .</target>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">템플릿의 위생</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">여기서는 &lt;em&gt;셀&lt;/em&gt; 이라는 용어를 사용하여 추적되는 모든 항목 (시퀀스, 참조, 문자열)을 나타냅니다. 이 섹션에서는 GC 작동 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">IO 효과.</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">IPv4 매핑 주소.</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">IPv4 호환 주소.</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">식별자 맹 글링</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">식별자 구성</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">식별자 평등</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">식별자 및 키워드</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">식별자는 &lt;code&gt;nnkIdent&lt;/code&gt; 노드입니다. 이름 조회 통과 &lt;code&gt;nnkSym&lt;/code&gt; 노드 는 nnkSym 노드 로 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">식별자는 선언 시점부터 선언이 발생한 블록의 끝까지 유효합니다. 식별자가 알려진 범위는 식별자의 범위입니다. 식별자의 정확한 범위는 선언 된 방식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Nim의 식별자는 문자로 시작하는 모든 문자, 숫자 및 밑줄이 될 수 있습니다. 두 개의 즉각적인 밑줄 &lt;code&gt;__&lt;/code&gt; 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">블록의 버전을 식별합니다</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">idetools 호출</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Idetools 출력은 항상 탭 문자 ( &lt;code&gt;\t&lt;/code&gt; )로 구분 된 한 줄로 반환됩니다 . 각 열의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Idetools는 항상 단일 정의로 응답하거나 쿼리 위치와 일치하는 유효한 기호를 찾을 수 없으면 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">경우 &lt;code&gt;address&lt;/code&gt; &quot;입니다&quot;다음 ADDR_ANY가 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 읽을 수있는 데이터가 없어 오류가 발생한 경우 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">경우 &lt;code&gt;async&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 오류가 읽을 수 할 수있는 데이터 없음으로 인한 때 오류가 경우 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;break&lt;/code&gt; 점프-에 위치없이 사용, &lt;code&gt;nnkEmpty&lt;/code&gt; 는 대체 &lt;code&gt;nnkIdent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;cache&lt;/code&gt; 비어 있지의 결과 &lt;code&gt;staticExec&lt;/code&gt; 는 내에서 캐시 &lt;code&gt;nimcache&lt;/code&gt; 의 디렉토리. 사용하다 &lt;code&gt;--forceBuild&lt;/code&gt; 이 캐싱 동작을 제거 --forceBuild 를 . &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (연결된 문자열)는 캐시의 항목이 여전히 유효한지 확인하는 데 사용됩니다. &lt;code&gt;cache&lt;/code&gt; 버전 정보를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 를 즉시 전송할 수없는 경우 버퍼링되고 전송 될 때 &lt;code&gt;sock&lt;/code&gt; , &lt;code&gt;handleWrite&lt;/code&gt; 이벤트 중에 양말 이 쓰기 가능하게 . &lt;code&gt;data&lt;/code&gt; 의 일부만 즉시 전송되고 나머지는 버퍼링되어 나중에 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">경우 &lt;code&gt;err&lt;/code&gt; 0보다 낮은되지 않은 예외가 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">경우 &lt;code&gt;format == ffDecimal&lt;/code&gt; 후 정밀도가 자릿수 소수점 후 인쇄한다. 경우 &lt;code&gt;format == ffScientific&lt;/code&gt; 다음 정밀 인쇄 할 유효 숫자의 최대 수입니다.&lt;em&gt;precision&lt;/em&gt; 의 기본값은 Nim의 &lt;code&gt;biggestFloat&lt;/code&gt; 유형에 대한 소수점 뒤의 의미있는 최대 자릿수 입니다.</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">경우 &lt;code&gt;format == ffDecimal&lt;/code&gt; 후 정밀도가 자릿수 소수점 후 인쇄한다. 경우 &lt;code&gt;format == ffScientific&lt;/code&gt; 다음 정밀 인쇄 할 유효 숫자의 최대 수입니다. &lt;em&gt;정도&lt;/em&gt; 의 기본값은 Nim의 &lt;code&gt;float&lt;/code&gt; 유형에 대한 소수점 뒤의 의미있는 최대 자릿수 입니다.</target>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">&lt;code&gt;fut&lt;/code&gt; 하면 완료 먼저 반환 미래가 참 개최한다 그렇지 않으면, &lt;code&gt;timeout&lt;/code&gt; (밀리 초)이 처음 경과, 반환 된 미래는 false를 개최한다.</target>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">경우 &lt;code&gt;in&lt;/code&gt; 로 선언했다 &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; 후 &lt;code&gt;T&lt;/code&gt; 가 결합했을 &lt;code&gt;char&lt;/code&gt; . 그러나 &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;set[char]&lt;/code&gt; 유형과 호환되지 않습니다 ! 해결책은 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;range['a'..'z']&lt;/code&gt; 에 바인딩 하는 것 입니다. 이것은 &lt;code&gt;contains&lt;/code&gt; 매개 변수를 반대로함으로써 달성됩니다 . &lt;code&gt;in&lt;/code&gt; 역순으로 인수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">&lt;code&gt;maxLen == 0&lt;/code&gt; 경우 이진수의 길이는 더 상한 없다. 문자열의 길이까지 &lt;code&gt;start + maxLen&lt;/code&gt; 문자를 구문 분석 하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">만약 &lt;code&gt;maxLen == 0&lt;/code&gt; 16 진수의 길이는 더 상한 없다. 그 외에는 &lt;code&gt;start + maxLen&lt;/code&gt; 문자열의 길이까지 start + maxLen 문자를 구문 분석 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">만약 &lt;code&gt;maxLen == 0&lt;/code&gt; 8 진수의 길이는 더 상한 없다. 그 외에는 &lt;code&gt;start + maxLen&lt;/code&gt; 문자열의 길이까지 start + maxLen 문자를 구문 분석 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">경우 &lt;code&gt;nested&lt;/code&gt; 사실이다, 리터럴은 도처에서 교체 &lt;code&gt;constructor&lt;/code&gt; 그렇지 않으면 첫 번째 레벨로 간주됩니다, AST :</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">경우 &lt;code&gt;oneshot&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 타이머는 한 번만 통보를받을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">경우 &lt;code&gt;precision == -1&lt;/code&gt; , 멋지게 포맷을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">경우 &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true이고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 는 다음 값 중 하나입니다 : &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; , 다음 반환 &lt;em&gt;사실&lt;/em&gt; . 경우 &lt;code&gt;s&lt;/code&gt; : 다음 값 중 하나입니다 &lt;code&gt;n, no, false, 0, off&lt;/code&gt; 후 반환 &lt;em&gt;거짓&lt;/em&gt; . 경우 &lt;code&gt;s&lt;/code&gt; 뭔가 그 밖에 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 은 거짓, 모든 문자 경우에만 true를 돌려 &lt;code&gt;s&lt;/code&gt; 알파벳 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 은 거짓, true를 돌려에서만 모든 문자 경우 &lt;code&gt;s&lt;/code&gt; 알파벳 및 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 은 거짓, true를 돌려주는 경우에만 모든 룬 &lt;code&gt;s&lt;/code&gt; 알파벳 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 은 거짓, true를 돌려주는 경우에만 모든 룬 &lt;code&gt;s&lt;/code&gt; 알파벳 및 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 는 사실에있는 모든 알파벳 문자가있는 경우, true를 돌려 &lt;code&gt;s&lt;/code&gt; 는 소문자입니다. 반환 false의 경우에 문자 없음 &lt;code&gt;s&lt;/code&gt; 가 알파벳이 합니다.</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 는 사실에있는 모든 알파벳 문자가있는 경우, true를 돌려 &lt;code&gt;s&lt;/code&gt; 대문자입니다. 반환 false의 경우에 문자 없음 &lt;code&gt;s&lt;/code&gt; 가 알파벳이 합니다.</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 는 사실에있는 모든 알파벳 룬 경우, true를 돌려 &lt;code&gt;s&lt;/code&gt; 는 소문자입니다. &lt;code&gt;s&lt;/code&gt; 에 룬이 없으면 false를 반환합니다. 이 알파벳이 합니다.</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">경우 &lt;code&gt;skipNonAlpha&lt;/code&gt; 는 사실에있는 모든 알파벳 룬 경우, true를 돌려 &lt;code&gt;s&lt;/code&gt; 대문자입니다. &lt;code&gt;s&lt;/code&gt; 에 룬이 없으면 false를 반환합니다. 이 알파벳이 합니다.</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">만약 &lt;code&gt;socket&lt;/code&gt; 의 SSL 소켓입니다 악수가 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">만약 &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; 사실이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">만약 &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; 진정한하는 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 를 기다리는 경우 &lt;code&gt;fv&lt;/code&gt; 가 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 이 proc / iterator / converter 호출 &lt;code&gt;c(X)&lt;/code&gt; 의 결과 유형을 판별하는 데 사용되는 경우 (여기서 &lt;code&gt;X&lt;/code&gt; 는 비어있는 인수 목록을 나타냄) &lt;code&gt;c&lt;/code&gt; 가 반복자 인 해석은 다른 해석보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">경우 &lt;em&gt;fromRoot가&lt;/em&gt; 설정되어, 순회은 파일 시스템 루트 diretory에서 시작됩니다. 경우 &lt;em&gt;포함이&lt;/em&gt; 설정되어, 원래의 인수는 탐색에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">경우 &lt;em&gt;선도는&lt;/em&gt; 사실, 최고의 &lt;em&gt;문자가&lt;/em&gt; 제거됩니다. 경우 &lt;em&gt;후행는&lt;/em&gt; 사실, 후행입니다 &lt;em&gt;문자&lt;/em&gt; 제거됩니다. 둘 다 거짓이면 문자열이 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">경우 &lt;em&gt;linkTitle&lt;/em&gt; 또는 &lt;em&gt;linkDesc가&lt;/em&gt; 빈 문자열 아닌, 그 내용이 추가 열이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 이 &lt;em&gt;xnElement 인&lt;/em&gt; 경우&lt;em&gt;&lt;/em&gt; 인 각 하위 노드에서 재귀 적으로 실행되며 결과를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">경우 &lt;em&gt;, n은&lt;/em&gt; 입니다 &lt;em&gt;xnText&lt;/em&gt; 또는 &lt;em&gt;xnEntity&lt;/em&gt; , 그 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">경우 &lt;em&gt;n은&lt;/em&gt; A는 &lt;em&gt;는 jarray&lt;/em&gt; , 그것은 요소의 수를 돌려줍니다. 경우 &lt;em&gt;, n은&lt;/em&gt; A는 &lt;em&gt;하는 jobject는&lt;/em&gt; , 그것은 쌍의 수를 반환합니다. 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">경우 &lt;em&gt;n은&lt;/em&gt; A는 &lt;em&gt;SLIST&lt;/em&gt; , 그것은 요소의 수를 돌려줍니다. 경우 &lt;em&gt;, n은&lt;/em&gt; A는 &lt;em&gt;하는 jobject는&lt;/em&gt; , 그것은 쌍의 수를 반환합니다. 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">경우 &lt;em&gt;경로는&lt;/em&gt; 확장자가없는, &lt;em&gt;내선은&lt;/em&gt; 빈 문자열입니다. 경우 &lt;em&gt;경로&lt;/em&gt; 에는 디렉토리 구성 요소가없는, &lt;em&gt;디렉토리는&lt;/em&gt; 빈 문자열입니다. 경우 &lt;em&gt;경로&lt;/em&gt; 에는 파일 이름 구성 요소가없는 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;내선&lt;/em&gt; 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">경우 &lt;em&gt;장소&lt;/em&gt; 정상 수학 반올림 규칙에 따라 가장 가까운 정수 값으로 라운드 0 (또는 생략)이다 (예를 들어 &lt;em&gt;원형 (54.5) -&amp;gt; 55.0&lt;/em&gt; ). 경우 &lt;em&gt;장소&lt;/em&gt; 지정된 소수점 수, 예를 들면 원형으로, 0보다 큰 &lt;em&gt;&amp;gt; 54.35 - 라운드 (54.346, 2)&lt;/em&gt; . 경우 &lt;em&gt;장소는&lt;/em&gt; 소수의 장소, 예를 들어 왼쪽 라운드 부정적이며,&lt;em&gt; 둥근 (537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 에 &lt;em&gt;chars&lt;/em&gt; 에 &lt;em&gt;문자&lt;/em&gt; 가 없으면&lt;em&gt;&lt;/em&gt; -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">경우 &lt;em&gt;들&lt;/em&gt; 로 시작하지 않는 &lt;code&gt;prefix&lt;/code&gt; 로 끝 &lt;code&gt;suffix&lt;/code&gt; 에 ValueError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 유효한 이진 정수가 아닌 경우 &lt;em&gt;ValueError&lt;/em&gt; 가 발생합니다. &lt;em&gt;s&lt;/em&gt; 는 다음 선택적 접두사 중 하나를 가질 수 있습니다 : &lt;code&gt;0b&lt;/code&gt; , &lt;code&gt;0B&lt;/code&gt; . &lt;em&gt;s&lt;/em&gt; 내의 밑줄&lt;em&gt;&lt;/em&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 유효한 16 진 정수가 아닌 경우 &lt;em&gt;ValueError&lt;/em&gt; 가 발생합니다. &lt;em&gt;s&lt;/em&gt; 는 다음 선택적 접두사 중 하나를 가질 수 있습니다 : &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0X&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; . &lt;em&gt;s&lt;/em&gt; 내의 밑줄 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 유효한 정수가 아닌 경우 &lt;em&gt;ValueError&lt;/em&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 유효한 8 진 정수가 아닌 경우 &lt;em&gt;ValueError&lt;/em&gt; 가 발생합니다. &lt;em&gt;s&lt;/em&gt; 는 다음 선택적 접두사 중 하나를 가질 수 있습니다 : &lt;code&gt;0o&lt;/code&gt; , &lt;code&gt;0O&lt;/code&gt; . &lt;em&gt;s&lt;/em&gt; 내의 밑줄&lt;em&gt;&lt;/em&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">경우 &lt;em&gt;siPrefix가&lt;/em&gt; true로 설정되어, 수는 SI 접두어는 지수에 해당하는 표시됩니다. 예를 들어 4100은 &quot;4.1e3&quot;대신 &quot;4.1 k&quot;로 표시됩니다. 참고 &lt;em&gt;u는&lt;/em&gt; 1E-18 &amp;lt;F &amp;lt;1000e18 (1A &amp;lt;F &amp;lt;1000E)로 표시되는 범위의 절대 값을 외부와 ISO 2955. 번호에 따라 그리스 문자 뮤 (&amp;mu;) 대신에 마이크로 사용되는 &lt;em&gt;siPrefix&lt;/em&gt; 여부에 관계없이 SI 접두어가 아닌 지수&lt;em&gt;&lt;/em&gt; 가 true .</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">만약 &lt;em&gt; 확산&lt;/em&gt; 거짓이고 길이 &lt;em&gt;s는&lt;/em&gt; 의 배수가 아닌 &lt;em&gt;NUM&lt;/em&gt; 가진 제 1 서브 시퀀스 출력은 PROC 것 최대 &lt;code&gt;1 + len(s) div num&lt;/code&gt; 항목, 마지막 시퀀스 요소의 나머지를 이탈.</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">경우 &lt;em&gt;트림이&lt;/em&gt; true로 설정되어, 후행 0이 제거됩니다; false 인 경우 &lt;em&gt;정밀도&lt;/em&gt; 로 지정된 &lt;em&gt;자릿수&lt;/em&gt; 가 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">경우 &lt;em&gt;useUnitSpace가&lt;/em&gt; 참일 제공된 유닛합니다 (SI 규격에 의해 요구되는 공간)와 문자열에 추가한다. 이 동작은 지수의 유무에 따라 공간의 위치가 변경되므로 결과에 장치를 추가하는 것과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">선언 된 기호에 &lt;span id=&quot;asterisk_1&quot;&gt;별표&lt;/span&gt; 가 표시된 경우&lt;span id=&quot;asterisk_1&quot;&gt;&lt;/span&gt; 경우 현재 모듈에서 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">전체 라인을 검색 한 경우; &lt;code&gt;ReadFullLine&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">전체 라인을 검색 한 경우; &lt;code&gt;RecvFullLine&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">전체 라인을 읽을 경우 &lt;code&gt;\r\L&lt;/code&gt; 추가되지 않습니다 &lt;code&gt;line&lt;/code&gt; 그러나 전적으로 경우, &lt;code&gt;\r\L&lt;/code&gt; 다음 읽기되어 &lt;code&gt;line&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">전체 줄을 읽으면 &lt;code&gt;\r\L&lt;/code&gt; 이 결과에 추가되지 않지만 &lt;code&gt;\r\L&lt;/code&gt; 만 읽으면 결과가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">전체 라인이 수신되면 &lt;code&gt;\r\L&lt;/code&gt; 추가되지 않습니다 &lt;code&gt;line&lt;/code&gt; 그러나 전적으로 경우, &lt;code&gt;\r\L&lt;/code&gt; 만 수신 &lt;code&gt;line&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">줄이 &lt;code&gt;#&lt;/code&gt; 으로 완전히 무시되므로 주석에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">모듈이 두 개의 다른 모듈에 의해 식별자를 가져 오는 경우, 오버로드 된 프로 시저 또는 반복자가 아닌 경우 오버로드 해결이 발생하지 않는 한, 각 식별자가 규정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">노드가 작성된 것과 다른 문서에서 노드를 사용하는 경우 (지원하지 않는)</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">기본 개체가 매개 변수 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">proc에 &lt;code&gt;noinit&lt;/code&gt; pragma로 주석이 달린 경우 암시 적 &lt;code&gt;result&lt;/code&gt; 나타냅니다. 변수를 .</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;em&gt;아무것도&lt;/em&gt; 가리 &lt;code&gt;nil&lt;/code&gt; 않으면 값은 nil 입니다.</target>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">코드 섹션이 &lt;code&gt;M&lt;/code&gt; 레벨의 잠금을 보유하는 경우 &lt;code&gt;N &amp;lt; M&lt;/code&gt; 레벨의 잠금을 획득 할 수도 있습니다 . 레벨 &lt;code&gt;M&lt;/code&gt; 의 다른 잠금을 획득 할 수 없습니다. 동일한 수준의 자물쇠만을 취득 할 수 &lt;em&gt;동시에&lt;/em&gt; 단일 내의 &lt;code&gt;locks&lt;/code&gt; 부 :</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">구조화 된 유형에 파괴 가능한 유형의 필드가 있고 사용자가 명시적인 구현을 제공하지 않은 경우 구조화 된 유형에 대한 소멸자가 자동으로 생성됩니다. 사용자 정의 소멸자와 생성 된 소멸자에서 기본 클래스 소멸자에 대한 호출이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">유형 섹션이 일반 매개 변수를 사용하는 경우 여기에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">Nim의 메모리 관리자 또는 GC의 어설 션이 실패하면 스택 추적이 메모리 할당을 유지합니다! 따라서 스택 오버플로가 발생하여 실제 문제를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">이미 다른 곳에서 사용중인 속성을 추가하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">네임 스페이스와 관련하여 잘못된 방식으로 객체를 만들거나 변경하려는 경우</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">수정이 허용되지 않는 객체를 수정하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">기본 개체의 유형을 수정하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">존재하지 않는 컨텍스트에서 노드를 참조하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">사용할 수 없거나 더 이상 사용할 수없는 객체를 사용하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">기다리는 미래가 오류와 함께 완료되면 &lt;code&gt;await&lt;/code&gt; 는이 오류를 다시 발생시킵니다. 이를 피하기 위해 &lt;code&gt;await&lt;/code&gt; 대신 &lt;code&gt;yield&lt;/code&gt; 키워드를 사용할 수 있습니다 . 다음 섹션은 비동기 프로세스에서 예외를 처리 할 수있는 다양한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">오류가 발생하면 EOS가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">오류가 발생하면 EOS 예외가 발생합니다. 그렇지 않으면 반환 값은 수신 된 데이터의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">오류가 발생하면 OSError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">에러가 발생하면 반환 값은 &lt;code&gt;-1&lt;/code&gt; 이 됩니다. 그렇지 않으면 반환 값은 수신 된 데이터의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">짝수의 백 슬래시 뒤에 큰 따옴표가 있으면 백 슬래시 쌍마다 백 슬래시 하나가 argv 배열에 배치되고 큰 따옴표는 문자열 구분 기호로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">이니셜 라이저가 제공되면 유형을 생략 할 수 있습니다. 변수는 초기화 표현식과 동일한 유형입니다. 초기화 표현식이 없으면 변수는 항상 기본값으로 초기화됩니다. 기본값은 유형에 따라 다르며 항상 이진수 0입니다.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">유효하지 않거나 잘못된 문자열이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">홀수의 백 슬래시 뒤에 큰 따옴표가 있으면, 백 슬래시 쌍마다 하나의 백 슬래시가 argv 배열에 배치되고 나머지 백 슬래시에 의해 큰 따옴표가 &quot;탈출&quot;되어 리터럴 큰 따옴표 ( &quot; )를 argv에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">선택적 인수가 존재하면 다음 조회 알고리즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">단항 연산자의 첫 번째 문자 인 경우 &lt;code&gt;@&lt;/code&gt; 그것이 인 &lt;span id=&quot;sigilminuslike_1&quot;&gt;인장 같은&lt;/span&gt; 연산자보다 강한 결합 &lt;code&gt;primarySuffix&lt;/code&gt; 는 : &lt;code&gt;@x.abc&lt;/code&gt; 로 파싱 &lt;code&gt;(@x).abc&lt;/code&gt; 반면 &lt;code&gt;$x.abc&lt;/code&gt; 로 파싱 &lt;code&gt;$(x.abc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">노드가 속하지 않는 곳에 삽입 된 경우</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">어설 션이 해제되어 있으면 아무 것도 수행하지 않습니다. 어설 션이 설정되어 있으면 이후 버전에서는 유효한 구문에 대해 문자열을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">비동기 디스패처가 실행되고 있지 않으면 &lt;code&gt;cbproc&lt;/code&gt; 이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">비동기 디스패처가 실행중인 경우 다음 디스패처 틱 중에 &lt;code&gt;cbproc&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 호출이 실패한 경우; &lt;code&gt;RecvFail&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 호출이 실패한 경우; &lt;strong&gt;EOS 예외가 발생합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">데이터를 지원하지 않는 노드에 데이터가 지정된 경우</target>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">환경 변수 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 이 정의 된 경우 &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; 또는 &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) 또는 &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). 이 파일은 &lt;code&gt;--skipUserCfg&lt;/code&gt; 명령 행 옵션 으로 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">표현하면</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">미래가 이미 완료된 경우 &lt;code&gt;cb&lt;/code&gt; 가 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">head가 빈 문자열이면 tail이 반환됩니다. tail이 빈 문자열 인 경우 후행 경로 구분 기호와 함께 head가 반환됩니다. 꼬리가 경로 분리기로 시작하면 머리에 연결될 때 꼬리가 제거됩니다. 경계에없는 다른 경로 구분 기호는 수정되지 않습니다. 유닉스에 대한 더 많은 예 :</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">위의 예제에서 모듈 &lt;code&gt;B&lt;/code&gt; 가 다시 컴파일되지만 &lt;code&gt;A&lt;/code&gt; 가 그렇지 않은 경우 &lt;code&gt;B&lt;/code&gt; 에서 &lt;code&gt;toBool&lt;/code&gt; 이 &lt;em&gt;명시 적으로&lt;/em&gt; 참조되지 않더라도 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;toBool&lt;/code&gt; 을 인식해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">색인 또는 크기가 음수이거나 허용 된 값보다 큰 경우</target>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">더 많은 품목이 추가 될 것으로 예상되는 경우이를 호출하기 전에 해당 추가 수량을 매개 변수에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">보다 정확한 제어가 필요한 경우, 아포스트로피 ( &lt;code&gt;'&lt;/code&gt; ) 는 제공된 패턴에서 일반 유형의 콘크리트 유형 매개 변수를 표시하는 데 사용될 수 있습니다. 자세한 내용은 proc 패턴에서 아포스트로피 연산자 사용법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">nimcache에 동일한 프로젝트에 대해 다른 컴파일러의 컴파일 된 코드가 이미 포함되어 있으면 &lt;code&gt;-f&lt;/code&gt; 플래그를 추가하여 모든 파일을 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">데이터를 검색 할 수없는 경우 &lt;code&gt;ReadNone&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">예외 이름을 지정하지 않으면 현재 예외가 &lt;span id=&quot;reminusraised_1&quot;&gt;다시 발생&lt;/span&gt; 합니다. &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError의&lt;/span&gt; 재 인상에 예외가없는 경우 예외가 발생합니다. 것을 다음과 &lt;code&gt;raise&lt;/code&gt; 문은 &lt;em&gt;항상&lt;/em&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">객체의 경우 &lt;code&gt;a&lt;/code&gt; 에서 상속 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 의 하위 유형 인 &lt;code&gt;b&lt;/code&gt; . 이 하위 유형 관계는 &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; 유형으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">가능하면 name 매개 변수는 tz 데이터베이스에서 사용 된 이름과 일치해야합니다. 시간대가 tz 데이터베이스에 존재하지 않거나 시간대 이름을 알 수없는 경우 시간대를 명확하게 설명하는 문자열을 사용할 수 있습니다. 시간대 이름은 평등을 확인하는 데 사용됩니다!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">가능하면 이름은 tz 데이터베이스에서 사용되는 이름입니다. 시간대가 tz 데이터베이스에 없거나 시간대 이름을 알 수없는 경우 시간대를 명확하게 설명하는 문자열이 사용될 수 있습니다. 예를 들어, 문자열 &quot;LOCAL&quot;은 시스템 현지 시간대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">소켓의 연결이 끊어지고 읽을 수있는 데이터가없는 경우 미래는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 값으로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소켓의 연결이 끊어지고 읽을 수있는 데이터가없는 경우 미래는 &lt;code&gt;0&lt;/code&gt; 값으로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">recv 조작 중에 소켓이 연결 해제되면 요청 된 데이터의 일부만으로 미래가 완료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">일부 데이터가 검색된 경우 &lt;code&gt;ReadPartialLine&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">일부 데이터가 검색된 경우 &lt;code&gt;RecvPartialLine&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">if 문</target>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">'#'문자가 있으면 정수는 형식화에 '대체 형식'을 사용합니다. 이는 2 진, 8 진 및 16 진 출력 앞에 각각 '0b', '0o'및 '0x'가 붙는다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">는 IF &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;실험 모드가&lt;/a&gt; 활성화되고 다른 일치하는 항목이없는 첫 번째 인수의 &lt;code&gt;a&lt;/code&gt; 이 포인터 타입이고 과부하 해상도가 함께 노력하면 자동으로 역 참조 &lt;code&gt;a[]&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">는 IF &lt;code&gt;line&lt;/code&gt; 래그 매개 변수가 사용되는 매개 변수가 될 필요가있다 &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; . 매개 변수없이 사용하면 &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">는 IF &lt;code&gt;raise&lt;/code&gt; 키워드가 표현식이 따르지 마지막 예외가되어 &lt;em&gt;다시 제기&lt;/em&gt; . 이 공통 코드 패턴의 반복을 피하기 위해 &lt;code&gt;system&lt;/code&gt; 모듈 의 템플리트 &lt;code&gt;newException&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">&lt;code&gt;stackTrace&lt;/code&gt; 옵션이 켜져 있으면 생성 된 C에 프로그램이 충돌하거나 포착되지 않은 예외가 발생하는 경우 적절한 스택 추적이 제공되도록하는 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 에 확장자가없는, &lt;em&gt;내선이&lt;/em&gt; 추가됩니다. 경우 &lt;em&gt;내선&lt;/em&gt; == &quot;&quot;다음 확장자가 제거됩니다. 일부 파일 시스템은 다른 문자를 사용할 수 있으므로 선행 '.'없이 &lt;em&gt;Ext를 제공&lt;/em&gt; 해야합니다. (나는 그런 짐승은 아무도 모른다.)</target>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">GNU 어셈블러를 사용하면 따옴표와 줄 바꿈이 자동으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">대기 한 선물 &lt;em&gt;이 &lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; 인 경우이 proc은 &lt;code&gt;Future[void]&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">대기 한 선물이 &lt;code&gt;Future[void]&lt;/code&gt; 가 아닌 경우 반환 된 미래는 모든 대기 된 선물의 값을 순서대로 보유합니다.</target>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">파일이 없으면 &lt;em&gt;EIO&lt;/em&gt; 가 발생합니다. 후행 줄 바꿈 문자는 반복 된 행에서 제거됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">파일 포인터가 파일의 끝을 지나면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">파일 포인터가 파일의 끝을 지나면 0이 반환되고 &lt;code&gt;buf&lt;/code&gt; 로 바이트를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">for 루프 표현식 &lt;code&gt;e&lt;/code&gt; 가 반복자를 나타내지 않고 for 루프에 정확히 1 개의 변수가 있으면 for 루프 표현식이 &lt;code&gt;items(e)&lt;/code&gt; 다시 작성됩니다 . 즉. &lt;code&gt;items&lt;/code&gt; 반복자는 암시 적으로 호출된다 :</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">for 루프에 정확히 2 개의 변수가 있으면 &lt;code&gt;pairs&lt;/code&gt; 반복자가 내재적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">형식 매개 변수 &lt;code&gt;f&lt;/code&gt; 가 일반 유형 검사 외에 &lt;code&gt;var T&lt;/code&gt; 유형 인 경우 인수는 &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value로&lt;/span&gt; 검사됩니다 . &lt;code&gt;var T&lt;/code&gt; 조금만 더 이상 일치 &lt;code&gt;T&lt;/code&gt; 다음.</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">미래 스트림에 이미 데이터가 있거나 완료된 경우 &lt;code&gt;cb&lt;/code&gt; 가 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">핸들러가 예외를 발생시키지 않으면 일반 제어 플로우가 계속되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">구현이 요청 된 유형의 객체 또는 작업을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">파일 핸들이 유효하지 않은 경우와 같이 정보를 검색 할 수 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">경로가 존재하지 않거나 권한 제한으로 인해 프로그램이 파일 정보를 검색 할 수없는 경우와 같이 정보를 검색 할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">반복자가 튜플을 생성하면 튜플에 구성 요소가있는만큼 반복 변수가있을 수 있습니다. i 번째 반복 변수의 유형은 i 번째 구성 요소의 유형입니다. 즉, for 루프 컨텍스트에서 암시 적 튜플 언 패킹이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">연산자가 &lt;code&gt;=&lt;/code&gt; 로 끝나고 첫 번째 문자가 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; ,!가 아닌 경우 &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , 그것은 인 &lt;em&gt;할당 연산자&lt;/em&gt; 번째로 낮은 우선 순위를 갖는다.</target>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">proc 선언에 본문이 없으면 &lt;span id=&quot;forward_1&quot;&gt;정방향&lt;/span&gt; 선언입니다. proc가 값을 리턴하면 프로 시저 본문은 리턴 값을 나타내는 &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; 라는 내재적으로 선언 된 변수에 액세스 할 수 있습니다 . 프로세스가 오버로드 될 수 있습니다. 과부하 해결 알고리즘은 인수에 가장 적합한 proc을 결정합니다. 예:</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">프로 시저가 호출자의 인수를 수정해야하는 경우 &lt;code&gt;var&lt;/code&gt; 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">미래의 결과가 오류이면 해당 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">결과 문자열이 원래 입력 문자열보다 길지 않은 경우 단일 메모리 할당 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">소켓이 분리 된 경우; &lt;code&gt;ReadDisconnected&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">소켓이 분리 된 경우; &lt;code&gt;RecvDisconnected&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">줄 중간에 ( &lt;code&gt;\r\L&lt;/code&gt; 을 읽기 전에) 소켓의 연결이 끊어지면 줄은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정됩니다 . 부분 라인&lt;strong&gt; 이 손실됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">소켓이 분리되면 &lt;code&gt;line&lt;/code&gt; 이 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정 되고 &lt;code&gt;True&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">소켓이 분리되면 &lt;code&gt;line&lt;/code&gt; 이 &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">소켓이 분리되면 결과는 &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">지정된 범위의 텍스트가 현재 사용되지 않는 DOMString에 맞지 않는 경우 (DOMString은 문자열이므로)</target>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TaintedString&lt;/code&gt; 모드가 꺼져 있으면 TaintedString 은 단순히 &lt;code&gt;string&lt;/code&gt; 의 별칭입니다. .</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">&lt;code&gt;--taintMode:on&lt;/code&gt; 명령 줄 옵션을 통해 오염 모드가 켜져 있으면 입력 유효성 검사 오류를 감지하는 데 도움이되는 고유 한 문자열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">템플릿 매개 변수에 대한 유형이없는 경우, 내부 타입 식별자 &lt;code&gt;nnkFormalParams&lt;/code&gt; 는 단지하게 &lt;code&gt;nnkEmpty&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">템플리트에 명시적인 리턴 유형이없는 경우 &lt;code&gt;void&lt;/code&gt; 는 프로세스 및 메소드와의 일관성을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">너비 필드 앞에 영 ( '0') 문자가 있으면 영 (0) 채움이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 부분 이 있으면 예외 처리기 이후에 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">&lt;span id=&quot;finally_1&quot;&gt;마지막으로&lt;/span&gt; 있다면&lt;span id=&quot;finally_1&quot;&gt;&lt;/span&gt; 절이 예외 처리기 이후에 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">소켓에서 읽을 데이터가 없으면 &lt;code&gt;False&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">이 알고리즘은 반환 &quot;모호한&quot;더욱 명료화 행하는 경우 인수 경우 일치 두 파라미터 타입 &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;g&lt;/code&gt; 의 &lt;code&gt;q&lt;/code&gt; 하위 유형 관계를 통해이 상속 깊이가 고려된다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. Windows 플랫폼에서이 프로세스는 속성을 &lt;em&gt;source&lt;/em&gt; 에서 &lt;em&gt;dest&lt;/em&gt; 로 복사합니다 . 다른 플랫폼에서 작성된 파일 및 디렉토리는 사용자에 대해 새로 작성된 파일 / 디렉토리의 기본 권한을 상속합니다. 이러한 플랫폼에서 속성을 재귀 적으로 유지하려면 &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions ()를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. Windows 플랫폼에서이 proc은 소스 파일의 속성을 dest로 복사합니다. 다른 플랫폼에서는 &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; 및 &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions ()&lt;/a&gt; 를 사용하여 직접 복사하거나 편리한 &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; proc을 사용해야합니다 . 그렇지 않으면 &lt;em&gt;dest&lt;/em&gt; 는 새로 작성된 파일의 기본 권한을 사용자에게 상속합니다. 경우 &lt;em&gt;이명 령은&lt;/em&gt; 이미 존재하는 파일 속성은 보존 및 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. 디렉토리가 처음에 존재하지 않았더라도 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. 이 래퍼의 PROC입니다 &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; 및 &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; 비 Windows 플랫폼에서. Windows에서이 proc은 &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; 의 래퍼 일뿐 입니다. 해당 proc은 이미 속성을 복사하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">우리가 사용하는 경우 &lt;code&gt;from ... import&lt;/code&gt; , 결과도 다르다.</target>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">테이블의 키에 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 과 같은 간단한 표준 유형을 사용하는 경우 아무런 문제가 없지만 더 복잡한 객체를 키로 사용하려고하면 이상한 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">모든 테스트 케이스 파일을 실행하지 않으려면 하위 문자열을 매개 변수로 &lt;code&gt;caasdriver&lt;/code&gt; 에 전달할 수 있습니다 . 전달 된 하위 문자열과 일치하는 파일 만 실행됩니다. 필터링은 globbing 메타 문자를 사용하지 않으며 일반 일치합니다. 예를 들어, 상세 모드에서 &lt;code&gt;*-compile*.txt&lt;/code&gt; 테스트 만 실행하려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">일반 이름 기호를 하이퍼 링크로 연결하고 동일한 HTML 파일에 다른 일치 항목이있는 경우 대부분의 브라우저가 첫 번째 브라우저로 이동합니다. 나머지를 구별하려면 복잡한 이름을 사용해야합니다. 호출 가능한 유형의 복잡한 이름은 여러 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">수행중인 작업을 알고 있다면 단일 문자열 (또는 시퀀스) 객체를 &lt;span id=&quot;shallow_1&quot;&gt;얕은&lt;/span&gt; 것으로 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">비동기 서버 소켓이 필요하지만 클라이언트를 동 기적으로 처리하려는 경우 &lt;code&gt;getSocket&lt;/code&gt; 변환기를 사용 하여 &lt;code&gt;AsyncSocket&lt;/code&gt; 객체 에서 &lt;code&gt;Socket&lt;/code&gt; 을 가져올 수 있습니다. 그러면 다음과 같이 &lt;code&gt;accept&lt;/code&gt; 와 결합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">키가있는 시퀀스가 ​​필요한 경우 반복자에서 &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq ()&lt;/a&gt; 를 사용할 수 있습니다 . 사용 예 :</target>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">당신이해야하는 경우 &lt;em&gt;액세스&lt;/em&gt; 내부 실제 예외 객체 또는 메시지를 &lt;code&gt;except&lt;/code&gt; 지점 당신은 사용할 수 있습니다 &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException ()&lt;/a&gt; 및 &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg ()&lt;/a&gt; 로부터 발동 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈을. 예:</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">첫 번째 &lt;code&gt;include&lt;/code&gt; 지시문 을 허용 하거나 생성 된 출력을 조정 &lt;code&gt;RstGenerator&lt;/code&gt; 경우 &lt;code&gt;initRstGenerator&lt;/code&gt; 및 관련 프로세스 를 사용하여 자체 RstGenerator 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">여러 식별자를 만들어야하는 경우 하위 수준 인 &lt;code&gt;newNimNode&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">Nim이 할당 한 메모리를 C로 전달해야하는 경우 &lt;code&gt;GC_ref&lt;/code&gt; 및 &lt;code&gt;GC_unref&lt;/code&gt; 를 사용 하여 GC에 의해 해제되지 않도록 객체를 참조로 표시 할 수 있습니다. 메모리를 추적하는 데 사용할 수있는 &lt;a href=&quot;system&quot;&gt;시스템의&lt;/a&gt; 다른 유용한 프로세서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x.len()&lt;/code&gt; 에서와 같이 Nim의 유연한 호출 구문을 사용하는 경우 결과는 위와 동일하지만 &lt;code&gt;nnkCall&lt;/code&gt; 로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">이 함수를 사용하는 경우 IOCP를 사용하므로 asyncdispatch.recv () 또는 asyncdispatch.accept ()를 사용할 필요가 없습니다. 대신 nativesockets.recv () 및 nativesockets.accept ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">이 함수를 사용하는 경우 IOCP를 사용하므로 asyncdispatch.send () 또는 asyncdispatch.connect ()를 사용할 필요가 없습니다. 대신 nativesockets.send () 및 nativesockets.connect ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">기존 코드에 &lt;code&gt;{.raises.}&lt;/code&gt; pragma 를 추가하려는 경우 컴파일러가 도움을 줄 수도 있습니다. 당신은 추가 할 수 있습니다 &lt;code&gt;{.effects.}&lt;/code&gt; 당신의 PROC로 프라그 문을 컴파일러가 출력 모두 그 시점까지 효과를 (예외 추적 님의 효과 시스템의 일부입니다) 추정. proc에 의해 발생한 예외 목록을 찾는 또 다른 방법 은 전체 모듈에 대한 문서를 생성하고 모든 예외를 발생한 예외 목록으로 장식 하는 Nim &lt;code&gt;doc2&lt;/code&gt; 명령 을 사용 하는 것입니다. Nim의 &lt;a href=&quot;manual#effect-system&quot;&gt;효과 시스템 및 관련 pragma에&lt;/a&gt; 대한 자세한 내용 은 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">사용자 정의 유형에 해시 프로세스를 구현하려면 다음과 같은 코드를 작성하게됩니다.</target>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">다시로드 할 때마다 전역 변수의 상태를 재설정하려면 최상위 코드 내에서 값을 다시 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">자체 문서에서이 기능을 재사용 하려면 자신의 코드 저장소에 대한 하이퍼 링크와 함께 &lt;code&gt;doc.item.seesrc&lt;/code&gt; 값 을 포함 하도록 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 를 수정 해야합니다. 해당 파일의 주석에서 볼 수 있듯이 명령 행에 전달 된 &lt;code&gt;txt&lt;/code&gt; 값 은 &lt;code&gt;$path&lt;/code&gt; 및 &lt;code&gt;$line&lt;/code&gt; 과 같은 HTML 템플리트에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">stdin / stdout을 통신으로 사용하여 서버를 시작하려면 다음을 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">tcp 및 포트를 사용하여 서버를 시작하려면 다음을 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">콜백을 제거하려면 간단히 &lt;code&gt;nil&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">사용자 정의 유형에 &lt;code&gt;strings&lt;/code&gt; 로 구성된 객체와 같이 해시 프로세스가 이미있는 필드가 포함 된 경우 개별 필드의 해시 값을 함께 해시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">폐기 명령문을 사용하지 않고 프로 시저의 리턴 값을 무시하는 것은 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">구현 별 프라 그마</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">(A)의 구현 &lt;span id=&quot;deque_1&quot;&gt;양단 큐&lt;/span&gt; (덱). 기본 구현은 &lt;code&gt;seq&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">단독 연결 및 이중 연결 목록 구현 그렇게하는 것은 의미가 없으므로 '다음'및 '이전'포인터는 숨겨져 있지 않으며 효율성을 위해 직접 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">님의 '스폰'을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">관련 항목 / 쌍 호출</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">가져 오기 섹션</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">수입 명세서</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">ImportCpp pragma</target>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC pragma</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">수입 프라 그마</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">열거 형을위한 Importcpp</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">객체에 대한 Importcpp</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">procs 용 importcpp</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">가져온 예외</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">다른 문서에서이 문서로 노드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">불결한 라이브러리</target>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">에서 &lt;code&gt;if&lt;/code&gt; 문 새로운 범위는 직후 시작 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 키워드 종료 후 해당 &lt;em&gt;다음&lt;/em&gt; 블록. 시각화 목적으로 범위는 &lt;code&gt;{| |}&lt;/code&gt; 다음 예에서 |} :</target>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">Nim에서는 예외가 있습니다. 일반적으로 예외 유형은 'Error'로 접미사가 붙습니다. &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈은에 충실 할 수 있다는 예외 계층 구조를 정의합니다. 예외 는 공통 인터페이스를 제공하는 &lt;code&gt;system.Exception&lt;/code&gt; 에서 파생 됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">Nim에서 새로운 타입은 &lt;code&gt;type&lt;/code&gt; 문장 내에서 정의 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">Nim에서 컴파일러는 참조가 스택에 저장되어 있는지 여부를 항상 알 수 없습니다. 이것은 var 매개 변수로 인해 발생합니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">님에서 &lt;em&gt;간단한 진술&lt;/em&gt; 과 &lt;em&gt;복잡한 진술&lt;/em&gt; 사이에는 차이가 있습니다. &lt;em&gt;단순 명령문&lt;/em&gt; 은 다른 명령문을 포함 할 수 없습니다. 지정, 프로 시저 호출 또는 &lt;code&gt;return&lt;/code&gt; 명령문은 단순 명령문에 속합니다. &lt;em&gt;복합 문은&lt;/em&gt; 원하는 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 다른 문을 포함 할 수 있습니다. 모호성을 피하기 위해 복잡한 명령문은 항상 들여 쓰기해야하지만 간단한 단일 명령문은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">UTF-8 모드에서 128보다 큰 값을 가진 문자는 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 또는 &lt;code&gt;\w&lt;/code&gt; 와 일치하지 않으며 항상 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다. 유니 코드 문자 속성 지원을 사용할 수있는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">A의 &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 문 튜플 풀기 수행 할 수 있습니다. 특수 식별자 &lt;code&gt;_&lt;/code&gt; 를 사용하여 튜플의 일부를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">호출 &lt;code&gt;p(args)&lt;/code&gt; 에서 가장 일치 하는 루틴 &lt;code&gt;p&lt;/code&gt; 가 선택됩니다. 여러 루틴이 동일하게 일치하면 컴파일 타임에 모호성이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">명령문 목록에서 마지막 표현식을 제외한 모든 표현식은 &lt;code&gt;void&lt;/code&gt; 유형을 가져야합니다 . 이 규칙 외에도 내장 &lt;code&gt;result&lt;/code&gt; 기호에 대한 지정은 후속 표현식에 대해 필수 &lt;code&gt;void&lt;/code&gt; 컨텍스트를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">다중 메소드에서 오브젝트 유형이있는 모든 매개 변수가 디스패치에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">&lt;code&gt;GC_ref&lt;/code&gt; 및 &lt;code&gt;GC_unref&lt;/code&gt; 외에도 &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;allocShared&lt;/code&gt; 또는 &lt;code&gt;allocCStringArray&lt;/code&gt; 와 같은 procs로 메모리를 수동으로 할당하여 GC를 피할 수 있습니다 . GC는 해방을 시도하지 않을 것입니다. &lt;em&gt;거래가&lt;/em&gt; 완료되면 각각의 &lt;em&gt;거래소&lt;/em&gt; 쌍 을 불러야합니다 .</target>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">필드 외에도 일상적인 응용 프로그램도 다시 작성되지만 호출에 대한 다른 해석이 불가능한 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">타입 검사를 방해하는 타입 이 &lt;code&gt;untyped&lt;/code&gt; 메타 타입 이외에도 &lt;code&gt;varargs[untyped]&lt;/code&gt; 있어서 파라미터의 개수조차 고정되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">이전 레벨 외에도 컴파일러 개발자를위한 디버그 스택 추적을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">서명 및 부호없는 정수에 대한 일반적인 산술 연산자에 추가하여 ( &lt;code&gt;+ - *&lt;/code&gt; 등) 운영자는 해당 공식적 작업도있다 &lt;em&gt;서명&lt;/em&gt; 정수 있지만 그들의 주장을 치료하는 &lt;em&gt;서명되지 않은&lt;/em&gt; : 그들은 주로 언어 그 이전 버전의 이전 버전과의 호환성을 위해 제공됩니다 부호없는 정수 유형이 없습니다. 부호없는 정수에 대한 부호없는 연산은 &lt;code&gt;%&lt;/code&gt; 접미사를 규칙으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">객체 유형의 모든 하위 유형에서.</target>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">두 경우 모두 서버가 시작되고 추가 명령을 기다립니다. 이제 서버로 보낼 수있는 명령 구문은 명령 줄에서 nim 컴파일러를 실행하는 것과 거의 동일하므로 이미 대화하고 있으므로 컴파일러 이름 만 제거하면됩니다. 서버는 필요한 것으로 생각되는 많은 텍스트 행과 응답의 끝을 나타내는 빈 행으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">이와는 대조적으로 &lt;span id=&quot;closure-iterator_1&quot;&gt;클로저 이터레이터&lt;/span&gt; 를보다 자유롭게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">디버그 모드에서는 예외를 유발 한 스택 추적을 저장합니다. StackTraceEntry는 스택 추적의 단일 항목입니다.</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">모든 모듈 컴파일에서 변수를 기본값으로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">실제로 모든 튜플 구성마다 후행 쉼표가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">실제로 이것은 AST가 &quot;얕은&quot;트리로 데이터베이스에 저장되는 방법을 설명합니다. 다음 내용으로 모듈 &lt;code&gt;m&lt;/code&gt; 을 컴파일한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">일반적으로 case 문은 하위 범위 유형 또는 열거에 사용되며 컴파일러에서 가능한 값을 커버했는지 확인하는 데 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">일반 타입을 선언하는 거울이 구 (즉, &lt;code&gt;nnkStaticTy&lt;/code&gt; 위한 &lt;code&gt;static&lt;/code&gt; 등). 예는 다음과 같습니다 ( &lt;code&gt;*&lt;/code&gt; 로 표시된 예외 ).</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">일반적으로 동적 라이브러리를 가져 오는 데 특별한 링커 옵션이나 가져 오기 라이브러리와의 링크가 필요하지 않습니다. 이는 또한 &lt;em&gt;devel&lt;/em&gt; 패키지를 설치할 필요 가 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">매우 구체적인 경우 (예 : 바이트 코드 인터프리터의 디스패치 루프) 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">많은 상황에서 Nim을 사용하면 유형 이름을 일반 값으로 취급 할 수 있습니다. 이러한 값은 컴파일 단계 중에 만 존재하지만 모든 값은 유형을 가져야하므로 &lt;code&gt;type&lt;/code&gt; 은 특수 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">일반적인 디버그 및 릴리스 빌드에서 &lt;code&gt;runnableExamples&lt;/code&gt; 섹션 내의 코드 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">모든 종류의 파일 전송을 시작하려면 먼저 FTP 서버에 연결해야합니다. 당신은에 그렇게 할 수 있습니다 &lt;code&gt;connect&lt;/code&gt; 절차.</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 매개 변수를 허용하는 기호를 확인 하려면 형식 앞에 명시 적 &lt;code&gt;type&lt;/code&gt; 수정자를 붙여야합니다 . &lt;code&gt;concept&lt;/code&gt; 키워드 뒤에 오는 유형의 명명 된 인스턴스 도 명시 적 수정자를 갖는 것으로 간주되며 유형으로 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">Nim을 올바르게 컴파일하려면 형식 검사를 구문 분석과 분리해야합니다. 그렇지 않으면 제네릭이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">일부 텍스트를 인코딩하려면 간단히 &lt;code&gt;encode&lt;/code&gt; 절차 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">구조 유형 검사를 단순화하기 위해 재귀 튜플은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">이 모듈에 정의 된 SSL 프로 시저를 사용하려면 &lt;code&gt;-d:ssl&lt;/code&gt; 플래그 를 사용하여 응용 프로그램을 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">일반적인 객체 지향 언어에서 프로 시저 ( &lt;em&gt;메소드&lt;/em&gt; 라고도 함 )는 클래스에 바인딩됩니다. 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95f94a22baed9e59f27d8a4126864041ec912710" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite.</source>
          <target state="translated">즉, &lt;code&gt;result&lt;/code&gt; 가리키는 수명은 첫 번째 매개 변수의 수명에 연결되며 이는 호출 사이트에서 메모리 안전성을 검증하기에 충분한 지식입니다.</target>
        </trans-unit>
        <trans-unit id="102f6667e274b32df706ad020620d76cc4f12944" translate="yes" xml:space="preserve">
          <source>In other words, the macro needs to transform the full &lt;code&gt;case&lt;/code&gt; statement but only the statement's selector expression is used to determine which macro to call.</source>
          <target state="translated">다시 말해, 매크로는 &lt;code&gt;case&lt;/code&gt; 문 을 변환해야 하지만 명령문의 선택자 표현식 만 사용하여 호출 할 매크로를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f0ffdfd405410c78e024047ef7872e44df7c644e" translate="yes" xml:space="preserve">
          <source>In practice, things are worse still, consider &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt;. We only know the root is &lt;code&gt;someGlobal&lt;/code&gt; but the concrete path to the data is unknown as is the value that is added. We could compute a &quot;diff&quot; between the global states and use that to compute a symbol patchset, but this is quite some work, expensive to do at runtime (it would need to run after every module has been compiled) and also would break for hash tables.</source>
          <target state="translated">실제로는 상황이 여전히 나빠집니다. &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt; . 우리는 루트가 &lt;code&gt;someGlobal&lt;/code&gt; 이라는 것을 알고 있지만 추가되는 값만큼 데이터의 구체적인 경로는 알 수 없습니다. 우리는 전역 상태 사이의 &quot;차이&quot;를 계산하고 그것을 사용하여 기호 패치 세트를 계산할 수 있지만, 이는 런타임에 수행하는 데 많은 비용이 들며 (모든 모듈이 컴파일 된 후에 실행해야 함) 또한 중단됩니다. 해시 테이블.</target>
        </trans-unit>
        <trans-unit id="b855cc2f2c105e6dd103557865ed5b380e3a2628" translate="yes" xml:space="preserve">
          <source>In raw literals the backslash is not an escape character.</source>
          <target state="translated">원시 리터럴에서 백 슬래시는 이스케이프 문자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7f10b9ab29ce16208f7daf440d19bf68a4e424e" translate="yes" xml:space="preserve">
          <source>In templates identifiers can be constructed with the backticks notation:</source>
          <target state="translated">템플릿에서 식별자는 백틱 표기법으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2768586236fda36fbb8835c6640e3bbf9f72b7a" translate="yes" xml:space="preserve">
          <source>In the above example, because the string ends in a period, to get the portion of the string that is &quot;useless&quot; and replace it with &quot;useful&quot;.</source>
          <target state="translated">위의 예에서 문자열은 마침표로 끝나기 때문에 &quot;무용 지&quot;인 문자열 부분을 가져 와서 &quot;유용한&quot;문자열로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="1c735dfcff9ac999e211c2de3309c6b523627b0e" translate="yes" xml:space="preserve">
          <source>In the above example, providing the -d flag causes the symbol &lt;code&gt;FooBar&lt;/code&gt; to be overwritten at compile time, printing out 42. If the &lt;code&gt;-d:FooBar=42&lt;/code&gt; were to be omitted, the default value of 5 would be used.</source>
          <target state="translated">위의 예에서 -d 플래그를 제공하면 컴파일시 &lt;code&gt;FooBar&lt;/code&gt; 기호 를 덮어 쓰고 42를 인쇄합니다. &lt;code&gt;-d:FooBar=42&lt;/code&gt; 를 생략하면 기본값 5가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef0c534b48c5ddbaf66e5a1fa0de3c409abe7be" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;recv&lt;/code&gt; function will return a brand new &lt;code&gt;Future&lt;/code&gt; instance once the request for data to be read from the socket is made. This &lt;code&gt;Future&lt;/code&gt; instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to &lt;code&gt;stdout&lt;/code&gt;. The &lt;code&gt;read&lt;/code&gt; function is used for this and it checks whether the future completes with an error for you (if it did it will simply raise the error), if there is no error however it returns the value of the future.</source>
          <target state="translated">위의 예에서 &lt;code&gt;recv&lt;/code&gt; 함수는 소켓에서 데이터를 읽도록 요청하면 새로운 &lt;code&gt;Future&lt;/code&gt; 인스턴스를 반환합니다 . 이 &lt;code&gt;Future&lt;/code&gt; 인스턴스는 요청 된 양의 데이터를 읽은 후에 완료됩니다 (이 경우 100 바이트). 두 번째 줄은 미래에 대한 콜백을 설정하며, 미래가 완료되면 호출됩니다. 모든 콜백은 향후 저장된 데이터를 &lt;code&gt;stdout&lt;/code&gt; 에 기록 합니다. &lt;code&gt;read&lt;/code&gt; 기능이 사용하고 그것을 확인 여부에 대한 오류와 함께 미래 완료 (그것이 단순히 오류가 발생합니다 한 경우)는 미래의 값을 반환 그러나 오류가없는 경우.</target>
        </trans-unit>
        <trans-unit id="21c40f021cb3285301a10da6c518a7dfee56f66a" translate="yes" xml:space="preserve">
          <source>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</source>
          <target state="translated">위의 예에서 검색 루프는 요인 4에 의해 언 롤링됩니다. 언롤 팩터도 생략 될 수 있습니다. 그런 다음 컴파일러는 적절한 언롤 팩터를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="447fba0bf5092295ea3ef5df369d20395a2954e0" translate="yes" xml:space="preserve">
          <source>In the age of HTTP, HTML, FTP, TCP, IP, UTF, WWW it is foolish to pretend these are somewhat special words requiring all uppercase. Instead treat them as what they are: Real words. So it's &lt;code&gt;parseUrl&lt;/code&gt; rather than &lt;code&gt;parseURL&lt;/code&gt;, &lt;code&gt;checkHttpHeader&lt;/code&gt; instead of &lt;code&gt;checkHTTPHeader&lt;/code&gt; etc.</source>
          <target state="translated">HTTP, HTML, FTP, TCP, IP, UTF, WWW의 시대에는 이것이 모두 대문자를 요구하는 다소 특별한 단어 인 것처럼 어리석은 일입니다. 대신 그것들을 실제 단어로 취급하십시오. 그것의 그래서 &lt;code&gt;parseUrl&lt;/code&gt; 보다는 &lt;code&gt;parseURL&lt;/code&gt; , &lt;code&gt;checkHttpHeader&lt;/code&gt; 대신 &lt;code&gt;checkHTTPHeader&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="1aaaccd5328576322733f4b1a0d0cfc0189406e9" translate="yes" xml:space="preserve">
          <source>In the case of Nim's own documentation, the &lt;code&gt;txt&lt;/code&gt; value is just a commit hash to append to a formatted URL to &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt;. The &lt;code&gt;tools/nimweb.nim&lt;/code&gt; helper queries the current git commit hash during doc generation, but since you might be working on an unpublished repository, it also allows specifying a &lt;code&gt;githash&lt;/code&gt; value in &lt;code&gt;web/website.ini&lt;/code&gt; to force a specific commit in the output.</source>
          <target state="translated">Nim 자체 문서의 경우 &lt;code&gt;txt&lt;/code&gt; 값은 &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim에&lt;/a&gt; 형식화 된 URL에 추가하기위한 커밋 해시 입니다. &lt;code&gt;tools/nimweb.nim&lt;/code&gt; 도우미는 현재의 자식이 문서 생성시 해시를 저지 쿼리, 그러나 당신이 게시되지 않은 저장소 작업을 할 수 있기 때문에, 그것은 또한 지정 할 수 있습니다 &lt;code&gt;githash&lt;/code&gt; 의 가치 &lt;code&gt;web/website.ini&lt;/code&gt; 특정 출력에 커밋 강제로.</target>
        </trans-unit>
        <trans-unit id="222b18bf0bb9eca48a64b5eb7ba691094c380acc" translate="yes" xml:space="preserve">
          <source>In the current implementation &lt;code&gt;FloatDivByZeroError&lt;/code&gt; and &lt;code&gt;FloatInexactError&lt;/code&gt; are never raised. &lt;code&gt;FloatOverflowError&lt;/code&gt; is raised instead of &lt;code&gt;FloatDivByZeroError&lt;/code&gt;. There is also a &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt; pragma that is a short-cut for the combination of &lt;code&gt;nanChecks&lt;/code&gt; and &lt;code&gt;infChecks&lt;/code&gt; pragmas. &lt;code&gt;floatChecks&lt;/code&gt; are turned off as default.</source>
          <target state="translated">현재 구현에서 &lt;code&gt;FloatDivByZeroError&lt;/code&gt; 및 &lt;code&gt;FloatInexactError&lt;/code&gt; 는 발생하지 않습니다. &lt;code&gt;FloatOverflowError&lt;/code&gt; 는 대신 발생 &lt;code&gt;FloatDivByZeroError&lt;/code&gt; . 도있다 &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks의&lt;/span&gt; 의 조합에 대한 짧은 컷 프라 그마 &lt;code&gt;nanChecks&lt;/code&gt; 및 &lt;code&gt;infChecks&lt;/code&gt; 프라 그마는. &lt;code&gt;floatChecks&lt;/code&gt; 는 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bff2144a51b7a2c294698601ad8d94335ce9f207" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;name&lt;/code&gt; is instantiated with &lt;code&gt;myint&lt;/code&gt;, so `T name` becomes &lt;code&gt;Tmyint&lt;/code&gt;.</source>
          <target state="translated">예제에서 &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;myint&lt;/code&gt; 로 인스턴스화 되므로`T name`은 &lt;code&gt;Tmyint&lt;/code&gt; 가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f3d915c7fda05ffa880f1a94fe575c45d57c7e6" translate="yes" xml:space="preserve">
          <source>In the example a new pragma named &lt;code&gt;rtl&lt;/code&gt; is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</source>
          <target state="translated">이 예에서는 동적 라이브러리에서 심볼을 가져 오거나 동적 라이브러리 생성을 위해 심볼을 내보내는 &lt;code&gt;rtl&lt;/code&gt; 이라는 새로운 pragma 가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="93f65483d248fc770a9b18bebde69fbd09a74d5c" translate="yes" xml:space="preserve">
          <source>In the example a tree structure is declared with the &lt;code&gt;Node&lt;/code&gt; type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The &lt;code&gt;acyclic&lt;/code&gt; pragma passes the information that this cannot happen to the GC. If the programmer uses the &lt;code&gt;acyclic&lt;/code&gt; pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</source>
          <target state="translated">이 예에서 트리 구조는 &lt;code&gt;Node&lt;/code&gt; 유형으로 선언됩니다 . 타입 정의는 재귀 적이며 GC는이 타입의 객체가 주기적 그래프를 형성 할 수 있다고 가정해야합니다. &lt;code&gt;acyclic&lt;/code&gt; pragma는 이것이 GC에 일어나지 않을 수있는 정보를 전달합니다. 프로그래머가 실제로주기적인 데이터 유형에 대해 &lt;code&gt;acyclic&lt;/code&gt; 주기적 pragma를 사용하는 경우 GC는 메모리를 누출 할 수 있지만 더 나쁜 일은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c223baf4c7b9145e95ff7b9ff3609cc1168a5f2c" translate="yes" xml:space="preserve">
          <source>In the example c2nim treats the declaration of &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; as if it has been defined via &lt;code&gt;#def&lt;/code&gt;.</source>
          <target state="translated">이 예에서 c2nim은 &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; 선언을 마치 &lt;code&gt;#def&lt;/code&gt; 를 통해 정의 된 것처럼 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="4931fb24c88d4a3add48a67517bb1d6df1d7d83b" translate="yes" xml:space="preserve">
          <source>In the example the &lt;code&gt;kind&lt;/code&gt; field is called the &lt;span id=&quot;discriminator_1&quot;&gt;discriminator&lt;/span&gt;: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch &lt;code&gt;system.reset&lt;/code&gt; has to be used. Also, when the fields of a particular branch are specified during object construction, the correct value for the discriminator must be supplied at compile-time.</source>
          <target state="translated">이 예에서는 &lt;code&gt;kind&lt;/code&gt; 필드를 &lt;span id=&quot;discriminator_1&quot;&gt;판별 자라고합니다&lt;/span&gt; . 안전을 위해 주소를 지정할 수없고 할당이 제한됩니다. 새 값이 활성 오브젝트 분기를 변경하지 않아야합니다. 오브젝트 브랜치 스위치의 경우 &lt;code&gt;system.reset&lt;/code&gt; 을 사용해야합니다. 또한 오브젝트 구성 중에 특정 브랜치의 필드가 지정된 경우 판별시 올바른 판별 자 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f870d1827ccced8c4dc81fc21ba54ed53d3b7fa4" translate="yes" xml:space="preserve">
          <source>In the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because they should use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">이 예제에서 &lt;code&gt;newLit&lt;/code&gt; 및 &lt;code&gt;newPlus&lt;/code&gt; 생성자 는 정적 바인딩을 사용해야하기 때문에 procs이지만 &lt;code&gt;eval&lt;/code&gt; 은 동적 바인딩이 필요하므로 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="ffcf0c9fc73817d81ec1bb90e18296fae7f0e1e3" translate="yes" xml:space="preserve">
          <source>In the example the external name of &lt;code&gt;p&lt;/code&gt; is set to &lt;code&gt;prefixp&lt;/code&gt;. Only &lt;code&gt;$1&lt;/code&gt; is available and a literal dollar sign must be written as &lt;code&gt;$$&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;p&lt;/code&gt; 의 외부 이름은 &lt;code&gt;prefixp&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;$1&lt;/code&gt; 만 사용할 수 있으며 리터럴 달러 기호는 &lt;code&gt;$$&lt;/code&gt; 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="207cdaa4265565920d4f81786bf2ce395e20de1e" translate="yes" xml:space="preserve">
          <source>In the example the generic &lt;code&gt;==&lt;/code&gt; for tuples (as defined in the system module) uses the &lt;code&gt;==&lt;/code&gt; operators of the tuple's components. However, the &lt;code&gt;==&lt;/code&gt; for the &lt;code&gt;Index&lt;/code&gt; type is defined &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;==&lt;/code&gt; for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</source>
          <target state="translated">이 예에서 시스템 모듈에 정의 된 튜플 의 일반 &lt;code&gt;==&lt;/code&gt; 는 튜플 구성 요소 의 &lt;code&gt;==&lt;/code&gt; 연산자를 사용합니다 . 그러나, &lt;code&gt;==&lt;/code&gt; 에 대한 &lt;code&gt;Index&lt;/code&gt; 유형은 정의 된 &lt;em&gt;후 &lt;/em&gt; &lt;code&gt;==&lt;/code&gt; 튜플; 그러나 인스턴스화에서 현재 정의 된 기호도 고려할 때 예제가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d09a6862f895be9685356eda8db42c91b15ade" translate="yes" xml:space="preserve">
          <source>In the example the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;body&lt;/code&gt; parameter. The &lt;code&gt;withFile&lt;/code&gt; template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the &lt;code&gt;let fn = filename&lt;/code&gt; statement ensures that &lt;code&gt;filename&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">이 예에서는 두 개의 &lt;code&gt;writeLine&lt;/code&gt; 문이 &lt;code&gt;body&lt;/code&gt; 매개 변수에 바인딩되어 있습니다. &lt;code&gt;withFile&lt;/code&gt; 의 템플릿은 상용구 코드를 포함하고 공통의 버그를 방지하는 데 도움이 : 파일을 닫습니다 잊어. &lt;code&gt;let fn = filename&lt;/code&gt; 문은 &lt;code&gt;filename&lt;/code&gt; 이 한 번만 평가 되도록하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e573c188d155c097bab8635e952a84f3906a513" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.</source>
          <target state="translated">이 예에서 &lt;code&gt;res&lt;/code&gt; 및 &lt;code&gt;remainder&lt;/code&gt; 는 &lt;em&gt;var parameters&lt;/em&gt; 입니다. Var 매개 변수는 프로 시저에 의해 수정 될 수 있으며 변경 사항은 호출자에게 표시됩니다. 위의 예제는 var 매개 변수를 사용하는 대신 튜플을 반환 값으로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e99258ef6102af84c3e85eb151f26d0965f922fd" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</source>
          <target state="translated">이 예에서 &lt;code&gt;res&lt;/code&gt; 및 &lt;code&gt;remainder&lt;/code&gt; 는 &lt;em&gt;var parameters&lt;/em&gt; 입니다. Var 매개 변수는 프로 시저에 의해 수정 될 수 있으며 변경 사항은 호출자에게 표시됩니다. var 매개 변수에 전달 된 인수는 l- 값이어야합니다. Var 매개 변수는 숨겨진 포인터로 구현됩니다. 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ce83aae39fe686c17231fc96b454e933bdbf835" translate="yes" xml:space="preserve">
          <source>In the example, the case branches &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</source>
          <target state="translated">이 예에서 사례 분기 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 다른 경우보다 훨씬 일반적입니다. 따라서 생성 된 어셈블러 코드는 먼저이 값을 테스트하여 CPU의 분기 예측기가 성공할 수있는 좋은 기회를 갖도록해야합니다 (고가의 CPU 파이프 라인 중단 방지). 다른 경우는 O (1) 오버 헤드를위한 점프 테이블에 넣을 수 있지만 파이프 라인이 멈출 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="449891737730fed7e4e9e268f5440bde8cd00a54" translate="yes" xml:space="preserve">
          <source>In the example, the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;actions&lt;/code&gt; parameter.</source>
          <target state="translated">이 예에서 두 개의 &lt;code&gt;writeLine&lt;/code&gt; 문은 &lt;code&gt;actions&lt;/code&gt; 매개 변수에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="05f29e9409204f7156a8b49a6edfe66f0ff90993" translate="yes" xml:space="preserve">
          <source>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</source>
          <target state="translated">예제에서 var 매개 변수 또는 포인터는 두 개의 리턴 값을 제공하는 데 사용됩니다. 튜플을 반환하면 깔끔한 방식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf1b069c247f4187c31c21ebbe40e040b094bad5" translate="yes" xml:space="preserve">
          <source>In the following sections &lt;em&gt;global&lt;/em&gt; means &lt;em&gt;shared between modules&lt;/em&gt; or &lt;em&gt;property of the whole program&lt;/em&gt;.</source>
          <target state="translated">다음 섹션에서 &lt;em&gt;전역 &lt;/em&gt;&lt;em&gt;은 전체 프로그램의 &lt;/em&gt;&lt;em&gt;모듈&lt;/em&gt; 또는 &lt;em&gt;속성 &lt;/em&gt;&lt;em&gt;간에 공유되는&lt;/em&gt; 것을 의미 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f42fa9bad92a4bca57282426b4b7870e70495fb5" translate="yes" xml:space="preserve">
          <source>In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</source>
          <target state="translated">이전 예제에서 슬라이스는 문자열의 일부를 수정하는 데 사용됩니다. 슬라이스의 경계는 해당 유형에서 지원하는 모든 값을 보유 할 수 있지만 어떤 개체가 허용되는지 정의하는 슬라이스 개체를 사용하는 것은 proc입니다.</target>
        </trans-unit>
        <trans-unit id="d9143e669402c29ee0475ca379b33b947a4800d5" translate="yes" xml:space="preserve">
          <source>In the previous sections the &lt;code&gt;NimMain()&lt;/code&gt; function reared its head. Since JavaScript already provides automatic memory management, you can freely pass objects between the two language without problems. In C and derivate languages you need to be careful about what you do and how you share memory. The previous examples only dealt with simple scalar values, but passing a Nim string to C, or reading back a C string in Nim already requires you to be aware of who controls what to avoid crashing.</source>
          <target state="translated">이전 섹션에서 &lt;code&gt;NimMain()&lt;/code&gt; 함수는 헤드를 양육했습니다. JavaScript는 이미 자동 메모리 관리를 제공하므로 문제없이 두 언어간에 객체를 자유롭게 전달할 수 있습니다. C 언어와 파생 언어에서는 수행 작업과 메모리 공유 방법에주의해야합니다. 앞의 예제는 간단한 스칼라 값만 다루었지만 Nim 문자열을 C로 전달하거나 Nim에서 C 문자열을 다시 읽으려면 충돌을 피할 대상을 누가 제어하는지 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1678b121aeb51003f37c84a3a8b55dda38dde0ae" translate="yes" xml:space="preserve">
          <source>In the standard library every name of a routine that returns a &lt;code&gt;var&lt;/code&gt; type starts with the prefix &lt;code&gt;m&lt;/code&gt; per convention.</source>
          <target state="translated">표준 라이브러리에서 &lt;code&gt;var&lt;/code&gt; 유형 을 반환하는 모든 루틴 이름은 규칙 당 접두사 &lt;code&gt;m&lt;/code&gt; 으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="3573423166a3714205c4fd8df064a462e9f793fc" translate="yes" xml:space="preserve">
          <source>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</source>
          <target state="translated">이와 관련하여 줄은 줄 바꿈 조합으로 구분 된 문자열입니다. 줄은 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c0be54e609e08ad5ac67f5c3b4c12362798deb" translate="yes" xml:space="preserve">
          <source>In this example &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. Note that &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; applied to strings is a nop.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; 는 매개 변수 &lt;code&gt;a&lt;/code&gt; 로 전달되는 모든 인수에 적용됩니다 . 문자열에 적용 되는 &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; 는 nop입니다.</target>
        </trans-unit>
        <trans-unit id="cd49a3b7329e865d00fe88035f180e3a31be031d" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;$&lt;/code&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. (Note that &lt;code&gt;$&lt;/code&gt; applied to strings is a nop.)</source>
          <target state="translated">이 예에서 &lt;code&gt;$&lt;/code&gt; 는 매개 변수 &lt;code&gt;a&lt;/code&gt; 로 전달되는 모든 인수에 적용됩니다 . ( 문자열에 적용 되는 &lt;code&gt;$&lt;/code&gt; 는 nop입니다.)</target>
        </trans-unit>
        <trans-unit id="caf41cefb1ec542e92b76fcef06da5301961d50c" translate="yes" xml:space="preserve">
          <source>In this example both macros are combined seamlessly in order to maximise efficiency and perform different checks.</source>
          <target state="translated">이 예에서는 효율성을 최대화하고 다른 검사를 수행하기 위해 두 매크로가 매끄럽게 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd15640684b666f33817b98a57e6ad3f6b44475" translate="yes" xml:space="preserve">
          <source>In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.</source>
          <target state="translated">이 예제에서 사용자 정의 pragma는 Nim 객체가 관계형 데이터베이스의 스키마에 매핑되는 방법을 설명하는 데 사용됩니다. 커스텀 pragma는 0 개 이상의 인수를 가질 수 있습니다. 여러 인수를 전달하려면 템플릿 호출 구문 중 하나를 사용하십시오. 모든 인수는 형식화되며 템플릿에 대한 표준 과부하 해결 규칙을 따릅니다. 따라서 인수, 이름 별 전달, varargs 등에 대한 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="664c924f4e9ba31a6bee85a98d981b31c47a324a" translate="yes" xml:space="preserve">
          <source>In this example, we define a helper proc &lt;code&gt;someSep&lt;/code&gt; that skips some separators which we then use in our scanf pattern to help us in the matching process:</source>
          <target state="translated">이 예제에서, 우리 는 매칭 프로세스에서 도움을주기 위해 scanf 패턴에서 사용하는 일부 분리 &lt;code&gt;someSep&lt;/code&gt; 건너 뛰는 helper proc someSep 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="534570485c11beb7704f319727846b8b4f022eb5" translate="yes" xml:space="preserve">
          <source>Include statement</source>
          <target state="translated">진술 포함</target>
        </trans-unit>
        <trans-unit id="bbc642ae58ad84741186ba01bd7a4f6256a9bccf" translate="yes" xml:space="preserve">
          <source>Includes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was added to &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">포함 &lt;em&gt;키&lt;/em&gt; 세트의 &lt;em&gt;의를&lt;/em&gt; 하고있는 경우 알려줍니다 &lt;em&gt;키&lt;/em&gt; 에 추가 된 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64f932923a0eaeac8401c0d332e7ec2bbdcdc32c" translate="yes" xml:space="preserve">
          <source>Includes all elements from &lt;em&gt;other&lt;/em&gt; into &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;other의&lt;/em&gt; 모든 요소 를 &lt;em&gt;s에&lt;/em&gt; 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="9a1bf1db1ba56c9fed3c108674752a59dfcd9da4" translate="yes" xml:space="preserve">
          <source>Includes an element &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">요소 포함 &lt;em&gt;키&lt;/em&gt; 에 &lt;em&gt;들&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="122d72fb5f4934f490f955173c3eef92832e3bcb" translate="yes" xml:space="preserve">
          <source>IncompleteStruct pragma</source>
          <target state="translated">불완전한 구조 pragma</target>
        </trans-unit>
        <trans-unit id="e458e98e024804e2195312b10a3a11a67d6582fd" translate="yes" xml:space="preserve">
          <source>Increments an ordinal</source>
          <target state="translated">서수 증가</target>
        </trans-unit>
        <trans-unit id="3579152b0f13082bc2ed763d516b6eeee04f5e41" translate="yes" xml:space="preserve">
          <source>Increments in place a floating point number</source>
          <target state="translated">부동 소수 점수의 증가</target>
        </trans-unit>
        <trans-unit id="3917b825256b71ec29e2860d96b9f3c57a46e2bf" translate="yes" xml:space="preserve">
          <source>Indent with two spaces.</source>
          <target state="translated">두 개의 공백으로 들여 쓰기하십시오.</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="3e69016e62b22706518f7fd44403f71f6f86a464" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;const&lt;/code&gt; keyword to list a whole section of constants:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드 다음에 들여 쓰기를 사용 하여 전체 상수 섹션을 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f45c825c4626280194b953ea0dec3e48ce7fccc" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;var&lt;/code&gt; keyword to list a whole section of variables:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드 다음에 들여 쓰기를 사용하여 변수의 전체 섹션을 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="520792c3a2538ee8e56f0b4f71803ca37955634d" translate="yes" xml:space="preserve">
          <source>Indents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">들여 각 라인 &lt;code&gt;s&lt;/code&gt; 에 의해 &lt;code&gt;count&lt;/code&gt; 의 양 &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="f2171e3002af9c53c4ea2469894d127d907cca3e" translate="yes" xml:space="preserve">
          <source>Index (idx) file format</source>
          <target state="translated">색인 (IDX) 파일 형식</target>
        </trans-unit>
        <trans-unit id="7086b5dce7145d779101ccd8901d9bbb698cae3d" translate="yes" xml:space="preserve">
          <source>Index files are line oriented and tab separated (newline and tab characters have to be escaped). Each line represents a record with at least two fields, but can have up to four (additional columns are ignored). The content of these columns is:</source>
          <target state="translated">색인 파일은 행 방향이며 탭으로 구분됩니다 (줄 바꾸기 및 탭 문자는 이스케이프되어야 함) 각 줄은 두 개 이상의 필드가있는 레코드를 나타내지 만 최대 4 개를 가질 수 있습니다 (추가 열은 무시 됨). 이 열의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c5d6204871842ba1c9f7cd8b0f7f94f787509f2" translate="yes" xml:space="preserve">
          <source>Index switch</source>
          <target state="translated">인덱스 스위치</target>
        </trans-unit>
        <trans-unit id="7d2d080b9c23631882a620ee4cef31b37b3e5e98" translate="yes" xml:space="preserve">
          <source>Index the collection with the proc provided.</source>
          <target state="translated">제공된 proc로 컬렉션을 인덱싱하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0343473193cfc7e99b7802a4d65dded5509d30" translate="yes" xml:space="preserve">
          <source>Indicates that a leading space should be used on positive numbers.</source>
          <target state="translated">양수에 선행 공백을 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c549fa4a0ba269a959c6226777ab5a0b50f1df5" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used for both positive as well as negative numbers.</source>
          <target state="translated">양수와 음수 모두에 부호를 사용해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a0c8cf09bdbe9d14558c3f28be789e07866609de" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used only for negative numbers (this is the default behavior).</source>
          <target state="translated">부호가 음수에만 사용해야 함을 나타냅니다 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="02d4b08a1673b232bf3018ee2f9d0a8e9fa2025c" translate="yes" xml:space="preserve">
          <source>Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.</source>
          <target state="translated">부정확 한 : 연산은 2.0 / 3.0, log (1.1) 및 0.1 입력과 같이 무한 정밀도로 표현할 수없는 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="63d5b176942ca6a8ddb9add205f21b0d98945888" translate="yes" xml:space="preserve">
          <source>Infix operator call</source>
          <target state="translated">중위 연산자 호출</target>
        </trans-unit>
        <trans-unit id="eb712e4e263d88043891e59382c4f31c8c4157de" translate="yes" xml:space="preserve">
          <source>Inheritance is done with the &lt;code&gt;object of&lt;/code&gt; syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, &lt;code&gt;RootObj&lt;/code&gt; can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt;. You can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;. (This is used in the GTK wrapper for instance.)</source>
          <target state="translated">상속은 구문 &lt;code&gt;object of&lt;/code&gt; 수행됩니다 . 다중 상속은 현재 지원되지 않습니다. 객체 유형에 적합한 조상이없는 경우 &lt;code&gt;RootObj&lt;/code&gt; 를 조상 으로 사용할 수 있지만 이는 단지 규칙입니다. 조상이없는 객체는 암시 적으로 &lt;code&gt;final&lt;/code&gt; 입니다. &lt;code&gt;inheritable&lt;/code&gt; pragma를 사용하여 &lt;code&gt;system.RootObj&lt;/code&gt; 와는 별도로 새 객체 루트를 도입 할 수 있습니다 . (이것은 예를 들어 GTK 래퍼에서 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="862fae5c64569c192f0058ccd3bbb5d19a019f65" translate="yes" xml:space="preserve">
          <source>Inhibit dynamic method resolution via procCall</source>
          <target state="translated">procCall을 통한 동적 분석 방법 금지</target>
        </trans-unit>
        <trans-unit id="5c4f1d9bb4b4c00271c428db76888f539a5526ec" translate="yes" xml:space="preserve">
          <source>Init procs must not be &quot;forgotten&quot; to be called.</source>
          <target state="translated">init procs를 호출하기 위해 &quot;잊어 버려&quot;서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e0133811d52fc5e0ce7548998427d86c5ecbabc3" translate="yes" xml:space="preserve">
          <source>Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised.</source>
          <target state="translated">AsyncSocket 객체를 초기화합니다. 소켓을 초기화 할 수없는 경우 EOS가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="0e8796999c73166ae179e51a98cc0d932f6227e2" translate="yes" xml:space="preserve">
          <source>Initialize SSL using OPENSSL_init_ssl for OpenSSL &amp;gt;= 1.1.0 otherwise SSL_library_init</source>
          <target state="translated">OpenSSL&amp;gt; = 1.1.0에 대해 OPENSSL_init_ssl을 사용하여 SSL을 초기화하십시오. 그렇지 않으면 SSL_library_init</target>
        </trans-unit>
        <trans-unit id="881e0294c3d407bde48feb8c4affbeeef0f33574" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RstGenerator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RstGenerator&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="40151f2c3d201480764280228665dd4a245cb8ae" translate="yes" xml:space="preserve">
          <source>Initializes a URI.</source>
          <target state="translated">URI를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="405224e088cd409637c05da8068dcfb0b7324f95" translate="yes" xml:space="preserve">
          <source>Initializes a hash set.</source>
          <target state="translated">해시 세트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e84a4c040ee7b5e4ea1966bc93e94a695c273213" translate="yes" xml:space="preserve">
          <source>Initializes an ordered hash set.</source>
          <target state="translated">정렬 된 해시 세트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="580bcf0259f858c591c1bdfb9fe2dbcc9bf29a6d" translate="yes" xml:space="preserve">
          <source>Initializes the default random number generator with a specific seed.</source>
          <target state="translated">특정 시드로 기본 난수 생성기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="dacee3e957999d4c882a7ef1c7b8e6793e30746e" translate="yes" xml:space="preserve">
          <source>Initializes the given condition variable.</source>
          <target state="translated">주어진 조건 변수를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0f32d11dbd1ff544f08160af91e946d34a75cd48" translate="yes" xml:space="preserve">
          <source>Initializes the given lock.</source>
          <target state="translated">주어진 잠금을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6ede6304ec6e7bf4a6a2e3d80c6b1eeb81cc73f8" translate="yes" xml:space="preserve">
          <source>Initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. Note: Does not work for NimScript.</source>
          <target state="translated">&quot;임의의&quot;숫자 (예 : 틱 카운트)로 난수 생성기를 초기화합니다. 참고 : NimScript에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7656a50f2e0ac5db2e06ce5648c4594fc345f831" translate="yes" xml:space="preserve">
          <source>InjectStmt pragma</source>
          <target state="translated">InstStmt pragma</target>
        </trans-unit>
        <trans-unit id="1ee7de66fcff05572c93c829536da75cc7683b42" translate="yes" xml:space="preserve">
          <source>Input flags.</source>
          <target state="translated">입력 플래그.</target>
        </trans-unit>
        <trans-unit id="f9e1ac91d7701d8e495d0f11ba5f1b00fdf6ed7f" translate="yes" xml:space="preserve">
          <source>Insert node B into A at pos</source>
          <target state="translated">pos에서 노드 B를 A에 삽입</target>
        </trans-unit>
        <trans-unit id="2db3b3fd15b7bb4b34dad30c689dad9d16b24896" translate="yes" xml:space="preserve">
          <source>Inserting data</source>
          <target state="translated">데이터 삽입</target>
        </trans-unit>
        <trans-unit id="dd923f823166b6196d06cbdd3db676002c784b17" translate="yes" xml:space="preserve">
          <source>Inserts items from &lt;em&gt;src&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt; at position &lt;em&gt;pos&lt;/em&gt;. This modifies &lt;em&gt;dest&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">&lt;em&gt;src&lt;/em&gt; 에서 &lt;em&gt;pos&lt;/em&gt; 위치의 &lt;em&gt;dest&lt;/em&gt; 로 항목을 삽입합니다 . 이것은 &lt;em&gt;dest&lt;/em&gt; 자체를 수정 하고 사본을 반환하지 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04298198949aebc6d2892e5fc955264070b8ebb9" translate="yes" xml:space="preserve">
          <source>Inserts the node &lt;code&gt;newChild&lt;/code&gt; before the existing child node &lt;code&gt;refChild&lt;/code&gt;. If &lt;code&gt;refChild&lt;/code&gt; is nil, insert &lt;code&gt;newChild&lt;/code&gt; at the end of the list of children.</source>
          <target state="translated">노드 삽입 &lt;code&gt;newChild&lt;/code&gt; 로 기존의 아이 노드 전에 &lt;code&gt;refChild&lt;/code&gt; 의 . &lt;code&gt;refChild&lt;/code&gt; 가 nil 인 경우 하위 목록 끝에 &lt;code&gt;newChild&lt;/code&gt; 를 삽입 하십시오.</target>
        </trans-unit>
        <trans-unit id="786ea42ccb1f6bb0efafd8f2b61725cd22b7b01c" translate="yes" xml:space="preserve">
          <source>Inserts the separator &lt;em&gt;sep&lt;/em&gt; after &lt;em&gt;digits&lt;/em&gt; digits from right to left.</source>
          <target state="translated">세퍼레이터 삽입 &lt;em&gt;9월&lt;/em&gt; 후 &lt;em&gt;자리&lt;/em&gt; 숫자가 오른쪽에서 왼쪽.</target>
        </trans-unit>
        <trans-unit id="873af15bd68c477178748ca072cfddf8b2be43af" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">문자 클래스 내에서, 또는 10 진수가 9보다 크고 캡처하는 하위 패턴이 많지 않은 경우 PCRE는 백 슬래시 다음에 최대 3 개의 8 진수를 다시 읽고 최소 8 비트에서 단일 바이트를 생성합니다. 값. 모든 후속 숫자는 자체를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca77b6367a8fe2f8a03241e2199780113a61f688" translate="yes" xml:space="preserve">
          <source>Inside asynchronous procedures &lt;code&gt;await&lt;/code&gt; can be used to call any procedures which return a &lt;code&gt;Future&lt;/code&gt;; this includes asynchronous procedures. When a procedure is &quot;awaited&quot;, the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</source>
          <target state="translated">내부 비동기 프로 시저 &lt;code&gt;await&lt;/code&gt; 를 사용하여 &lt;code&gt;Future&lt;/code&gt; 를 리턴하는 프로 시저를 호출 할 수 있습니다 . 여기에는 비동기 절차가 포함됩니다. 프로 시저가 &quot;대기&quot;된 경우, 대기중인 비동기 프로시 저는 대기중인 프로 시저의 Future가 완료 될 때까지 실행을 일시 중단합니다. 이 시점에서 비동기 프로시 저는 실행을 재개합니다. 비동기 프로 시저가 일시 중단 된 기간 동안 디스패처가 다른 비동기 프로 시저를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="58445a9dc8fa874d6c0999c2be877243221f8374" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;#@ @#&lt;/code&gt; Nim's pragma brackets &lt;code&gt;{. .}&lt;/code&gt; can also be used, but not nested since the &lt;code&gt;.}&lt;/code&gt; doesn't have to be on a line of its own:</source>
          <target state="translated">&lt;code&gt;#@ @#&lt;/code&gt; 대신 Nim의 pragma 괄호 &lt;code&gt;{. .}&lt;/code&gt; 도 사용할 수 있지만 &lt;code&gt;.}&lt;/code&gt; 이 자체 줄에있을 필요가 없으므로 중첩 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed085b50e598c9e9c3c998d8d02d824b13f51bfb" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;self&lt;/code&gt; any other identifier can be used too, but &lt;code&gt;{.this: self.}&lt;/code&gt; will become the default directive for the whole language eventually.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 대신 다른 식별자를 사용할 수도 있지만 &lt;code&gt;{.this: self.}&lt;/code&gt; 는 결국 전체 언어의 기본 지시문이됩니다.</target>
        </trans-unit>
        <trans-unit id="5150cf2c23ac3058436fce11d312cb4ab7dd9726" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;code&gt;try finally&lt;/code&gt; statement a &lt;code&gt;defer&lt;/code&gt; statement can be used.</source>
          <target state="translated">&lt;code&gt;try finally&lt;/code&gt; 문 대신 &lt;code&gt;defer&lt;/code&gt; 문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03665382599317cc60a7efd5af43d25b36a35438" translate="yes" xml:space="preserve">
          <source>Instead of depending on the generation of the individual &lt;code&gt;.c&lt;/code&gt; files you can also ask the Nim compiler to generate a statically linked library:</source>
          <target state="translated">개별 &lt;code&gt;.c&lt;/code&gt; 파일 의 생성에 의존하지 않고 Nim 컴파일러에 정적으로 링크 된 라이브러리를 생성하도록 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff60c5d0007a18ea981f49f0360da2385ccc4565" translate="yes" xml:space="preserve">
          <source>Instead of keeping 2 versions of &lt;code&gt;define foo&lt;/code&gt; around, one &lt;code&gt;#def foo&lt;/code&gt; for c2nim and one ordinary &lt;code&gt;#define foo&lt;/code&gt; for C/C++, it is often more convenient to tell c2nim that &lt;code&gt;foo&lt;/code&gt; is to be interpreted as a &lt;code&gt;#def&lt;/code&gt;. This is what the &lt;code&gt;#pp&lt;/code&gt; directive accomplishes:</source>
          <target state="translated">대신 2 개 버전 유지의 &lt;code&gt;define foo&lt;/code&gt; 주위를 한 &lt;code&gt;#def foo&lt;/code&gt; 는 c2nim에 대한 하나의 일반 &lt;code&gt;#define foo&lt;/code&gt; C / C ++에, 그 c2nim 얘기하는 것이 더 편리 &lt;code&gt;foo&lt;/code&gt; A와 해석되어야 &lt;code&gt;#def&lt;/code&gt; . 이것이 &lt;code&gt;#pp&lt;/code&gt; 지시어가 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7301e8180a639fec5b0ce81d171622b155df52d" translate="yes" xml:space="preserve">
          <source>Instead of removing &lt;code&gt;EXTERN()&lt;/code&gt; from the input source file (which cannot be done reliably even with a regular expression!), one can tell c2nim that &lt;code&gt;EXTERN&lt;/code&gt; is a macro that should be expanded by c2nim too:</source>
          <target state="translated">입력 소스 파일에서 &lt;code&gt;EXTERN()&lt;/code&gt; 을 제거하는 대신 ( 정규 표현식으로도 안정적으로 수행 할 수 없습니다!) &lt;code&gt;EXTERN&lt;/code&gt; 이 c2nim으로 확장되어야하는 매크로임을 c2nim에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="84737859654b67b2b9a33e5c2db83b51683c5344" translate="yes" xml:space="preserve">
          <source>Instead this code has to be used:</source>
          <target state="translated">대신이 코드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec54b2dcce7fd1b6d6a547c96c19205ad88a3d5d" translate="yes" xml:space="preserve">
          <source>Int values of &lt;em&gt;x&lt;/em&gt; are simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; int 값 은 단순히 &lt;code&gt;float&lt;/code&gt; 로 변환되고 다른 푸시 작업이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2adc71fa12ee88a61833caad8062097e6410346c" translate="yes" xml:space="preserve">
          <source>Integer division for durations.</source>
          <target state="translated">지속 기간의 정수 나누기.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="584a126c172b3ef1ff0c69307f68a5ebdd0d1d09" translate="yes" xml:space="preserve">
          <source>Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types &lt;code&gt;uint&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; are not ordinal types.</source>
          <target state="translated">정수, 부울, 문자 및 열거 유형 (및 이러한 유형의 하위 범위)은 서수 유형에 속합니다. 구현이 간단하기 때문에 &lt;code&gt;uint&lt;/code&gt; 및 &lt;code&gt;uint64&lt;/code&gt; 유형은 서수 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="90c35cf1c7e9e4b6aa47b681a51fc9aa23f2f3de" translate="yes" xml:space="preserve">
          <source>Integral conversion match: &lt;code&gt;a&lt;/code&gt; is convertible to &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is some integer or floating point type.</source>
          <target state="translated">완전한 변환 일치 : &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;f&lt;/code&gt; 로 변환 가능 하며 &lt;code&gt;a&lt;/code&gt; 는 정수 또는 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2cea7df8891dd1065020c3b86bf5bf912b6baca2" translate="yes" xml:space="preserve">
          <source>Interfacing</source>
          <target state="translated">Interfacing</target>
        </trans-unit>
        <trans-unit id="a954e42be7d65d0d68df6c2475675a3e2ab46fae" translate="yes" xml:space="preserve">
          <source>Internal documentation</source>
          <target state="translated">내부 문서</target>
        </trans-unit>
        <trans-unit id="6be940d65e52db18b5d8edc969f415c8720649fa" translate="yes" xml:space="preserve">
          <source>Internal type representation</source>
          <target state="translated">내부 유형 표현</target>
        </trans-unit>
        <trans-unit id="664fc2f86af06c6988fa72f769d3e17fcd2731e8" translate="yes" xml:space="preserve">
          <source>Internally, we want mustRehash(rightSize(x), x) == false.</source>
          <target state="translated">내부적으로 mustRehash (rightSize (x), x) == false를 원합니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2938da18cdb579e62b1141f39929cc36fdc8e917" translate="yes" xml:space="preserve">
          <source>Internals of the Nim Compiler</source>
          <target state="translated">Nim 컴파일러의 내부</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">인터넷 프로토콜 및 지원</target>
        </trans-unit>
        <trans-unit id="c77102105a7e484189908c6c3aaa8b4fde6d5bd4" translate="yes" xml:space="preserve">
          <source>Interpolates a format string with the values from &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">의 값으로 형식 문자열 보간 &lt;em&gt;을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1a2e25ef70924b9dc72d6e9cae42a42464d5c3ae" translate="yes" xml:space="preserve">
          <source>Invalid SQL encountered</source>
          <target state="translated">잘못된 SQL이 발생했습니다</target>
        </trans-unit>
        <trans-unit id="3579c51a9cfa004f6051766e66c67a34af9f5d6d" translate="yes" xml:space="preserve">
          <source>Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).</source>
          <target state="translated">유효하지 않음 : 수학적으로 유효하지 않은 피연산자가있는 조작 (예 : 0.0 / 0.0, sqrt (-1.0) 및 log (-37.8))</target>
        </trans-unit>
        <trans-unit id="e0c13b2efd4e2d6dec9f73473d4c5e30f853cc74" translate="yes" xml:space="preserve">
          <source>Invocation context</source>
          <target state="translated">호출 컨텍스트</target>
        </trans-unit>
        <trans-unit id="45e47edcb41b8a29e3a098022eba6bd2db5b9ca3" translate="yes" xml:space="preserve">
          <source>Invocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">다중 메소드의 호출은 모호 할 수 없습니다. 충돌이 왼쪽에서 오른쪽으로 작동하기 때문에 충돌 1이 충돌 1보다 선호됩니다. 예제 &lt;code&gt;Unit, Thing&lt;/code&gt; 은 &lt;code&gt;Thing, Unit&lt;/code&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f35cc2588d6df7883512e310eaf3cfe55f22b5" translate="yes" xml:space="preserve">
          <source>Is operator</source>
          <target state="translated">운영자</target>
        </trans-unit>
        <trans-unit id="3bcc962b75eed7b2e391c690e8701aa2754af2d5" translate="yes" xml:space="preserve">
          <source>Is rewritten to:</source>
          <target state="translated">다음으로 다시 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="41e7fee403015340d1195de277c32fe1acf8a866" translate="yes" xml:space="preserve">
          <source>Is short for:</source>
          <target state="translated">약자 :</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="ae0bcdcfc983072ff2e5010acbd964825c34f849" translate="yes" xml:space="preserve">
          <source>Is translated into:</source>
          <target state="translated">로 번역됩니다 :</target>
        </trans-unit>
        <trans-unit id="6f20666fec7d3538d857abddfabb7eb0323d351c" translate="yes" xml:space="preserve">
          <source>Is translated to:</source>
          <target state="translated">번역 된 내용 :</target>
        </trans-unit>
        <trans-unit id="90d19d41b3a53b1379c3459c0faab9f64cca3759" translate="yes" xml:space="preserve">
          <source>It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake_style, and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like &lt;code&gt;var foo: Foo&lt;/code&gt; to be parsed unambiguously.</source>
          <target state="translated">그것은 프로그래머가 대부분 자신이 선호하는 철자 스타일을 사용하도록합니다. humpStyle 또는 snake_style이며 다른 프로그래머가 작성한 라이브러리는 호환되지 않는 규칙을 사용할 수 없습니다. 님 인식 편집기 또는 IDE는 식별자를 원하는대로 표시 할 수 있습니다. 또 다른 장점은 프로그래머가 식별자의 정확한 철자를 기억하지 못한다는 것입니다. 첫 글자에 대한 예외는 &lt;code&gt;var foo: Foo&lt;/code&gt; 와 같은 일반적인 코드를 명확하게 파싱 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="2fe9d58777a4819a056f680773675b458bc59f43" translate="yes" xml:space="preserve">
          <source>It also possible to pass arguments to a user definable matcher:</source>
          <target state="translated">또한 사용자 정의 가능 매처에 인수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b2feef416362147669a39cf0c612de62bb2d19e" translate="yes" xml:space="preserve">
          <source>It also provides some fast iterators over lines in text files (or other &quot;line-like&quot;, variable length, delimited records).</source>
          <target state="translated">또한 텍스트 파일의 줄 (또는 다른 &quot;줄 모양&quot;, 가변 길이, 구분 된 레코드)에 대한 빠른 반복자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dff3ae584541038e537e5a342c1930160c45bf0a" translate="yes" xml:space="preserve">
          <source>It can also be used when defines are being referred to, as c2nim currently does not expand defines:</source>
          <target state="translated">c2nim이 현재 정의를 확장하지 않기 때문에 정의가 참조 될 때에도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0075f000dd30ff460292c5c1bbbe6ad98332e6c" translate="yes" xml:space="preserve">
          <source>It can be used to parse a wild HTML document and output it as valid XHTML document (well, if you are lucky):</source>
          <target state="translated">와일드 HTML 문서를 구문 분석하고 유효한 XHTML 문서로 출력하는 데 사용할 수 있습니다 (운이 좋으면 잘).</target>
        </trans-unit>
        <trans-unit id="589d528fa76550fcfe67d75a7cc3b724508c0925" translate="yes" xml:space="preserve">
          <source>It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:</source>
          <target state="translated">달러에 달러를 곱하는 것이 아니라 단위가없는 숫자를 곱하는 것은 합리적이지 않습니다. 분할에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c9187f5ee38c2d68fe98474af10e0521e2ff318b" translate="yes" xml:space="preserve">
          <source>It helps to think that the iterator actually returns a pair &lt;code&gt;(value, done)&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; is used to access the hidden &lt;code&gt;done&lt;/code&gt; field.</source>
          <target state="translated">반복자가 실제로 한 쌍 &lt;code&gt;(value, done)&lt;/code&gt; 리턴 하고 &lt;code&gt;finished&lt;/code&gt; 는 숨겨진 &lt;code&gt;done&lt;/code&gt; 필드 에 액세스하는 데 사용 된다고 생각하는 데 도움 이됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7934ea36bb3abaeb6de1ae68617ee4fa3e89f7c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; safe to disable the garbage collector and enable it after the call from your background thread even if the code you are calling is short lived.</source>
          <target state="translated">이다 &lt;strong&gt;없는&lt;/strong&gt; 가비지 컬렉터를 사용하지 않도록하고 호출하는 코드가 수명이 짧은 경우에도 귀하의 백그라운드 스레드에서 호출 후 활성화하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0ce32c42207b074e8614eb82e24a7a71033a751d" translate="yes" xml:space="preserve">
          <source>It is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</source>
          <target state="translated">내재적으로 도입 된 포인터를 사용하여 수명이 지난 위치에 액세스 할 수있는 경우 컴파일 시간 오류입니다.</target>
        </trans-unit>
        <trans-unit id="654b26d139effb1815e88b12fee61a0a858572c0" translate="yes" xml:space="preserve">
          <source>It is also important that the replay involves the &lt;code&gt;import&lt;/code&gt; statement so that the dependencies are resolved properly.</source>
          <target state="translated">재생에 &lt;code&gt;import&lt;/code&gt; 문이 포함되어 종속성이 올바르게 해결되는 것도 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="2d729a9913be11aee103dc8aea1b73a4c4edcc41" translate="yes" xml:space="preserve">
          <source>It is an essential property of abstract types that they &lt;strong&gt;do not&lt;/strong&gt; imply a subtype relation between the abstract type and its base type. Explicit type conversions from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;SQL&lt;/code&gt; are allowed:</source>
          <target state="translated">추상 유형과 기본 유형 사이의 하위 유형 관계를 암시 &lt;strong&gt;하지 않는 것은&lt;/strong&gt; 추상 유형의 필수 특성입니다 . &lt;code&gt;string&lt;/code&gt; 에서 &lt;code&gt;SQL&lt;/code&gt; 로의 명시 적 유형 변환 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e31fcf4a46656a66279b459e1a0815babbcc226" translate="yes" xml:space="preserve">
          <source>It is important to note that reordering &lt;em&gt;only&lt;/em&gt; works for symbols at top level scope. Therefore, the following will &lt;em&gt;fail to compile:&lt;/em&gt;</source>
          <target state="translated">재정렬 은 최상위 수준의 심볼에 &lt;em&gt;대해서만&lt;/em&gt; 작동 한다는 점에 유의해야합니다 . 따라서 다음은 &lt;em&gt;컴파일에 실패합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eccab016e9c85070b264d0771a05edb52b43822b" translate="yes" xml:space="preserve">
          <source>It is not checked that the &lt;code&gt;except&lt;/code&gt; list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 목록이 실제로 모듈에서 내보내 졌는지 확인되지 않았습니다 . 이 기능을 사용하면 이러한 식별자를 내 보내지 않는 이전 버전의 모듈에 대해 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56aa33e889a1d3e8b0dbe2f53303f6d1de0ebdc" translate="yes" xml:space="preserve">
          <source>It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma &lt;code&gt;pragma&lt;/code&gt;:</source>
          <target state="translated">사용자 정의 유형의 pragma를 정의 할 수 있습니다. 사용자 정의 pragma는 코드 생성에 직접 영향을 미치지 않지만 매크로로 해당 존재를 감지 할 수 있습니다. 사용자 정의 pragma는 pragma &lt;code&gt;pragma&lt;/code&gt; 로 주석이 달린 템플릿을 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc420b00d95b0079b6bcd9cda3e4f93970825224" translate="yes" xml:space="preserve">
          <source>It is possible to raise/catch imported C++ exceptions. Types imported using &lt;em&gt;importcpp&lt;/em&gt; can be raised or caught. Exceptions are raised by value and caught by reference. Example:</source>
          <target state="translated">가져온 C ++ 예외를 발생 / 포착 할 수 있습니다. &lt;em&gt;importcpp&lt;/em&gt; 를 사용하여 가져온 유형을 올리거나 잡을 수 있습니다. 예외는 가치에 의해 제기되고 참조에 의해 포착됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="82b23252352db8b301d0df8ca78112f74b272448" translate="yes" xml:space="preserve">
          <source>It is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</source>
          <target state="translated">배열이 0에서 시작하는 것이 일반적이므로 0에서 지정된 인덱스에서 1을 뺀 범위를 지정하는 바로 가기 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="82118804703a69ba666b11e8579a1411bb333d2a" translate="yes" xml:space="preserve">
          <source>It may be surprising but the function as a whole can take longer than the specified timeout, only individual internal calls on the socket are affected. In practice this means that as long as the server is sending data an exception will not be raised, if however data does not reach the client within the specified timeout a &lt;code&gt;TimeoutError&lt;/code&gt; exception will be raised.</source>
          <target state="translated">놀랍지 만 전체 기능이 지정된 시간 초과보다 오래 걸릴 수 있으며 소켓의 개별 내부 호출에만 영향을 미칩니다. 실제로 이것은 서버가 데이터를 전송하는 한 예외가 발생하지 않지만 지정된 시간 제한 내에 데이터가 클라이언트에 도달하지 않으면 &lt;code&gt;TimeoutError&lt;/code&gt; 예외가 발생한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="919d2993bd870949c788657a2aacbe74a9e6d3fc" translate="yes" xml:space="preserve">
          <source>It must be a call expression &lt;code&gt;f(a, ...)&lt;/code&gt;.</source>
          <target state="translated">호출 표현식 &lt;code&gt;f(a, ...)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1bdeab513f38cc4e202661fc69c3b7e5aa7c684" translate="yes" xml:space="preserve">
          <source>It must contain &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 분기 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f548d24fefd8a46690cd32590a6cce7dfd8f4a7" translate="yes" xml:space="preserve">
          <source>It must not contain &lt;code&gt;elif&lt;/code&gt; branches.</source>
          <target state="translated">&lt;code&gt;elif&lt;/code&gt; 분기를 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0657d7c3802eac9139afa1fdbbc00243500a126" translate="yes" xml:space="preserve">
          <source>It's a static error if the compiler cannot perform the evaluation at compile time.</source>
          <target state="translated">컴파일러가 컴파일 타임에 평가를 수행 할 수없는 경우 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b08a29bb41e597ad7a05123c2e5513c91c059874" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;from module import nil&lt;/code&gt; if one wants to import the module but wants to enforce fully qualified access to every symbol in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">그것은 사용하는 것도 가능 &lt;code&gt;from module import nil&lt;/code&gt; 하나의 모듈을 수입하고 싶어하지만, 모든 기호에 대한 완전한 액세스 시행하고자하는 경우 &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de95b4993b261b85e3332b1324f8a0290c259dec" translate="yes" xml:space="preserve">
          <source>It's recommended to use &lt;code&gt;addCallback&lt;/code&gt; or &lt;code&gt;then&lt;/code&gt; instead.</source>
          <target state="translated">사용하는 것이 좋습니다 &lt;code&gt;addCallback&lt;/code&gt; 하거나 &lt;code&gt;then&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="cadaa83ad0b6b331d838560da721266dc244b734" translate="yes" xml:space="preserve">
          <source>Iterate over all the directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 과 일치하는 모든 디렉토리를 반복하십시오 . POSIX에서는 &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e75e34b52a6961303566d6b4dd5b3c4b21d77274" translate="yes" xml:space="preserve">
          <source>Iterate over all the files and directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 과 일치하는 모든 파일 및 디렉토리를 반복하십시오 . POSIX에서는 &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9d643234b1583c1062d05608e19e2329372f5e89" translate="yes" xml:space="preserve">
          <source>Iterate over all the files that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 과 일치하는 모든 파일을 반복합니다 . POSIX에서는 &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="584cc308ff50e7947ff5a4e8292a45088ef391f4" translate="yes" xml:space="preserve">
          <source>Iterate over any line in the file &lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">파일의 모든 줄을 반복합니다 . &lt;em&gt;f&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1c0deeb78059911d4801816fdd1f4f108e438a" translate="yes" xml:space="preserve">
          <source>Iterates over [optional &lt;em&gt;eat&lt;/em&gt;] &lt;em&gt;delim&lt;/em&gt;-delimited slices in MemFile &lt;em&gt;mfile&lt;/em&gt;.</source>
          <target state="translated">MemFile &lt;em&gt;mfile&lt;/em&gt; 에서 [선택적인 &lt;em&gt;eat&lt;/em&gt; ] &lt;em&gt;delim-&lt;/em&gt; delimited 슬라이스를 반복 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52d58a07e8a9d8fd6b99e5571402712d73dfd13e" translate="yes" xml:space="preserve">
          <source>Iterates over all the children of &lt;em&gt;n&lt;/em&gt; returning those matching &lt;em&gt;tag&lt;/em&gt;.</source>
          <target state="translated">일치하는 &lt;em&gt;태그를&lt;/em&gt; 반환하는 &lt;em&gt;n의&lt;/em&gt; 모든 자식을 반복 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b19228b3b231795b187dec3bdf8a6cb478e6ffc7" translate="yes" xml:space="preserve">
          <source>Iterates over any line in the file named &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 의 모든 줄을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="232f547ddc65be9624e107036fe1044b4d2a410d" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning runes</source>
          <target state="translated">문자열을 반환하는 룬 &lt;code&gt;s&lt;/code&gt; 모든 유니 코드 문자를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="8bc06e9d0c093f624eaf1ffbfc94ebe52d5cb792" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning utf8 values</source>
          <target state="translated">utf8 값을 리턴 하는 문자열 &lt;code&gt;s&lt;/code&gt; 모든 유니 코드 문자를 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="0388ab64e5b2bc44c4842558d16b95e6873ca62a" translate="yes" xml:space="preserve">
          <source>Iterates over every field of &lt;em&gt;x&lt;/em&gt; returning their name and value.</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; 모든 필드를 반복 하여 이름과 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00e6300c1169713ff3c5939859f36401dc5c4eee" translate="yes" xml:space="preserve">
          <source>Iterates over every line in the stream. The iteration is based on &lt;code&gt;readLine&lt;/code&gt;.</source>
          <target state="translated">스트림의 모든 라인을 반복합니다. 반복은 &lt;code&gt;readLine&lt;/code&gt; 을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="d86ccc2321238c55eb2895e898e51e2cea46b931" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the ordered set &lt;em&gt;s&lt;/em&gt; in insertion order.</source>
          <target state="translated">순서가 지정된 세트 &lt;em&gt;의&lt;/em&gt; 키 를 삽입 순서대로 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="c71c7420dcf70891eaaf12e2494e2aabe991e2e1" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">세트 &lt;em&gt;의&lt;/em&gt; 키를 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="46bdee16e1d678daf2434ac56d4f6f640c4d7297" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt; and its indices.</source>
          <target state="translated">NimNode &lt;code&gt;n&lt;/code&gt; 의 하위 및 해당 인덱스를 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="a478441af6bfca796118a06d6ecf3801a9262e8d" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">NimNode &lt;code&gt;n&lt;/code&gt; 의 자식을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="019eedce602970f3a59ce2f86870397544031ca8" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if every item fulfills the predicate.</source>
          <target state="translated">컨테이너를 반복하고 모든 항목이 술어를 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3501cb1c35511e4764121e28692134446b5075eb" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if some item fulfills the predicate.</source>
          <target state="translated">컨테이너를 반복하고 일부 항목이 술어를 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7fbdcafeaa504e0cbb5d1d512e8dfbaba8410003" translate="yes" xml:space="preserve">
          <source>Iterates through a container and yields every item that fulfills the predicate.</source>
          <target state="translated">컨테이너를 반복하고 술어를 충족시키는 모든 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="81ad0b1b4463be831a5785f4d06c130b3622cb6b" translate="yes" xml:space="preserve">
          <source>Iterator declaration</source>
          <target state="translated">반복자 선언</target>
        </trans-unit>
        <trans-unit id="edfa2bc8a9c8c3896d560c27f80be0217d6f76a5" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 의 자식 요소에 대한 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 JObject 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7b68d08a7df61a331ce7105b12ff381cd2542871" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject. Values can be modified</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 의 자식 요소에 대한 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 JObject 여야합니다. 값을 수정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6229022bcfa1dd29b2c2a761afb0d2b506503b49" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 항목의 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 JArray 여야합니다.</target>
        </trans-unit>
        <trans-unit id="937eeb4e7eb8e59ed90bf865be25f2439aa4af89" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray. Items can be modified.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 항목의 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 JArray 여야합니다. 항목을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853abfbfe15cced2111de5887bb206586352e215" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 항목의 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 SList 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cba2124d3f6e176e90018e400cd94d03ff65e532" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList. Items can be modified.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 항목의 반복자입니다 . &lt;em&gt;node&lt;/em&gt; 는 SList 여야합니다. 항목을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e0b6581a3426edca0a47a508b898e82d9d301321" translate="yes" xml:space="preserve">
          <source>Iterators and the for statement</source>
          <target state="translated">반복자와 for 문</target>
        </trans-unit>
        <trans-unit id="c425b7e3d2bb19788f1181a2d9b7a44e6225c0c2" translate="yes" xml:space="preserve">
          <source>Iterators can only be called from for loops.</source>
          <target state="translated">반복자는 for 루프에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df973b05a9a30c48e0cd32ea43a5a32471fddcf5" translate="yes" xml:space="preserve">
          <source>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</source>
          <target state="translated">컴파일러는 반복자를 인라인 할 수 있어야하기 때문에 반복자를 전달할 수 없습니다. (이 제한은 이후 버전의 컴파일러에서 사라질 것입니다.)</target>
        </trans-unit>
        <trans-unit id="5ab10982165c8e92be42e548c908af50f06450ed" translate="yes" xml:space="preserve">
          <source>Iterators cannot contain a &lt;code&gt;return&lt;/code&gt; statement (and procs cannot contain a &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">반복자는 &lt;code&gt;return&lt;/code&gt; 문을 포함 할 수 없으며 procs는 &lt;code&gt;yield&lt;/code&gt; 문을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6bf87542270934bc52223ff3fd2180cee9913ce5" translate="yes" xml:space="preserve">
          <source>Iterators do not support recursion.</source>
          <target state="translated">반복자는 재귀를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f13b815d55263a0262e1d3f448ea1ef694f0c5ac" translate="yes" xml:space="preserve">
          <source>Iterators have no implicit &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">반복자는 암시 적 &lt;code&gt;result&lt;/code&gt; 변수 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="876bf01455350b312419f0cdb54d8032bb9cad66" translate="yes" xml:space="preserve">
          <source>Iterators look very similar to procedures, but there are several important differences:</source>
          <target state="translated">반복자는 절차와 매우 유사하지만 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc9cd0b4b1a838a8dbe53e1eea311fe67780b4c" translate="yes" xml:space="preserve">
          <source>Iterators that are neither marked &lt;code&gt;{.closure.}&lt;/code&gt; nor &lt;code&gt;{.inline.}&lt;/code&gt; explicitly default to being inline, but this may change in future versions of the implementation.</source>
          <target state="translated">&lt;code&gt;{.closure.}&lt;/code&gt; 또는 &lt;code&gt;{.inline.}&lt;/code&gt; 으로 표시되지 않은 반복기는 기본적으로 인라인으로 기본 설정되지만 이후 버전의 구현에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38589c6c98e2050e493732fa1ecf1db5355eff6a" translate="yes" xml:space="preserve">
          <source>Its expression must always be &lt;code&gt;nimvm&lt;/code&gt;. More complex expressions are not allowed.</source>
          <target state="translated">표현식은 항상 &lt;code&gt;nimvm&lt;/code&gt; 이어야합니다 . 더 복잡한 표현은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="cc51bafafaa93b2fbf580ec2042f2d93d08d2a66" translate="yes" xml:space="preserve">
          <source>JSON node</source>
          <target state="translated">JSON 노드</target>
        </trans-unit>
        <trans-unit id="10e429d7ec1e1bc197f5757d96b736f7f4406dc2" translate="yes" xml:space="preserve">
          <source>JSON representation is stored in the passed &lt;em&gt;result&lt;/em&gt;</source>
          <target state="translated">JSON 표현은 전달 된 &lt;em&gt;결과에&lt;/em&gt; 저장됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d58199ede61c8be4b203d8081423f4280c50eb7c" translate="yes" xml:space="preserve">
          <source>JavaScript compatibility</source>
          <target state="translated">자바 스크립트 호환성</target>
        </trans-unit>
        <trans-unit id="f916a308bc581d1790072c2938487f3e908716e7" translate="yes" xml:space="preserve">
          <source>JavaScript invocation example</source>
          <target state="translated">자바 스크립트 호출 예제</target>
        </trans-unit>
        <trans-unit id="763eb4bbded920e91a4a60898d473e2e59d035cd" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;delete&lt;/em&gt; operator</source>
          <target state="translated">자바 스크립트의 &lt;em&gt;삭제&lt;/em&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="7069adda83e85fa6bdd1af127a53c1cd02199edc" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;require&lt;/em&gt; function</source>
          <target state="translated">JavaScript &lt;em&gt;는&lt;/em&gt; 함수를 &lt;em&gt;요구한다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e59bd4e62783475d358a55e576f9e1db556cc458" translate="yes" xml:space="preserve">
          <source>JavaScript's __dirname pseudo-variable</source>
          <target state="translated">JavaScript의 __dirname 의사 변수</target>
        </trans-unit>
        <trans-unit id="c05cec6255459be0665ced8c38873552b1af2710" translate="yes" xml:space="preserve">
          <source>JavaScript's __filename pseudo-variable</source>
          <target state="translated">JavaScript의 __filename 의사 변수</target>
        </trans-unit>
        <trans-unit id="48e39cbab3720cf60b021ee6573c7b065c55248f" translate="yes" xml:space="preserve">
          <source>JavaScript's arguments pseudo-variable</source>
          <target state="translated">유사 변수의 JavaScript 인수</target>
        </trans-unit>
        <trans-unit id="54d029c76d92f4b9cfa620d278a0227c9c10f25f" translate="yes" xml:space="preserve">
          <source>JavaScript's null literal</source>
          <target state="translated">자바 스크립트의 null 리터럴</target>
        </trans-unit>
        <trans-unit id="cf269e0f71fff143464c4dce0ba8941aff38d4fb" translate="yes" xml:space="preserve">
          <source>JavaScript's undefined literal</source>
          <target state="translated">자바 스크립트의 정의되지 않은 리터럴</target>
        </trans-unit>
        <trans-unit id="dcbcd7e22ce06dbd66e5b01adffbd52ed0a91c58" translate="yes" xml:space="preserve">
          <source>Joins two URLs together, separating them with / if needed.</source>
          <target state="translated">두 개의 URL을 결합하여 필요한 경우 /로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6b949efa98af5de2c9a9e2aa57c0ac512664c7bb" translate="yes" xml:space="preserve">
          <source>Joins two directory names to one.</source>
          <target state="translated">두 개의 디렉토리 이름을 하나로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f916106b08687c9b3604d03769854685d4185a21" translate="yes" xml:space="preserve">
          <source>Just like an &lt;em&gt;if expression&lt;/em&gt;, but corresponding to the when statement.</source>
          <target state="translated">그냥 같은 &lt;em&gt;경우 표현&lt;/em&gt; 하지만, 때 문에 해당.</target>
        </trans-unit>
        <trans-unit id="1f5a23579b9dec30ee62832658d6b0b949930854" translate="yes" xml:space="preserve">
          <source>Just like in regular type classes, Nim discriminates between &lt;code&gt;bind once&lt;/code&gt; and &lt;code&gt;bind many&lt;/code&gt; types when matching the concept. You can add the &lt;code&gt;distinct&lt;/code&gt; modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:</source>
          <target state="translated">일반 유형 클래스와 마찬가지로 Nim은 &lt;code&gt;bind once&lt;/code&gt; 과 개념을 일치시킬 때 &lt;code&gt;bind many&lt;/code&gt; 유형을 바인드 하는 것을 구별 합니다. 다른 유추 할 수없는 유형에 &lt;code&gt;distinct&lt;/code&gt; 수정자를 추가하여 영구적으로 유추하지 않고 일치하는 유형을 얻을 수 있습니다. 이것은 같은 종류의 클래스를 수용하는 여러 프로세스를 일치시켜야 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3706f82fc751aa40a365d4e0255b0c559571efe9" translate="yes" xml:space="preserve">
          <source>Just like in this example we pass the path to the &lt;code&gt;mylib.a&lt;/code&gt; library (and we could as well pass &lt;code&gt;logic.o&lt;/code&gt;) we could be passing switches to link any other static C library.</source>
          <target state="translated">이 예제에서와 같이 &lt;code&gt;mylib.a&lt;/code&gt; 라이브러리에 경로를 전달하고 (그리고 &lt;code&gt;logic.o&lt;/code&gt; 도 전달할 수 있음) 다른 정적 C 라이브러리를 연결하기 위해 스위치를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec69238a91ddb84ddd174a422a2bc6d89e341833" translate="yes" xml:space="preserve">
          <source>Just like strings, custom data types that are to be shared between Nim and the backend will need careful consideration of who controls who. If you want to hand a Nim reference to C code, you will need to use &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; to mark the reference as used, so it does not get freed. And for the C backend you will need to expose the &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc to clean up this memory when it is not required any more.</source>
          <target state="translated">문자열과 마찬가지로 Nim과 백엔드간에 공유 될 사용자 정의 데이터 유형은 누가 제어하는 ​​사람을 신중하게 고려해야합니다. C 코드에 Nim 참조를 전달하려면 &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; 를 사용 하여 참조를 사용 된 것으로 표시 해야 하므로 해제되지 않습니다. 그리고 C 백엔드의 경우 더 이상 필요하지 않은 경우이 메모리를 정리 하려면 &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc을 노출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1934a4d1d0bfda8c814a6f373c36bed11fcc1a9" translate="yes" xml:space="preserve">
          <source>Just like with regular pointers, covariance will be enabled only for immutable values:</source>
          <target state="translated">일반 포인터와 마찬가지로 공분산은 변경 불가능한 값에 대해서만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ba04be8caff7a5b413c929b67abe644a93a8234c" translate="yes" xml:space="preserve">
          <source>Keeping track of memory</source>
          <target state="translated">메모리 추적</target>
        </trans-unit>
        <trans-unit id="c3cc4a28dc3c7c50a7cedf645fccd862a77c3448" translate="yes" xml:space="preserve">
          <source>Keeps the items in the passed sequence if they fulfilled the predicate. Same as the &lt;code&gt;filter&lt;/code&gt; proc, but modifies the sequence directly.</source>
          <target state="translated">술어를 이행 한 경우 항목을 전달 된 순서로 유지합니다. &lt;code&gt;filter&lt;/code&gt; proc 와 동일 하지만 시퀀스를 직접 수정합니다.</target>
        </trans-unit>
        <trans-unit id="cd0b9402bb38009f565aff1f5e64a66bff29662b" translate="yes" xml:space="preserve">
          <source>Kill the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill()&lt;/code&gt; is simply an alias for &lt;code&gt;terminate()&lt;/code&gt;.</source>
          <target state="translated">프로세스 &lt;em&gt;p를 종료하십시오&lt;/em&gt; . Posix OS에서 절차는 &lt;code&gt;SIGKILL&lt;/code&gt; 을 프로세스로 보냅니다 . Windows에서 &lt;code&gt;kill()&lt;/code&gt; 은 단순히 &lt;code&gt;terminate()&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="71e0d9df3f621a55340e5e059ae130eb41a5eb1c" translate="yes" xml:space="preserve">
          <source>Lambda lifting is implemented as part of the &lt;code&gt;transf&lt;/code&gt; pass. The &lt;code&gt;transf&lt;/code&gt; pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is &lt;code&gt;void*&lt;/code&gt; and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying &lt;code&gt;s.ast[paramPos]&lt;/code&gt; to contain the formal hidden parameter, but not &lt;code&gt;s.typ&lt;/code&gt;!</source>
          <target state="translated">람다 리프팅은 &lt;code&gt;transf&lt;/code&gt; 패스의 일부로 구현됩니다 . &lt;code&gt;transf&lt;/code&gt; 패스 설정에 환경을 코드를 생성하고 주위에 전달합니다. 그러나이 패스는 유형을 변경하지 않습니다! 여기에 어떤 종류의 불일치가 있습니다. 한편으로 proc 표현식은 명시적인 튜플이되고, 반면에 tyProc (ccClosure) 유형은 변경되지 않습니다. C 코드 생성의 경우 숨겨진 형식 매개 변수가 &lt;code&gt;void*&lt;/code&gt; 이며 더 특수한 것이 아니라는 것도 중요합니다 . 그러나 더 전문화 된 env 유형은 어떻게 든 백엔드로 전달되어야합니다. 우리는 수정하여이 처리 &lt;code&gt;s.ast[paramPos]&lt;/code&gt; 하지만, 공식 숨겨진 매개 변수를 포함하는 &lt;code&gt;s.typ&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="6f81dcaf384dc8f0c6782aafff539ab7cb63534e" translate="yes" xml:space="preserve">
          <source>Language Manual</source>
          <target state="translated">언어 매뉴얼</target>
        </trans-unit>
        <trans-unit id="f1a81de77c30016ff417d2dc8525d90f0c658140" translate="yes" xml:space="preserve">
          <source>Large example</source>
          <target state="translated">큰 예</target>
        </trans-unit>
        <trans-unit id="309493ddacc4fb8306467fc937e00c3cfc275435" translate="yes" xml:space="preserve">
          <source>Larger example</source>
          <target state="translated">더 큰 예</target>
        </trans-unit>
        <trans-unit id="84d8b12a98abf233ce61b735b7f623dfa748d624" translate="yes" xml:space="preserve">
          <source>Later versions of Nim can be more precise about the borrowing rule with a syntax like:</source>
          <target state="translated">최신 버전의 Nim은 다음과 같은 구문을 사용하여 차용 규칙에 대해 더 정확할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84ad3bb11b5b72ae8064b2e03ac6593bfc14c79" translate="yes" xml:space="preserve">
          <source>Later versions of the language will weaken the requirements for forward declarations.</source>
          <target state="translated">이후 버전의 언어는 사전 선언 요구 사항을 약화시킵니다.</target>
        </trans-unit>
        <trans-unit id="b6e6ff1bcd7ed1a5e8f4c37ec0106d2e2587cae3" translate="yes" xml:space="preserve">
          <source>Lazy type resolution for untyped</source>
          <target state="translated">형식화되지 않은 게으른 형식 해상도</target>
        </trans-unit>
        <trans-unit id="a4f7fe013eb75f3bd7abaac6e67f4376f5da9c25" translate="yes" xml:space="preserve">
          <source>Leaf nodes/Atoms</source>
          <target state="translated">리프 노드 / 원자</target>
        </trans-unit>
        <trans-unit id="a6702a5291853b1308e7bd674d53f7e0975e6409" translate="yes" xml:space="preserve">
          <source>Left-Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">왼쪽에 정렬은 문자열 &lt;em&gt;s의&lt;/em&gt; 와 &lt;em&gt;패딩&lt;/em&gt; 은 길이입니다 그래서, &lt;em&gt;수&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="581f4b8c009369b50e3d9ba5325d87417e6534b8" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 16-bits value.</source>
          <target state="translated">16 비트 값의 왼쪽 회전 비트.</target>
        </trans-unit>
        <trans-unit id="d3409f80fea6038549fe1206956266f2e8a6fbb1" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 32-bits value.</source>
          <target state="translated">32 비트 값의 왼쪽 회전 비트.</target>
        </trans-unit>
        <trans-unit id="0aef55ce888f5b32fb20afe0a6d757edd1ce8821" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 64-bits value.</source>
          <target state="translated">64 비트 값의 왼쪽 회전 비트.</target>
        </trans-unit>
        <trans-unit id="73e3851ee7450c9ad9c84aa2c1e0ca99eeb3856b" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 8-bits value.</source>
          <target state="translated">8 비트 값의 왼쪽 회전 비트.</target>
        </trans-unit>
        <trans-unit id="08b05a7cc45a3cfbb0bd52f3553051c002b98ea9" translate="yes" xml:space="preserve">
          <source>Let section</source>
          <target state="translated">섹션을 보자</target>
        </trans-unit>
        <trans-unit id="aa344992ab3c9cce0c812154c891a2082a0f43d5" translate="yes" xml:space="preserve">
          <source>Let us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.</source>
          <target state="translated">다른 프로그래밍 언어와 마찬가지로 Nim은 (문자열) 리터럴, 식별자, 키워드, 주석, 연산자 및 기타 문장 부호로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b472892cf2e180fd60510de81af55b7e2fd6e956" translate="yes" xml:space="preserve">
          <source>Let's return to the simple counting example:</source>
          <target state="translated">간단한 카운팅 예제로 돌아가 봅시다 :</target>
        </trans-unit>
        <trans-unit id="3714e6d8f0e24eacd7b52251a4d193e3636ffbc7" translate="yes" xml:space="preserve">
          <source>Let's start with an example: a procedure that finds the index of a character in a string.</source>
          <target state="translated">문자열에서 문자의 인덱스를 찾는 프로 시저를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1be636c6149d23a6ac7030b7b471d95740b30580" translate="yes" xml:space="preserve">
          <source>Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.</source>
          <target state="translated">프로 시저 호출이 어떻게 분류되는지에 대한 느낌을 얻기 위해 많은 흥미로운 측면이있는 프로 시저를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f090ebad1e9028f1098a5af4e5a797eb536bf181" translate="yes" xml:space="preserve">
          <source>Lets</source>
          <target state="translated">Lets</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="0948974278e3b95cbbb246e9eab8bec6da78b254" translate="yes" xml:space="preserve">
          <source>Lexical Analysis</source>
          <target state="translated">어휘 분석</target>
        </trans-unit>
        <trans-unit id="484504bca1de9d78289cf5ed0ff59489797fb25f" translate="yes" xml:space="preserve">
          <source>Lexical elements</source>
          <target state="translated">어휘 요소</target>
        </trans-unit>
        <trans-unit id="fd70e598fcf927041c896f6dc4b87e917b2286bf" translate="yes" xml:space="preserve">
          <source>Library documentation</source>
          <target state="translated">도서관 문서</target>
        </trans-unit>
        <trans-unit id="850e532a72f1397362ed6c2e2c7768467301292f" translate="yes" xml:space="preserve">
          <source>Licence of the PCRE library</source>
          <target state="translated">PCRE 라이브러리의 라이센스</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="7babbd6a13612f2b75fad2536bf20e3a90be6f3a" translate="yes" xml:space="preserve">
          <source>Lifting Procs</source>
          <target state="translated">리프팅 프로세스</target>
        </trans-unit>
        <trans-unit id="133720a88f4f0b2480df1a722653e8f80be2609a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exportc&lt;/code&gt; or &lt;code&gt;importc&lt;/code&gt;, the &lt;code&gt;extern&lt;/code&gt; pragma affects name mangling. The string literal passed to &lt;code&gt;extern&lt;/code&gt; can be a format string:</source>
          <target state="translated">마찬가지로 &lt;code&gt;exportc&lt;/code&gt; 또는 &lt;code&gt;importc&lt;/code&gt; 의 &lt;code&gt;extern&lt;/code&gt; pragma는 이름 맹 글링에 영향을 미칩니다. &lt;code&gt;extern&lt;/code&gt; 에 전달 된 문자열 리터럴 은 형식 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89c659521de912108568798c30a4d3b9390dd11" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkDiscardStmt&lt;/code&gt; kind.</source>
          <target state="translated">마찬가지로 &lt;code&gt;return&lt;/code&gt; 하지만,와 &lt;code&gt;nnkDiscardStmt&lt;/code&gt; 의 종류.</target>
        </trans-unit>
        <trans-unit id="70b76be5ae3e05bda0dbd20d90abcc0ff40f9de9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkYieldStmt&lt;/code&gt; kind.</source>
          <target state="translated">마찬가지로 &lt;code&gt;return&lt;/code&gt; 하지만,와 &lt;code&gt;nnkYieldStmt&lt;/code&gt; 의 종류.</target>
        </trans-unit>
        <trans-unit id="b4cf638ae85ebba4736e92856cb8c627ef275c96" translate="yes" xml:space="preserve">
          <source>Like a plain &lt;code&gt;import&lt;/code&gt; statement but with &lt;code&gt;nnkIncludeStmt&lt;/code&gt;.</source>
          <target state="translated">일반 &lt;code&gt;import&lt;/code&gt; 문과 비슷하지만 &lt;code&gt;nnkIncludeStmt&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a95e62d7c911dbac4f0639f9bb4cb823deae98" translate="yes" xml:space="preserve">
          <source>Like in many other programming languages, a &lt;code&gt;continue&lt;/code&gt; statement starts the next iteration immediately:</source>
          <target state="translated">다른 많은 프로그래밍 언어와 마찬가지로 &lt;code&gt;continue&lt;/code&gt; 문은 다음 반복을 즉시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="35a4297befbf3cbceda9715d4684f55b9e927a9e" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;if&lt;/code&gt; statement, but the root has the kind &lt;code&gt;nnkWhenStmt&lt;/code&gt;.</source>
          <target state="translated">등의 &lt;code&gt;if&lt;/code&gt; 문하지만, 뿌리는 종류가 &lt;code&gt;nnkWhenStmt&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ab04aac5a7e1d598d2f186753e388a3731d77143" translate="yes" xml:space="preserve">
          <source>Like tuples, objects are a means to pack different values together in a structured way. However, objects provide many features that tuples do not: They provide inheritance and information hiding. Because objects encapsulate data, the &lt;code&gt;T()&lt;/code&gt; object constructor should only be used internally and the programmer should provide a proc to initialize the object (this is called a &lt;em&gt;constructor&lt;/em&gt;).</source>
          <target state="translated">튜플과 마찬가지로 객체는 서로 다른 값을 체계적으로 묶는 수단입니다. 그러나 객체는 튜플이 제공하지 않는 많은 기능을 제공합니다. 상속 및 정보 숨기기를 제공합니다. 객체는 데이터를 캡슐화하기 때문에 &lt;code&gt;T()&lt;/code&gt; 객체 생성자는 내부적으로 만 사용해야하며 프로그래머는 객체를 초기화하기위한 proc을 제공해야합니다 ( &lt;em&gt;생성자&lt;/em&gt; 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="07bc01629a98c42a6a26d28d793349cd9ddcb413" translate="yes" xml:space="preserve">
          <source>Likewise &lt;code&gt;T = ref T&lt;/code&gt; is an invalid type.</source>
          <target state="translated">마찬가지로 &lt;code&gt;T = ref T&lt;/code&gt; 는 유효하지 않은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="012148b3c7c09fe4183a821ac0dfc3df94a4644a" translate="yes" xml:space="preserve">
          <source>Likewise for generic matches the most specialized generic type (that still matches) is preferred:</source>
          <target state="translated">마찬가지로 일반 일치의 경우 가장 일치하는 일반 형식 (여전히 일치하는)이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe316ffb5c502363f1602369491e5771962db68" translate="yes" xml:space="preserve">
          <source>Likewise the following does not make sense as the name is &lt;code&gt;strutils&lt;/code&gt; already:</source>
          <target state="translated">마찬가지로 이름이 이미 &lt;code&gt;strutils&lt;/code&gt; 이므로 다음과 같은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="79cb6c70879ccadb6a188effd65c3c269014aee8" translate="yes" xml:space="preserve">
          <source>Limitations of the method call syntax</source>
          <target state="translated">메소드 호출 구문의 한계</target>
        </trans-unit>
        <trans-unit id="7556b5753ea0ca8128d6f780d7fa036fc5b03486" translate="yes" xml:space="preserve">
          <source>Limitations/Bugs</source>
          <target state="translated">Limitations/Bugs</target>
        </trans-unit>
        <trans-unit id="81e5623d345118d762dbee1a0e1de32ed5723969" translate="yes" xml:space="preserve">
          <source>Limitations: If used within nim VM context &lt;code&gt;sizeof&lt;/code&gt; will only work for simple types.</source>
          <target state="translated">제한 사항 : nim VM context &lt;code&gt;sizeof&lt;/code&gt; 내에서 사용되는 경우 단순 유형에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4c46adaafc40b789df2ecf20dd985f671faba467" translate="yes" xml:space="preserve">
          <source>Line exceeds the maximum length.</source>
          <target state="translated">선이 최대 길이를 초과합니다.</target>
        </trans-unit>
        <trans-unit id="223cc1feb0fa894d9ee9937b64e7b5859c71bc96" translate="yes" xml:space="preserve">
          <source>Line where the symbol is located in the file. Lines start to count at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">파일에서 기호가있는 줄입니다. 줄은 &lt;strong&gt;1&lt;/strong&gt; 부터 계산을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="6975daf276430ee5b07e3f0247df76b80c98d27d" translate="yes" xml:space="preserve">
          <source>LineDir option</source>
          <target state="translated">LineDir 옵션</target>
        </trans-unit>
        <trans-unit id="268d8379173ac37e106048c36fff01d9c9b4910e" translate="yes" xml:space="preserve">
          <source>LineTooLong</source>
          <target state="translated">LineTooLong</target>
        </trans-unit>
        <trans-unit id="064387f46f31232c3427cd5f69fac7318fd9f966" translate="yes" xml:space="preserve">
          <source>LineTrace option</source>
          <target state="translated">LineTrace 옵션</target>
        </trans-unit>
        <trans-unit id="ac3679d78b17b02969cddb03c164e6e2d4dc3390" translate="yes" xml:space="preserve">
          <source>Lines should be no longer than 80 characters. Limiting the amount of information present on each line makes for more readable code - the reader has smaller chunks to process.</source>
          <target state="translated">줄은 80자를 넘지 않아야합니다. 각 줄에 존재하는 정보의 양을 제한하면 더 읽기 쉬운 코드가 만들어집니다. 독자는 처리 할 청크가 적습니다.</target>
        </trans-unit>
        <trans-unit id="b0876c4bcec0ae3cbb0d666f7829f1981ec34562" translate="yes" xml:space="preserve">
          <source>Lines starting with &lt;code&gt;&amp;gt;&lt;/code&gt; indicate a command to be sent to the compiler and the lines following a command include checks for expected or forbidden output (&lt;code&gt;!&lt;/code&gt; for forbidden).</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; 으로 시작 하는 행은 컴파일러로 전송 될 명령을 나타내며 명령 다음의 행에는 예상 또는 금지 된 출력에 대한 검사가 포함됩니다 ( &lt;code&gt;!&lt;/code&gt; for forbidden).</target>
        </trans-unit>
        <trans-unit id="d0517071aa376e797705058bbad4b658954b9930" translate="yes" xml:space="preserve">
          <source>Link</source>
          <target state="translated">Link</target>
        </trans-unit>
        <trans-unit id="1c3cb2684d19be6954dbbdc4f8e73df679e8e5d0" translate="yes" xml:space="preserve">
          <source>Link pragma</source>
          <target state="translated">링크 pragma</target>
        </trans-unit>
        <trans-unit id="9da74ab1a4b986bea87990a9a620e399e5636c76" translate="yes" xml:space="preserve">
          <source>Linking phase.</source>
          <target state="translated">연결 단계.</target>
        </trans-unit>
        <trans-unit id="29298813156f944560ccc7706430702f6f4ee582" translate="yes" xml:space="preserve">
          <source>List comprehension, returns a sequence. &lt;em&gt;comp&lt;/em&gt; is the actual list comprehension, for example &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt;. &lt;em&gt;typ&lt;/em&gt; is the type that will be stored inside the result seq.</source>
          <target state="translated">리스트 이해, 시퀀스를 반환합니다. &lt;em&gt;comp&lt;/em&gt; 는 실제 목록 이해입니다 (예 : &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt; . &lt;em&gt;typ&lt;/em&gt; 는 결과 seq에 저장 될 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f8243f1d71ba9600f36e4fd5c7ce82f383a50045" translate="yes" xml:space="preserve">
          <source>List of hints</source>
          <target state="translated">힌트 목록</target>
        </trans-unit>
        <trans-unit id="5516fee04290d8fb240eb1035f9649b7af9c46bc" translate="yes" xml:space="preserve">
          <source>List of warnings</source>
          <target state="translated">경고 목록</target>
        </trans-unit>
        <trans-unit id="104e72166267b2e14189f97dfc051685f78e0501" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory.</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; 의 모든 파일을 나열합니다 . 경우 &lt;code&gt;dir&lt;/code&gt; 있다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 현재 작업 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1ab878ae07a9cde029575d5b2c8f1f1831aa46a7" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory. If &lt;code&gt;async&lt;/code&gt; is true, this function will return immediately and it will be your job to call asyncio's &lt;code&gt;poll&lt;/code&gt; to progress this operation.</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; 의 모든 파일을 나열합니다 . 경우 &lt;code&gt;dir&lt;/code&gt; 있다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 현재 작업 디렉토리를 사용합니다. 경우 &lt;code&gt;async&lt;/code&gt; 사실,이 기능은 즉시 반환하고는 전화 asyncio의에 당신의 일이 될 것입니다 &lt;code&gt;poll&lt;/code&gt; 이 작업을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="236263cf5e9fb34d2dba2a5c051ef5dc5349c21d" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">리터럴 &lt;code&gt;&quot;&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="b0e13df3237422a975bbec14b9ac839dee36c914" translate="yes" xml:space="preserve">
          <source>Literal match: &lt;code&gt;a&lt;/code&gt; is an integer literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a signed or unsigned integer type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range. Or: &lt;code&gt;a&lt;/code&gt; is a floating point literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a floating point type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range.</source>
          <target state="translated">리터럴 일치 : &lt;code&gt;a&lt;/code&gt; 는 값 &lt;code&gt;v&lt;/code&gt; 의 정수 리터럴 이고 &lt;code&gt;f&lt;/code&gt; 는 부호있는 또는 부호없는 정수 유형이고 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 범위에 있습니다. 또는 : &lt;code&gt;a&lt;/code&gt; 는 값 &lt;code&gt;v&lt;/code&gt; 의 부동 소수점 리터럴 이고 &lt;code&gt;f&lt;/code&gt; 는 부동 소수점 유형이며 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9727a86e89a8cbd82800b60294dabca16499a86" translate="yes" xml:space="preserve">
          <source>Literals are bounds checked so that they fit the datatype. Non base-10 literals are used mainly for flags and bit pattern representations, therefore bounds checking is done on bit width, not value range. If the literal fits in the bit width of the datatype, it is accepted. Hence: 0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1 instead of causing an overflow error.</source>
          <target state="translated">리터럴은 데이터 유형에 맞도록 바운드 검사됩니다. 기본이 아닌 10 리터럴은 주로 플래그 및 비트 패턴 표현에 사용되므로 범위 검사는 값 범위가 아닌 비트 폭에서 수행됩니다. 리터럴이 데이터 유형의 비트 너비에 맞는 경우 허용됩니다. 따라서 0b10000000'u8 == 0x80'u8 == 128이지만 오버플로 오류 대신 0b10000000'i8 == 0x80'i8 == -1입니다.</target>
        </trans-unit>
        <trans-unit id="8b2a6eba528cf2e8ab33fb4a2bec0b163b834789" translate="yes" xml:space="preserve">
          <source>Literals are compile-time computable.</source>
          <target state="translated">리터럴은 컴파일 타임 계산 가능합니다.</target>
        </trans-unit>
        <trans-unit id="de51bd63110c92754499c41c1b9fc0a1062026bc" translate="yes" xml:space="preserve">
          <source>Load the specified configuration file into a new Config instance.</source>
          <target state="translated">지정된 구성 파일을 새 구성 인스턴스로로드하십시오.</target>
        </trans-unit>
        <trans-unit id="1a9e1513745115068212c830b486292757f91900" translate="yes" xml:space="preserve">
          <source>Load the specified configuration from stream into a new Config instance. &lt;em&gt;filename&lt;/em&gt; parameter is only used for nicer error messages.</source>
          <target state="translated">지정된 구성을 스트림에서 새 구성 인스턴스로로드하십시오. &lt;em&gt;filename&lt;/em&gt; 매개 변수는 더 좋은 오류 메시지에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a139e4bbf5ca5504f1d17d1d98e927f4b59c9a47" translate="yes" xml:space="preserve">
          <source>Loading a simple C function</source>
          <target state="translated">간단한 C 함수로드</target>
        </trans-unit>
        <trans-unit id="d468cd435069219754afbbe7d097d97a919d76a4" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 파일에서 HTML을로드하고 구문 분석 하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 모든 구문 분석 오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e13175d1bc7af2e5d6755aeb721e7338069be90d" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 파일에서 HTML을로드하고 구문 분석 하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 발생한 모든 구문 분석 오류가 &lt;em&gt;오류&lt;/em&gt; 순서에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4296f849be147d08fdb9d341d2ab77c8da850fd7" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 파일에서 XML을로드 및 구문 분석 하고 &lt;code&gt;PDocument&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="26e2e2e83d566103f2e7459a72bbf8e836f49d66" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a stream specified by &lt;code&gt;stream&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">로드 및 파싱에 의해 지정된 스트림에서 XML &lt;code&gt;stream&lt;/code&gt; 및 반환 &lt;code&gt;PDocument&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="045d13349b264d2eba76a0804c08fa59e6a17cff" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a string specified by &lt;code&gt;xml&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 로 지정된 문자열에서 XML을로드하고 구문 분석 하고 &lt;code&gt;PDocument&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1f9e01e6b541364451c7b06cd42daa257c56a015" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 파일에서 XML을로드하고 구문 분석 하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 모든 구문 분석 오류는 &lt;code&gt;XmlError&lt;/code&gt; 예외 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="58715b2c04bf6ee07528232196803acf3ddcf9e8" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 파일에서 XML을로드하고 구문 분석 하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 발생한 모든 구문 분석 오류가 &lt;code&gt;errors&lt;/code&gt; 순서에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7db461111deca6d0f8236779f0bb1263494a8e8" translate="yes" xml:space="preserve">
          <source>Lock levels</source>
          <target state="translated">잠금 수준</target>
        </trans-unit>
        <trans-unit id="98f1e767de995c2aa21fe38394145cda4db0f95d" translate="yes" xml:space="preserve">
          <source>Lock levels are used to enforce a global locking order in order to prevent deadlocks at compile-time. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</source>
          <target state="translated">잠금 레벨은 컴파일시 교착 상태를 방지하기 위해 전역 잠금 순서를 적용하는 데 사용됩니다. 잠금 레벨은 0..1_000 범위의 상수 정수입니다. 잠금 레벨 0은 잠금이 전혀 획득되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a026b72d4824601afcdf130fca670d0c8d13f97d" translate="yes" xml:space="preserve">
          <source>Locks and routines can be annotated with &lt;span id=&quot;lock-levels_1&quot;&gt;lock levels&lt;/span&gt; to prevent deadlocks at compile time.</source>
          <target state="translated">컴파일 타임에 교착 상태를 방지하기 위해 &lt;span id=&quot;lock-levels_1&quot;&gt;잠금 레벨&lt;/span&gt; 에 잠금 및 루틴에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e5c380132554658df14cbe018d3eebcce0b49de" translate="yes" xml:space="preserve">
          <source>Logs a debug message to all registered handlers.</source>
          <target state="translated">등록 된 모든 핸들러에 디버그 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="4c7f919536de93b8ad43c3247437839e50803cac" translate="yes" xml:space="preserve">
          <source>Logs a fatal error message to all registered handlers.</source>
          <target state="translated">등록 된 모든 처리기에 치명적인 오류 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="5dfc8bdbe4c51442cb3331391bf133dae2303823" translate="yes" xml:space="preserve">
          <source>Logs a message to all registered handlers at the given level.</source>
          <target state="translated">주어진 레벨에서 등록 된 모든 핸들러에 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="57d8e0636873737f16f4b7cc780f237140e75837" translate="yes" xml:space="preserve">
          <source>Logs a warning message to all registered handlers.</source>
          <target state="translated">등록 된 모든 처리기에 경고 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9317adaad7621328486bdf8c1ddb1b9fc41f1e55" translate="yes" xml:space="preserve">
          <source>Logs an error message to all registered handlers.</source>
          <target state="translated">등록 된 모든 처리기에 오류 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="4b60a8dc51101a47288a87fdd0bfadc5f86cbf8e" translate="yes" xml:space="preserve">
          <source>Logs an info message to all registered handlers.</source>
          <target state="translated">등록 된 모든 처리기에 정보 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="d163792610c410f93f355f367ec68f39a5ba2888" translate="yes" xml:space="preserve">
          <source>Logs an notice message to all registered handlers.</source>
          <target state="translated">등록 된 모든 핸들러에 통지 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="968b9d0e2a2ece8aa91b1cc23a28091c21b0a82f" translate="yes" xml:space="preserve">
          <source>Logs to a file using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">&lt;code&gt;logger&lt;/code&gt; 만 사용하여 파일에 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="1a9ec4044346457b95a04e72c6feb17b0ce890ff" translate="yes" xml:space="preserve">
          <source>Logs to a file using rolling &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">롤링 &lt;code&gt;logger&lt;/code&gt; 만 사용하여 파일에 로그 합니다.</target>
        </trans-unit>
        <trans-unit id="50128c469a86270a2da91f8b00b431458f68392b" translate="yes" xml:space="preserve">
          <source>Logs to the console using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">&lt;code&gt;logger&lt;/code&gt; 만 사용하여 콘솔에 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="e8ee53aa3b26fe91c5819ca15b134a56f645ac1e" translate="yes" xml:space="preserve">
          <source>Lookup rules for template parameters</source>
          <target state="translated">템플릿 매개 변수에 대한 조회 규칙</target>
        </trans-unit>
        <trans-unit id="ce44bf0dea95522d8571be7ae1c1bf020f1c61c5" translate="yes" xml:space="preserve">
          <source>Loopback address.</source>
          <target state="translated">루프백 주소.</target>
        </trans-unit>
        <trans-unit id="ed3b229a877674fc9085bfff9aad369487b7967d" translate="yes" xml:space="preserve">
          <source>Lossless &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; exception is raised (if the error cannot be detected at compile time).</source>
          <target state="translated">무손실 &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;자동 유형 변환&lt;/span&gt; 은 다른 종류의 정수 유형이 사용되는 표현식에서 수행됩니다. 그러나 형식 변환으로 인해 정보가 손실되면 &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; 예외가 발생합니다 (컴파일시 오류를 감지 할 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="5ca6f7c7b2f3fcead3d5cf315885d15734fca9dc" translate="yes" xml:space="preserve">
          <source>Lots of other small issues...</source>
          <target state="translated">다른 많은 작은 문제들 ...</target>
        </trans-unit>
        <trans-unit id="b8a68b12b71fd0a8e62d67043581d497f4e0c387" translate="yes" xml:space="preserve">
          <source>Macro declaration</source>
          <target state="translated">매크로 선언</target>
        </trans-unit>
        <trans-unit id="d5f312834ff09b9cbab1f1a3ebc0bbe0f1a19b93" translate="yes" xml:space="preserve">
          <source>Macro which converts normal procedures into javascript-compatible async procedures</source>
          <target state="translated">일반 프로 시저를 JavaScript 호환 비동기 프로 시저로 변환하는 매크로</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="bcf4850e55a2614c2efa81a2629e41ec19afef8b" translate="yes" xml:space="preserve">
          <source>Macros as pragmas</source>
          <target state="translated">pragma로 매크로</target>
        </trans-unit>
        <trans-unit id="980cf51d761ff2e575f35b48bf655118288e07f9" translate="yes" xml:space="preserve">
          <source>Macros behave like templates, but &lt;code&gt;nnkTemplateDef&lt;/code&gt; is replaced with &lt;code&gt;nnkMacroDef&lt;/code&gt;.</source>
          <target state="translated">매크로 템플릿처럼 행동하지만, &lt;code&gt;nnkTemplateDef&lt;/code&gt; 는 대체됩니다 &lt;code&gt;nnkMacroDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fabe264274a80515010384b77dc0559e962ca19d" translate="yes" xml:space="preserve">
          <source>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;foreign function interface (FFI)&lt;/a&gt; is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</source>
          <target state="translated">매크로는 고급 컴파일 타임 코드 변환을 가능하게하지만 Nim의 구문을 변경할 수는 없습니다. 그러나 Nim의 구문이 충분히 유연하기 때문에 이것은 실제 제한이 아닙니다. 컴파일러에서 &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;FFI (Foreign Function Interface)&lt;/a&gt; 를 사용할 수없는 경우 매크로를 순수 Nim 코드로 구현해야 하지만, 그 제한 외 (어느 시점에 없어 질 것임 ) 가 아니라면 모든 종류의 Nim 코드를 작성할 수 있습니다. 컴파일러는 컴파일 타임에이를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4316199fa5a1551b8a3aa00b57acfb7552982193" translate="yes" xml:space="preserve">
          <source>Macros module includes helpers which can be used to simplify custom pragma access &lt;em&gt;hasCustomPragma&lt;/em&gt;, &lt;em&gt;getCustomPragmaVal&lt;/em&gt;. Please consult macros module documentation for details. These macros are no magic, they don't do anything you cannot do yourself by walking AST object representation.</source>
          <target state="translated">매크로 모듈에는 사용자 정의 pragma 액세스 &lt;em&gt;hasCustomPragma&lt;/em&gt; , &lt;em&gt;getCustomPragmaVal&lt;/em&gt; 을 단순화하는 데 사용할 수있는 도우미가 포함되어 있습니다 . 자세한 내용은 매크로 모듈 설명서를 참조하십시오. 이 매크로는 마법이 아니며, AST 객체 표현을 걸어서 스스로 할 수있는 일은하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcb1a29368fba3810f040b19c708029e63713744" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;osproc&lt;/code&gt; use &lt;code&gt;fork&lt;/code&gt; instead of &lt;code&gt;posix_spawn&lt;/code&gt;.</source>
          <target state="translated">만든다 &lt;code&gt;osproc&lt;/code&gt; 의 사용 &lt;code&gt;fork&lt;/code&gt; 대신 &lt;code&gt;posix_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c651f2d69bb1c5e0aa5eb7b1418517d939a6973" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log.</source>
          <target state="translated">서버 로그 대신 Nim 출력 스택 추적을 stdout으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="499d78e3579f7c7ce46ccd08c0c7e05dcf497fe4" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout.</source>
          <target state="translated">서버 로그 대신 Nim 출력 스택 추적을 stdout으로 만듭니다. setStackTraceStdout에 대한 설명이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e3d974a9298c4b4ebf6fa1f9cde4cea6a610923" translate="yes" xml:space="preserve">
          <source>Makes Nim use C's &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; instead of Nim's own memory manager, ableit prefixing each allocation with its size to support clearing memory on reallocation. This only works with &lt;code&gt;gc:none&lt;/code&gt;.</source>
          <target state="translated">Nim 이 Nim의 자체 메모리 관리자 대신 C의 &lt;span id=&quot;malloc_1&quot;&gt;malloc을&lt;/span&gt; 사용하게 하여 재 할당시 메모리 지우기를 지원하기 위해 각 할당에 크기를 접두어로 붙일 수 있습니다. 이것은 &lt;code&gt;gc:none&lt;/code&gt; 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3c24f6fa722204e68ea302ade8ca94caa0a75902" translate="yes" xml:space="preserve">
          <source>Mandatory term being indexed. Terms can include quoting according to Nim's rules (eg. `^`).</source>
          <target state="translated">인덱싱되는 필수 용어입니다. 용어에는 님의 규칙에 따른 인용 (예 :`^`)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="8b04fd7fca9bde6ca081d5a883719b86d91603ee" translate="yes" xml:space="preserve">
          <source>Manual: AST based overloading</source>
          <target state="translated">수동 : AST 기반 과부하</target>
        </trans-unit>
        <trans-unit id="defb0de64fe7ca08a6ed982374de4bb9a85c2662" translate="yes" xml:space="preserve">
          <source>Manual: Effect system</source>
          <target state="translated">수동 : 효과 시스템</target>
        </trans-unit>
        <trans-unit id="c96afc4df608947a129115509fc6ac1d02f56202" translate="yes" xml:space="preserve">
          <source>Manual: Exception handling</source>
          <target state="translated">수동 : 예외 처리</target>
        </trans-unit>
        <trans-unit id="ddfc1de56c3bd1d03afdd4142362226685aca4b2" translate="yes" xml:space="preserve">
          <source>Manual: Foreign function interface</source>
          <target state="translated">수동 : 외부 기능 인터페이스</target>
        </trans-unit>
        <trans-unit id="e56aa0932cbe0a4d0a9778061468fdfecc37f816" translate="yes" xml:space="preserve">
          <source>Manual: Generics</source>
          <target state="translated">매뉴얼 : 제네릭</target>
        </trans-unit>
        <trans-unit id="5774a3094051cc1a01178d4abbdf9174054d2afa" translate="yes" xml:space="preserve">
          <source>Manual: Guards and locks</source>
          <target state="translated">수동 : 가드 및 잠금</target>
        </trans-unit>
        <trans-unit id="034ba2f8aa22d8c1659925669461f5c6bb46d48d" translate="yes" xml:space="preserve">
          <source>Manual: Implementation Specific Pragmas</source>
          <target state="translated">매뉴얼 : 구현 관련 실습</target>
        </trans-unit>
        <trans-unit id="5b04a062ff7cc9d86ce05472065106035a8097fa" translate="yes" xml:space="preserve">
          <source>Manual: Import statement Include statement Module names in imports Collective imports from a directory Pseudo import/include paths From import statement Export statement</source>
          <target state="translated">수동 : 가져 오기 명령문 포함 명령문 가져 오기의 모듈 이름 디렉토리에서 일괄 가져 오기 의사 가져 오기 / 포함 경로 가져 오기 명령문에서 내보내기 명령문</target>
        </trans-unit>
        <trans-unit id="fd76cbedf6737eb16d94623f5ae0365ae0d604f1" translate="yes" xml:space="preserve">
          <source>Manual: Iterators and the for statement</source>
          <target state="translated">수동 : 반복자와 for 문</target>
        </trans-unit>
        <trans-unit id="a243b6fe56c421c23e6ef513dd30b788f1257a68" translate="yes" xml:space="preserve">
          <source>Manual: Lexical Analysis</source>
          <target state="translated">매뉴얼 : 어휘 분석</target>
        </trans-unit>
        <trans-unit id="ed3d84a9118355ed8740c1a7b3f3b4c841535124" translate="yes" xml:space="preserve">
          <source>Manual: Macros</source>
          <target state="translated">수동 : 매크로</target>
        </trans-unit>
        <trans-unit id="4bafc4dbfa5c0e3c58d2fb274d692bbf25d243fc" translate="yes" xml:space="preserve">
          <source>Manual: Modules</source>
          <target state="translated">수동 : 모듈</target>
        </trans-unit>
        <trans-unit id="9a290e826830f6686d0f05fcc67ab7c270d95dbb" translate="yes" xml:space="preserve">
          <source>Manual: Multi-methods</source>
          <target state="translated">수동 : 다중 방법</target>
        </trans-unit>
        <trans-unit id="11714535fa66e7fe2732c23bbc152d68d14f704d" translate="yes" xml:space="preserve">
          <source>Manual: Overloading resolution</source>
          <target state="translated">수동 : 과부하 해상도</target>
        </trans-unit>
        <trans-unit id="856ff8f109b24f9933255ac3581aadee568cd2dc" translate="yes" xml:space="preserve">
          <source>Manual: Parallel &amp;amp; Spawn</source>
          <target state="translated">매뉴얼 : Parallel &amp;amp; Spawn</target>
        </trans-unit>
        <trans-unit id="7ec22936b55b7f305c2be8dba10aa5109567b287" translate="yes" xml:space="preserve">
          <source>Manual: Pragmas</source>
          <target state="translated">매뉴얼 : Pragmas</target>
        </trans-unit>
        <trans-unit id="770e4cc3468cd2ab34e2292349c2fc7f1254bba1" translate="yes" xml:space="preserve">
          <source>Manual: Procedures</source>
          <target state="translated">수동 : 절차</target>
        </trans-unit>
        <trans-unit id="1b494587e353e28a4fb14cede5251f048106d63a" translate="yes" xml:space="preserve">
          <source>Manual: Special Operators</source>
          <target state="translated">매뉴얼 : 특수 연산자</target>
        </trans-unit>
        <trans-unit id="67456811ead6b001268c25ae75d8eb80bf9b78d4" translate="yes" xml:space="preserve">
          <source>Manual: Special Types</source>
          <target state="translated">수동 : 특수 유형</target>
        </trans-unit>
        <trans-unit id="6decf7713585353b542d22a07833a9e3f4608374" translate="yes" xml:space="preserve">
          <source>Manual: Statements and expressions</source>
          <target state="translated">매뉴얼 : 진술과 표현</target>
        </trans-unit>
        <trans-unit id="c06b311819398e9a7a08be8caed1736017ac7522" translate="yes" xml:space="preserve">
          <source>Manual: Syntax</source>
          <target state="translated">수동 : 구문</target>
        </trans-unit>
        <trans-unit id="bacd5ce7b4fc6c233337b20743738357eb3d4917" translate="yes" xml:space="preserve">
          <source>Manual: Templates</source>
          <target state="translated">매뉴얼 : 템플릿</target>
        </trans-unit>
        <trans-unit id="817f3b64b7fab30fc4fa2987f47b2de7d799191c" translate="yes" xml:space="preserve">
          <source>Manual: Term rewriting macros</source>
          <target state="translated">수동 : 용어 재 작성 매크로</target>
        </trans-unit>
        <trans-unit id="cbe3bd9f8e9a36414594a7b27bafcc1a597a3da5" translate="yes" xml:space="preserve">
          <source>Manual: Threads</source>
          <target state="translated">수동 : 실</target>
        </trans-unit>
        <trans-unit id="aafb451a891596fbad0f0184b0ad302e74ebffc7" translate="yes" xml:space="preserve">
          <source>Manual: Type bound operations</source>
          <target state="translated">수동 : 유형 바운드 작업</target>
        </trans-unit>
        <trans-unit id="166a47f26935d8e4d08a27d4c17c4e1d1999f722" translate="yes" xml:space="preserve">
          <source>Manual: Type relations</source>
          <target state="translated">수동 : 유형 관계</target>
        </trans-unit>
        <trans-unit id="bd029877fffa549daa894766df47948479afd2f1" translate="yes" xml:space="preserve">
          <source>Manual: Types</source>
          <target state="translated">수동 : 유형</target>
        </trans-unit>
        <trans-unit id="2a1633f65bbc398d71c3ebfc3241c0af807273d5" translate="yes" xml:space="preserve">
          <source>Mark the test as skipped. Should be used directly in case when it is not possible to perform test for reasons depending on outer environment, or certain application logic conditions or configurations. The test code is still executed.</source>
          <target state="translated">테스트를 건너 뛴 것으로 표시하십시오. 외부 환경 또는 특정 애플리케이션 로직 조건 또는 구성에 따라 이유로 테스트를 수행 할 수없는 경우 직접 사용해야합니다. 테스트 코드는 여전히 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1d3b7aa9b4c642f5735f40da06dfed06fbca163e" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;socket&lt;/code&gt; as accepting connections. &lt;code&gt;Backlog&lt;/code&gt; specifies the maximum length of the queue of pending connections.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 을 허용되는 연결로 표시 합니다 . &lt;code&gt;Backlog&lt;/code&gt; 그는 보류중인 연결 큐의 최대 길이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f07f226b4437e06fea4e70beb870cd20dccb2b33" translate="yes" xml:space="preserve">
          <source>Matches a binary integer. This uses &lt;code&gt;parseutils.parseBin&lt;/code&gt;.</source>
          <target state="translated">이진 정수와 일치합니다. &lt;code&gt;parseutils.parseBin&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="61f72fda5d63c33af385805c251186ac41827a95" translate="yes" xml:space="preserve">
          <source>Matches a character set</source>
          <target state="translated">문자 세트와 일치</target>
        </trans-unit>
        <trans-unit id="7c21df5bb89686108056b549eda7fc196d394426" translate="yes" xml:space="preserve">
          <source>Matches a decimal integer. This uses &lt;code&gt;parseutils.parseInt&lt;/code&gt;.</source>
          <target state="translated">십진 정수와 일치합니다. &lt;code&gt;parseutils.parseInt&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a12cb4b049a1da7e03f068b60b69ca0670549bfd" translate="yes" xml:space="preserve">
          <source>Matches a floating pointer number. Uses &lt;code&gt;parseFloat&lt;/code&gt;.</source>
          <target state="translated">부동 포인터 번호와 일치합니다. &lt;code&gt;parseFloat&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2464cd36660069f3fcf2e58ee0a418607e32a9bc" translate="yes" xml:space="preserve">
          <source>Matches a hex integer. This uses &lt;code&gt;parseutils.parseHex&lt;/code&gt;.</source>
          <target state="translated">16 진 정수와 일치합니다. &lt;code&gt;parseutils.parseHex&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="532fa54ee42246846545dbf2fc331f03ad0daeed" translate="yes" xml:space="preserve">
          <source>Matches a single character</source>
          <target state="translated">단일 문자와 일치</target>
        </trans-unit>
        <trans-unit id="e01edc99d3df652b0b10d0cd88889a4c6db28db5" translate="yes" xml:space="preserve">
          <source>Matches a single dollar sign.</source>
          <target state="translated">단일 달러 기호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="56b8550638d15898163432e2ef863037d24cf3ab" translate="yes" xml:space="preserve">
          <source>Matches a string</source>
          <target state="translated">문자열과 일치</target>
        </trans-unit>
        <trans-unit id="2b0f27dc90ddd03570b6691c4598abffade1d014" translate="yes" xml:space="preserve">
          <source>Matches an ASCII identifier: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt;.</source>
          <target state="translated">ASCII 식별자 &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4f19ab90d0dfde58576111f53aea6162591341ee" translate="yes" xml:space="preserve">
          <source>Matches an octal integer. This uses &lt;code&gt;parseutils.parseOct&lt;/code&gt;.</source>
          <target state="translated">8 진 정수와 일치합니다. &lt;code&gt;parseutils.parseOct&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8507509e46ea139d748c7c784f7cdc32a09d48f7" translate="yes" xml:space="preserve">
          <source>Matches if the end of the input string has been reached.</source>
          <target state="translated">입력 문자열의 끝에 도달하면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="44e83eb14a6d865158691b6ead9b69eedf905cb4" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$*&lt;/code&gt; was found. The match is allowed to be of 0 length.</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; 다음에 나오는 토큰 을 찾을 때까지 일치합니다 . 일치 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="548a91d3213ffddd1a11e82050c55439466aaf2f" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$+&lt;/code&gt; was found. The match must consist of at least one char.</source>
          <target state="translated">&lt;code&gt;$+&lt;/code&gt; 다음의 토큰 이 발견 될 때까지 일치합니다 . 일치하는 문자는 하나 이상의 문자로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac458e6963c6ebdd9c5ca1f8b279a9eb42dfc913" translate="yes" xml:space="preserve">
          <source>Math libraries</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="6e4c4838bcc55297c563147e236843926c319da6" translate="yes" xml:space="preserve">
          <source>Max line length is 80 characters.</source>
          <target state="translated">최대 줄 길이는 80 자입니다.</target>
        </trans-unit>
        <trans-unit id="353de93dd15ff6db8a4b838f009f42da8fc085cc" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">32 비트 부동 소수점 숫자의 최대 (양수) 지수.</target>
        </trans-unit>
        <trans-unit id="1d2ac0d1ca31ee91cf5ff6056f9a16027dd8fd2a" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">64 비트 부동 소수점 숫자의 최대 (양수) 지수.</target>
        </trans-unit>
        <trans-unit id="8bbd4cef55a64a4e58be3f1e60ec750e94d7d807" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">32 비트 부동 소수점 숫자에 대한 기수 10의 최대 (양수) 지수.</target>
        </trans-unit>
        <trans-unit id="50184f5eb64ad277177d238e645f028ed1a230ab" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">64 비트 부동 소수점 숫자에 대한 기수 10의 최대 (양수) 지수.</target>
        </trans-unit>
        <trans-unit id="ed71d9f1d146dd9fd80c9fea6cf2280768a6a052" translate="yes" xml:space="preserve">
          <source>Maybe you didn't notice, but in the &lt;code&gt;dumpTree&lt;/code&gt; example the first constant explicitly specifies the type of the constant. That's why in the tree output the two last constants have their second child &lt;code&gt;Empty&lt;/code&gt; but the first has a string identifier. So basically a &lt;code&gt;const&lt;/code&gt; definition is made up from an identifier, optionally a type (can be an &lt;em&gt;empty&lt;/em&gt; node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</source>
          <target state="translated">아마 눈치 채지 &lt;code&gt;dumpTree&lt;/code&gt; 예제에서 첫 번째 상수는 상수 유형을 명시 적으로 지정합니다. 이것이 트리 출력에서 ​​두 개의 마지막 상수에 두 번째 자식 &lt;code&gt;Empty&lt;/code&gt; 가 있지만 첫 번째 상수에는 문자열 식별자가있는 이유입니다 . 따라서 기본적으로 &lt;code&gt;const&lt;/code&gt; 정의는 식별자, 선택적으로 유형 ( &lt;em&gt;빈&lt;/em&gt; 노드 일 수 있음 ) 및 값으로 구성됩니다. 이 지식으로 무장 한 AST 빌딩 매크로의 완성 된 버전을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="9baa9878dfbef1d35fc905168a10b0c4a8c0fbd9" translate="yes" xml:space="preserve">
          <source>Memory safety for returning by &lt;code&gt;var T&lt;/code&gt; is ensured by a simple borrowing rule: If &lt;code&gt;result&lt;/code&gt; does not refer to a location pointing to the heap (that is in &lt;code&gt;result = X&lt;/code&gt; the &lt;code&gt;X&lt;/code&gt; involves a &lt;code&gt;ptr&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; access) then it has to be deviated by the routine's first parameter:</source>
          <target state="translated">&lt;code&gt;var T&lt;/code&gt; 에 의한 반환에 대한 메모리 안전성 은 간단한 빌리기 규칙에 의해 보장됩니다. &lt;code&gt;result&lt;/code&gt; 가 힙을 가리키는 위치를 참조하지 않는 경우 ( &lt;code&gt;result = X&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 에 &lt;code&gt;ptr&lt;/code&gt; 또는 &lt;code&gt;ref&lt;/code&gt; 액세스가 포함됨) 루틴의 첫 번째 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="50ff34431595cf400d81245be2a86a83f82386dd" translate="yes" xml:space="preserve">
          <source>Merges all index files in &lt;em&gt;dir&lt;/em&gt; and returns the generated index as HTML.</source>
          <target state="translated">&lt;em&gt;dir의&lt;/em&gt; 모든 색인 파일을 병합 하고 생성 된 색인을 HTML로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c08446305ac72d52aeff6051e72faf9d7787f9fc" translate="yes" xml:space="preserve">
          <source>Merges all separated TextNodes together, and removes any empty TextNodes</source>
          <target state="translated">분리 된 모든 TextNode를 병합하고 비어있는 TextNode를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="33ef168ac38cdf5d66a3f96ccc53c0bcb2bec97c" translate="yes" xml:space="preserve">
          <source>Messages that are generated during the normal operation of an application and are of no particular importance. Useful to aggregate for potential later analysis.</source>
          <target state="translated">응용 프로그램이 정상적으로 작동하는 동안 생성되며 특별히 중요하지 않은 메시지. 나중에 분석 할 수 있도록 집계하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="949ba2d44e279ebf601f54248d567bd067f76669" translate="yes" xml:space="preserve">
          <source>Messages that are useful to the application developer only and are usually turned off in release.</source>
          <target state="translated">응용 프로그램 개발자에게만 유용하며 일반적으로 릴리스에서 해제 된 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="de329f9988dc07ac218d31798f3d3fb0e319aeeb" translate="yes" xml:space="preserve">
          <source>Method call syntax</source>
          <target state="translated">메소드 호출 구문</target>
        </trans-unit>
        <trans-unit id="b768cedc4687283126d9b1ed420f777b12a98828" translate="yes" xml:space="preserve">
          <source>Method dispatchers are global.</source>
          <target state="translated">메소드 디스패처는 글로벌입니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="3c397a7933a859382d85ab67743d94fecb8793cf" translate="yes" xml:space="preserve">
          <source>Methods and type converters</source>
          <target state="translated">방법 및 유형 변환기</target>
        </trans-unit>
        <trans-unit id="70972ae112e939ad343653a1ba078194eea37b73" translate="yes" xml:space="preserve">
          <source>Methods imply &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt; and idetools performs a static analysis on the code. For this reason idetools may not return the definition of the correct method you are querying because it may be impossible to know until the code is executed. It will try to return the method which covers the most possible cases (i.e. for variations of different classes in a hierarchy it will prefer methods using the base class).</source>
          <target state="translated">메소드는 &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;동적 디스패치를&lt;/a&gt; 의미 하며 idetools는 코드에서 정적 분석을 수행합니다. 이러한 이유로 idetools는 코드가 실행될 때까지 알기가 불가능하기 때문에 쿼리하는 올바른 메소드의 정의를 리턴하지 않을 수 있습니다. 가장 가능한 경우를 다루는 메소드를 리턴하려고 시도합니다 (즉, 계층 구조에서 다른 클래스의 변형에 대해서는 기본 클래스를 사용하는 메소드를 선호 함).</target>
        </trans-unit>
        <trans-unit id="53abbdb21e81e3f2df2cf14c89d5b6dbabdbe501" translate="yes" xml:space="preserve">
          <source>Microseconds display</source>
          <target state="translated">마이크로 초 표시</target>
        </trans-unit>
        <trans-unit id="71a3c685e2a1c832e7011ccdc9b0d684ec6c5b11" translate="yes" xml:space="preserve">
          <source>Milliseconds display</source>
          <target state="translated">밀리 초 표시</target>
        </trans-unit>
        <trans-unit id="f0ba6bd90de6cbdc1ad731d5daa371ecb83efe18" translate="yes" xml:space="preserve">
          <source>Minimal output level for the compiler.</source>
          <target state="translated">컴파일러의 최소 출력 레벨.</target>
        </trans-unit>
        <trans-unit id="011feb85fd840211ebe3cbea6d10c757384f0950" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">32 비트 부동 소수점 숫자에 대한 최소 (음수) 지수.</target>
        </trans-unit>
        <trans-unit id="a6a8707c6b54291fbf3e81a23b30ec1365b0f17e" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">64 비트 부동 소수점 숫자의 최소 (음수) 지수입니다.</target>
        </trans-unit>
        <trans-unit id="c80cc0223dc92abbd631516781aea6a70a2336ee" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">32 비트 부동 소수점 숫자에 대한 기수 10의 최소 (음수) 지수입니다.</target>
        </trans-unit>
        <trans-unit id="8c0da4d03317d4bba985f6d156cd17b8a1e9fe83" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">64 비트 부동 소수점 숫자에 대한 기수 10의 최소 (음수) 지수입니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="fde8fd6d013071c5b0da03141012d8c86a59338b" translate="yes" xml:space="preserve">
          <source>Mixin statement</source>
          <target state="translated">믹스 인 진술</target>
        </trans-unit>
        <trans-unit id="54a58f4d81597ea468c275c465f53b922146c355" translate="yes" xml:space="preserve">
          <source>Mixing parameters that should use the &lt;code&gt;using&lt;/code&gt; declaration with parameters that are explicitly typed is possible and requires a semicolon between them.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 선언을 사용해야하는 매개 변수와 명시 적으로 입력 된 매개 변수를 혼합하는 것이 가능하며 그 사이에 세미콜론이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e4544d11fd6da006e85425de7ccf9cc035a9102d" translate="yes" xml:space="preserve">
          <source>Modelling currencies</source>
          <target state="translated">통화 모델링</target>
        </trans-unit>
        <trans-unit id="aa74d48711737b61f9e3b5b05bb11e9299107ca2" translate="yes" xml:space="preserve">
          <source>Modifies the prefix of this node</source>
          <target state="translated">이 노드의 접두사를 수정합니다</target>
        </trans-unit>
        <trans-unit id="08534cfcbbc9538479a2881f8f4160931eb1a4e4" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by adding &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 추가하여 제자리에서 수정 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d316a8d9b4204cded1b078dfca344f13947d6088" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by subtracting &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 를 빼서 a를 수정 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf753b23cff3eb87675698eadfe1b3df8dc21c1" translate="yes" xml:space="preserve">
          <source>Modifying a configuration file.</source>
          <target state="translated">구성 파일 수정</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="37f0da15f20ceb74b60fd308e1dca9126540cb05" translate="yes" xml:space="preserve">
          <source>Module algorithm</source>
          <target state="translated">모듈 알고리즘</target>
        </trans-unit>
        <trans-unit id="98195ccd152814f0ec7cb526f9dfddd0c0f2d040" translate="yes" xml:space="preserve">
          <source>Module asyncdispatch</source>
          <target state="translated">모듈 비동기 디스패치</target>
        </trans-unit>
        <trans-unit id="4bc2eee542f289752eea25797a5b576fdb1f0212" translate="yes" xml:space="preserve">
          <source>Module asyncfile</source>
          <target state="translated">모듈 비동기 파일</target>
        </trans-unit>
        <trans-unit id="1982b034043183e25a12a7f8201ac7aedfe1337c" translate="yes" xml:space="preserve">
          <source>Module asyncftpclient</source>
          <target state="translated">모듈 asyncftpclient</target>
        </trans-unit>
        <trans-unit id="c8ecdd97327b90a5e22c271e6446280bc42a28c4" translate="yes" xml:space="preserve">
          <source>Module asyncfutures</source>
          <target state="translated">모듈 비동기</target>
        </trans-unit>
        <trans-unit id="36cb7286c251d44bed6e333ac6ff256e07f23e46" translate="yes" xml:space="preserve">
          <source>Module asynchttpserver</source>
          <target state="translated">모듈 비동기 httpserver</target>
        </trans-unit>
        <trans-unit id="a17c24b3dfb9bd981141eb4c7df0cf7bc771a15a" translate="yes" xml:space="preserve">
          <source>Module asyncio</source>
          <target state="translated">모듈 비동기</target>
        </trans-unit>
        <trans-unit id="c68f5ddf8354a55f6684c3fbe9c3bf177423a499" translate="yes" xml:space="preserve">
          <source>Module asyncjs</source>
          <target state="translated">모듈 비동기</target>
        </trans-unit>
        <trans-unit id="101489cc366780f3080d0d181d612c9897002730" translate="yes" xml:space="preserve">
          <source>Module asyncnet</source>
          <target state="translated">모듈 비동기</target>
        </trans-unit>
        <trans-unit id="6fed8121401f7f3d76d9ac08c713d6fc1d80130c" translate="yes" xml:space="preserve">
          <source>Module asyncstreams</source>
          <target state="translated">모듈 비동기 스트림</target>
        </trans-unit>
        <trans-unit id="7760e4149a4aa9f2f5276da9842c763efe627d2d" translate="yes" xml:space="preserve">
          <source>Module base64</source>
          <target state="translated">모듈 base64</target>
        </trans-unit>
        <trans-unit id="90d38995e07bc5f4bab2517945813fb23c0f041c" translate="yes" xml:space="preserve">
          <source>Module bitops</source>
          <target state="translated">모듈 비트</target>
        </trans-unit>
        <trans-unit id="50eadb9d8cc85daa18b406eb03722df6d8ad89ae" translate="yes" xml:space="preserve">
          <source>Module browsers</source>
          <target state="translated">모듈 브라우저</target>
        </trans-unit>
        <trans-unit id="541c25a9eda5bd8f8b769d4123a86bdd4573b52d" translate="yes" xml:space="preserve">
          <source>Module cgi</source>
          <target state="translated">모듈 CGI</target>
        </trans-unit>
        <trans-unit id="582466c566af045f4b9e5cd6e35678516157979c" translate="yes" xml:space="preserve">
          <source>Module channels</source>
          <target state="translated">모듈 채널</target>
        </trans-unit>
        <trans-unit id="9b8b21dabbac15d101b015114dad88029c7c9e26" translate="yes" xml:space="preserve">
          <source>Module colors</source>
          <target state="translated">모듈 색상</target>
        </trans-unit>
        <trans-unit id="eed8ec6f020ff8aa124c5b37641c245a63ddde69" translate="yes" xml:space="preserve">
          <source>Module complex</source>
          <target state="translated">모듈 콤플렉스</target>
        </trans-unit>
        <trans-unit id="374208eb48a6ab162ea9a9795c69a75d26d8d0d8" translate="yes" xml:space="preserve">
          <source>Module cookies</source>
          <target state="translated">모듈 쿠키</target>
        </trans-unit>
        <trans-unit id="a4721d23b264afe3adb6840e441ad673c273dbe5" translate="yes" xml:space="preserve">
          <source>Module coro</source>
          <target state="translated">모듈 코로</target>
        </trans-unit>
        <trans-unit id="0b7487264409b62ec77bc44946eb6949835043bd" translate="yes" xml:space="preserve">
          <source>Module cpuinfo</source>
          <target state="translated">cpuinfo 모듈</target>
        </trans-unit>
        <trans-unit id="65a4bb57d62e6d50e39758f49fa5d45582a06fcf" translate="yes" xml:space="preserve">
          <source>Module cpuload</source>
          <target state="translated">모듈 CPU로드</target>
        </trans-unit>
        <trans-unit id="0eaf026ca68438c31c5ddb66759abefe57ca491a" translate="yes" xml:space="preserve">
          <source>Module critbits</source>
          <target state="translated">모듈 critbits</target>
        </trans-unit>
        <trans-unit id="17fb6170e7c4b5192d13d3ef92b62003adec52ed" translate="yes" xml:space="preserve">
          <source>Module cstrutils</source>
          <target state="translated">모듈 cstrutils</target>
        </trans-unit>
        <trans-unit id="dccbda4248191deb5d482692eac7fa4e615cc212" translate="yes" xml:space="preserve">
          <source>Module db_common</source>
          <target state="translated">모듈 db_common</target>
        </trans-unit>
        <trans-unit id="8d09576b4e94ea8a8b0016794ba4536d4b1759df" translate="yes" xml:space="preserve">
          <source>Module db_mysql</source>
          <target state="translated">모듈 db_mysql</target>
        </trans-unit>
        <trans-unit id="6624ca243c80fc450c0491ae2bd086e7f22e2273" translate="yes" xml:space="preserve">
          <source>Module db_odbc</source>
          <target state="translated">모듈 db_odbc</target>
        </trans-unit>
        <trans-unit id="fd6fae1e074c3591c208c14db853d9f0744b3fe6" translate="yes" xml:space="preserve">
          <source>Module db_postgres</source>
          <target state="translated">모듈 db_postgres</target>
        </trans-unit>
        <trans-unit id="b401aafda6e7b26047ce7d9b236e3e28ead3b900" translate="yes" xml:space="preserve">
          <source>Module db_sqlite</source>
          <target state="translated">모듈 db_sqlite</target>
        </trans-unit>
        <trans-unit id="a36cab96e59f81b2cfa2e287c992565577181e19" translate="yes" xml:space="preserve">
          <source>Module deques</source>
          <target state="translated">모듈 deques</target>
        </trans-unit>
        <trans-unit id="230fe8691288c49b13cd6d0d633b0aa094bba0ba" translate="yes" xml:space="preserve">
          <source>Module distros</source>
          <target state="translated">모듈 배포</target>
        </trans-unit>
        <trans-unit id="b98b5015c00736657c4dd0da231c080c137bf240" translate="yes" xml:space="preserve">
          <source>Module docgen_sample</source>
          <target state="translated">모듈 docgen_sample</target>
        </trans-unit>
        <trans-unit id="9b3df8bd64b5aae95560173051cb9413193a2ac6" translate="yes" xml:space="preserve">
          <source>Module dom</source>
          <target state="translated">모듈 돔</target>
        </trans-unit>
        <trans-unit id="941b4acd398cb84658e8c03ee70acb8a6a6ad12b" translate="yes" xml:space="preserve">
          <source>Module dynlib</source>
          <target state="translated">모듈 dynlib</target>
        </trans-unit>
        <trans-unit id="0b682ac70a1c85d9baf3957f2aa8f759d24240e0" translate="yes" xml:space="preserve">
          <source>Module encodings</source>
          <target state="translated">모듈 인코딩</target>
        </trans-unit>
        <trans-unit id="db5b0c91c31ae7c7d91818dc9b614356c8ac354a" translate="yes" xml:space="preserve">
          <source>Module endians</source>
          <target state="translated">모듈 엔디 언</target>
        </trans-unit>
        <trans-unit id="bd74d2f3f124ee315af73875094015c9b005becf" translate="yes" xml:space="preserve">
          <source>Module fenv</source>
          <target state="translated">모듈 fenv</target>
        </trans-unit>
        <trans-unit id="731086b25ca52f0d4ba784e9023a512802282c5d" translate="yes" xml:space="preserve">
          <source>Module for computing MD5 checksums.</source>
          <target state="translated">MD5 체크섬을 계산하기위한 모듈.</target>
        </trans-unit>
        <trans-unit id="b4be1b80500b5ac048dcc726ed598ece6701931b" translate="yes" xml:space="preserve">
          <source>Module ftpclient</source>
          <target state="translated">모듈 ftpclient</target>
        </trans-unit>
        <trans-unit id="3c4f086976fa89f11b3a0b18d36e2a8854016a20" translate="yes" xml:space="preserve">
          <source>Module hashes</source>
          <target state="translated">모듈 해시</target>
        </trans-unit>
        <trans-unit id="a2e15c184ec6f1cb32588bee5d5ccb0d11dcc6e5" translate="yes" xml:space="preserve">
          <source>Module heapqueue</source>
          <target state="translated">모듈 힙큐</target>
        </trans-unit>
        <trans-unit id="83b2786d0af670a8727d352ab2cc17a4801a8fde" translate="yes" xml:space="preserve">
          <source>Module highlite</source>
          <target state="translated">모듈 하이라이트</target>
        </trans-unit>
        <trans-unit id="68378bdbde20dbf762ba106c90a960cc76a0c343" translate="yes" xml:space="preserve">
          <source>Module htmlgen</source>
          <target state="translated">모듈 htmlgen</target>
        </trans-unit>
        <trans-unit id="11585b007040719709343df6d82764795667bb4d" translate="yes" xml:space="preserve">
          <source>Module htmlparser</source>
          <target state="translated">모듈 htmlparser</target>
        </trans-unit>
        <trans-unit id="ce266765149cfec68daffab151c2d1cbb6ebb974" translate="yes" xml:space="preserve">
          <source>Module httpclient</source>
          <target state="translated">모듈 httpclient</target>
        </trans-unit>
        <trans-unit id="ae17027dff9b5c5e08184e61c512b15de51aca77" translate="yes" xml:space="preserve">
          <source>Module httpcore</source>
          <target state="translated">모듈 httpcore</target>
        </trans-unit>
        <trans-unit id="efcdd786f2c6fa38c8e234f0d6d253c5564d8710" translate="yes" xml:space="preserve">
          <source>Module intsets</source>
          <target state="translated">모듈 intsets</target>
        </trans-unit>
        <trans-unit id="ae1f8df6d1f31431338fdcd3f32d3d351bdb0f67" translate="yes" xml:space="preserve">
          <source>Module iup</source>
          <target state="translated">모듈 iup</target>
        </trans-unit>
        <trans-unit id="8abdec2103ddf3b91238dc0ef753306e3cf948a1" translate="yes" xml:space="preserve">
          <source>Module jscore</source>
          <target state="translated">모듈 jscore</target>
        </trans-unit>
        <trans-unit id="2445c7a3a0648ca25b67b51a400e8dde36b920dc" translate="yes" xml:space="preserve">
          <source>Module jsffi</source>
          <target state="translated">모듈 jsffi</target>
        </trans-unit>
        <trans-unit id="3e231af76878f00ab682498609250b7a33902b37" translate="yes" xml:space="preserve">
          <source>Module json</source>
          <target state="translated">모듈 JSON</target>
        </trans-unit>
        <trans-unit id="37345fc873fd9ef2206568b360b1c24cb44c6a79" translate="yes" xml:space="preserve">
          <source>Module lenientops</source>
          <target state="translated">모듈 lenientops</target>
        </trans-unit>
        <trans-unit id="580e2f376943e7c873eabc0e8de78d45329a29d4" translate="yes" xml:space="preserve">
          <source>Module lexbase</source>
          <target state="translated">모듈 lexbase</target>
        </trans-unit>
        <trans-unit id="f7eb0bf35deb63519acf61a5dc69c51f5b06735f" translate="yes" xml:space="preserve">
          <source>Module lists</source>
          <target state="translated">모듈 목록</target>
        </trans-unit>
        <trans-unit id="5fa64d315f22284a510ec90f2b3766f8771aa4d3" translate="yes" xml:space="preserve">
          <source>Module locks</source>
          <target state="translated">모듈 잠금</target>
        </trans-unit>
        <trans-unit id="d68a3f14f1246e34391c7c956005b435126a1feb" translate="yes" xml:space="preserve">
          <source>Module logging</source>
          <target state="translated">모듈 로깅</target>
        </trans-unit>
        <trans-unit id="70e578149237a5fb397ecdf712216171be19d22c" translate="yes" xml:space="preserve">
          <source>Module macros</source>
          <target state="translated">모듈 매크로</target>
        </trans-unit>
        <trans-unit id="8e11adceffbd4622428572ca4afc35c17c825d9b" translate="yes" xml:space="preserve">
          <source>Module marshal</source>
          <target state="translated">모듈 마샬</target>
        </trans-unit>
        <trans-unit id="33c70e8cca5fc846249c996c55efdccf09fa04af" translate="yes" xml:space="preserve">
          <source>Module matchers</source>
          <target state="translated">모듈 매처</target>
        </trans-unit>
        <trans-unit id="60528f0928b59cfa4557a3b1b994edb4024106b0" translate="yes" xml:space="preserve">
          <source>Module math</source>
          <target state="translated">모듈 수학</target>
        </trans-unit>
        <trans-unit id="56d8fbdebc1eb23f12cddf043b4f3037a450710a" translate="yes" xml:space="preserve">
          <source>Module md5</source>
          <target state="translated">모듈 md5</target>
        </trans-unit>
        <trans-unit id="bce77eb47d51483993e4fa0db56b0547cc3dd24c" translate="yes" xml:space="preserve">
          <source>Module memfiles</source>
          <target state="translated">모듈 memfile</target>
        </trans-unit>
        <trans-unit id="20df3a115fcb30f9b530aa03bdc18faa0ae695c2" translate="yes" xml:space="preserve">
          <source>Module mersenne</source>
          <target state="translated">모듈 메르 센</target>
        </trans-unit>
        <trans-unit id="cc1b82bbab0603a47f41c5adca38b87a9321bee7" translate="yes" xml:space="preserve">
          <source>Module mimetypes</source>
          <target state="translated">모듈 mimetypes</target>
        </trans-unit>
        <trans-unit id="6657cfabe7d07bf51cc2fb118ba722ffc96aba89" translate="yes" xml:space="preserve">
          <source>Module mysql</source>
          <target state="translated">모듈 mysql</target>
        </trans-unit>
        <trans-unit id="31d0c7d344fc5c65774ddf00049b1876645f3b19" translate="yes" xml:space="preserve">
          <source>Module names in imports</source>
          <target state="translated">수입품의 모듈 이름</target>
        </trans-unit>
        <trans-unit id="30df598104815cce6ad06791aec2a9d153b164f7" translate="yes" xml:space="preserve">
          <source>Module nativesockets</source>
          <target state="translated">모듈 네이티브 소켓</target>
        </trans-unit>
        <trans-unit id="a3d7a3865b172afee6c2b7c8977de511e77b6757" translate="yes" xml:space="preserve">
          <source>Module net</source>
          <target state="translated">모듈 네트</target>
        </trans-unit>
        <trans-unit id="6c357de2b2a9a1de2189540c4281941a77608057" translate="yes" xml:space="preserve">
          <source>Module odbcsql</source>
          <target state="translated">모듈 odbcsql</target>
        </trans-unit>
        <trans-unit id="9ac9afd12fcca720ece0b72dd61269f6e7843617" translate="yes" xml:space="preserve">
          <source>Module oids</source>
          <target state="translated">모듈 oids</target>
        </trans-unit>
        <trans-unit id="df6c016676012b7a90d7af54c2025872180c6083" translate="yes" xml:space="preserve">
          <source>Module openssl</source>
          <target state="translated">모듈 openssl</target>
        </trans-unit>
        <trans-unit id="181f431ffc709c06a61935e69331ac8e4563f46c" translate="yes" xml:space="preserve">
          <source>Module options</source>
          <target state="translated">모듈 옵션</target>
        </trans-unit>
        <trans-unit id="7f661395966d22306bb86d25ec0d945d397507a0" translate="yes" xml:space="preserve">
          <source>Module os</source>
          <target state="translated">모듈 OS</target>
        </trans-unit>
        <trans-unit id="dae29e69d6fcac477476832d0c04d256e4219700" translate="yes" xml:space="preserve">
          <source>Module ospaths</source>
          <target state="translated">모듈 경로</target>
        </trans-unit>
        <trans-unit id="5395928ecc4ce4edf1eabd8f020d30b8523fd803" translate="yes" xml:space="preserve">
          <source>Module osproc</source>
          <target state="translated">모듈 osproc</target>
        </trans-unit>
        <trans-unit id="2bfeeb302a2c2fb80d26255c95b4f0b069b97c41" translate="yes" xml:space="preserve">
          <source>Module parsecfg</source>
          <target state="translated">모듈 구문 분석</target>
        </trans-unit>
        <trans-unit id="d9ee6d4bae252aefed2ecd2ae012f67dfe339140" translate="yes" xml:space="preserve">
          <source>Module parsecsv</source>
          <target state="translated">모듈 파섹</target>
        </trans-unit>
        <trans-unit id="348399e23d1c192b9c45e1b0c83d05337c92bf98" translate="yes" xml:space="preserve">
          <source>Module parsejson</source>
          <target state="translated">모듈 파서 손</target>
        </trans-unit>
        <trans-unit id="682e643a35975c3826db50e0bb0cd0dd5c2ca34f" translate="yes" xml:space="preserve">
          <source>Module parseopt</source>
          <target state="translated">모듈 분석</target>
        </trans-unit>
        <trans-unit id="0ed92eaefc270e8b9dd075eb2dd08dbaa5b51f01" translate="yes" xml:space="preserve">
          <source>Module parsesql</source>
          <target state="translated">모듈 구문 분석</target>
        </trans-unit>
        <trans-unit id="855c130387d410a61e37f5b34d034cd98d89f8d8" translate="yes" xml:space="preserve">
          <source>Module parseutils</source>
          <target state="translated">모듈 구문 분석</target>
        </trans-unit>
        <trans-unit id="9371c7c885849232742553f842dca9202b5ed289" translate="yes" xml:space="preserve">
          <source>Module parsexml</source>
          <target state="translated">모듈 구문 분석</target>
        </trans-unit>
        <trans-unit id="20024d265db3ebf3a4cb1f9d150f212626383df7" translate="yes" xml:space="preserve">
          <source>Module pcre</source>
          <target state="translated">모듈 pcre</target>
        </trans-unit>
        <trans-unit id="a17a4c9cec16cef361a14841e228e5ed78a25395" translate="yes" xml:space="preserve">
          <source>Module pegs</source>
          <target state="translated">모듈 못</target>
        </trans-unit>
        <trans-unit id="5f3bf0ccd39bc7809674b2d661113030c738201e" translate="yes" xml:space="preserve">
          <source>Module posix</source>
          <target state="translated">모듈 posix</target>
        </trans-unit>
        <trans-unit id="eef6ef7935050ba1da22c08049e0e742ab0545c6" translate="yes" xml:space="preserve">
          <source>Module postgres</source>
          <target state="translated">모듈 postgres</target>
        </trans-unit>
        <trans-unit id="4c337d9754fa6144e8e8c63eb6714830a7bf2680" translate="yes" xml:space="preserve">
          <source>Module random</source>
          <target state="translated">임의 모듈</target>
        </trans-unit>
        <trans-unit id="6f3863bd09c8389a708515de060c50fe217a1fc5" translate="yes" xml:space="preserve">
          <source>Module rationals</source>
          <target state="translated">모듈 합리성</target>
        </trans-unit>
        <trans-unit id="1c6043ad9977193e14836b1453a2c14e877b9c12" translate="yes" xml:space="preserve">
          <source>Module re</source>
          <target state="translated">모듈 다시</target>
        </trans-unit>
        <trans-unit id="beb8a46432b339ddaa74839d412412426afb7728" translate="yes" xml:space="preserve">
          <source>Module rlocks</source>
          <target state="translated">모듈 록</target>
        </trans-unit>
        <trans-unit id="373d2a7e384e4c78df72f2a532ade493280ab5b9" translate="yes" xml:space="preserve">
          <source>Module ropes</source>
          <target state="translated">모듈 로프</target>
        </trans-unit>
        <trans-unit id="791fafc4980538594d1205be2e024d8f062a8ef6" translate="yes" xml:space="preserve">
          <source>Module rst</source>
          <target state="translated">모듈 첫</target>
        </trans-unit>
        <trans-unit id="e62ac437c8e15e65ba3f4a9ec5166f39349d24d8" translate="yes" xml:space="preserve">
          <source>Module rstast</source>
          <target state="translated">모듈 rstast</target>
        </trans-unit>
        <trans-unit id="71d839f9565a57347512e1bcb1209ad6ecbd1571" translate="yes" xml:space="preserve">
          <source>Module rstgen</source>
          <target state="translated">모듈 rstgen</target>
        </trans-unit>
        <trans-unit id="64202e11eebaa8fdc9db2592feeeca4f21b321b4" translate="yes" xml:space="preserve">
          <source>Module rtarrays</source>
          <target state="translated">모듈 rtarrays</target>
        </trans-unit>
        <trans-unit id="34de3c41db61af2ec348412e142cf1de55f30e2c" translate="yes" xml:space="preserve">
          <source>Module scgi</source>
          <target state="translated">모듈 scgi</target>
        </trans-unit>
        <trans-unit id="9d18a075abac676c24c84bba7822fb5ce2702cec" translate="yes" xml:space="preserve">
          <source>Module scope</source>
          <target state="translated">모듈 범위</target>
        </trans-unit>
        <trans-unit id="b6a250923bc9b9d586fc748c435010dc3db2a298" translate="yes" xml:space="preserve">
          <source>Module segfaults</source>
          <target state="translated">모듈 segfaults</target>
        </trans-unit>
        <trans-unit id="8208cbe439f9b79060081af450aa66cdb0a714b6" translate="yes" xml:space="preserve">
          <source>Module selectors</source>
          <target state="translated">모듈 선택기</target>
        </trans-unit>
        <trans-unit id="23026b5c559a2292c7babd2476fc9f08c5816964" translate="yes" xml:space="preserve">
          <source>Module sequtils</source>
          <target state="translated">모듈 sequtils</target>
        </trans-unit>
        <trans-unit id="c3ea468cd06b16c0644d2bacc8da61f318bab4bb" translate="yes" xml:space="preserve">
          <source>Module sets</source>
          <target state="translated">모듈 세트</target>
        </trans-unit>
        <trans-unit id="a16a3e9b2eb88fe04764ed85fb0218873cc38566" translate="yes" xml:space="preserve">
          <source>Module sexp</source>
          <target state="translated">모듈 섹스</target>
        </trans-unit>
        <trans-unit id="59d0872f6bd60a77e18aa4238e904f432277b85d" translate="yes" xml:space="preserve">
          <source>Module sha1</source>
          <target state="translated">모듈 sha1</target>
        </trans-unit>
        <trans-unit id="4ece62635ed6e99fbdb3e080b7996745d5c3b1f3" translate="yes" xml:space="preserve">
          <source>Module sharedlist</source>
          <target state="translated">모듈 공유 목록</target>
        </trans-unit>
        <trans-unit id="b5e68bfc8c55fb54fde0c83c3f95af5feaf92c9b" translate="yes" xml:space="preserve">
          <source>Module sharedtables</source>
          <target state="translated">모듈 공유 테이블</target>
        </trans-unit>
        <trans-unit id="c339964428c500099d3daed6fb8542e3b613f1ef" translate="yes" xml:space="preserve">
          <source>Module smtp</source>
          <target state="translated">모듈 smtp</target>
        </trans-unit>
        <trans-unit id="ac4edb7026adc886e3dd2c3c0e2fa6b2624eac99" translate="yes" xml:space="preserve">
          <source>Module sockets</source>
          <target state="translated">모듈 소켓</target>
        </trans-unit>
        <trans-unit id="44b9eae64da1d100a47749f8e94861aceb4e1953" translate="yes" xml:space="preserve">
          <source>Module sqlite3</source>
          <target state="translated">모듈 sqlite3</target>
        </trans-unit>
        <trans-unit id="8c907d2d3470228660aa0f1c6e876cce39cd9be0" translate="yes" xml:space="preserve">
          <source>Module ssl</source>
          <target state="translated">모듈 SSL</target>
        </trans-unit>
        <trans-unit id="5dddec2bc7b6889e3d6e4572f0e2abcd568ae642" translate="yes" xml:space="preserve">
          <source>Module stats</source>
          <target state="translated">모듈 통계</target>
        </trans-unit>
        <trans-unit id="af7ea72f6db5731696a9ec545d89e8dbf5355b5e" translate="yes" xml:space="preserve">
          <source>Module streams</source>
          <target state="translated">모듈 스트림</target>
        </trans-unit>
        <trans-unit id="d563539aac0aa375abd30d9cff848fd83c1d6b90" translate="yes" xml:space="preserve">
          <source>Module strformat</source>
          <target state="translated">모듈 형식</target>
        </trans-unit>
        <trans-unit id="c5b35d487655735440b1511f4cbcb6212ffb09bf" translate="yes" xml:space="preserve">
          <source>Module strmisc</source>
          <target state="translated">모듈 strmisc</target>
        </trans-unit>
        <trans-unit id="39a556995953f0750f993afaabbda0fb9aa0c361" translate="yes" xml:space="preserve">
          <source>Module strscans</source>
          <target state="translated">모듈 스캔</target>
        </trans-unit>
        <trans-unit id="9add54a0554d7d5e3b57ccafbebed36cfff3a00a" translate="yes" xml:space="preserve">
          <source>Module strtabs</source>
          <target state="translated">모듈 strtab</target>
        </trans-unit>
        <trans-unit id="2c2fe9377d124f6f70ba53c4aac93232b71c1394" translate="yes" xml:space="preserve">
          <source>Module strutils</source>
          <target state="translated">모듈 strutils</target>
        </trans-unit>
        <trans-unit id="c427c4ed878b917bab65e9b41afb7305c3c93c47" translate="yes" xml:space="preserve">
          <source>Module subexes</source>
          <target state="translated">모듈 하위 실행</target>
        </trans-unit>
        <trans-unit id="2ff9cf6c55f0b207b0fa1b96a01a770ee71c8eaa" translate="yes" xml:space="preserve">
          <source>Module sugar</source>
          <target state="translated">모듈 설탕</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">모듈 시스템</target>
        </trans-unit>
        <trans-unit id="e9cc05615900094d98054d721ed949701ef00a47" translate="yes" xml:space="preserve">
          <source>Module tables</source>
          <target state="translated">모듈 테이블</target>
        </trans-unit>
        <trans-unit id="12b55983071a387f9c09feaf0f6a54c990c5be1d" translate="yes" xml:space="preserve">
          <source>Module terminal</source>
          <target state="translated">모듈 단자</target>
        </trans-unit>
        <trans-unit id="84ba9986fea98d5aed3aa1e050cd37789056e75a" translate="yes" xml:space="preserve">
          <source>Module that implements a fixed length array whose size is determined at runtime. Note: This is not ready for other people to use!</source>
          <target state="translated">런타임에 크기가 결정되는 고정 길이 배열을 구현하는 모듈. 참고 : 이것은 다른 사람들이 사용할 준비가되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="3b2dabb54c51f17c55a0e6927caa5f742504ae33" translate="yes" xml:space="preserve">
          <source>Module threadpool</source>
          <target state="translated">모듈 스레드 풀</target>
        </trans-unit>
        <trans-unit id="f92a75aeabfd1c4044569aecab8ccb991701806b" translate="yes" xml:space="preserve">
          <source>Module threads</source>
          <target state="translated">모듈 스레드</target>
        </trans-unit>
        <trans-unit id="fb3625f5ec0037d48d6c0cb336a239dd3b00b7ca" translate="yes" xml:space="preserve">
          <source>Module times</source>
          <target state="translated">모듈 시간</target>
        </trans-unit>
        <trans-unit id="80fdbaacf746a3cedeab4e5928808c2384a50612" translate="yes" xml:space="preserve">
          <source>Module typeinfo</source>
          <target state="translated">모듈 유형 정보</target>
        </trans-unit>
        <trans-unit id="2b741b4fc7fd10f81b2d720dc6c96f43017249fb" translate="yes" xml:space="preserve">
          <source>Module typetraits</source>
          <target state="translated">모듈 유형 특성</target>
        </trans-unit>
        <trans-unit id="9043c86e7cedc7aab24be69a0efdba5ddf0f80e5" translate="yes" xml:space="preserve">
          <source>Module unicode</source>
          <target state="translated">모듈 유니 코드</target>
        </trans-unit>
        <trans-unit id="7085badef4953ee4bbceb9688b13d4140b27c724" translate="yes" xml:space="preserve">
          <source>Module unittest</source>
          <target state="translated">모듈 단위 테스트</target>
        </trans-unit>
        <trans-unit id="8bbd7d4f48877a7314d216e6ebdb985da4bfafac" translate="yes" xml:space="preserve">
          <source>Module uri</source>
          <target state="translated">모듈 URI</target>
        </trans-unit>
        <trans-unit id="8a680992d6079b9c0e11b05251fd8f87bfbf1fe8" translate="yes" xml:space="preserve">
          <source>Module winlean</source>
          <target state="translated">윈린 모듈</target>
        </trans-unit>
        <trans-unit id="d8fdebbbc5615918cb9d798309cb31cd866e4994" translate="yes" xml:space="preserve">
          <source>Module xmldom</source>
          <target state="translated">모듈 xmldom</target>
        </trans-unit>
        <trans-unit id="f295719f36ed63526a4da7b30de4cad8a8999c32" translate="yes" xml:space="preserve">
          <source>Module xmldomparser</source>
          <target state="translated">모듈 xmldomparser</target>
        </trans-unit>
        <trans-unit id="634e83af2de2c8fae54f36c85ad255fa78fdc1fe" translate="yes" xml:space="preserve">
          <source>Module xmlparser</source>
          <target state="translated">모듈 xmlparser</target>
        </trans-unit>
        <trans-unit id="fffc921107774b45b37fb11a2ae26e6c1756df47" translate="yes" xml:space="preserve">
          <source>Module xmltree</source>
          <target state="translated">모듈 xmltree</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d4bb1d0c8920c90ab574ded6626feabfc7eb5056" translate="yes" xml:space="preserve">
          <source>Modules for JS backend</source>
          <target state="translated">JS 백엔드 용 모듈</target>
        </trans-unit>
        <trans-unit id="04ed0b03aed0cadb43ffc6bfd838816a8c42b369" translate="yes" xml:space="preserve">
          <source>Modules like &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;osproc&lt;/code&gt; use the Ansi versions of the Windows API. The default build uses the Unicode version.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; 및 &lt;code&gt;osproc&lt;/code&gt; 와 같은 모듈 은 Ansi 버전의 Windows API를 사용합니다. 기본 빌드는 유니 코드 버전을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5492a7b7e10ca5189dd3f4f7cd04aaa834acbe84" translate="yes" xml:space="preserve">
          <source>More examples with custom pragmas:</source>
          <target state="translated">맞춤 pragma를 사용한 추가 예 :</target>
        </trans-unit>
        <trans-unit id="02e1b6aeefcbcdce8ddb030e0d03e46f8f19c14b" translate="yes" xml:space="preserve">
          <source>More information: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt;/</source>
          <target state="translated">자세한 정보 : &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt; /</target>
        </trans-unit>
        <trans-unit id="2fa11c0cc6358778587e65242e73c28f8b0ce69a" translate="yes" xml:space="preserve">
          <source>Most (if not all) modules that use asyncio provide a userArg which is passed on with the events. The type that you set userArg to must be inheriting from &lt;code&gt;RootObj&lt;/code&gt;!</source>
          <target state="translated">asyncio를 사용하는 대부분의 모듈은 이벤트와 함께 전달되는 userArg를 제공합니다. 상속해야하는 유형 당신은 userArg를 설정하는 것이 &lt;code&gt;RootObj&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="3a3648df8257d95dad8a542820feec7313dcffba" translate="yes" xml:space="preserve">
          <source>Most calling conventions exist only for the Windows 32-bit platform.</source>
          <target state="translated">대부분의 호출 규칙은 Windows 32 비트 플랫폼에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="d682310dcece700c3a8748a725359d19f632cdec" translate="yes" xml:space="preserve">
          <source>Most native Nim types support conversion to strings with the special &lt;code&gt;$&lt;/code&gt; proc. When calling the &lt;code&gt;echo&lt;/code&gt; proc, for example, the built-in stringify operation for the parameter is called:</source>
          <target state="translated">대부분의 네이티브 Nim 유형은 특수 &lt;code&gt;$&lt;/code&gt; proc를 사용하여 문자열로의 변환을 지원 합니다. 예를 들어, &lt;code&gt;echo&lt;/code&gt; proc을 호출 할 때 매개 변수에 대한 내장 stringify 조작이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c330bf74003c40f0baff1596cb0fe1aa69f44229" translate="yes" xml:space="preserve">
          <source>Most often integers are used for counting objects that reside in memory, so &lt;code&gt;int&lt;/code&gt; has the same size as a pointer.</source>
          <target state="translated">대부분 정수는 메모리에있는 객체를 계산하는 데 사용되므로 &lt;code&gt;int&lt;/code&gt; 는 포인터와 크기가 같습니다.</target>
        </trans-unit>
        <trans-unit id="2dcc64ab52a078dbecfc23dc0e106a84a69bd521" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized ordered set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">초기화되지 않은 주문 설정을 통해 대부분의 작업은 런타임에와 충돌합니다 &lt;a href=&quot;system#assert&quot;&gt;주장&lt;/a&gt; 디버그 빌드에서. 자신의 procs에서이 proc을 사용하여 procs에 전달 된 순서 집합이 올바르게 초기화되었는지 확인할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="b286a20955238c202888cbd22fcba1b32dbb5ccf" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">초기화되지 않은 설정을 통해 대부분의 작업은 런타임에와 충돌합니다 &lt;a href=&quot;system#assert&quot;&gt;주장&lt;/a&gt; 디버그 빌드에서. 자신의 procs에서이 proc을 사용하여 procs에 전달 된 세트가 올바르게 초기화되었는지 확인할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="40f1f54ed50170dad3e2a2e1db2410306c0d2895" translate="yes" xml:space="preserve">
          <source>Most procedures raise OSError on error, but some may return &lt;code&gt;-1&lt;/code&gt; or a boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">대부분의 프로시 저는 오류시 OSError를 발생 시키지만 일부는 &lt;code&gt;-1&lt;/code&gt; 또는 부울 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbb5ab88dfbf525d498b45d241a40f2698fed97a" translate="yes" xml:space="preserve">
          <source>Mostly used by the &lt;a href=&quot;tables&quot;&gt;tables&lt;/a&gt; module, it can also be raised by other collection modules like &lt;a href=&quot;sets&quot;&gt;sets&lt;/a&gt; or &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;tables&quot;&gt;테이블&lt;/a&gt; 모듈에서 주로 사용되며 &lt;a href=&quot;sets&quot;&gt;set&lt;/a&gt; 또는 &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt; 와 같은 다른 컬렉션 모듈에서도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff0881f9033325d1090cbf272495b3ea89cd9ef" translate="yes" xml:space="preserve">
          <source>Move optimization</source>
          <target state="translated">이동 최적화</target>
        </trans-unit>
        <trans-unit id="4406458901a000581b1c862bae39b54d20d9bf38" translate="yes" xml:space="preserve">
          <source>Moves a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised.</source>
          <target state="translated">디렉토리를 &lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 이동합니다 . 이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a88abf00e872b645596ba5706595492621b50d3" translate="yes" xml:space="preserve">
          <source>Moves a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. Can be used to &lt;span id=&quot;rename-files_1&quot;&gt;rename files&lt;/span&gt;</source>
          <target state="translated">파일을 &lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 이동합니다 . 이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. &lt;span id=&quot;rename-files_1&quot;&gt;파일 이름&lt;/span&gt; 을 &lt;span id=&quot;rename-files_1&quot;&gt;바꾸는&lt;/span&gt; 데 사용할 수 있습니다&lt;span id=&quot;rename-files_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8720bd922009aac72de226d7d61d6fe73ea2154f" translate="yes" xml:space="preserve">
          <source>Moves the cursor backward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">&lt;em&gt;카운트&lt;/em&gt; 열 만큼 커서를 뒤로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="5b4f5707c476bf0444f3d7ca4829bce587056960" translate="yes" xml:space="preserve">
          <source>Moves the cursor down by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">&lt;em&gt;카운트&lt;/em&gt; 행 단위로 커서를 아래로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="5731b74c9a2498294ab69fa71acf35d7129365e9" translate="yes" xml:space="preserve">
          <source>Moves the cursor forward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">&lt;em&gt;카운트&lt;/em&gt; 열을 기준으로 커서를 앞으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="eb4d28da6332be8ce6373d9d339c7fe48fa23486" translate="yes" xml:space="preserve">
          <source>Moves the cursor up by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">&lt;em&gt;카운트&lt;/em&gt; 행 만큼 커서를 위로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="78732a3d2d5bc767bacb10d82e232dfa8d87404f" translate="yes" xml:space="preserve">
          <source>Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.</source>
          <target state="translated">제네릭과 마찬가지로 개념은 테스트 된 각 유형마다 정확히 한 번 인스턴스화되며 본문에 포함 된 정적 코드는 한 번만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5f2fd6e9c15080786fa9fc4a690a2cc1e48b6a" translate="yes" xml:space="preserve">
          <source>Multi-line procedure calls should continue on the same column as the opening parenthesis (like multi-line procedure declarations).</source>
          <target state="translated">여러 줄 프로 시저 호출은 여는 괄호와 같은 열에서 계속되어야합니다 (여러 줄 프로 시저 선언과 같이).</target>
        </trans-unit>
        <trans-unit id="9254f56fa866823471402ac94c86d60cd0bf7ec3" translate="yes" xml:space="preserve">
          <source>Multi-methods</source>
          <target state="translated">Multi-methods</target>
        </trans-unit>
        <trans-unit id="f038ab50dbba14467b3f2d54ae4453034bd4e0b4" translate="yes" xml:space="preserve">
          <source>Multicast address.</source>
          <target state="translated">멀티 캐스트 주소.</target>
        </trans-unit>
        <trans-unit id="7eef768291d80681527aa60e3df38506cba1a219" translate="yes" xml:space="preserve">
          <source>Multicast global address.</source>
          <target state="translated">멀티 캐스트 전체 주소</target>
        </trans-unit>
        <trans-unit id="48369fed2a551361b8045057023eecff834b5fb1" translate="yes" xml:space="preserve">
          <source>Multicast link-local address.</source>
          <target state="translated">멀티 캐스트 링크 로컬 주소</target>
        </trans-unit>
        <trans-unit id="24dcc40f5a40c25ac2feb7b6c8089ae89a9733cc" translate="yes" xml:space="preserve">
          <source>Multicast node-local address.</source>
          <target state="translated">멀티 캐스트 노드 로컬 주소</target>
        </trans-unit>
        <trans-unit id="7b7ea2cc81efabb6fd79723109a63d77b71fcdc4" translate="yes" xml:space="preserve">
          <source>Multicast organization-local address.</source>
          <target state="translated">멀티 캐스트 조직 로컬 주소</target>
        </trans-unit>
        <trans-unit id="3867c8b804a55ef6500439f739768f84c270b65d" translate="yes" xml:space="preserve">
          <source>Multicast site-local address.</source>
          <target state="translated">멀티 캐스트 사이트 로컬 주소</target>
        </trans-unit>
        <trans-unit id="d8164f83c1acb0822b6c1157de32950f13f00bf8" translate="yes" xml:space="preserve">
          <source>Multiline comments</source>
          <target state="translated">여러 줄 주석</target>
        </trans-unit>
        <trans-unit id="64ad927c3d1f8a60b8de3a4dcfa11cb5f9ed2b35" translate="yes" xml:space="preserve">
          <source>Multiline comments are started with &lt;code&gt;#[&lt;/code&gt; and terminated with &lt;code&gt;]#&lt;/code&gt;. Multiline comments can also be nested.</source>
          <target state="translated">여러 줄 주석은 &lt;code&gt;#[&lt;/code&gt; 으로 시작 하고 &lt;code&gt;]#&lt;/code&gt; 으로 끝납니다 . 여러 줄 주석도 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b13e7abf733936d7df1349e642855933b8c93f" translate="yes" xml:space="preserve">
          <source>Multiline comments support nesting:</source>
          <target state="translated">여러 줄 주석은 중첩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d8b83fc7a7727ea41499ff067b6d0dbb7149942a" translate="yes" xml:space="preserve">
          <source>Multiline documentation comments also exist and support nesting too:</source>
          <target state="translated">여러 줄 문서 주석도 존재하며 중첩도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cbf27a3ccf0fd00bcb0f6850421450358a6cae08" translate="yes" xml:space="preserve">
          <source>Multimedia support</source>
          <target state="translated">멀티미디어 지원</target>
        </trans-unit>
        <trans-unit id="09f3196845a8359a6ecedfa5af3141e1edccd739" translate="yes" xml:space="preserve">
          <source>Multiple arguments can be used.</source>
          <target state="translated">여러 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89c998a8939bd86eba71a1abb06f5d85c817883" translate="yes" xml:space="preserve">
          <source>Multiplies in place a floating point number</source>
          <target state="translated">부동 소수점 수를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="fcd886e69a9b9ba9f155b8a7f1e41875370c7b1d" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;x&lt;/em&gt; with &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 에 &lt;em&gt;y를&lt;/em&gt; 곱하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2f2f1bb918524a79ef38752dea6ec686cd665c1" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;y&lt;/em&gt; 에 &lt;em&gt;x를&lt;/em&gt; 곱하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf4b7cc064435e9b222c2ae1ef88a90049e33ef7" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;y&lt;/em&gt; 에 복소수 &lt;em&gt;x&lt;/em&gt; 를 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="967a2a96e493c3fa19de6d580534df7c563be46e" translate="yes" xml:space="preserve">
          <source>Multiply a duration by some scalar.</source>
          <target state="translated">지속 시간에 스칼라를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="3992914db890fb69ae7d33ac0b14f1598d61248c" translate="yes" xml:space="preserve">
          <source>Multiply complex &lt;em&gt;x&lt;/em&gt; with float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">복소수 &lt;em&gt;x&lt;/em&gt; 에 float &lt;em&gt;y를&lt;/em&gt; 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="1b5c2c91504b80f3c83b9e589314371f1f27f89a" translate="yes" xml:space="preserve">
          <source>Multiply float &lt;em&gt;x&lt;/em&gt; with complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 에 복소수 &lt;em&gt;y를&lt;/em&gt; 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="0476878c0b1cabcde1afe8aa70cf6a429753af27" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;x&lt;/em&gt; with rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">int &lt;em&gt;x&lt;/em&gt; 에 유리수 &lt;em&gt;y를&lt;/em&gt; 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="10cf9524fcce1f51fd3027d067a68e18439d699b" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">int &lt;em&gt;y&lt;/em&gt; 에 유리수 &lt;em&gt;x&lt;/em&gt; 를 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="bfb40c2a917440a979a3937c83ab1838a96e6061" translate="yes" xml:space="preserve">
          <source>Multiply rational &lt;em&gt;x&lt;/em&gt; with int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 에 int &lt;em&gt;y를&lt;/em&gt; 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="be6d2d49f08d8ce52cada7a4e40308b84089a378" translate="yes" xml:space="preserve">
          <source>Multiply rationals &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;y&lt;/em&gt; 에 &lt;em&gt;x를&lt;/em&gt; 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="407f3e6e72365b49bada1f7c9b2babeb3f8c1e8f" translate="yes" xml:space="preserve">
          <source>Multiply two rational numbers.</source>
          <target state="translated">두 개의 유리수를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="57d62a44db1dbaaab6871e35242edd989b03aa79" translate="yes" xml:space="preserve">
          <source>Mutually recursive types</source>
          <target state="translated">상호 재귀 유형</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="c83bf68eaf2532d248d1885057b7fe59c910abf7" translate="yes" xml:space="preserve">
          <source>Name of the test suite that contains this test case. Can be &lt;code&gt;nil&lt;/code&gt; if the test case is not in a suite.</source>
          <target state="translated">이 테스트 케이스가 포함 된 테스트 스위트의 이름입니다. 테스트 케이스가 스위트에없는 경우에는 &lt;code&gt;nil&lt;/code&gt; 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">명명 된 인수</target>
        </trans-unit>
        <trans-unit id="dc74246cc093982dca8a3a3f276b5d8b65d59486" translate="yes" xml:space="preserve">
          <source>Named pipe, or FIFO.</source>
          <target state="translated">명명 된 파이프 또는 FIFO</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">명명 규칙</target>
        </trans-unit>
        <trans-unit id="c6c5f0ef33b66371fc9992be0b7555afe7072e1f" translate="yes" xml:space="preserve">
          <source>Naming scheme</source>
          <target state="translated">명명 체계</target>
        </trans-unit>
        <trans-unit id="9a732a9b195778d45aff4c029836d8016c6d092a" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last access.</source>
          <target state="translated">마지막 액세스의 나노초 단위 시간.</target>
        </trans-unit>
        <trans-unit id="44a8ea231c9b25a28c6b1bae13f6d58d8ab769bb" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last data modification.</source>
          <target state="translated">마지막 데이터 수정의 나노초 단위 시간.</target>
        </trans-unit>
        <trans-unit id="ac4471c1eac2668f96fa75ca630c4f282bc0b52a" translate="yes" xml:space="preserve">
          <source>Nanoseconds display</source>
          <target state="translated">나노초 표시</target>
        </trans-unit>
        <trans-unit id="8b8960e4540a492b4c2ade7385f3643ce326ec71" translate="yes" xml:space="preserve">
          <source>Natural log of the gamma function</source>
          <target state="translated">감마 함수의 자연 로그</target>
        </trans-unit>
        <trans-unit id="40ae5bdaf41bbc2df0ddd3ba6cd0e29b307d851a" translate="yes" xml:space="preserve">
          <source>Navigation through the FTP server's directories.</source>
          <target state="translated">FTP 서버의 디렉토리를 통한 탐색</target>
        </trans-unit>
        <trans-unit id="b5c25dae4dbbde41bb6194a297db2a60c41076f4" translate="yes" xml:space="preserve">
          <source>Negated version of &lt;em&gt;is&lt;/em&gt;. Equivalent to &lt;code&gt;not(x is y)&lt;/code&gt;.</source>
          <target state="translated">의 부정 버전은 &lt;em&gt;입니다&lt;/em&gt; . &lt;code&gt;not(x is y)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c0ca5089d3b83be1bafc4d4d1a8a2d03a288270" translate="yes" xml:space="preserve">
          <source>Neither inline nor closure iterators can be recursive.</source>
          <target state="translated">인라인 또는 클로저 반복자는 재귀적일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0db36e51e26b9948538aa75241b28b52b8a7c448" translate="yes" xml:space="preserve">
          <source>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">사전 서면 허가없이이 소프트웨어에서 파생 된 제품을 보증하거나 홍보하는 데 케임브리지 대학교 이름이나 기고자 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d050b1bc6d5102e8c3c43e52f8c2bc1d471d35c1" translate="yes" xml:space="preserve">
          <source>Network Programming and Internet Protocols</source>
          <target state="translated">네트워크 프로그래밍 및 인터넷 프로토콜</target>
        </trans-unit>
        <trans-unit id="171eece6964ab33a2181793b80b9e480760fd86a" translate="yes" xml:space="preserve">
          <source>Never used by PCRE itself</source>
          <target state="translated">PCRE 자체에서 사용되지 않음</target>
        </trans-unit>
        <trans-unit id="17c5fe945bffa6ac038aff7b2982abfca0575621" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;AsyncEvent&lt;/code&gt; object is not automatically registered with dispatcher like &lt;code&gt;AsyncSocket&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;AsyncEvent&lt;/code&gt; 의 객체가 자동으로 같은 디스패처에 등록되지 않은 &lt;code&gt;AsyncSocket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d212a8c45cffe38583de7b76bc156d6b77f1fb" translate="yes" xml:space="preserve">
          <source>New data is written into the future stream.</source>
          <target state="translated">새로운 데이터가 미래 스트림에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="567bb6ab39291d029af6c28280c594e2fe015993" translate="yes" xml:space="preserve">
          <source>New nil literal shortcut</source>
          <target state="translated">새로운 nil 리터럴 단축키</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="7793ecd2f1c81dc748001f595a446d07a21dca61" translate="yes" xml:space="preserve">
          <source>Nim Backend Integration</source>
          <target state="translated">Nim 백엔드 통합</target>
        </trans-unit>
        <trans-unit id="16df2910cd311102e24b9deaaab6834d4ce68a59" translate="yes" xml:space="preserve">
          <source>Nim Compiler</source>
          <target state="translated">님 컴파일러</target>
        </trans-unit>
        <trans-unit id="21f8909f95c6aa6f948aea798f908963482f9a9e" translate="yes" xml:space="preserve">
          <source>Nim Compiler User Guide</source>
          <target state="translated">Nim 컴파일러 사용 설명서</target>
        </trans-unit>
        <trans-unit id="4e729000a4923f3f92aa9b54b57cd9d13b461a42" translate="yes" xml:space="preserve">
          <source>Nim DocGen Tools Guide</source>
          <target state="translated">Nim DocGen 도구 안내서</target>
        </trans-unit>
        <trans-unit id="3e73c9c60a5f0a7a9de0b9e82a823b0e9e25a26d" translate="yes" xml:space="preserve">
          <source>Nim Documentation</source>
          <target state="translated">님 설명서</target>
        </trans-unit>
        <trans-unit id="f6faadf36850555183f2e6623ce564cd582735b7" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1</source>
          <target state="translated">님 향상 제안 # 1</target>
        </trans-unit>
        <trans-unit id="a017c7a8f194b967e2353a197aaf8085c32d102d" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1 - Standard Library Style Guide</source>
          <target state="translated">Nim Enhancement Proposal # 1-표준 라이브러리 스타일 안내서</target>
        </trans-unit>
        <trans-unit id="088e91f2731d3d61908df7c6c9c0f48f04e35180" translate="yes" xml:space="preserve">
          <source>Nim IDE Integration Guide</source>
          <target state="translated">Nim IDE 통합 안내서</target>
        </trans-unit>
        <trans-unit id="ff5833e01f31589edf6457bc7ab5ad35afc09f25" translate="yes" xml:space="preserve">
          <source>Nim Manual</source>
          <target state="translated">님 매뉴얼</target>
        </trans-unit>
        <trans-unit id="a5cb0d9617774a42fc73cf0e3f868eb3b8c421d4" translate="yes" xml:space="preserve">
          <source>Nim OID support. An OID is a global ID that consists of a timestamp, a unique counter and a random value. This combination should suffice to produce a globally distributed unique ID. This implementation was extracted from the Mongodb interface and it thus binary compatible with a Mongo OID.</source>
          <target state="translated">Nim OID 지원 OID는 타임 스탬프, 고유 카운터 및 임의 값으로 구성된 전역 ID입니다. 이 조합은 전체적으로 분산 된 고유 ID를 생성하기에 충분해야합니다. 이 구현은 Mongodb 인터페이스에서 추출되어 Mongo OID와 바이너리 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="8afe44256c32445d4aba7446f16d139424f08995" translate="yes" xml:space="preserve">
          <source>Nim Standard Library</source>
          <target state="translated">님 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="322ec21475cb7cfeb95acf76114506a7658630c5" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part I)</source>
          <target state="translated">님 튜토리얼 (파트 I)</target>
        </trans-unit>
        <trans-unit id="e48ab7d7dac65733835e8b6fac71558fd72d4d0c" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part II)</source>
          <target state="translated">님 튜토리얼 (파트 II)</target>
        </trans-unit>
        <trans-unit id="ab4a51307d67466d1629dcfcafd64254208d0d47" translate="yes" xml:space="preserve">
          <source>Nim allows &lt;code&gt;.global, compiletime&lt;/code&gt; variables that can be filled by macro invokations across different modules. This feature breaks modularity in a severe way. Plenty of different solutions have been proposed:</source>
          <target state="translated">Nim은 여러 모듈에서 매크로 호출로 채울 수있는 &lt;code&gt;.global, compiletime&lt;/code&gt; 변수를 허용 합니다. 이 기능은 모듈성을 심각하게 손상시킵니다. 다양한 솔루션이 제안되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7723fae5b868ab64bfd1ed4f9d563b3f719c2a6" translate="yes" xml:space="preserve">
          <source>Nim allows user defined operators. An operator is any combination of the following characters:</source>
          <target state="translated">Nim은 사용자 정의 연산자를 허용합니다. 연산자는 다음 문자의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="dec77fd63ea6f3b6392da08312e8457c86c6a4ab" translate="yes" xml:space="preserve">
          <source>Nim allows user-definable operators. Binary operators have 11 different levels of precedence.</source>
          <target state="translated">Nim은 사용자 정의 연산자를 허용합니다. 이항 연산자의 우선 순위는 11 가지입니다.</target>
        </trans-unit>
        <trans-unit id="bb3ac87c3ce8cafa37c2ac5913d2e44f2c0fae11" translate="yes" xml:space="preserve">
          <source>Nim also allows for type classes and regular types to be specified as &lt;span id=&quot;type-constraints_1&quot;&gt;type constraints&lt;/span&gt; of the generic type parameter:</source>
          <target state="translated">Nim을 사용하면 형식 클래스와 일반 형식을 일반 형식 매개 변수의 &lt;span id=&quot;type-constraints_1&quot;&gt;형식 제약 조건&lt;/span&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7367770c702c3c07c0edb5a157905ffed2fb24f" translate="yes" xml:space="preserve">
          <source>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</source>
          <target state="translated">Nim은 클래스에 메소드를 지정하지 않음으로써 이러한 문제를 피합니다. Nim의 모든 방법은 다중 방법입니다. 나중에 볼 수 있듯이, 멀티 메소드는 동적 바인딩 목적으로 만 proc와 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb26fe48597e8b904be37ef641797aa814138fa" translate="yes" xml:space="preserve">
          <source>Nim can also generate &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; code through the &lt;code&gt;js&lt;/code&gt; command.</source>
          <target state="translated">Nim은 &lt;code&gt;js&lt;/code&gt; 명령을 통해 &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; 코드를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af85440d1b434e6ec278854daf1f3f305d5ad156" translate="yes" xml:space="preserve">
          <source>Nim code calling the backend</source>
          <target state="translated">백엔드를 호출하는 님 코드</target>
        </trans-unit>
        <trans-unit id="6b156a5e46fd0f15d386450049ef7bee6965340f" translate="yes" xml:space="preserve">
          <source>Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:</source>
          <target state="translated">Nim 코드는 JavaScript로 컴파일 할 수 있습니다. 그러나 JavaScript 호환 코드를 작성하려면 다음을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9fa29ab6035f83a6a5d536db8f22202827f364" translate="yes" xml:space="preserve">
          <source>Nim code can interface with the backend through the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;Foreign function interface&lt;/a&gt; mainly through the &lt;a href=&quot;manual#importc-pragma&quot;&gt;importc pragma&lt;/a&gt;. The &lt;code&gt;importc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making backend symbols available in Nim and is available in all the target backends (JavaScript too). The C++ or Objective-C backends have their respective &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; and &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragmas to call methods from classes.</source>
          <target state="translated">Nim 코드는 주로 &lt;a href=&quot;manual#importc-pragma&quot;&gt;importc pragma를&lt;/a&gt; 통해 &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;Foreign 함수 인터페이스를&lt;/a&gt; 통해 백엔드와 인터페이스 할 수 있습니다 . &lt;code&gt;importc&lt;/code&gt; 프라 그마는이다 &lt;em&gt;일반적인&lt;/em&gt; 님에서 사용할 수있는 백엔드 기호를 만드는 방법과 (너무 JavaScript)를 모든 대상 백엔드에서 사용할 수 있습니다. C ++ 또는 Objective-C 백엔드에는 클래스에서 메소드를 호출하기 위한 각각의 &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; 및 &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragma가 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31a93bb37537ccf8bc65c227c96a067156777ba9" translate="yes" xml:space="preserve">
          <source>Nim code renderer (AST back to its textual form)</source>
          <target state="translated">님 코드 렌더러 (ASTN)</target>
        </trans-unit>
        <trans-unit id="fabc8c2c3d55b64590195b71fee1f8bf15a0783b" translate="yes" xml:space="preserve">
          <source>Nim condition variable</source>
          <target state="translated">님 조건 변수</target>
        </trans-unit>
        <trans-unit id="d2f3eed8f027ae703cfbb62e68bece8443bf88e7" translate="yes" xml:space="preserve">
          <source>Nim contains a sophisticated compile-time evaluator, so procedures which have no side-effect can be used in constant expressions too:</source>
          <target state="translated">Nim에는 정교한 컴파일 타임 평가 기가 포함되어 있으므로 부작용이없는 프로시 저는 상수 표현식에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a84a384a071f2c590cf4715be4dfac5778bd58a" translate="yes" xml:space="preserve">
          <source>Nim contains language features that are &lt;em&gt;global&lt;/em&gt;. The best example for that are multi methods: Introducing a new method with the same name and some compatible object parameter means that the method's dispatcher needs to take the new method into account. So the dispatching logic is only completely known after the whole program has been translated!</source>
          <target state="translated">Nim에는 &lt;em&gt;전 세계&lt;/em&gt; 언어 기능이 포함되어 있습니다 . 이에 대한 가장 좋은 예는 다중 메소드입니다. 동일한 이름과 일부 호환 가능한 객체 매개 변수를 사용하여 새 메소드를 도입하면 메소드의 디스패처가 새 메소드를 고려해야합니다. 따라서 디스패치 로직은 전체 프로그램이 번역 된 후에 만 ​​완전히 알려집니다!</target>
        </trans-unit>
        <trans-unit id="fc85ea062290958c11ff84b074507e523841a2ee" translate="yes" xml:space="preserve">
          <source>Nim coroutines implementation supports several context switching methods: ucontext: available on unix and alike (default) setjmp: available on unix and alike (x86/64 only) Fibers: available and required on windows.</source>
          <target state="translated">Nim 코 루틴 구현은 여러 컨텍스트 전환 방법을 지원합니다. ucontext : 유닉스 및 유사 (기본)에서 가능 setjmp : 유닉스 및 유사 (x86 / 64 만)에서 가능 섬유 : Windows에서 사용 가능하고 필수입니다.</target>
        </trans-unit>
        <trans-unit id="bd26dc8c514bd37794fcd3b5dc3270d84d36b348" translate="yes" xml:space="preserve">
          <source>Nim currently generates &lt;em&gt;async/await&lt;/em&gt; JavaScript code which is supported in modern EcmaScript and most modern versions of browsers, Node.js and Electron. If you need to use this module with older versions of JavaScript, you can use a tool that backports the resulting JavaScript code, as babel.</source>
          <target state="translated">Nim은 현재 최신 EcmaScript와 최신 버전의 브라우저 (Node.js 및 Electron)에서 지원되는 &lt;em&gt;비동기 / 대기&lt;/em&gt; JavaScript 코드를 생성 합니다. 이 모듈을 이전 버전의 JavaScript와 함께 사용해야하는 경우 결과 JavaScript 코드를 babel로 백 포트하는 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb9f4917308e21a1a3ea298a44a71e622ad4adc" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;idetools&lt;/code&gt; command of &lt;a href=&quot;nimc&quot;&gt;the compiler&lt;/a&gt;, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim은 정말 빠르다는 점에서 다른 많은 컴파일러와 다릅니다. 너무 빠르면 텍스트 편집기에 작성되는 소스 코드에 대한 외부 쿼리를 제공하는 데 적합합니다. &lt;a href=&quot;nimc&quot;&gt;컴파일러&lt;/a&gt; 의 &lt;code&gt;idetools&lt;/code&gt; 명령을 통해 모든 IDE는 &lt;code&gt;.nim&lt;/code&gt; 소스 파일을 쿼리하고 심볼 정의 또는 완료 제안과 같은 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7c9cacf76b4e6e9b8bdb4149ed42fa0f2b0f03" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim은 정말 빠르다는 점에서 다른 많은 컴파일러와 다릅니다. 너무 빠르면 텍스트 편집기에 작성되는 소스 코드에 대한 외부 쿼리를 제공하는 데 적합합니다. 가장 &lt;code&gt;nimsuggest&lt;/code&gt; 도구를 통해 모든 IDE는 &lt;code&gt;.nim&lt;/code&gt; 소스 파일을 쿼리하고 심볼 정의 또는 완성 제안과 같은 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2086951d5e25c94d3bcd3c946d696aab645c5e42" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects in a garbage collected heap, untraced references point to manually allocated objects or to objects elsewhere in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (e.g., accessing the hardware), untraced references are necessary.</source>
          <target state="translated">Nim은 &lt;span id=&quot;traced_1&quot;&gt;추적 된&lt;/span&gt; 참조 와 &lt;span id=&quot;traced_1&quot;&gt;추적되지 &lt;/span&gt;&lt;span id=&quot;untraced_1&quot;&gt;않은&lt;/span&gt; 참조를 구별 합니다. 추적되지 않은 참조를 &lt;em&gt;포인터&lt;/em&gt; 라고도 합니다. 추적 된 참조는 가비지 수집 힙의 객체를 가리키고, 추적되지 않은 참조는 수동으로 할당 된 객체 또는 메모리의 다른 곳을 가리 킵니다. 따라서 추적되지 &lt;em&gt;않은&lt;/em&gt; 참조는 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 그러나 특정 하위 수준 작업 (예 : 하드웨어 액세스)의 경우 추적되지 않은 참조가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ccd83d27c6d420699215e95b7549c5d18179dd95" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</source>
          <target state="translated">Nim은 &lt;span id=&quot;traced_1&quot;&gt;추적 된&lt;/span&gt; 참조 와 &lt;span id=&quot;traced_1&quot;&gt;추적되지 &lt;/span&gt;&lt;span id=&quot;untraced_1&quot;&gt;않은&lt;/span&gt; 참조를 구별 합니다. 추적되지 않은 참조를 &lt;em&gt;포인터&lt;/em&gt; 라고도 합니다. 추적 된 참조는 가비지 수집 힙의 객체를 가리키고, 추적되지 않은 참조는 수동으로 할당 된 객체 또는 메모리의 다른 곳을 가리 킵니다. 따라서 추적되지 &lt;em&gt;않은&lt;/em&gt; 참조는 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 그러나 특정 저수준 작업 (하드웨어에 액세스)의 경우 추적되지 않은 참조는 피할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dac7bba6bc8f19f6387033c2480f36e741751cd5" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;type-casts_1&quot;&gt;type casts&lt;/span&gt; and &lt;span id=&quot;type-conversions_1&quot;&gt;type conversions&lt;/span&gt;. Casts are done with the &lt;code&gt;cast&lt;/code&gt; operator and force the compiler to interpret a bit pattern to be of another type.</source>
          <target state="translated">Nim은 &lt;span id=&quot;type-casts_1&quot;&gt;타입 캐스트&lt;/span&gt; 와 &lt;span id=&quot;type-conversions_1&quot;&gt;타입 변환을&lt;/span&gt; 구별 합니다. 캐스트는 &lt;code&gt;cast&lt;/code&gt; 연산자 로 수행되며 컴파일러가 비트 패턴을 다른 유형으로 해석하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0dc26f37589711a4ebd6a75d29c4f31d6f5268ca" translate="yes" xml:space="preserve">
          <source>Nim documentation tools</source>
          <target state="translated">님 문서화 도구</target>
        </trans-unit>
        <trans-unit id="32a303beaf961d29337f0ffeb398d9c829260321" translate="yes" xml:space="preserve">
          <source>Nim expression</source>
          <target state="translated">님 표현</target>
        </trans-unit>
        <trans-unit id="835ecda86802386305ce589edd8369f0e4a635cf" translate="yes" xml:space="preserve">
          <source>Nim file input</source>
          <target state="translated">님 파일 입력</target>
        </trans-unit>
        <trans-unit id="07b88f09d9e474dda1eb0ea8c1cc96c629f4c605" translate="yes" xml:space="preserve">
          <source>Nim for embedded systems</source>
          <target state="translated">임베디드 시스템 용 Nim</target>
        </trans-unit>
        <trans-unit id="a0e42e450f6ef10bfc996fbef965403967ca2952" translate="yes" xml:space="preserve">
          <source>Nim for realtime systems</source>
          <target state="translated">실시간 시스템을위한 Nim</target>
        </trans-unit>
        <trans-unit id="ad31881a208f486ef9ab2bb940bdcd789a709ad9" translate="yes" xml:space="preserve">
          <source>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</source>
          <target state="translated">님은 사용자를 귀찮게 할 수있는 몇 가지 경고와 힌트 ( &quot;너무 긴 줄&quot;)를 생성합니다. 특정 메시지를 비활성화하는 메커니즘이 제공됩니다. 각 힌트 및 경고 메시지에는 괄호 안에 기호가 있습니다. 이는 메시지를 활성화 또는 비활성화하는 데 사용할 수있는 메시지 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim에는 CPU를 많이 사용하는 작업에 사용할 수있는 내장 스레드 풀이 있습니다. IO 집약적 작업의 경우 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 기능을 대신 사용해야합니다. 병렬 및 스폰 둘 다 작동 하려면 &lt;a href=&quot;threadpool&quot;&gt;스레드 풀&lt;/a&gt; 모듈이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim은 &lt;em&gt;get-properties&lt;/em&gt; 가 필요하지 않습니다 . &lt;em&gt;메소드 호출 구문으로 호출&lt;/em&gt; 되는 일반적인 get-procedure 는 동일한 결과를 얻습니다. 그러나 값을 설정하는 것은 다릅니다. 이를 위해 특별한 세터 구문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">Nim에는 별도의 최적화 프로그램이 없지만 생성 된 C 코드는 매우 효율적입니다. 대부분의 C 컴파일러에는 뛰어난 옵티마이 저가 있으므로 일반적으로 코드를 최적화 할 필요가 없습니다. Nim은 효율적인 코드를 장려하도록 설계되었습니다. Nim에서 가장 읽기 쉬운 코드가 종종 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim은 가져온 모듈을 찾거나 파일을 포함 할 위치를 결정하기 위해 쿼리되는 전역 검색 경로 (PATH) 개념을 가지고 있습니다. 여러 파일이 발견되면 모호성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">Nim에는 다음 부동 소수점 유형이 내장되어 있습니다. &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">Nim에는 다음 정수 유형이 내장되어 있습니다. &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Nim에는 두 가지 병렬 처리 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">Nim idetools 통합</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">C의 Nim 호출 예제</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">JavaScript의 Nim 호출 예제</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">님은 자유 소프트웨어입니다. &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT 라이센스에&lt;/a&gt; 따라 라이센스가 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">님 잠금, 재진입</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">님 잠금; 재진입 여부는 불특정입니다!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">님 유지 보수 스크립트</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim은 이전에 선언되지 않은 기호 이름을 참조하여 프로세스 호출 및 필드 액세스 시도를 가로 채서 다시 쓰는 데 사용할 수있는 특수 도트 연산자 제품군을 제공합니다. 동적 스크립팅 언어의 값 또는 JSON 또는 XML과 같은 동적 파일 형식과 같은 유형 시스템의 정적 경계 외부에있는 객체에 유창한 인터페이스를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim은 대상 백엔드와 양방향 인터페이스를 제공합니다. 즉, Nim에서 백엔드 코드를 호출 할 수 있으며 백엔드 코드로 Nim 코드를 호출 할 수 있습니다. 일반적으로 소프트웨어 아키텍처에 따라 어떤 호출 방향 (Nim이 기본 프로그램입니까 아니면 Nim이 구성 요소를 제공하고 있습니까?)</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim은 내 보내지 않고 사용되지 않은 기호에 대해 경고를 생성합니다. &lt;code&gt;used&lt;/code&gt; 프라 그마는이 경고를 억제하는 기호에 부착 될 수있다. 이는 매크로가 심볼을 생성 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim은 idetools 명령을 통해 외부 IDE와의 언어 통합을 제공합니다. 자세한 내용은 &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim은 &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; 및 &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; 명령을 제공하여 &lt;code&gt;.nim&lt;/code&gt; 소스 파일 에서 HTML 문서를 생성 합니다. 내 보낸 심볼 만 출력에 나타납니다. 자세한 내용 &lt;a href=&quot;docgen&quot;&gt;은 docgen 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim은 C ++과 유사한 프로 시저를 오버로드하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim은 pragma &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; 및 &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; 를 제공하여 IEEE 예외가 무시되는지 또는 Nim 예외를 트랩할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Nim 검색 및 교체 유틸리티.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim은 추가 pragma를 통해 이러한 기능의 안전성을 크게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">&lt;span id=&quot;substitution-expressions_1&quot;&gt;대체 표현식에&lt;/span&gt; 대한 Nim 지원 ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim은 예외 추적을 지원합니다. 이 &lt;span id=&quot;raises_1&quot;&gt;제기&lt;/span&gt; 프라그 명시 적 PROC / 반복기 / 방법 / 컨버터 올리 허용되는 예외를 정의하는데 사용될 수있다. 컴파일러는 이것을 검증합니다 :</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim은 모듈 개념으로 프로그램을 조각으로 분할하는 것을 지원합니다. 각 모듈은 자체 파일에 있어야하며 자체 &lt;span id=&quot;namespace_1&quot;&gt;네임 스페이스가&lt;/span&gt; 있습니다. 모듈은 &lt;span id=&quot;information-hiding_1&quot;&gt;정보 숨기기&lt;/span&gt; 및 &lt;span id=&quot;separate-compilation_1&quot;&gt;별도의 컴파일을&lt;/span&gt; 가능하게 &lt;span id=&quot;information-hiding_1&quot;&gt;합니다&lt;/span&gt; . 모듈은 &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; 문 을 통해 다른 모듈의 심볼에 액세스 할 수 있습니다 . &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;재귀 모듈 종속성&lt;/span&gt; 은 허용되지만 약간 미묘합니다. 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 표시된 최상위 심볼 만 내 보냅니다. 유효한 모듈 이름은 유효한 Nim 식별자 만 가능하므로 파일 이름은 &lt;code&gt;identifier.nim&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim은 모듈 개념으로 프로그램을 조각으로 분할하는 것을 지원합니다. 각 모듈은 자체 파일에 있습니다. 모듈은 &lt;span id=&quot;information-hiding_1&quot;&gt;정보 숨기기&lt;/span&gt; 및 &lt;span id=&quot;separate-compilation_1&quot;&gt;별도의 컴파일을&lt;/span&gt; 가능하게 &lt;span id=&quot;information-hiding_1&quot;&gt;합니다&lt;/span&gt; . 모듈은 &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; 문 을 사용하여 다른 모듈의 심볼에 액세스 할 수 있습니다 . 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 표시된 최상위 심볼 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim은 DLL 생성을 지원합니다. 그러나 프로세스 / 주소 공간 당 GC 인스턴스는 하나만 있어야합니다. 이 인스턴스는 &lt;code&gt;nimrtl.dll&lt;/code&gt; 에 포함되어 있습니다 . 이것은 생성 된 모든 Nim DLL이 &lt;code&gt;nimrtl.dll&lt;/code&gt; 에 의존한다는 것을 의미합니다 . &quot;nimrtl.dll&quot;파일을 생성하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim은 다음과 같은 &lt;span id=&quot;calling-conventions_1&quot;&gt;호출 규칙을&lt;/span&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim은 널리 사용되는 모든 브라우저에서 지원되는 JavaScript 1.5를 대상으로합니다. JavaScript에는 다른 모듈을 포함 할 수있는 이식 가능한 수단이 없으므로 Nim은 긴 &lt;code&gt;.js&lt;/code&gt; 파일 만 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">님 타입</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim은 대부분의 유형에 구조적 유형 동등성을 사용합니다. 객체, 열거 및 구별 유형 이름 동등성에 대해서만 사용됩니다. &lt;em&gt;pseudo-code&lt;/em&gt; 의 다음 알고리즘 &lt;em&gt;은&lt;/em&gt; 유형 평등을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Nim은 클래식 컴파일러 아키텍처를 사용합니다. lexer / scanner는 토큰을 파서에 공급합니다. 파서는 코드 생성기에서 사용하는 구문 트리를 작성합니다. 이 구문 트리는 파서와 코드 생성기 간의 인터페이스입니다. 대부분의 컴파일러 코드를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Nim은 일반적인 문장 / 표현 패러다임을 사용합니다. 문장은 표현식과 달리 값을 생성하지 않습니다. 그러나 일부 표현은 진술입니다.</target>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">님의 가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">Nim의 &lt;code&gt;import&lt;/code&gt; 문은 실제로 어떤 키워드가 있는지에 따라 다르게 변형됩니다. 가장 간단한 양식부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">Nim의 &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface)는 광범위하며 다른 미래 백엔드 (LLVM / JavaScript 백엔드와 같은)로 확장되는 부분 만 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">님의 가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">님의 부울 유형이라고 &lt;code&gt;bool&lt;/code&gt; 두 미리 정의 된 값으로 구성 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; . while, if, elif 및 when 문의 조건은 bool 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">스레드에 대한 Nim의 메모리 모델은 다른 일반적인 프로그래밍 언어 (C, Pascal)와는 매우 다릅니다. 각 스레드에는 자체 (가비지 수집) 힙이 있으며 메모리 공유가 제한됩니다. 이것은 경쟁 조건을 예방하고 효율성을 향상시킵니다. &lt;a href=&quot;manual#threads&quot;&gt;이 메모리 모델에 대한 자세한&lt;/a&gt; 내용 은 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">스레드에 대한 Nim의 메모리 모델은 다른 일반적인 프로그래밍 언어 (C, Pascal, Java)의 메모리 모델과는 상당히 다릅니다. 각 스레드에는 자체 (가비지 수집) 힙이 있으며 메모리 공유는 전역 변수로 제한됩니다. 이것은 경쟁 조건을 방지하는 데 도움이됩니다. GC는 다른 스레드를 중지하고 참조하는 것을 볼 필요가 없기 때문에 GC 효율성이 상당히 향상되었습니다. 메모리 할당에는 전혀 잠금이 필요하지 않습니다! 이 디자인은 표준이되는 대규모 멀티 코어 프로세서로 쉽게 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">님의 객체 구문은 풍부합니다. 복잡성의 일부를보기 위해 전체적으로 관련된 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">님의 파서</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">님의 표준 문법은 &lt;span id=&quot;indentation-sensitive_1&quot;&gt;들여 쓰기에 민감한&lt;/span&gt; 언어를 설명합니다 . 이는 모든 제어 구조가 들여 쓰기로 인식됨을 의미합니다. 들여 쓰기는 공백으로 만 구성됩니다. tabulators는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">님의 표준 난수 생성기. &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate) 라이브러리를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble은 Nim 프로그래밍 언어의 패키지 관리자입니다. Nimble 패키지 설치 방법에 대한 지침은 &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;해당 README를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache 및 C 유사 대상</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache와 자바 스크립트 대상</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">Nimcache 이름 지정 논리</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep은 특히 Nim의 편심 &lt;em&gt;스타일 무감도&lt;/em&gt; 를 잘 지원합니다 . 그 외에도 일반적인 텍스트 조작 도구입니다.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep은 검색 및 교체 작업을위한 명령 줄 도구입니다. 정규식 또는 페그 패턴을 검색하고 전체 디렉토리를 한 번에 검색 할 수 있습니다. 모든 단일 교체 작업에 대한 사용자 확인을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">IDE 지원에 가장 적합한</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">가장 가까운 호출</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">님 무스 트는 님의 핵심의 일부입니다. 다음을 통해 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Nimuggest 출력은 항상 탭 문자 ( &lt;code&gt;\t&lt;/code&gt; )로 구분 된 한 줄로 반환됩니다 . 각 열의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">쿼리가 처리되기를 기다리는 것보다 가장 까다 롭습니다. 질의는 암호로 된 3 문자 &quot;command&quot; &lt;code&gt;def&lt;/code&gt; 또는 &lt;code&gt;con&lt;/code&gt; 또는 &lt;code&gt;sug&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 와 위치로 구성됩니다. 쿼리 위치는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest는 항상 단일 정의로 응답하거나 쿼리 위치와 일치하는 유효한 기호를 찾을 수 없으면 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">더 이상 실제로 사용되지 않음</target>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">NoDecl pragma</target>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">기본이 아닌 분리 문자를 전달하여 다른 종류의 &quot;라인 유사&quot;가변 길이 레코드를 반복 할 수 있습니다. = 먹고 '\ 0'를 엄격히로 전달 &lt;em&gt;DELIM&lt;/em&gt; -delimited. ( '\ 0'과 같은 선택적 접두사를 먹는 것은 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">비 인쇄 문자</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">순수하지 않은 열거 형 값은 camelCase를 사용해야하지만 순수한 열거 형 값은 PascalCase를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">비 터미널은 소문자로 시작하며 추상 터미널 기호는 대문자입니다. 축약어 터미널 기호 (키워드 포함)는 &lt;code&gt;'&lt;/code&gt; 로 인용됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">deque에서 개별 값을 얻는 procs는 빈 deque에서 사용할 수 없습니다. &lt;em&gt;boundChecks&lt;/em&gt; 옵션으로 컴파일하면 해당 &lt;em&gt;프로세스&lt;/em&gt; 에서 해당 액세스에 대해 &lt;em&gt;IndexError&lt;/em&gt; 가 발생합니다. &lt;em&gt;-d : release&lt;/em&gt; 는 이러한 검사를 비활성화하고 가비지를 반환하거나 프로그램을 중단시킬 수 있으므로이를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">과부하 불가능한 내장</target>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">주변 공백이 제거 된 일반 기호가 색인에 추가됩니다. 이에 대한 예외는 목차 (TOC) 항목입니다. 목차가 TOC에있는 수만큼의 접두사 공간이있는 세 번째 열과 함께 TOC 항목이 색인 파일에 추가됩니다 (최소 1 자). 접두사 공백은 API 또는 텍스트 기호에서 TOC 항목을 필터링하는 데 도움이됩니다. 공간의 양이 최종 색인의 문서 TOC에 대한 &lt;code&gt;.nim&lt;/code&gt; 를 복제하는 데 사용되며 .nim 파일에있는 TOC 항목 이 삭제 되기 때문에 이는 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">경로를 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 정규화 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">주석이 아님</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">nil이 아닌 주석은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">술어 아님</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">술어 아님 : 식 E가 앞의 텍스트와 일치하면 실패를 나타냅니다. 그렇지 않으면 성공을 나타냅니다. 텍스트를 소비하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">그 자체로는 그다지 유용하지는 않지만,이를 사용 하여 &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find () 프로 시저&lt;/a&gt; 가 문자열에서 &lt;strong&gt;유효하지 않은&lt;/strong&gt; 문자를 찾 도록 &lt;em&gt;반전 된&lt;/em&gt; 세트를 작성할 수 있습니다 . 예:&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">내장 &lt;code&gt;len&lt;/code&gt; proc이 어떻게 배열의 첫 번째 차원 길이 만 반환 하는지 주목하십시오 . 중첩 특성을 더 잘 설명하기 위해 &lt;code&gt;LightTower&lt;/code&gt; 를 정의하는 또 다른 방법은 &lt;code&gt;LevelSetting&lt;/code&gt; 유형 의 이전 정의를 생략 하고 대신 첫 번째 차원의 유형으로 직접 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">예제 에 생성 된 Nim 코드에서 &lt;code&gt;iupdll&lt;/code&gt; 기호 를 선언하는 추가 C 코드가 어떻게 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">참고 &lt;code&gt;getCurrentException&lt;/code&gt; 는 항상 반환 &lt;code&gt;ref Exception&lt;/code&gt; 유형입니다. 적절한 유형의 변수가 필요한 경우 (위의 예에서 &lt;code&gt;IOError&lt;/code&gt; ) 명시 적으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">참고 &lt;code&gt;import math as m&lt;/code&gt; 다른 노드를 사용하지 않습니다; 오히려, 우리는 사용 &lt;code&gt;nnkImportStmt&lt;/code&gt; 을 과 &lt;code&gt;as&lt;/code&gt; 중위 연산자로.</target>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">참고 &lt;code&gt;system.finished&lt;/code&gt; 는 단지 반환하기 때문에 사용하기 쉬운 오류가 &lt;code&gt;true&lt;/code&gt; 반복자가 완료되면 하나의 반복 :</target>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;using&lt;/code&gt; 적용되지 &lt;code&gt;template&lt;/code&gt; 유형에 지정되지 않은 템플릿 매개 변수의 기본부터 &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Nim의 확장 원시 문자열 리터럴은 &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; 구문 을 &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; 의 짧은 형식으로 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">기간이 없더라도 제외 될 수 있음을 유의 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 참 큰 절대 시간을 나타내는 수는. 절대 기간을 비교 하려면 &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; 를 사용하십시오. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; 매개 변수에 전달 된 명시 적 배열 생성자 는 다른 암시 적 배열 구성으로 래핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">현재 예상 &lt;code&gt;method&lt;/code&gt; 대신 발견 된 메소드의 서명에 대해 &lt;code&gt;proc&lt;/code&gt; 단어 가 리턴됩니다 . 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">프로 시저를 호출하는 단일 할당으로 여러 변수를 선언하면 예기치 않은 결과가 발생할 수 있습니다. 컴파일러는 할당 을 &lt;em&gt;풀고&lt;/em&gt; 프로 시저를 여러 번 호출하게됩니다. 절차의 결과가 부작용에 의존하는 경우 변수의 값이 다를 수 있습니다! 안전을 위해 여러 번 할당 할 경우 부작용이없는 절차를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">컴파일러는 어떤 식 으로든 (지정된 할당에서 유추 할 수있는) 유형을 알아야하기 때문에 위의 두 번째 또는 세 번째 (또는 둘 다) 매개 변수가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">연속 스택이있는 시스템 (대부분의 시스템에 있음)의 경우 참조가 스택에 있는지 확인하는 것이 매우 저렴합니다 (두 개의 비교 만).</target>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">예제에서 생성자 &lt;code&gt;newLit&lt;/code&gt; 및 &lt;code&gt;newPlus&lt;/code&gt; 는 정적 바인딩을 사용하는 것이 더 의미가 있기 때문에 procs이지만, &lt;code&gt;eval&lt;/code&gt; 은 동적 바인딩이 필요하기 때문에 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">모든 &lt;code&gt;nnkTypeDef&lt;/code&gt; 가 &lt;code&gt;nnkIdent&lt;/code&gt; 를 매개 변수로 사용 하는 것은 아닙니다 . 타입 선언의 가장 일반적인 용도 중 하나는 객체를 다루는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">3 개 이하의 8 진 숫자는 읽지 않기 때문에 100 이상의 8 진 값은 앞에 오는 0으로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">이것은 반복자이므로 반복하는 문자열을 수정해서는 안됩니다. 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">참고는 것을 &lt;code&gt;Time&lt;/code&gt; 인수 시점을 나타내지 않는, 그것은 현지 시간을 나타냅니다! 예를 들어 &lt;code&gt;adjTime&lt;/code&gt; 이 &lt;code&gt;fromUnix(0)&lt;/code&gt; 이면 UTC가 아닌 &lt;code&gt;zone&lt;/code&gt; 시간대 에서 1970-01-01T00 : 00 : 00으로 해석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">procs에 대한 &lt;code&gt;importcpp&lt;/code&gt; 변형은 최대한의 유연성을 위해 다소 암호화 된 패턴 언어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">&lt;code&gt;jsondoc&lt;/code&gt; 명령 은 예쁘게 인쇄하지 않고 JSON을 출력하는 반면 &lt;code&gt;jsondoc0&lt;/code&gt; 은 예쁘게 인쇄 된 JSON을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">인코딩을 설정 한 후에는 변경할 수 없습니다. SQLite3 문서에 따르면 데이터베이스가 작성된 후 인코딩을 변경하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">참고 모듈 이름은 여전히 것을 &lt;code&gt;strutils&lt;/code&gt; 하지 &lt;code&gt;lib/pure/strutils&lt;/code&gt; 하나 그렇게 &lt;strong&gt;할 수없는&lt;/strong&gt; 수행</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">패턴 언어는 자연스럽게 C ++의 연산자 오버로드 기능도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">정규 표현식은 의도 한대로 작동하지 않습니다. 예제에서 &lt;code&gt;*&lt;/code&gt; 는 욕심이 없어야하므로 대신 &lt;code&gt;\[.*?\]&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">시퀀스는 0으로 된 항목으로 채워지며 문자열을 포함하는 시퀀스의 값은 &lt;code&gt;nil&lt;/code&gt; 이기 때문에 문제가 될 수 있습니다 . 시퀀스를 생성 한 후 추가하는 대신 시퀀스에 항목을 할당해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">삼각 함수는 자연스럽게 라디안에서 작동합니다. 도우미 함수 &lt;em&gt;degToRad&lt;/em&gt; 및 &lt;em&gt;radToDeg&lt;/em&gt; 는 라디안과도 사이의 변환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">이 규칙에는 예외가있을 수 있습니다. Nim은 그처럼 유연하기 때문에 특정 상황에서는 이해가되지 않는이 스타일 가이드의 일부가있을 것입니다. 또한 &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;파이썬의 스타일 가이드&lt;/a&gt; 가 시간이 지남에 따라 변경 되는 것처럼 이 스타일 가이드도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">이것은 &lt;em&gt;런타임&lt;/em&gt; 호출이며 매크로 내에서 &lt;code&gt;quit&lt;/code&gt; 을 사용 하면 컴파일 시간 효과가 없습니다. 매크로 내에서 컴파일러를 중지해야하는 경우 &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;오류&lt;/a&gt; 또는 &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;치명적인&lt;/a&gt; pragma를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">이것은 기본적으로 Nim에 존재하는 유일한 형식 추론 형식입니다. 간결성과 가독성 사이의 좋은 절충안입니다.</target>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">이 pragma는 다소 잘못된 것입니다. 다른 백엔드는 동일한 이름으로 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">이 pragma는 다소 잘못된 것입니다. 다른 백엔드는 동일한 이름으로 동일한 기능을 제공합니다. 또한 C ++ 과 인터페이스 하고 &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; 와 Objective-C와 인터페이스하고 &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;있으면 ImportObjC pragma를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">이를 위해서는 입력 및 출력 유형이 동일해야합니다 (제자리에서 수정되므로). 매개 변수 함수는 &lt;code&gt;var T&lt;/code&gt; 유형 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">이를 위해서는 입력 및 출력 유형이 동일해야합니다 (제자리에서 수정되므로). 매개 변수 함수는 &lt;code&gt;T&lt;/code&gt; 유형 변수를 가져오고 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">이 버전의 &lt;code&gt;map&lt;/code&gt; 에서는 입력 및 출력 유형이 동일하게 수정되어야합니다 (제자리에서 수정되므로).</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">형식 유추는 기본값이있는 매개 변수에 적용됩니다. 예를 들어 &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; 을 쓸 필요가 없습니다 : string = &quot;unknown&quot; .</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 데이터와 동일한 크기이므로 정렬 옵션은이 경우 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">정렬되지 않은 또는 정렬 된 선택 연산자 ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; )는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">월을 추가 할 때 월요일 오버플로가 허용됩니다. 즉, 결과 월에 일 수가 충분하지 않으면 월이 증가하고 월일이 오버플로 된 일 수로 설정됩니다. 1 개월을 추가 그래서 &lt;em&gt;(31) 10 월&lt;/em&gt; 에 발생합니다 &lt;em&gt;11월 31일&lt;/em&gt; 오버 플로우와 초래할 것이다, &lt;em&gt;12 월 1&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">여러 개의 삽입 연산자를 사용하면 명령이 연산자 우선 순위에 따라 구문 분석됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
