<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="42990e8d286d37551071332b9121a8612c8438d5" translate="yes" xml:space="preserve">
          <source>Closes the database connection.</source>
          <target state="translated">데이터베이스 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="2efdb2b9a5fb0fb0dfc161aa071faade80a58272" translate="yes" xml:space="preserve">
          <source>Closes the file specified.</source>
          <target state="translated">지정된 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="c4ff63fa85db450c0b8efcf5dbcdc3cd9880b858" translate="yes" xml:space="preserve">
          <source>Closes the file.</source>
          <target state="translated">파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="0146ce78d015ea8e74af50fbb0752de4a6645ed2" translate="yes" xml:space="preserve">
          <source>Closes the selector.</source>
          <target state="translated">선택기를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e252b2992033e8d453dcf8db318690b39e28adb6" translate="yes" xml:space="preserve">
          <source>Closes the socket</source>
          <target state="translated">소켓을 닫습니다</target>
        </trans-unit>
        <trans-unit id="d088ba46947a0a90bc08a101b18b61eb57bcdcb7" translate="yes" xml:space="preserve">
          <source>Closes the socket.</source>
          <target state="translated">소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="358e9ce9eb4dde7cc51c84b2514e0d337c0d712a" translate="yes" xml:space="preserve">
          <source>Closes user-defined event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 이벤트 &lt;code&gt;ev&lt;/code&gt; 를 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="f60f90bfb0ba11553d29fa35745bde4ff3e460f2" translate="yes" xml:space="preserve">
          <source>Closure iterators are &lt;em&gt;resumable functions&lt;/em&gt; and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:</source>
          <target state="translated">클로저 반복자는 &lt;em&gt;재개 가능한 함수입니다&lt;/em&gt; 이므로 모든 호출에 인수를 제공해야합니다. 이 한계를 극복하기 위해 외부 팩토리 프로세스의 매개 변수를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e578ab4b574d30ac423f92c9fab9fbe6d26dc03c" translate="yes" xml:space="preserve">
          <source>Closure iterators are not supported by the js backend.</source>
          <target state="translated">js 백엔드는 클로저 반복자를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac6bebb0e61dc15f297ef83fbf7603d0859ce49" translate="yes" xml:space="preserve">
          <source>Closure iterators have other restrictions than inline iterators:</source>
          <target state="translated">클로저 이터레이터는 인라인 이터레이터 이외의 다른 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b1546bfaf51b2730baa3cec8823ad69c6d520a" translate="yes" xml:space="preserve">
          <source>Closures</source>
          <target state="translated">Closures</target>
        </trans-unit>
        <trans-unit id="a59a3e19db547beb43e74807faac277fd8e514cf" translate="yes" xml:space="preserve">
          <source>Code generation for closures</source>
          <target state="translated">클로저를위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="2f2988662bb4dae449632c59f53891896c1ffe6f" translate="yes" xml:space="preserve">
          <source>Code generation for closures is implemented by &lt;span id=&quot;lambda-lifting_1&quot;&gt;lambda lifting&lt;/span&gt;.</source>
          <target state="translated">클로저를위한 코드 생성은 &lt;span id=&quot;lambda-lifting_1&quot;&gt;람다 리프팅에&lt;/span&gt; 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="da115340933af8057af8e634df00ede4fbf023ff" translate="yes" xml:space="preserve">
          <source>Code in branches must not affect semantics of the code that follows the &lt;code&gt;when nimvm&lt;/code&gt; statement. E.g. it must not define symbols that are used in the following code.</source>
          <target state="translated">분기의 코드는 &lt;code&gt;when nimvm&lt;/code&gt; 문 다음에 오는 코드의 의미에 영향을 주어서는 안됩니다 . 예를 들어 다음 코드에서 사용되는 기호를 정의해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="342a22088ff07c4856bdae6049bd642267e82137" translate="yes" xml:space="preserve">
          <source>Code reordering</source>
          <target state="translated">코드 재정렬</target>
        </trans-unit>
        <trans-unit id="6052b9228e0225025d8079d4cd9a44dffae292d0" translate="yes" xml:space="preserve">
          <source>Code to read some data from a socket may look something like this:</source>
          <target state="translated">소켓에서 일부 데이터를 읽는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3e28ec05628ca798056cbfe2d6c881da021d62b" translate="yes" xml:space="preserve">
          <source>CodeBegin</source>
          <target state="translated">CodeBegin</target>
        </trans-unit>
        <trans-unit id="f8913336b5472371376c916db93144a284d40348" translate="yes" xml:space="preserve">
          <source>CodeEnd</source>
          <target state="translated">CodeEnd</target>
        </trans-unit>
        <trans-unit id="90e297f174173c518c30f1b842a7ba4b8fe59f7f" translate="yes" xml:space="preserve">
          <source>CodegenDecl pragma</source>
          <target state="translated">CodegenDecl pragma</target>
        </trans-unit>
        <trans-unit id="f13c6d40584dcb243a09754125c5488f70e52a2c" translate="yes" xml:space="preserve">
          <source>Coding Conventions</source>
          <target state="translated">코딩 규칙</target>
        </trans-unit>
        <trans-unit id="130ffb676acebdd914d1ba89691ee6564f18cfff" translate="yes" xml:space="preserve">
          <source>Coding Guidelines</source>
          <target state="translated">코딩 지침</target>
        </trans-unit>
        <trans-unit id="61b2c7d3d530eede50c425105c2a07ac349b139d" translate="yes" xml:space="preserve">
          <source>Coding conventions: ALL types are named the same as in the POSIX standard except that they start with 'T' or 'P' (if they are pointers) and without the '_t' suffix to be consistent with Nim conventions. If an identifier is a Nim keyword the `identifier` notation is used.</source>
          <target state="translated">코딩 규칙 : 모든 유형의 이름은 POSIX 표준과 동일하게 지정됩니다. 단, 'T'또는 'P'(포인터 인 경우)로 시작하고 '_t'접미사없이 Nim 규칙과 일치합니다. 식별자가 Nim 키워드 인 경우 '식별자'표기법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21e28b42b63f040d868b338385a8167ba642e965" translate="yes" xml:space="preserve">
          <source>Collections and algorithms</source>
          <target state="translated">컬렉션과 알고리즘</target>
        </trans-unit>
        <trans-unit id="50faf4a1b9645cfa18e81b78bec6a225240d18b4" translate="yes" xml:space="preserve">
          <source>Collective imports from a directory</source>
          <target state="translated">디렉토리에서 일괄 가져 오기</target>
        </trans-unit>
        <trans-unit id="154f0a9ca98bc313c70b75923e7bd5fd5480e175" translate="yes" xml:space="preserve">
          <source>Column where the symbol is located in the file. Columns start to count at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">파일에서 기호가있는 열입니다. 열은 &lt;strong&gt;0&lt;/strong&gt; 부터 계산을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="b730a233b63c2d53c4768d67fff2f5f7835afa27" translate="yes" xml:space="preserve">
          <source>Combines a base URI with a reference URI.</source>
          <target state="translated">기본 URI와 참조 URI를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1ed571befc0ee7c064890552078226fe5f5464c0" translate="yes" xml:space="preserve">
          <source>Combines multiple URIs together.</source>
          <target state="translated">여러 URI를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="9121404c3361888c8d936a3c6ea87d5d1db69153" translate="yes" xml:space="preserve">
          <source>Command call</source>
          <target state="translated">커맨드 콜</target>
        </trans-unit>
        <trans-unit id="3ebaef5fa9df20d34828a55c8d915b4d58e4c565" translate="yes" xml:space="preserve">
          <source>Command has the form 'program args' where args are the command line arguments given to program. The proc returns the error code of the shell when it has finished. The proc does not return until the process has finished. To execute a program without having a shell involved, use the &lt;em&gt;execProcess&lt;/em&gt; proc of the &lt;em&gt;osproc&lt;/em&gt; module.</source>
          <target state="translated">명령의 형식은 'program args'입니다. 여기서 args는 프로그램에 제공된 명령 행 인수입니다. proc은 완료되면 쉘의 에러 코드를 반환한다 프로세스가 완료 될 때까지 프로세스가 반환되지 않습니다. 쉘 참여를하지 않고 프로그램을 실행하려면 사용 &lt;em&gt;execProcess의&lt;/em&gt; 의 PROC &lt;em&gt;osproc을&lt;/em&gt; 모듈 .</target>
        </trans-unit>
        <trans-unit id="ea4e7b6e909cec5cea4f1f8e29c9d02f8626fd95" translate="yes" xml:space="preserve">
          <source>Command invocation syntax</source>
          <target state="translated">명령 호출 구문</target>
        </trans-unit>
        <trans-unit id="1a602b900f84a5cedb11f83b2b59a0df7530ae0b" translate="yes" xml:space="preserve">
          <source>Command line parameters. It doesn't make sense to have these for a console anyways, so no big deal here.</source>
          <target state="translated">명령 줄 매개 변수 어쨌든 콘솔을 위해 이것을 갖는 것은 의미가 없으므로 여기서 큰 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc917b5ddc14434e4f4bd712313ab213bb59479b" translate="yes" xml:space="preserve">
          <source>Command line settings have priority over configuration file settings.</source>
          <target state="translated">명령 줄 설정은 구성 파일 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="774ba146a62c9c3ff46ff9cc5455b08807e03827" translate="yes" xml:space="preserve">
          <source>Command line switches</source>
          <target state="translated">커맨드 라인 스위치</target>
        </trans-unit>
        <trans-unit id="e7d3c5a2a69a1e7554cc4d6cced80eec24d1af6c" translate="yes" xml:space="preserve">
          <source>Command:</source>
          <target state="translated">Command:</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="274b97749534c15eb0881156658aa6a771af205f" translate="yes" xml:space="preserve">
          <source>Comments start anywhere outside a string or character literal with the hash character &lt;code&gt;#&lt;/code&gt;. Comments consist of a concatenation of &lt;span id=&quot;comment-pieces_1&quot;&gt;comment pieces&lt;/span&gt;. A comment piece starts with &lt;code&gt;#&lt;/code&gt; and runs until the end of the line. The end of line characters belong to the piece. If the next line only consists of a comment piece with no other tokens between it and the preceding one, it does not start a new comment:</source>
          <target state="translated">주석은 문자열 또는 문자 리터럴 외부에서 해시 문자 &lt;code&gt;#&lt;/code&gt; 로 시작 합니다. 주석은 &lt;span id=&quot;comment-pieces_1&quot;&gt;주석 조각&lt;/span&gt; 의 연결로 구성됩니다 . 주석 조각은 &lt;code&gt;#&lt;/code&gt; 으로 시작 하여 줄 끝까지 실행됩니다. 줄 끝 문자는 조각에 속합니다. 다음 행은 이전 토큰과 토큰 사이에 다른 토큰이없는 주석으로 만 구성된 경우 새 주석을 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c411e8b7522f5f1ab1db28f26cc28d9cfcd3b95f" translate="yes" xml:space="preserve">
          <source>Comments start anywhere outside a string or character literal with the hash character &lt;code&gt;#&lt;/code&gt;. Documentation comments start with &lt;code&gt;##&lt;/code&gt;:</source>
          <target state="translated">주석은 문자열 또는 문자 리터럴 외부에서 해시 문자 &lt;code&gt;#&lt;/code&gt; 로 시작 합니다. 설명서 주석은 &lt;code&gt;##&lt;/code&gt; 으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="4f1f26885ef678483f0972813d20a3f0988b06c7" translate="yes" xml:space="preserve">
          <source>Common datatypes and definitions for all &lt;code&gt;db_*.nim&lt;/code&gt; ( &lt;a href=&quot;db_mysql&quot;&gt;db_mysql&lt;/a&gt;, &lt;a href=&quot;db_postgres&quot;&gt;db_postgres&lt;/a&gt;, and &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;) modules.</source>
          <target state="translated">모든 &lt;code&gt;db_*.nim&lt;/code&gt; ( &lt;a href=&quot;db_mysql&quot;&gt;db_mysql&lt;/a&gt; , &lt;a href=&quot;db_postgres&quot;&gt;db_postgres&lt;/a&gt; 및 &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt; ) 모듈에 대한 공통 데이터 유형 및 정의</target>
        </trans-unit>
        <trans-unit id="902810f4e60ff40db9d84f3da77588ba1b818549" translate="yes" xml:space="preserve">
          <source>Commonly used commands and switches have abbreviations, so you can also use:</source>
          <target state="translated">일반적으로 사용되는 명령 및 스위치에는 약어가 있으므로 다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5319d0d1ec0d55142df426892db8c5d05612430" translate="yes" xml:space="preserve">
          <source>Compare a pair of MemSlice for strict equality.</source>
          <target state="translated">엄밀한 동등성을 위해 MemSlice 쌍을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="713c0a3395ba4071e3413c8aa68d41913525749b" translate="yes" xml:space="preserve">
          <source>Compare proc for strings. More efficient than the generic version. &lt;strong&gt;Note&lt;/strong&gt;: The precise result values depend on the used C runtime library and can differ between operating systems!</source>
          <target state="translated">문자열에 대한 proc을 비교하십시오. 일반 버전보다 더 효율적입니다. &lt;strong&gt;참고&lt;/strong&gt; : 정확한 결과 값은 사용 된 C 런타임 라이브러리에 따라 다르며 운영 체제마다 다를 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="69bc2d6cb05278fa849c74440b354d87fa821fc7" translate="yes" xml:space="preserve">
          <source>Compare two JsObjects or JsAssocs. Be careful though, as this is comparison like in JavaScript, so if your JsObjects are in fact JavaScript Objects, and not strings or numbers, this is a &lt;em&gt;comparison of references&lt;/em&gt;.</source>
          <target state="translated">두 개의 JsObject 또는 JsAssoc을 비교하십시오. JavaScript와 같은 비교이므로 JsObject가 실제로 문자열이나 숫자가 아닌 JavaScript 객체 &lt;em&gt;인 경우 reference 비교입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ace263e4f421cf6dcb4056cab9ce47e4c97e0a57" translate="yes" xml:space="preserve">
          <source>Compare two Mongo Object IDs for equality</source>
          <target state="translated">두 개의 몽고 객체 ID가 동일한 지 비교</target>
        </trans-unit>
        <trans-unit id="b756ed11ee75b3719724aaa8f881b347765d2a4c" translate="yes" xml:space="preserve">
          <source>Compare two complex numbers &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; approximately.</source>
          <target state="translated">두 개의 복소수 &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y를&lt;/em&gt; 대략 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="cda56ff99b85235122f5a9199c294005e500883f" translate="yes" xml:space="preserve">
          <source>Compare two complex numbers &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; for equality.</source>
          <target state="translated">동일성을 위해 두 개의 복소수 &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 를 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="363e8f93b8478ce56f8e97751dd31a0540861b16" translate="yes" xml:space="preserve">
          <source>Compares two IpAddresses for Equality. Returns true if the addresses are equal</source>
          <target state="translated">평등을 위해 두 IpAddress를 비교합니다. 주소가 동일한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dfc90cbcfaae0111e022afd0892deaca0124b935" translate="yes" xml:space="preserve">
          <source>Compares two UTF-8 strings and ignores the case. Returns:</source>
          <target state="translated">두 개의 UTF-8 문자열을 비교하고 대소 문자를 무시합니다. 보고:</target>
        </trans-unit>
        <trans-unit id="7964e96a9d4978590242bc809014c96b43dddcd4" translate="yes" xml:space="preserve">
          <source>Compares two integers for equality.</source>
          <target state="translated">두 정수가 같은지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="4755fdf3699ce46356b5650690f4aed883d34282" translate="yes" xml:space="preserve">
          <source>Compares two paths.</source>
          <target state="translated">두 경로를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="4bc1b15886f0cbabc95be9b72e466b42cff2a2ff" translate="yes" xml:space="preserve">
          <source>Compares two rationals.</source>
          <target state="translated">두 합리를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="1186fbbc3d52de56dbc9c9717535fda54143ab4e" translate="yes" xml:space="preserve">
          <source>Compares two strings in a case insensitive manner. Returns:</source>
          <target state="translated">대소 문자를 구분하지 않는 방식으로 두 문자열을 비교합니다. 보고:</target>
        </trans-unit>
        <trans-unit id="a1205e65094b19ac14de1f11feba4ed9f7fbd6ca" translate="yes" xml:space="preserve">
          <source>Compares two unsigned integers for equality.</source>
          <target state="translated">부호없는 두 정수가 같은지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="808665b55ba7e91152a1e1b3a1ba6da3d73c296b" translate="yes" xml:space="preserve">
          <source>Compilation cache</source>
          <target state="translated">컴파일 캐시</target>
        </trans-unit>
        <trans-unit id="0932ff4b69c147e1bda9fb48fe84be75b0a10c3e" translate="yes" xml:space="preserve">
          <source>Compilation to JavaScript</source>
          <target state="translated">JavaScript로 컴파일</target>
        </trans-unit>
        <trans-unit id="878af28b527d45c55cf5a43057e4215a4aca3e21" translate="yes" xml:space="preserve">
          <source>Compile and link against &lt;code&gt;nimrtl.dll&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nimrtl.dll&lt;/code&gt; 을 컴파일하고 링크 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c33145fed36fd775c7d41e28dfbc2215fbd287c5" translate="yes" xml:space="preserve">
          <source>Compile nimgrep with the command:</source>
          <target state="translated">다음 명령으로 nimgrep을 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="bf709b6eca5cee4cc4462e1ffec11a8906e37288" translate="yes" xml:space="preserve">
          <source>Compile pragma</source>
          <target state="translated">프라 그마 컴파일</target>
        </trans-unit>
        <trans-unit id="7488dd43b0bed69cfe822389dad57f393c6418dc" translate="yes" xml:space="preserve">
          <source>Compile the Nim code to JavaScript with &lt;code&gt;nim js -o:calculator.js calculator.nim&lt;/code&gt; and open &lt;code&gt;host.html&lt;/code&gt; in a browser. If the browser supports javascript, you should see the value &lt;code&gt;10&lt;/code&gt; in the browser's console. Use the &lt;a href=&quot;dom&quot;&gt;dom module&lt;/a&gt; for specific DOM querying and modification procs or take a look at &lt;a href=&quot;https://github.com/pragmagic/karax&quot;&gt;karax&lt;/a&gt; for how to develop browser based applications.</source>
          <target state="translated">&lt;code&gt;nim js -o:calculator.js calculator.nim&lt;/code&gt; 을 사용하여 Nim 코드를 JavaScript로 컴파일하고 브라우저에서 &lt;code&gt;host.html&lt;/code&gt; 을 엽니 다 . 브라우저가 자바 스크립트를 지원하는 경우 브라우저 콘솔에 값 &lt;code&gt;10&lt;/code&gt; 이 표시 됩니다. 특정 DOM 쿼리 및 수정 &lt;a href=&quot;https://github.com/pragmagic/karax&quot;&gt;프로세스에 &lt;/a&gt;&lt;a href=&quot;dom&quot;&gt;dom 모듈&lt;/a&gt; 을 사용 하거나 karax를 살펴보십시오. 에 브라우저 기반 애플리케이션을 개발하는 방법에 대한 를 .</target>
        </trans-unit>
        <trans-unit id="85eaa712abd6399660c862038765176bc6bda1e6" translate="yes" xml:space="preserve">
          <source>Compile the Nim code to JavaScript with &lt;code&gt;nim js -o:fib.js fib.nim&lt;/code&gt; and open &lt;code&gt;mhost.html&lt;/code&gt; in a browser. If the browser supports javascript, you should see an alert box displaying the text &lt;code&gt;Fib for 9 is 34&lt;/code&gt;. As mentioned earlier, JavaScript doesn't require an initialisation call to &lt;code&gt;NimMain&lt;/code&gt; or similar function and you can call the exported Nim proc directly.</source>
          <target state="translated">와 자바 스크립트에 님의 코드를 컴파일 &lt;code&gt;nim js -o:fib.js fib.nim&lt;/code&gt; 오픈 &lt;code&gt;mhost.html&lt;/code&gt; 브라우저입니다. 브라우저가 자바 스크립트를 지원하는 경우 &lt;code&gt;Fib for 9 is 34&lt;/code&gt; 텍스트 가 34 라는 경고 상자가 표시 됩니다. 앞에서 언급했듯이 JavaScript는 &lt;code&gt;NimMain&lt;/code&gt; 또는 이와 유사한 기능에 대한 초기화 호출이 필요하지 않으며 내 보낸 Nim 프로 시저를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3249c107401dff650798e6147591e69a403f5d98" translate="yes" xml:space="preserve">
          <source>Compile time symbols</source>
          <target state="translated">컴파일 타임 심볼</target>
        </trans-unit>
        <trans-unit id="6596981d9091711d03709b87143d43f267911a52" translate="yes" xml:space="preserve">
          <source>Compile time symbols are completely &lt;strong&gt;case insensitive&lt;/strong&gt; and underscores are ignored too. &lt;code&gt;--define:FOO&lt;/code&gt; and &lt;code&gt;--define:foo&lt;/code&gt; are identical.</source>
          <target state="translated">컴파일 시간 기호는 &lt;strong&gt;대소 문자를 구분하지 않으며&lt;/strong&gt; 밑줄도 무시됩니다. &lt;code&gt;--define:FOO&lt;/code&gt; 와 &lt;code&gt;--define:foo&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a4d15220f7a3c39d67a6c4bbb5529936f352e04" translate="yes" xml:space="preserve">
          <source>Compile-time &lt;a href=&quot;#readFile&quot;&gt;readFile&lt;/a&gt; proc for easy &lt;span id=&quot;resource_1&quot;&gt;resource&lt;/span&gt; embedding:</source>
          <target state="translated">쉬운 &lt;span id=&quot;resource_1&quot;&gt;리소스&lt;/span&gt; 임베딩을 위한 컴파일 타임 &lt;a href=&quot;#readFile&quot;&gt;readFile&lt;/a&gt; proc :&lt;span id=&quot;resource_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="3093b3355195e5474b9e58889d112403d17e51f9" translate="yes" xml:space="preserve">
          <source>Compiled test files return the number of failed test as exit code, while &lt;code&gt;nim c -r &amp;lt;testfile.nim&amp;gt;&lt;/code&gt; exits with 0 or 1</source>
          <target state="translated">컴파일 된 테스트 파일은 실패한 테스트 수를 종료 코드로 반환하지만 &lt;code&gt;nim c -r &amp;lt;testfile.nim&amp;gt;&lt;/code&gt; 은 0 또는 1로 종료됩니다</target>
        </trans-unit>
        <trans-unit id="bbb5c798e62139162af1473600be1f2596ffad9b" translate="yes" xml:space="preserve">
          <source>Compiler Messages</source>
          <target state="translated">컴파일러 메시지</target>
        </trans-unit>
        <trans-unit id="520d5b4d745c1a503b4c698fcaf940baef838b67" translate="yes" xml:space="preserve">
          <source>Compiler Selection</source>
          <target state="translated">컴파일러 선택</target>
        </trans-unit>
        <trans-unit id="1d3daee41eb1ab95a24f4b4808b6f46a84a1ada9" translate="yes" xml:space="preserve">
          <source>Compiler Usage</source>
          <target state="translated">컴파일러 사용법</target>
        </trans-unit>
        <trans-unit id="6e268e20d746fbfa3dab80e82d173f18b1763a04" translate="yes" xml:space="preserve">
          <source>Compiler as a service (CAAS)</source>
          <target state="translated">서비스로서의 컴파일러 (CAAS)</target>
        </trans-unit>
        <trans-unit id="3bd2372d9b1a43593fb29c3768d4082dd251bffe" translate="yes" xml:space="preserve">
          <source>Compiler user guide</source>
          <target state="translated">컴파일러 사용 설명서</target>
        </trans-unit>
        <trans-unit id="81ac7f1d4388e9b128f4215cf40efb4e745cff02" translate="yes" xml:space="preserve">
          <source>Compiles the passed string to its AST representation. Expects a single expression. Raises &lt;code&gt;ValueError&lt;/code&gt; for parsing errors.</source>
          <target state="translated">전달 된 문자열을 AST 표현으로 컴파일합니다. 단일 표현식이 필요합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 를이 오류를 구문 분석.</target>
        </trans-unit>
        <trans-unit id="a5085005cb5e2953acc40fa1e77b07cbbfd40dfe" translate="yes" xml:space="preserve">
          <source>Compiles the passed string to its AST representation. Expects one or more statements. Raises &lt;code&gt;ValueError&lt;/code&gt; for parsing errors.</source>
          <target state="translated">전달 된 문자열을 AST 표현으로 컴파일합니다. 하나 이상의 진술을 기대합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 를이 오류를 구문 분석.</target>
        </trans-unit>
        <trans-unit id="77eb56771c18bc8b264df4346e94b7ebe6b33123" translate="yes" xml:space="preserve">
          <source>Compiling the compiler is a simple matter of running:</source>
          <target state="translated">컴파일러 컴파일은 다음과 같은 간단한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="2f5077fe77321d47df48ccf8749520b36071aa88" translate="yes" xml:space="preserve">
          <source>Complete traversal is done in this way:</source>
          <target state="translated">다음과 같이 완전한 순회가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cab76b2ebd69bdf3b5b92eb52feb51cc4b402a6f" translate="yes" xml:space="preserve">
          <source>Completes &lt;code&gt;future&lt;/code&gt; with &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 를 &lt;code&gt;error&lt;/code&gt; 완성 .</target>
        </trans-unit>
        <trans-unit id="b727af9ba59f59ad76e825b70f43aaa3d42ea3d1" translate="yes" xml:space="preserve">
          <source>Completes &lt;code&gt;future&lt;/code&gt; with value &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">가치 &lt;code&gt;val&lt;/code&gt; 로 &lt;code&gt;future&lt;/code&gt; 를 완성합니다 .</target>
        </trans-unit>
        <trans-unit id="40ef4eeda1b4f2a13db5aaf9f7e4bddee599955c" translate="yes" xml:space="preserve">
          <source>Completes a &lt;code&gt;FutureStream&lt;/code&gt; signalling the end of data.</source>
          <target state="translated">&lt;code&gt;FutureStream&lt;/code&gt; 을 완성합니다데이터의 끝을 알리는 .</target>
        </trans-unit>
        <trans-unit id="0110b9cf619b8ce82b78df293b7c62f65f9eb0a4" translate="yes" xml:space="preserve">
          <source>Completes a &lt;code&gt;FutureVar&lt;/code&gt; with value &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 값 으로 &lt;code&gt;FutureVar&lt;/code&gt; 를 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="08cb7e6f1a4681459b6dd072ffa9fc0fdcc0eb0c" translate="yes" xml:space="preserve">
          <source>Completes a &lt;code&gt;FutureVar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FutureVar&lt;/code&gt; 를 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="6d097314815e40ae3735bd71a1636ee42c72c8e0" translate="yes" xml:space="preserve">
          <source>Completes a void &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">공허한 &lt;code&gt;future&lt;/code&gt; 완성합니다 .</target>
        </trans-unit>
        <trans-unit id="333a1a308de6c2c35e0d5e33f72d7cfe880dee44" translate="yes" xml:space="preserve">
          <source>Completes the report and closes the underlying stream.</source>
          <target state="translated">보고서를 작성하고 기본 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="7e686cfe94c3be5906c62711bb9280b6cd35fad5" translate="yes" xml:space="preserve">
          <source>Complex assignments</source>
          <target state="translated">복잡한 과제</target>
        </trans-unit>
        <trans-unit id="d61d954a7d29ef62d0d0f483f113da14d756f75b" translate="yes" xml:space="preserve">
          <source>Compute the duration between &lt;code&gt;dt1&lt;/code&gt; and &lt;code&gt;dt2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt1&lt;/code&gt; 과 &lt;code&gt;dt2&lt;/code&gt; 사이의 지속 시간을 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af3b0d9da2e0553db86df53b3bb62313863ad0f" translate="yes" xml:space="preserve">
          <source>Compute the hash for a JSON node</source>
          <target state="translated">JSON 노드의 해시 계산</target>
        </trans-unit>
        <trans-unit id="4ced60d2b9e85b7a9857baac040d6183d6108fbb" translate="yes" xml:space="preserve">
          <source>Compute the hash for a SEXP node</source>
          <target state="translated">SEXP 노드의 해시 계산</target>
        </trans-unit>
        <trans-unit id="af6cee62dd41244862a1beef8f748c9e0185561d" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;x&lt;/code&gt; to the power &lt;code&gt;y&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; must be non-negative, use &lt;a href=&quot;#pow,float,float&quot;&gt;pow&lt;/a&gt; for negative exponents.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 거듭 제곱 &lt;code&gt;y&lt;/code&gt; 로 계산합니다 . &lt;code&gt;x&lt;/code&gt; 는 음이 아니어야합니다 . 음의 지수 에는 &lt;a href=&quot;#pow,float,float&quot;&gt;pow&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94af11070cce950ccd5ff1c392eaed4a40509f7a" translate="yes" xml:space="preserve">
          <source>Computes a new mapping for the &lt;code&gt;key&lt;/code&gt; with the specified &lt;code&gt;mapper&lt;/code&gt; procedure.</source>
          <target state="translated">지정된 &lt;code&gt;mapper&lt;/code&gt; 프로 시저 를 사용하여 &lt;code&gt;key&lt;/code&gt; 대한 새 맵핑을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="6c04ba3c833d3f546fd08002af4268456d017142" translate="yes" xml:space="preserve">
          <source>Computes hash for rational &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">합리적인 &lt;em&gt;x에&lt;/em&gt; 대한 해시 계산&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c2f9ccd39cdba13c669ca2a0055b9b0a4909c0d" translate="yes" xml:space="preserve">
          <source>Computes the arc cosine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 아크 코사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf55e852b0dbff2433c783e81a929c4f0b4a9f33" translate="yes" xml:space="preserve">
          <source>Computes the arc sine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 아크 사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="507714367865db0ab4803b7a4b586e3ab661f4cc" translate="yes" xml:space="preserve">
          <source>Computes the binary logarithm (base 2) of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 이진 로그 (기본 2)를 계산합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30e6de74cfb2bc09fb9067c6b8d0d8b7713db1fd" translate="yes" xml:space="preserve">
          <source>Computes the binomial coefficient</source>
          <target state="translated">이항 계수를 계산합니다</target>
        </trans-unit>
        <trans-unit id="9e4192d8b442923fa8c8d5f73c494baf6af1074c" translate="yes" xml:space="preserve">
          <source>Computes the ceiling function (i.e., the smallest integer not less than &lt;em&gt;x&lt;/em&gt;)</source>
          <target state="translated">상한 함수를 계산합니다 (즉, &lt;em&gt;x&lt;/em&gt; 이상의 최소 정수 ).</target>
        </trans-unit>
        <trans-unit id="4a1a3e5645a57f45efdbc13dda288c84db32a663" translate="yes" xml:space="preserve">
          <source>Computes the common logarithm (base 10) of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; 상용 로그 (기본 10)를 계산합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3005e72782e4350360276425a67838d35dbb58b2" translate="yes" xml:space="preserve">
          <source>Computes the cosecant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 코시컨트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02903ae0e7537c44a816c0842613da27ba245ee8" translate="yes" xml:space="preserve">
          <source>Computes the cosine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 코사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dbae45c2e9244d49426ff36de71b26ded3fe218" translate="yes" xml:space="preserve">
          <source>Computes the cotangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 코탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53507c10559296a6e81c410382cb6292a109df9a" translate="yes" xml:space="preserve">
          <source>Computes the cubic root of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 세제곱근을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65027d320358c8301e120e8893408e68ef88ab79" translate="yes" xml:space="preserve">
          <source>Computes the duration between two points in time.</source>
          <target state="translated">두 시점 사이의 지속 시간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ba2ad1be3e6872259a4fa759c87da79b1b565e0e" translate="yes" xml:space="preserve">
          <source>Computes the exponential function of &lt;em&gt;x&lt;/em&gt; (pow(E, x))</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 지수 함수를 계산합니다 (pow (E, x))</target>
        </trans-unit>
        <trans-unit id="4a9df6b28f413c3fe5356f4e924dfa7e33b37cb5" translate="yes" xml:space="preserve">
          <source>Computes the faculty/factorial function.</source>
          <target state="translated">교직원 / 계승 기능을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b130f520330c20664bde7298dd85d42b5e113b68" translate="yes" xml:space="preserve">
          <source>Computes the floor function (i.e., the largest integer not greater than &lt;em&gt;x&lt;/em&gt;)</source>
          <target state="translated">바닥 함수를 계산합니다 (즉, &lt;em&gt;x&lt;/em&gt; 보다 크지 않은 가장 큰 정수)&lt;em&gt;&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="bad4aab9ce9b47e0f5345f1350e73e6b829622c3" translate="yes" xml:space="preserve">
          <source>Computes the greatest common (positive) divisor of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Note that for floats, the result cannot always be interpreted as &quot;greatest decimal &lt;em&gt;z&lt;/em&gt; such that &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; where N and M are positive integers.&quot;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 최대 공약수 (제수) 제수를 계산합니다 . 수레, 결과는 반드시 해석 될 수 없습니다 &quot;큰 소수 &lt;em&gt;Z&lt;/em&gt; 되도록 &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; N, m은 양의 정수이다 어디.&quot;</target>
        </trans-unit>
        <trans-unit id="c338a76288b47826a2962fc026cb84a8010c14b6" translate="yes" xml:space="preserve">
          <source>Computes the greatest common (positive) divisor of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Using binary GCD (aka Stein's) algorithm.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 최대 공약수 (제수) 제수를 계산합니다 . 바이너리 GCD (일명 Stein 's) 알고리즘 사용.</target>
        </trans-unit>
        <trans-unit id="b91a35b0b32492541a8286fccdde382e025d4e54" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic cosecant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡 코시컨트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="876a4baa4ad45e746aa3dbca4acca480383a7832" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic cosine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡 코사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1867f34a7cca1f42d2b954fe4bfe9c7fd0afbc2" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic cotangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡 코탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07fbe4b329fe39bcfcf082eeba32148cb0552e83" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic secant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡선을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bca28d196ea89d1b9d2bb42ec2d85060ceb01a8b" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic sine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡 사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be23d88f7012d83273037eb93a737e1d91d7ae52" translate="yes" xml:space="preserve">
          <source>Computes the hyperbolic tangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 쌍곡 탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75bc6e9251cf37f46a3b21810ace6fa11472ed58" translate="yes" xml:space="preserve">
          <source>Computes the hypotenuse of a right-angle triangle with &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; as its base and height. Equivalent to &lt;code&gt;sqrt(x*x + y*y)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 를 기준과 높이로 직각 삼각형의 빗변을 계산합니다 . 상당 &lt;code&gt;sqrt(x*x + y*y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea262da8445e7f9cb33fa3e7ef327367210f32ba" translate="yes" xml:space="preserve">
          <source>Computes the inverse cosecant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 코시컨트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4bf0a1516ae5481cc52796c8506c472cfa313407" translate="yes" xml:space="preserve">
          <source>Computes the inverse cotangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 코탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50138a0fbefac768659982567821be3716d61a6a" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic cosecant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 코시컨트를 계산합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9bd639135b5af144056273ae41390723b778b650" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic cosine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 코사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5f162a23dee6259c3039459bb14fa0d499cdd48" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic cotangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 코탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bab4662aee1247acb70654a6e7cec0327039a9c" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic secant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 항을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12e8b4582b0cdb788510f9b8097199f5dfc39849" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic sine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 사인을 계산합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a10c44d17cff2cd49ff4a6d7c6158dc672276f9d" translate="yes" xml:space="preserve">
          <source>Computes the inverse hyperbolic tangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 쌍곡 탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6078029e42d1ca15858897e83ce5ec110dbdbe35" translate="yes" xml:space="preserve">
          <source>Computes the inverse secant of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 역 분포를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcf0fe26f2cf39af52e4cbac9149522989a7ab9f" translate="yes" xml:space="preserve">
          <source>Computes the least common multiple of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 최소 ​​공배수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e2f9c0cb3f880f9487d363ce5febf1ea0928eafb" translate="yes" xml:space="preserve">
          <source>Computes the logarithm &lt;code&gt;base&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 로그 &lt;code&gt;base&lt;/code&gt; 을 계산합니다</target>
        </trans-unit>
        <trans-unit id="22c80bbfdebc08ef33ed05ece113561968eaebee" translate="yes" xml:space="preserve">
          <source>Computes the modulo operation for float operators.</source>
          <target state="translated">float 연산자의 모듈로 연산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ffa67e94d43ff96b188bdcaaf82d12d8bd455c73" translate="yes" xml:space="preserve">
          <source>Computes the natural log of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 자연 로그를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="02649b1419dc3947eaa1a1e41f9bef3fe6d7ec79" translate="yes" xml:space="preserve">
          <source>Computes the product of the elements in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, 1 is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 요소 곱을 계산합니다 . 경우 &lt;code&gt;x&lt;/code&gt; 는 비어, 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1214bf288d7366f0e7d0004d5fecfe778fa2a9b7" translate="yes" xml:space="preserve">
          <source>Computes the rational floor division.</source>
          <target state="translated">합리적인 층 나누기를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c9aac3aafefcc68f017ef8000633792b27059e3a" translate="yes" xml:space="preserve">
          <source>Computes the rational modulo by floor division (modulo).</source>
          <target state="translated">층별 나눗셈 (modulo)으로 합리적인 모듈로를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f9e8c053555af0b1cb26dacb1db8b21008bd8700" translate="yes" xml:space="preserve">
          <source>Computes the rational modulo by truncated division (remainder). This is same as &lt;code&gt;x - (x div y) * y&lt;/code&gt;.</source>
          <target state="translated">잘린 나눗셈 (나머지)으로 합리적인 모듈로를 계산합니다. 이것은 &lt;code&gt;x - (x div y) * y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76b3949e45b3e56c2a69076e28b08edd777c9794" translate="yes" xml:space="preserve">
          <source>Computes the rational truncated division.</source>
          <target state="translated">합리적인 절두 나누기를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="49107112a95894e6405ad9c1663b79a79a6d0b67" translate="yes" xml:space="preserve">
          <source>Computes the remainder of &lt;em&gt;x&lt;/em&gt; divided by &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 나머지를 &lt;em&gt;y&lt;/em&gt; 로 나눈 값을 계산합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dce606b04199cbd897cf780311535258a1144852" translate="yes" xml:space="preserve">
          <source>Computes the secant of &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 시컨트를 계산합니다&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1fa53a7e42079dc09998f78a715c437efd1e1c" translate="yes" xml:space="preserve">
          <source>Computes the sine of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 사인을 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daa74773ee1b0afd13d31e45f568e2573592c343" translate="yes" xml:space="preserve">
          <source>Computes the square root of &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; 제곱근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="723659a3460f2775205661fbd8e077e76996a132" translate="yes" xml:space="preserve">
          <source>Computes the sum of the elements in &lt;em&gt;x&lt;/em&gt;. If &lt;em&gt;x&lt;/em&gt; is empty, 0 is returned.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 요소 합계를 계산합니다 . 경우 &lt;em&gt;x는&lt;/em&gt; 비어, 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="86b01f7c104fbfa64a4d34cc7b872170f8d7bd63" translate="yes" xml:space="preserve">
          <source>Computes the tangent of &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 의 탄젠트를 계산합니다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69168e23351fbdf792fbf11e89eb3a45cb3df0c0" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y를&lt;/em&gt; 연결&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3c617381a09076a96cf4139313c0c2b44082253" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; in place</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 를 제자리에 연결</target>
        </trans-unit>
        <trans-unit id="bb8633f5a6193e7f44c0302215205095b0f2721c" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; into a string</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 를 문자열로 연결</target>
        </trans-unit>
        <trans-unit id="32997746130ec704518233619bdc747ed94f3f09" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;em&gt;x&lt;/em&gt; with &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 &lt;em&gt;y&lt;/em&gt; 와 연결&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57490e1af96ea8441649614f62e7ef1476e5794b" translate="yes" xml:space="preserve">
          <source>Concatenates all strings in &lt;em&gt;a&lt;/em&gt; separating them with &lt;em&gt;sep&lt;/em&gt;.</source>
          <target state="translated">모든 문자열을 연결 으로 구분 &lt;em&gt;년 9 월&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5736c670ec44584205028e1043d3e7354d3f193" translate="yes" xml:space="preserve">
          <source>Concatenates and quotes shell arguments &lt;em&gt;args&lt;/em&gt;</source>
          <target state="translated">연결하여 따옴표 인수 쉘 &lt;em&gt;인수를&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24de3ce1b7fcfc77ec8b592055d85477fab673e8" translate="yes" xml:space="preserve">
          <source>Concatenates the path specified to the specified URI's path.</source>
          <target state="translated">지정된 경로를 지정된 URI의 경로에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="6a80acf6035135e3322fc4365151ccd06c4456b5" translate="yes" xml:space="preserve">
          <source>Concatenates two sequences. Requires copying of the sequences.</source>
          <target state="translated">두 개의 시퀀스를 연결합니다. 시퀀스를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ce3519bb12e02fe1e27270b7b0e9d5822c98480" translate="yes" xml:space="preserve">
          <source>Concatenation operator for JavaScript strings</source>
          <target state="translated">JavaScript 문자열의 연결 연산자</target>
        </trans-unit>
        <trans-unit id="0b907fb1d7856e45b7c447d5c3e6ba10493bcd6f" translate="yes" xml:space="preserve">
          <source>Concept derived values</source>
          <target state="translated">개념 파생 값</target>
        </trans-unit>
        <trans-unit id="007618c827a49774da32acdf52c89eea51e2109d" translate="yes" xml:space="preserve">
          <source>Concept diagnostics</source>
          <target state="translated">개념 진단</target>
        </trans-unit>
        <trans-unit id="19252c25a8f8353d84a6ddf07415a7678bb689f8" translate="yes" xml:space="preserve">
          <source>Concept refinement</source>
          <target state="translated">컨셉 개선</target>
        </trans-unit>
        <trans-unit id="6f58d263f33944384921df8405fd4a36e06175e2" translate="yes" xml:space="preserve">
          <source>Concepts</source>
          <target state="translated">Concepts</target>
        </trans-unit>
        <trans-unit id="a6d1c38ed5d7542a3f74dd161f8ce14e29d3b36c" translate="yes" xml:space="preserve">
          <source>Concepts are written in the following form:</source>
          <target state="translated">개념은 다음 형식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="bead2e297ad337998c0913849946084ad8d27f87" translate="yes" xml:space="preserve">
          <source>Concepts, also known as &quot;user-defined type classes&quot;, are used to specify an arbitrary set of requirements that the matched type must satisfy.</source>
          <target state="translated">&quot;사용자 정의 형식 클래스&quot;라고도하는 개념은 일치하는 형식이 충족해야하는 임의의 요구 사항 집합을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19ca5bfd4010e53032fc796157670b7e2e65d5cf" translate="yes" xml:space="preserve">
          <source>Conceptually this is the AST we store for the module:</source>
          <target state="translated">개념적으로 이것은 모듈에 대해 저장 한 AST입니다.</target>
        </trans-unit>
        <trans-unit id="9587314138e773090e39a49cb842df3ce2ad3aba" translate="yes" xml:space="preserve">
          <source>Concrete syntax:</source>
          <target state="translated">구체적인 구문 :</target>
        </trans-unit>
        <trans-unit id="c743ed8f51d9fe3230cc0a6dda2caf2c9be6a227" translate="yes" xml:space="preserve">
          <source>CondTrue</source>
          <target state="translated">CondTrue</target>
        </trans-unit>
        <trans-unit id="0a3de9ebe5a09753cf625726cbf755c5c8a8909f" translate="yes" xml:space="preserve">
          <source>Conf</source>
          <target state="translated">Conf</target>
        </trans-unit>
        <trans-unit id="25b200c7bc8586a43869623132838a97561b78d7" translate="yes" xml:space="preserve">
          <source>ConfigDeprecated</source>
          <target state="translated">ConfigDeprecated</target>
        </trans-unit>
        <trans-unit id="5e9e2d64c5e127c299b896e015cd2b7bb4f8b5d4" translate="yes" xml:space="preserve">
          <source>Configuration files</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="c066aca97a5b1dc8e8948428318170412f9c8d81" translate="yes" xml:space="preserve">
          <source>Configures &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; to be unbuffered.</source>
          <target state="translated">를 구성은 &lt;em&gt;표준 입력 (stdin)&lt;/em&gt; , &lt;em&gt;표준 출력&lt;/em&gt; 및 &lt;em&gt;표준 오류를&lt;/em&gt; 버퍼링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f6da9b726d56ab5f4cb1674e7f64f2941921e74" translate="yes" xml:space="preserve">
          <source>Conjugate of complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="translated">복소수 &lt;em&gt;z의&lt;/em&gt; 결합입니다 .</target>
        </trans-unit>
        <trans-unit id="74a42d68c78d59242b71eaa6dc76d7ed3361c7c8" translate="yes" xml:space="preserve">
          <source>Connect to the FTP server specified by &lt;code&gt;ftp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 로 지정된 FTP 서버에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0c98804e10c954cf45314cd913154bd60fee512" translate="yes" xml:space="preserve">
          <source>Connecting to a server</source>
          <target state="translated">서버에 연결</target>
        </trans-unit>
        <trans-unit id="5015a874a361c8ebd9a43c59c6a05bc9e9fc1692" translate="yes" xml:space="preserve">
          <source>Connecting to an FTP server</source>
          <target state="translated">FTP 서버에 연결</target>
        </trans-unit>
        <trans-unit id="d53eb33aabd00f08db43585f95288c4641075b9c" translate="yes" xml:space="preserve">
          <source>Connection will be kept alive. Further requests on the same &lt;code&gt;client&lt;/code&gt; to the same hostname will not require a new connection to be made. The connection can be closed by using the &lt;code&gt;close&lt;/code&gt; procedure.</source>
          <target state="translated">연결이 유지됩니다. 동일한 &lt;code&gt;client&lt;/code&gt; 에서 동일한 호스트 이름 에 대한 추가 요청 은 새 연결을 요구하지 않습니다. &lt;code&gt;close&lt;/code&gt; 절차 를 사용하여 연결을 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="860ecaf055cc36f1f7821dc6e804fb24a575ec14" translate="yes" xml:space="preserve">
          <source>Connects &lt;code&gt;socket&lt;/code&gt; to server at &lt;code&gt;address:port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;address:port&lt;/code&gt; 의 &lt;code&gt;socket&lt;/code&gt; 을 서버에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="7d0384bee4253d60a61dff7ba8bbcf1d0825d752" translate="yes" xml:space="preserve">
          <source>Connects socket to &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt;. &lt;code&gt;Address&lt;/code&gt; can be an IP address or a host name. If &lt;code&gt;address&lt;/code&gt; is a host name, this function will try each IP of that host name. &lt;code&gt;htons&lt;/code&gt; is already performed on &lt;code&gt;port&lt;/code&gt; so you must not do it.</source>
          <target state="translated">소켓을 &lt;code&gt;address&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; 연결합니다 . &lt;code&gt;Address&lt;/code&gt; 는 IP 주소 또는 호스트 이름 일 수 있습니다. 경우 &lt;code&gt;address&lt;/code&gt; 호스트 이름이며,이 기능은 호스트 이름의 각 IP를 시도 할 것이다. &lt;code&gt;htons&lt;/code&gt; 은 이미 &lt;code&gt;port&lt;/code&gt; 수행 되므로 수행 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="387b916f30e0df4e1cf9521be5b0ca09775478bf" translate="yes" xml:space="preserve">
          <source>Connects to Unix socket on &lt;em&gt;path&lt;/em&gt;. This only works on Unix-style systems: Mac OS X, BSD and Linux</source>
          <target state="translated">&lt;em&gt;path의&lt;/em&gt; Unix 소켓에 연결합니다 . 이것은 유닉스 스타일 시스템에서만 작동합니다 : Mac OS X, BSD 및 Linux</target>
        </trans-unit>
        <trans-unit id="7fb8b6730ca3e99b7bc9ea840e9aec1306a35af0" translate="yes" xml:space="preserve">
          <source>Connects to server as specified by &lt;code&gt;address&lt;/code&gt; on port specified by &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">에 의해 지정된 서버에 연결 &lt;code&gt;address&lt;/code&gt; 포트에 의해 지정된 &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b36a62f20ad8f1205cbd235f147131f385b9639" translate="yes" xml:space="preserve">
          <source>Connects to the hostname specified by the URL and performs a GET request.</source>
          <target state="translated">URL로 지정된 호스트 이름에 연결하고 GET 요청을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ae5c28dec2176494058438db3eb2fa62edf045ef" translate="yes" xml:space="preserve">
          <source>Connects to the hostname specified by the URL and performs a POST request.</source>
          <target state="translated">URL로 지정된 호스트 이름에 연결하고 POST 요청을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fd2a9d55e7edd660c9a497d5e739b973c1d4db8f" translate="yes" xml:space="preserve">
          <source>Connects to the hostname specified by the URL and performs a request using the custom method string specified by &lt;code&gt;httpMethod&lt;/code&gt;.</source>
          <target state="translated">URL로 지정된 호스트 이름에 연결하고 &lt;code&gt;httpMethod&lt;/code&gt; 로 지정된 사용자 정의 메소드 문자열을 사용하여 요청을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="be93d2099ec1307f3bb75d6b60d399cc26121000" translate="yes" xml:space="preserve">
          <source>Connects to the hostname specified by the URL and performs a request using the method specified.</source>
          <target state="translated">URL로 지정된 호스트 이름에 연결하고 지정된 방법을 사용하여 요청을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bde6c6d13353142a51eaa643321e1cdea82fbe53" translate="yes" xml:space="preserve">
          <source>Connects to the specified &lt;em&gt;address&lt;/em&gt; on the specified &lt;em&gt;port&lt;/em&gt;. Returns the result of the certificate validation.</source>
          <target state="translated">지정된 &lt;em&gt;포트&lt;/em&gt; 의 지정된 &lt;em&gt;주소&lt;/em&gt; 에 연결합니다 . 인증서 유효성 검사 결과를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1744e691b487b5b7b13ffd10d2944fda6b288e55" translate="yes" xml:space="preserve">
          <source>Consecutive directory separators are collapsed, including an initial double slash.</source>
          <target state="translated">초기 이중 슬래시를 포함하여 연속적인 디렉토리 구분 기호가 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9817ec32f0986f22f75f11a52584945c89ab12" translate="yes" xml:space="preserve">
          <source>Consider stylized example of possible Object Relation Mapping (ORM) implementation:</source>
          <target state="translated">가능한 객체 관계 매핑 (ORM) 구현의 양식화 된 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b25e9811f03e4b93438d6bd4cbda02584da8908c" translate="yes" xml:space="preserve">
          <source>Const section</source>
          <target state="translated">콘 스트 섹션</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="845a0797c46f7f26627ffe10839f77d59e552b54" translate="yes" xml:space="preserve">
          <source>Constants are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time:</source>
          <target state="translated">상수는 값에 바인딩 된 기호입니다. 상수 값은 변경할 수 없습니다. 컴파일러는 컴파일 타임에 상수 선언에서 표현식을 평가할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7e0d5ea781b9c258a083b8a655e5d33254f964" translate="yes" xml:space="preserve">
          <source>Constants cannot be of type &lt;code&gt;ptr&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;, nor can they contain such a type.</source>
          <target state="translated">상수는 &lt;code&gt;ptr&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;var&lt;/code&gt; 유형일 수 없으며 그러한 유형을 포함 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="da54a7002c11cab53e8584c5a1f75e9944ef9eed" translate="yes" xml:space="preserve">
          <source>Construct a JsonNode that represents the specified enum value as a string. Creates a new &lt;code&gt;JString JsonNode&lt;/code&gt;.</source>
          <target state="translated">지정된 열거 값을 캐릭터 라인으로서 나타내는 JsonNode를 구축합니다. 새로운 &lt;code&gt;JString JsonNode&lt;/code&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="993d1122d6585d39bb0f853956e6b9969a9867c4" translate="yes" xml:space="preserve">
          <source>Construct a new time format for parsing &amp;amp; formatting time types.</source>
          <target state="translated">시간 유형 구문 분석 및 형식화를위한 새로운 시간 형식을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8e3ac0f291f854a218bb7b6224446d033abdb4da" translate="yes" xml:space="preserve">
          <source>Constructing the AST directly with proc calls. This method does not support constructing rules, only simple expressions and is not as convenient. Its only advantage is that it does not pull in the whole PEG parser into your executable.</source>
          <target state="translated">proc 호출로 직접 AST 구성 이 방법은 규칙 구성을 지원하지 않고 단순한 표현식 만 지원하며 편리하지 않습니다. 유일한 이점은 전체 PEG 파서를 실행 파일로 가져 오지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78302751c725b4c26b8aede6760f2c2729c6bd43" translate="yes" xml:space="preserve">
          <source>Constructive mathematics is naturally typed. -- Simon Thompson</source>
          <target state="translated">건설 수학은 자연스럽게 입력됩니다. -사이먼 톰슨</target>
        </trans-unit>
        <trans-unit id="4f454784bbe295c080a86588cdce55c691d5ae55" translate="yes" xml:space="preserve">
          <source>Constructor for &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문의 생성자</target>
        </trans-unit>
        <trans-unit id="062b02bd6a0b90bb0f511b0f03cfc573a5e18204" translate="yes" xml:space="preserve">
          <source>Constructor for extended regular expressions.</source>
          <target state="translated">확장 정규 표현식의 생성자.</target>
        </trans-unit>
        <trans-unit id="140e5ae2bcf9f25834222fd8ce1b872589964edc" translate="yes" xml:space="preserve">
          <source>Constructor macro for XML. Example usage:</source>
          <target state="translated">XML의 생성자 매크로 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="aa36f56205949f481b7537602145f7b72d37d588" translate="yes" xml:space="preserve">
          <source>Constructor of regular expressions.</source>
          <target state="translated">정규 표현식의 생성자.</target>
        </trans-unit>
        <trans-unit id="42b9ee9a1b2575edcbe0c928850aa10ec986744c" translate="yes" xml:space="preserve">
          <source>Constructs a new &lt;code&gt;MultipartData&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;MultipartData&lt;/code&gt; 객체를 구축 합니다.</target>
        </trans-unit>
        <trans-unit id="9c4c23da832bf816388baf9def9c41eec8b28590" translate="yes" xml:space="preserve">
          <source>Constructs a new &lt;code&gt;TProxy&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;TProxy&lt;/code&gt; 객체를 구축 합니다.</target>
        </trans-unit>
        <trans-unit id="af58575746c3a32456d9c37adfb71f0c9df2779a" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;em&gt;and&lt;/em&gt; meta class</source>
          <target state="translated">구축 &lt;em&gt;및&lt;/em&gt; 메타 클래스를</target>
        </trans-unit>
        <trans-unit id="732af8deac3342b336d166fbfe0227ae58cbf577" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;em&gt;not&lt;/em&gt; meta class</source>
          <target state="translated">메타 클래스 가 &lt;em&gt;아님&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f557f4a3151c4696ede6f82dcb91dd5dc71ce04" translate="yes" xml:space="preserve">
          <source>Constructs an &lt;em&gt;or&lt;/em&gt; meta class</source>
          <target state="translated">구축 &lt;em&gt;또는&lt;/em&gt; 메타 클래스를</target>
        </trans-unit>
        <trans-unit id="87ae5014545d1989ad429432fe3fd06348d10cc6" translate="yes" xml:space="preserve">
          <source>Consts</source>
          <target state="translated">Consts</target>
        </trans-unit>
        <trans-unit id="675f91de4abaa0e659cc758096cc8fde4deb7fc9" translate="yes" xml:space="preserve">
          <source>Contains functionality shared between the &lt;code&gt;httpclient&lt;/code&gt; and &lt;code&gt;asynchttpserver&lt;/code&gt; modules.</source>
          <target state="translated">&lt;code&gt;httpclient&lt;/code&gt; 와 &lt;code&gt;asynchttpserver&lt;/code&gt; 모듈 간에 공유되는 기능이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e93b75b8202c61172b7292deeb552aba64e6d3a" translate="yes" xml:space="preserve">
          <source>Contains information associated with a file object.</source>
          <target state="translated">파일 객체와 관련된 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3d7c5a052a4c654935405b7c129909a0754ebdd0" translate="yes" xml:space="preserve">
          <source>Continue statement</source>
          <target state="translated">계속 진술</target>
        </trans-unit>
        <trans-unit id="598143c2cf06ef03b671a0fdf6b2792917d41b74" translate="yes" xml:space="preserve">
          <source>Contrary to the &lt;code&gt;combine&lt;/code&gt; procedure you do not have to worry about the slashes at the beginning and end of the path and URI's path respectively.</source>
          <target state="translated">&lt;code&gt;combine&lt;/code&gt; 절차 와 달리 경로와 URI 경로의 시작과 끝에서 슬래시에 대해 각각 걱정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf54fab626834a6b88d0646d64263ba703df0fbb" translate="yes" xml:space="preserve">
          <source>Control flow statements</source>
          <target state="translated">제어 흐름 설명</target>
        </trans-unit>
        <trans-unit id="5354c2d75e39532abe50b6d8107e92c05eaa8c23" translate="yes" xml:space="preserve">
          <source>Control flow statements have a feature not covered yet: they open a new scope. This means that in the following example, &lt;code&gt;x&lt;/code&gt; is not accessible outside the loop:</source>
          <target state="translated">제어 흐름 설명에는 아직 다루지 않은 기능이 있습니다. 새로운 범위를 엽니 다. 이것은 다음 예제에서 &lt;code&gt;x&lt;/code&gt; 가 루프 외부에서 액세스 할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="17936062c7215d6eae4ebb04a6e3ca95ab879398" translate="yes" xml:space="preserve">
          <source>ConvFromXtoItselfNotNeeded</source>
          <target state="translated">ConvFromXtoItselfNotNeeded</target>
        </trans-unit>
        <trans-unit id="b0ffb806c1564fb77217e33d4acfe37c022f1860" translate="yes" xml:space="preserve">
          <source>ConvToBaseNotNeeded</source>
          <target state="translated">ConvToBaseNotNeeded</target>
        </trans-unit>
        <trans-unit id="18839f7ff9b089bb8450bd9f381df874a58d3fc5" translate="yes" xml:space="preserve">
          <source>Convenience proc which returns the command line parameters.</source>
          <target state="translated">명령 행 매개 변수를 리턴하는 편의 proc.</target>
        </trans-unit>
        <trans-unit id="25faeec30b9e7e871df8e2b4943f4f256afa83f9" translate="yes" xml:space="preserve">
          <source>Convenience template around the &lt;code&gt;keepIf&lt;/code&gt; proc to reduce typing.</source>
          <target state="translated">&lt;code&gt;keepIf&lt;/code&gt; 프로 시저 주위의 편의 템플릿은 입력을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d9dfac3ba207eed8bbe4edac3196966f97c7acbb" translate="yes" xml:space="preserve">
          <source>Convenience template around the &lt;code&gt;map&lt;/code&gt; proc to reduce typing.</source>
          <target state="translated">타이핑을 줄이기 위해 &lt;code&gt;map&lt;/code&gt; 프로세스 주변의 편의 템플릿 .</target>
        </trans-unit>
        <trans-unit id="061e3b113201cf22cd61e5dd0fbf1a0b76c6e60d" translate="yes" xml:space="preserve">
          <source>Convenience template around the &lt;code&gt;sorted&lt;/code&gt; proc to reduce typing.</source>
          <target state="translated">&lt;code&gt;sorted&lt;/code&gt; proc 주변의 편의 템플릿 을 사용하여 입력을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3c7236137b33372fd4f4077bc4f2516868b7185c" translate="yes" xml:space="preserve">
          <source>Convenience template around the mutable &lt;code&gt;apply&lt;/code&gt; proc to reduce typing.</source>
          <target state="translated">변경 가능한 &lt;code&gt;apply&lt;/code&gt; 프로 시저 주변의 편의 템플릿은 입력을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b5fe60ed937e9cf18b8da54d7ef267e681ef53ce" translate="yes" xml:space="preserve">
          <source>Conventions for multi-line statements and expressions</source>
          <target state="translated">여러 줄 문장과 표현에 대한 규칙</target>
        </trans-unit>
        <trans-unit id="81070514fb20efd82762d697a06192f5e5f09a77" translate="yes" xml:space="preserve">
          <source>Conversion between numerical types is performed by using the type as a function:</source>
          <target state="translated">숫자 유형 간 변환은 유형을 함수로 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="95137103326cf95d4d730adb027b0fc2ce460ea2" translate="yes" xml:space="preserve">
          <source>Conversion match: &lt;code&gt;a&lt;/code&gt; is convertible to &lt;code&gt;f&lt;/code&gt;, possibly via a user defined &lt;code&gt;converter&lt;/code&gt;.</source>
          <target state="translated">변환 일치 : &lt;code&gt;a&lt;/code&gt; 는 가능하면 사용자 정의 &lt;code&gt;converter&lt;/code&gt; 를 통해 &lt;code&gt;f&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edfedd4d8d22c53dc59ad0bd047093615bb8b306" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;t&lt;/code&gt; to a Windows file time (100-nanosecond intervals since &lt;code&gt;1601-01-01T00:00:00Z&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 를 Windows 파일 시간으로 변환하십시오 ( &lt;code&gt;1601-01-01T00:00:00Z&lt;/code&gt; 이후 100 나노초 간격 ).</target>
        </trans-unit>
        <trans-unit id="7e1779ebc3fb6ed3b2b675004fc280428cefaea2" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;t&lt;/code&gt; to a unix timestamp (seconds since &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt;).</source>
          <target state="translated">변환 &lt;code&gt;t&lt;/code&gt; 을 (이후 초 유닉스 타임 스탬프 &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; 를 ).</target>
        </trans-unit>
        <trans-unit id="2e0b4ea1ef1e20b85ac7d7f5de56ba692cfc1390" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;time&lt;/code&gt; into a &lt;code&gt;DateTime&lt;/code&gt; using &lt;code&gt;zone&lt;/code&gt; as the timezone.</source>
          <target state="translated">시간대 를 &lt;code&gt;zone&lt;/code&gt; 로 사용하여 &lt;code&gt;time&lt;/code&gt; 을 &lt;code&gt;DateTime&lt;/code&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="5f878a4752429ea738d1292646bf8d5e38096ed2" translate="yes" xml:space="preserve">
          <source>Convert a Windows file time (100-nanosecond intervals since &lt;code&gt;1601-01-01T00:00:00Z&lt;/code&gt;) to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Windows 파일 시간 ( &lt;code&gt;1601-01-01T00:00:00Z&lt;/code&gt; 이후 100 나노초 간격 )을 &lt;code&gt;Time&lt;/code&gt; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="015f4435cfb9631b8f884d9dc9766f8a2d2e498f" translate="yes" xml:space="preserve">
          <source>Convert a quantity of some duration unit to another duration unit.</source>
          <target state="translated">일부 지속 시간 단위의 수량을 다른 지속 시간 단위로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="5f5ca34112b308b928b17703848baf0a1eea255b" translate="yes" xml:space="preserve">
          <source>Convert a rational number &lt;em&gt;x&lt;/em&gt; to a float.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 를 float로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="550d596743cff3cc098ebb95a88d1df4e98623e5" translate="yes" xml:space="preserve">
          <source>Convert a rational number &lt;em&gt;x&lt;/em&gt; to an int. Conversion rounds towards 0 if &lt;em&gt;x&lt;/em&gt; does not contain an integer value.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 를 정수로 변환합니다 . &lt;em&gt;x&lt;/em&gt; 에 정수 값이 없으면 변환은 0으로 반올림 합니다.</target>
        </trans-unit>
        <trans-unit id="9af4a72ac37a88ee2780cbfc843f29eeb34e32a0" translate="yes" xml:space="preserve">
          <source>Convert a unix timestamp (seconds since &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt;) to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">유닉스 타임 스탬프 ( &lt;code&gt;1970-01-01T00:00:00Z&lt;/code&gt; 이후의 초 )를 &lt;code&gt;Time&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="08e95a2a4f83a1be35a630b5230f6179ce54d400" translate="yes" xml:space="preserve">
          <source>Convert an expression to a JsonNode directly, without having to specify &lt;em&gt;%&lt;/em&gt; for every element.</source>
          <target state="translated">모든 요소에 &lt;em&gt;%&lt;/em&gt; 를 지정할 필요없이 표현식을 JsonNode로 직접 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6725ffc3be75a1101ebf8d1858da9f2cb5f61f5" translate="yes" xml:space="preserve">
          <source>Convert an expression to a SexpNode directly, without having to specify &lt;em&gt;%&lt;/em&gt; for every element.</source>
          <target state="translated">모든 요소에 대해 &lt;em&gt;%&lt;/em&gt; 를 지정하지 않고 표현식을 SexpNode로 직접 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="deaadce9f5527ca719acc921a68c010c9ab04e06" translate="yes" xml:space="preserve">
          <source>Convert from degrees to radians</source>
          <target state="translated">도에서 라디안으로 변환</target>
        </trans-unit>
        <trans-unit id="d9f815d0223347240aa67fb63c474893cdc26cb2" translate="yes" xml:space="preserve">
          <source>Convert from radians to degrees</source>
          <target state="translated">라디안에서도 단위로 변환</target>
        </trans-unit>
        <trans-unit id="087644e53ad0b243e2a187d1c148b6b7c36bf553" translate="yes" xml:space="preserve">
          <source>Convert hex-encoded string to byte string, e.g.:</source>
          <target state="translated">16 진 인코딩 문자열을 바이트 문자열로 변환하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="02028585cbfe237a1827e46ad6ac7fbcbac3e933" translate="yes" xml:space="preserve">
          <source>Convert some integer &lt;code&gt;x&lt;/code&gt; to a complex number.</source>
          <target state="translated">정수 &lt;code&gt;x&lt;/code&gt; 를 복소수로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0a37d3dc8cf5bbed8dfe9e2cfa92a773632aca2" translate="yes" xml:space="preserve">
          <source>Convert some integer &lt;em&gt;x&lt;/em&gt; to a rational number.</source>
          <target state="translated">정수 &lt;em&gt;x&lt;/em&gt; 를 유리수로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="1400752ded339e0b84004cc4660bc5991da8797f" translate="yes" xml:space="preserve">
          <source>Convert the AST &lt;em&gt;n&lt;/em&gt; to a human-readable lisp-like string,</source>
          <target state="translated">AST &lt;em&gt;n&lt;/em&gt; 을 사람이 읽을 수있는 lisp와 유사한 문자열로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c1f537e28f3fea6c32729c1411231812fbcd9f4" translate="yes" xml:space="preserve">
          <source>Convert the AST &lt;em&gt;n&lt;/em&gt; to a human-readable tree-like string.</source>
          <target state="translated">AST &lt;em&gt;n&lt;/em&gt; 을 사람이 읽을 수있는 트리 형 문자열로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="565148a92c0fe349637395b81e6d35c72aef2a67" translate="yes" xml:space="preserve">
          <source>Convert the AST &lt;em&gt;n&lt;/em&gt; to the code required to generate that AST. So for example</source>
          <target state="translated">AST &lt;em&gt;n&lt;/em&gt; 을 해당 AST를 생성하는 데 필요한 코드로 변환하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="dd60d8e1b3dc3e84b6ad33107ccae0f4a0a5b1ad" translate="yes" xml:space="preserve">
          <source>Convert the Windows file time timestamp &lt;code&gt;t&lt;/code&gt; to &lt;code&gt;FILETIME&lt;/code&gt;.</source>
          <target state="translated">Windows 파일 시간 시간 소인 &lt;code&gt;t&lt;/code&gt; 를 &lt;code&gt;FILETIME&lt;/code&gt; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="035adc3c464a0402d6eb1110d19a062484e3cd84" translate="yes" xml:space="preserve">
          <source>Converter declaration</source>
          <target state="translated">변환기 선언</target>
        </trans-unit>
        <trans-unit id="6a89fde6d6a92b19247264815bcda3f0b2c24bd4" translate="yes" xml:space="preserve">
          <source>Converters</source>
          <target state="translated">Converters</target>
        </trans-unit>
        <trans-unit id="aa41bdcfed5c5360fe474f3e6e3765683fa1e63a" translate="yes" xml:space="preserve">
          <source>Convertible relation</source>
          <target state="translated">컨버터블 관계</target>
        </trans-unit>
        <trans-unit id="f13c6007f9a31fb218a6e9856d5bd0eabae594d1" translate="yes" xml:space="preserve">
          <source>Converts 16-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation. &lt;strong&gt;Warning&lt;/strong&gt;: This template is deprecated since 0.14.0, where port numbers became unsigned integers. Please use the unsigned version of this template.</source>
          <target state="translated">호스트에서 네트워크 바이트 순서로 16 비트 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다. &lt;strong&gt;경고&lt;/strong&gt; :이 템플릿은 포트 번호가 부호없는 정수가 된 0.14.0부터 더 이상 사용되지 않습니다. 이 템플릿의 서명되지 않은 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="112970288de99fcc4ef0869ce910dea86e504b1c" translate="yes" xml:space="preserve">
          <source>Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</source>
          <target state="translated">네트워크에서 호스트 바이트 순서로 16 비트 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ce75842f40e151559b568e6573c54eac78d72857" translate="yes" xml:space="preserve">
          <source>Converts 16-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation. &lt;strong&gt;Warning&lt;/strong&gt;: This template is deprecated since 0.14.0, where port numbers became unsigned integers. Please use the unsigned version of this template.</source>
          <target state="translated">네트워크에서 호스트 바이트 순서로 16 비트 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다. &lt;strong&gt;경고&lt;/strong&gt; :이 템플릿은 포트 번호가 부호없는 정수가 된 0.14.0부터 더 이상 사용되지 않습니다. 이 템플릿의 서명되지 않은 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3170b9f7c82d391839fc8e073cccdacf59335d62" translate="yes" xml:space="preserve">
          <source>Converts 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</source>
          <target state="translated">호스트에서 네트워크 바이트 순서로 16 비트 양의 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b0a13ae85937fdadd1005cf5909ae143deb8de8a" translate="yes" xml:space="preserve">
          <source>Converts 16-bit unsigned integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</source>
          <target state="translated">16 비트 부호없는 정수를 호스트에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ff243cc395b86a8cec44acfb9033fce9d63637ce" translate="yes" xml:space="preserve">
          <source>Converts 16-bit unsigned integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</source>
          <target state="translated">16 비트 부호없는 정수를 네트워크에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 2 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f4f64c087c3e1ad11ea7a90ed48e6faf7ae5b17f" translate="yes" xml:space="preserve">
          <source>Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</source>
          <target state="translated">호스트에서 네트워크 바이트 순서로 32 비트 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e0ceaca88a0be29f81497e1e7b81bb7a382142b4" translate="yes" xml:space="preserve">
          <source>Converts 32-bit integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation. &lt;strong&gt;Warning&lt;/strong&gt;: This template is deprecated since 0.14.0, IPv4 addresses are now treated as unsigned integers. Please use the unsigned version of this template.</source>
          <target state="translated">호스트에서 네트워크 바이트 순서로 32 비트 정수를 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다. &lt;strong&gt;경고&lt;/strong&gt; :이 템플릿은 0.14.0부터 사용되지 않으며 IPv4 주소는 이제 부호없는 정수로 취급됩니다. 이 템플릿의 서명되지 않은 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8afa0be74a654bec084128b6af93faeeb0933d3" translate="yes" xml:space="preserve">
          <source>Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</source>
          <target state="translated">32 비트 정수를 네트워크에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="04a2bcac233b58526f24cd9cdf297210fe25d5c3" translate="yes" xml:space="preserve">
          <source>Converts 32-bit integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation. &lt;strong&gt;Warning&lt;/strong&gt;: This template is deprecated since 0.14.0, IPv4 addresses are now treated as unsigned integers. Please use the unsigned version of this template.</source>
          <target state="translated">32 비트 정수를 네트워크에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다. &lt;strong&gt;경고&lt;/strong&gt; :이 템플릿은 0.14.0부터 사용되지 않으며 IPv4 주소는 이제 부호없는 정수로 취급됩니다. 이 템플릿의 서명되지 않은 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="697f3586b4c3e2ecd768e863113dc3f5e415ac83" translate="yes" xml:space="preserve">
          <source>Converts 32-bit unsigned integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</source>
          <target state="translated">32 비트 부호없는 정수를 호스트에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4085a37c7adaa9303fbad22d9259fe86c7a53cdb" translate="yes" xml:space="preserve">
          <source>Converts 32-bit unsigned integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</source>
          <target state="translated">32 비트 부호없는 정수를 네트워크에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 동일한 시스템에서는 이것이 작동하지 않습니다. 그렇지 않으면 4 바이트 스왑 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a0fd062c5d223b6adbdaeec5097887d5fdf9d113" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;c&lt;/code&gt; into lower case. This works for any Unicode character. If possible, prefer &lt;code&gt;toLower&lt;/code&gt; over &lt;code&gt;toUpper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 를 소문자로 변환합니다 . 이것은 모든 유니 코드 문자에 적용됩니다. 가능하면 선호하는 &lt;code&gt;toLower&lt;/code&gt; 통해 &lt;code&gt;toUpper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baee2b4fec316a5e504a92174f415f90f55d984b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;c&lt;/code&gt; into upper case. This works for any Unicode character. If possible, prefer &lt;code&gt;toLower&lt;/code&gt; over &lt;code&gt;toUpper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 를 대문자로 변환합니다 . 이것은 모든 유니 코드 문자에 적용됩니다. 가능하면 선호하는 &lt;code&gt;toLower&lt;/code&gt; 통해 &lt;code&gt;toUpper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be1e3629dab565005581db83380e6ff5ca311308" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;c&lt;/code&gt; to title case</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 를 제목 대소 문자로 변환</target>
        </trans-unit>
        <trans-unit id="2d3e032ae7eeaf93db44832c7880be4bc982c849" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;IpAddress&lt;/em&gt; and &lt;em&gt;Port&lt;/em&gt; to &lt;em&gt;SockAddr&lt;/em&gt; and &lt;em&gt;Socklen&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IpAddress&lt;/em&gt; 및 &lt;em&gt;포트&lt;/em&gt; 를 &lt;em&gt;SockAddr&lt;/em&gt; 및 &lt;em&gt;Socklen으로&lt;/em&gt; 변환&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4970977db5e63bbeee8ad9440616e31263fb4987" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;SockAddr&lt;/em&gt; and &lt;em&gt;Socklen&lt;/em&gt; to &lt;em&gt;IpAddress&lt;/em&gt; and &lt;em&gt;Port&lt;/em&gt;. Raises &lt;em&gt;ObjectConversionError&lt;/em&gt; in case of invalid &lt;em&gt;sa&lt;/em&gt; and &lt;em&gt;sl&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;em&gt;SockAddr&lt;/em&gt; 및 &lt;em&gt;Socklen&lt;/em&gt; 을 &lt;em&gt;IpAddress&lt;/em&gt; 및 &lt;em&gt;Port&lt;/em&gt; 로 변환합니다 . 발생시킵니다 &lt;em&gt;ObjectConversionError를&lt;/em&gt; 유효하지 않은 경우 &lt;em&gt;SA&lt;/em&gt; 와 &lt;em&gt;SL&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="132b954edc540ee9c1993d9dc186bd73348a4f45" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;c&lt;/em&gt; into lower case.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 를 소문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="3af2ee2a4ed1cc1d608d72c8c3ae4cea0695fe8c" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;c&lt;/em&gt; into upper case.</source>
          <target state="translated">&lt;em&gt;c&lt;/em&gt; 를 대문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="bca8141d56a4e25b8dd82d4de6ea898aa22dc018" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;node&lt;/em&gt; to its JSON Representation on one line.</source>
          <target state="translated">한 줄에서 &lt;em&gt;노드&lt;/em&gt; 를 JSON 표현으로 변환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1d985f45cce074cc6a26e7ba7af5cd406702d977" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;node&lt;/em&gt; to its JSON Representation, without regard for human readability. Meant to improve &lt;code&gt;$&lt;/code&gt; string conversion performance.</source>
          <target state="translated">사람의 가독성을 고려하지 않고 &lt;em&gt;노드&lt;/em&gt; 를 JSON 표현으로 변환 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;$&lt;/code&gt; 문자열 변환 성능 을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="923945d0338dd3a1a6e58bd0654ba3de80ba4bc6" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;node&lt;/em&gt; to its SEXP Representation on one line.</source>
          <target state="translated">한 줄에서 &lt;em&gt;노드&lt;/em&gt; 를 SEXP 표현으로 변환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a792422dd2486386982477d31b67a244da8230f2" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;node&lt;/em&gt; to its Sexp Representation, with indentation and on multiple lines.</source>
          <target state="translated">들여 쓰기와 여러 줄로 &lt;em&gt;노드&lt;/em&gt; 를 Sexp Representation으로 변환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="70897bd4d5c4caeee681cc289ef5651d4f55aee0" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; into lower case.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 소문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d31d348b9930174bb237699f1a5b65399cfcb02d" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; into lower-case unicode characters.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 소문자 유니 코드 문자로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="7c5c9b5c90c23f06d6a46c0113bc7d33fbc5e9b7" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; into upper case.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 대문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="3209fb6ea3be4a22e43b5b34ae338513cccf88b7" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; into upper-case unicode characters.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 대문자 유니 코드 문자로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="3b61bf3e758d2db20f90fb1782a0f4257fbd0a46" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; to a &lt;code&gt;HtmlTag&lt;/code&gt;. If &lt;em&gt;s&lt;/em&gt; is no HTML tag, &lt;code&gt;tagUnknown&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 &lt;code&gt;HtmlTag&lt;/code&gt; 로 변환합니다 . 경우 &lt;em&gt;들&lt;/em&gt; 에는 HTML 태그입니다, &lt;code&gt;tagUnknown&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e2ec3121dd6a68244ebb47e387a583cfd501bb4" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;s&lt;/em&gt; to a unicode title.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 를 유니 코드 제목으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e07ee6c014358eadf4dbfba4c269ef31497207c4" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;x&lt;/em&gt; into its binary representation.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 이진 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab472f8bd5ae22e48a39bbe5fb7e540462161b5b" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;x&lt;/em&gt; into its octal representation.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 8 진수로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="ffdd068e1e5efa11728a7316dd8ef9efca871fc8" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;x&lt;/em&gt; to its decimal representation.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 10 진수 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d563f3144c7da67380912ebc6bcc289364c1773" translate="yes" xml:space="preserve">
          <source>Converts &lt;em&gt;x&lt;/em&gt; to its hexadecimal representation.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 16 진수 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="86db6dda92699e287cb31688f0225e8242cebac9" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;SOBool&lt;/code&gt; into its Socket Option cint representation.</source>
          <target state="translated">&lt;code&gt;SOBool&lt;/code&gt; 을 소켓 옵션 cint 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="cae1368ca9d5aab3254d562edf2c2d1277961752" translate="yes" xml:space="preserve">
          <source>Converts a &lt;em&gt;DateTime&lt;/em&gt; object to a string representation. It uses the format &lt;code&gt;yyyy-MM-dd'T'HH-mm-sszzz&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;DateTime&lt;/em&gt; 객체를 문자열 표현으로 변환합니다 . &lt;code&gt;yyyy-MM-dd'T'HH-mm-sszzz&lt;/code&gt; 형식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ef8ba3acf6bc618ca7755af8da66d033762e1026" translate="yes" xml:space="preserve">
          <source>Converts a &lt;em&gt;TimeInterval&lt;/em&gt; into an array consisting of its time units, starting with nanoseconds and ending with years</source>
          <target state="translated">&lt;em&gt;TimeInterval&lt;/em&gt; 을 나노초로 시작하고 연도로 끝나는 시간 단위로 구성된 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="481782a78d6c6a6f5912ee18b38849de114c2541" translate="yes" xml:space="preserve">
          <source>Converts a JsObject &lt;em&gt;x&lt;/em&gt; to type &lt;em&gt;T&lt;/em&gt;.</source>
          <target state="translated">JsObject &lt;em&gt;x&lt;/em&gt; 를 유형 &lt;em&gt;T로&lt;/em&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="029d72c09a90bcd7724cb048b8ac57981e038fd1" translate="yes" xml:space="preserve">
          <source>Converts a PDocument object into a string representation of it's XML</source>
          <target state="translated">PDocument 객체를 XML의 문자열 표현으로 변환</target>
        </trans-unit>
        <trans-unit id="b207e6466ce9409cf23b2e695cecd05a1a641f8f" translate="yes" xml:space="preserve">
          <source>Converts a Rune to a string</source>
          <target state="translated">룬을 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="06687e8646c98fd466b6593adc7633e07d3802b5" translate="yes" xml:space="preserve">
          <source>Converts a Time to a TimeInterval.</source>
          <target state="translated">시간을 TimeInterval로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="33c4af7b4093b872dfa99666650b90a1599e8951" translate="yes" xml:space="preserve">
          <source>Converts a UNIX &lt;em&gt;Time&lt;/em&gt; (&lt;code&gt;time_t&lt;/code&gt;) to a Windows file time</source>
          <target state="translated">UNIX &lt;em&gt;시간&lt;/em&gt; ( &lt;code&gt;time_t&lt;/code&gt; )을 Windows 파일 시간으로 변환</target>
        </trans-unit>
        <trans-unit id="fb4253b3fec47cce9ac2ef0b00d04c0683adcde6" translate="yes" xml:space="preserve">
          <source>Converts a Windows time to a UNIX &lt;em&gt;Time&lt;/em&gt; (&lt;code&gt;time_t&lt;/code&gt;)</source>
          <target state="translated">Windows 시간을 UNIX &lt;em&gt;시간&lt;/em&gt; ( &lt;code&gt;time_t&lt;/code&gt; )으로 변환</target>
        </trans-unit>
        <trans-unit id="350872a14db782f8ade20bff003b8c94bef1fb6b" translate="yes" xml:space="preserve">
          <source>Converts a broken-down time structure to calendar time representation.</source>
          <target state="translated">분류 시간 구조를 달력 시간 표시로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e3bbf98d6403034e03a544285bf03fa7955725f0" translate="yes" xml:space="preserve">
          <source>Converts a bytes string to its hexadecimal representation.</source>
          <target state="translated">바이트 문자열을 16 진수 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="85026d6926a4e7a672dcc8b8d7ac51a3b00a2c0f" translate="yes" xml:space="preserve">
          <source>Converts a character &lt;em&gt;c&lt;/em&gt; to its octal representation.</source>
          <target state="translated">문자 &lt;em&gt;c&lt;/em&gt; 를 8 진수 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e9408fa8c3a5a9ba3d6818c0b6c2f27e9f2690c2" translate="yes" xml:space="preserve">
          <source>Converts a duration into an array consisting of fixed time units.</source>
          <target state="translated">지속 시간을 고정 시간 단위로 구성된 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8109d0ec0ec971268bd4881af86d9494871caed9" translate="yes" xml:space="preserve">
          <source>Converts a float to a rope.</source>
          <target state="translated">플로트를 로프로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="896a32553e9a5f9757c4f2288d68cb72828738da" translate="yes" xml:space="preserve">
          <source>Converts a floating point value &lt;em&gt;f&lt;/em&gt; to a string using engineering notation.</source>
          <target state="translated">공학 표기법을 사용하여 부동 소수점 값 &lt;em&gt;f&lt;/em&gt; 를 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="fb161a2e089df85f212ce9fefaf9c1474cc935eb" translate="yes" xml:space="preserve">
          <source>Converts a floating point value &lt;em&gt;f&lt;/em&gt; to a string.</source>
          <target state="translated">부동 소수점 값 &lt;em&gt;f&lt;/em&gt; 를 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="e5115f681c42a2856e5beb235a2f163c3ae48ea1" translate="yes" xml:space="preserve">
          <source>Converts a rune into its UTF-8 representation</source>
          <target state="translated">룬을 UTF-8 표현으로 변환</target>
        </trans-unit>
        <trans-unit id="cac73a3c487c89173ad6ca2e4fe0a15207567929" translate="yes" xml:space="preserve">
          <source>Converts a sequence of Runes to a string</source>
          <target state="translated">일련의 룬을 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="3607b84941cf64f7a5e7eeb9a31345adf57c9dcb" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;em&gt;s&lt;/em&gt; to its JSON representation with quotes.</source>
          <target state="translated">변환 된 문자열 &lt;em&gt;이야&lt;/em&gt; 따옴표와의 JSON 표현으로.</target>
        </trans-unit>
        <trans-unit id="803d8bfb91eb518feb79e584c203b8c3e39b0c0d" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;em&gt;s&lt;/em&gt; to its JSON representation with quotes. Appends to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">변환 된 문자열 &lt;em&gt;이야&lt;/em&gt; 따옴표와의 JSON 표현으로. &lt;code&gt;result&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ae0b67d3e7042ebdf584c0562fe26565654e8496" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;em&gt;s&lt;/em&gt; to its JSON representation without quotes.</source>
          <target state="translated">변환 된 문자열 &lt;em&gt;이야&lt;/em&gt; 따옴표없이 JSON 표현으로.</target>
        </trans-unit>
        <trans-unit id="816b661910c73aef452ccae49353c83110e9b0f7" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;em&gt;s&lt;/em&gt; to its JSON representation without quotes. Appends to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">변환 된 문자열 &lt;em&gt;이야&lt;/em&gt; 따옴표없이 JSON 표현으로. &lt;code&gt;result&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a12e9384fdef1dafb9fae65265be9c74c596dbe9" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;em&gt;s&lt;/em&gt; to its JSON representation.</source>
          <target state="translated">변환 된 문자열 &lt;em&gt;이야&lt;/em&gt; 의 JSON 표현으로.</target>
        </trans-unit>
        <trans-unit id="980e1d8060d78e58486c9df3e550ee5f6e2a68cc" translate="yes" xml:space="preserve">
          <source>Converts a string to a rope.</source>
          <target state="translated">문자열을 로프로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c429827106a747e37bec2a11c760bb8286d88760" translate="yes" xml:space="preserve">
          <source>Converts a value of any type to type JsObject</source>
          <target state="translated">모든 유형의 값을 JsObject 유형으로 변환</target>
        </trans-unit>
        <trans-unit id="f4e3067d8b47a656f48f8d82ac8876d087f88612" translate="yes" xml:space="preserve">
          <source>Converts all elements in &lt;em&gt;a&lt;/em&gt; to strings using &lt;em&gt;$&lt;/em&gt; and concatenates them with &lt;em&gt;sep&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;$를&lt;/em&gt; 사용하여 &lt;em&gt;a의&lt;/em&gt; 모든 요소 를 문자열로 변환 하고 &lt;em&gt;sep로&lt;/em&gt; 연결합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ec455ba743328c09b87329d96d1742813160d1e" translate="yes" xml:space="preserve">
          <source>Converts an HTML entity name like &lt;code&gt;&amp;amp;Uuml;&lt;/code&gt; or values like &lt;code&gt;&amp;amp;#220;&lt;/code&gt; or &lt;code&gt;&amp;amp;#x000DC;&lt;/code&gt; to its UTF-8 equivalent. &quot;&quot; is returned if the entity name is unknown. The HTML parser already converts entities to UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;amp;Uuml;&lt;/code&gt; 과 같은 HTML 엔티티 이름을 변환합니다 . 또는 &lt;code&gt;&amp;amp;#220;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;#x000DC;&lt;/code&gt; UTF-8과 동일합니다. 엔티티 이름을 알 수 없으면 &quot;&quot;가 리턴됩니다. HTML 파서는 이미 엔티티를 UTF-8로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf422f15d84b0f3aca45688ec388fe854366390" translate="yes" xml:space="preserve">
          <source>Converts an HTML entity name like &lt;code&gt;&amp;amp;Uuml;&lt;/code&gt; or values like &lt;code&gt;&amp;amp;#220;&lt;/code&gt; or &lt;code&gt;&amp;amp;#x000DC;&lt;/code&gt; to its UTF-8 equivalent. Rune(0) is returned if the entity name is unknown.</source>
          <target state="translated">&lt;code&gt;&amp;amp;Uuml;&lt;/code&gt; 과 같은 HTML 엔티티 이름을 변환합니다 . 또는 &lt;code&gt;&amp;amp;#220;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;#x000DC;&lt;/code&gt; UTF-8과 동일합니다. 엔터티 이름을 알 수 없으면 Rune (0)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0825a884dd8b1351613add9fb0074308e15e7d03" translate="yes" xml:space="preserve">
          <source>Converts an IpAddress into the textual representation</source>
          <target state="translated">IpAddress를 텍스트 표현으로 변환</target>
        </trans-unit>
        <trans-unit id="d28476e13bd8712221e541d096e4554fc6bc2d9d" translate="yes" xml:space="preserve">
          <source>Converts an SQL abstract syntax tree to its string representation.</source>
          <target state="translated">SQL 추상 구문 트리를 문자열 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="52438a7f27ee3d446a585f5bd5053b0046a801ed" translate="yes" xml:space="preserve">
          <source>Converts an UNIX-like path to a native one.</source>
          <target state="translated">UNIX와 유사한 경로를 기본 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="af9c67dfb7d7eacfd4f6812e4d2da7af1e606a58" translate="yes" xml:space="preserve">
          <source>Converts an input rst string into embeddable HTML.</source>
          <target state="translated">입력 된 첫 번째 문자열을 포함 가능한 HTML로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e966a333b537fd28276357a714fff24d7c4269fa" translate="yes" xml:space="preserve">
          <source>Converts an int to a rope.</source>
          <target state="translated">int를 로프로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2b863f714c71b2f5335df47d4d51a0b3c7cd9cb7" translate="yes" xml:space="preserve">
          <source>Converts between different character encodings. On UNIX, this uses the &lt;span id=&quot;iconv_1&quot;&gt;iconv&lt;/span&gt; library, on Windows the Windows API.</source>
          <target state="translated">다른 문자 인코딩 사이를 변환합니다. UNIX에서는 &lt;span id=&quot;iconv_1&quot;&gt;iconv&lt;/span&gt; 라이브러리, Windows에서는 Windows API를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f369afdb862db9c6076cc0006672f79db242e04e" translate="yes" xml:space="preserve">
          <source>Converts the Domain enum to a platform-dependent &lt;code&gt;cint&lt;/code&gt;.</source>
          <target state="translated">Domain 열거 형을 플랫폼 종속 &lt;code&gt;cint&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5284f00d462106a66438ab9161d28b6293460651" translate="yes" xml:space="preserve">
          <source>Converts the Protocol enum to a platform-dependent &lt;code&gt;cint&lt;/code&gt;.</source>
          <target state="translated">프로토콜 열거를 플랫폼 종속 &lt;code&gt;cint&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb7bb4e86c94bc9c61d088e91eb1e1cc87527efa" translate="yes" xml:space="preserve">
          <source>Converts the SockType enum to a platform-dependent &lt;code&gt;cint&lt;/code&gt;.</source>
          <target state="translated">SockType 열거 형을 플랫폼 종속 &lt;code&gt;cint&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="c100daeea4e8861ff9b8da2e9a038086e2b6d6bb" translate="yes" xml:space="preserve">
          <source>Converts the calendar time &lt;em&gt;time&lt;/em&gt; to broken-down time representation, expressed in Coordinated Universal Time (UTC).</source>
          <target state="translated">UTC (협정 세계시)로 표현 된 달력 시간 &lt;em&gt;시간&lt;/em&gt; 을 고장 시간 표시로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="82b6ac140a4ff1ac23733bb4818757b4392f5663" translate="yes" xml:space="preserve">
          <source>Converts the calendar time &lt;em&gt;time&lt;/em&gt; to broken-time representation, expressed relative to the user's specified time zone.</source>
          <target state="translated">사용자가 지정한 시간대를 기준으로 표현 된 달력 시간 &lt;em&gt;시간&lt;/em&gt; 을 중단 시간 표시로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b877ab37d239a0331d907c9b9daebdcacce63678" translate="yes" xml:space="preserve">
          <source>Converts the first character of &lt;em&gt;s&lt;/em&gt; into an upper-case unicode character.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 의 첫 문자를 대문자 유니 코드 문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="66e240e2249a2ca669aab16ffa70496a571eea1a" translate="yes" xml:space="preserve">
          <source>Converts the first character of &lt;em&gt;s&lt;/em&gt; into upper case.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 의 첫 문자 를 대문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="accdebd1b9a0af8ede9cc279b021822c54d22306" translate="yes" xml:space="preserve">
          <source>Converts the flags into the underlying OS representation.</source>
          <target state="translated">플래그를 기본 OS 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b7f6a299ff03d2d45b011ac4ee94f76ad82dbe6e" translate="yes" xml:space="preserve">
          <source>Converts the ordered hash set &lt;em&gt;s&lt;/em&gt; to a string, mostly for logging purposes.</source>
          <target state="translated">변환 정렬 된 해시 세트 &lt;em&gt;이야&lt;/em&gt; 대부분 로깅 목적으로, 문자열로.</target>
        </trans-unit>
        <trans-unit id="e6ddc6102110e98997c6395cbc1fab19c069874f" translate="yes" xml:space="preserve">
          <source>Converts the platform-dependent &lt;code&gt;cint&lt;/code&gt; to the Domain or none(), if the &lt;code&gt;cint&lt;/code&gt; is not known.</source>
          <target state="translated">플랫폼 종속 &lt;code&gt;cint&lt;/code&gt; 를 도메인으로 변환 하거나 &lt;code&gt;cint&lt;/code&gt; 를 알 수없는 경우 none ()을 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="0ce86adbb1cbb7e191b6716e3d3416e6d7d67afe" translate="yes" xml:space="preserve">
          <source>Converts the set &lt;em&gt;s&lt;/em&gt; to a string, mostly for logging purposes.</source>
          <target state="translated">변환 설정은 &lt;em&gt;이야&lt;/em&gt; 대부분의 목적을 로깅을위한 문자열로.</target>
        </trans-unit>
        <trans-unit id="6ee1dfa98f8b595b823b8bbb065918996eb4cb8f" translate="yes" xml:space="preserve">
          <source>Converts the specified &lt;code&gt;HttpCode&lt;/code&gt; into a HTTP status.</source>
          <target state="translated">지정된 &lt;code&gt;HttpCode&lt;/code&gt; 를 HTTP 상태로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5537e8dacd67b8d16a5dabd66f88a682e4bbd2" translate="yes" xml:space="preserve">
          <source>Copies UTF-8 representation of &lt;em&gt;c&lt;/em&gt; into the preallocated string &lt;em&gt;s&lt;/em&gt; starting at position &lt;em&gt;pos&lt;/em&gt;. If &lt;em&gt;doInc == true&lt;/em&gt;, &lt;em&gt;pos&lt;/em&gt; is incremented by the number of bytes that have been processed.</source>
          <target state="translated">사본 UTF-8로 표현 &lt;em&gt;C&lt;/em&gt; 미리 할당 된 문자열로 &lt;em&gt;의&lt;/em&gt; 위치에서 시작하는 &lt;em&gt;POS&lt;/em&gt; . &lt;em&gt;doInc == true&lt;/em&gt; 인 경우 처리 된 바이트 수만큼 &lt;em&gt;pos&lt;/em&gt; 가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="26de59e7e7997b34cdeba48bd9e16d70c4d54776" translate="yes" xml:space="preserve">
          <source>Copies a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; preserving file permissions.</source>
          <target state="translated">&lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;대상&lt;/em&gt; 파일 보존 권한 으로 디렉토리를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="8f4e6d44e5f3dc2d0f438e53da3cebaabb2b1b5f" translate="yes" xml:space="preserve">
          <source>Copies a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;dest&lt;/em&gt; 로 디렉토리를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="90b4902582c509337a81a289d51814c12a990773" translate="yes" xml:space="preserve">
          <source>Copies a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; preserving file permissions.</source>
          <target state="translated">파일을 &lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;대상&lt;/em&gt; 보존 권한으로 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="0d8d572c7de42b33f034bac4aeb6c7120daa5e04" translate="yes" xml:space="preserve">
          <source>Copies a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;소스&lt;/em&gt; 에서 &lt;em&gt;dest&lt;/em&gt; 로 파일을 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="2aee4f4602aac4bdcb0717c3e27a950207855d89" translate="yes" xml:space="preserve">
          <source>Copy all children from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;src&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 모든 어린이 복사&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b531523845572624d464c4423bc89536820c92e" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2005 University of Cambridge</source>
          <target state="translated">저작권 (c) 1997-2005 Cambridge University</target>
        </trans-unit>
        <trans-unit id="68836c550ee20fae0e06b2994e76a40348d2fc30" translate="yes" xml:space="preserve">
          <source>Core</source>
          <target state="translated">Core</target>
        </trans-unit>
        <trans-unit id="879f7a1f1ea784df949fa9fd42df4e58db07743b" translate="yes" xml:space="preserve">
          <source>CoroutineRef holds a pointer to actual coroutine object. Public API always returns CoroutineRef instead of CoroutinePtr in order to allow holding a reference to coroutine object while it can be safely deallocated by coroutine scheduler loop. In this case Coroutine.reference.coro is set to nil. Public API checks for for it being nil and gracefully fails if it is nil.</source>
          <target state="translated">CoroutineRef에는 실제 코 루틴 객체에 대한 포인터가 있습니다. 퍼블릭 API는 코 루틴 스케줄러 루프에 의해 안전하게 할당 해제 될 수 있지만 코 루틴 객체에 대한 참조를 보유 할 수 있도록 항상 CoroutinePtr 대신 CoroutineRef를 반환합니다. 이 경우 Coroutine.reference.coro는 nil로 설정됩니다. 공개 API가 nil인지 확인하고 nil이면 정상적으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ca6ad6006b6cf8a63b13b4b15300ec4f06f6b0bb" translate="yes" xml:space="preserve">
          <source>Corresponding AST</source>
          <target state="translated">해당 AST</target>
        </trans-unit>
        <trans-unit id="ecbbbe8b50c48c4f3e149e9838ae64b233a8ac9a" translate="yes" xml:space="preserve">
          <source>Count the occurrences of a substring &lt;em&gt;sub&lt;/em&gt; in the string &lt;em&gt;s&lt;/em&gt;. Overlapping occurrences of &lt;em&gt;sub&lt;/em&gt; only count when &lt;em&gt;overlapping&lt;/em&gt; is set to true.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 에서 하위 문자열 &lt;em&gt;하위&lt;/em&gt; 의 발생 횟수를 계산하십시오 . &lt;em&gt;하위의&lt;/em&gt; 중복 발생은 &lt;em&gt;중복&lt;/em&gt; 이 true로 설정된 경우에만 계산됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8eb9181e4924c1b8e6a2676efbc599b82be9c0b5" translate="yes" xml:space="preserve">
          <source>Count the occurrences of the character &lt;em&gt;sub&lt;/em&gt; in the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 에서 문자 &lt;em&gt;하위&lt;/em&gt; 의 발생 횟수를 계산하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62be6439bd5e8c4e51fce3efc8fd3d9c251d4337" translate="yes" xml:space="preserve">
          <source>Count the occurrences of the group of character &lt;em&gt;subs&lt;/em&gt; in the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 에서 문자 &lt;em&gt;서브&lt;/em&gt; 그룹의 발생 횟수를 계산하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8eeb1ed4c17fdc34ce13e52780c6286e251b4fe" translate="yes" xml:space="preserve">
          <source>Counting down can be achieved as easily (but is less often needed):</source>
          <target state="translated">카운트 다운은 쉽게 수행 할 수 있지만 덜 자주 필요합니다.</target>
        </trans-unit>
        <trans-unit id="95e4c673e17a060a448495af86d78f8c7deacaa8" translate="yes" xml:space="preserve">
          <source>Counts from ordinal value &lt;em&gt;a&lt;/em&gt; down to &lt;em&gt;b&lt;/em&gt; (inclusive) with the given step count. &lt;em&gt;T&lt;/em&gt; may be any ordinal type, &lt;em&gt;step&lt;/em&gt; may only be positive. &lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;low(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="translated">주어진 걸음 수를 사용하여 서수 값 &lt;em&gt;a&lt;/em&gt; 에서 &lt;em&gt;b&lt;/em&gt; (포함)까지 계산합니다. &lt;em&gt;T&lt;/em&gt; 는 서수 유형일 수 있으며 &lt;em&gt;단계&lt;/em&gt; 는 양수일 수 있습니다. &lt;strong&gt;참고&lt;/strong&gt; : 효율성상의 이유로 T = int이면 &lt;code&gt;low(int)&lt;/code&gt; 로 계산되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a4a396824d4f9efa6ebc6369fd73dcb9de024e14" translate="yes" xml:space="preserve">
          <source>Counts from ordinal value &lt;em&gt;a&lt;/em&gt; up to &lt;em&gt;b&lt;/em&gt; (inclusive) with the given step count. &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;T&lt;/em&gt; may be any ordinal type, &lt;em&gt;step&lt;/em&gt; may only be positive. &lt;strong&gt;Note&lt;/strong&gt;: This fails to count to &lt;code&gt;high(int)&lt;/code&gt; if T = int for efficiency reasons.</source>
          <target state="translated">주어진 단계 수를 사용하여 서수 값 &lt;em&gt;a&lt;/em&gt; 에서 &lt;em&gt;b&lt;/em&gt; (포함)까지 계산합니다. &lt;em&gt;S&lt;/em&gt; , &lt;em&gt;T&lt;/em&gt; 는 임의의 서수 유형일 수 있으며, &lt;em&gt;단계&lt;/em&gt; 는 양수일 수 있습니다. &lt;strong&gt;참고&lt;/strong&gt; : 효율성상의 이유로 T = int 인 경우 &lt;code&gt;high(int)&lt;/code&gt; 로 계산되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ab8edac288ea60a72babb4ac13f00e39b6304d03" translate="yes" xml:space="preserve">
          <source>Counts the set bits in &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">세트 비트를 &lt;em&gt;n&lt;/em&gt; 단위로 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b1f89440b5c7c37e9007e782278123e452405973" translate="yes" xml:space="preserve">
          <source>Counts the set bits in integer. (also called &lt;span id=&quot;hamming-weight_1&quot;&gt;Hamming weight&lt;/span&gt;.)</source>
          <target state="translated">설정된 비트를 정수로 계산합니다. ( &lt;span id=&quot;hamming-weight_1&quot;&gt;해밍 무게&lt;/span&gt; 라고도 함 )</target>
        </trans-unit>
        <trans-unit id="d37d133ea5c1b52753b3893f902c233ee8442bb5" translate="yes" xml:space="preserve">
          <source>Covariance</source>
          <target state="translated">Covariance</target>
        </trans-unit>
        <trans-unit id="63b826ee60a4e4916057a0ebb51042f5ae103a26" translate="yes" xml:space="preserve">
          <source>Covariance in Nim can be introduced only though pointer-like types such as &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt;. Sequence, Array and OpenArray types, instantiated with pointer-like types will be considered covariant if and only if they are also immutable. The introduction of a &lt;code&gt;var&lt;/code&gt; modifier or additional &lt;code&gt;ptr&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; indirections would result in invariant treatment of these types.</source>
          <target state="translated">Nim의 공분산은 &lt;code&gt;ptr&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 와 같은 포인터와 같은 유형을 통해서만 도입 될 수 있습니다 . 포인터와 같은 유형으로 인스턴스화 된 시퀀스, 배열 및 OpenArray 유형은 불변 인 경우에만 공변량으로 간주됩니다. &lt;code&gt;var&lt;/code&gt; 수정 자 또는 추가 &lt;code&gt;ptr&lt;/code&gt; 또는 &lt;code&gt;ref&lt;/code&gt; 간접 지시를 도입하면 이러한 유형의 변경이 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33c07d86e5962dca17024d9f64967cd8c28e691b" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;AsyncFTPClient&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;AsyncFTPClient&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f5fecadebd6d593a6695431391ad0fd49c5ed655" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;FtpClient&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;FtpClient&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="23edbeaa9cc5fe8cad35404118fd40e0a614f8b3" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Time&lt;/code&gt; from a unix timestamp and a nanosecond part.</source>
          <target state="translated">유닉스 타임 스탬프와 나노초 부분에서 &lt;code&gt;Time&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fff4f72ec41ce789bcee80aeb477691effbd6311" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;calculator.nim&lt;/code&gt; file with the following content (or reuse the one from the previous section):</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;calculator.nim&lt;/code&gt; 파일을 생성하십시오 (또는 이전 섹션의 파일을 재사용하십시오) :</target>
        </trans-unit>
        <trans-unit id="0750a0fb5f72560c40d6368863dca814c7e932c6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;calculator.nim&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음과 같은 내용 으로 &lt;code&gt;calculator.nim&lt;/code&gt; 파일을 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="d4e6a4c5d2254e6dc4b39e6d1c01a13965f476bc" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;fib.nim&lt;/code&gt; file with the following content (or reuse the one from the previous section):</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;fib.nim&lt;/code&gt; 파일을 작성하십시오 (또는 이전 섹션의 파일을 재사용하십시오).</target>
        </trans-unit>
        <trans-unit id="4e02889edf7b7d868b5ba6d7e5e804755b35a935" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;fib.nim&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;fib.nim&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="770be89953f498f7072651045ca40deb34be8bc5" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;host.html&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;host.html&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ed3a44cf5a0ea5653d547132a4b1514041e6365" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;logic.c&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;logic.c&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d10438b4c20277d901a7f3991b84fbd9aa0db8d" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;maths.c&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;maths.c&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e060d79809bc44b5c4d312ecb96133e434fb4eee" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;mhost.html&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용 으로 &lt;code&gt;mhost.html&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="82dbacf1c35d81a7e70386b3e2d60c18b2bfd7c8" translate="yes" xml:space="preserve">
          <source>Create a hard link at &lt;em&gt;dest&lt;/em&gt; which points to the item specified by &lt;em&gt;src&lt;/em&gt;.</source>
          <target state="translated">에서 하드 링크 만들기 &lt;em&gt;의 최종 도착&lt;/em&gt; 항목에 포인트로 지정 &lt;em&gt;SRC를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e61edb70f4e4628737d81482078857a79a3958cd" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;DateTime&lt;/code&gt; in the specified timezone.</source>
          <target state="translated">지정된 시간대에서 새 &lt;code&gt;DateTime&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad134b7dabefd052798c23ea0136931ba041a207" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;FutureStream&lt;/code&gt;. This future's callback is activated when two events occur:</source>
          <target state="translated">새 &lt;code&gt;FutureStream&lt;/code&gt; 을 만듭니다 . 이 미래의 콜백은 두 가지 이벤트가 발생하면 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed592456e6fa924c32835bdba9590feaf11f59c" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;FutureVar&lt;/code&gt;. This Future type is ideally suited for situations where you want to avoid unnecessary allocations of Futures.</source>
          <target state="translated">새로운 &lt;code&gt;FutureVar&lt;/code&gt; 를 만듭니다 . 이 선물 유형은 불필요한 선물 할당을 피하려는 상황에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="7577f69a35b8e4422d6b2c993390e358a36644e3" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;Timezone&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Timezone&lt;/code&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="075b6ed9e1da39a3c8119948c33156a30e0f223d" translate="yes" xml:space="preserve">
          <source>Create a new block statement with label</source>
          <target state="translated">라벨이 붙은 새로운 블록 문장 만들기</target>
        </trans-unit>
        <trans-unit id="9e803c40a5172896982bbe0c82954f04e3a426ac" translate="yes" xml:space="preserve">
          <source>Create a new block: stmt</source>
          <target state="translated">새 블록을 작성하십시오. stmt</target>
        </trans-unit>
        <trans-unit id="c81a7fb4162b5e66a18e252548a4190916db5c61" translate="yes" xml:space="preserve">
          <source>Create a new configuration table. Useful when wanting to create a configuration file.</source>
          <target state="translated">새 구성 테이블을 작성하십시오. 구성 파일을 만들 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="28d3edec8c7cef4cf9fb42a75c8f5598392223c2" translate="yes" xml:space="preserve">
          <source>Create a new const stmt</source>
          <target state="translated">새로운 const stmt 생성</target>
        </trans-unit>
        <trans-unit id="e8f77cac1785ce96b6a76e96505d2a469b7f8af7" translate="yes" xml:space="preserve">
          <source>Create a new deque. Optionally, the initial capacity can be reserved via &lt;em&gt;initialSize&lt;/em&gt; as a performance optimization. The length of a newly created deque will still be 0.</source>
          <target state="translated">새로운 deque를 만듭니다. 선택적 으로 성능 최적화로 &lt;em&gt;initialSize&lt;/em&gt; 를 통해 초기 용량을 예약 할 수 있습니다 . 새로 생성 된 deque의 길이는 여전히 0입니다.</target>
        </trans-unit>
        <trans-unit id="593df16e6d922e3bffcf46384642bb067a49cbef" translate="yes" xml:space="preserve">
          <source>Create a new empty node</source>
          <target state="translated">빈 노드를 새로 만듭니다</target>
        </trans-unit>
        <trans-unit id="3a174e3ed8e720e11187b74c70084dc931935a3f" translate="yes" xml:space="preserve">
          <source>Create a new ident node from a string</source>
          <target state="translated">문자열에서 새 아이디 노드 만들기</target>
        </trans-unit>
        <trans-unit id="296989a179b6137adf54b8b30a7e490ad29a910b" translate="yes" xml:space="preserve">
          <source>Create a new let stmt</source>
          <target state="translated">새로운 let stmt를 작성하십시오</target>
        </trans-unit>
        <trans-unit id="8887d174892fa4be23f465c6c582cf6fc6d2956d" translate="yes" xml:space="preserve">
          <source>Create a new multipart data object and fill it with the entries &lt;em&gt;xs&lt;/em&gt; directly.</source>
          <target state="translated">새로운 멀티 파트 데이터 객체를 생성하고 &lt;em&gt;xs&lt;/em&gt; 항목으로 직접 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="29eb5b33a33d8081ef581fce9546bd890d04de83" translate="yes" xml:space="preserve">
          <source>Create a new parentheses-enclosed expression</source>
          <target state="translated">괄호로 묶은 새 표현식 작성</target>
        </trans-unit>
        <trans-unit id="8f27a0df0d9d34715e04c11b1f227f743f45013c" translate="yes" xml:space="preserve">
          <source>Create a new rational number.</source>
          <target state="translated">새로운 유리수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="552598b4b539185c0edfc3839a664894484059a7" translate="yes" xml:space="preserve">
          <source>Create a new statement list</source>
          <target state="translated">새로운 명세서리스트 작성</target>
        </trans-unit>
        <trans-unit id="aed0349c73070e14686b4d9c58ef01120325cd7e" translate="yes" xml:space="preserve">
          <source>Create a new var stmt</source>
          <target state="translated">새로운 var stmt 생성</target>
        </trans-unit>
        <trans-unit id="2673c8ff74ced70c5116036fab9e318a8b91f3a4" translate="yes" xml:space="preserve">
          <source>Create a symbolic link at &lt;em&gt;dest&lt;/em&gt; which points to the item specified by &lt;em&gt;src&lt;/em&gt;. On most operating systems, will fail if a link already exists.</source>
          <target state="translated">에서 심볼릭 링크 만들기 &lt;em&gt;의 최종 도착&lt;/em&gt; 항목에 포인트로 지정 &lt;em&gt;SRC를&lt;/em&gt; . 대부분의 운영 체제에서 링크가 이미 존재하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d6362064f96a05cf2bb91cb3077538fd06202e6c" translate="yes" xml:space="preserve">
          <source>Create a temporary file.</source>
          <target state="translated">임시 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b3ea057aeb3f6aa1874ce264a3345d18c387ba36" translate="yes" xml:space="preserve">
          <source>Create new colon expression newColonExpr(a, b) -&amp;gt; &lt;em&gt;a: b&lt;/em&gt;</source>
          <target state="translated">새 콜론 표현식 작성 newColonExpr (a, b)-&amp;gt; &lt;em&gt;a : b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6d7e615c75ed606e1264e4ea4741c40a7f18023" translate="yes" xml:space="preserve">
          <source>Create new dot expression a.dot(b) -&amp;gt; &lt;em&gt;a.b&lt;/em&gt;</source>
          <target state="translated">새로운 점 표현 만들기 a.dot (b)-&amp;gt; &lt;em&gt;ab&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e32cb321457c0858e2e809df0094b72d918dbc21" translate="yes" xml:space="preserve">
          <source>Creates &lt;em&gt;AsyncFile&lt;/em&gt; with a previously opened file descriptor &lt;em&gt;fd&lt;/em&gt;.</source>
          <target state="translated">작성 &lt;em&gt;AsyncFile을&lt;/em&gt; 이전에 열린 파일 기술자와 &lt;em&gt;FD&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="51c2a002a32b91eb9796a0b1ab55d33e641a5607" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;File&lt;/code&gt; from a &lt;em&gt;filehandle&lt;/em&gt; with given &lt;em&gt;mode&lt;/em&gt;.</source>
          <target state="translated">작성 &lt;code&gt;File&lt;/code&gt; A로부터 &lt;em&gt;파일 핸들&lt;/em&gt; 주어진와 &lt;em&gt;모드&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea3db51de64d8fe4daabbd9c6a635502cb1d6af7" translate="yes" xml:space="preserve">
          <source>Creates a CDATASection node whose value is the specified string.</source>
          <target state="translated">값이 지정된 문자열 인 CDATASection 노드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9e3b2800905b10fb32ad73c64fb25c61255d8385" translate="yes" xml:space="preserve">
          <source>Creates a Comment node given the specified string.</source>
          <target state="translated">지정된 문자열이 주어진 Comment 노드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1d2239d815558fae2098e2b33fdbabedd53aaf01" translate="yes" xml:space="preserve">
          <source>Creates a ProcessingInstruction node given the specified name and data strings.</source>
          <target state="translated">지정된 이름과 데이터 문자열이 주어진 ProcessingInstruction 노드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fe3cab960a9b3394ae3f294a187a878cfc7226ae" translate="yes" xml:space="preserve">
          <source>Creates a Text node given the specified string.</source>
          <target state="translated">지정된 문자열이 지정된 텍스트 노드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b265e81dc0757d098864df1b026e934c585d7a22" translate="yes" xml:space="preserve">
          <source>Creates a command in the format of &lt;code&gt;Set-Cookie: key=value; Domain=...; ...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Set-Cookie: key=value; Domain=...; ...&lt;/code&gt; 형식으로 명령을 만듭니다 . key = value; 도메인 = ...; ...</target>
        </trans-unit>
        <trans-unit id="7d15b2faff2a42afd6bb1667ac4a7587715b676a" translate="yes" xml:space="preserve">
          <source>Creates a directory &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;recursive&lt;/code&gt; is true, the topmost subdirectory of &lt;code&gt;dir&lt;/code&gt; will be created first, following the secondmost... etc. this allows you to give a full path as the &lt;code&gt;dir&lt;/code&gt; without worrying about subdirectories not existing.</source>
          <target state="translated">디렉토리 &lt;code&gt;dir&lt;/code&gt; 을 작성 합니다. 경우 &lt;code&gt;recursive&lt;/code&gt; 사실이다의 최상위 하위 &lt;code&gt;dir&lt;/code&gt; 이 당신이로 전체 경로를 제공 할 수 있습니다 등 ... secondmost 다음, 처음 생성 될 &lt;code&gt;dir&lt;/code&gt; 존재하지 않는 하위 디렉토리에 대한 걱정없이.</target>
        </trans-unit>
        <trans-unit id="dae70e0209ed57f5cb8389beda242534dd55df39" translate="yes" xml:space="preserve">
          <source>Creates a formatter that writes report to the specified stream in JUnit format. The &lt;code&gt;stream&lt;/code&gt; is NOT closed automatically when the test are finished, because the formatter has no way to know when all tests are finished. You should invoke formatter.close() to finalize the report.</source>
          <target state="translated">지정된 스트림에 보고서를 JUnit 형식으로 작성하는 포맷터를 작성합니다. &lt;code&gt;stream&lt;/code&gt; 테스트가 완료되면 포맷터는 모든 검사가 완료되면 알 수있는 방법이 없기 때문에, 자동으로 종료되지 않습니다. formatter.close ()를 호출하여 보고서를 마무리해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1788e2f22de39c5d0455bb03a33a9c96849e4c1" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;AsyncFtpClient&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;AsyncFtpClient&lt;/code&gt; 객체를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="6e13e475fb9b0f98eca84d01c93cd394fa75836f" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;AsyncHttpServer&lt;/code&gt; instance.</source>
          <target state="translated">새로운 &lt;code&gt;AsyncHttpServer&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c1b4b9f562ea0a6366e523f447871dad7dedb995" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;AsyncSmtp&lt;/code&gt; instance.</source>
          <target state="translated">새로운 &lt;code&gt;AsyncSmtp&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3b35a1f40d937326ff0bab2ad3f1dc72040c8cf6" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;AsyncSocket&lt;/code&gt; based on the supplied params.</source>
          <target state="translated">제공된 매개 변수를 기반으로 새 &lt;code&gt;AsyncSocket&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3e365e4727663367a1661340e026ab26c3670c3e" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;Rand&lt;/code&gt; state from &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seed&lt;/code&gt; 에서 새 &lt;code&gt;Rand&lt;/code&gt; 상태를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e77348f71d231e6e6513f22075a4477daa51ac85" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;Smtp&lt;/code&gt; instance.</source>
          <target state="translated">새로운 &lt;code&gt;Smtp&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1eaf912ec41b24d949c7682efd7ae15eb5805ccc" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;SqlPrepared&lt;/code&gt; statement. Parameter substitution is done via &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, etc.</source>
          <target state="translated">새로운 &lt;code&gt;SqlPrepared&lt;/code&gt; 문을 만듭니다 . 매개 변수 대체는 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등을 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a3a52a7c298533908167099608eeefa7d73bf86" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;TimeInterval&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;TimeInterval&lt;/code&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="931ea726913ddc96238ea9e98f07b7b0eeaff38c" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;nnkIdentDefs&lt;/code&gt; node of a specific kind and value.</source>
          <target state="translated">특정 종류 및 값 의 새 &lt;code&gt;nnkIdentDefs&lt;/code&gt; 노드를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6536ad4a1ea6812a166395f652dd54f9e13e77b6" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JArray JsonNode&lt;/em&gt;</source>
          <target state="translated">새로운 &lt;em&gt;JArray JsonNode를 작성합니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b3d217ffdcef21fc95e5196187ea5bc54a29010" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JBool JsonNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;JBool JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c3edaa8dd3ddf51c0898151aa192a6ca33b3ae26" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JFloat JsonNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;JFloat JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7ec1f5e99e284aed59ae7d3b0c3acd9d66f88d02" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JInt JsonNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;JInt JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bf27dac0cb27a30c25e8ee3b02ae6ee96df0a763" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JNull JsonNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;JNull JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c74323920b2d322c5918831e9a35c334440186f2" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JObject JsonNode&lt;/em&gt;</source>
          <target state="translated">새로운 &lt;em&gt;JObject JsonNode를&lt;/em&gt; 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d5c3fda9ce6357768481607c34cedacb699e6ae" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;JString JsonNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;JString JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2ffdf8f85b3fb5fa765801e8fc44b15863de757f" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SCons SexpNode&lt;/em&gt;</source>
          <target state="translated">새로운 &lt;em&gt;SCons SexpNode를&lt;/em&gt; 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03ac288c573f6c7e4fb78f29669957e603cfb8ef" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SFloat SexpNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;SFloat SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="df4cf4d41f96304b44b50fd172bec3a73e46bda3" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SInt SexpNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;SInt SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="17271a72c46267bfda4e7e6ccc8b7b5083f4c1f9" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SList SexpNode&lt;/em&gt;</source>
          <target state="translated">새로운 &lt;em&gt;SList SexpNode를&lt;/em&gt; 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a126f39e6fde470c76fd428d92c81cec4f8a6ee7" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SNil SexpNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;SNil SexpNode를&lt;/em&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2f27c6a06fa99e865b80d167d84c82a9cd158324" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;em&gt;SString SexpNode&lt;/em&gt;.</source>
          <target state="translated">새로운 &lt;em&gt;SString SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ca52f76fb58ff063636bf319ab5d4ccb3e95054b" translate="yes" xml:space="preserve">
          <source>Creates a new AST node of the specified kind.</source>
          <target state="translated">지정된 종류의 새 AST 노드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3935a50a40a4679e58e6421cbbb017e2fab2d878" translate="yes" xml:space="preserve">
          <source>Creates a new AsyncHttpClient instance.</source>
          <target state="translated">새로운 AsyncHttpClient 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7e42e3d783e045e776b4e5f780dd0cd2670ab15e" translate="yes" xml:space="preserve">
          <source>Creates a new Dispatcher instance.</source>
          <target state="translated">새로운 디스패처 인스턴스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a39c787004337e77b85fb2a72bd38c3f1a9634dc" translate="yes" xml:space="preserve">
          <source>Creates a new HttpClient instance.</source>
          <target state="translated">새로운 HttpClient 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4a49fc47d501422a0e7784df87146196511de3d6" translate="yes" xml:space="preserve">
          <source>Creates a new MIME compliant message.</source>
          <target state="translated">새로운 MIME 호환 메시지를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="30538f237d4f9845b41dbff0d40d205fe272dbce" translate="yes" xml:space="preserve">
          <source>Creates a new Mimetypes database. The database will contain the most common mimetypes.</source>
          <target state="translated">새로운 Mimetypes 데이터베이스를 작성합니다. 데이터베이스는 가장 일반적인 mimetype을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f9fefb7b2a8f7f8398a6f9ff844afa8d0a77bf7f" translate="yes" xml:space="preserve">
          <source>Creates a new asynchronous socket.</source>
          <target state="translated">새로운 비동기 소켓을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="33e4224a87027f9aef23ecc4052592742ed723a5" translate="yes" xml:space="preserve">
          <source>Creates a new console logger. This logger logs to the console.</source>
          <target state="translated">새로운 콘솔 로거를 만듭니다. 이 로거는 콘솔에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="47bdf3ded5ecc72f0243c3632454b2329dfc36d1" translate="yes" xml:space="preserve">
          <source>Creates a new delegate.</source>
          <target state="translated">새 대리자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9029117b9d691f0b92a9a226b9c4ebf5da4786b7" translate="yes" xml:space="preserve">
          <source>Creates a new empty JsAssoc with key type &lt;em&gt;K&lt;/em&gt; and value type &lt;em&gt;V&lt;/em&gt;.</source>
          <target state="translated">키 유형 &lt;em&gt;K&lt;/em&gt; 및 값 유형 &lt;em&gt;V로&lt;/em&gt; 비어있는 새 JsAssoc을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="893e64dc1e5ca9aef6d0724e5de914f2a349aa04" translate="yes" xml:space="preserve">
          <source>Creates a new empty JsObject</source>
          <target state="translated">비어있는 새 JsObject를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9ef055cd5c39219c0b34b4e156b41149c0e1ea8a" translate="yes" xml:space="preserve">
          <source>Creates a new enum. &lt;em&gt;name&lt;/em&gt; must be an ident. Fields are allowed to be either idents or EnumFieldDef</source>
          <target state="translated">새로운 열거 형을 작성합니다. &lt;em&gt;이름&lt;/em&gt; 은 신분이어야합니다. 필드는 idents 또는 EnumFieldDef 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c99b61be96eb449cda76e440222b303de93cf1" translate="yes" xml:space="preserve">
          <source>Creates a new file logger. This logger logs to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">새로운 파일 로거를 작성합니다. 이 로거는 &lt;code&gt;file&lt;/code&gt; 로그 합니다 .</target>
        </trans-unit>
        <trans-unit id="57e0013098d4a45d00c424f089cb8f7bc586d5eb" translate="yes" xml:space="preserve">
          <source>Creates a new file logger. This logger logs to a file, specified by &lt;code&gt;fileName&lt;/code&gt;. Use &lt;code&gt;bufSize&lt;/code&gt; as size of the output buffer when writing the file (-1: use system defaults, 0: unbuffered, &amp;gt;0: fixed buffer size).</source>
          <target state="translated">새로운 파일 로거를 작성합니다. 이 로거는 &lt;code&gt;fileName&lt;/code&gt; 으로 지정된 파일에 로그합니다 . 파일을 쓸 때 출력 버퍼의 크기로 &lt;code&gt;bufSize&lt;/code&gt; 를 사용하십시오 (-1 : 시스템 기본값 사용, 0 : 버퍼되지 않음,&amp;gt; 0 : 고정 버퍼 크기).</target>
        </trans-unit>
        <trans-unit id="da0631af382222a663f00eef225f13c67dd0fd14" translate="yes" xml:space="preserve">
          <source>Creates a new future.</source>
          <target state="translated">새로운 미래를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d22ee44302e8b1951e26381979dbda9c32df6b30" translate="yes" xml:space="preserve">
          <source>Creates a new hash set that contains the given &lt;em&gt;keys&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;키&lt;/em&gt; 를 포함하는 새로운 해시 세트를 작성 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5ae89ab8d1bd0d00171a35bf4ba65c6d456f7daf" translate="yes" xml:space="preserve">
          <source>Creates a new ordered hash set that contains the given &lt;em&gt;keys&lt;/em&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;키&lt;/em&gt; 를 포함하는 새로운 순서의 해시 세트를 작성 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d327c27468cfd87650f44312e18da039e8885e03" translate="yes" xml:space="preserve">
          <source>Creates a new rolling file logger. Once a file reaches &lt;code&gt;maxLines&lt;/code&gt; lines a new log file will be started and the old will be renamed. Use &lt;code&gt;bufSize&lt;/code&gt; as size of the output buffer when writing the file (-1: use system defaults, 0: unbuffered, &amp;gt;0: fixed buffer size).</source>
          <target state="translated">새로운 롤링 파일 로거를 만듭니다. 파일이 &lt;code&gt;maxLines&lt;/code&gt; 행에 도달하면 새 로그 파일이 시작되고 이전 이름이 바뀝니다. 파일을 쓸 때 출력 버퍼의 크기로 &lt;code&gt;bufSize&lt;/code&gt; 를 사용하십시오 (-1 : 시스템 기본값 사용, 0 : 버퍼되지 않음,&amp;gt; 0 : 고정 버퍼 크기).</target>
        </trans-unit>
        <trans-unit id="4aebfe6dbd3ba833b7866ae9ff4700e5a486a45b" translate="yes" xml:space="preserve">
          <source>Creates a new selector</source>
          <target state="translated">새로운 선택자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="db5f105207af18fa248cc6ae468b071100b9d4a7" translate="yes" xml:space="preserve">
          <source>Creates a new socket as specified by the params.</source>
          <target state="translated">params에 의해 지정된 새로운 소켓을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="46e397d113b6a20fc8740a85a4158b1f1e6dbb77" translate="yes" xml:space="preserve">
          <source>Creates a new socket.</source>
          <target state="translated">새로운 소켓을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2bcc994307c7bb05b50439da51e6a4f28a519eb2" translate="yes" xml:space="preserve">
          <source>Creates a new socket; returns &lt;em&gt;InvalidSocket&lt;/em&gt; if an error occurs.</source>
          <target state="translated">새로운 소켓을 작성합니다. 오류가 발생하면 &lt;em&gt;InvalidSocket을&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="abdca6d53ed7120e4f32dabe09d38b3b245a49d9" translate="yes" xml:space="preserve">
          <source>Creates a new socket; returns &lt;em&gt;osInvalidSocket&lt;/em&gt; if an error occurs.</source>
          <target state="translated">새로운 소켓을 작성합니다. 오류가 발생하면 &lt;em&gt;osInvalidSocket을&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a03a88acdaa13820176791e85d3e86103d2b7826" translate="yes" xml:space="preserve">
          <source>Creates a new thread-safe &lt;code&gt;AsyncEvent&lt;/code&gt; object.</source>
          <target state="translated">새로운 스레드 안전 &lt;code&gt;AsyncEvent&lt;/code&gt; 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c01025184f157b7f925df9f054dd1b3a17aeee59" translate="yes" xml:space="preserve">
          <source>Creates a new user-defined event.</source>
          <target state="translated">새로운 사용자 정의 이벤트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f0c4f85e4914a33780136be6fe9f32e5c82801f4" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;AsyncScgiState&lt;/code&gt; object which serves as a SCGI server.</source>
          <target state="translated">SCGI 서버 역할을 하는 &lt;code&gt;AsyncScgiState&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8d5badfaf65b9d85e41ca541f17d5e2ad13a7c2f" translate="yes" xml:space="preserve">
          <source>Creates an Attr of the given name. Note that the Attr instance can then be set on an Element using the setAttributeNode method. To create an attribute with a qualified name and namespace URI, use the createAttributeNS method.</source>
          <target state="translated">지정된 이름의 Attr을 작성합니다. 그런 다음 setAttributeNode 메소드를 사용하여 Attr 인스턴스를 요소에 설정할 수 있습니다. 규정 된 이름과 네임 스페이스 URI로 속성을 작성하려면 createAttributeNS 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24a651579c04908c160b4936a473b704a0a1db4f" translate="yes" xml:space="preserve">
          <source>Creates an SSL context.</source>
          <target state="translated">SSL 컨텍스트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="18146698b37bb3ef78ddb2e3ebc9b7f7e8c3171d" translate="yes" xml:space="preserve">
          <source>Creates an XML Document object of the specified type with its document element.</source>
          <target state="translated">문서 요소를 사용하여 지정된 유형의 XML 문서 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0ccf8847ae080229117753dedb3917a877ab8802" translate="yes" xml:space="preserve">
          <source>Creates an attribute of the given qualified name and namespace URI</source>
          <target state="translated">주어진 정규화 된 이름과 네임 스페이스 URI의 속성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="521e8d861e29dd20ae3f05b555ed5bc031a59c9d" translate="yes" xml:space="preserve">
          <source>Creates an element of the given qualified name and namespace URI.</source>
          <target state="translated">주어진 정규화 된 이름과 네임 스페이스 URI의 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7fb93e01953b423994157a2902c7fa5505afeba4" translate="yes" xml:space="preserve">
          <source>Creates an element of the type specified.</source>
          <target state="translated">지정된 유형의 요소를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a0eb2da505ca06ee47f0d72006910740f7a87ee5" translate="yes" xml:space="preserve">
          <source>Creates an empty DocumentFragment object.</source>
          <target state="translated">빈 DocumentFragment 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1069a59f1d48632c1603e127af7a2c6051032a8" translate="yes" xml:space="preserve">
          <source>Creates the &lt;span id=&quot;directory_2&quot;&gt;directory&lt;/span&gt;&lt;em&gt;dir&lt;/em&gt;.</source>
          <target state="translated">작성 &lt;span id=&quot;directory_2&quot;&gt;디렉토리 &lt;/span&gt;&lt;em&gt;말 일세&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="da1c277aa223391e9a5a2eca64bf1b8e345b705e" translate="yes" xml:space="preserve">
          <source>Creating JSON</source>
          <target state="translated">JSON 만들기</target>
        </trans-unit>
        <trans-unit id="a043eff94e3b002b2d06a59b53f27166020db8b4" translate="yes" xml:space="preserve">
          <source>Creating a configuration file.</source>
          <target state="translated">구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="6005f7b2874625a48384d80e948e41227a45219c" translate="yes" xml:space="preserve">
          <source>Creating a server</source>
          <target state="translated">서버 만들기</target>
        </trans-unit>
        <trans-unit id="caa32e4e8e79e2c3c02dca0de8e30c735ffb9e02" translate="yes" xml:space="preserve">
          <source>Creating a table</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="353ca08a0875743d6d075dfe55ac39667c480345" translate="yes" xml:space="preserve">
          <source>Creating closures in loops</source>
          <target state="translated">루프에서 클로저 만들기</target>
        </trans-unit>
        <trans-unit id="dbc00a91eff4276f07e3361b175e94d3eb014573" translate="yes" xml:space="preserve">
          <source>Cross compilation</source>
          <target state="translated">크로스 컴파일</target>
        </trans-unit>
        <trans-unit id="5d627257eabb026d6e37a9fc89af0a8b892846ec" translate="yes" xml:space="preserve">
          <source>Cross compilation for Nintendo Switch</source>
          <target state="translated">닌텐도 스위치 크로스 컴파일</target>
        </trans-unit>
        <trans-unit id="3a30385cfc2980dd1d7d1913af03cc8e19bb6219" translate="yes" xml:space="preserve">
          <source>Cryptography and Hashing</source>
          <target state="translated">암호화 및 해싱</target>
        </trans-unit>
        <trans-unit id="8f3896c45fffd6cca2d32bcbab32873cb06fb1e6" translate="yes" xml:space="preserve">
          <source>Curly braces</source>
          <target state="translated">중괄호</target>
        </trans-unit>
        <trans-unit id="56e31ab1833744822d2ee2546af636c8e2c14524" translate="yes" xml:space="preserve">
          <source>Curly braces are used as the set constructor.</source>
          <target state="translated">중괄호는 집합 생성자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1e56e27a0597efeb808c21d1b38cc357f11a35" translate="yes" xml:space="preserve">
          <source>Current date</source>
          <target state="translated">현재 날짜</target>
        </trans-unit>
        <trans-unit id="09150060974e22dd6942171bb9b7f95ae8524dea" translate="yes" xml:space="preserve">
          <source>Current time</source>
          <target state="translated">현재 시간</target>
        </trans-unit>
        <trans-unit id="11be62e9fa7efe4df7fe07e5c236d969e4976243" translate="yes" xml:space="preserve">
          <source>Currently all queries are ANSI calls, not Unicode.</source>
          <target state="translated">현재 모든 쿼리는 유니 코드가 아닌 ANSI 호출입니다.</target>
        </trans-unit>
        <trans-unit id="21552dbce343d65b9b2afed13575f529b89c2bb7" translate="yes" xml:space="preserve">
          <source>Currently any Unicode character with an ordinal value &amp;gt; 127 (non ASCII) is classified as a &lt;code&gt;letter&lt;/code&gt; and may thus be part of an identifier but later versions of the language may assign some Unicode characters to belong to the operator characters instead.</source>
          <target state="translated">현재 서 수가 127보다 큰 유니 코드 문자 (ASCII 아님)는 &lt;code&gt;letter&lt;/code&gt; 로 분류 되므로 식별자의 일부일 수 있지만 이후 버전의 언어에서는 일부 유니 코드 문자가 연산자 문자에 속하도록 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5041b5ff33d654ad27f3037259c3d51d09fcb7" translate="yes" xml:space="preserve">
          <source>Currently case statement macros must be enabled explicitly via &lt;code&gt;{.experimental: &quot;caseStmtMacros&quot;.}&lt;/code&gt;.</source>
          <target state="translated">현재 사례 명령문 매크로는 &lt;code&gt;{.experimental: &quot;caseStmtMacros&quot;.}&lt;/code&gt; 를 통해 명시 적으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="340e67b06e3a575587e92e054af1e1e0133e9d22" translate="yes" xml:space="preserve">
          <source>Currently for loop macros must be enabled explicitly via &lt;code&gt;{.experimental: &quot;forLoopMacros&quot;.}&lt;/code&gt;.</source>
          <target state="translated">현재 for 루프 매크로는 &lt;code&gt;{.experimental: &quot;forLoopMacros&quot;.}&lt;/code&gt; 를 통해 명시 적으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d26c01f3ff1b576add581da7e6d1f4d18f72afe" translate="yes" xml:space="preserve">
          <source>Currently not implemented for ODBC.</source>
          <target state="translated">현재 ODBC 용으로 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ab7cce4834f14cc8539768a218f249d659c44848" translate="yes" xml:space="preserve">
          <source>Currently only the dot accessor can be borrowed in this way.</source>
          <target state="translated">현재는 점 접근 자만이 방법으로 빌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b8eb558a36f3acc9d57e87afcc83f2333aca6e" translate="yes" xml:space="preserve">
          <source>Currently only the synchronous functions support a timeout. The timeout is measured in milliseconds, once it is set any call on a socket which may block will be susceptible to this timeout.</source>
          <target state="translated">현재 동기 함수 만 시간 종료를 지원합니다. 제한 시간은 밀리 초 단위로 측정되며 일단 차단되면 소켓에 대한 호출이 설정되면이 제한 시간에 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="173a35daa134ad3a8e12cc27fe7eb43b17e821dd" translate="yes" xml:space="preserve">
          <source>Currently the database parameter is ignored, but included to match &lt;code&gt;open()&lt;/code&gt; in the other db_xxxxx library modules.</source>
          <target state="translated">현재 데이터베이스 매개 변수는 무시되지만 다른 db_xxxxx 라이브러리 모듈의 &lt;code&gt;open()&lt;/code&gt; 과 일치하도록 포함되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a80a2b2ea1693d1b7b908c7997e09534c7a319d4" translate="yes" xml:space="preserve">
          <source>Custom annotations</source>
          <target state="translated">맞춤 주석</target>
        </trans-unit>
        <trans-unit id="59e80a7eaa7504ded2159eceee554eb6cea68ef2" translate="yes" xml:space="preserve">
          <source>Custom data types</source>
          <target state="translated">맞춤 데이터 유형</target>
        </trans-unit>
        <trans-unit id="5ecd13a23c1742a9a584f1f7c3f1289b615bd48b" translate="yes" xml:space="preserve">
          <source>Custom pragmas can be used in all locations where ordinary pragmas can be specified. It is possible to annotate procs, templates, type and variable definitions, statements, etc.</source>
          <target state="translated">일반 pragma를 지정할 수있는 모든 위치에서 사용자 정의 pragma를 사용할 수 있습니다. proc, 템플릿, 유형 및 변수 정의, 명령문 등에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5efdba27b5ba6eb23f21dccff045fc4b5e15649b" translate="yes" xml:space="preserve">
          <source>Cycle collector</source>
          <target state="translated">사이클 수집기</target>
        </trans-unit>
        <trans-unit id="1fa2cb810dcc2a5fa06854c2836cea239c6828fd" translate="yes" xml:space="preserve">
          <source>DB quotes the string.</source>
          <target state="translated">DB는 문자열을 인용합니다.</target>
        </trans-unit>
        <trans-unit id="36040bd2059d08df88ed7944b5e359b04d30367f" translate="yes" xml:space="preserve">
          <source>DLL generation</source>
          <target state="translated">DLL 생성</target>
        </trans-unit>
        <trans-unit id="36972ef7c9e006ffcf7c4c34c7d388f185ad9c86" translate="yes" xml:space="preserve">
          <source>DLL loading via &lt;code&gt;dlsym&lt;/code&gt; is global.</source>
          <target state="translated">&lt;code&gt;dlsym&lt;/code&gt; 을 통한 DLL 로딩 은 글로벌입니다.</target>
        </trans-unit>
        <trans-unit id="6299959dd9f9ba60735730d1d725169e46ab966a" translate="yes" xml:space="preserve">
          <source>Data flow variables ensure that no data races are possible. Due to technical limitations not every type &lt;code&gt;T&lt;/code&gt; is possible in a data flow variable: &lt;code&gt;T&lt;/code&gt; has to be of the type &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt; or of a type that doesn't contain a type that is garbage collected. This restriction is not hard to work-around in practice.</source>
          <target state="translated">데이터 흐름 변수는 데이터 경쟁이 불가능하다는 것을 보장합니다. 기술적 제한으로 인해 데이터 흐름 변수에서 모든 유형 &lt;code&gt;T&lt;/code&gt; 가 가능한 것은 아닙니다 . &lt;code&gt;T&lt;/code&gt; 는 유형 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; 또는 가비지 수집 된 유형을 포함하지 않는 유형 이어야 합니다. 이 제한은 실제로 해결하기 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="254201a1cd6b53ffb45f6e76fbc025f80039c274" translate="yes" xml:space="preserve">
          <source>Database support</source>
          <target state="translated">데이터베이스 지원</target>
        </trans-unit>
        <trans-unit id="8fc6ff82795e7cf381c1b241714313f9d82727ad" translate="yes" xml:space="preserve">
          <source>Debugging Nim's memory management</source>
          <target state="translated">Nim의 메모리 관리 디버깅</target>
        </trans-unit>
        <trans-unit id="7a442b40082af358980ccde93abe3fac72eaa773" translate="yes" xml:space="preserve">
          <source>Debugging the compiler</source>
          <target state="translated">컴파일러 디버깅</target>
        </trans-unit>
        <trans-unit id="ee0651b2882dbb9272d181f70c07d1807e1f7962" translate="yes" xml:space="preserve">
          <source>Decimal Integer. Outputs the number in base 10.</source>
          <target state="translated">십진 정수. 밑이 10 인 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="faf9a616be1a96a0f253b577af7bdb667d8f1ff2" translate="yes" xml:space="preserve">
          <source>Declaration of the Document Object Model for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript backend&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 백엔드에&lt;/a&gt; 대한 문서 객체 모델의 선언 .</target>
        </trans-unit>
        <trans-unit id="6703ff440bcb04e79ba0360b4e3f4d5024abe855" translate="yes" xml:space="preserve">
          <source>Declare a test suite identified by &lt;em&gt;name&lt;/em&gt; with optional &lt;code&gt;setup&lt;/code&gt; and/or &lt;code&gt;teardown&lt;/code&gt; section.</source>
          <target state="translated">선택적 &lt;code&gt;setup&lt;/code&gt; 및 / 또는 &lt;code&gt;teardown&lt;/code&gt; 섹션을 사용 하여 &lt;em&gt;이름&lt;/em&gt; 으로 식별 된 테스트 스위트를 선언 하십시오.</target>
        </trans-unit>
        <trans-unit id="97befc331a58a9a3c707b5e50780ec15616e5f6c" translate="yes" xml:space="preserve">
          <source>Declaring &lt;code&gt;distinct&lt;/code&gt; types is similar, with the last &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkDistinctTy&lt;/code&gt;.</source>
          <target state="translated">선언 &lt;code&gt;distinct&lt;/code&gt; 유형은 마지막으로 비슷하다 &lt;code&gt;nnkIdent&lt;/code&gt; 에 싸여 &lt;code&gt;nnkDistinctTy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d779abcf9e4be03342551d2efe4b130dd69421ab" translate="yes" xml:space="preserve">
          <source>Decodes a URL according to RFC3986.</source>
          <target state="translated">RFC3986에 따라 URL을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="133868f74e6ab7f40ef03d68c323718e0da1f9ad" translate="yes" xml:space="preserve">
          <source>Decoding data</source>
          <target state="translated">데이터 디코딩</target>
        </trans-unit>
        <trans-unit id="8e6709a624ea4d2592d488d29785d6f3a679fa95" translate="yes" xml:space="preserve">
          <source>Decrements an ordinal</source>
          <target state="translated">서수 감소</target>
        </trans-unit>
        <trans-unit id="f77ddc5e8aa829c42eea4936032517eb20ae470e" translate="yes" xml:space="preserve">
          <source>Decrements in place a floating point number</source>
          <target state="translated">부동 소수 점수 감소</target>
        </trans-unit>
        <trans-unit id="709a8d353480f0587a10991793ee126cac3909dc" translate="yes" xml:space="preserve">
          <source>Deep copying for communication between threads</source>
          <target state="translated">스레드 간 통신을위한 딥 카피</target>
        </trans-unit>
        <trans-unit id="61c35f6ab9b64b6090e79153752181a629e873bb" translate="yes" xml:space="preserve">
          <source>Default FTP &lt;code&gt;onProgressChanged&lt;/code&gt; handler. Does nothing.</source>
          <target state="translated">기본 FTP &lt;code&gt;onProgressChanged&lt;/code&gt; 핸들러입니다. 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b7cea1d46ac70ffcdb85b428af0dbca4d6782b9" translate="yes" xml:space="preserve">
          <source>Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable and the worst case is guaranteed to be O(n log n). The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length &lt;code&gt;a.len div 2&lt;/code&gt;. Currently Nim does not support a sensible default argument for &lt;code&gt;cmp&lt;/code&gt;, so you have to provide one of your own. However, the &lt;code&gt;system.cmp&lt;/code&gt; procs can be used:</source>
          <target state="translated">기본 Nim 정렬 (병합 정렬 구현). 정렬은 안정적이며 최악의 경우 O (n log n)입니다. 현재 구현에서는 반복 병합 소트를 사용하여이를 달성합니다. 길이가 &lt;code&gt;a.len div 2&lt;/code&gt; 인 임시 시퀀스를 사용합니다 . 현재 Nim은 &lt;code&gt;cmp&lt;/code&gt; 에 대해 합리적인 기본 인수를 지원하지 않으므로 직접 제공해야합니다. 그러나 &lt;code&gt;system.cmp&lt;/code&gt; procs를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00a4ee95a1618b2b8a2f4e2f7aab0c17955155c9" translate="yes" xml:space="preserve">
          <source>Default mode is readonly. Raises an &lt;code&gt;IO&lt;/code&gt; exception if the file could not be opened.</source>
          <target state="translated">기본 모드는 읽기 전용입니다. 발생시킵니다 &lt;code&gt;IO&lt;/code&gt; 의 파일을 열 수없는 경우 예외를.</target>
        </trans-unit>
        <trans-unit id="0663ebb5857b5bb7cebfc29afee0cbc83d8917f0" translate="yes" xml:space="preserve">
          <source>Default mode is readonly. Returns true iff the file could be opened.</source>
          <target state="translated">기본 모드는 읽기 전용입니다. 파일을 열 수있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="044708b937264e5230ca38f24417ce73effb53a7" translate="yes" xml:space="preserve">
          <source>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</source>
          <target state="translated">기본 모드는 읽기 전용입니다. 파일을 열 수있는 경우 true를 리턴합니다. 파일을 열 수 없으면 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4974325a7bbead77ecc882824b28920ab85fa946" translate="yes" xml:space="preserve">
          <source>Default mode is readonly. Returns true iff the file could be reopened.</source>
          <target state="translated">기본 모드는 읽기 전용입니다. 파일을 다시 열 수있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f38233b48a1416c37a816a5ed3ac36b2ac620522" translate="yes" xml:space="preserve">
          <source>Default parameters parse lines ending in either Unix(\l) or Windows(\r\l) style on on a line-by-line basis. I.e., not every line needs the same ending. Unlike readLine(File) &amp;amp; lines(File), archaic MacOS9 \r-delimited lines are not supported as a third option for each line. Such archaic MacOS9 files can be handled by passing delim='\r', eat='\0', though.</source>
          <target state="translated">기본 매개 변수는 줄 단위로 Unix (\ l) 또는 Windows (\ r \ l) 스타일로 끝나는 줄을 구문 분석합니다. 즉, 모든 줄에 같은 결말이 필요한 것은 아닙니다. readLine (File) &amp;amp; lines (File)과 달리, 오래된 MacOS9 \ r로 구분 된 행은 각 행의 세 번째 옵션으로 지원되지 않습니다. 이러한 오래된 MacOS9 파일은 delim = '\ r', eat = '\ 0'을 전달하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="c92af4a2fee8fa21e98e9b0a84dda32dce775583" translate="yes" xml:space="preserve">
          <source>Defer statement</source>
          <target state="translated">연기 진술</target>
        </trans-unit>
        <trans-unit id="9954e10c2071b77cdeeee4eff4774d5451047817" translate="yes" xml:space="preserve">
          <source>Define</source>
          <target state="translated">Define</target>
        </trans-unit>
        <trans-unit id="9f935fb2249d726382729a921c798d1fe91d11ee" translate="yes" xml:space="preserve">
          <source>Define a single test case identified by &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;name으로&lt;/em&gt; 식별 된 단일 테스트 케이스를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f527bf122db25b986b5a2e9ef0702b7a34384d0" translate="yes" xml:space="preserve">
          <source>Define the symbol &lt;code&gt;reportMissedDeadlines&lt;/code&gt; to make the GC output whenever it missed a deadline. The reporting will be enhanced and supported by the API in later versions of the collector.</source>
          <target state="translated">기한을 놓칠 때마다 GC 출력을 만들려면 &lt;code&gt;reportMissedDeadlines&lt;/code&gt; 기호를 정의하십시오 . 이후 버전의 수집기에서 API가보고를 향상시키고 지원합니다.</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="1bc8bc5a73886baac76f0365db51f9aa14316fde" translate="yes" xml:space="preserve">
          <source>Delete a directory &lt;code&gt;dir&lt;/code&gt; on the remote FTP server</source>
          <target state="translated">디렉토리 삭제 &lt;code&gt;dir&lt;/code&gt; 원격 FTP 서버에</target>
        </trans-unit>
        <trans-unit id="5c133930bedfdc94a02af9857d8f82eddd60b4cd" translate="yes" xml:space="preserve">
          <source>Delete a file &lt;code&gt;filename&lt;/code&gt; on the remote FTP server</source>
          <target state="translated">원격 FTP 서버에서 파일 파일 &lt;code&gt;filename&lt;/code&gt; 삭제</target>
        </trans-unit>
        <trans-unit id="646c7a3581e35a68e5e4a3bfb1336c7ab5e8c970" translate="yes" xml:space="preserve">
          <source>Delete the header entries associated with &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 와 관련된 헤더 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="9528ca4fead50f5e8c361d2f3c9b7bc9c4ec3f43" translate="yes" xml:space="preserve">
          <source>Delete the key of the specified section.</source>
          <target state="translated">지정된 섹션의 키를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="b12804935b72746fe5cf644c6403d97468fa5f05" translate="yes" xml:space="preserve">
          <source>Deletes &lt;code&gt;obj[key]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj[key]&lt;/code&gt; 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="27904c001140bfc7ee212c552fa81f05ddb62f01" translate="yes" xml:space="preserve">
          <source>Deletes in &lt;em&gt;s&lt;/em&gt; the characters at position &lt;em&gt;first&lt;/em&gt; .. &lt;em&gt;last&lt;/em&gt;.</source>
          <target state="translated">에서 삭제 &lt;em&gt;의&lt;/em&gt; 위치에있는 문자를 &lt;em&gt;첫 번째&lt;/em&gt; .. &lt;em&gt;마지막&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="be41706c95a8ad67d8fdf7ec06fcb395acc028d7" translate="yes" xml:space="preserve">
          <source>Deletes in &lt;em&gt;s&lt;/em&gt; the items at position &lt;em&gt;first&lt;/em&gt; .. &lt;em&gt;last&lt;/em&gt;. This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">에서 삭제 &lt;em&gt;의&lt;/em&gt; 위치에있는 항목을 &lt;em&gt;첫 번째&lt;/em&gt; .. &lt;em&gt;마지막&lt;/em&gt; . 이 수정 &lt;em&gt;의&lt;/em&gt; 자체, 그것은 사본을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76e4578e259f246d107f986f6ac5e8a3ca71cd44" translate="yes" xml:space="preserve">
          <source>Deletes the &lt;code&gt;key&lt;/code&gt; from the table. Returns &lt;code&gt;true&lt;/code&gt;, if the &lt;code&gt;key&lt;/code&gt; existed, and sets &lt;code&gt;val&lt;/code&gt; to the mapping of the key. Otherwise, returns &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;val&lt;/code&gt; is unchanged.</source>
          <target state="translated">테이블 에서 &lt;code&gt;key&lt;/code&gt; 를 삭제 합니다. &lt;code&gt;key&lt;/code&gt; 존재 하면 &lt;code&gt;true&lt;/code&gt; 를 리턴 하고 &lt;code&gt;val&lt;/code&gt; 을 키 맵핑으로 설정합니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 &lt;code&gt;val&lt;/code&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9769950fc676393bfb14e27828598a23095906cb" translate="yes" xml:space="preserve">
          <source>Deletes the specified section and all of its sub keys.</source>
          <target state="translated">지정된 섹션과 모든 하위 키를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="eda35fdccc2f05ab998b9970dc628b067f222e28" translate="yes" xml:space="preserve">
          <source>Deleting a section key in a configuration file.</source>
          <target state="translated">구성 파일에서 섹션 키를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="ce4926b30c0ffa5bf0cd62760347b64dfbe6dd1e" translate="yes" xml:space="preserve">
          <source>Delimit the end of a suite name with &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;::&quot;&lt;/code&gt; 로 스위트 이름의 끝을 구분하십시오 .</target>
        </trans-unit>
        <trans-unit id="88295f9121962875b3b19310f8fb5bcade3fa4bc" translate="yes" xml:space="preserve">
          <source>Delimiters are not part of the returned slice. A final, unterminated line or record is returned just like any other.</source>
          <target state="translated">분리 문자는 리턴 된 슬라이스의 일부가 아닙니다. 마지막으로 끝나지 않은 줄이나 레코드는 다른 것과 마찬가지로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce311abe7bbcb35898a8ac0bf7c2dca01106d8f6" translate="yes" xml:space="preserve">
          <source>Dependency</source>
          <target state="translated">Dependency</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="2a4f466f8700759ceeaf85836326412139917e31" translate="yes" xml:space="preserve">
          <source>Deprecated - use &lt;em&gt;startProcess&lt;/em&gt; directly.</source>
          <target state="translated">더 이상 사용되지 않음 &lt;em&gt;-startProcess를&lt;/em&gt; 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="47a25d0d4712cdcae280ac4b0a25cdbc60973fc1" translate="yes" xml:space="preserve">
          <source>Deprecated alias for poUsePath.</source>
          <target state="translated">poUsePath에 사용되지 않는 별명입니다.</target>
        </trans-unit>
        <trans-unit id="cc01e7b3dae78296cf7590fd6e036bd137aa088e" translate="yes" xml:space="preserve">
          <source>Deprecated since 0.16.2. Use &lt;code&gt;freeAddrInfo&lt;/code&gt; instead.</source>
          <target state="translated">0.16.2부터 사용되지 않습니다. 대신 &lt;code&gt;freeAddrInfo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb95b6ed6f151492e7ced9dc02734612515f0e00" translate="yes" xml:space="preserve">
          <source>Deprecated since version 0.15 since it's so rarely useful.</source>
          <target state="translated">그다지 유용하지 않기 때문에 버전 0.15부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f6099e74cbc3dd750f3f8c3a0780439db19107b" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;em&gt;dumpLisp&lt;/em&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;em&gt;dumpLisp&lt;/em&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a3b50e5a959fd6d1fb9b3d17471bd65e7b6012" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;em&gt;dumpTree&lt;/em&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;em&gt;dumpTree&lt;/em&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="040d702e8cbe0e3efefbf3e6c37eb72ad9795c63" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;em&gt;init&lt;/em&gt; instead. This is not posix compliant, may introduce undefined behavior.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;em&gt;init&lt;/em&gt; 를 사용하십시오 . 이것은 posix를 준수하지 않으므로 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b04dc6c55db8242a8584278ef43d6b7c7c5ddf2" translate="yes" xml:space="preserve">
          <source>Dereference operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">역 참조 연산자 &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbd22b3c27fd2ccfedbd58762a2f1f7cd4630023" translate="yes" xml:space="preserve">
          <source>Describes the type of an IP address</source>
          <target state="translated">IP 주소의 유형을 설명합니다</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="87251b6483b7eb8db1a561509a10c24a6f595b0e" translate="yes" xml:space="preserve">
          <source>Description of some tools that come with the standard distribution.</source>
          <target state="translated">표준 배포판과 함께 제공되는 일부 도구에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="59b035367211a9382930b2a4c13637dbc33c4f32" translate="yes" xml:space="preserve">
          <source>Design</source>
          <target state="translated">Design</target>
        </trans-unit>
        <trans-unit id="d5c53e3e08d26edb69d4944cdf8d485692edcbd8" translate="yes" xml:space="preserve">
          <source>Destruction</source>
          <target state="translated">Destruction</target>
        </trans-unit>
        <trans-unit id="bb4c1fc784dbbda7030fb74a982622da115da2e9" translate="yes" xml:space="preserve">
          <source>Determine the &lt;code&gt;#include&lt;/code&gt;'ed files of a C file:</source>
          <target state="translated">C 파일 의 &lt;code&gt;#include&lt;/code&gt; 파일을 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="548b6cfc5c679e787affe27cf57ca6da7b1d599e" translate="yes" xml:space="preserve">
          <source>Determine which of subset of the exceptions specified by &lt;em&gt;excepts&lt;/em&gt; are currently set.</source>
          <target state="translated">&lt;em&gt;excepts&lt;/em&gt; 로 지정된 예외 중 일부 가 현재 설정 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfaa6cf8bf284fa9df50aea5a8bb1aa0e2c9bffe" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;value&lt;/code&gt; is one of the values inside &lt;code&gt;values&lt;/code&gt;. Comparison is performed without case sensitivity.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 values ​​내의 &lt;code&gt;values&lt;/code&gt; 중 하나 인지 확인 합니다 . 대소 문자 구분없이 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e47cafb565016b1e61daa60db211d9225b92c561" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;code&lt;/code&gt; is a 2xx HTTP status code.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 가 2xx HTTP 상태 코드 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2bd1aed59a99c53cf9cd069b363f937cb4acccd0" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;code&lt;/code&gt; is a 3xx HTTP status code.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 가 3xx HTTP 상태 코드 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7440b81fa6a1c0863c7903d942999144ff6bc0f9" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;code&lt;/code&gt; is a 4xx HTTP status code.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 가 4xx HTTP 상태 코드 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e25bcb13e7fee5e66eb297110b9578d9acf0b1" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;code&lt;/code&gt; is a 5xx HTTP status code.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 가 5xx HTTP 상태 코드 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="edf5c02e54a5ecbc9f01ef7166d08fe2051ff3e3" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;file&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이 존재 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="cc70cbbe0e74a99f871258ec45e5aab2a3586e5a" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;future&lt;/code&gt; completed with an error.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 가 오류와 함께 완료 되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="27d4f23e1e3cd03fc852860d844cd0823e54db02" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;future&lt;/code&gt; has completed.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 가 완료 되었는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="004971d97947b14dd1a345c70fbcec05085e553a" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;lastError&lt;/code&gt; is a disconnection error. Only does this if flags contains &lt;code&gt;SafeDisconn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lastError&lt;/code&gt; 가 연결 끊기 오류 인지 확인합니다 . 플래그에 &lt;code&gt;SafeDisconn&lt;/code&gt; 이 포함 된 경우에만이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4760e3090e27b0e0f30a59cbe20dc8cc549385ba" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;s&lt;/code&gt; has been closed.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 닫혔 는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="54ddcc057005fdcd26dc51c87f32d186f7380d45" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;s&lt;/code&gt; has data waiting to be sent, i.e. whether this socket's sendBuffer contains data.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 데이터가 전송 대기 중인지 여부, 즉이 소켓의 sendBuffer에 데이터가 있는지 여부를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="9a804a4d8d1da251cfd532bcef5fcc1cbeaa7e20" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;s&lt;/code&gt; is connected.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 연결 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="88e0bb657eecf84348741c5571bd7fd13d76e94e" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;s&lt;/code&gt; is connecting.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 연결 중인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dbc5fbb83030ed239ba458c9c843c6ada5d27a91" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;s&lt;/code&gt; is listening for incoming connections.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 들어오는 연결을 수신하고 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9a9db2989a3cfca9733bf51b90bf684eee3c62ff" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;socket&lt;/code&gt; is a SSL socket.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 이 SSL 소켓 인지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="c501d92f92c03ea5d6d002d5e5b344101e25eae5" translate="yes" xml:space="preserve">
          <source>Determines whether &lt;code&gt;socket&lt;/code&gt; is blocking.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 이 차단 중인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b92aa67460bb97677722539055cc8a6bf9c3ea61" translate="yes" xml:space="preserve">
          <source>Determines whether a given path is hidden or not. Returns false if the file doesn't exist. The given path must be accessible from the current working directory of the program.</source>
          <target state="translated">주어진 경로를 숨길 지 여부를 결정합니다. 파일이 존재하지 않으면 false를 반환합니다. 주어진 경로는 프로그램의 현재 작업 디렉토리에서 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0990ddcc2e54903529c1e86242269a56658650e2" translate="yes" xml:space="preserve">
          <source>Determines whether a socket has data buffered.</source>
          <target state="translated">소켓이 데이터를 버퍼링했는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="09ea6698207d44822ff3cc6496caa7658a41ceff" translate="yes" xml:space="preserve">
          <source>Determines whether selector contains a file descriptor.</source>
          <target state="translated">선택기에 파일 설명자가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b8488348d19529de69048bce7d7c71a262d3d7c8" translate="yes" xml:space="preserve">
          <source>Determines whether socket &lt;code&gt;s&lt;/code&gt; is ready to be written to.</source>
          <target state="translated">소켓 여부를 결정 &lt;code&gt;s&lt;/code&gt; 에 기록 할 준비가되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="092818d9f0760dce13c3f35f4c9de0e2ce0a4ae4" translate="yes" xml:space="preserve">
          <source>Determines whether the socket has been closed.</source>
          <target state="translated">소켓이 닫혔는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="430856c5d481f654d8ac28c99ea36efae64be0c1" translate="yes" xml:space="preserve">
          <source>Determines whether the specified &lt;code&gt;FlowVarBase&lt;/code&gt;'s value is available.</source>
          <target state="translated">지정된 &lt;code&gt;FlowVarBase&lt;/code&gt; 값을 사용할 수 있는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4d792c5ff143fb7e44ec9106da12784d951fd67c" translate="yes" xml:space="preserve">
          <source>Different currencies should not be mixed in monetary calculations. Distinct types are a perfect tool to model different currencies:</source>
          <target state="translated">화폐 계산에서 다른 통화를 혼용해서는 안됩니다. 고유 한 유형은 다른 통화를 모델링하는 완벽한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="1603179dcb1ea8bf090ff9d59c3a9f11ff61fc63" translate="yes" xml:space="preserve">
          <source>Different units of time.</source>
          <target state="translated">다른 시간 단위.</target>
        </trans-unit>
        <trans-unit id="07461fdd8bbd77721cfe447edf9e4bd20cbd0023" translate="yes" xml:space="preserve">
          <source>Directory structure</source>
          <target state="translated">디렉토리 구조</target>
        </trans-unit>
        <trans-unit id="5969fa73eaa43f73a5289188c026ff6a45c76d37" translate="yes" xml:space="preserve">
          <source>Directory.</source>
          <target state="translated">Directory.</target>
        </trans-unit>
        <trans-unit id="0cf9219017d35d6c60f2ebb9887a7f1f82a117fd" translate="yes" xml:space="preserve">
          <source>Dirty files are likely to contain errors and they are usually compiled partially only to the point needed to service the idetool request. The compiler discriminates them to ensure that &lt;strong&gt;a)&lt;/strong&gt; they won't be cached and &lt;strong&gt;b)&lt;/strong&gt; they won't invalidate the cached contents of the original module.</source>
          <target state="translated">더티 파일은 오류를 포함 할 가능성이 높으며 일반적으로 idetool 요청을 처리하는 데 필요한 지점으로 만 부분적으로 컴파일됩니다. 컴파일러를 판별 그들은 보장하기 위해 &lt;strong&gt;)을을&lt;/strong&gt; 가 캐시되지 않습니다 및 &lt;strong&gt;B)&lt;/strong&gt; 그들은 원래 모듈의 캐시 내용을 무효화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="022f041c1fe8271f3ebfbaa93f163efde52c8226" translate="yes" xml:space="preserve">
          <source>Disable the crash handler from &lt;code&gt;system.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;system.nim&lt;/code&gt; 에서 충돌 핸들러를 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d0f18ab4aa8ee164f96b32e10617c6c324773e" translate="yes" xml:space="preserve">
          <source>Disable true color.</source>
          <target state="translated">트루 컬러를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f9cfcc118136753cd88279b6ca78e5c91a831b80" translate="yes" xml:space="preserve">
          <source>Disabling certain messages</source>
          <target state="translated">특정 메시지 비활성화</target>
        </trans-unit>
        <trans-unit id="1a6b9915bc2e01d9fa24aba2060fb2247f108935" translate="yes" xml:space="preserve">
          <source>Discard statement</source>
          <target state="translated">진술 폐기</target>
        </trans-unit>
        <trans-unit id="8e1b8d01990ec0eea6f2dfe6e450c0320a04704e" translate="yes" xml:space="preserve">
          <source>Discarding futures</source>
          <target state="translated">미래 폐기</target>
        </trans-unit>
        <trans-unit id="4d4c8e8b5b56af988da876772ec7856ae8af3764" translate="yes" xml:space="preserve">
          <source>Disconnects from the SMTP server and closes the socket.</source>
          <target state="translated">SMTP 서버에서 연결을 끊고 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a98d0ab4691ead58f53524818054ebd1c3d152b6" translate="yes" xml:space="preserve">
          <source>Displays compilation of all the compiled files, including those imported by other modules or through the &lt;a href=&quot;#compile-pragma&quot;&gt;compile pragma&lt;/a&gt;. This is the default level.</source>
          <target state="translated">다른 모듈 또는 &lt;a href=&quot;#compile-pragma&quot;&gt;컴파일 pragma를&lt;/a&gt; 통해 가져온 파일을 포함하여 모든 컴파일 된 파일의 컴파일을 표시 합니다. 이것이 기본 수준입니다.</target>
        </trans-unit>
        <trans-unit id="cf27f204e53592da8a41ef882d4b3025ae4982fe" translate="yes" xml:space="preserve">
          <source>Displays compilation statistics, enumerates the dynamic libraries that will be loaded by the final binary and dumps to standard output the result of applying &lt;a href=&quot;filters&quot;&gt;a filter to the source code&lt;/a&gt; if any filter was used during compilation.</source>
          <target state="translated">컴파일 통계를 표시하고 최종 바이너리에 의해로드 될 동적 라이브러리를 열거하고 컴파일 중에 필터가 사용 된 경우 &lt;a href=&quot;filters&quot;&gt;소스 코드에 필터를&lt;/a&gt; 적용한 결과를 표준 출력으로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="985836dae98d2f5d2b7e282391b9efede9138024" translate="yes" xml:space="preserve">
          <source>Displays the timezone offset from UTC.</source>
          <target state="translated">UTC로부터 시간대 오프셋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ccf7ead01d442ec24cd6acda659368e0e39d1ab2" translate="yes" xml:space="preserve">
          <source>Distinct type</source>
          <target state="translated">고유 한 유형</target>
        </trans-unit>
        <trans-unit id="00c68bf4be715a3cf7fd52af1b931957da3c8703" translate="yes" xml:space="preserve">
          <source>Distro/OS detection. For convenience the required &lt;code&gt;Distribution.&lt;/code&gt; qualifier is added to the enum value.</source>
          <target state="translated">배포판 / OS 감지. 편의상 필요한 &lt;code&gt;Distribution.&lt;/code&gt; 한정자가 열거 형 값에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0f3fb13e4f3fe0fd4f7a4a067437f8e120731633" translate="yes" xml:space="preserve">
          <source>Divide &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;y&lt;/em&gt; in place.</source>
          <target state="translated">나누기 &lt;em&gt;(X)&lt;/em&gt; 에 의해 &lt;em&gt;Y&lt;/em&gt; 위치이다.</target>
        </trans-unit>
        <trans-unit id="47be64b7e56f21beb87652d8ab0fc4dfdc80ed88" translate="yes" xml:space="preserve">
          <source>Divide &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">나누기 &lt;em&gt;(X)&lt;/em&gt; 에 의해 &lt;em&gt;Y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e561da24d048dbc37c8241f1892f682367b7dcae" translate="yes" xml:space="preserve">
          <source>Divide complex &lt;em&gt;x&lt;/em&gt; by float &lt;em&gt;y&lt;/em&gt; in place.</source>
          <target state="translated">복소수 &lt;em&gt;x&lt;/em&gt; 를 플로트 &lt;em&gt;y&lt;/em&gt; 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="59fd2ce109c77255dd7a9d40e66ee5809ee519fd" translate="yes" xml:space="preserve">
          <source>Divide complex &lt;em&gt;x&lt;/em&gt; by float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">복소수 &lt;em&gt;x&lt;/em&gt; 를 float &lt;em&gt;y로 나눕니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eb7094fc793d7ff9c2dcdb5867b6a21e30b1da10" translate="yes" xml:space="preserve">
          <source>Divide float &lt;em&gt;x&lt;/em&gt; by complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">float &lt;em&gt;x&lt;/em&gt; 를 complex &lt;em&gt;y로 나눕니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="00bcf1dd7590a3417d37303b0fdecc5327742701" translate="yes" xml:space="preserve">
          <source>Divide int &lt;em&gt;x&lt;/em&gt; by Rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">int &lt;em&gt;x&lt;/em&gt; 를 유리수 &lt;em&gt;y로 나눕니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="401af8fc3ad55d05186996b894ff3f64b23f5654" translate="yes" xml:space="preserve">
          <source>Divide rational &lt;em&gt;x&lt;/em&gt; by int &lt;em&gt;y&lt;/em&gt; in place.</source>
          <target state="translated">합리적인 &lt;em&gt;x&lt;/em&gt; 를 int &lt;em&gt;y&lt;/em&gt; 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="58655b52bb7d7c0d630f44f6da666825adfffe43" translate="yes" xml:space="preserve">
          <source>Divide rational &lt;em&gt;x&lt;/em&gt; by int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 를 int &lt;em&gt;y로 나눕니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e0464d7632a87c3eb12b30bb3d5c2d799dea995d" translate="yes" xml:space="preserve">
          <source>Divide rationals &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;y&lt;/em&gt; in place.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 를 &lt;em&gt;y&lt;/em&gt; 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="933c90ca6645f4618e52caf970df26f662a363a2" translate="yes" xml:space="preserve">
          <source>Divide rationals &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x&lt;/em&gt; 를 &lt;em&gt;y&lt;/em&gt; 로 &lt;em&gt;나눕니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c55b3fcf0307520e69ff919f2af69043a887cc27" translate="yes" xml:space="preserve">
          <source>Divides in place a floating point number</source>
          <target state="translated">부동 소수점 숫자를 제자리로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c10b77ff5ae5207804b93a18058984ec3dd18805" translate="yes" xml:space="preserve">
          <source>Division by zero: divisor is zero and dividend is a finite nonzero number, for example 1.0/0.0.</source>
          <target state="translated">0으로 나누기 : 제수는 0이고 피제수는 0이 아닌 유한 한 숫자입니다 (예 : 1.0 / 0.0).</target>
        </trans-unit>
        <trans-unit id="9485d84eb22396b73e1cead6aef0f5ba44fff659" translate="yes" xml:space="preserve">
          <source>Divisor is zero and dividend is a finite nonzero number.</source>
          <target state="translated">제수는 0이고 배당은 0이 아닌 유한 한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="8f59767d0feb20f56ba6390675c09040039496ec" translate="yes" xml:space="preserve">
          <source>Do notation</source>
          <target state="translated">표기법</target>
        </trans-unit>
        <trans-unit id="6bd2a1cbf993386f67ff1437e37d966de7656316" translate="yes" xml:space="preserve">
          <source>Docstring for the symbol if available or the empty string. To differentiate the docstring from end of answer in server mode, the docstring is always provided enclosed in double quotes, and if the docstring spans multiple lines, all following lines of the docstring will start with a blank space to align visually with the starting quote.</source>
          <target state="translated">사용 가능한 경우 기호의 문자열 또는 빈 문자열 서버 모드에서 docstring을 응답 끝과 구별하기 위해 docstring은 항상 큰 따옴표로 묶여 제공되며 docstring이 여러 줄에 걸쳐 있으면 docstring의 모든 다음 줄은 공백으로 시작하여 시작 따옴표와 시각적으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="affd2a6092e73a6459a751ad697f3bbf7be7a8bf" translate="yes" xml:space="preserve">
          <source>Docstring for the symbol if available or the empty string. To differentiate the docstring from end of answer, the docstring is always provided enclosed in double quotes, and if the docstring spans multiple lines, all following lines of the docstring will start with a blank space to align visually with the starting quote.</source>
          <target state="translated">사용 가능한 경우 기호의 문자열 또는 빈 문자열 docstring을 응답 끝과 구별하기 위해 docstring은 항상 큰 따옴표로 묶여 제공되며 docstring이 여러 줄에 걸쳐 있으면 docstring의 다음 줄은 모두 공백으로 시작하여 시작 따옴표와 시각적으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c8a1c8fb291e4e88d92472a780cce3feb80a95" translate="yes" xml:space="preserve">
          <source>Document Types</source>
          <target state="translated">문서 종류</target>
        </trans-unit>
        <trans-unit id="7ceb1bc39c07e6f3e294a5782801c6bc2eed4a03" translate="yes" xml:space="preserve">
          <source>Documentation Comments</source>
          <target state="translated">설명서 주석</target>
        </trans-unit>
        <trans-unit id="e865c7ef5e7ddaedaa17748ddbe9fd552f6c342b" translate="yes" xml:space="preserve">
          <source>Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.</source>
          <target state="translated">문서 주석은 토큰입니다. 그것들은 구문 트리에 속하기 때문에 입력 파일의 특정 위치에서만 허용됩니다! 이 기능은 더 간단한 문서 생성기를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="a56767c0462e8ec9b006459313198af2cb0ca301" translate="yes" xml:space="preserve">
          <source>Documentation generator</source>
          <target state="translated">문서 생성기</target>
        </trans-unit>
        <trans-unit id="8a975b5f64977e0471ef78a594968f8d38e9c4c2" translate="yes" xml:space="preserve">
          <source>Does not create parent directories (fails if parent does not exist). Returns &lt;em&gt;true&lt;/em&gt; if the directory already exists, and &lt;em&gt;false&lt;/em&gt; otherwise.</source>
          <target state="translated">부모 디렉토리를 만들지 않습니다 (부모가 없으면 실패). 디렉토리가 이미 존재하면 &lt;em&gt;true를&lt;/em&gt; , 그렇지 않으면 &lt;em&gt;false를&lt;/em&gt; 리턴 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d51a209bab72a8621c6573b2ed74560555af6343" translate="yes" xml:space="preserve">
          <source>Don't use this proc for serialization, the representation may change at any moment and values are not escaped. Example:</source>
          <target state="translated">직렬화에이 proc을 사용하지 마십시오. 표현은 언제든지 변경 될 수 있으며 값이 이스케이프되지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="fec78f1f169db0654a11f86d047bbd31b8722221" translate="yes" xml:space="preserve">
          <source>Double-hash (&lt;code&gt;##&lt;/code&gt;) comments in the code actually have their own format, using &lt;code&gt;strVal&lt;/code&gt; to get and set the comment text. Single-hash (&lt;code&gt;#&lt;/code&gt;) comments are ignored.</source>
          <target state="translated">코드에서 이중 해시 ( &lt;code&gt;##&lt;/code&gt; ) 주석은 실제로 &lt;code&gt;strVal&lt;/code&gt; 을 사용 하여 주석 텍스트를 가져오고 설정하는 자체 형식을 갖습니다 . 단일 해시 ( &lt;code&gt;#&lt;/code&gt; ) 주석은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="81b5c43dd872b5c09dff18e92fdbc184ac7fdfa9" translate="yes" xml:space="preserve">
          <source>Download of files.</source>
          <target state="translated">파일 다운로드</target>
        </trans-unit>
        <trans-unit id="7be3be9ea58619176e7fff0589c33e5526dd9493" translate="yes" xml:space="preserve">
          <source>Downloads &lt;code&gt;file&lt;/code&gt; and saves it to &lt;code&gt;dest&lt;/code&gt;. The &lt;code&gt;EvRetr&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the download is finished. The event's &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 다운로드 하여 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다 . &lt;code&gt;EvRetr&lt;/code&gt; 의 이벤트는 지정된에 전달 &lt;code&gt;handleEvent&lt;/code&gt; 다운로드가 완료 될 때 기능. 이벤트의 &lt;code&gt;filename&lt;/code&gt; 필드는 &lt;code&gt;file&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6af892c013f61baa43bb291ad8a209106690db46" translate="yes" xml:space="preserve">
          <source>Downloads &lt;code&gt;file&lt;/code&gt; and saves it to &lt;code&gt;dest&lt;/code&gt;. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvRetr&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the download is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 다운로드 하여 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다 . 다운로드 진행 상황을 보려면이 기능을 비동기 적으로 사용하는 것이 좋습니다. &lt;code&gt;EvRetr&lt;/code&gt; 의 이벤트는 지정된에 전달 &lt;code&gt;handleEvent&lt;/code&gt; 다운로드가 완료 될 때 기능과 &lt;code&gt;filename&lt;/code&gt; 필드와 동일합니다 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59e7fa384f3d7f9f32ba0a373a21a9607615ddf8" translate="yes" xml:space="preserve">
          <source>Downloads &lt;code&gt;url&lt;/code&gt; and saves it to &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; 을 다운로드 하여 &lt;code&gt;filename&lt;/code&gt; 으로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="b817aed53e0fcdfeab19c046fbdace4e6e4b81ab" translate="yes" xml:space="preserve">
          <source>Downloads &lt;code&gt;url&lt;/code&gt; and saves it to &lt;code&gt;outputFilename&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; 다운로드 하여 &lt;code&gt;outputFilename&lt;/code&gt; 에 저장합니다</target>
        </trans-unit>
        <trans-unit id="81418674c8c7701fbe6e25d2a4956f04ef4b3c30" translate="yes" xml:space="preserve">
          <source>Due to an implementation detail you can call this proc on variables which have not been initialized yet. The proc will return zero as the length then. Example:</source>
          <target state="translated">구현 세부 사항으로 인해 아직 초기화되지 않은 변수에 대해이 proc을 호출 할 수 있습니다. proc은 길이로 0을 반환합니다. 예:</target>
        </trans-unit>
        <trans-unit id="68d3cc5c647d9856c415b767b90eff09217dbe14" translate="yes" xml:space="preserve">
          <source>Due to implementation restrictions thread local variables cannot be initialized within the &lt;code&gt;var&lt;/code&gt; section. (Every thread local variable needs to be replicated at thread creation.)</source>
          <target state="translated">구현 제한으로 인해 스레드 로컬 변수는 &lt;code&gt;var&lt;/code&gt; 섹션 내에서 초기화 될 수 없습니다 . 스레드 생성시 모든 스레드 로컬 변수를 복제해야합니다.</target>
        </trans-unit>
        <trans-unit id="a06e95fadd5c749a8379257958c1fe02d0831a57" translate="yes" xml:space="preserve">
          <source>Due to intrinsic differences between operating systems, the information contained by the returned &lt;em&gt;FileInfo&lt;/em&gt; structure will be slightly different across platforms, and in some cases, incomplete or inaccurate.</source>
          <target state="translated">운영 체제 간의 본질적인 차이로 인해 반환 된 &lt;em&gt;FileInfo&lt;/em&gt; 구조에 포함 된 정보 는 플랫폼마다 약간 씩 다르며 경우에 따라 불완전하거나 정확하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a064c856b9c7f8c428db04200ec49c55ade9a25" translate="yes" xml:space="preserve">
          <source>Dumps statistics about the Garbage Collector.</source>
          <target state="translated">가비지 콜렉터에 대한 통계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c5735569bde97160505df3253fe1d6e7b9929434" translate="yes" xml:space="preserve">
          <source>Dumps the content of an expression, useful for debugging. It accepts any expression and prints a textual representation of the tree representing the expression - as it would appear in source code - together with the value of the expression.</source>
          <target state="translated">디버깅에 유용한 표현식의 내용을 덤프합니다. 모든 표현식을 허용하며 표현식을 나타내는 트리의 텍스트 표현을 소스 코드에 표시되는 것처럼 표현식의 값과 함께 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f0a199eef233da4a31218573e216bc2bd3610d7c" translate="yes" xml:space="preserve">
          <source>During compilation of the source code we should see the following lines in the output (again, since this is a macro, compilation is enough, you don't have to run any binary):</source>
          <target state="translated">소스 코드를 컴파일하는 동안 출력에 다음 줄이 표시됩니다 (다시 말해서 매크로이므로 컴파일하면 충분하므로 바이너리를 실행할 필요가 없습니다).</target>
        </trans-unit>
        <trans-unit id="2cb4f2db39a923075e1426b02f664b6eee0ae4de" translate="yes" xml:space="preserve">
          <source>Dynamic calls. DevkitPro libraries have no dlopen/dlclose functions.</source>
          <target state="translated">동적 통화. DevkitPro 라이브러리에는 dlopen / dlclose 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="612d35050e691a1a2b9f22fe6b8f2fde9cb8f9d1" translate="yes" xml:space="preserve">
          <source>Dynamic dispatch</source>
          <target state="translated">동적 디스패치</target>
        </trans-unit>
        <trans-unit id="05a259530e41429744f111df0421f50ba2407d45" translate="yes" xml:space="preserve">
          <source>Dynamic method resolution can be inhibited via the builtin &lt;span id=&quot;systemdotproccall_1&quot;&gt;system.procCall&lt;/span&gt;. This is somewhat comparable to the &lt;span id=&quot;super_1&quot;&gt;super&lt;/span&gt; keyword that traditional OOP languages offer.</source>
          <target state="translated">내장 된 &lt;span id=&quot;systemdotproccall_1&quot;&gt;system.procCall을&lt;/span&gt; 통해 동적 메소드 분석을 막을 수 있습니다 . 이것은 전통적인 OOP 언어가 제공 하는 &lt;span id=&quot;super_1&quot;&gt;슈퍼&lt;/span&gt; 키워드 와 다소 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="488b9f75aa25e35ff8f7eaba651ce43a61e65595" translate="yes" xml:space="preserve">
          <source>Dynamically retrieving fields from JSON</source>
          <target state="translated">JSON에서 동적으로 필드 검색</target>
        </trans-unit>
        <trans-unit id="856725a690441d81bbc02a839d0b73e988e3905d" translate="yes" xml:space="preserve">
          <source>Dynamically typed wrapper around a JavaScript object.</source>
          <target state="translated">JavaScript 객체 주위에 동적으로 입력 된 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="62679a570d8f79b420f4acbc59b384bebec763f8" translate="yes" xml:space="preserve">
          <source>Dynlib pragma for export</source>
          <target state="translated">수출을위한 Dynlib pragma</target>
        </trans-unit>
        <trans-unit id="d60375f8c1b519a260879d01fcc8988ed6c1c997" translate="yes" xml:space="preserve">
          <source>Dynlib pragma for import</source>
          <target state="translated">수입을위한 Dynlib pragma</target>
        </trans-unit>
        <trans-unit id="fdb8546dcb8fc0bb9da0b05ea78668537102f7b2" translate="yes" xml:space="preserve">
          <source>DynlibOverride</source>
          <target state="translated">DynlibOverride</target>
        </trans-unit>
        <trans-unit id="50c321f9472c4d4c9346c89122e7ef47659f0800" translate="yes" xml:space="preserve">
          <source>Each builds on top of the layers below it. The selectors module is an abstraction for the various system &lt;code&gt;select()&lt;/code&gt; mechanisms such as epoll or kqueue. If you wish you can use it directly, and some people have done so &lt;a href=&quot;http://goran.krampe.se/2014/10/25/nim-socketserver/&quot;&gt;successfully&lt;/a&gt;. But you must be aware that on Windows it only supports &lt;code&gt;select()&lt;/code&gt;.</source>
          <target state="translated">각각은 그 아래 레이어 위에 빌드됩니다. 선택기 모듈은 epoll 또는 kqueue와 같은 다양한 시스템 &lt;code&gt;select()&lt;/code&gt; 메커니즘에 대한 추상화입니다 . 원하는 경우 직접 사용할 수 있으며 일부 사람들은이를 &lt;a href=&quot;http://goran.krampe.se/2014/10/25/nim-socketserver/&quot;&gt;성공적으로&lt;/a&gt; 수행 했습니다 . 그러나 Windows에서는 &lt;code&gt;select()&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="55aaf45bd708c3bfb722e9d2c6eacac3fa05e904" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;addQuitProc&lt;/code&gt; registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). &lt;code&gt;addQuitProc&lt;/code&gt; raises an EOutOfIndex exception if &lt;code&gt;QuitProc&lt;/code&gt; cannot be registered.</source>
          <target state="translated">&lt;code&gt;addQuitProc&lt;/code&gt; 를 호출 할 때 마다 다른 종료 절차가 등록됩니다. 최대 30 개의 절차를 등록 할 수 있습니다. 그것들은 선착순으로 실행됩니다 (즉, 마지막으로 등록 된 기능이 가장 먼저 실행됩니다). &lt;code&gt;addQuitProc&lt;/code&gt; 등록 할 수 없으면 addQuitProc 가 EOutOfIndex 예외를 발생 &lt;code&gt;QuitProc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="776ab18061da1c2db02c658f9e63cbc92d5d6a98" translate="yes" xml:space="preserve">
          <source>Each cell has a header consisting of a RC and a pointer to its type descriptor. However the program does not know about these, so they are placed at negative offsets. In the GC code the type &lt;code&gt;PCell&lt;/code&gt; denotes a pointer decremented by the right offset, so that the header can be accessed easily. It is extremely important that &lt;code&gt;pointer&lt;/code&gt; is not confused with a &lt;code&gt;PCell&lt;/code&gt; as this would lead to a memory corruption.</source>
          <target state="translated">각 셀에는 RC로 구성된 헤더와 해당 유형 설명자에 대한 포인터가 있습니다. 그러나 프로그램은 이에 대해 알지 못하므로 음수 오프셋에 배치됩니다. GC 코드에서 &lt;code&gt;PCell&lt;/code&gt; 유형 은 오른쪽 오프셋으로 감소 된 포인터를 나타내므로 헤더에 쉽게 액세스 할 수 있습니다. &lt;code&gt;pointer&lt;/code&gt; 가 &lt;code&gt;PCell&lt;/code&gt; 과 혼동되지 않아야 메모리 손상이 발생할 수 있으므로 매우 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="f169302282df0e0c677e88af5b44a815e9972064" translate="yes" xml:space="preserve">
          <source>Each condition (&lt;code&gt;expr&lt;/code&gt;) has to be a constant expression (of type &lt;code&gt;bool&lt;/code&gt;).</source>
          <target state="translated">각 조건 ( &lt;code&gt;expr&lt;/code&gt; )은 상수 식 ( &lt;code&gt;bool&lt;/code&gt; 유형 ) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c5f18bf9edfdee8494149e1bf1280ccbded6d1b" translate="yes" xml:space="preserve">
          <source>Each condition must be a constant expression since it is evaluated by the compiler.</source>
          <target state="translated">각 조건은 컴파일러에 의해 평가되므로 상수 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ca9b2d8812c1052b1bd208e798293ecf5422595d" translate="yes" xml:space="preserve">
          <source>Each exception has to inherit from &lt;em&gt;Exception&lt;/em&gt;. See the full &lt;a href=&quot;manual#exception-handling-exception-hierarchy&quot;&gt;exception hierarchy&lt;/a&gt;.</source>
          <target state="translated">각 예외는 &lt;em&gt;Exception&lt;/em&gt; 을 상속해야 합니다. 전체 &lt;a href=&quot;manual#exception-handling-exception-hierarchy&quot;&gt;예외 계층 구조를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8795144c72e58f2853040daf356daa6a3a1f08c" translate="yes" xml:space="preserve">
          <source>Each hint can be activated individually with &lt;code&gt;--hint[NAME]:on|off&lt;/code&gt; or in a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="translated">각 힌트는 &lt;code&gt;--hint[NAME]:on|off&lt;/code&gt; 또는 &lt;code&gt;push&lt;/code&gt; pragma 를 사용하여 개별적으로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dba3186d05b73e92a36305f51916ec16a9b0422" translate="yes" xml:space="preserve">
          <source>Each line that does not start with the meta character (ignoring leading whitespace) is converted to a string literal that is added to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">메타 문자로 시작하지 않는 (행의 공백은 무시) 각 행은 문자열 리터럴로 변환되어 &lt;code&gt;result&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="336ae7eb96b67805237df64771f2e59017fa723d" translate="yes" xml:space="preserve">
          <source>Each module has a special magic constant &lt;code&gt;isMainModule&lt;/code&gt; that is true if the module is compiled as the main file. This is very useful to embed tests within the module as shown by the above example.</source>
          <target state="translated">각 모듈에는 특수 매직 상수 &lt;code&gt;isMainModule&lt;/code&gt; 이 있으며, 모듈이 기본 파일로 컴파일되면 true입니다. 이것은 위의 예제에 표시된 것처럼 모듈 내에 테스트를 포함시키는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="74b6e0bb402a2281485388b5cef2a2dbe1d7bff8" translate="yes" xml:space="preserve">
          <source>Each occurrence of &lt;em&gt;sub&lt;/em&gt; has to be surrounded by word boundaries (comparable to &lt;code&gt;\\w&lt;/code&gt; in regular expressions), otherwise it is not replaced.</source>
          <target state="translated">&lt;em&gt;sub의&lt;/em&gt; 각 발생은 단어 경계 ( 정규 표현식에서 &lt;code&gt;\\w&lt;/code&gt; 와 비교할 수 있음)로 둘러싸 야합니다 . 그렇지 않으면 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dc521c7d1ecb10c8d0cb27af3a35d2a73de8e54" translate="yes" xml:space="preserve">
          <source>Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.</source>
          <target state="translated">각 이스케이프 시퀀스 쌍은 완전한 문자 세트를 두 개의 분리 된 세트로 분할합니다. 주어진 문자는 각 쌍 중 하나만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2798cd0af8dc2b229ac3657798cbcfe39f0e2e62" translate="yes" xml:space="preserve">
          <source>Each value in the array gives information about a specific unit of time, for example &lt;code&gt;result[Days]&lt;/code&gt; gives a count of days.</source>
          <target state="translated">배열의 각 값은 특정 시간 단위에 대한 정보를 제공합니다. 예를 들어 &lt;code&gt;result[Days]&lt;/code&gt; 는 일 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="334a2ced35643b727dc74a2b4d5929156f67651e" translate="yes" xml:space="preserve">
          <source>Each warning can be activated individually with &lt;code&gt;--warning[NAME]:on|off&lt;/code&gt; or in a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="translated">각 경고는 &lt;code&gt;--warning[NAME]:on|off&lt;/code&gt; 또는 &lt;code&gt;push&lt;/code&gt; pragma 를 사용하여 개별적으로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="182eb105cb39c089eb1a6cb198b242a6bc8197af" translate="yes" xml:space="preserve">
          <source>EachIdentIsTuple</source>
          <target state="translated">EachIdentIsTuple</target>
        </trans-unit>
        <trans-unit id="4e5c9f473381f3fb5761e0382ebc9ae5ed1f4a90" translate="yes" xml:space="preserve">
          <source>Echoes styles arguments to stdout using &lt;code&gt;styledWriteLine&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;styledWriteLine&lt;/code&gt; 을 사용하여 스타일 인수를 stdout으로 에코합니다 .</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="7bd83ec4ed0ca781743b20854734c95169abfbc0" translate="yes" xml:space="preserve">
          <source>Effect describing a read IO operation.</source>
          <target state="translated">읽기 IO 작업을 설명하는 효과.</target>
        </trans-unit>
        <trans-unit id="8cf0e5c235365c0df79d3069265545c9b1dee897" translate="yes" xml:space="preserve">
          <source>Effect describing a write IO operation.</source>
          <target state="translated">쓰기 IO 작업을 설명하는 효과.</target>
        </trans-unit>
        <trans-unit id="31f2bfea355139e3e9e22b99d6278d277f73df7d" translate="yes" xml:space="preserve">
          <source>Effect describing an executing IO operation.</source>
          <target state="translated">실행 IO 작업을 설명하는 효과.</target>
        </trans-unit>
        <trans-unit id="0ff13f219cd501e9f019a49db523861036e244ba" translate="yes" xml:space="preserve">
          <source>Effect system</source>
          <target state="translated">효과 시스템</target>
        </trans-unit>
        <trans-unit id="23bb6b343bea5538c8faec4ca171c4196b53f6f6" translate="yes" xml:space="preserve">
          <source>Effects pragma</source>
          <target state="translated">효과 pragma</target>
        </trans-unit>
        <trans-unit id="e823398a4f7891c2d5ec8900dbdfdb32b4773e9f" translate="yes" xml:space="preserve">
          <source>Else: Use a generic proc/iterator, if possible.</source>
          <target state="translated">그렇지 않은 경우 : 가능한 경우 일반 proc / iterator를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="67b4f087ef7af9792bb49c6da895bc3e222818fb" translate="yes" xml:space="preserve">
          <source>Else: Use a macro.</source>
          <target state="translated">그렇지 않으면 : 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7cea9c6c6c0e3e71c3024c7d2a5662ce06f45196" translate="yes" xml:space="preserve">
          <source>Else: Use a template, if possible.</source>
          <target state="translated">그렇지 않으면 : 가능하면 템플릿을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0d03a360b0cb309d8ddab5a3e699532d6d036345" translate="yes" xml:space="preserve">
          <source>Embedding Nim code</source>
          <target state="translated">님 코드 임베드</target>
        </trans-unit>
        <trans-unit id="963a7e6e94be0ac23f53b0f0df85fce3746851bc" translate="yes" xml:space="preserve">
          <source>Emit pragma</source>
          <target state="translated">프라 그마 방출</target>
        </trans-unit>
        <trans-unit id="fa9fc5308602902adcb2b4168c008aabc529239c" translate="yes" xml:space="preserve">
          <source>Emulated thread vars are global.</source>
          <target state="translated">에뮬레이트 된 스레드 변수는 전역 적입니다.</target>
        </trans-unit>
        <trans-unit id="d2e677bc187b965f194ccfa9377784fced1c470f" translate="yes" xml:space="preserve">
          <source>Enable true color.</source>
          <target state="translated">트루 컬러를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="9052f6b509949db9c2a3effc890b2a6c9e48284d" translate="yes" xml:space="preserve">
          <source>Enables OpenSSL support for the sockets module.</source>
          <target state="translated">소켓 모듈에 대한 OpenSSL 지원을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="96b622c3f2b0c249a2a9abd87ac899c69c9ecb8a" translate="yes" xml:space="preserve">
          <source>Enables memory profiling for the native GC.</source>
          <target state="translated">기본 GC에 대한 메모리 프로파일 링을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f8633c619b634ffa027448ea481b7d0093ef9d6e" translate="yes" xml:space="preserve">
          <source>Enables support of Nim's GC for &lt;em&gt;soft&lt;/em&gt; realtime systems. See the documentation of the &lt;a href=&quot;gc&quot;&gt;gc&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;em&gt;소프트&lt;/em&gt; 실시간 시스템에 대한 Nim의 GC를 지원 합니다. 자세한 내용은 &lt;a href=&quot;gc&quot;&gt;gc&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c3ff6df0146db2d8f131bb539905ccce63e9217" translate="yes" xml:space="preserve">
          <source>Enables the caching of leaves. This reduces the memory footprint at the cost of runtime efficiency.</source>
          <target state="translated">잎을 캐싱 할 수 있습니다. 이는 런타임 효율을 희생시키면서 메모리 풋 프린트를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="fdf56a868f24cb7f08adaaac7d560795f5b0d0fe" translate="yes" xml:space="preserve">
          <source>Encodes a URL according to RFC3986.</source>
          <target state="translated">RFC3986에 따라 URL을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="25eba2103c20a20b4f854b80459e39a11e6c00fa" translate="yes" xml:space="preserve">
          <source>Encodes a value to be XML safe:</source>
          <target state="translated">XML 안전을 위해 값을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="154be40dfe5d0a56bc2fc4f3b006b1ffa31e7e17" translate="yes" xml:space="preserve">
          <source>Encoding data</source>
          <target state="translated">데이터 인코딩</target>
        </trans-unit>
        <trans-unit id="4042806d682d8a45bda241197080e343a1c23e5f" translate="yes" xml:space="preserve">
          <source>English word</source>
          <target state="translated">영어 단어</target>
        </trans-unit>
        <trans-unit id="f2bba7a713c8df3215f1bd35e964187dd2b8779d" translate="yes" xml:space="preserve">
          <source>Enumeration and object types may only be defined within a &lt;code&gt;type&lt;/code&gt; statement.</source>
          <target state="translated">열거 및 객체 유형은 &lt;code&gt;type&lt;/code&gt; 문 내에서만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de95348406525f80d9c73a93317163dea26a0952" translate="yes" xml:space="preserve">
          <source>Enumeration specifying a path component.</source>
          <target state="translated">경로 구성 요소를 지정하는 열거.</target>
        </trans-unit>
        <trans-unit id="3e2bf03a268096db9df6b0465b51da16d0d1910a" translate="yes" xml:space="preserve">
          <source>Enumeration types</source>
          <target state="translated">열거 형</target>
        </trans-unit>
        <trans-unit id="7b46585d986b63e5c84f089146aa1e206d252ae8" translate="yes" xml:space="preserve">
          <source>Enumeration types define a new type whose values consist of the ones specified. The values are ordered. Example:</source>
          <target state="translated">열거 유형은 값이 지정된 유형으로 구성된 새 유형을 정의합니다. 값이 정렬됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="413e9110db4f37157b581483ed8d7133f5021d89" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerations</target>
        </trans-unit>
        <trans-unit id="3d57504f6fc8184f9917dab72bb8b6f0fc65ea4a" translate="yes" xml:space="preserve">
          <source>Enumerations, integer types, &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; (and subranges) are called ordinal types. Ordinal types have quite a few special operations:</source>
          <target state="translated">열거 형, 정수형, &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;bool&lt;/code&gt; (및 하위 범위)을 서수형이라고합니다. 서수 유형에는 몇 가지 특수 연산이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6cfd98e1a208ad6316665ea88cb2b668e0700b" translate="yes" xml:space="preserve">
          <source>Equality for ordered sets.</source>
          <target state="translated">주문 된 세트의 평등</target>
        </trans-unit>
        <trans-unit id="ecccc8ce13010bacb868722464db64d58f6d7452" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;acceptAddr&lt;/code&gt; but doesn't return the address, only the socket.</source>
          <target state="translated">&lt;code&gt;acceptAddr&lt;/code&gt; 와 동일 하지만 주소를 반환하지 않고 소켓 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fc024b1d434cedadc23ef57e6c74217e4e0894e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sockets.accept&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sockets.accept&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="697bc63b6dcba7e34e13299df63fb1414234ed36" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sockets.acceptAddr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sockets.acceptAddr&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0604774d60ab64b389eba4998686a49917f37f1d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sockets.acceptAddr&lt;/code&gt;. This procedure should be called in a &lt;code&gt;handleAccept&lt;/code&gt; event handler &lt;strong&gt;only&lt;/strong&gt; once.</source>
          <target state="translated">&lt;code&gt;sockets.acceptAddr&lt;/code&gt; 와 같습니다 . 이 절차는 호출해야 &lt;code&gt;handleAccept&lt;/code&gt; 의 이벤트 핸들러 &lt;strong&gt;단&lt;/strong&gt; 한 번.</target>
        </trans-unit>
        <trans-unit id="a95bf8dedb35cdd899a5d6e172bb67456de99695" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sockets.bindAddr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sockets.bindAddr&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7599fc48268927adf6e46e7be9046635db26a2cf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sockets.listen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sockets.listen&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a0e3f64c59fa3fafa886a4a11af79a5f9f6c90b9" translate="yes" xml:space="preserve">
          <source>Era: AD or BC</source>
          <target state="translated">시대 : AD 또는 BC</target>
        </trans-unit>
        <trans-unit id="b6ed88865d1b3cdebc3673b10f131985f6aae0e3" translate="yes" xml:space="preserve">
          <source>Erases the entire current line.</source>
          <target state="translated">현재 줄 전체를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="5ca334765c9f492fac0cffe803f2502e8b9af5c0" translate="yes" xml:space="preserve">
          <source>Erases the screen with the background colour and moves the cursor to home.</source>
          <target state="translated">배경색으로 화면을 지우고 커서를 집으로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="0db72e172d24bd8ce3e4907133558b491951978e" translate="yes" xml:space="preserve">
          <source>Escape sequence</source>
          <target state="translated">탈출 순서</target>
        </trans-unit>
        <trans-unit id="0d71e463bc98e6b713f02475b527b066e7ed293d" translate="yes" xml:space="preserve">
          <source>Escapes a string &lt;em&gt;s&lt;/em&gt;. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;system.addEscapedChar&lt;/a&gt; for the escaping scheme.</source>
          <target state="translated">문자열 이스케이프 &lt;em&gt;의&lt;/em&gt; . 이스케이프 체계에 대해서는 &lt;a href=&quot;system#addEscapedChar&quot;&gt;system.addEscapedChar&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebd9f96f52afcf1872610e11bf957c2e3fce63d5" translate="yes" xml:space="preserve">
          <source>Escapes the HTML.</source>
          <target state="translated">HTML을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="783d409d7482af05fb23227e1180b70d47859cb8" translate="yes" xml:space="preserve">
          <source>Establish the floating-point environment represented by the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;envp가&lt;/em&gt; 가리키는 객체가 나타내는 부동 소수점 환경을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e353bf0b3a24e4306cbf0bb86c2dff1c822e00fe" translate="yes" xml:space="preserve">
          <source>Establish the rounding direction represented by &lt;em&gt;roundingDirection&lt;/em&gt;.</source>
          <target state="translated">로 표현되는 반올림 방향 수립 &lt;em&gt;roundingDirection을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d3a01e138c496208aa3759c0e95392bbbd765c" translate="yes" xml:space="preserve">
          <source>Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error.</source>
          <target state="translated">SMTP 서버와 연결을 설정합니다. ReplyError 또는 소켓 오류로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e671f390e06cb895c11177c3a256261229018f0" translate="yes" xml:space="preserve">
          <source>Establishes connection to the specified &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt; pair via the specified protocol. The procedure iterates through possible resolutions of the &lt;code&gt;address&lt;/code&gt; until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns AsyncSocket ready to send or receive data.</source>
          <target state="translated">지정된 프로토콜을 통해 지정된 &lt;code&gt;address&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; 쌍에 연결합니다. 이 절차 는 성공할 때까지 &lt;code&gt;address&lt;/code&gt; 의 가능한 해결 방법을 반복 하므로 IPv4 및 IPv6 모두에서 원활하게 작동합니다. 데이터를 보내거나받을 준비가 된 AsyncSocket을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4443d26269000b5708852a2218ba1399e31a5b1a" translate="yes" xml:space="preserve">
          <source>Establishes connection to the specified &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt; pair via the specified protocol. The procedure iterates through possible resolutions of the &lt;code&gt;address&lt;/code&gt; until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns Socket ready to send or receive data.</source>
          <target state="translated">지정된 프로토콜을 통해 지정된 &lt;code&gt;address&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; 쌍에 연결합니다. 이 절차 는 성공할 때까지 &lt;code&gt;address&lt;/code&gt; 의 가능한 해결 방법을 반복 하므로 IPv4 및 IPv6 모두에서 원활하게 작동합니다. 데이터를 보내거나받을 준비가 된 소켓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d25d939a4d4d60a1388bc207afef74f93ceb416" translate="yes" xml:space="preserve">
          <source>Euler's number</source>
          <target state="translated">오일러 수</target>
        </trans-unit>
        <trans-unit id="e1643253b40ca890659deaa2ba04c73ed6b689b6" translate="yes" xml:space="preserve">
          <source>Evaluate difference between two dates in &lt;code&gt;TimeInterval&lt;/code&gt; format, so, it will be relative.</source>
          <target state="translated">&lt;code&gt;TimeInterval&lt;/code&gt; 형식으로 두 날짜 간의 차이를 평가 하므로 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="2524ffeb65491857bf944c68f78b89d81327c52a" translate="yes" xml:space="preserve">
          <source>Even more sophisticated name mangling can be achieved by the &lt;code&gt;#mangle&lt;/code&gt; directive: It takes a PEG pattern and format string that specify how the identifier should be converted:</source>
          <target state="translated">&lt;code&gt;#mangle&lt;/code&gt; 지시어 를 사용하면보다 복잡한 이름 조작을 수행 할 수 있습니다 . 식별자 변환 방법을 지정하는 PEG 패턴 및 형식 문자열이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="27af5de002f30bc2e9af71c4a12bc6a8a81fbb37" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;$*&lt;/code&gt; and &lt;code&gt;$+&lt;/code&gt; look similar to the regular expressions &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.+&lt;/code&gt; they work quite differently, there is no non-deterministic state machine involved and the matches are non-greedy. &lt;code&gt;[$*]&lt;/code&gt; matches &lt;code&gt;[xyz]&lt;/code&gt; via &lt;code&gt;parseutils.parseUntil&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;$*&lt;/code&gt; 과 &lt;code&gt;$+&lt;/code&gt; 정규 표현식과 유사 &lt;code&gt;.*&lt;/code&gt; 와 &lt;code&gt;.+&lt;/code&gt; 그들은 매우 다르게 작동,이 반군 비 결정적 상태 머신없고 일치하는 비 욕심이다. &lt;code&gt;[$*]&lt;/code&gt; 는 &lt;code&gt;parseutils.parseUntil&lt;/code&gt; 을 통해 &lt;code&gt;[xyz]&lt;/code&gt; ] 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d35ac72ee7166d41e67fb47beca1c5e4b8922f69" translate="yes" xml:space="preserve">
          <source>Even though the algorithm works with any string &lt;em&gt;s&lt;/em&gt;, it is only useful if &lt;em&gt;s&lt;/em&gt; contains a number.</source>
          <target state="translated">알고리즘이 문자열 &lt;em&gt;s&lt;/em&gt; 와 함께 작동 하더라도 &lt;em&gt;s&lt;/em&gt; 에 숫자가 포함 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f70e3e815b8a733357251ed7732d44011fcf1bd8" translate="yes" xml:space="preserve">
          <source>Even though the conversion is implicit, it is not &lt;em&gt;safe&lt;/em&gt;: The garbage collector does not consider a &lt;code&gt;cstring&lt;/code&gt; to be a root and may collect the underlying memory. However in practice this almost never happens as the GC considers stack roots conservatively. One can use the builtin procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to keep the string data alive for the rare cases where it does not work.</source>
          <target state="translated">변환은 암시 적이지만 &lt;em&gt;안전&lt;/em&gt; 하지 않습니다. 가비지 수집기는 &lt;code&gt;cstring&lt;/code&gt; 을 루트로 간주하지 않으며 기본 메모리를 수집 할 수 있습니다. 그러나 실제로 이것은 GC가 스택 루트를 보수적으로 고려할 때 거의 발생하지 않습니다. 내장 프로 시저 &lt;code&gt;GC_ref&lt;/code&gt; 및 &lt;code&gt;GC_unref&lt;/code&gt; 를 사용하여 문자열 데이터가 작동하지 않는 드문 경우에 대해 문자열 데이터를 활성 상태 로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05d2e4b7c53e86de6170c6fcf499454d34430a3" translate="yes" xml:space="preserve">
          <source>Even though the translation process is not perfect, it is often the case that the translated Nim code does not need any tweaking by hand. In other cases it may be preferable to modify the input file instead of the generated Nim code so that c2nim can parse it properly. c2nim's preprocessor defines the symbol &lt;code&gt;C2NIM&lt;/code&gt; that can be used to mark code sections:</source>
          <target state="translated">번역 프로세스가 완벽하지는 않지만 번역 된 Nim 코드를 직접 조정할 필요가없는 경우가 종종 있습니다. 다른 경우 c2nim이 올바르게 구문 분석 할 수 있도록 생성 된 Nim 코드 대신 입력 파일을 수정하는 것이 좋습니다. c2nim의 전처리 기는 코드 섹션을 표시하는 데 사용할 수있는 기호 &lt;code&gt;C2NIM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e00da9359b8f6b979472d9d18acc3f0800a129b9" translate="yes" xml:space="preserve">
          <source>Even though you don't need to declare a type for a tuple to use it, tuples created with different field names will be considered different objects despite having the same field types.</source>
          <target state="translated">튜플에서이를 사용하기 위해 유형을 선언 할 필요는 없지만 동일한 필드 유형에도 불구하고 다른 필드 이름으로 작성된 튜플은 다른 객체로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="c1bb065f39932ece8029ed29026b45a8cf4dcb27" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing end of line characters unless parameter &lt;code&gt;keepEol&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;a href=&quot;manual#character-literals&quot;&gt;문자 리터럴&lt;/a&gt; 개행 조합 (CR, LF, CR-LF)이 지원됩니다. 매개 변수 &lt;code&gt;keepEol&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정 되지 않으면 결과 문자열에 줄 끝 문자가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c77fb4846042da3ceb41a89e050f00de3c12260f" translate="yes" xml:space="preserve">
          <source>Every Nim module resides in a (nimble) package. An object type can be attached to the package it resides in. If that is done, the type can be referenced from other modules as an &lt;span id=&quot;incomplete_1&quot;&gt;incomplete&lt;/span&gt; object type. This features allows to break up recursive type dependencies accross module boundaries. Incomplete object types are always passed &lt;code&gt;byref&lt;/code&gt; and can only be used in pointer like contexts (&lt;code&gt;var/ref/ptr IncompleteObject&lt;/code&gt;) in general since the compiler does not yet know the size of the object. To complete an incomplete object the &lt;code&gt;package&lt;/code&gt; pragma has to be used. &lt;code&gt;package&lt;/code&gt; implies &lt;code&gt;byref&lt;/code&gt;.</source>
          <target state="translated">모든 Nim 모듈은 (신속한) 패키지에 있습니다. 객체 유형은 패키지에 상주하는 패키지에 첨부 될 수 있습니다. 완료되면 다른 모듈에서 유형 이 &lt;span id=&quot;incomplete_1&quot;&gt;불완전한&lt;/span&gt; 객체 유형 으로 참조 될 수 있습니다 . 이 기능을 사용하면 모듈 경계에 걸쳐 재귀 유형 종속성을 분류 할 수 있습니다. 불완전한 객체 유형은 항상 &lt;code&gt;byref&lt;/code&gt; 전달 되며 컴파일러는 아직 객체의 크기를 알지 못하므로 일반적으로 컨텍스트와 같은 포인터 ( &lt;code&gt;var/ref/ptr IncompleteObject&lt;/code&gt; ) 에서만 사용할 수 있습니다 . 불완전한 객체를 완성하려면 &lt;code&gt;package&lt;/code&gt; pragma를 사용해야합니다. &lt;code&gt;package&lt;/code&gt; 는 &lt;code&gt;byref&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a8cfd4261435d32982761b3dde7bd6de2d29d6f3" translate="yes" xml:space="preserve">
          <source>Every access of a guarded memory location needs to happen in an appropriate &lt;span id=&quot;locks_1&quot;&gt;locks&lt;/span&gt; statement.</source>
          <target state="translated">보호 된 메모리 위치에 대한 모든 액세스는 적절한 &lt;span id=&quot;locks_1&quot;&gt;잠금&lt;/span&gt; 명령문 에서 발생해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca62ae16b33dceaf19c5d1465c9d9125be109135" translate="yes" xml:space="preserve">
          <source>Every arg in args needs to match. There are multiple different categories how an argument can match. Let &lt;code&gt;f&lt;/code&gt; be the formal parameter's type and &lt;code&gt;a&lt;/code&gt; the type of the argument.</source>
          <target state="translated">args의 모든 arg는 일치해야합니다. 인수가 일치하는 방법에는 여러 가지 범주가 있습니다. 하자 &lt;code&gt;f&lt;/code&gt; 는 형식적인 매개 변수의 종류와 수 인수의 유형입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be67c2bbb9942cd3be9b909db99c265560744375" translate="yes" xml:space="preserve">
          <source>Every array access has to be provably within bounds. This is called the &lt;em&gt;bounds check&lt;/em&gt;.</source>
          <target state="translated">모든 어레이 액세스는 경계 내에 있어야합니다. 이것을 &lt;em&gt;경계 검사&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce51b86a2644666a064bc71fe0df29fee802324" translate="yes" xml:space="preserve">
          <source>Every call to a method &lt;code&gt;m&lt;/code&gt; is assumed to raise &lt;code&gt;system.Exception&lt;/code&gt; unless &lt;code&gt;m&lt;/code&gt; has an explicit &lt;code&gt;raises&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 메소드에 대한 모든 호출은 시스템을 발생시키는 것으로 가정됩니다 &lt;code&gt;system.Exception&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 에 명시 적 &lt;code&gt;raises&lt;/code&gt; 목록 이 없으면 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="b34ead0e5dfbe731b7b536ad959d8a1bc4bb04b6" translate="yes" xml:space="preserve">
          <source>Every call to a proc &lt;code&gt;q&lt;/code&gt; which has an unknown body (due to a forward declaration or an &lt;code&gt;importc&lt;/code&gt; pragma) is assumed to raise &lt;code&gt;system.Exception&lt;/code&gt; unless &lt;code&gt;q&lt;/code&gt; has an explicit &lt;code&gt;raises&lt;/code&gt; list.</source>
          <target state="translated">알 수없는 본문이 있는 proc &lt;code&gt;q&lt;/code&gt; 를 호출 할 때마다 (포워드 선언 또는 &lt;code&gt;importc&lt;/code&gt; pragma 로 인해 ) 시스템이 발생한다고 가정합니다 &lt;code&gt;system.Exception&lt;/code&gt; &lt;code&gt;q&lt;/code&gt; 에 명시 적 &lt;code&gt;raises&lt;/code&gt; 목록 이 없으면 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="df3d4aeadc3195348572c41b2174a65bcb0c4fee" translate="yes" xml:space="preserve">
          <source>Every expression of some proc type within a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to &lt;code&gt;p&lt;/code&gt;'s raises list.</source>
          <target state="translated">호출 자체가 아닌 (그리고 nil이 아닌) 호출 내에서 일부 proc 유형의 모든 표현은 간접적으로 호출되는 것으로 가정되므로 제기 목록이 &lt;code&gt;p&lt;/code&gt; 의 제기 목록에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="354b547169f14688eed8ccd9aeb4b010abe50bfe" translate="yes" xml:space="preserve">
          <source>Every indirect call via some proc type &lt;code&gt;T&lt;/code&gt; is assumed to raise &lt;code&gt;system.Exception&lt;/code&gt; (the base type of the exception hierarchy) and thus any exception unless &lt;code&gt;T&lt;/code&gt; has an explicit &lt;code&gt;raises&lt;/code&gt; list. However if the call is of the form &lt;code&gt;f(...)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.</source>
          <target state="translated">일부 proc 유형 &lt;code&gt;T&lt;/code&gt; 를 통한 모든 간접 호출 은 &lt;code&gt;system.Exception&lt;/code&gt; (예외 계층 구조의 기본 유형)을 발생시키는 것으로 가정되며 , 따라서 &lt;code&gt;T&lt;/code&gt; 에 명시 적 &lt;code&gt;raises&lt;/code&gt; 목록 이 없으면 예외 가 발생 합니다. 그러나 호출이 &lt;code&gt;f(...)&lt;/code&gt; 형식 인 경우 &lt;code&gt;f&lt;/code&gt; 는 현재 분석 된 루틴의 매개 변수입니다. 호출은 효과가 없다고 낙관적으로 가정합니다. 규칙 2는이 경우를 보상합니다.</target>
        </trans-unit>
        <trans-unit id="bb548758d08a2c10b16050f6d416d20221486de9" translate="yes" xml:space="preserve">
          <source>Every location of the form &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[i..j]&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; where &lt;code&gt;dest&lt;/code&gt; is part of the pattern &lt;code&gt;dest = spawn f(...)&lt;/code&gt; has to be provably disjoint. This is called the &lt;em&gt;disjoint check&lt;/em&gt;.</source>
          <target state="translated">폼의 각 위치 &lt;code&gt;a[i]&lt;/code&gt; 및 &lt;code&gt;a[i..j]&lt;/code&gt; 및 &lt;code&gt;dest&lt;/code&gt; 여기서 &lt;code&gt;dest&lt;/code&gt; 패턴의 부분 &lt;code&gt;dest = spawn f(...)&lt;/code&gt; 라도 유용 해체되어야한다. 이것을 &lt;em&gt;분리 검사&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="cba4580f1c0b505633eb8e175bcb26eb141a1f43" translate="yes" xml:space="preserve">
          <source>Every other complex location &lt;code&gt;loc&lt;/code&gt; that is used in a spawned proc (&lt;code&gt;spawn f(loc)&lt;/code&gt;) has to be immutable for the duration of the &lt;code&gt;parallel&lt;/code&gt; section. This is called the &lt;em&gt;immutability check&lt;/em&gt;. Currently it is not specified what exactly &quot;complex location&quot; means. We need to make this an optimization!</source>
          <target state="translated">스폰 된 proc ( &lt;code&gt;spawn f(loc)&lt;/code&gt; )에 사용되는 다른 모든 복잡한 위치 &lt;code&gt;loc&lt;/code&gt; 은 &lt;code&gt;parallel&lt;/code&gt; 섹션 기간 동안 변경 불가능해야합니다 . 이를 &lt;em&gt;불변성 검사&lt;/em&gt; 라고합니다 . 현재는 정확히 &quot;복잡한 위치&quot;가 무엇을 의미하는지 지정되어 있지 않습니다. 이를 최적화해야합니다!&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1716f12b6b99ead4104b896e3c8385d943dd249" translate="yes" xml:space="preserve">
          <source>Every table implementation is treated equal syntactically.</source>
          <target state="translated">모든 테이블 구현은 구문 적으로 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="469b9f46546ac9d56164f67e3cf63d154c4c18b8" translate="yes" xml:space="preserve">
          <source>Every tag in the resulting tree is in lower case.</source>
          <target state="translated">결과 트리의 모든 태그는 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="357eae391ef69fac015faff1a81a0bc59cb03fd8" translate="yes" xml:space="preserve">
          <source>Every variable, procedure, etc. needs to be declared before it can be used. (The reason for this is that it is non-trivial to avoid this need in a language that supports meta programming as extensively as Nim does.) However, this cannot be done for mutually recursive procedures:</source>
          <target state="translated">모든 변수, 프로 시저 등을 사용하려면 먼저 선언해야합니다. (이 이유는 Nim처럼 광범위하게 메타 프로그래밍을 지원하는 언어에서 이러한 요구를 피하는 것이 사소한 것이 아니기 때문에 상호 재귀적인 절차에는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57dd2bb10c86456fbdafdf47dec18bce66c355f9" translate="yes" xml:space="preserve">
          <source>Exact match: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are of the same type.</source>
          <target state="translated">정확히 일치 : &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; 는 같은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="092d0946bf1defa2720482b8b8241d820ad34582" translate="yes" xml:space="preserve">
          <source>Example 1: Retrieve HTML title</source>
          <target state="translated">예 1 : HTML 제목 검색</target>
        </trans-unit>
        <trans-unit id="310dfe3e84588da282cab337066ff71027987656" translate="yes" xml:space="preserve">
          <source>Example 2: Retrieve all HTML links</source>
          <target state="translated">예 2 : 모든 HTML 링크 검색</target>
        </trans-unit>
        <trans-unit id="d5ea3515a6cb589cfe9b0bbcd41c02701cea03b1" translate="yes" xml:space="preserve">
          <source>Example Templates and Macros</source>
          <target state="translated">예제 템플릿 및 매크로</target>
        </trans-unit>
        <trans-unit id="1fabb1683d22d0469c9e9cac437dfd3fa193ab75" translate="yes" xml:space="preserve">
          <source>Example code:</source>
          <target state="translated">예제 코드 :</target>
        </trans-unit>
        <trans-unit id="f34d521cfab6899ca509ba9279f748bc93f954d1" translate="yes" xml:space="preserve">
          <source>Example gmail use:</source>
          <target state="translated">Gmail 사용 예 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c4de85f28e60b5135cb3762767ab2c1a5c91d823" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;parentDir(&quot;/usr/local/bin&quot;) == &quot;/usr/local&quot;&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;parentDir(&quot;/usr/local/bin&quot;) == &quot;/usr/local&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8b8c06a5ad97dce6b3af023a5b20c8c69ae38d1" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;parentDir(&quot;/usr/local/bin/&quot;) == &quot;/usr/local&quot;&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;parentDir(&quot;/usr/local/bin/&quot;) == &quot;/usr/local&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d735ffab2b32ed73e75ae249ea554cf0c98dd96e" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;tailDir(&quot;/usr/local/bin&quot;) == &quot;local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;tailDir(&quot;/usr/local/bin&quot;) == &quot;local/bin&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28cb1bb1a4f7e2d78a60de9cab48d666c79b5806" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;tailDir(&quot;bin&quot;) == &quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;tailDir(&quot;bin&quot;) == &quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a1e037796371e98acc6412fb8ca0db9884aa53" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;tailDir(&quot;usr/local/bin/&quot;) == &quot;local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;tailDir(&quot;usr/local/bin/&quot;) == &quot;local/bin&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fca31664ee5491a1a146def15be930ce333a074" translate="yes" xml:space="preserve">
          <source>Example: Hoisting</source>
          <target state="translated">예 : 게양</target>
        </trans-unit>
        <trans-unit id="c68385cace14f3acde243a85007b37824dd88a35" translate="yes" xml:space="preserve">
          <source>Example: How to use the parser</source>
          <target state="translated">예 : 파서를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="f9a290fed60a06db2defb42324fd53368a8f6ec0" translate="yes" xml:space="preserve">
          <source>Example: Partial evaluation</source>
          <target state="translated">예 : 부분 평가</target>
        </trans-unit>
        <trans-unit id="a1a9de1d5c7df46bbb5fac7dc9c5de11a722db1a" translate="yes" xml:space="preserve">
          <source>Example: Transforming hyperlinks</source>
          <target state="translated">예 : 하이퍼 링크 변환</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="ae660b90e2a8e639cd3e547a2fea51b830ac299b" translate="yes" xml:space="preserve">
          <source>Except clauses</source>
          <target state="translated">절 제외</target>
        </trans-unit>
        <trans-unit id="a4033a571807e39735d2a99ca592a29f56808dd1" translate="yes" xml:space="preserve">
          <source>Exception and Error types should have the &quot;Error&quot; suffix.</source>
          <target state="translated">예외 및 오류 유형에는 &quot;오류&quot;접미사가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="209011554fcfc911dcec7eb38e42eca35be08388" translate="yes" xml:space="preserve">
          <source>Exception hierarchy</source>
          <target state="translated">예외 계층</target>
        </trans-unit>
        <trans-unit id="b8e75446a5258ec2872aeb702faa50a3a5ca3727" translate="yes" xml:space="preserve">
          <source>Exception that is raised for invalid XML.</source>
          <target state="translated">유효하지 않은 XML에 대해 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="a99d65c4d420b5eb1b5525adaf042541111850ec" translate="yes" xml:space="preserve">
          <source>Exception tracking</source>
          <target state="translated">예외 추적</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="4c69892fb47339f7f39b915fd73a75ce2a42d35b" translate="yes" xml:space="preserve">
          <source>Exceptions have to be allocated on the heap because their lifetime is unknown. The compiler will prevent you from raising an exception created on the stack. All raised exceptions should at least specify the reason for being raised in the &lt;code&gt;msg&lt;/code&gt; field.</source>
          <target state="translated">수명을 알 수 없기 때문에 힙에 예외를 할당해야합니다. 컴파일러는 스택에서 생성 된 예외를 발생시키지 못하게합니다. 발생한 모든 예외는 &lt;code&gt;msg&lt;/code&gt; 필드 에 발생한 이유를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1d61829f05e5e1694fa50bf814a5c0406c134efd" translate="yes" xml:space="preserve">
          <source>Exchange (key, val)-pairs:</source>
          <target state="translated">교환 (키, 발) 쌍 :</target>
        </trans-unit>
        <trans-unit id="5d1a6a0dfee883c7a3f66c3ed18e2b4a1bd2536e" translate="yes" xml:space="preserve">
          <source>Excludes &lt;em&gt;key&lt;/em&gt; from the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">제외 &lt;em&gt;키&lt;/em&gt; 세트에서 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46f8d91f1c210d2f50acf5779d694e19d5a3ced6" translate="yes" xml:space="preserve">
          <source>Excludes &lt;em&gt;key&lt;/em&gt; from the set &lt;em&gt;s&lt;/em&gt;. Efficiency: O(n).</source>
          <target state="translated">제외 &lt;em&gt;키&lt;/em&gt; 세트에서 &lt;em&gt;의&lt;/em&gt; . 효율 : O (n).</target>
        </trans-unit>
        <trans-unit id="4defbdc5548dfa00e9c2628c31236fc48129545a" translate="yes" xml:space="preserve">
          <source>Excludes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was removed from &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">제외 &lt;em&gt;키&lt;/em&gt; 세트에서 &lt;em&gt;의&lt;/em&gt; 경우는 말한다 &lt;em&gt;키가&lt;/em&gt; 제거 된 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef14e257b85d654038cfad08d10ac737dcc9a45" translate="yes" xml:space="preserve">
          <source>Excludes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was removed from &lt;em&gt;s&lt;/em&gt;. Efficiency: O(n).</source>
          <target state="translated">제외 &lt;em&gt;키&lt;/em&gt; 세트에서 &lt;em&gt;의&lt;/em&gt; 경우는 말한다 &lt;em&gt;키가&lt;/em&gt; 제거 된 &lt;em&gt;의&lt;/em&gt; . 효율 : O (n).</target>
        </trans-unit>
        <trans-unit id="2dd68543d3655b9bcb0e841f27150b50eebd0270" translate="yes" xml:space="preserve">
          <source>Excludes all elements from &lt;em&gt;other&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">제외 모든 요소 &lt;em&gt;기타&lt;/em&gt; 에서 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="92991bbdc88c8988100fa83a6f32c8ee20f7ec9e" translate="yes" xml:space="preserve">
          <source>Excludes everything in &lt;em&gt;other&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">에서 제외 모든 &lt;em&gt;기타&lt;/em&gt; 에서 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a2df53ea70d100361d3d9484a43219ffa63491d8" translate="yes" xml:space="preserve">
          <source>Excluding symbols</source>
          <target state="translated">기호 제외</target>
        </trans-unit>
        <trans-unit id="0233eba4e19efdcef5da485af2c2db8b0901f32a" translate="yes" xml:space="preserve">
          <source>Exec</source>
          <target state="translated">Exec</target>
        </trans-unit>
        <trans-unit id="883c3083244b6a387f122c092facd5ecfde90074" translate="yes" xml:space="preserve">
          <source>Exec-time and get/set-time error codesSpecific error codes for UTF-8 validity checksSpecific error codes for UTF-16 validity checksSpecific error codes for UTF-32 validity checksRequest types for pcre_fullinfo()Request types for pcre_config(). Do not re-arrange, in order to remain compatible.Request types for pcre_study(). Do not re-arrange, in order to remain compatible.Bit flags for the pcre[16|32]_extra structure. Do not re-arrange or redefine these bits, just add new ones on the end, in order to remain compatible.TypesThe structure for passing additional data to pcre_exec(). This is defined in such as way as to be extensible. Always add new fields at the end, in order to remain compatible.The structure for passing out data via the pcre_callout_function. We use a structure so that new fields can be added on the end in future versions, without changing the API of the function, thereby allowing old clients to work without modification.User defined callback which provides a stack just before the match starts.</source>
          <target state="translated">실행 시간 및 가져 오기 / 설정 시간 오류 코드 UTF-8 유효성 검사에 대한 특정 오류 코드 UTF-16 유효성 검사에 대한 특정 오류 코드 UTF-32 유효성 검사에 대한 특정 오류 코드 pcre_fullinfo ()에 대한 요청 유형 pcre_config ()에 대한 요청 유형. 호환성을 유지하기 위해 다시 정렬하지 마십시오. pcre_study ()에 대한 요청 유형입니다. pcre [16 | 32] _extra 구조에 대해 비트 플래그가 호환되도록 유지하십시오. 호환성을 유지하려면 이러한 비트를 다시 정렬하거나 재정의하지 말고 끝에 새 비트를 추가하십시오. 유형 pcre_exec ()에 추가 데이터를 전달하는 구조입니다. 이것은 확장 가능한 방식으로 정의됩니다. 호환성을 유지하려면 항상 끝에 새 필드를 추가하십시오. pcre_callout_function을 통해 데이터를 전달하는 구조입니다. 향후 버전에서는 새로운 필드를 추가 할 수 있도록 구조를 사용합니다.함수의 API를 변경하지 않고 이전 클라이언트가 수정없이 작업 할 수 있도록합니다. 사용자 정의 콜백은 일치가 시작되기 직전에 스택을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31baca40e6a53aab4ec8803731b3d1fd62a87366" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;command&lt;/code&gt; and returns its error code. Standard input, output, error streams are inherited from the calling process. This operation is also often called &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 실행 하고 오류 코드를 반환합니다. 표준 입력, 출력, 오류 스트림은 호출 프로세스에서 상속됩니다. 이 작업을 &lt;span id=&quot;system_1&quot;&gt;시스템&lt;/span&gt; 이라고도 &lt;span id=&quot;system_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="0456123c87daef6e82145d36ba14937131d8d863" translate="yes" xml:space="preserve">
          <source>Executes a &lt;span id=&quot;shell-command_1&quot;&gt;shell command&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;shell-command_1&quot;&gt;쉘 명령을&lt;/span&gt; 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="f207f4e7d2736cf822b6a070dbb8290b8c96a356" translate="yes" xml:space="preserve">
          <source>Executes a block of code only once (the first time the block is reached). When hot code reloading is enabled, protects top-level code from being re-executed on each module reload.</source>
          <target state="translated">코드 블록을 한 번만 실행합니다 (블록에 처음 도달 할 때). 핫 코드 재로드가 활성화되면 각 모듈 재로드에서 최상위 코드가 다시 실행되지 않도록 보호합니다.</target>
        </trans-unit>
        <trans-unit id="23be2e59ff95a420ce744d7d4311b1e8059f31f2" translate="yes" xml:space="preserve">
          <source>Executes an external process at compile-time. if &lt;em&gt;input&lt;/em&gt; is not an empty string, it will be passed as a standard input to the executed program.</source>
          <target state="translated">컴파일 타임에 외부 프로세스를 실행합니다. 경우 &lt;em&gt;입력이&lt;/em&gt; 빈 문자열이 아닌, 그것은 실행 된 프로그램의 표준 입력으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="472916b1b838ef8d4abf40ad5a21c68935cf0130" translate="yes" xml:space="preserve">
          <source>Executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row or -1 in case of an error.</source>
          <target state="translated">쿼리를 실행하고 (일반적으로 &quot;INSERT&quot;) 행에 대해 생성 된 ID를 반환하거나 오류가 발생하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc2d188ac9262918f80c754587253c30573bd801" translate="yes" xml:space="preserve">
          <source>Executes the query (typically &quot;INSERT&quot;) and returns the generated ID for the row.</source>
          <target state="translated">쿼리 (일반적으로 &quot;INSERT&quot;)를 실행하고 행에 대해 생성 된 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97e7f2cd9432445064354c0efa963f3c28bb34da" translate="yes" xml:space="preserve">
          <source>Executes the query and iterates over the result dataset.</source>
          <target state="translated">쿼리를 실행하고 결과 데이터 집합을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="3441d5c8741fc016bb44b2fc85745e6f79ba3e81" translate="yes" xml:space="preserve">
          <source>Executes the query and raises EDB if not successful.</source>
          <target state="translated">쿼리를 실행하고 실패하면 EDB를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="99ff2cddde8a0e99076b6f6bcc05f230fdf6ddb4" translate="yes" xml:space="preserve">
          <source>Executes the query and returns the first column of the first row of the result dataset. Returns &quot;&quot; if the dataset contains no rows or the database value is NULL.</source>
          <target state="translated">쿼리를 실행하고 결과 데이터 집합의 첫 번째 행의 첫 번째 열을 반환합니다. 데이터 세트에 행이 없거나 데이터베이스 값이 NULL 인 경우 &quot;&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22ba79be578f4c3bc12771e5102181dd9f69d5a4" translate="yes" xml:space="preserve">
          <source>Executes the query and returns the whole result dataset.</source>
          <target state="translated">쿼리를 실행하고 전체 결과 데이터 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c170b5e47b6f6bbfdc7fa2f0ab77d2c9b55606c8" translate="yes" xml:space="preserve">
          <source>Expand tab characters in &lt;em&gt;s&lt;/em&gt; by &lt;em&gt;tabSize&lt;/em&gt; spaces</source>
          <target state="translated">에서 탭 문자 확장 &lt;em&gt;들&lt;/em&gt; 에 의해 &lt;em&gt;tabSize의&lt;/em&gt; 공간</target>
        </trans-unit>
        <trans-unit id="28841a5aef9bd2f282281352d9d0f3b870e4f455" translate="yes" xml:space="preserve">
          <source>Expands &lt;code&gt;~&lt;/code&gt; or a path starting with &lt;code&gt;~/&lt;/code&gt; to a full path, replacing &lt;code&gt;~&lt;/code&gt; with &lt;code&gt;getHomeDir()&lt;/code&gt; (otherwise returns &lt;code&gt;path&lt;/code&gt; unmodified).</source>
          <target state="translated">확장합니다 &lt;code&gt;~&lt;/code&gt; 또는 경로로 시작 &lt;code&gt;~/&lt;/code&gt; 교체, 전체 경로로 &lt;code&gt;~&lt;/code&gt; 와 &lt;code&gt;getHomeDir()&lt;/code&gt; (그렇지 않으면 반환 &lt;code&gt;path&lt;/code&gt; 수정되지 않은).</target>
        </trans-unit>
        <trans-unit id="4f7f911eb6d6408692ac0df07b787cd78ad1f159" translate="yes" xml:space="preserve">
          <source>Expands one level of macro - useful for debugging. Can be used to inspect what happens when a macro call is expanded, without altering its result.</source>
          <target state="translated">한 수준의 매크로를 확장하여 디버깅에 유용합니다. 결과를 변경하지 않고 매크로 호출이 확장 될 때 발생하는 상황을 검사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101833a434fba0cfc969d68876ccbc6341c4fa47" translate="yes" xml:space="preserve">
          <source>Expands operating GC stack range to &lt;em&gt;theStackBottom&lt;/em&gt;. Does nothing if current stack bottom is already lower than &lt;em&gt;theStackBottom&lt;/em&gt;.</source>
          <target state="translated">작동 GC 스택 범위를 &lt;em&gt;StackBottom으로&lt;/em&gt; 확장합니다 . 현재 스택 바닥이 이미 &lt;em&gt;StackBottom&lt;/em&gt; 보다 낮은 경우 아무 작업도 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cdfd59c2674c5e3dc8bf54a6b2ebf8c3fc009b2c" translate="yes" xml:space="preserve">
          <source>Expands to &lt;em&gt;true&lt;/em&gt; if expression &lt;em&gt;n&lt;/em&gt; which is expected to be &lt;em&gt;nnkDotExpr&lt;/em&gt; (if checking a field), a proc or a type has custom pragma &lt;em&gt;cp&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;nnkDotExpr&lt;/em&gt; (필드를 검사하는 경우), proc 또는 유형에 사용자 정의 pragma &lt;em&gt;cp&lt;/em&gt; 가있는 표현식 &lt;em&gt;n&lt;/em&gt; 이 &lt;em&gt;true 인&lt;/em&gt; 경우 &lt;em&gt;true로&lt;/em&gt; 확장됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55bd87c3849e895c3502e5702bad1cee6ad854d7" translate="yes" xml:space="preserve">
          <source>Expands to value of custom pragma &lt;em&gt;cp&lt;/em&gt; of expression &lt;em&gt;n&lt;/em&gt; which is expected to be &lt;em&gt;nnkDotExpr&lt;/em&gt;, a proc or a type.</source>
          <target state="translated">&lt;em&gt;nnkDotExpr&lt;/em&gt; , proc 또는 유형 인 것으로 예상되는 표현식 &lt;em&gt;n&lt;/em&gt; 의 사용자 정의 pragma &lt;em&gt;cp&lt;/em&gt; 값으로 확장됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="707b65561f251ee73412c1e241b27b70f0900c62" translate="yes" xml:space="preserve">
          <source>Experimental &quot;method call&quot; operator for type JsAssoc. Takes the name of a method of the JavaScript object (&lt;em&gt;field&lt;/em&gt;) and calls it with &lt;em&gt;args&lt;/em&gt; as arguments. Here, everything is typechecked, so you do not have to worry about &lt;em&gt;undefined&lt;/em&gt; return values.</source>
          <target state="translated">JsAssoc 유형에 대한 실험적인 &quot;방법 호출&quot;연산자. JavaScript 객체 ( &lt;em&gt;field&lt;/em&gt; ) 의 메소드 이름을 &lt;em&gt;인수&lt;/em&gt; 로 인수로 사용 하여 호출합니다 . 여기에서 모든 것이 유형 검사되므로 &lt;em&gt;정의되지 않은&lt;/em&gt; 반환 값 에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32b393dec0eaed1959f38f8d3343d100759d9ba8" translate="yes" xml:space="preserve">
          <source>Experimental &quot;method call&quot; operator for type JsObject. Takes the name of a method of the JavaScript object (&lt;em&gt;field&lt;/em&gt;) and calls it with &lt;em&gt;args&lt;/em&gt; as arguments, returning a JsObject (which may be discarded, and may be &lt;em&gt;undefined&lt;/em&gt;, if the method does not return anything, so be careful when using this.)</source>
          <target state="translated">JsObject 유형에 대한 실험적인 &quot;방법 호출&quot;연산자. JavaScript 객체 ( &lt;em&gt;field&lt;/em&gt; ) 의 메소드 이름을 &lt;em&gt;인수&lt;/em&gt; 로 인수로 사용 하여 &lt;em&gt;인수&lt;/em&gt; 로 호출 하여 JsObject를 반환합니다 ( 메소드가 아무것도 반환하지 않으면 버릴 수 있고 &lt;em&gt;정의되지&lt;/em&gt; 않을 수 있음) .이를 사용할 때주의하십시오. )</target>
        </trans-unit>
        <trans-unit id="b842160d9fc98509ceb331b56069bb8cad25a6b4" translate="yes" xml:space="preserve">
          <source>Experimental dot accessor (get) for type JsAssoc. Returns the value of a property of name &lt;em&gt;field&lt;/em&gt; from a JsObject &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">JsAssoc 유형의 실험용 도트 접근 자 (get). JsObject &lt;em&gt;x&lt;/em&gt; 에서 name &lt;em&gt;필드&lt;/em&gt; 의 속성 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="760eda2e38d22e7b04138a0c9fa2054af4ea2593" translate="yes" xml:space="preserve">
          <source>Experimental dot accessor (get) for type JsObject. Returns the value of a property of name &lt;em&gt;field&lt;/em&gt; from a JsObject &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">JsObject 유형의 실험용 도트 접근 자 (get)입니다. JsObject &lt;em&gt;x&lt;/em&gt; 에서 name &lt;em&gt;필드&lt;/em&gt; 의 속성 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7a1f5386119ad377a8afd58045628698d382a5b" translate="yes" xml:space="preserve">
          <source>Experimental dot accessor (set) for type JsAssoc. Sets the value of a property of name &lt;em&gt;field&lt;/em&gt; in a JsObject &lt;em&gt;x&lt;/em&gt; to &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">JsAssoc 유형의 실험용 도트 접근 자 (세트) 세트 이름의 속성 값 &lt;em&gt;필드&lt;/em&gt; JSObject가에가 &lt;em&gt;X&lt;/em&gt; 에 &lt;em&gt;값&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1c35223f6c1e376aad28ae4008182c90920af9f9" translate="yes" xml:space="preserve">
          <source>Experimental dot accessor (set) for type JsObject. Sets the value of a property of name &lt;em&gt;field&lt;/em&gt; in a JsObject &lt;em&gt;x&lt;/em&gt; to &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">JsObject 유형의 실험용 도트 접근 자 (세트) 세트 이름의 속성 값 &lt;em&gt;필드&lt;/em&gt; JSObject가에가 &lt;em&gt;X&lt;/em&gt; 에 &lt;em&gt;값&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a5cb19fe1b5d986ff214b2b92f69b3dc9e121f" translate="yes" xml:space="preserve">
          <source>Exponent notation. Prints the number in scientific notation using the letter 'e' to indicate the exponent.</source>
          <target state="translated">지수 표기법. 지수를 나타 내기 위해 문자 'e'를 사용하여 과학적 표기법으로 숫자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3e943cba043e68e3445abb572e5842ae2d96a804" translate="yes" xml:space="preserve">
          <source>Exponent notation. Same as 'e' except it converts the number to uppercase.</source>
          <target state="translated">지수 표기법. 숫자를 대문자로 변환한다는 점을 제외하고 'e'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b69fabe72a1a8ef94ccbaed90b1ff760672656a7" translate="yes" xml:space="preserve">
          <source>Export marker</source>
          <target state="translated">마커 내보내기</target>
        </trans-unit>
        <trans-unit id="2b5379c685f6c0429617cc976cd0962ec294bdc1" translate="yes" xml:space="preserve">
          <source>Export statement</source>
          <target state="translated">수출 명세서</target>
        </trans-unit>
        <trans-unit id="aba10a2b2cb7d015177f5430377472f0d4f27b19" translate="yes" xml:space="preserve">
          <source>Exportc pragma</source>
          <target state="translated">엑스포트 프라 그마</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="165b224a7786a3f140439f36e19095d95a659a92" translate="yes" xml:space="preserve">
          <source>ExprAlwaysX</source>
          <target state="translated">ExprAlwaysX</target>
        </trans-unit>
        <trans-unit id="5cdc37794c3d9d40c04fc1095a008030e492768c" translate="yes" xml:space="preserve">
          <source>Expression Macros</source>
          <target state="translated">식 매크로</target>
        </trans-unit>
        <trans-unit id="aeed2acfc308499dc3ff29f3797cd488a0696166" translate="yes" xml:space="preserve">
          <source>Expression evaluation</source>
          <target state="translated">식 평가</target>
        </trans-unit>
        <trans-unit id="f70b3e8217b43930f2fdd79cffb903ca5b1eed9a" translate="yes" xml:space="preserve">
          <source>ExtendedContext</source>
          <target state="translated">ExtendedContext</target>
        </trans-unit>
        <trans-unit id="923b3a2c7de4f149efbe34807f7e5b279ac46236" translate="yes" xml:space="preserve">
          <source>Extern pragma</source>
          <target state="translated">인턴 프라 그마</target>
        </trans-unit>
        <trans-unit id="47bdcf155b88b88eb2eaf1535f4e8de526144860" translate="yes" xml:space="preserve">
          <source>Extra headers can be specified and must be separated by &lt;code&gt;\c\L&lt;/code&gt;</source>
          <target state="translated">추가 헤더를 지정할 수 있으며 &lt;code&gt;\c\L&lt;/code&gt; 로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c02377f98d45f16599d240fba553875971cb7e7" translate="yes" xml:space="preserve">
          <source>Extra headers can be specified and must be separated by &lt;code&gt;\c\L&lt;/code&gt;.</source>
          <target state="translated">추가 헤더를 지정할 수 있으며 &lt;code&gt;\c\L&lt;/code&gt; 로 구분해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7875459efed3e47169700cfc7f4def832c31fcb" translate="yes" xml:space="preserve">
          <source>Extracts the filename of a given &lt;em&gt;path&lt;/em&gt;. This is the same as &lt;code&gt;name &amp;amp; ext&lt;/code&gt; from &lt;code&gt;splitFile(path)&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;경로&lt;/em&gt; 의 파일 이름을 추출합니다 . 이것과 동일 &lt;code&gt;name &amp;amp; ext&lt;/code&gt; 로부터 &lt;code&gt;splitFile(path)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a156208983e39fa49f0a27d444e15f239a741624" translate="yes" xml:space="preserve">
          <source>Fast check whether &lt;em&gt;x&lt;/em&gt; is nil. This is sometimes more efficient than &lt;code&gt;== nil&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 가 nil 인지 빨리 확인하십시오 . 이것은 때때로 &lt;code&gt;== nil&lt;/code&gt; 보다 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="547d124e8bc5ba4779d4259b47b642e1c3acc7cb" translate="yes" xml:space="preserve">
          <source>Fast version of a push followed by a pop.</source>
          <target state="translated">푸시의 빠른 버전과 팝.</target>
        </trans-unit>
        <trans-unit id="c02d8af0ddc22e526cdea228d5a0ac51aececef3" translate="yes" xml:space="preserve">
          <source>Fastcall means different things to different C compilers. One gets whatever the C &lt;code&gt;__fastcall&lt;/code&gt; means.</source>
          <target state="translated">Fastcall은 다른 C 컴파일러와 다른 것을 의미합니다. C &lt;code&gt;__fastcall&lt;/code&gt; 의 의미 가 무엇이든 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b8c956d8c46c826db42f2f2000ce296b187497" translate="yes" xml:space="preserve">
          <source>Features or modules that the JavaScript platform does not support are not available. This includes:</source>
          <target state="translated">JavaScript 플랫폼이 지원하지 않는 기능 또는 모듈을 사용할 수 없습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0b16a42883b77ed0dcd72aca8625e73fba7400" translate="yes" xml:space="preserve">
          <source>Field designators of a variable of the given tuple/object type.</source>
          <target state="translated">주어진 튜플 / 객체 유형의 변수에 대한 필드 지정자.</target>
        </trans-unit>
        <trans-unit id="59aae2d19b7a556460f9b4b1660df0564835f06d" translate="yes" xml:space="preserve">
          <source>Field documentation comments can be added to fields like so:</source>
          <target state="translated">필드 문서 주석은 다음과 같이 필드에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df8dfb1a40f7caddd6202eab6c059f8eafeffd9e" translate="yes" xml:space="preserve">
          <source>File number of stderr;</source>
          <target state="translated">stderr의 파일 번호;</target>
        </trans-unit>
        <trans-unit id="aa8b3dc326ab82a2ed3d67111913dce5ca2eb733" translate="yes" xml:space="preserve">
          <source>File number of stdin;</source>
          <target state="translated">stdin의 파일 번호;</target>
        </trans-unit>
        <trans-unit id="006805ebc2fae21c430f8d33e716fe4291281be7" translate="yes" xml:space="preserve">
          <source>File number of stdout;</source>
          <target state="translated">stdout의 파일 번호;</target>
        </trans-unit>
        <trans-unit id="c46373a577413707e84b99ca0fd9139ae73282cb" translate="yes" xml:space="preserve">
          <source>Filenames for modules found in the standard library will be named &lt;code&gt;stdlib_module.c&lt;/code&gt;. Unless you are doing something special, you will end up with at least &lt;code&gt;stdlib_system.c&lt;/code&gt;, since the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; is always imported automatically. Same for the &lt;a href=&quot;hashes&quot;&gt;hashes module&lt;/a&gt; which will be named &lt;code&gt;stdlib_hashes.c&lt;/code&gt;. The &lt;code&gt;stdlib_&lt;/code&gt; prefix comes from the &lt;em&gt;fake&lt;/em&gt;&lt;code&gt;lib/stdlib.nimble&lt;/code&gt; file.</source>
          <target state="translated">표준 라이브러리에있는 모듈의 파일 이름은 &lt;code&gt;stdlib_module.c&lt;/code&gt; 입니다. &lt;a href=&quot;system&quot;&gt;시스템 모듈&lt;/a&gt; 은 항상 자동으로 가져 &lt;code&gt;stdlib_system.c&lt;/code&gt; 때문에 특별한 작업을 수행하지 않으면 최소한 stdlib_system.c로 끝납니다 . &lt;code&gt;stdlib_hashes.c&lt;/code&gt; 라는 &lt;a href=&quot;hashes&quot;&gt;해시 모듈&lt;/a&gt; 과 동일합니다 . &lt;code&gt;stdlib_&lt;/code&gt; 접두사는에서 온다 &lt;em&gt;가짜의 &lt;/em&gt; &lt;code&gt;lib/stdlib.nimble&lt;/code&gt; 파일.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc57d945b36594b68b2a3c3e0ebaf995f83e77da" translate="yes" xml:space="preserve">
          <source>Filenames for modules imported from &lt;a href=&quot;https://github.com/nim-lang/nimble&quot;&gt;nimble packages&lt;/a&gt; will end up with &lt;code&gt;nimblePackageName_module.c&lt;/code&gt;. For example, if you import the &lt;code&gt;argument_parser&lt;/code&gt; module from the same name nimble package you will end up with a &lt;code&gt;argument_parser_argument_parser.c&lt;/code&gt; file under &lt;code&gt;nimcache&lt;/code&gt;. The name of the nimble package comes from the &lt;code&gt;proj.nimble&lt;/code&gt; file, the actual contents are not read by the compiler.</source>
          <target state="translated">&lt;code&gt;nimblePackageName_module.c&lt;/code&gt; &lt;a href=&quot;https://github.com/nim-lang/nimble&quot;&gt;패키지&lt;/a&gt; 에서 가져온 모듈의 파일 이름은 nimblePackageName_module.c로 끝납니다 . 예를 들어, 동일한 이름의 민첩 패키지에서 &lt;code&gt;argument_parser&lt;/code&gt; 모듈 을 가져 &lt;code&gt;nimcache&lt;/code&gt; 아래에 &lt;code&gt;argument_parser_argument_parser.c&lt;/code&gt; 파일이 생깁니다 . 민첩 패키지의 이름은 &lt;code&gt;proj.nimble&lt;/code&gt; 파일 에서 가져 오며 실제 내용은 컴파일러에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a933371037aa6356cf097d60b8a8a068b105a6a" translate="yes" xml:space="preserve">
          <source>Filenames for non nimble packages (like your project) will be renamed from &lt;code&gt;.nim&lt;/code&gt; to have the extension of your target backend (from now on &lt;code&gt;.c&lt;/code&gt; for these examples), but otherwise nothing else will change. This will quickly break if your project consists of a main &lt;code&gt;proj.nim&lt;/code&gt; file which includes a &lt;code&gt;utils/proj.nim&lt;/code&gt; file: both &lt;code&gt;proj.nim&lt;/code&gt; files will generate the same name &lt;code&gt;proj.c&lt;/code&gt; output in the &lt;code&gt;nimcache&lt;/code&gt; directory overwriting themselves!</source>
          <target state="translated">프로젝트와 같은 민첩하지 않은 패키지의 파일 이름은 &lt;code&gt;.nim&lt;/code&gt; 에서 이름이 바뀌어 대상 백엔드의 확장명을 갖습니다 ( 이 예제 에서는 &lt;code&gt;.c&lt;/code&gt; 부터 ). 그렇지 않으면 다른 것은 변경되지 않습니다. 프로젝트 가 &lt;code&gt;utils/proj.nim&lt;/code&gt; 파일 을 포함 하는 기본 &lt;code&gt;proj.nim&lt;/code&gt; 파일 로 구성되어 있으면 빠르게 중단됩니다 . 두 &lt;code&gt;proj.nim&lt;/code&gt; 파일 모두 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리 덮어 쓰기 자체 에서 동일한 이름의 &lt;code&gt;proj.c&lt;/code&gt; 출력을 생성합니다 !</target>
        </trans-unit>
        <trans-unit id="b2ae50a69f411bc14345a00be6059bf4dea4b106" translate="yes" xml:space="preserve">
          <source>Files must not be &quot;forgotten&quot; to be linked.</source>
          <target state="translated">파일을 링크에서 &quot;잊어 버려&quot;서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd05fc44107052a44b6b35e9aecb58676bd658a" translate="yes" xml:space="preserve">
          <source>Files with the &lt;code&gt;.idx&lt;/code&gt; extension are generated when you use the &lt;a href=&quot;#index-switch&quot;&gt;Index switch&lt;/a&gt; along with commands to generate documentation from source or text files. You can programatically generate indices with the &lt;a href=&quot;rstgen#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;rstgen#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt; procs. The purpose of &lt;code&gt;idx&lt;/code&gt; files is to hold the interesting symbols and their HTML references so they can be later concatenated into a big index file with &lt;a href=&quot;rstgen#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt;. This section documents the file format in detail.</source>
          <target state="translated">확장자가 &lt;code&gt;.idx&lt;/code&gt; 인 파일 은 &lt;a href=&quot;#index-switch&quot;&gt;색인 스위치&lt;/a&gt; 를 명령과 함께 사용하여 소스 또는 텍스트 파일에서 문서를 생성 할 때 생성됩니다 . &lt;a href=&quot;rstgen#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; 및 &lt;a href=&quot;rstgen#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; procs를 사용하여 프로그래밍 방식으로 인덱스를 생성 할 수 있습니다 . &lt;code&gt;idx&lt;/code&gt; 파일 의 목적은 흥미로운 심볼과 HTML 참조를 보유하여 나중에 &lt;a href=&quot;rstgen#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; 를 사용하여 큰 인덱스 파일로 연결할 수 있도록하는 것 입니다. 이 섹션에서는 파일 형식에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad35d60ce8cd2f119bf179d2d09ac421cac11c3f" translate="yes" xml:space="preserve">
          <source>Filters can be combined with the &lt;code&gt;|&lt;/code&gt; pipe operator:</source>
          <target state="translated">필터는 &lt;code&gt;|&lt;/code&gt; 파이프 운영자 :</target>
        </trans-unit>
        <trans-unit id="aaa5558255bc2b843a6bc0a11a6327850e51b053" translate="yes" xml:space="preserve">
          <source>Finally, the 'type' determines how the data should be presented.</source>
          <target state="translated">마지막으로 '유형'에 따라 데이터를 표시하는 방법이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8f54f7d2cd9405c1515842c98505909ee64784fa" translate="yes" xml:space="preserve">
          <source>Find the first child node matching condition (or nil).</source>
          <target state="translated">첫 번째 하위 노드 일치 조건을 찾으십시오 (또는 nil).</target>
        </trans-unit>
        <trans-unit id="30719f0f88d14e35d99a50a7b43d9fb871f016e8" translate="yes" xml:space="preserve">
          <source>Find the page descriptor for the page the cell belongs to.</source>
          <target state="translated">셀이 속한 페이지의 페이지 디스크립터를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9a995785552ee9c2ac039b3c0c3df41b9e13f6c9" translate="yes" xml:space="preserve">
          <source>Finds the first attribute of &lt;em&gt;n&lt;/em&gt; with a name of &lt;em&gt;name&lt;/em&gt;. Returns &quot;&quot; on failure.</source>
          <target state="translated">이름이 &lt;em&gt;name&lt;/em&gt; 인 &lt;em&gt;n&lt;/em&gt; 의 첫 번째 속성을 찾습니다 . 실패하면 &quot;&quot;를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116c9d25902f0a4de6f1544ba04093c5b88e71cd" translate="yes" xml:space="preserve">
          <source>Finds the first child element of &lt;em&gt;n&lt;/em&gt; with a name of &lt;em&gt;name&lt;/em&gt;. Returns &lt;em&gt;nil&lt;/em&gt; on failure.</source>
          <target state="translated">이름이 &lt;em&gt;name&lt;/em&gt; 인 &lt;em&gt;n&lt;/em&gt; 의 첫 번째 자식 요소를 찾습니다 . 실패하면 &lt;em&gt;nil&lt;/em&gt; 을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4389c17550fe9ddc9f86819d4a7b60ae0e67f0d1" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;first&lt;/code&gt;, then returns everything from there up to &lt;code&gt;second&lt;/code&gt; (if &lt;code&gt;second&lt;/code&gt; is '0', then &lt;code&gt;first&lt;/code&gt; is used).</source>
          <target state="translated">발견의 첫번째 발생 &lt;code&gt;first&lt;/code&gt; 다음 거기 내지 모든 리턴 &lt;code&gt;second&lt;/code&gt; (만약 &lt;code&gt;second&lt;/code&gt; 후, '0'인 &lt;code&gt;first&lt;/code&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="1fa44f085f8c7a5bc6ceea9feaf111cbe756da9a" translate="yes" xml:space="preserve">
          <source>First character</source>
          <target state="translated">첫 캐릭터</target>
        </trans-unit>
        <trans-unit id="6fb97620efec2fa3a50f072b3fe2fec2847a9ff6" translate="yes" xml:space="preserve">
          <source>First class iterators</source>
          <target state="translated">퍼스트 클래스 반복자</target>
        </trans-unit>
        <trans-unit id="9425d904ba25f89814dc275a1eb0f4d3e77e6315" translate="yes" xml:space="preserve">
          <source>Fixed point. Displays the number as a fixed-point number.</source>
          <target state="translated">고정 점. 숫자를 고정 소수점 숫자로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e63454c17e4292081d77b79e20733cc89121e3be" translate="yes" xml:space="preserve">
          <source>Fixed point. Same as 'f' except it converts the number to uppercase.</source>
          <target state="translated">고정 점. 숫자를 대문자로 변환한다는 점을 제외하고 'f'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f9deb82314740be86449314d50ff9ec9da219490" translate="yes" xml:space="preserve">
          <source>Float literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default float type:</source>
          <target state="translated">부동 리터럴에는 기본이 아닌 부동 유형을 지정하기 위해 &lt;em&gt;유형 접미사&lt;/em&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4709f8479ca7711f846d5473ffd0b30643744aba" translate="yes" xml:space="preserve">
          <source>Floating point literals may also be in binary, octal or hexadecimal notation: &lt;code&gt;0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64&lt;/code&gt; is approximately 1.72826e35 according to the IEEE floating point standard.</source>
          <target state="translated">부동 소수점 리터럴은 2 진, 8 진 또는 16 진 표기법 일 수도 있습니다. &lt;code&gt;0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64&lt;/code&gt; 는 IEEE 부동 소수점 표준에 따라 약 1.72826e35입니다.</target>
        </trans-unit>
        <trans-unit id="b19d1e4b5ac02d569d7b1224c5537d91831a7f87" translate="yes" xml:space="preserve">
          <source>Floating-point environment. Handling of floating-point rounding and exceptions (overflow, division by zero, etc.).</source>
          <target state="translated">부동 소수점 환경. 부동 소수점 반올림 및 예외 처리 (오버플로, 0으로 나누기 등).</target>
        </trans-unit>
        <trans-unit id="c9fdb9f56bbed11dccf6a43b0581d80890cf2517" translate="yes" xml:space="preserve">
          <source>Floats</source>
          <target state="translated">Floats</target>
        </trans-unit>
        <trans-unit id="0b8bb28712c30f69189ad1e4c48e26c04e7296ed" translate="yes" xml:space="preserve">
          <source>Floor division is conceptually defined as &lt;code&gt;floor(x / y)&lt;/code&gt;. This is different from the &lt;code&gt;div&lt;/code&gt; operator, which is defined as &lt;code&gt;trunc(x / y)&lt;/code&gt;. That is, &lt;code&gt;div&lt;/code&gt; rounds towards &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;floorDiv&lt;/code&gt; rounds down.</source>
          <target state="translated">바닥 구분은 개념적으로 &lt;code&gt;floor(x / y)&lt;/code&gt; 로 정의됩니다 . 이것은 &lt;code&gt;trunc(x / y)&lt;/code&gt; 로 정의 된 &lt;code&gt;div&lt;/code&gt; 연산자와 다릅니다 . 즉, &lt;code&gt;div&lt;/code&gt; 대한 원 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;floorDiv&lt;/code&gt; 는 아래로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="507e183eb0245f3035a2072cd5bbfa4b4fe3cfd9" translate="yes" xml:space="preserve">
          <source>Floor modulus is conceptually defined as &lt;code&gt;x - (floorDiv(x, y) * y). This proc behaves the same as the ``%&lt;/code&gt; operator in python.</source>
          <target state="translated">바닥 계수는 개념적으로 &lt;code&gt;x - (floorDiv(x, y) * y). This proc behaves the same as the ``%&lt;/code&gt; 로 정의됩니다 . 이 proc은`` python의 % 연산자 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="b68a30374763b478aa4e124731b01b2713f1f18a" translate="yes" xml:space="preserve">
          <source>Flushes &lt;em&gt;f&lt;/em&gt;'s buffer for the number of attempts equal to &lt;em&gt;attempts&lt;/em&gt;. If were errors an exception &lt;em&gt;OSError&lt;/em&gt; will be raised.</source>
          <target state="translated">시도 횟수와 동일한 횟수로 &lt;em&gt;f&lt;/em&gt; 의 버퍼를 플러시 &lt;em&gt;합니다&lt;/em&gt; . 오류 인 경우 예외 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3be2c81cbf56cdb975e556d6b5fbea831465559e" translate="yes" xml:space="preserve">
          <source>Flushes &lt;em&gt;f&lt;/em&gt;'s buffer.</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; 의 버퍼를 플러시 합니다.</target>
        </trans-unit>
        <trans-unit id="c25050c008414c32efb1dc94b6d6e01b1c908aed" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;let&lt;/code&gt; symbols a copy is not always necessary:</source>
          <target state="translated">대한 &lt;code&gt;let&lt;/code&gt; 상징 사본은 항상 필요하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="93eae6a8185698ce3b52d68a8a1fdbd2033c2edc" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;poll&lt;/em&gt; and &lt;em&gt;select&lt;/em&gt; selectors &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">대한 &lt;em&gt;설문 조사&lt;/em&gt; 및 &lt;em&gt;선택&lt;/em&gt; 선택기 &lt;code&gt;-1&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c94fe4e1280ca06c679c18c21a534b0efbabcc4" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;safe&lt;/em&gt; data exchange between &lt;code&gt;f&lt;/code&gt; and the caller a global &lt;code&gt;TChannel&lt;/code&gt; needs to be used. However, since spawn can return a result, often no further communication is required.</source>
          <target state="translated">들면 &lt;em&gt;금고&lt;/em&gt; 간의 데이터 교환 &lt;code&gt;f&lt;/code&gt; 호출자 글로벌 &lt;code&gt;TChannel&lt;/code&gt; 가 사용되어야한다. 그러나 스폰은 결과를 반환 할 수 있으므로 더 이상 통신이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45da4482954f28ab16fcb0291f1dcae1eb3d1129" translate="yes" xml:space="preserve">
          <source>For CSV files with a header row, the header can be read and then used as a reference for item access with &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt;:</source>
          <target state="translated">헤더 행이있는 CSV 파일의 경우 헤더를 읽고 &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt; 를 사용하여 항목 액세스에 대한 참조로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0242b091c3a87873ec98ea878a8dd380d1d20c4f" translate="yes" xml:space="preserve">
          <source>For SSL support this module relies on OpenSSL. If you want to enable SSL, compile with &lt;code&gt;-d:ssl&lt;/code&gt;.</source>
          <target state="translated">SSL 지원을 위해이 모듈은 OpenSSL을 사용합니다. SSL을 사용하려면 &lt;code&gt;-d:ssl&lt;/code&gt; 을 사용하여 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c826cb55e40a0152d8b6297bef6da259dfc72eb" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;JsonNode&lt;/code&gt; who's kind is &lt;code&gt;JObject&lt;/code&gt;, you can acess its fields using the &lt;code&gt;[]&lt;/code&gt; operator. The following example shows how to do this:</source>
          <target state="translated">A에 대한 &lt;code&gt;JsonNode&lt;/code&gt; 종류의이다 &lt;code&gt;JObject&lt;/code&gt; , 당신은 사용하여 필드를 ACESS 수 있습니다 &lt;code&gt;[]&lt;/code&gt; 연산자를. 다음 예제는이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c37182cb924bb624a7088fb745305dafdcf10c15" translate="yes" xml:space="preserve">
          <source>For a release version use:</source>
          <target state="translated">릴리스 버전의 경우 :</target>
        </trans-unit>
        <trans-unit id="d05dd7196bfebecfb5e43d1a1b6a86b9cd04aa9e" translate="yes" xml:space="preserve">
          <source>For a routine &lt;code&gt;p&lt;/code&gt; the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on &lt;code&gt;p&lt;/code&gt;'s call graph:</source>
          <target state="translated">루틴 &lt;code&gt;p&lt;/code&gt; 의 경우 컴파일러는 추론 규칙을 사용하여 가능한 예외 세트를 결정합니다. 알고리즘은 &lt;code&gt;p&lt;/code&gt; 의 호출 그래프 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="62deebd5b6d9318d830bba76bfa2f8fef9acd3df" translate="yes" xml:space="preserve">
          <source>For a slice &lt;em&gt;a .. b&lt;/em&gt; returns a value in the range &lt;em&gt;a .. b-1&lt;/em&gt;. &lt;strong&gt;Deprecated since version 0.18.0&lt;/strong&gt;. Use &lt;code&gt;rand&lt;/code&gt; instead.</source>
          <target state="translated">슬라이스 &lt;em&gt;a .. b&lt;/em&gt; 의 경우 &lt;em&gt;a .. b-1&lt;/em&gt; 범위 &lt;em&gt;의&lt;/em&gt; 값을 반환합니다 . &lt;strong&gt;버전 0.18.0부터 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;code&gt;rand&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="34b1c5436f8148b5507779ddb104dba21e9b926d" translate="yes" xml:space="preserve">
          <source>For a slice &lt;em&gt;a .. b&lt;/em&gt; returns a value in the range &lt;em&gt;a .. b&lt;/em&gt;.</source>
          <target state="translated">슬라이스 a..b의 &lt;em&gt;경우 a..b&lt;/em&gt; 범위 &lt;em&gt;의&lt;/em&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8452d704bc107017adee94ca36f643a56bd5272a" translate="yes" xml:space="preserve">
          <source>For a specification of the &lt;code&gt;&amp;amp;&lt;/code&gt; macro, see the module level documentation.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 매크로 의 사양은 모듈 수준 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7afbbc7a944bdae2a321287d22dceb33fb748d7e" translate="yes" xml:space="preserve">
          <source>For a toplevel emit statement the section where in the generated C/C++ file the code should be emitted can be influenced via the prefixes &lt;code&gt;/*TYPESECTION*/&lt;/code&gt; or &lt;code&gt;/*VARSECTION*/&lt;/code&gt; or &lt;code&gt;/*INCLUDESECTION*/&lt;/code&gt;:</source>
          <target state="translated">최상위 레벨 emit 문의 경우, 생성 된 C / C ++ 파일에서 코드가 방출되어야하는 섹션은 접두사 &lt;code&gt;/*TYPESECTION*/&lt;/code&gt; 또는 &lt;code&gt;/*VARSECTION*/&lt;/code&gt; 또는 &lt;code&gt;/*INCLUDESECTION*/&lt;/code&gt; 를 통해 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b81eef4c1cbf50e8420e0c334dd047d24a51c0df" translate="yes" xml:space="preserve">
          <source>For backward compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="b8aab3834714de2c3d8adfb34a6816ec7d88ac0a" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, if the argument to the &lt;code&gt;emit&lt;/code&gt; statement is a single string literal, Nim symbols can be referred to via backticks. This usage is however deprecated.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;emit&lt;/code&gt; 문에 대한 인수가 단일 문자열 리터럴 인 경우 백틱을 통해 Nim 기호를 참조 할 수 있습니다. 그러나이 사용법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c2a63fd55994e33a6c697c0db6532833f78e796" translate="yes" xml:space="preserve">
          <source>For better interfacing to other programming languages, the fields of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A field whose ordinal value is not explicitly given is assigned the value of the previous field + 1.</source>
          <target state="translated">다른 프로그래밍 언어와의 인터페이스를 개선하기 위해 열거 형 필드에 명시적인 서수 값을 할당 할 수 있습니다. 그러나 서수 값은 오름차순이어야합니다. 서수 값이 명시 적으로 주어지지 않은 필드에는 이전 필드 + 1의 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="5f99de42e817dbe899e9068c1a506a2b0085b960" translate="yes" xml:space="preserve">
          <source>For better interfacing to other programming languages, the symbols of enum types can be assigned an explicit ordinal value. However, the ordinal values must be in ascending order.</source>
          <target state="translated">다른 프로그래밍 언어와의 인터페이스를 개선하기 위해 열거 형 심볼에 명시적인 서수 값을 할당 할 수 있습니다. 그러나 서수 값은 오름차순이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a3e556431f7fdff11ba27ff4e2fe38111fc0a0d5" translate="yes" xml:space="preserve">
          <source>For binary operators that are not keywords the precedence is determined by the following rules:</source>
          <target state="translated">키워드가 아닌 이진 연산자의 우선 순위는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="50e70d3b2cf30a567fbbd7db505ed0bac67c53e0" translate="yes" xml:space="preserve">
          <source>For buffered sockets this function will attempt to read all the requested data. It will read this data in &lt;code&gt;BufferSize&lt;/code&gt; chunks.</source>
          <target state="translated">버퍼 소켓의 경우이 함수는 요청 된 모든 데이터를 읽으려고 시도합니다. 이 데이터를 읽습니다 &lt;code&gt;BufferSize&lt;/code&gt; 청크로 .</target>
        </trans-unit>
        <trans-unit id="b07bee32e3d9817814d2d5762aa7e5112fbbb6a7" translate="yes" xml:space="preserve">
          <source>For building URIs you may wish to use `/` instead.</source>
          <target state="translated">URI를 빌드하는 경우`/`를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56aa9c952e34a0418a5a4c9eec099b7963eda0ac" translate="yes" xml:space="preserve">
          <source>For client sockets you should only be interested in the &lt;code&gt;handleRead&lt;/code&gt; and &lt;code&gt;handleConnect&lt;/code&gt; events. The former gets called whenever the socket has received messages and can be read from and the latter gets called whenever the socket has established a connection to a server socket; from that point it can be safely written to.</source>
          <target state="translated">클라이언트 소켓의 경우 &lt;code&gt;handleRead&lt;/code&gt; 및 &lt;code&gt;handleConnect&lt;/code&gt; 에만 관심이 있어야합니다. 이벤트 합니다. 전자는 소켓이 메시지를 수신 할 때마다 호출되고 읽을 수 있으며 후자는 소켓이 서버 소켓에 연결될 때마다 호출됩니다. 그 시점부터 안전하게 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf84e8819d7b798ed0f33860eca0b4d23e243863" translate="yes" xml:space="preserve">
          <source>For compatibility with Perl, &lt;code&gt;\s&lt;/code&gt; does not match the VT character (code 11). This makes it different from the the POSIX &quot;space&quot; class. The &lt;code&gt;\s&lt;/code&gt; characters are HT (9), LF (10), FF (12), CR (13), and space (32).</source>
          <target state="translated">Perl과의 호환성을 위해 &lt;code&gt;\s&lt;/code&gt; 는 VT 문자 (코드 11)와 일치하지 않습니다. 이것은 POSIX &quot;space&quot;클래스와 다릅니다. &lt;code&gt;\s&lt;/code&gt; 자 HT (9), LF (10), FF (12), CR (13) 및 공간 (32)이다.</target>
        </trans-unit>
        <trans-unit id="04a21c372d5006a94127af5667affc0f95a564d8" translate="yes" xml:space="preserve">
          <source>For consistency with &lt;code&gt;object&lt;/code&gt; declarations, tuples in a &lt;code&gt;type&lt;/code&gt; section can also be defined with indentation instead of &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 선언 과 일관성을 유지하기 위해 &lt;code&gt;type&lt;/code&gt; 섹션의 튜플 을 &lt;code&gt;[]&lt;/code&gt; 대신 들여 쓰기로 정의 할 수도 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="56f219e03de2a46a6add0fb8b66238ad6651513a" translate="yes" xml:space="preserve">
          <source>For constants coming from a C/C++ wrapper, ALL_UPPERCASE are allowed, but ugly. (Why shout CONSTANT? Constants do no harm, variables do!)</source>
          <target state="translated">C / C ++ 랩퍼에서 오는 상수의 경우 ALL_UPPERCASE가 허용되지만 추악합니다. 상수는 해를 끼치 지 않으며 변수는 해 롭습니다!</target>
        </trans-unit>
        <trans-unit id="eea6f2ab43bc6b381d32b3dbb31175730e9dc10c" translate="yes" xml:space="preserve">
          <source>For convenience the PEG pattern and the replacement can be single identifiers too, there is no need to quote them:</source>
          <target state="translated">편의상 PEG 패턴 및 대체는 단일 식별자 일 수 있으며,이를 인용 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fe02d597cd0aceb5f5e862dbd619f6afc8eff0a" translate="yes" xml:space="preserve">
          <source>For convenience you can access the returned tuples through the named fields &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. If one container is shorter, the remaining items in the longer container are discarded.</source>
          <target state="translated">편의상 명명 된 필드 &lt;em&gt;a&lt;/em&gt; 및 &lt;em&gt;b를&lt;/em&gt; 통해 반환 된 튜플에 액세스 할 수 있습니다 . 하나의 컨테이너가 더 짧은 경우, 더 긴 컨테이너의 나머지 항목은 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="eb68ce2fa4474dfa498dc8618e15328f34f957b8" translate="yes" xml:space="preserve">
          <source>For cross compilation, the compiler invokes a C compiler named like &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; (for example arm.linux.gcc) and the configuration system is used to provide meaningful defaults. For example for &lt;code&gt;ARM&lt;/code&gt; your configuration file should contain something like:</source>
          <target state="translated">크로스 컴파일의 경우 컴파일러는 &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; (예 : arm.linux.gcc)와 같은 C 컴파일러를 호출 하고 구성 시스템은 의미있는 기본값을 제공하는 데 사용됩니다. 예를 들어 &lt;code&gt;ARM&lt;/code&gt; 의 경우 구성 파일에는 다음과 같은 내용이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bfddb4fd4901c9377aa65c5c53f4fed568adddec" translate="yes" xml:space="preserve">
          <source>For determining a &lt;code&gt;raises&lt;/code&gt; list, the &lt;code&gt;raise&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt; statements of &lt;code&gt;p&lt;/code&gt; are taken into consideration.</source>
          <target state="translated">&lt;code&gt;raises&lt;/code&gt; 목록을 결정하기 &lt;code&gt;raise&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; 의 raise 및 &lt;code&gt;try&lt;/code&gt; 문이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="f6433d7fa88d46fa2ef63d15b0a2f1c232846783" translate="yes" xml:space="preserve">
          <source>For each input line we have to create a constant definition (&lt;code&gt;nnkConstDef&lt;/code&gt;) and wrap it inside a constant section (&lt;code&gt;nnkConstSection&lt;/code&gt;). Once these variables are created, we fill them hierarchichally (line 17) like the previous AST dump tree showed: the constant definition is a child of the section definition, and the constant definition has an identifier node, an empty node (we let the compiler figure out the type), and a string literal with the value.</source>
          <target state="translated">각 입력 줄에 대해 상수 정의 ( &lt;code&gt;nnkConstDef&lt;/code&gt; ) 를 작성하고 이를 상수 섹션 ( &lt;code&gt;nnkConstSection&lt;/code&gt; )으로 랩핑해야합니다 . 이러한 변수가 생성되면 이전 AST 덤프 트리와 같이 계층 적으로 (17 행) 변수를 채 웁니다. 상수 정의는 섹션 정의의 자식이고 상수 정의에는 식별자 노드, 빈 노드가 있습니다 (컴파일러를 허용합니다) 유형을 파악하고 값이 포함 된 문자열 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="5d10f6f6e4da7bf81dd537bc78c82cd345945246" translate="yes" xml:space="preserve">
          <source>For easier interoperability with other compiled languages such as C, retrieving the address of a &lt;code&gt;let&lt;/code&gt; variable, a parameter or a &lt;code&gt;for&lt;/code&gt; loop variable, the &lt;code&gt;unsafeAddr&lt;/code&gt; operation can be used:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 변수, 매개 변수 또는 &lt;code&gt;for&lt;/code&gt; 루프 변수 의 주소를 검색하는 C와 같은 다른 컴파일 된 언어와의보다 쉬운 상호 운용성을 위해 &lt;code&gt;unsafeAddr&lt;/code&gt; 작업을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da10bc47ce513830b3757fe3c7440fcd62b179cc" translate="yes" xml:space="preserve">
          <source>For either value of &lt;code&gt;skipNonAlpha&lt;/code&gt;, returns false if &lt;code&gt;s&lt;/code&gt; is an empty string.</source>
          <target state="translated">&lt;code&gt;skipNonAlpha&lt;/code&gt; 값 중 하나에 대해 &lt;code&gt;s&lt;/code&gt; 가 빈 문자열 이면 false를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e6c82f147503f7c257ef61cf3047e2f8c4af476c" translate="yes" xml:space="preserve">
          <source>For every other call the analysis can determine an exact &lt;code&gt;raises&lt;/code&gt; list.</source>
          <target state="translated">다른 모든 통화에 대해 분석은 정확한 &lt;code&gt;raises&lt;/code&gt; 목록을 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6dc513bae3196a45b6b788484cf2f9e6b9080fd1" translate="yes" xml:space="preserve">
          <source>For example C++'s &lt;code&gt;new&lt;/code&gt; operator can be &quot;imported&quot; like this:</source>
          <target state="translated">예를 들어 C ++의 &lt;code&gt;new&lt;/code&gt; 연산자는 다음과 같이 &quot;가져올 수 있습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="d6943604d0d0031805c4f8cff45ec5239cbec0ac" translate="yes" xml:space="preserve">
          <source>For example on Unix:</source>
          <target state="translated">예를 들어 유닉스에서 :</target>
        </trans-unit>
        <trans-unit id="8da3513cd0ef136598e40fc41ccc6496e8f86d48" translate="yes" xml:space="preserve">
          <source>For example, if a system had &lt;em&gt;#&lt;/em&gt; as a delimiter, you could do the following to get the tail of the path:</source>
          <target state="translated">예를 들어, 시스템 에 구분 기호로 &lt;em&gt;#&lt;/em&gt; 이 있으면 경로의 꼬리를 얻기 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f1d5711f93558dbbd9946c13e3cca40ecd81c0d" translate="yes" xml:space="preserve">
          <source>For example, if you want to match a &lt;code&gt;*&lt;/code&gt; character, you write &lt;code&gt;\*&lt;/code&gt; in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;*&lt;/code&gt; 문자 를 일치 시키려면 패턴에 &lt;code&gt;\*&lt;/code&gt; 를 씁니다 . 이 이스케이프 동작은 다음 문자가 메타 문자로 해석되는지 여부에 따라 적용되므로 영숫자가 아닌 문자 앞에 백 슬래시를 붙여서 자신을 나타내는 것으로 지정하는 것이 안전합니다. 특히 백 슬래시와 일치 시키려면 &lt;code&gt;\\&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e8063e111c73956a53cf7043ebd6ff7c73d1a5" translate="yes" xml:space="preserve">
          <source>For example, to generate code for an &lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt; processor use this command:</source>
          <target state="translated">예를 들어, &lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt; 프로세서 용 코드를 생성 하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d524a00442ffaa71bfebe71d2798beae54e3c6ce" translate="yes" xml:space="preserve">
          <source>For example, with the above mentioned config:</source>
          <target state="translated">예를 들어, 위에서 언급 한 설정으로 :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a979257c11b99f6ef8da4c81ce4f3101724cf59" translate="yes" xml:space="preserve">
          <source>For example: &quot;..&quot; for POSIX or &quot;::&quot; for the classic Macintosh.</source>
          <target state="translated">예를 들어 POSIX의 경우 &quot;..&quot;또는 기본 Macintosh의 경우 &quot;::&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ce7ab614d3eacbc0791f3fe3e19af3be1ce99832" translate="yes" xml:space="preserve">
          <source>For example: '.' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">예를 들어 '.' POSIX의 경우 또는 기존 Macintosh의 경우 ':'.</target>
        </trans-unit>
        <trans-unit id="037a4a3add4baf2d3ff924d7337a1bbfa00ace3f" translate="yes" xml:space="preserve">
          <source>For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet module&lt;/a&gt;.</source>
          <target state="translated">예를 들어 비동기 IO를 구현하는 모듈에 대한 설명서를 살펴보십시오. 시작하기 좋은 곳은 &lt;a href=&quot;asyncnet&quot;&gt;asyncnet 모듈&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc3abbf1f795d4e9d5c1784083fe048325a83d84" translate="yes" xml:space="preserve">
          <source>For functional style programming you may want to pass &lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; to procs like &lt;code&gt;filter&lt;/code&gt; to reduce typing. Anonymous procs can use &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;the special do notation&lt;/a&gt; which is more convenient in certain situations.</source>
          <target state="translated">함수형 프로그래밍의 경우 입력을 줄이기 위해 &lt;code&gt;filter&lt;/code&gt; 와 같은 &lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;프로세스&lt;/a&gt; 에 익명 프로세스 를 전달할 수 있습니다 . 익명의 procs는 특정 상황에서 더 편리한 &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;특수 표기법&lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87503a2c24062ef64c2113839dd981902727d48c" translate="yes" xml:space="preserve">
          <source>For further details, see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;컨버터블 관계를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="0f62f66675d36a6676ee88d1387217b9a0cb3dbf" translate="yes" xml:space="preserve">
          <source>For instance, the following directive</source>
          <target state="translated">예를 들어, 다음 지시문</target>
        </trans-unit>
        <trans-unit id="8770baa4a92dda2f0c75267da1bf45a501c6f548" translate="yes" xml:space="preserve">
          <source>For iterators, a component of a tuple return type can have a &lt;code&gt;var&lt;/code&gt; type too:</source>
          <target state="translated">반복자의 경우 튜플 리턴 유형의 구성 요소는 &lt;code&gt;var&lt;/code&gt; 유형도 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bec3615cf893c57a0cbb546697b4dd32edca860" translate="yes" xml:space="preserve">
          <source>For let variables the same pragmas are available as for ordinary variables.</source>
          <target state="translated">변수의 경우 일반 변수와 동일한 pragma를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec1a5d2526c1a701579992b7f06bf43e3a282a0" translate="yes" xml:space="preserve">
          <source>For loop macros</source>
          <target state="translated">루프 매크로</target>
        </trans-unit>
        <trans-unit id="4c0c7feb9fa0ff4f152b87b5bc78bff622fe2f93" translate="yes" xml:space="preserve">
          <source>For more information read &lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;http://www.unix.com/man-page/posix/3/utimes/&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;http://www.unix.com/man-page/posix/3/utimes/를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b270b757b3673b1757f055c08aa37dc2ffdc3b3a" translate="yes" xml:space="preserve">
          <source>For most applications using &lt;code&gt;asyncnet&lt;/code&gt; is the way to go as it builds over all the layers, providing some extra features such as buffering.</source>
          <target state="translated">&lt;code&gt;asyncnet&lt;/code&gt; 을 사용하는 대부분의 응용 프로그램 은 모든 계층에 구축되어 버퍼링과 같은 추가 기능을 제공하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b855e8d2a69b94fb603cd76d8ffd3b97477d2b9d" translate="yes" xml:space="preserve">
          <source>For most purposes you do not need to worry about the &lt;code&gt;Delegate&lt;/code&gt; type. The &lt;code&gt;AsyncSocket&lt;/code&gt; is what you are after. It's a reference to the &lt;code&gt;AsyncSocketObj&lt;/code&gt; object. This object defines events which you should overwrite by your own procedures.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;Delegate&lt;/code&gt; 유형 에 대해 걱정할 필요가 없습니다 . &lt;code&gt;AsyncSocket&lt;/code&gt; 은 당신이 후에 무엇이다. &lt;code&gt;AsyncSocketObj&lt;/code&gt; 객체에 대한 참조 입니다. 이 객체는 자신의 프로 시저로 덮어 써야하는 이벤트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="82c56a62c887a5008858ef06fc31221465f85713" translate="yes" xml:space="preserve">
          <source>For non ordinal types it is not possible to list every possible value and so these always require an &lt;code&gt;else&lt;/code&gt; part.</source>
          <target state="translated">서 수가 아닌 유형의 경우 가능한 모든 값을 나열 할 수 없으므로 항상 &lt;code&gt;else&lt;/code&gt; 부분이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f2b8bbe837ee8842537829c10888fa08ecf522a6" translate="yes" xml:space="preserve">
          <source>For now, a closure iterator cannot be evaluated at compile time.</source>
          <target state="translated">현재로서는 컴파일 타임에 클로저 반복자를 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25d429d625fe5e6a8fac368190dac2b15a574c80" translate="yes" xml:space="preserve">
          <source>For object oriented programming, the syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. The parentheses can be omitted if there are no remaining arguments: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">객체 지향 프로그래밍 의 경우 &lt;code&gt;method(obj, args)&lt;/code&gt; 대신 &lt;code&gt;obj.method(args)&lt;/code&gt; 구문을 사용할 수 있습니다 . 나머지 인수가없는 경우 괄호를 생략 할 수 있습니다 : &lt;code&gt;obj.len&lt;/code&gt; ( &lt;code&gt;len(obj)&lt;/code&gt; 대신 ).</target>
        </trans-unit>
        <trans-unit id="e047dc8cf0cf0c6f8e9fbc9b5e9a48f6934f18d4" translate="yes" xml:space="preserve">
          <source>For parameters it currently creates implicitly generic routines:</source>
          <target state="translated">매개 변수의 경우 현재 암시 적으로 일반적인 루틴을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0381d3dfe342faa183e25e1ee71de71a0859eee8" translate="yes" xml:space="preserve">
          <source>For procedures $1 is the return type of the procedure, $2 is the name of the procedure and $3 is the parameter list.</source>
          <target state="translated">프로 시저의 경우 $ 1은 프로 시저의 리턴 유형이고 $ 2는 프로 시저 이름이며 $ 3은 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="34556ac1ba7d733468b2f993f99301502888774e" translate="yes" xml:space="preserve">
          <source>For reasons of type safety and implementation simplicity the expression that &lt;code&gt;spawn&lt;/code&gt; takes is restricted:</source>
          <target state="translated">타입 안전성과 구현의 단순성으로 인해 &lt;code&gt;spawn&lt;/code&gt; 되는 표현 은 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="531f693384cd4ad63c34772dfec0f60d10560ced" translate="yes" xml:space="preserve">
          <source>For server sockets the only event you need to worry about is the &lt;code&gt;handleAccept&lt;/code&gt; event, in your handleAccept proc you should call &lt;code&gt;accept&lt;/code&gt; on the server socket which will give you the client which is connecting. You should then set any events that you want to use on that client and add it to your dispatcher using the &lt;code&gt;register&lt;/code&gt; procedure.</source>
          <target state="translated">서버 소켓의 경우 &lt;code&gt;handleAccept&lt;/code&gt; 이벤트 만 걱정해야 합니다. handleAccept proc 에서는 서버 소켓에서 &lt;code&gt;accept&lt;/code&gt; 를 호출 하여 연결중인 클라이언트를 제공해야합니다. 그런 다음 해당 클라이언트에서 사용할 이벤트를 설정하고 &lt;code&gt;register&lt;/code&gt; 절차를 사용하여 디스패처에 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="38d9bef073eca3a25be73089c4f87edb342cf60c" translate="yes" xml:space="preserve">
          <source>For statement</source>
          <target state="translated">진술</target>
        </trans-unit>
        <trans-unit id="50e66b9d8bd4ebf421c876d84099cdc2470a333b" translate="yes" xml:space="preserve">
          <source>For strings and numeric types the optional argument is a so-called &quot;standard format specifier&quot;.</source>
          <target state="translated">문자열 및 숫자 유형의 경우 선택적 인수는 &quot;표준 형식 지정자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5118253ef90c345c13ce011297a04d47555e82ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;NimNode&lt;/code&gt; type, the &lt;code&gt;[]&lt;/code&gt; operator has been overloaded: &lt;code&gt;n[i]&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;'s &lt;code&gt;i&lt;/code&gt;-th child.</source>
          <target state="translated">들어 &lt;code&gt;NimNode&lt;/code&gt; 의 종류, &lt;code&gt;[]&lt;/code&gt; : 연산자 과부하 된 &lt;code&gt;n[i]&lt;/code&gt; 인 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;i&lt;/code&gt; 번째 자식.</target>
        </trans-unit>
        <trans-unit id="5b23d075b9b8ec0ab77df3a4277b9163e7d757d8" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;standalone&lt;/code&gt; target one needs to provide a file &lt;code&gt;panicoverride.nim&lt;/code&gt;. See &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; for an example implementation. Additionally, users should specify the amount of heap space to use with the &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; command line switch. Note that the total heap size will be &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt;.</source>
          <target state="translated">를 들어 &lt;code&gt;standalone&lt;/code&gt; 목표 중 하나는 파일 제공해야 &lt;code&gt;panicoverride.nim&lt;/code&gt; 을 . 구현 예는 &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; 을 참조하십시오 . 또한 사용자는 &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; 명령 행 스위치 와 함께 사용할 힙 공간을 지정해야 합니다. 총 힙 크기는 &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e28f94973a02fa8efb6d2d9f2bdf6b84f68ef4a9" translate="yes" xml:space="preserve">
          <source>For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).</source>
          <target state="translated">코드 생성을 위해 모든 정적 매개 변수는 일반 매개 변수로 처리됩니다. proc는 각 고유 한 제공된 값 (또는 값의 조합)에 대해 별도로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="7a599903250272239a970ef2b91cb9fbc4cc7a6e" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by Nimsuggest and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">이러한 종류의 쿼리의 경우 IDE는 Nimsuggest가 제공하는 모든 유형 / 서명 정보를 무시하고 반환 된 여러 응답의 파일 이름, 줄 및 열 위치에 집중합니다.</target>
        </trans-unit>
        <trans-unit id="21e8a16f7bac8ed1e3af0648dd4af16f400ffa1b" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by idetools and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">이러한 종류의 쿼리의 경우 IDE는 idetools가 제공하는 모든 유형 / 서명 정보를 무시하고 반환 된 여러 응답의 파일 이름, 줄 및 열 위치에 집중합니다.</target>
        </trans-unit>
        <trans-unit id="4f2a830522144ce433b177e154438fbea54f01ba" translate="yes" xml:space="preserve">
          <source>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</source>
          <target state="translated">버퍼되지 않은 소켓의 경우이 함수는 요청 된 모든 데이터를 읽으려고 노력하지 않습니다. 운영 체제가 제공하는만큼의 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f29c22d667f2c9809200dc3c652631cb432b95f9" translate="yes" xml:space="preserve">
          <source>For variables $1 in the format string represents the type of the variable and $2 is the name of the variable.</source>
          <target state="translated">형식 문자열에서 변수 $ 1의 경우 변수 유형을 나타내고 $ 2는 변수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b57f0c15791c6915cb3fe418d16a695f3e93406f" translate="yes" xml:space="preserve">
          <source>Forces the field to be centered within the available space.</source>
          <target state="translated">사용 가능한 공간 내에서 필드를 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="d7b27b7009675d9666afa3d1598bf15fcf934615" translate="yes" xml:space="preserve">
          <source>Forces the field to be left-aligned within the available space. (This is the default for strings.)</source>
          <target state="translated">사용 가능한 공간 내에서 필드가 왼쪽 정렬되도록합니다. (이것은 문자열의 기본값입니다.)</target>
        </trans-unit>
        <trans-unit id="5401c23ac1c35518b24a7af9c1a0f66703531dae" translate="yes" xml:space="preserve">
          <source>Forces the field to be right-aligned within the available space. (This is the default for numbers.)</source>
          <target state="translated">사용 가능한 공간 내에서 필드가 오른쪽 정렬되도록합니다. 숫자의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5e823a3f6053e51d24188588d1235d16fdedb5e9" translate="yes" xml:space="preserve">
          <source>Foreign function interface</source>
          <target state="translated">외국 기능 인터페이스</target>
        </trans-unit>
        <trans-unit id="62f5fffe14b79a85984464c3815f9c99671b76a7" translate="yes" xml:space="preserve">
          <source>Format &lt;code&gt;dt&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;dt&lt;/code&gt; 로 지정된 형식 사용하여 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc91fa1264bb70f29dff1283c89ce3d70708411e" translate="yes" xml:space="preserve">
          <source>Format a log message using the &lt;code&gt;frmt&lt;/code&gt; format string, &lt;code&gt;level&lt;/code&gt; and varargs. See the module documentation for the format string syntax.</source>
          <target state="translated">&lt;code&gt;frmt&lt;/code&gt; 형식 문자열, &lt;code&gt;level&lt;/code&gt; 및 varargs를 사용하여 로그 메시지를 형식화하십시오 . 형식 문자열 구문에 대해서는 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5fd1007724ad6493fdeb7d3d2e1c8dcb319f39f" translate="yes" xml:space="preserve">
          <source>Format strings support the following variables which must be prefixed with the dollar operator (&lt;code&gt;$&lt;/code&gt;):</source>
          <target state="translated">형식 문자열은 달러 연산자 ( &lt;code&gt;$&lt;/code&gt; )를 접두어로 붙여야하는 다음 변수를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9a5aa38b4d926a0fd6b7ab965445c10223a0ef52" translate="yes" xml:space="preserve">
          <source>Formatting floats</source>
          <target state="translated">수레 포맷</target>
        </trans-unit>
        <trans-unit id="119b045ed7d9e9597e047eb5230d1263cac6b285" translate="yes" xml:space="preserve">
          <source>Formatting strings</source>
          <target state="translated">문자열 서식</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">전달 선언</target>
        </trans-unit>
        <trans-unit id="863ed164c9c45905d0e8f390e051e690266656e8" translate="yes" xml:space="preserve">
          <source>Forward definitions work properly, you just need to always add the &lt;code&gt;{.async.}&lt;/code&gt; pragma:</source>
          <target state="translated">정방향 정의가 제대로 작동하려면 항상 &lt;code&gt;{.async.}&lt;/code&gt; pragma를 추가하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cd6940a09171e7ee9b5773accc63e225abdd1b0" translate="yes" xml:space="preserve">
          <source>Found nodes satisfying the condition will be appended to the &lt;em&gt;result&lt;/em&gt; sequence, which can't be nil or the proc will crash. Usage example:</source>
          <target state="translated">조건을 만족하는 발견 된 노드는 &lt;em&gt;결과&lt;/em&gt; 시퀀스에 추가되며, nil 일 수 없거나 proc이 충돌합니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="9451eac4434aa603b5d91f3457a805bcfe91aafd" translate="yes" xml:space="preserve">
          <source>Free memory referenced by SSLContext.</source>
          <target state="translated">SSLContext가 참조한 사용 가능한 메모리</target>
        </trans-unit>
        <trans-unit id="217bf834335a4b2616a03e550f18eef5531ae2a0" translate="yes" xml:space="preserve">
          <source>Frees the resources associated with the lock.</source>
          <target state="translated">잠금과 관련된 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="54d3a1861da397f72e90bc587323bda31c9c723e" translate="yes" xml:space="preserve">
          <source>Friendlier version of the low-level &lt;code&gt;sendTo&lt;/code&gt;.</source>
          <target state="translated">낮은 수준의 &lt;code&gt;sendTo&lt;/code&gt; 의 친숙한 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="0651a01fbb901bf5682fe3d0d43a4123bbbc43b0" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;n&lt;/code&gt; up to &lt;code&gt;m&lt;/code&gt; times &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">에서 &lt;code&gt;n&lt;/code&gt; 개 까지 &lt;code&gt;m&lt;/code&gt; 의 회 &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1ea6e8437394953edbfda643d827e4d4ef3e935" translate="yes" xml:space="preserve">
          <source>From import statement</source>
          <target state="translated">수입 명세서에서</target>
        </trans-unit>
        <trans-unit id="bee0ffc05592a90a71b79296ba74ad204f6a4854" translate="yes" xml:space="preserve">
          <source>From statement</source>
          <target state="translated">성명서</target>
        </trans-unit>
        <trans-unit id="089c0e110f7531cecf41cc21ee48d15578ad6130" translate="yes" xml:space="preserve">
          <source>Full month string, properly capitalized.</source>
          <target state="translated">전체 달 문자열, 제대로 대문자.</target>
        </trans-unit>
        <trans-unit id="1efdfc3c3fae4cb87be2f821dbd15c17e614eb81" translate="yes" xml:space="preserve">
          <source>Full path to the file containing the symbol.</source>
          <target state="translated">기호가 포함 된 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9aa17034b6f9cc3733582b028743a15d4ca9a823" translate="yes" xml:space="preserve">
          <source>Full qualitifed path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="translated">심볼의 전체 경로. &lt;code&gt;proj.nim&lt;/code&gt; 파일에 정의 된 심볼을 쿼리하는 경우 proj.symbolName 형식이 &lt;code&gt;proj.symbolName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25eab966ab009c6f9396a404c34a6efc2aec6a35" translate="yes" xml:space="preserve">
          <source>Full string for the day of the week.</source>
          <target state="translated">요일의 전체 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="56a52eaf688c8eb99e5f2a5f4ed34a39517d41a8" translate="yes" xml:space="preserve">
          <source>Fully supported OS: MacOSX, FreeBSD, OpenBSD, NetBSD, Linux (except for Android).</source>
          <target state="translated">완전히 지원되는 OS : MacOSX, FreeBSD, OpenBSD, NetBSD, Linux (Android 제외).</target>
        </trans-unit>
        <trans-unit id="d14c246c1269ccb4359c67583949d6908348f108" translate="yes" xml:space="preserve">
          <source>Func</source>
          <target state="translated">Func</target>
        </trans-unit>
        <trans-unit id="103b82fef1279c926f44a70b4dcbb7c19d6cba9c" translate="yes" xml:space="preserve">
          <source>Further complications</source>
          <target state="translated">추가 합병증</target>
        </trans-unit>
        <trans-unit id="bab2f0e91a508ebe1da51e92c439b6ffc92bda93" translate="yes" xml:space="preserve">
          <source>Furthermore no backtracking is performed, if parsing fails after a value has already been bound to a matched subexpression this value is not restored to its original value. This rarely causes problems in practice and if it does for you, it's easy enough to bind to a temporary variable first.</source>
          <target state="translated">또한 값이 이미 일치하는 하위 표현식에 바인딩 된 후 구문 분석에 실패하면 역 추적이 수행되지 않습니다.이 값은 원래 값으로 복원되지 않습니다. 이것은 실제로 문제를 일으키는 경우는 거의 없으며, 그렇게한다면 임시 변수에 먼저 바인딩하기가 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="69610179c37adaec5ee39f67c094bcf4f227a4f5" translate="yes" xml:space="preserve">
          <source>Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.</source>
          <target state="translated">또한 모든 제네릭 형식은 제네릭 형식의 인스턴스화와 일치하는 동일한 이름의 형식 클래스를 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="020268db057d0d374d177846575179b989319d62" translate="yes" xml:space="preserve">
          <source>Future directions</source>
          <target state="translated">향후 방향</target>
        </trans-unit>
        <trans-unit id="08cefc2bd0b44f2a8a17df6ae2c7647385a570c9" translate="yes" xml:space="preserve">
          <source>Future directions:</source>
          <target state="translated">향후 방향:</target>
        </trans-unit>
        <trans-unit id="628f36f2b247989f52efae291bc0d00b5bc12f2e" translate="yes" xml:space="preserve">
          <source>Future objects can also store a callback procedure which will be called automatically once the future completes.</source>
          <target state="translated">미래 객체는 또한 미래가 완료되면 자동으로 호출되는 콜백 프로 시저를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52ca92f6deff645322e492b01bf4e7e07479dc7" translate="yes" xml:space="preserve">
          <source>Futures should &lt;strong&gt;never&lt;/strong&gt; be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the &lt;code&gt;asyncCheck&lt;/code&gt; procedure instead of the &lt;code&gt;discard&lt;/code&gt; keyword.</source>
          <target state="translated">선물은 버려서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 오류가있을 수 있기 때문입니다. 미래의 결과에 신경 쓰지 않으면 &lt;code&gt;discard&lt;/code&gt; 키워드 대신 &lt;code&gt;asyncCheck&lt;/code&gt; 프로 시저를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56d159d6d60dadf784672c33c747ac7bbedd187d" translate="yes" xml:space="preserve">
          <source>Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the &lt;code&gt;recv&lt;/code&gt; function will create a request for some data to be read from a socket. The future which the &lt;code&gt;recv&lt;/code&gt; function returns will then complete once the requested amount of data is read &lt;strong&gt;or&lt;/strong&gt; an exception occurs.</source>
          <target state="translated">그러므로 선물은 프로 액터 패턴의 구현으로 생각할 수 있습니다. 이 패턴에서 조치를 요청하고 해당 조치가 완료되면 해당 조치의 결과로 미래가 완료됩니다. 적절한 기능을 호출하여 요청할 수 있습니다. 예를 들어 : &lt;code&gt;recv&lt;/code&gt; 함수를 호출하면 소켓에서 일부 데이터를 읽도록 요청합니다. 요청 된 양의 데이터를 읽으면 &lt;code&gt;recv&lt;/code&gt; 함수가 반환 하는 미래 는 완료됩니다.&lt;strong&gt; 거나&lt;/strong&gt; 예외가 발생 됩니다.</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="24886e2768e1ad172ed42c67c3aefd8db070df8a" translate="yes" xml:space="preserve">
          <source>GC safety</source>
          <target state="translated">GC 안전</target>
        </trans-unit>
        <trans-unit id="eaa3fa39346ddc09dbf2bdba8048d23ac925a06b" translate="yes" xml:space="preserve">
          <source>GCStats</source>
          <target state="translated">GCStats</target>
        </trans-unit>
        <trans-unit id="decdf7b7c7e08bf8d9a5d48840bcdaa2ba169aa4" translate="yes" xml:space="preserve">
          <source>GETs the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; 와서 &lt;code&gt;Response&lt;/code&gt; 객체를 반환</target>
        </trans-unit>
        <trans-unit id="3cdc3ef08c097eb553bfa51683db392e9fd2bf94" translate="yes" xml:space="preserve">
          <source>GETs the body and returns it as a string.</source>
          <target state="translated">본문을 가져 와서 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a252097fa66659331b3cddc9019fcc983caa9d2" translate="yes" xml:space="preserve">
          <source>GUI libraries</source>
          <target state="translated">GUI 라이브러리</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="f6e05ce0d9c731cfa7368a04629cc24b4369f36e" translate="yes" xml:space="preserve">
          <source>General approach: AST replay</source>
          <target state="translated">일반적인 접근 방식 : AST 재생</target>
        </trans-unit>
        <trans-unit id="e8d58703ce9850fb34cef0e5f6a677d9ab6d889a" translate="yes" xml:space="preserve">
          <source>General format. Same as 'g' except switches to 'E' if the number gets to large.</source>
          <target state="translated">일반적인 형식. 숫자가 커지면 'E'로 전환한다는 점을 제외하고 'g'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a78239c87e6d40ce60ad0d42f7de857091c769b8" translate="yes" xml:space="preserve">
          <source>General format. This prints the number as a fixed-point number, unless the number is too large, in which case it switches to 'e' exponent notation.</source>
          <target state="translated">일반적인 형식. 숫자가 너무 크지 않으면 숫자를 고정 소수점 숫자로 인쇄합니다.이 경우 'e'지수 표기법으로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="6ab8b3a8d895f749e9bdf5ce934de1c2d1d0b06b" translate="yes" xml:space="preserve">
          <source>Generalized raw string literals</source>
          <target state="translated">일반화 된 원시 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="64fc3c60ac61d616b71e452185b1f4af623a77b5" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a file. Result is a 32 character</source>
          <target state="translated">파일에 대한 MD5 해시를 생성하십시오. 결과는 32 자입니다</target>
        </trans-unit>
        <trans-unit id="9af7c728cf98e71cf64f9b1972e19c2d127c4a0b" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a string. Result is a 32 character hex string with lowercase characters</source>
          <target state="translated">문자열에 대한 MD5 해시를 생성하십시오. 결과는 소문자로 된 32 자의 16 진 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="98d2101f8c390609a97dc36588eb2c2b928336e4" translate="yes" xml:space="preserve">
          <source>Generated C code directory</source>
          <target state="translated">생성 된 C 코드 디렉토리</target>
        </trans-unit>
        <trans-unit id="289133444536aa23e14085f7d4547c38b4614e68" translate="yes" xml:space="preserve">
          <source>Generates an interpreting event parser &lt;em&gt;proc&lt;/em&gt; according to the specified PEG AST and handler code blocks. The &lt;em&gt;proc&lt;/em&gt; can be called with a string to be parsed and will execute the handler code blocks whenever their associated grammar element is matched. It returns -1 if the string does not match, else the length of the total match. The following example code evaluates an arithmetic expression defined by a simple PEG:</source>
          <target state="translated">지정된 PEG AST 및 핸들러 코드 블록에 따라 해석 이벤트 파서 &lt;em&gt;proc을&lt;/em&gt; 생성합니다 . &lt;em&gt;시저는&lt;/em&gt; 구문 분석 할 수있는 문자열로 호출 할 수 있습니다 및 관련 문법 요소가 일치 될 때마다 핸들러 코드 블록을 실행합니다. 문자열이 일치하지 않으면 -1을 반환하고 그렇지 않으면 총 일치 길이를 반환합니다. 다음 예제 코드는 간단한 PEG로 정의 된 산술 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="d238e05cf8359baddfe7e098b6e336c92a9522a7" translate="yes" xml:space="preserve">
          <source>Generating AST by hand</source>
          <target state="translated">손으로 AST 생성</target>
        </trans-unit>
        <trans-unit id="6d7d9e5c5c51e8cdad797fbcfcf569b8c1cb37c1" translate="yes" xml:space="preserve">
          <source>Generating source code</source>
          <target state="translated">소스 코드 생성</target>
        </trans-unit>
        <trans-unit id="35071138dc35da926de98aaefe96984d4217c446" translate="yes" xml:space="preserve">
          <source>Generation of HTML documents is done via the &lt;code&gt;doc&lt;/code&gt; command. This command takes either a single .nim file, outputting a single .html file with the same base filename, or multiple .nim files, outputting multiple .html files and, optionally, an index file.</source>
          <target state="translated">HTML 문서 생성은 &lt;code&gt;doc&lt;/code&gt; 명령을 통해 수행됩니다 . 이 명령은 기본 파일 이름이 동일한 단일 .html 파일을 출력하는 단일 .nim 파일 또는 다중 .html 파일 및 선택적으로 색인 파일을 출력하는 다중 .nim 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa6d6526a743c04cb138f95e5e874619707d13b3" translate="yes" xml:space="preserve">
          <source>Generation of JSON documents is done via the &lt;code&gt;jsondoc&lt;/code&gt; command. This command takes in a .nim file, and outputs a .json file with the same base filename. Note that this tool is built off of the &lt;code&gt;doc&lt;/code&gt; command (previously &lt;code&gt;doc2&lt;/code&gt;), and contains the same information.</source>
          <target state="translated">JSON 문서 생성은 &lt;code&gt;jsondoc&lt;/code&gt; 명령을 통해 수행됩니다 . 이 명령은 .nim 파일을 받아서 동일한 기본 파일 이름을 가진 .json 파일을 출력합니다. 이 도구는 &lt;code&gt;doc&lt;/code&gt; 명령 (이전의 &lt;code&gt;doc2&lt;/code&gt; )을 기반으로하며 동일한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="33a377ee820e09df0403fe82c53c3c8f2ee70f4b" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;importcpp&lt;/code&gt;'ed objects are mapped to C++ templates. This means that you can import C++'s templates rather easily without the need for a pattern language for object types:</source>
          <target state="translated">일반적인 &lt;code&gt;importcpp&lt;/code&gt; 객체는 C ++ 템플릿에 매핑됩니다. 즉, 객체 유형에 패턴 언어가 없어도 C ++의 템플릿을 쉽게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0fbaa97fbe2d5968844c44481eeeeaa9d8cf4d" translate="yes" xml:space="preserve">
          <source>Generic Operating System Services</source>
          <target state="translated">일반 운영 체제 서비스</target>
        </trans-unit>
        <trans-unit id="464fc06b76ab248412509ecef43c71e506b6ded7" translate="yes" xml:space="preserve">
          <source>Generic character types</source>
          <target state="translated">일반 문자 유형</target>
        </trans-unit>
        <trans-unit id="678e67a971cceb4e4204476fbf467e12791b8c3c" translate="yes" xml:space="preserve">
          <source>Generic compare proc. Returns a value &amp;lt; 0 iff x &amp;lt; y, a value &amp;gt; 0 iff x &amp;gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;em&gt;==&lt;/em&gt; and &lt;em&gt;&amp;lt;&lt;/em&gt; operators.</source>
          <target state="translated">일반 비교 절차 값 &amp;lt;0 iff x &amp;lt;y, 값&amp;gt; 0 iff x&amp;gt; y 및 0 iff x == y를 반환합니다. 이것은 성능 손실없이 일반 알고리즘을 작성하는 데 유용합니다. 이 일반적인 구현은 &lt;em&gt;==&lt;/em&gt; 및 &lt;em&gt;&amp;lt;&lt;/em&gt; 연산자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6aac3374886170bb41e18aa9ef46d585b4c0cf3d" translate="yes" xml:space="preserve">
          <source>Generic concepts and type binding rules</source>
          <target state="translated">일반적인 개념과 유형 바인딩 규칙</target>
        </trans-unit>
        <trans-unit id="5758f3b8d7db49429e2450605302abae607b2d2e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JArray JsonNode&lt;/em&gt;</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JArray JsonNode를 작성합니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56196b58c5a518827914bf2b7e0d971615bef4ef" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JBool JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JBool JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c522119659c3ad469d660cbc777be1566eab03ca" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JFloat JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JFloat JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="428d41d73169fa86a546999a3ecbb89be1dc15dd" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JInt JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JInt JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b6b9a542f51bfb8d8a58c48f28ef2d46b8502cfe" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JObject JsonNode&lt;/em&gt;</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JObject JsonNode를&lt;/em&gt; 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2877938000b60f256eb2208f3e2064ca182d0d1e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JString JsonNode&lt;/em&gt;.</source>
          <target state="translated">JSON 데이터의 일반 생성자 새로운 &lt;em&gt;JString JsonNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7a8148d60cedc7cdb10800bc50e60d1a318f6ded" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SFloat SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP 데이터의 일반 생성자. 새로운 &lt;em&gt;SFloat SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="368e470b1e2f2321d77f4df18391df0ebee5b99f" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SInt SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP 데이터의 일반 생성자. 새로운 &lt;em&gt;SInt SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ce95a5ca77c5c22b17a766116d3147d2635c453e" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SList SexpNode&lt;/em&gt;</source>
          <target state="translated">SEXP 데이터의 일반 생성자. 새로운 &lt;em&gt;SList SexpNode를&lt;/em&gt; 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70060a28a86cfcd2dc2f2ba89648bd6996b8b345" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SString SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP 데이터의 일반 생성자. 새로운 &lt;em&gt;SString SexpNode를 작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ea5770ee43cc8a593a59a930e346d52787e2ce7c" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SSymbol SexpNode&lt;/em&gt; with value t or &lt;em&gt;SNil SexpNode&lt;/em&gt;.</source>
          <target state="translated">SEXP 데이터의 일반 생성자. 값이 t 또는 &lt;em&gt;SNil SexpNode 인&lt;/em&gt; 새 &lt;em&gt;SSymbol SexpNode&lt;/em&gt; 를 &lt;em&gt;작성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="64fb5138e59ddec98dd809de58b7d3ddb3a5428f" translate="yes" xml:space="preserve">
          <source>Generic equals operator for sequences: relies on a equals operator for the element type &lt;em&gt;T&lt;/em&gt;.</source>
          <target state="translated">시퀀스의 일반 등가 연산자 : 요소 유형 &lt;em&gt;T&lt;/em&gt; 의 등가 연산자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="54e8bb6d675a2725d1d4b86c632445dea3d31b1b" translate="yes" xml:space="preserve">
          <source>Generic inference restrictions</source>
          <target state="translated">일반적인 추론 제한</target>
        </trans-unit>
        <trans-unit id="2b4ec6bb77472d676b0b71755309ad80e343f837" translate="yes" xml:space="preserve">
          <source>Generic match: &lt;code&gt;f&lt;/code&gt; is a generic type and &lt;code&gt;a&lt;/code&gt; matches, for instance &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a generic (constrained) parameter type (like in &lt;code&gt;[T]&lt;/code&gt; or &lt;code&gt;[T: int|char]&lt;/code&gt;.</source>
          <target state="translated">일반 경기 : &lt;code&gt;f&lt;/code&gt; 제네릭 형식이며 예를 들어, 일치 &lt;code&gt;a&lt;/code&gt; 는 이다 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; 처럼 (일반 (제한) 매개 변수 유형입니다 &lt;code&gt;[T]&lt;/code&gt; 또는 &lt;code&gt;[T: int|char]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e2cd7649b731671a13f778e5ca52832337336a2" translate="yes" xml:space="preserve">
          <source>Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. Note &lt;em&gt;uint&lt;/em&gt; and &lt;em&gt;uint64&lt;/em&gt; are not ordinal types for implementation reasons</source>
          <target state="translated">일반 서수 타입. 정수, 부울, 문자 및 열거 유형과 하위 유형을 포함합니다. 참고 &lt;em&gt;uint&lt;/em&gt; 및 &lt;em&gt;uint64&lt;/em&gt; 는 구현상의 이유로 서수 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="59d85eb1d2101a47518908a9543ab04dd38c3be8" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a data item &lt;em&gt;y&lt;/em&gt; to a container &lt;em&gt;x&lt;/em&gt;. For containers that have an order, &lt;em&gt;add&lt;/em&gt; means &lt;em&gt;append&lt;/em&gt;. New generic containers should also call their adding proc &lt;em&gt;add&lt;/em&gt; for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.</source>
          <target state="translated">컨테이너 &lt;em&gt;x에&lt;/em&gt; 데이터 항목 &lt;em&gt;y&lt;/em&gt; 를 추가하기위한 일반 프로세스입니다 . 주문이있는 컨테이너의 경우 &lt;em&gt;add&lt;/em&gt; 는 &lt;em&gt;append를&lt;/em&gt; 의미 합니다. 새로운 일반 컨테이너는 일관성을 위해 추가 proc &lt;em&gt;add&lt;/em&gt; 를 호출해야합니다 . Nim 이름 지정 체계를 준수하면 일반 코드 작성이 훨씬 쉬워집니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dbccc6a656c4c0fcf5215bff94a25f9c34e2bcf1" translate="yes" xml:space="preserve">
          <source>Generic type to construct a varargs type.</source>
          <target state="translated">varargs 형식을 구성하는 제네릭 형식입니다.</target>
        </trans-unit>
        <trans-unit id="d4c17034fe5c9e8772b30101d8cc632e4a17baf3" translate="yes" xml:space="preserve">
          <source>Generic type to construct bit sets.</source>
          <target state="translated">비트 세트를 구성하는 제네릭 형식입니다.</target>
        </trans-unit>
        <trans-unit id="082c9d1651fdd2acdb7f2c31b3f3648b7afec885" translate="yes" xml:space="preserve">
          <source>Generic type to construct fixed-length arrays.</source>
          <target state="translated">고정 길이 배열을 구성하는 제네릭 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ce68ddc8e58b7a3242f91b2251724e6a4a8e1dda" translate="yes" xml:space="preserve">
          <source>Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field.</source>
          <target state="translated">개방형 배열을 구성하는 제네릭 형식입니다. 개방형 배열은 배열 데이터와 길이 필드에 대한 포인터로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a145c1c6d93be237b998460577b653c1465acceb" translate="yes" xml:space="preserve">
          <source>Generic type to construct range types.</source>
          <target state="translated">범위 유형을 구성하는 일반 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a5a528710df29c84abff0cbb0679efaae048d50e" translate="yes" xml:space="preserve">
          <source>Generic type to construct sequences.</source>
          <target state="translated">시퀀스를 생성하는 제네릭 형식입니다.</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="3b461060a51b8a72f2a4cb78364c85efb904c7a8" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.</source>
          <target state="translated">제네릭은 프로세스, 반복자 또는 유형 &lt;span id=&quot;type-parameters_1&quot;&gt;매개 변수를 사용&lt;/span&gt; 하여 &lt;span id=&quot;type-parameters_1&quot;&gt;유형을 매개&lt;/span&gt; 변수화하는 Nim의 수단 입니다. 컨텍스트에 따라 대괄호는 형식 매개 변수를 도입하거나 일반 proc, iterator 또는 형식을 인스턴스화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba8db3e0e66211eabb3c4f25fee0a1d1829b963a" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. They are most useful for efficient type safe containers:</source>
          <target state="translated">제네릭은 프로세스, 반복자 또는 유형 &lt;span id=&quot;type-parameters_1&quot;&gt;매개 변수를 사용&lt;/span&gt; 하여 &lt;span id=&quot;type-parameters_1&quot;&gt;유형을 매개&lt;/span&gt; 변수화하는 Nim의 수단 입니다. 효율적인 유형의 안전한 컨테이너에 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d40e8a56834c6a89deae8c24980dea5a106cc1dc" translate="yes" xml:space="preserve">
          <source>Get PSK identity.</source>
          <target state="translated">PSK 정체성을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="07a2ad39e6ce26d304194dfe8051981d34f5f859" translate="yes" xml:space="preserve">
          <source>Get current implementation of &lt;code&gt;callSoon&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;callSoon&lt;/code&gt; 의 현재 구현을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5454dcbb9ac5865ed0ee9c43e8d6c25d91b7171b" translate="yes" xml:space="preserve">
          <source>Get current rounding direction.</source>
          <target state="translated">현재 반올림 방향을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="12714742014fb6228a1c3f36ea543012ada95c75" translate="yes" xml:space="preserve">
          <source>Get string representation of &lt;em&gt;TimeInterval&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TimeInterval의&lt;/em&gt; 문자열 표현을 가져 &lt;em&gt;옵니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad54c08fe8749a0e81ff7837b23c3157c0895d10" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the UTC timezone.</source>
          <target state="translated">UTC 시간대 의 &lt;code&gt;Timezone&lt;/code&gt; 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="130ee2f075e62422a363a8a189c3d9f93794fbf2" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the local timezone.</source>
          <target state="translated">현지 시간대 의 &lt;code&gt;Timezone&lt;/code&gt; 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b5c7e7bb6bfadc9b10aaa987304f7abf1345c0db" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;code&gt;DateTime&lt;/code&gt; in the local timezone.</source>
          <target state="translated">현지 시간대에서 현재 시간을 &lt;code&gt;DateTime&lt;/code&gt; 으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="11562b1334027fecd5dcb805739b82f536f9c783" translate="yes" xml:space="preserve">
          <source>Get the fractional part of a &lt;code&gt;Time&lt;/code&gt; as the number of nanoseconds of the second.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 의 소수 부분을 초의 나노초 수로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="28122ec43897f8843b8ea9fdf99ecd6c1be76468" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration of negative direction.</source>
          <target state="translated">음의 방향을 나타내는 가장 긴 지속 시간을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7bdc6c0918cf5d26da44cabeb23abccc70e09b4e" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration.</source>
          <target state="translated">표현 가능한 가장 긴 기간을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="bf89b2420cafea5152352e14cc484f7a750ccd87" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;month&lt;/code&gt; of a &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">의 일 수를 가져옵니다 &lt;code&gt;month&lt;/code&gt; (A)의 &lt;code&gt;year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a91e315a40bea130b02d973a8401879d06157a88" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;year&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;year&lt;/code&gt; 의 일수를 구하십시오</target>
        </trans-unit>
        <trans-unit id="4f8e6af49ebd57b98c32b3bef36972e51d6956de" translate="yes" xml:space="preserve">
          <source>Get the pragma of a proc type These will be expanded</source>
          <target state="translated">proc 유형의 pragma를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="c2fb3d2f912aad36a7a2fab3df616b85598528a1" translate="yes" xml:space="preserve">
          <source>Get the socket's local address and port number.</source>
          <target state="translated">소켓의 로컬 주소와 포트 번호를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ed61d3d7776639eccbb79106f8cddd298594c0ca" translate="yes" xml:space="preserve">
          <source>Get the socket's peer address and port number.</source>
          <target state="translated">소켓의 피어 주소와 포트 번호를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="723d6575987f98cca4d17c0950fa5dba4078249b" translate="yes" xml:space="preserve">
          <source>Get the string of an identifier node</source>
          <target state="translated">식별자 노드의 문자열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="c99521d6ef98a806e912444f989eca6e635eefe5" translate="yes" xml:space="preserve">
          <source>Get the string representation of this option. If the option has a value, the result will be &lt;em&gt;Some(x)&lt;/em&gt; where &lt;em&gt;x&lt;/em&gt; is the string representation of the contained value. If the option does not have a value, the result will be &lt;em&gt;None[T]&lt;/em&gt; where &lt;em&gt;T&lt;/em&gt; is the name of the type contained in the option.</source>
          <target state="translated">이 옵션의 캐릭터 라인 표현을 가져옵니다. 옵션에 값이 있으면 결과는 &lt;em&gt;Some (x)입니다.&lt;/em&gt; 여기서 &lt;em&gt;x&lt;/em&gt; 는 포함 된 값의 문자열 표현입니다. 옵션에 값이 없으면 결과는 &lt;em&gt;None [T]가됩니다.&lt;/em&gt; 여기서 &lt;em&gt;T&lt;/em&gt; 는 옵션에 포함 된 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e6e81c9ca7b9838c7aad39a88a6bc88879fb7071" translate="yes" xml:space="preserve">
          <source>Gets &lt;em&gt;n&lt;/em&gt;'s tag as a &lt;code&gt;HtmlTag&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 의 태그를 &lt;code&gt;HtmlTag&lt;/code&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="13689de7004dbf96d752346d793d33acafe479cd" translate="yes" xml:space="preserve">
          <source>Gets a cookie. If no cookie of &lt;em&gt;name&lt;/em&gt; exists, &quot;&quot; is returned.</source>
          <target state="translated">쿠키를 가져옵니다. &lt;em&gt;이름의&lt;/em&gt; 쿠키가 없으면 &quot;&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ee6b6486187c570cea3bd16707c23edffa1180" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;JObject&lt;/em&gt;, which must not be nil. If the value at &lt;em&gt;name&lt;/em&gt; does not exist, raises KeyError.</source>
          <target state="translated">&lt;em&gt;JObject&lt;/em&gt; 에서 필드를 가져 &lt;em&gt;옵니다&lt;/em&gt; .이 값은 nil이 아니어야합니다. &lt;em&gt;이름에&lt;/em&gt; 값 이 없으면 KeyError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f35abda3cff44672e27443c29310a4342a3a7c85" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;node&lt;/em&gt;. If &lt;em&gt;node&lt;/em&gt; is nil or not an object or value at &lt;em&gt;key&lt;/em&gt; does not exist, returns nil</source>
          <target state="translated">&lt;em&gt;노드&lt;/em&gt; 에서 필드를 가져 &lt;em&gt;옵니다&lt;/em&gt; . 경우 &lt;em&gt;노드가&lt;/em&gt; 존재하지 않거나없는에서 객체 또는 값 &lt;em&gt;키&lt;/em&gt; , 반환 전무 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d9e896ea8856279a92c23ca43823ce2065dfa17c" translate="yes" xml:space="preserve">
          <source>Gets extension which corresponds to &lt;code&gt;mimetype&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;mimetype&lt;/code&gt; could not be found. Extensions are returned without the leading dot.</source>
          <target state="translated">&lt;code&gt;mimetype&lt;/code&gt; 에 해당하는 확장을 가져 옵니다 . &lt;code&gt;mimetype&lt;/code&gt; 을 찾을 수없는 경우 &lt;code&gt;default&lt;/code&gt; 반환합니다 . 확장은 선행 점없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d08dcb1eea4061ffa3605412e9746813dfd3d3a3" translate="yes" xml:space="preserve">
          <source>Gets mimetype which corresponds to &lt;code&gt;ext&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;ext&lt;/code&gt; could not be found. &lt;code&gt;ext&lt;/code&gt; can start with an optional dot which is ignored.</source>
          <target state="translated">&lt;code&gt;ext&lt;/code&gt; 에 해당하는 mimetype을 가져옵니다 . &lt;code&gt;ext&lt;/code&gt; 를 찾을 수없는 경우 &lt;code&gt;default&lt;/code&gt; 리턴합니다 . &lt;code&gt;ext&lt;/code&gt; 는 무시되는 선택적 점으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1714560401ef5d53bb12109cf2cb88182bbf5caa" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;NonTerminalFlag&lt;/em&gt;-typed flags field of the parent &lt;em&gt;Peg&lt;/em&gt; variant object of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;NonTerminal&lt;/em&gt; 의 부모 &lt;em&gt;Peg&lt;/em&gt; 변형 객체의 &lt;em&gt;NonTerminalFlag&lt;/em&gt; 유형의 플래그 필드를 가져 &lt;em&gt;옵니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92e639fc7e6c6f3a36a4b433e2efd44d76d332e9" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;Peg&lt;/em&gt; object representing the rule definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;NonTerminal&lt;/em&gt; 의 부모 &lt;em&gt;Peg&lt;/em&gt; 객체 변형의 규칙 정의를 나타내는 &lt;em&gt;Peg&lt;/em&gt; 객체를 가져 &lt;em&gt;옵니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2a31ab6e34d28da2594120eec11f6a9e165ade3" translate="yes" xml:space="preserve">
          <source>Gets the Key value of the specified Section.</source>
          <target state="translated">지정된 Section의 Key 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="db4276492a87292b45a2d798b8604d66f0972994" translate="yes" xml:space="preserve">
          <source>Gets the PSK identity provided by the client.</source>
          <target state="translated">클라이언트가 제공 한 PSK ID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="654f49772dc846fc7e8b0b5fafe8aba913ce8713" translate="yes" xml:space="preserve">
          <source>Gets the column number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;NonTerminal&lt;/em&gt; 의 부모 &lt;em&gt;Peg&lt;/em&gt; 객체 변형 정의의 열 번호를 가져 &lt;em&gt;옵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd81d39ed2660b2a192796678428676c0ea999cd" translate="yes" xml:space="preserve">
          <source>Gets the current clock time as a string of the format &lt;code&gt;HH:MM:SS&lt;/code&gt;.</source>
          <target state="translated">현재 시계 시간을 &lt;code&gt;HH:MM:SS&lt;/code&gt; 형식의 문자열로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3261759c69cac472d4a177821c0ced7e8297f225" translate="yes" xml:space="preserve">
          <source>Gets the current date as a string of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="translated">현재 날짜를 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 형식의 문자열로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="247d662645bc1637ead4656674f1a702738e8829" translate="yes" xml:space="preserve">
          <source>Gets the current time as a &lt;code&gt;Time&lt;/code&gt; with nanosecond resolution.</source>
          <target state="translated">현재 &lt;code&gt;Time&lt;/code&gt; 을 나노초 해상도의 시간으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1c769de6a12c15bcc2c5b444e497708dc0f8ed81" translate="yes" xml:space="preserve">
          <source>Gets the global log filter.</source>
          <target state="translated">글로벌 로그 필터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e9d0ac9e5207f2824570ddf9a5876cb435b1720a" translate="yes" xml:space="preserve">
          <source>Gets the line number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;NonTerminal&lt;/em&gt; 의 부모 &lt;em&gt;Peg&lt;/em&gt; 객체 변형의 정의의 행 번호를 가져 &lt;em&gt;옵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56bd530836a48d9d37ff0198c3155398e3eb5899" translate="yes" xml:space="preserve">
          <source>Gets the name of the symbol represented by the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">지정된 &lt;em&gt;NonTerminal&lt;/em&gt; 의 부모 &lt;em&gt;Peg&lt;/em&gt; 객체 변형이 나타내는 기호의 이름을 가져 &lt;em&gt;옵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="60fbf54936c22fd972d85ed8d34160d9e21cbc39" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in a List. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds</source>
          <target state="translated">List의 &lt;em&gt;인덱스&lt;/em&gt; 에있는 노드를 가져옵니다 . &lt;em&gt;인덱스&lt;/em&gt; 가 범위를 벗어난 경우 결과가 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="f194ace764156524b46a54cf14a3d07dfbe7aad4" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in an Array. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds, but as long as array bound checks are enabled it will result in an exception.</source>
          <target state="translated">배열의 &lt;em&gt;인덱스&lt;/em&gt; 에있는 노드를 가져옵니다 . &lt;em&gt;인덱스&lt;/em&gt; 가 범위를 벗어난 경우 결과는 정의되지 않지만 배열 바운드 검사가 활성화되어 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="329aa8af8f1565e4ae1eb4a65d49566bcb3acd69" translate="yes" xml:space="preserve">
          <source>Getting a blocking client from an AsyncSocket</source>
          <target state="translated">AsyncSocket에서 차단 클라이언트 가져 오기</target>
        </trans-unit>
        <trans-unit id="3ef086870f2969d8fb668096b14518cd761c2738" translate="yes" xml:space="preserve">
          <source>GlobalVar</source>
          <target state="translated">GlobalVar</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="4ff36b989c4ec5364741f73abb04f8673b791c08" translate="yes" xml:space="preserve">
          <source>Grouping: Parenthesis can be used to change operator priority.</source>
          <target state="translated">그룹화 : 괄호를 사용하여 운영자 우선 순위를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db8f40454de4a3c5f9326c0b5a2982f87e8e8255" translate="yes" xml:space="preserve">
          <source>Guards and locks</source>
          <target state="translated">가드 및 잠금</target>
        </trans-unit>
        <trans-unit id="2bd9bcf38059609e0eeeb386a0d770db57a4886d" translate="yes" xml:space="preserve">
          <source>Guards and the locks section</source>
          <target state="translated">가드 및 잠금 섹션</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="b670aa89386f34895332e01e04f3dc802e9f3d5c" translate="yes" xml:space="preserve">
          <source>HTML anchor generation</source>
          <target state="translated">HTML 앵커 생성</target>
        </trans-unit>
        <trans-unit id="a2ef27ac824bc904fefaa0d0d28b7f8253599ae9" translate="yes" xml:space="preserve">
          <source>HTML tags are case insensitive, XML tags are case sensitive. Since this library can parse both, only the client knows which comparison is to be used.</source>
          <target state="translated">HTML 태그는 대소 문자를 구분하지 않으며 XML 태그는 대소 문자를 구분합니다. 이 라이브러리는 둘 다 구문 분석 할 수 있으므로 클라이언트 만 사용할 비교를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="194f68d829d02bf8087b17ed3a49b755b9584b08" translate="yes" xml:space="preserve">
          <source>Handling Exceptions</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="260da45171e90fa3c6347df36e669fab555188ca" translate="yes" xml:space="preserve">
          <source>Hash sets are different from the &lt;a href=&quot;manual#types-set-type&quot;&gt;built in set type&lt;/a&gt;. Sets allow you to store any value that can be &lt;a href=&quot;hashes&quot;&gt;hashed&lt;/a&gt; and they don't contain duplicate entries.</source>
          <target state="translated">해시 세트는 &lt;a href=&quot;manual#types-set-type&quot;&gt;내장 세트 유형&lt;/a&gt; 과 다릅니다 . 세트를 사용하면 &lt;a href=&quot;hashes&quot;&gt;해시&lt;/a&gt; 할 수 있고 중복 항목이 포함되지 않은 값을 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="379820ada71e6fc460419ac92a81ed0859a3ea71" translate="yes" xml:space="preserve">
          <source>Have test results printed in color. Default is true for the non-js target, for which &lt;code&gt;stdout&lt;/code&gt; is a tty. Setting the environment variable &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; changes the default for the non-js target to true or false respectively. The deprecated environment variable &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt;, when set, changes the defualt to true, if &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; is undefined.</source>
          <target state="translated">테스트 결과를 컬러로 인쇄하십시오. &lt;code&gt;stdout&lt;/code&gt; 이 tty 인 비 js 대상의 기본값은 true입니다 . 환경 변수 &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; 를 &lt;code&gt;always&lt;/code&gt; 또는 &lt;code&gt;never&lt;/code&gt; 설정하면 js가 아닌 대상의 기본값이 각각 true 또는 false로 변경됩니다. 더 이상 사용되지 않는 환경 변수 &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt; 은 설정된 경우 &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; 이 정의되지 않은 경우 defualt를 true로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="23843a4a411f31b588dbb2d3c2973e3567ff072f" translate="yes" xml:space="preserve">
          <source>Header pragma</source>
          <target state="translated">헤더 프라 그마</target>
        </trans-unit>
        <trans-unit id="73a2a0df8c0716bca2e8f0a3245d12dcc9011dbf" translate="yes" xml:space="preserve">
          <source>Heap dump</source>
          <target state="translated">힙 덤프</target>
        </trans-unit>
        <trans-unit id="cd81a03d092d8f4c8cc38f239229d0a6b095622c" translate="yes" xml:space="preserve">
          <source>Heap queue algorithm (a.k.a. priority queue). Ported from Python heapq.</source>
          <target state="translated">힙 큐 알고리즘 (일명 우선 순위 큐) Python heapq에서 이식되었습니다.</target>
        </trans-unit>
        <trans-unit id="8131611ca642b3a3b9f02be683c0bd269e027af5" translate="yes" xml:space="preserve">
          <source>Heaps are arrays for which a[k] &amp;lt;= a[2*k+1] and a[k] &amp;lt;= a[2*k+2] for all k, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that a[0] is always its smallest element.</source>
          <target state="translated">힙은 모든 k에 대해 a [k] &amp;lt;= a [2 * k + 1] 및 a [k] &amp;lt;= a [2 * k + 2]이며 0부터 요소를 계산하는 배열입니다. 비교를 위해 non 기존 요소는 무한한 것으로 간주됩니다. 힙의 흥미로운 특성은 a [0]이 항상 가장 작은 요소라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fe815bc3011561cb8a3933b51b18ec4e9c969d5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;odd&lt;/code&gt; depends on &lt;code&gt;even&lt;/code&gt; and vice versa. Thus &lt;code&gt;even&lt;/code&gt; needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the &lt;code&gt;=&lt;/code&gt; and the procedure's body. The &lt;code&gt;assert&lt;/code&gt; just adds border conditions, and will be covered later in &lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; section.</source>
          <target state="translated">다음은 &lt;code&gt;odd&lt;/code&gt; 에 따라 &lt;code&gt;even&lt;/code&gt; 하고 그 반대의 경우도 마찬가지입니다. 따라서 &lt;code&gt;even&lt;/code&gt; 가 완전히 정의되기 전에 컴파일러에 도입 될 필요가있다. 이러한 전달 선언의 구문은 간단합니다. &lt;code&gt;=&lt;/code&gt; 와 프로 시저 본문을 생략하면 됩니다. &lt;code&gt;assert&lt;/code&gt; 단지 경계 조건을 추가하고, 나중에 다룰 것이다 &lt;a href=&quot;#modules&quot;&gt;모듈&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b85b0f3abb03a93662419b1e5d9c37d24bb18a1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;var T from container&lt;/code&gt; explicitly exposes that the location is deviated from the second parameter (called 'container' in this case). The syntax &lt;code&gt;var T from p&lt;/code&gt; specifies a type &lt;code&gt;varTy[T, 2]&lt;/code&gt; which is incompatible with &lt;code&gt;varTy[T, 1]&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;var T from container&lt;/code&gt; 는 위치가 두 번째 매개 변수 (이 경우 '컨테이너'라고 함)에서 벗어났다는 것을 명시 적으로 노출합니다. 문법 &lt;code&gt;var T from p&lt;/code&gt; &lt;code&gt;varTy[T, 1]&lt;/code&gt; 과 호환되지 않는 &lt;code&gt;varTy[T, 2]&lt;/code&gt; 유형을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="474408b78552b4a0d7ae5fdabc19bf252fc0eb8c" translate="yes" xml:space="preserve">
          <source>Here are some examples for Unix:</source>
          <target state="translated">유닉스에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4b5a5ccfafdc873c836f01f1f7137f9ef720f3e" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use the configuration file parser:</source>
          <target state="translated">구성 파일 구문 분석기를 사용하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a23c6c65d4dacf92bd4b7dd12966aa26aed4b8f6" translate="yes" xml:space="preserve">
          <source>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of the same lock level:</source>
          <target state="translated">Nim에서 일반적인 멀티 락문을 구현하는 방법은 다음과 같습니다. 두 개의 잠금 장치에 대한 전역 주문을 보장하기 위해 런타임 검사가 어떻게 필요한지 확인하십시오 &lt;code&gt;a&lt;/code&gt; 동일한 잠금 레벨의 및 &lt;code&gt;b&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="a8056266ad685c758cc11b7e966ef3226e799b6f" translate="yes" xml:space="preserve">
          <source>Here is some example usage of this module:</source>
          <target state="translated">이 모듈의 사용법 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d75a6bc3a26bf7e15a375f54de00e7b3a24d49e" translate="yes" xml:space="preserve">
          <source>Heterogeneous arrays are not supported.</source>
          <target state="translated">이기종 어레이는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a472603c4793ba32a26895360ca1c167352b47b" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.</source>
          <target state="translated">16 진수 형식. 9보다 큰 숫자에 소문자를 사용하여 16 진수로 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="16ecf8c049c3a3fc4daf4d45c04ec54049be9338" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using uppercase letters for the digits above 9.</source>
          <target state="translated">16 진수 형식. 9보다 큰 자릿수에 대문자를 사용하여 16 진수로 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c64b0888277a234e68d21751554b1e7fd37d63e3" translate="yes" xml:space="preserve">
          <source>Hides the cursor.</source>
          <target state="translated">커서를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="201789f2014169f3fb9b5be056554d96ad45efe9" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt; which returns a string.</source>
          <target state="translated">문자열을 반환하는 &lt;code&gt;recv&lt;/code&gt; 의 상위 레벨 버전 .</target>
        </trans-unit>
        <trans-unit id="375f88a238b922b4a8492616aa39100964dc9e28" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 의 상위 레벨 버전 .</target>
        </trans-unit>
        <trans-unit id="e181cef40f6b34c1f59ee5117ab9fb62d1330e72" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be false.</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; 최적화기를 힌트&lt;em&gt;&lt;/em&gt; 이 false 일 가능성이 .</target>
        </trans-unit>
        <trans-unit id="19f673072699a2a1b1f923ef0f54e924acd06dc7" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be true.</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; 최적화기를 힌트&lt;em&gt;&lt;/em&gt; 이 true 일 가능성이 합니다.</target>
        </trans-unit>
        <trans-unit id="8393d3af1bb0b9c3fc06f67e4b0baddd2f8abb94" translate="yes" xml:space="preserve">
          <source>Historically, Nim was a fully &lt;span id=&quot;styleminusinsensitive_1&quot;&gt;style-insensitive&lt;/span&gt; language. This meant that it was not case-sensitive and underscores were ignored and there was not even a distinction between &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">역사적으로 Nim은 완전히 &lt;span id=&quot;styleminusinsensitive_1&quot;&gt;스타일에 구애받지 않는&lt;/span&gt; 언어였습니다. 이것은 대소 문자를 구분하지 않았으며 밑줄은 무시되었으며 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;Foo&lt;/code&gt; 의 구분조차 없었습니다. .</target>
        </trans-unit>
        <trans-unit id="ebb7c24bb94fb8d304cae1d3ff1be0dcb43bbb49" translate="yes" xml:space="preserve">
          <source>Hot code reloading</source>
          <target state="translated">핫 코드 리로딩</target>
        </trans-unit>
        <trans-unit id="a6ec9f4760713f74026109bf0ded7ccc69847229" translate="yes" xml:space="preserve">
          <source>How the RTL is compiled</source>
          <target state="translated">RTL 컴파일 방법</target>
        </trans-unit>
        <trans-unit id="edc42b66f73d1503ac061b4ce145b9a1dd7e0b1b" translate="yes" xml:space="preserve">
          <source>How to deal with an absence of a value:</source>
          <target state="translated">가치의 부재를 다루는 방법 :</target>
        </trans-unit>
        <trans-unit id="7980a8ae26b43f84582fc4763e99898544da0dad" translate="yes" xml:space="preserve">
          <source>However before the PATH is used the current directory is checked for the file's existence. So if PATH contains &lt;code&gt;$lib&lt;/code&gt; and &lt;code&gt;$lib/bar&lt;/code&gt; and the directory structure looks like this:</source>
          <target state="translated">그러나 PATH를 사용하기 전에 현재 디렉토리에서 파일이 있는지 확인합니다. PATH에 &lt;code&gt;$lib&lt;/code&gt; 와 &lt;code&gt;$lib/bar&lt;/code&gt; 가 있다면 있고 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
