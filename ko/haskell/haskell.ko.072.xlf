<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 가능 값의 유형 클래스입니다 . &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 의 방법은 값 필드 포맷 디스크립터를 받아 하나 실패로 인해 잘못된 설명하거나 생성 &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 결과한다. 기본 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 은 수정자를 기대하지 않습니다. 일반적인 경우입니다. 최소 예 : &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">유형이 지정된 표현식 스플 라이스 : 유형이 지정되지 않은 표현식 스플 라이스와 동일한 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">유형이 지정된 표현식</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">유형이 지정된 구멍은 GHC의 기능으로, 밑줄 (예 : &quot; &lt;code&gt;_&lt;/code&gt; &quot;, &quot; &lt;code&gt;_foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;_bar&lt;/code&gt; &quot;)로 작성된 특수 자리 표시자를 표현식으로 사용할 수 있습니다. 컴파일하는 동안 이러한 구멍은 구멍 위치에 어떤 유형이 예상되는지, 자유 유형 변수의 원점에 대한 정보 및 구멍을 채우는 데 도움이되는 로컬 바인딩 목록 및 유형에 맞는 범위의 바인딩을 설명하는 오류 메시지를 생성합니다. 실제 코드로 구멍을 채우는 데 도움이 될 수 있습니다. 타입 홀은 GHC에서 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTC 및 UT1의 유형 및 함수</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">유니 코드 텍스트의 인코딩 및 디코딩 오류를 처리하기위한 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">리모트 GHCi에서 리모트 오브젝트를 참조하기위한 유형. 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [외부 GHCi 포인터]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">텍스트 인코딩 / 디코딩 실패 방법을 지정하는 유형</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I / O 오류 유형</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">유형과 클래스 제약 조건은 접두사로 쓸 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">일반적으로 GHCi는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후에로드 한 모듈 수만 표시합니다 . 이 플래그를 사용하면 GHC는로드 된 모듈의 이름도 나열합니다. 이것은 GHC 8.2.1 이전의 기본 동작이며 일부 툴링 사용자에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">일반적으로이 &lt;code&gt;GSerialize&lt;/code&gt; 클래스는 표시 유형에 대한 인스턴스 만 갖는 것이 적합하므로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 자체를 입력 하면 현재 정의 된 매크로가 나열됩니다. &lt;code&gt;:def!&lt;/code&gt; 가 아니면 기존 명령 이름을 재정의하려고하면 오류가 발생합니다 . form이 사용되며,이 경우 해당 이름의 이전 명령을 자동으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">입력 : ⟨exp⟩ 유형이 ⟨T1⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩이고 ⟨pat⟩가 ⟨T2⟩와 일치하면 전체보기 패턴이 ⟨T1⟩과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">유닉스 스타일 포맷</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">유닉스 스타일 파싱</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE 환경 변수.</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTC는 시계로 측정 한 시간으로 &quot;도약 초&quot;라고하는 가끔씩 초를 추가하거나 제거하여 지구와 보조를 맞추도록 수정되었습니다. 이러한 수정 사항은 예측할 수 없으며 6 개월 전에 통지합니다. 이 수정 사항에 대한 표는 제공되지 않습니다.이 프로그램으로 컴파일 된 프로그램은 6 개월 후에 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16 (Windows 시스템에서 사용).</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-16 코덱</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 서로 게이트 코드 포인트는 유니 코드 스칼라 값 세트에 포함되지 않지만 불행히도 Haskell에 의해 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정됩니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, '')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32 (C 컴파일러는 &lt;code&gt;201605L&lt;/code&gt; 을 정의 함 ) 또는</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-32 코덱</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-8 코덱</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">단항 부정. 음의 &lt;code&gt;Int#&lt;/code&gt; 범위는 양의 범위보다 하나 더 확장 되므로 가장 음수 인 &lt;code&gt;negateInt#&lt;/code&gt; 는 항등 연산입니다. 이런 식으로 &lt;code&gt;negateInt#&lt;/code&gt; 는 항상 자체 역수입니다.</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">식에 사용 된 언 바운드 데이터 생성자는 위와 동일하게 동작합니다. 그러나 &lt;em&gt;패턴에&lt;/em&gt; 사용 된 바인딩되지 않은 데이터 생성자 는 지연 될 수 없으며 대신 컴파일을 중단합니다. (구현 용어로, 그것들은 타입 체커가 아닌 리 네이터에 의해보고됩니다.)</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">이름이 같은 언 바운드 식별자는 동일한 기능 내에서도 통합되지 않지만 개별적으로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">무제한 채널.</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">박스형 배열</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">박스형 불변 배열.</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">박스형 표현 유형</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">박스형 합계 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">박스형 합계 유형 생성자</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">Unboxed sum은 힙에 sum을 할당하고 포인터로 값을 나타내는 대신 unboxed tuple과 같이 구성 요소로 표현된다는 의미에서&amp;ldquo;unboxed&amp;rdquo;입니다. 이러한&amp;ldquo;구성 요소&amp;rdquo;는 합계 유형의 대안에 따라 다릅니다. 박스형 튜플과 같이 박스형 합계는 리프팅 된 구성 요소에 게으르다.</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">박스형 튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">박스형 튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">박스형 튜플은 여러 값을 반환해야하는 함수에 사용되지만 일반적으로 본격적인 튜플 사용과 관련된 힙 할당을 피합니다. 박스형 튜플이 반환되면 구성 요소는 레지스터 나 스택에 직접 저장됩니다. 박스형 튜플 자체에는 합성 표현이 없습니다. &lt;code&gt;primops.txt.pp&lt;/code&gt; 에 나열된 많은 기본 작업은 상자가 없는 튜플을 반환합니다. 특히, &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;ST&lt;/code&gt; 모나드는 작동 순서 동안 불필요한 할당을 피하기 위해 상자없는 튜플을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">Unboxed 튜플은 실제로 &lt;code&gt;GHC.Exts&lt;/code&gt; ; 그것들은 구문 확장 ( &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; )입니다. 박스형 튜플은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">박스형 튜플은 다중 대치 대안에 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">박스형 유형은 C에서 사용하는 &quot;원시 기계&quot;유형에 해당합니다. &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *) 등 이러한 유형 의 &lt;em&gt;기본 작업&lt;/em&gt; (PrimOps)은 기대할지도 모른다; 예를 들어, &lt;code&gt;(+#)&lt;/code&gt; 은 &lt;code&gt;Int#&lt;/code&gt; s 에 추가 된 것으로서, 우리 모두가 알고 사랑하는 기계 첨가물이며 대개 하나의 명령입니다.</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">확인되지 않은 액세스</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">확인되지 않은 부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">불변 배열의 확인되지 않은 읽기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">변경 가능한 배열의 확인되지 않은 쓰기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">제안의 유형이나 응용 프로그램을 표시하지 않음으로써 유효한 구멍 맞춤 목록을 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">C 전 처리기에서 기호 정의</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">일반적인 방법으로 매크로 &quot;기호&quot;를 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">사용자 정의 명령 ⟨name⟩을 정의 해제하십시오 ( 위의 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 이는 &lt;code&gt;Either * Char&lt;/code&gt; 와 같은 표현식이 &lt;code&gt;(*) Either Char&lt;/code&gt; 아닌 &lt;code&gt;Either (*) Char&lt;/code&gt; 로 구문 분석 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서 시스템 I / O 라이브러리는 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">GHC에서 재 작성 규칙은 중단 (==)을 특수한 breakByte에 대한 호출로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">Mac OS X에서는 디버그 정보가 실행 파일과 떨어져 있습니다. 실행 파일을 컴파일 한 후 &lt;code&gt;dsymutil&lt;/code&gt; 유틸리티를 사용하여 디버깅 정보를 추출하고 디버그 아카이브에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">대부분의 상황에서 독립 실행 형 파생을 사용하여 생성자가 모두 범위에 속하지 않는 데이터 유형에 대한 인스턴스를 작성할 수는 없습니다. 파생 된 인스턴스가 배후의 생성자를 사용하는 코드를 생성하기 때문에 추상화가 중단되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">ByteString 펼치기</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">생성자 응용 프로그램 펼치기</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">불행히도 DWARF는 GHC가 생성하는 코드를 완전히 설명하기에 충분하지 않습니다. 이것은 라인 정보의 경우에 가장 분명합니다. GHC는 다양한 가능한 소스 위치 중에서 일부를 선택해야합니다. 이는 기존 통계 프로파일 링 도구로 DWARF 정보의 유용성을 제한합니다. 프로파일 링을 위해서는 확장 된 디버깅 정보를 사용하는 것이 좋습니다. 아래의 &lt;em&gt;프로파일 링&lt;/em&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">불행히도. 아직 구현하지 않았습니다. GHCi에로드하기 전에 문제가있는 모듈을 직접 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">유니 코드 표준 범주 (UnicodeData 테이블의 열 2)는 유니 코드 표준 (특히 유니 코드 문자 데이터베이스)에 나열된 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">유니 코드 로마 숫자도 &quot;숫자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">유니 코드 대안</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">유니 코드 문자는 문자, 숫자, 표시, 문장 부호, 기호, 구분 기호 (공백 포함) 및 기타 (제어 문자 포함)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">유니 코드 인코딩 / 디코딩</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">유니 코드 일반 범주</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">단방향 동의어는 패턴 컨텍스트에서만 사용할 수 있으며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​출력 기록으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​상태로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">무인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">프로그램 텍스트에 지정된 순서대로 1부터 계산되는 데이터 유형 생성자에 대한 고유 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">독특한 개체</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">단위 : 인수가없는 생성자에 사용</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">세계시</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">범용 결합 기능</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">유닉스 시스템</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">달리 문서화되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">달리 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 우측 함수 유형을 포함하는 데이터 타입에 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">달리 &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 암시하지 않습니다 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; . 이 결정의 근거는 용어 레벨 패턴 이름과 달리 유형 이름은 종종 문서화 목적으로 명시 적으로 선택되므로 유형 이름에 밑줄을 사용하면 문서를 읽기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">프로그램을 불완전하게 만들고 평가할 때 오류를 생성하는 &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; 와 달리 형식 서명에 구멍이있을 필요는 없습니다. 형식 검사기는 형식 서명이 있거나없는 바인딩을 형식 검사 할 수 있습니다 (대부분의 경우). 부분 타입 시그니처는 두 극단 사이의 간격을 메우고, 프로그래머는 어떤 유형의 부분에 주석을 달고 어떤 부분을 유형 검사기에 남겨 둘지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 와 달리이 옵션으로 인해 패키지 ⟨pkg be가 결과 실행 파일 또는 공유 객체에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 와 달리 요소를 강제하지 않고 검색하는 데 사용할 수 있습니다. 예를 들어, 시퀀스의 다섯 번째 요소 삽입 &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 키에서 &lt;code&gt;k&lt;/code&gt; , 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 타입 생성자에 매핑되지 않는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; . 다음과 같이 직접 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 절대 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 과 달리 재귀 함수 에는 &lt;code&gt;INLINABLE&lt;/code&gt; pragma 를 사용하는 것이 좋습니다 . &lt;code&gt;SPECIALISE&lt;/code&gt; 나중에 사용할 수 있도록하는 주요 이유</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">달리 C에서 &lt;code&gt;printf(3)&lt;/code&gt; 이 본의 서식 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 인수의 형태에 의해 구동된다; 형식은 유형에 따라 다릅니다. 로 포맷 종류 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;상자 밖으로&quot;는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 GHC는 데이터 유형의 형식을 제한하지 않습니다. 대신 GHC는 단순히 지정된 클래스에 적합한 상용구 코드를 생성하고 유형을 확인합니다. 유형 오류가 있으면 문제입니다. (GHC는 유형 오류가있는 경우 문제 코드를 표시합니다.)</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 , 인스턴스는 데이터 유형보다 더 구체적 일 수 있습니다 ( &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 완화 된 규칙을&lt;/a&gt; 사용한다고 가정 ). 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">Haskell-98 스타일 데이터 형식 선언과 달리 &quot; &lt;code&gt;data Set a where&lt;/code&gt; &quot;헤더 의 형식 변수 에는 범위가 없습니다. 실제로, 대신에 친절한 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">표현식 및 선언 유형 서명과 달리 패턴 유형 서명은 암시 적으로 일반화되지 않습니다. &lt;em&gt;패턴 바인딩&lt;/em&gt; 의 &lt;em&gt;패턴&lt;/em&gt; 은 이미 범위에있는 유형 변수 만 언급 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 과 달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 &lt;code&gt;encode'&lt;/code&gt; 가 아니라 &lt;code&gt;encode&lt;/code&gt; '를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; 형식의 일반 선언 스플 라이스와 달리 선언 준 따옴표는 선언 그룹을 중단시키지 않습니다. 자세한 정보는 &lt;a href=&quot;#th-syntax&quot;&gt;구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">일반적인 선언 스플 라이스와 달리 선언 준 따옴표는 분리되지 않습니다. 이 준표자는 나머지 선언 그룹이 처리되기 전에 확장되고 생성 된 선언은 주변 선언 그룹에 병합됩니다. 따라서, 볼 타입 환경 &lt;code&gt;reify&lt;/code&gt; 선언의 quasiquoter에서이 quasiquoter의 선언 그룹에서 아무것도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">서명 파일에 선언 된 엔터티 만 범위로 가져 오는 다른 선언과 달리 구현의 인스턴스는 서명 파일에서 선언되지 않은 경우에도 항상 범위로 가져옵니다. 이것은 모듈이 서명에 대해서는 타입 검사를 할 수 있지만 일치하는 구현에 대해서는 검사 할 수 없음을 의미합니다. 서명이있는 패키지 내에 고아 인스턴스를 정의하지 않으면 이와 같은 상황을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">다른 제거 기능과 달리이 기능은 읽기 전용으로 표시되거나 권한으로 인해 제거 할 수없는 파일을 삭제하려고 시도합니다. 결과적으로 제거가 완료되지 않으면 나머지 파일의 권한 또는 속성이 변경 될 수 있습니다. 디렉토리에 하드 링크가 있으면 모든 관련 하드 링크에 대한 권한이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">비슷한 이름의 다른 함수와 달리 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 는 Win32 API의 &lt;code&gt;SearchPath&lt;/code&gt; 를 사용하지 않습니다 . 따라서 Windows에서이 기능의 동작은 Windows 이외의 플랫폼에서의 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">일반 모듈과 달리 서명의 정의 된 엔터티에는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일에 기록 된 엔터티 뿐만 아니라 상속 된 서명의 엔터티 도 포함됩니다 ( &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그 에서 유추 ). 이러한 엔티티는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일을 유형 검사 할 때 범위 내에서 고려되지 않지만 서명을 가져 오는 모듈 또는 서명으로 가져올 수 있습니다. 이 규칙의 예외는 아래에 설명 된 내보내기 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 묶인 타입 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 방정식 의 오른쪽에 걸쳐 있습니다. (따라서 구별 유형 변수 사용할 필요가 없다; 사용 &lt;code&gt;a&lt;/code&gt; . 동등한 것)를</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">연관된 유형 패밀리 선언 자체와 달리 기본 인스턴스의 유형 변수는 상위 클래스의 유형 변수와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 의 기본 정의와 달리 0에 대해 정의되므로 가능하면 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">일반 데이터 정의와는 달리, 데이터 가족의 결과 종류 일 필요는 없습니다 &lt;code&gt;Type&lt;/code&gt; : 그것은 양자 택일 (와 종류의 변수가 될 수 있습니다 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ). 그러나 데이터 인스턴스의 종류는 &lt;code&gt;Type&lt;/code&gt; 으로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">:-) GHC에 제공하는 유용한 편집증 옵션은 &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lint 옵션입니다. 이로 인해 각 코어에서 코어로의 변환 패스 후 &quot;보풀이없는&quot;패스가 오류 (특히 유형 오류)를 확인합니다. 우리는 &lt;code&gt;-dcore-lint&lt;/code&gt; 실행 합니다. 컴파일 시간이 약 5 %입니다.</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">세마포어를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">벡터의 요소를 언 박스 튜플에 풉니 다. #</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">압축 풀기 생성자 필드는 컴파일러에 펼침을 표시하여 가능한 한 자주 복싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">활성 시간 초과를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">등록되지 않은 컴파일은 GHC를 새로운 머신으로 포팅 할 때 유용 할 수 있습니다. 그 이유는 사전 설치 도구를 &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 로 줄이거 나 그 외에는 더 이상 등록하지 않은 컴파일을 얻기 위해 작성해야하는 플랫폼 별 코드의 양을 줄여 주기 때문입니다. 가는 것은 보통 아주 작습니다.</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">컴파일 타임에 등록되지 않은 컴파일을 선택할 수 없습니다. 적절한 옵션 세트로 GHC를 빌드해야합니다. 자세한 내용은 GHC 빌딩 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자, 0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 반환 반환 범위 검사를 생략합니다. 이는 프로그래머가 범위를 다른 방식으로 검사하도록 보장해야 할 의무가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">안전하지 않은 API 만.</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">안전하지 않은 IO 작업</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 사이의 안전하지 않은 변환 . 이것은 no-op이며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성에 편의상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">안전하지 않은 변환 코드</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">소수 자릿수에 대한 안전하지 않은 변환.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">안전하지 않은 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">안전하지 않은 저수준 작업</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">안전하지 않은 작업</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 수준 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 적 원자 비교 및 ​​배열 내 요소 교체.</target>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">STM 모나드에서 IO를 안전하지 않게 수행합니다. 조심하십시오 : 이것은 매우 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">특정 옵션을 설정 해제합니다. 사용 가능한 옵션 목록은 &lt;a href=&quot;#ghci-set&quot;&gt;: set 및 : seti 명령&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">부호없는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">부호없는 정수 유형</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">불안정한 스냅 샷 릴리스의 이름은 &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; 입니다. 여기서 &lt;code&gt;YYYYMMDD&lt;/code&gt; 는 스냅 샷이 작성된 소스의 날짜입니다. 예를 들어, &lt;code&gt;6.7.20040225&lt;/code&gt; 는 &lt;code&gt;6.8&lt;/code&gt; 분기를 만들기 전에 HEAD의 스냅 샷입니다 .</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">함수로 RWST 계산을 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">누적 계산을 (결과, 출력) 쌍으로 래핑 해제합니다. (의 역 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">누적 계산을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">일련의 쌍을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">문자가 지정된 소스 위치를 업데이트하십시오. 문자가 개행 ( ​​'\ n') 또는 캐리지 리턴 ( '\ r') 인 경우 줄 번호는 1 씩 증가합니다. 문자가 탭 ( 't') 인 경우 열 번호는 가장 가까운 8 '까지 증가합니다 열, 즉 &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; . 다른 모든 경우에는 열이 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">지정된 시간 (마이크로 초) 내에 실행되도록 활성 시간 초과를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &quot;을 사용하여 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; 대해 미리 작성된 정확한 바이트 수를 계산하십시오 . 경우 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 가 작성되고보고 제로 반면, 기록 된 바이트 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 에 보고 한 바이트.</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt; 사용할 프로그램을 선택 하려면 -pgmF ⟨cmd⟩ 를 사용하십시오 . ⟨cmd⟩ 프리 프로세서는 명령 행에 최소한 세 개의 인수가 제공됩니다. 첫 번째 인수는 원본 소스 파일의 이름이고, 두 번째는 입력을 보유한 파일의 이름이며, 세 번째는 ⟨cmd⟩가 출력을 기록해야하는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 규칙이 해고되고 있는지 아주 자세하게 볼 수 있습니다. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt; 정의 된 규칙 확인 &lt;em&gt;이 모듈을&lt;/em&gt; . 여기에는 전문화 단계에서 생성 된 규칙이 포함되지만 다른 모듈에서 가져온 규칙은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실행중인 규칙을 확인하십시오. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용 하고 중단 가능한 작업을 피 하십시오 . 이를 위해 어떤 작업이 중단 가능한지 알아야합니다. 주어진 라이브러리 함수에 대해 내부적으로 인터럽트 가능한 조작을 호출 할 수 있는지 여부를 알 수 없습니다. 대신 아래에 보장 할 수없는 보장 가능한 작업 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 범위 동안 호출 된 인터럽트 가능 조작 이 단시간 동안 만 차단 될 수 있다는 것을 보장 할 수 없으면 일반적으로 권장되지 않습니다 . 그렇지 않으면, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 는 프로그램을 교착 상태로 만들고 사용자 인터럽트에 응답하지 않는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">이 문제를 피 하려면 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 의 동작을 얻으려면 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; 을 사용 하여 &lt;a href=&quot;data-monoid&quot;&gt;Data&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 의 동작을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">실행 파일에 &lt;strong&gt;strip&lt;/strong&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">LLVM을 통해 컴파일하는 대신 GHC의 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;고유 코드 생성기를&lt;/a&gt; 사용하십시오 . &lt;code&gt;-fasm&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">STM을 사용하십시오. 트랜잭션은 항상 완전히 실행되거나 전혀 실행되지 않기 때문에 트랜잭션은 비동기 (및 실제로 동기) 예외가있을 때 상태에 대한 불변을 유지하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 입력 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 증거 로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">더 큰 힙을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">가장 오래된 세대를 수집하려면 압축 알고리즘을 사용하십시오. 기본적으로 가장 오래된 세대는 복사 알고리즘을 사용하여 수집됩니다. 이 옵션을 사용하면 대신 해당 위치로 압축됩니다. 압축 알고리즘은 복사 알고리즘보다 속도가 느리지 만 메모리 사용을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">ApplicativeDo에 대해 느리지 만 더 나은 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">제목에 작은 상자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오. 항상 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">다음과 같이 레코드 표현식에 명시 적 유형 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">오류 메시지에 색상 사용</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">GHCi 명령 히스토리 파일 &lt;code&gt;.ghci-history&lt;/code&gt; 에 현재 디렉토리를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">사이의 값을 소수점 표기법을 사용하여 &lt;code&gt;0.1&lt;/code&gt; 및 &lt;code&gt;9,999,999&lt;/code&gt; 달리, 과학 표기법을.</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">주어진 파일에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">외국 수출 신고를 사용하여 외부에서 호출하려는 Haskell 함수를 수출하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">세대 Cgen⟩ 이상의 병렬 GC에서로드 밸런싱을 사용하십시오. ⟨gen⟩을 생략하면로드 밸런싱이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">더 많은 메모리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">이 유형의 사용은 권장하지 않습니다. 다음과 같은 내용을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">세대 ⟨gen⟩ 이상에서는 병렬 GC를 사용하십시오. ⟨gen⟩을 생략하면 병렬 GC가 완전히 꺼지고 순차적 GC로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">posix setgid를 사용하여 하위 프로세스의 그룹 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">posix setsid를 사용하여 새 세션에서 새 프로세스를 시작하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">posix setuid를 사용하여 하위 프로세스의 사용자 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">이전 매개 변수를 사용하십시오. 기본적으로 PostScript 그래프는 페이지를 채울 수 있도록 가로 및 세로로 자동 크기 조정됩니다. 그러나 프리젠 테이션에 사용할 일련의 그래프를 준비 할 때 이전 그래프와 동일한 스케일, 음영 및 순서를 사용하여 새 그래프를 그리는 것이 종종 유용합니다. &lt;code&gt;-p&lt;/code&gt; 플래그의 이전 실행에 의해 결정된 파라미터를 사용하여 그려 그래프 발생 &lt;code&gt;hp2ps&lt;/code&gt; 에 &lt;code&gt;file&lt;/code&gt; . 이들은 &lt;code&gt;file@.aux&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">정적 하스켈 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">엄격 주석을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아닌 경우에도 가능하면 터미널 스타일의 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 블록 에서 반박 가능한 패턴을 제거 할 때 레거시 &lt;code&gt;Monad.fail&lt;/code&gt; 함수 대신 &lt;code&gt;MonadFail.fail&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">OS 선호도 기능을 사용하여 OS 스레드를 CPU 코어에 고정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;-fno-cse&lt;/code&gt; 를 사용하면 모듈에서 공통 하위 표현식 제거가 수행되지 않도록 할 수 있습니다. 별도의 두 가지 부작용이 결합 될 수 있습니다. 좋은 예는 여러 전역 변수를 사용하는 것입니다 ( 아래 예의 &lt;code&gt;test&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">어떤 플래그가 실행 &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 하려면 디버그 플래그 -ddump-simpl-stats 를 사용하십시오. 추가 정보가 필요한 경우 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 는 각 개별 규칙 발생을 표시하고 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 는 재 작성 전후의 코드 모양도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">디버깅 런타임 사용</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 코드 생성기의 레지스터 할당에 그래프 색상 지정 레지스터 할당자를 사용하십시오. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">기본 코드 생성기에서 반복 병합 그래프 색상 지정 레지스터 할당자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">입력 및 출력 모두에서 기본 개행 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">새로운 cfg 기반 블록 레이아웃 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">⟨file⟩ 또는 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; 패키지 환경 을 사용하십시오 &lt;code&gt;-&lt;/code&gt; 패키지 환경을 읽지 않으면 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">개인용 이스케이프 메커니즘을 사용하여 잘못된 시퀀스를 라운드 트립 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">실행 가능 프로그램 에서 런타임 플래그 &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;-with-rtsopts&lt;/code&gt; 로 설정된 옵션을보십시오 .</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">지정된 패키지 환경을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">제공된 손잡이를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">스레드 런타임 사용</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">다음과 같이 레코드 업데이트에 푸시되는 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows CREATE_NEW_CONSOLE 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows DETACHED_PROCESS 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">바운드 스레드 사용으로 인해 실제로 성능 손실이 관찰 된 드문 경우 &lt;em&gt;에만&lt;/em&gt; 이 기능을 사용하십시오 . 메인 스레드를 바인딩 할 필요가없고 동시성 (예 : 웹 서버) 을 &lt;em&gt;많이&lt;/em&gt; 사용 하는 프로그램 은 &lt;code&gt;main&lt;/code&gt; 액션을 &lt;code&gt;runInUnboundThread&lt;/code&gt; 로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">이 기능을 사용하면 JSON 또는 HTML과 같은 텍스트 기반 형식에 효율적인 인코더를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">청크가 생성 된 직후 폐기되는 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 생성에이 전략을 사용하십시오 . 예를 들어 네트워크 소켓에 쓰기 위해 생성하는 경우를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">이 전략을 사용하면 청크가 하나의 가비지 콜렉션에서 살아남을 수있는 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 할 수 있습니다. 이 전략은 너무 많은 메모리를 쏟지 않도록 절반 이하로 채워진 버퍼를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">박스 형태를 사용하지 마십시오 (GHC 확장자) :</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때는 유니 코드 구문을 사용하십시오. &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">C 컴파일러로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">C 컴파일러로 cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-cpp&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-cpp&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">LLVM 최적화 프로그램으로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">LLcmd⟩를 LLVM 최적화 프로그램으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool의 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">interpretcmd⟩를 외부 인터프리터 명령으로 사용하십시오 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 기본값 : &lt;code&gt;-prof&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;ghc-iserv-prof&lt;/code&gt; , &lt;code&gt;-dynamic&lt;/code&gt; 이 활성화 된 경우 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 또는 그렇지 않으면 &lt;code&gt;ghc-iserv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">외부 통역사 명령으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용 하는 경우).</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">링커로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">링커로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-F&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-F&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">Windows에서 매니페스트를 포함시키기위한 프로그램으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windows에서 매니페스트를 포함하는 데 사용할 프로그램으로 ⟨cmd⟩를 사용하십시오. 일반적으로 이것은 GHC 설치와 함께 제공되는 프로그램 &lt;code&gt;windres&lt;/code&gt; 입니다. &lt;a href=&quot;#options-linker&quot;&gt;연결에 영향을주는 옵션의 &lt;/a&gt; &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">스플리터로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">스플리터로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">filefile⟩을 makefile로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makefile&lt;/code&gt; 또는 &lt;code&gt;Makefile&lt;/code&gt; 대신 ⟨file⟩을 makefile로 사용하십시오 . ⟨file⟩이 존재하지 않는 경우, &lt;code&gt;mkdependHS&lt;/code&gt; 는 그것을 만듭니다. 우리는 자주 사용하는 &lt;code&gt;-dep-makefile .depend&lt;/code&gt; 의 종속성을 넣어 &lt;code&gt;.depend&lt;/code&gt; 을 다음 &lt;code&gt;include&lt;/code&gt; 파일 &lt;code&gt;.depend&lt;/code&gt; 에 &lt;code&gt;Makefile&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">프로그램을 실행할 때 ⟨x⟩ 동시 스레드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">대화식 바인딩 세트에 대한 SPT 항목을 추가하기 위해 GHCi에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">'x 등에 사용되지만 프로그래머는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">컴파일러 생성 오류 메시지에 사용됩니다. 인코딩하면 문자열 정크 바이트가 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">매개 변수 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">오버로드 및 오버로드되지 않은 리터럴에 사용됩니다. 현재 오버로드되지 않은 리터럴을 표현할 수있는 좋은 방법이 없습니다. 그게 중요하지 않을까요?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; , &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 및 &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..m]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; , &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 및 &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..]&lt;/code&gt; 을 &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..m]&lt;/code&gt; 을 &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">Fast String 조각을 나타내는 데 사용되지만 이제는 더 이상 사용되지 않으며 Str 생성자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 의 &lt;code&gt;xxxBy&lt;/code&gt; 함수 계열 과 함께 사용하기에 유용한 결합기 ( 예 :</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">유용한 오류 처리 기능</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">NF = WHNF가 보유한 유형에 대해 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 를 정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">가비지 수집이 필요한 장기 할당에 유용합니다. 그러나 외부 데이터 구조에 메모리에 대한 포인터를 저장하려는 경우 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 을 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">할당이 지정된 &lt;code&gt;IO&lt;/code&gt; 계산을 통해 범위를 지정하려는 경우 단기 할당에 유용합니다 . 이러한 종류의 할당은 일반적으로 FFI 기능과 데이터를 마샬링 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">에 유용한:</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">유용한 기능과 결합기.</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">유용한 기능.</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">유용한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">인스턴스 작성에 유용한 헬퍼</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">불변으로 인한 유용한 속성 :</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">사용자 환경</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">사용자 상호 작용 기능</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">사용자 환경 설정</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">사용자 정의 연산자에는 새 &lt;code&gt;form&lt;/code&gt; 키워드 대신 바나나 괄호가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">사용자 정의 유형 오류</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 비교 ( &lt;code&gt;Ord&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 평등 ( &lt;code&gt;Eq&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">사용자는 GHC가 내부적으로 지문 계산에 사용하는 것과 동일한 기능을 사용할 수 있습니다. &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint의&lt;/a&gt; 모듈은 지문을 구성하기위한 유용한 기능을 제공합니다. 예를 들어, &lt;code&gt;fingerprintFingerprints&lt;/code&gt; 와 &lt;code&gt;fingerprintString&lt;/code&gt; 을 함께 사용 하면 플러그인에 인수를 순진하게 쉽게 지문으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;~/.haskeline&lt;/code&gt; 파일을 사용 하여 인터페이스를 사용자 정의 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">내장 제약 조건 해결 동작과 충돌하지 않는 경우 사용자는 자신의 &lt;code&gt;HasField&lt;/code&gt; 인스턴스를 정의 할 수 있습니다. 이를 통해 다른 유형의 데이터 유형에 대해 &quot;가상&quot;레코드 필드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">사용자는 다음 규칙을 준수 할 것으로 예상되는 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 의 사용자 지정 인스턴스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">이 기능의 사용자는 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; 그들이 다른 하스켈 스레드가 readProcess의 결과를 기다리는 동안 계속 실행하려면.</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">사용자는 &lt;code&gt;~&lt;/code&gt; 를 원할 가능성이 높지만 , GHC가 사전에 두 가지 관심 유형이 같은 종류라는 것을 알 수없는 경우 &lt;code&gt;~~&lt;/code&gt; 를 사용할 수 있습니다. 있다는 증거 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; GHC이 모두 알려 &lt;code&gt;k1&lt;/code&gt; 과 &lt;code&gt;k2&lt;/code&gt; 동일하고 있는지 및 &lt;code&gt;b&lt;/code&gt; 동일하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">구성 및 패턴 일치를 포함하여 생성자를 언급하기 때문에 항상 모호하지 않은 필드를 사용하면 중복 된 필드 이름을 자유롭게 사용할 수 있습니다. 예를 들어, &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 다음이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">8 비트 문자 사용</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">프로그래머는 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#newtype-deriving&quot;&gt;newtypes의 일반 파생 인스턴스)을&lt;/a&gt; 사용하여 기존 클래스 인스턴스를 가져 와서 새 유형의 해당 클래스 인스턴스로 &quot;리프팅&quot;할 수 있습니다. 그러나 이것이 항상 안전한 것은 아닙니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC에게 인쇄시 동등 관계를 구별하도록 지시합니다. 예를 들어, &lt;code&gt;~&lt;/code&gt; 는 균질 해제 평등 (인수의 종류는 동일 함)이며 &lt;code&gt;~~&lt;/code&gt; 는 이종 해제 평등 (인수의 종류가 다를 수 있음)이며 &lt;code&gt;~#&lt;/code&gt; 는 이기종 해제 된 평등, GHC의 내부 평등 관계입니다. 솔버. 일반적으로 사용자는 여기서 미묘함에 대해 걱정할 필요가 없습니다. &lt;code&gt;~&lt;/code&gt; 아마 당신이 원하는 것입니다. &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는이 모든 것을 &lt;code&gt;~&lt;/code&gt; 로 인쇄합니다 . &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;평등 제약 조건을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt; 유형의 GHC 인쇄 강제 변환을합니다. 다른 종류의 유형 간 동등성을 증명하려고 할 때 GHC는 유형 수준의 강제를 사용합니다. 사용자는 내부 용이므로 이러한 정보를 거의 볼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; GHC는 명시 적으로 인쇄 할 수 &lt;code&gt;forall&lt;/code&gt; 유형의 상단 수준에서 정량화; 일반적으로 이것은 억제됩니다. 예를 들어 GHCi에서 :</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; GHC는 일반적으로 억제하는 유형의 종류 인수를 인쇄 할 수 있습니다. 종류 다형성을 사용할 때 중요 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 의 형식 서명 에있는 형식 변수가 형식 응용 프로그램에 사용 가능 하지 않다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 보이는 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 를&lt;/a&gt; 사용 하는 것은 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 것이 좋습니다. 그렇지 않으면 추가 포장 및 포장 풀기가 최적화되지 않기 때문입니다. 사실, 가능성이 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 도 성능을 악화시킬 수 &lt;em&gt;와 &lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 를&lt;/a&gt; (그것이 당신에게 무슨 일이 생기면 알려 주시기), 그러나 이것은 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 은 하스켈 런타임 시스템의 스케줄링 행동에 전혀 차이가 없습니다. 당신이 사용해야하는 일반적인 오해입니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 을 외국 전화를 걸 때 모든 하스켈 스레드를 차단하지 않도록; 그렇지 않습니다. 모든 Haskell 스레드 (GHC 포함)를 차단하지 않고 외래 전화를 걸 려면 프로그램을 링크 할 때 &lt;code&gt;-threaded&lt;/code&gt; 옵션 만 사용 하고 외래 가져 오기가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 형식 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머는 이러한 문제를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 사용 은 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 형식 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머는 이러한 문제를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 형식 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머는 이러한 문제를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">로 ByteStrings를 사용 &lt;code&gt;CString&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">ByteString을 CString으로 사용</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">CString에 함수와 함께 ByteStrings 사용</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; 옵션 없이 GHC를 사용하면 모든 외래 호출은 시스템의 다른 모든 Haskell 스레드를 차단하지만 I / O 작업은 그렇지 않습니다. 으로 &lt;code&gt;-threaded&lt;/code&gt; 옵션의 만 외국 통화 &lt;code&gt;unsafe&lt;/code&gt; 속성은 다른 모든 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">공유 객체 이름에 GHC의 버전 번호를 사용하면 다른 GHC 버전으로 컴파일 된 다른 라이브러리 버전을 표준 시스템 위치 (예 : * nix &lt;code&gt;/usr/lib&lt;/code&gt; 아래)에 설치할 수 있습니다 . GHC의 버전 번호를 얻으려면 &lt;code&gt;ghc --numeric-version&lt;/code&gt; 을 호출 하고 ⟨GHCVersion⟩ 대신 해당 출력을 사용하십시오. 공유 객체 링크를 위해 객체 파일을 준비하는 방법에 대한 &lt;a href=&quot;phases#options-codegen&quot;&gt;코드 생성&lt;/a&gt; 에 영향을주는 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 의 조합을 사용하면 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 일반 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는 수행 방법에 대한 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">로케일 종속 인코딩 사용</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">패키지를 사용하는 것이 더 간단 할 수는 없습니다 : &lt;code&gt;--make&lt;/code&gt; 또는 GHCi를 사용하는 경우 , 설치된 옵션의 대부분은 추가 옵션없이 프로그램에서 자동으로 사용할 수 있습니다. 이 규칙의 예외는 아래의 &lt;a href=&quot;#using-packages&quot;&gt;패키지 사용&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">값을 0으로 설정하면 RTS 클럭이 완전히 비활성화되고 컨텍스트 스위치 타이머 및 힙 프로파일 링 타이머와 같은 타이머를 비활성화하는 효과가 있습니다. 상황 전환은 여전히 ​​발생하지만 결정 론적으로 정상보다 훨씬 빠른 속도로 진행됩니다. 인터벌 타이머를 비활성화하면 런타임시 비결 정성 소스가 제거되므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">레코드 선택기 사용</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 모듈을 병렬로 컴파일 할 수 있습니다. ⟨n⟩ 작업을 병렬로 컴파일하려면 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; 을 지정 하십시오 . ⟨n⟩을 생략하면 기본값은 프로세서 수입니다.</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">은 Using &lt;code&gt;+&lt;/code&gt; 용 의 형태 &lt;code&gt;module&lt;/code&gt; 명령은 현재 범위에 모듈을 추가하고 &lt;code&gt;-&lt;/code&gt; 이를 제거한다. &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 없으면 현재 범위는 지정된 모듈 세트로 대체됩니다. 이 양식을 사용하고 &lt;code&gt;Prelude&lt;/code&gt; 를 생략 하면 암시 적 &lt;code&gt;Prelude&lt;/code&gt; 가져 오기가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">일반적으로 GHC 블랙홀은 스레드를 전환 할 때만 썽크입니다. 이 플래그는 썽크가 입력 되 자마자 그렇게합니다. &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;공유 메모리 멀티 프로세서에서 Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">일반적으로 사용자의 실제 이름 (pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">일반적으로 파일 이름은 모듈 이름을 따서 지정해야하며 모듈 이름의 점은 디렉토리 구분 기호로 대체해야합니다. 예를 들어, Unix 시스템에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈 은 일부 기본 디렉토리와 관련 하여 파일 &lt;code&gt;A/B/C.hs&lt;/code&gt; 에 배치되어야합니다 . 다른 모듈 ( 예 : &lt;code&gt;Main&lt;/code&gt; ) 에서 모듈을 가져 오지 않으면 파일 이름을 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">Win32 API 호출을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">Windows C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">문서를위한 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">유효한 &lt;code&gt;fst _ _&lt;/code&gt; 구멍 인 &lt;code&gt;head _ _&lt;/code&gt; 또는 fst _ _ 와 같은 구멍 이 있지만 리파이닝 레벨이 &lt;code&gt;&amp;gt;= 2&lt;/code&gt; 인 경우 유효한 리파이닝 구멍 맞춤의 유효한 목록이 종종 커질 수 있습니다. 이러한 구멍의 종류 나 종류가 제안 된 식별자에 의해 전혀 제약을받지 않는다는 점에서 여전히 완전히 개방되어있다. 기본적으로 이러한 구멍은보고되지 않습니다. 이 플래그를 켜면 해당 구멍이 유효한 다듬기 구멍 맞춤 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 유효성을 검사합니다 . 이 접근법은 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt; 사용의 장점을 보여 줍니다 . 우리는에 계속 전달 &lt;code&gt;validateName&lt;/code&gt; 및 인터럽트의 실행을 &lt;code&gt;Cont&lt;/code&gt; 발 블록 &lt;em&gt;내부&lt;/em&gt; 의 &lt;code&gt;validateName&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우는 동안 계산 된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 값 은 항상 네트워크 순서 (빅 엔디안) 형식으로 인코딩되며 인코딩 된 데이터는 컴퓨터 엔디안, 워드 크기 또는 컴파일러 버전간에 이식 가능해야합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 데이터 는 모든 컴퓨터에서 쓰고 다른 컴퓨터에서 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TExp a&lt;/code&gt; 유형의 값은 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; 함수를 사용하여 &lt;code&gt;Exp&lt;/code&gt; 유형의 값으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">바닐라 유형 동의어 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">타입 어플리케이션에 사용할 수없는 변수가 우선입니다.</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort (ScopedSort)에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; 하는 &quot;장벽 재정렬에&quot;속성 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">허용되는 인스턴스의 다양성이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">OS 버전 확인</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">버전 정보</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">컴퓨터에 대한 버전 정보.</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 크기의 moduli 용 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;nextPrimeInteger&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">버전 관리 체계는 다양하고 다양하므로이 라이브러리에서 제공하는 버전 표현은 거의 모든 기능이 합리적으로 제공 될 수없는 완전한 일반 성과 너무 제한적인 특정 버전 관리 체계를 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">시퀀스의 왼쪽 끝을 봅니다.</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">시퀀스의 오른쪽 끝보기</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">패턴보기</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">언어 패턴 &lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; 에&lt;/a&gt; 의해 뷰 패턴이 활성화됩니다 . 보기 패턴에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">뷰 패턴은 다른 패턴 안에 중첩 될 수있는 패턴 가드와 다소 비슷합니다. 그것들은 추상 타입의 값들에 대한 패턴 매칭의 편리한 방법입니다. 예를 들어, 프로그래밍 언어 구현에서 다음과 같이 언어 유형의 구문을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">뷰 패턴을 사용하면 패턴 내부에서 뷰 함수를 호출하고 결과와 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">거의 모든 종류의 데이터 생성자를 포함하여 거의 모든 데이터 생성자를 승격시킬 수 있습니다. 이 규칙에는 몇 가지 예외 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">무효 : 생성자가없는 데이터 유형에 사용</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">경고 : 컴파일러가 기본 데이터 구조를 자유롭게 최적화하거나 복제 할 수 있기 때문에 기본이 아닌 기본 Haskell 유형에 대한 약한 포인터는 특히 취약합니다. 따라서 종료자를 일반 Haskell 유형에 배치하려고하면 종료 기가 예상보다 빨리 실행될 수 있습니다. 조기 종료가 쉬운 캐시 및 메모 테이블에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">장치를 사용할 수있게 될 때까지 기다리십시오</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">지정된 수량이 준비 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 을 기다 립니다 (일명 &lt;strong&gt;P&lt;/strong&gt; 작업).</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">신호를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">지정된 프로세스가 종료 될 때까지 대기하고 종료 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 예 : &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(*&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 즉, &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; 가 거꾸로 정의 된 경우 경고합니다 (예 : &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 가 거꾸로 정의되어 있으면 경고합니다 (예 : &lt;code&gt;pure = return&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">패턴 바인딩이 고독한 와일드 카드 패턴이거나 뱅킹 패턴이 아닌 한 변수가 바인딩되지 않는 경우 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">승격 된 데이터 생성자가 이름 앞에 틱없이 사용 된 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">규칙이 실행되기 전에 함수가 인라인 될 수 있으므로 재 작성 RULE이 실행되지 않을 수 있음을 경고합니다. &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;규칙이 INLINE / NOINLINE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Applicative&lt;/code&gt; 또는 &lt;code&gt;Monad&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규적인 &lt;code&gt;Monad&lt;/code&gt; 또는 &lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Semigroup&lt;/code&gt; 또는 &lt;code&gt;Monoid&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없으면 패키지를로드하고 대상 패키지 설명의 추가 라이브러리 스탠자를 분석 할 때로드해야한다고 추론했습니다.</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">범위를 벗어난 지연된 변수가 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 가없는 do-block에 실패한 패턴이 사용될 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">정의가 향후 &lt;code&gt;Semigroup&lt;/code&gt; 타입을 표준 유형 클래스에 포함시키는 것과 충돌 할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">지원되지 않는 LLVM 버전으로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">경고 : 주어진 &lt;code&gt;Vertex&lt;/code&gt; 이없는 경우 &lt;code&gt;nodeFromVertex&lt;/code&gt; 함수는 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">경고 :이 기능에는 몇 가지 단점이 있습니다 (설명서 참조). 대신 Control.Concurrent.threadDelay를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">경고 :이 함수는 엣지 목록의 정점이 지정된 &lt;code&gt;Bounds&lt;/code&gt; 내에 있지 않으면 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">경고 : 인터페이스가 불안정합니다.</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">경고 : 줄 바꿈 및 탭 문자는 구분 기호로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 논의하십시오. 이후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 토론하십시오. 이후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">(a) 정의 모듈 내에서의 사용, (b) 클래스 인스턴스에서 메소드 정의 및 (c) 내보내기 목록에서의 사용에 대해서는 경고 및 사용 중단이보고되지 않습니다. 후자는 하나의 모듈이 모여서 다른 모듈의 내보내기를 다시 내보내는 라이브러리 내의 가짜 불만을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">경고는 오류가 아닌 경고로만 취급됩니다. 이것이 기본값이지만 &lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 플래그 를 무효화하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">이 프로그램은 &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;등록되지 않은&amp;rdquo;&lt;/a&gt; GHC 버전으로 컴파일 되었습니까 ? (즉, 현재 지원되지 않는 플랫폼이기 때문에 플랫폼 별 최적화가 컴파일되지 않은 GHC 버전입니다.)이 값은 실험적으로 빌드 된 GHC를 사용하지 않는 한 일반적으로 아니오입니다.</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우리는 (1) 버퍼를 작성하는 것에 대한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현하는 BuildStep 에 완전히 넘겨줌으로써 달성 합니다 . 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 은 버퍼의 시작과 끝을 알려줍니다 ( &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 나타냄 ). 그런 다음, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 는 이것의 큰 접두사로 쓸 수 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 이 원하시는 어떤 방법이다. 경우] &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 가 완료되면, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 은 전체, 또는 바이트의 긴 시퀀스는 다음 직접 삽입 할 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 를 사용하여 A 호출자이 신호 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">우리는 (2) 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 계속되는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 을 수행하는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 으로 구현 되도록 요구함으로써이를 달성 함으로써 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 호출 합니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 연결을 구현하려면 함수 호출에서 두 개의 포인터 만 전달하면됩니다 . 또한 많은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 완전히 인라인되어 있으므로 컴파일러는 함수 호출없이 권투를 전혀하지 않고도 시퀀스를 시퀀싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">병렬 프로그램을 프로파일 링 하는 데 &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; 를 사용하는 것이 좋습니다 . 병렬 실행을 시각화하기위한 GUI를 제공하며 GHC와 함께 제공되는 시간 및 공간 프로파일 링 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 의 운영을 높이고 자 합니다. 동작을 위해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; , 우리는 알고 &lt;code&gt;throwE e&lt;/code&gt; 우리가 두 개의 모나드 변압기를 통해 올릴 수 있도록, 간단한 작업입니다 &lt;code&gt;InterpM&lt;/code&gt; 이와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">우리는 실제로 더 구체적인 유형으로 &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; 를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">우리는 하나의 모듈에 국한되지 않습니다 : GHCi는의 혼합, 여러 개의 모듈에서 범위를 결합 할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 및 비 &lt;code&gt;*&lt;/code&gt; 의 형태. GHCi는 이러한 모든 모듈의 범위를 결합하여 프롬프트에서 적용되는 범위를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">이것을 절차 또는 화살표 추상화라고합니다. 람다 식과 마찬가지로 변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;proc&lt;/code&gt; -expression 내에 바인딩 된 새 변수 입니다. 화살표 입력을 나타냅니다. 위의 예에서 &lt;code&gt;-&amp;lt;&lt;/code&gt; 는 식별자가 아니라 화살표 유형의 표현식과 해당 화살표에 입력으로 공급 될 표현식에서 명령을 빌드하는 데 사용되는 새로운 예약 기호입니다. (이상한 모양은 나중에 더 의미가있을 것입니다.) 화살표의 적용과 유사하게 읽을 수 있습니다. 위의 예는 Haskell 식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">Writer를 사용하여 프리미티브를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">비슷한 방식으로 생성자 클래스의 인스턴스를 파생시킬 수도 있습니다. 예를 들어, 상태 및 고장 모나드 변압기를 구현했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">또한 핸들 또는 파일과의 값을 직접 직렬화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">소스의 마크 업 버전을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">공백과 같은 문자가 포함 된 인수를 인용 할 수도 있고 Haskell 문자열처럼 취급하거나 Haskell 목록 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">위 의 &lt;code&gt;byteStringHex&lt;/code&gt; 예제 와 같이 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 16 진수로 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">이제 예상대로 &lt;code&gt;x&lt;/code&gt; 의 유형 이 재구성 되었으며 &lt;code&gt;f&lt;/code&gt; 의 유형 도 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">&lt;em&gt;바이너리&lt;/em&gt; 형식으로 변환하고 있음을 분명히 알 수 있습니다 . 127 이상의 유니 코드 코드 포인트를 갖는 '&amp;lambda;'및 '&amp;ouml;'문자는 해당 UTF-8 멀티 바이트 표현으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 목록의 여러 값을 단일 값으로 결합 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 여러 가지 다른 작업에서 monoid 이므로 여기에서 유형을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">우리는 &lt;code&gt;D&lt;/code&gt; 를 컴파일 한 다음 다음과 같이 전체 프로그램을로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">파일에서 GHCi 입력을 읽는 명령을 정의 할 수 있습니다. 이는 GHCi 세션에 반복적으로로드 할 바인딩 세트를 작성하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 변환기 를 추가하여 계산할 파서를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; 형식을 수정하여 접두사, 접두사 또는 레코드 패턴 동의어를 정의 할 수 있습니다 . 이에 대한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">정규 이해로 번역하여 병렬 목록 이해를 정의 할 수 있습니다. 기본 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">다음 인스턴스를 사용하여이 유형의 값을 바이트 문자열로 인코딩 할 수 있습니다.이 인스턴스는 반복적으로 구조를 직렬화하여 처리합니다.</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">newtype이 마지막 클래스 매개 변수 인 경우 다중 매개 변수 클래스의 인스턴스를 파생시킬 수도 있습니다. 이 경우 클래스의 &quot;부분 응용 프로그램&quot;이 &lt;code&gt;deriving&lt;/code&gt; 조항에 나타납니다 . 예를 들어, 클래스가 주어지면</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">대신 새로운 유형의 &lt;code&gt;App&lt;/code&gt; ( &lt;code&gt;App f a&lt;/code&gt; 및 &lt;code&gt;f a&lt;/code&gt; 가 메모리에서 동일하게 표시됨)을 만들고 &lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt; 를 사용하여이 패턴의 사용을 명시 적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;MismatchedParentheses&lt;/code&gt; 예외를 &lt;code&gt;MismatchedParentheses&lt;/code&gt; , &lt;code&gt;SomeFrontendException&lt;/code&gt; 또는 &lt;code&gt;SomeCompilerException&lt;/code&gt; 으로 잡을 수 있지만 &lt;code&gt;IOException&lt;/code&gt; 과 같은 다른 유형은 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">이제 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">값과 응용 프로그램으로 구성된 간단한 표현식을 EvalStmt에 전달할 수 있습니다. 이를 통해 GHCi에서 : set args 및 : set prog를 구현하는 데 사용되는 다른 함수에서 명령문을 랩핑 할 수 있습니다. 앞으로이 작은 언어를 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">클래스 선언에서 빈 멤버를 제거하여이 특정 문제를 회피 할 수 있습니다. 그러나 나머지 멤버 인 insert 및 member에는 모호한 유형이 없지만 사용하려고 할 때 여전히 문제가 발생합니다. 예를 들어 다음 두 가지 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">모나드 결합자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 인스턴스 작성을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">다음과 같이 마지막 두 개로 작성된 명령에 필요한 추가 입력을 일반 표현식에 적용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">그런 다음 표현 및 패턴 컨텍스트에서 &lt;code&gt;HeadC&lt;/code&gt; 를 사용할 수 있습니다. 패턴 컨텍스트에서는 길이가 하나 이상인 목록의 헤드와 일치합니다. 표현식 컨텍스트에서 싱글 톤 목록을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">따라서 &lt;code&gt;P&lt;/code&gt; 유형 (생성자 &lt;code&gt;MkP&lt;/code&gt; 가 있음 )을 승격 된 데이터 생성자 &lt;code&gt;'P&lt;/code&gt; (종류 &lt;code&gt;Prom&lt;/code&gt; ) 와 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">우리는 유형 체킹 수 &lt;code&gt;A&lt;/code&gt; 이 서명에 대해, 또는 우리는 인스턴스화 할 수 &lt;code&gt;Str&lt;/code&gt; 다음과 같은 선언을 제공하는 모듈. 서명을 인스턴스화하는 방법에 대한 자세한 내용은 Cabal 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">우리는 &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt; 의 인스턴스 이지만 &lt;code&gt;Monad&lt;/code&gt; 가 아닌 타입으로 do-notation을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">예를 들어 고정 값을 프리미티브 앞에 추가하거나 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">우리는 levity polymorphism을 사용하여 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 와 함께 좋은 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">다음 함수를 사용하여 조각을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">GHCi를 사용할 때 프로파일 러를 사용하여 스택 추적을 수집 할 수 있습니다 (GHCi의 &lt;a href=&quot;#ghci-stack-traces&quot;&gt;스택 추적&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 긴 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 짧은 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">마법의 유선 유형이 유형 &lt;a href=&quot;ghc-base&quot;&gt;검사기&lt;/a&gt; 가 알아 낸 것과 혼동되기 때문에 이러한 기능을 사용할 수있는 모듈 (예 : GHC.Base ) 에서 이러한 기능을 정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">우리는 우리 자신의 연산자를 정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">우리는 &lt;code&gt;f0&lt;/code&gt; 에게 아무것도 해독하기에 충분한 입력을 줄 수 없었 으므로 빈 문자열을 반환했습니다. 입력의 마지막 바이트 인 두 번째 연속 &lt;code&gt;f1&lt;/code&gt; 을 공급 하면 진행이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">우리는 시뮬레이션 할 수 &lt;code&gt;if&lt;/code&gt; 정의하여</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;g&lt;/code&gt; 를 적용 해 볼 수 있습니다. &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 형 과 &lt;code&gt;x :: b&lt;/code&gt; 형의 인수를 기대하기 때문에 작동하지 않습니다 . 더 나쁜 것은, &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 타입의 인수가 필요하기 때문에 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;a&lt;/code&gt; 타입 의 무언가로 바꿀 수 없다는 것입니다 ! 요컨대,이 작업을 수행하는 좋은 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">다음 표에서 UTF-8 CSV 인코딩 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">컴파일 된 버전의 &lt;code&gt;C&lt;/code&gt; 를 얻지 못했습니다 ! 어떻게 된 거예요? 글쎄, GHCi에서 컴파일 된 모듈은 다른 컴파일 된 모듈에만 의존 할 수 있으며,이 경우 &lt;code&gt;C&lt;/code&gt; 는 객체 파일이없는 &lt;code&gt;D&lt;/code&gt; 에 의존 하므로 GHCi는 &lt;code&gt;C&lt;/code&gt; 의 객체 파일 도 거부했다 . 자, &lt;code&gt;D&lt;/code&gt; 도 컴파일하자 :</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">우리는 세 종류의 와일드 카드를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 보편적으로 다형성이 아니기 때문에 &lt;code&gt;E3&lt;/code&gt; 의 주장을 접지 않습니다. 에서 &lt;code&gt;E3&lt;/code&gt; 은 그것의 최종 형태 파라미터와 동일하지 않도록, (암시 적) 실존 정량화 &lt;code&gt;E&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;(a ~ Int)&lt;/code&gt; 이지만 &lt;code&gt;Int&lt;/code&gt; 가 구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지 않기 때문에 &lt;code&gt;E1&lt;/code&gt; 또는 &lt;code&gt;E4&lt;/code&gt; 의 인수를 접지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">패키지를 어려운 방식으로 빌드하지 않는 것이 좋습니다. 대신 가능 하면 &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; 인프라를 사용하십시오 . 패키지가 특히 복잡하거나 많은 구성이 필요한 경우 저수준 메커니즘으로 돌아 가야 할 수 있으므로 용감한 영혼을위한 몇 가지 힌트가 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">우리는 일상 업무에 &lt;code&gt;-O*&lt;/code&gt; 플래그를 사용하지 않습니다 . 우리는 &lt;code&gt;-O&lt;/code&gt; 를 사용 하여 적절한 속도를 얻습니다. 예를 들어, 무언가를 측정하고 싶을 때. 우리는 파산을 원할 때 &lt;code&gt;-O2&lt;/code&gt; 를 사용하는 경향이 있습니다 (그리고 우리는 많은 커피 휴식을 취합니다).</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 수준의 숫자로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 레벨 기호로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">우리는 &lt;code&gt;_t1&lt;/code&gt; 썽크 만 평가 하여 목록의 머리를 드러 냈으며 꼬리는 이제 &lt;code&gt;_t2&lt;/code&gt; 에 바인딩 된 또 다른 썽크 입니다. &lt;code&gt;seq&lt;/code&gt; 기능을 사용할 수 있도록, 여기에 사용하기 조금 불편 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; (! 독자들에게 숙제로 남긴다) 더 좋은 인터페이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">현재 기능 번호를 찾아 C로 전달합니다.이 값은 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 로 다시 전달 되며 RTS가 &lt;code&gt;tryPutMVar&lt;/code&gt; 를 수행하려고 시도하는 기능을 알 수 있도록 도와줍니다 . 신경 쓰지 않으면 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 기능에 대해 &lt;code&gt;-1&lt;/code&gt; 을 전달 하면 임의의 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">우리는이 &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; , &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; , 그리고 &lt;code&gt;x :: b&lt;/code&gt; . 이것들을 사용하여, 우리는 어떻게 든 구멍을 (밑줄로 표시) &lt;code&gt;Int&lt;/code&gt; 유형의 값으로 채워야합니다 . 우리의 옵션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">우리는 GHC를 분기시키고 문제를 해결하는 것이이 컴파일 된 프로그램 이외의 다른 클래스의 프로그램을 발견 한 적이 없으며 모든 컴파일에 추가적인 오버 헤드를 부과합니다. 따라서 버그는 수정되지 않은 상태로 유지됩니다. &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;GHC 인라이너의 비밀&lt;/a&gt; 에는 더 많은 배경이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">우리는 이러한 종류를 유추합니다 :</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">내부적으로 테이블 내부의 셀을 유형의 객체로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">&lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트 로 새 샘플의 시작을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; 모드는 내부 UTF-16 인코딩을 통해 바이트를 왕복하는 바이트를 만들기 때문에 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 시퀀스 를 &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 로 인코딩 할 때 잘못된 문자를 감지하면 잘못된 문자를 표시해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">나중에이 기능의 구문과 의미를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 안정적인 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">앞서 언급 한 바와 같이 게으른 계산, 즉 썽 크는 생성 될 때 현재 스택을 캡처하고 평가 될 때이 스택을 복원합니다. 최상위 썽 크는 어떻습니까? 그것들은 프로그램이 컴파일 될 때&amp;ldquo;만들어집니다&amp;rdquo;. 그래서 우리는 어떤 스택을 주어야합니까? 최상위 썽크의 기술적 이름은 CAF (&amp;ldquo;일정 적용 신청서&amp;rdquo;)입니다. GHC는 모듈의 모든 CAF에 단일 비용 센터 &lt;code&gt;M.CAF&lt;/code&gt; 로 구성된 스택을 할당합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 모듈의 이름입니다. &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 각 CAF에 다른 스택을 제공 할 수도 있습니다 . &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 로&lt;/a&gt; 컴파일 할 때 특히 유용합니다 ( &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 의&lt;/a&gt; 기본값과 같이).기능 체의 상수가 최상위 수준으로 상승하여 CAF가됨에 따라) 이러한 CAF가 무엇에 해당하는지 판별 하려면 코어 ( &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; )&lt;/a&gt; 를 참조해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알 수 있습니다 . 따라서 (B)는 부분 성이 없으며 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며 GHC는 실제로 함수가 절대 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">이제 실제 &lt;code&gt;encode&lt;/code&gt; 함수에 대해 &lt;code&gt;Encode&lt;/code&gt; 클래스를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">이제 hpc의 주요 모드에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">우리는 원래 표현의 자유 변수가 아닌 범위 내의 모든 변수에 대한 바인딩을 제공했지만 이것이 성능에 상당한 영향을 미치기 때문에 자유 변수에 대한 현재 제한 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 에 대한 참조를 &lt;code&gt;hs_init()&lt;/code&gt; 전달하여 RTS에 대한 인수 ( &lt;code&gt;+RTS...-RTS&lt;/code&gt; 사이의 인수)를 분리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">파일을 찾을 수 없거나 읽기에 실패하면 종료합니다. (대구 또는 다른 고객을위한 편의 루틴)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt; 플래그 와 병렬로 실행되도록 작성된 코드를 컴파일하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">표준 Windows 콘솔에서 GHCi를 실행하는 것이 좋습니다 . GHC 설치 프로그램이 추가 한 시작 메뉴 항목에서 &lt;code&gt;GHCi&lt;/code&gt; 옵션을 선택 하거나 &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; 를 사용하여 Windows 콘솔을 가져 &lt;code&gt;ghci&lt;/code&gt; 를 호출 하십시오 . 당신의 &lt;code&gt;PATH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">분기를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록으로 나타내 므로 버전 3.2.1은 [3,2,1]이됩니다. 사전 순서 (즉, &lt;code&gt;[Int]&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 기본 인스턴스 )는 분기의 자연스러운 순서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">서명이 기본 방법에만 적용됨을 알리기 위해 &lt;code&gt;default&lt;/code&gt; 키워드를 재사용합니다 . 의 인스턴스를 정의 할 때 &lt;code&gt;Enum&lt;/code&gt; 클래스가 원래 형 &lt;code&gt;[a]&lt;/code&gt; 의 &lt;code&gt;enum&lt;/code&gt; 여전히 적용된다. 그러나 빈 인스턴스를 제공 할 때 기본 구현 &lt;code&gt;(map to genum)&lt;/code&gt; 이 채워지고 유형 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 유형 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">바운드 검사가 융합되도록 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; 의 연속 사용을 다시 작성합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">GHC에 대한 다음 메일 링리스트를 운영합니다. 적절하다고 생각되면 가입하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;f&lt;/code&gt; 의 타입 변수 가 &lt;em&gt;지정&lt;/em&gt; 되고 &lt;code&gt;g&lt;/code&gt; 의 변수 는 &lt;em&gt;유추&lt;/em&gt; 된다고 말합니다 . 일반적인 규칙은 다음과 같습니다. 사용자가 소스 프로그램에서 유형 변수를 작성한 경우 &lt;em&gt;지정됩니다&lt;/em&gt; . 그렇지 않은 경우 &lt;em&gt;추론됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 중단 점을 설정 하고 호출합니다.</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">항목 개수도 공유 메모리에 저장되고 여러 코어에서 지속적으로 업데이트하기 때문에 여러 코어에서 프로파일 링 할 프로그램을 컴파일 할 때 &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">그런 다음 새로운 Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;Danger&lt;/code&gt; 플러그인 을 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">우리는 &lt;code&gt;class&lt;/code&gt; 를 확장해야 합니다 (경고 : 이것은 다소 혼란스럽지 않은 비 터미널 기호입니다), 즉 인스턴스 선언에 나타날 수있는 두 가지 추가 양식</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">기본 서명을 사용하여 GHC ( &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍&lt;/a&gt; )의 일반 프로그래밍 을 단순화 합니다.</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">우리는 &lt;code&gt;criterion&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt; )를 사용하여 다음 표에서 인코딩 기능의 효율성을 벤치마킹합니다.</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">연속 &lt;code&gt;f0&lt;/code&gt; 을 사용하여 두 번째 패킷을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 줄여 읽기 를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">차라리 버그와 같은 동작을보고하여 수정을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">우리는 &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; ; 나머지 코드는 FFI 표준을 지원하는 Haskell 구현에서 이식 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">약한 포인터는 캐시 및 메모 테이블에 특히 유용합니다. 메모 테이블을 작성하려면 함수 인수 (키)에서 결과 (값)로 데이터 구조 맵핑을 빌드하십시오. 함수를 새 인수에 적용하면 먼저 키 / 값 쌍이 이미 메모 테이블에 있는지 확인하십시오. 요점은 메모 테이블 자체가 키와 값을 유지하지 않아야한다는 것입니다. 따라서 테이블에는 일반적인 포인터가 아닌 키에 대한 약한 포인터가 포함되어야합니다. 값에 대한 유일한 참조는 실제로 메모 테이블에서 올 수 있으므로 값에 대한 포인터는 약해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">약한 포인터.</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">ThreadId에 대한 약한 참조</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">GHC 사용자 안내서에 오신 것을 환영합니다</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">재귀 함수와 상호 재귀 함수 그룹은 어떻습니까? 비용은 어디에서 발생합니까? GHC는 서로 호출하는 함수 그룹에 대한 정보를 재귀 적으로 유지하지만,이 정보는 기본 시간 및 할당 프로파일에 표시되지 않고 대신 다음과 같이 콜 그래프가 트리로 표시됩니다. 현재 스택의 다른 곳에서 발생하면 스택의 다른 항목을 푸시하지 않고이 호출에 대한 비용이 호출자에 집계됩니다 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">원래 정의에서 발생한 모호성 문제는 어떻습니까? 빈 함수에는 여전히 &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; 유형이 있지만 더 이상 모호한 유형으로 간주 할 필요가 없습니다. 변수 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나지 않지만 &lt;code&gt;Collects&lt;/code&gt; 클래스에 대한 종속성 은 우리에게 알려줍니다 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나는 &lt;code&gt;ce&lt;/code&gt; 에 의해 고유하게 결정됩니다 . 따라서 empty가 사용되는 컨텍스트는 &lt;code&gt;ce&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 모두에 대한 유형을 결정하기에 충분한 정보를 제공 할 수 있습니다모호함이 없습니다. 보다 일반적으로, 오른쪽의 변수에 의해 (직접 또는 간접적으로) 고유하게 결정되지 않은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 왼쪽에 변수가 포함 된 경우에만 유형을 모호한 것으로 간주하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">무엇 실제로 일어나는 일은 GHCi는 표현을 typechecks 것을, 그리고 그것이이없는 경우 &lt;code&gt;IO&lt;/code&gt; 의 유형을 다음과 같이 다음 그것을 변환 : 표현의 &lt;code&gt;e&lt;/code&gt; 로 변신</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 타입의 값으로 무엇을 할 수 있습니까? 특히 &lt;code&gt;MkFoo&lt;/code&gt; 에서 패턴 일치를 하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">x에 대한 명시 적 유형을 &quot;제공&quot;한다는 것은 무엇을 의미합니까? 패턴 유형 서명 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt; )을 사용하여 x에 대한 유형 서명을 직접 제공하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">안전하다는 것은 무엇을 의미합니까? &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈을 가져와도 모듈 을 가져 오지 않고 잘 컴파일되는 코드의 의미를 변경해서는 안됩니다. &lt;em&gt;시맨틱 일관성&lt;/em&gt; 이라고 알려진 Safe Haskell 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">유형 생성자에 대해&amp;ldquo;완전한 사용자 제공 종류 서명&amp;rdquo;으로 간주되는 것은 무엇입니까? 다음과 같은 형태입니다.</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">&lt;em&gt;실존 적&lt;/em&gt; 정량화 와 어떤 관련이 있습니까? 간단히 &lt;code&gt;MkFoo&lt;/code&gt; 는 (거의) 동형 형태 를가 집니다</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">유형 생성자 (예 : &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; )를 포괄하는 일반 클래스를 정의하려면 어떻게해야 합니까?</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">결과 유형 에서이 &quot; &lt;code&gt;a&lt;/code&gt; &quot; 는 무엇입니까 ? 분명히 우리는 이것을 의미하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">어떤 종류의 접속인가</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">주어진 유형 매개 변수의 역할은 무엇입니까? GHC는 역할 유추를 수행하여 모든 매개 변수에 대한 올바른 역할을 결정합니다. 몇 가지 기본 사실로 시작합니다. &lt;code&gt;(-&amp;gt;)&lt;/code&gt; 에는 두 가지 표현 매개 변수가 있습니다. &lt;code&gt;(~)&lt;/code&gt; 두 개의 공칭 매개 변수가 있습니다. 모든 유형 패밀리의 매개 변수는 공칭입니다. 모든 GADT와 유사한 매개 변수는 공칭입니다. 그런 다음 이러한 사실이 이러한 유형이 사용되는 모든 장소로 전파됩니다. 데이터 유형 및 동의어의 기본 역할은 팬텀입니다. 클래스의 기본 역할은 명목입니다. 따라서 데이터 유형 및 동의어의 경우 오른쪽에서 사용되지 않거나 팬텀 위치의 다른 유형에서만 사용되는 모든 매개 변수는 팬텀이됩니다. 매개 변수가 표현 위치에서 사용될 때마다 (즉, 해당 변수가 역할 표현 인 생성자에 대한 유형 인수로 사용되는 경우), 우리는 그 역할을 팬텀에서 표현으로 올립니다. 마찬가지로 매개 변수를 공칭 위치에 사용하면 해당 역할이 공칭으로 업그레이드됩니다. 우리는 역할을 명목에서 팬텀 또는 표현으로, 또는 표현에서 팬텀으로 다운 그레이드하지 않습니다.이러한 방식으로 각 매개 변수에 대해 가장 일반적인 역할을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; 의 역할 은 무엇입니까 ? 처음에는 홍당무가 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 역할을 나타내는 것처럼 보 였는데, 둘 다 오른쪽에 사용되며 유형 패밀리에는 관여하지 않기 때문입니다. 그러나 다음 예제와 같이 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCi는 무엇을해야합니까? 엄밀히 말하면, 프로그램은 모호합니다. &lt;code&gt;show (reverse [])&lt;/code&gt; (여기서 GHCi가 계산 &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; 형식)는 Show a =&amp;gt; String 유형을 &lt;code&gt;a&lt;/code&gt; 표시 방법은 유형 a 에 따라 다릅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">단일 패턴 세트에 적용 되는 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 가있는 경우 어떻게 됩니까? 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">어떤 종류의 힙 프로필을 수집합니까?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskell 컴파일러가 올바르게 생성하는 것은 사용되는 백엔드 코드 생성기에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC 백엔드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">인스턴스를 파생시킬 때 사용자가 명시 적으로 요청하는 것.</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">이것이 우리가 할 수있는 것은 이기종 값을 조작하는 많은 함수와 함께 이기종 값을 패키징 한 다음 패키지 모음을 균일 한 방식으로 처리하는 것입니다. 이런 식으로 상당히 객체 지향 프로그래밍을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">마지막에해야 할 일.</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 이 아닌 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">에서 키 수행 할 작업 &lt;code&gt;m2&lt;/code&gt; 하지만 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">비 옵션에 따른 옵션으로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">텍스트로해야 할 일.</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">우리가 보여준 것은 어떤 &lt;code&gt;make&lt;/code&gt; 와도 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">어떤 다른 것은 우리가 지금 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 매개 변수 (그리고로 사용되는 매개 변수를 참조 &lt;code&gt;a&lt;/code&gt; ), 이름 어디서나 명시 적으로 언급되지 않는다; 우리는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;Tree a&lt;/code&gt; 의 재귀 적 사용을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">예외가 발생할 때 대상 스레드가 수행 한 작업은 손실되지 않습니다. 다른 스레드가 필요할 때까지 계산이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 모호한 필드는 오히려 최상위 레벨에보다, 그 데이터 타입의 일환으로 내 보내야합니다. 예를 들어 다음은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수가 explicily 같은 방식으로 관련 데이터 또는 형의 가족 인스턴스에 바인딩 할 수 있습니다 (같은 제한)와 같은 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 또는 &lt;a href=&quot;#type-instance-declarations&quot;&gt;유형의 인스턴스 선언&lt;/a&gt; . 예를 들어, 위의 내용을 적용하면 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 좌측에서 사용 유형 또는 종류의 변수를 명시 적으로 결합 될 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt; 활성화되어, GHC는 인쇄 &lt;code&gt;RuntimeRep&lt;/code&gt; 의 경솔-다형성 유형에 대한 유형의 변수를. 그렇지 않으면 GHC는이를 기본값으로 &lt;code&gt;LiftedRep&lt;/code&gt; 로 설정 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 사용 하면 명시 적 으로 수량화 된 유형 변수도 사용되지 않은 것으로 식별 될 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">때 &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; 활성화되어, 추정 변수는 중괄호로 인쇄됩니다. 따라서 이전 예제 의 데이터 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형은 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; . GHCi 세션에서이 동작을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 가 활성화되어 사용 &lt;code&gt;anyclass&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newytype&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">경우 &lt;code&gt;mappend x x = x&lt;/code&gt; ,이 정의가 바람직되어야 오히려 O (로그 N)에 비해 O (1)에 작동하기 때문에</target>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; 는 O (1)에서 작동하기 때문에,이 정의가 아닌 O (로그 n)이보다 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">GHC가 클래스에 대한 인스턴스를 찾을 수 없으면 알고있는 인스턴스에 일부의 짧은 목록을 표시합니다. 이 플래그를 사용하면 알고있는 &lt;em&gt;모든&lt;/em&gt; 인스턴스를 인쇄 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">GHC 가 &lt;code&gt;foreign export&lt;/code&gt; 또는 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 를 사용 하는 모듈 (예 : &lt;code&gt;M.hs&lt;/code&gt; )을 컴파일 할 때 C 프로그램에서 사용할 &lt;code&gt;M_stub.h&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">등록되지 않은 모드에서 GHC가 빌드되면 LLVM 및 C 코드 생성기 만 사용할 수 있습니다. 네이티브 코드 생성기는 그렇지 않습니다. LLVM은 일반적으로 미등록 모드에서 C 백엔드에 비해 상당한 성능 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">GHC를 사용하여 C 파일을 컴파일하는 경우 GHC는 패키지 포함 경로를 추가하고 &lt;code&gt;ghcversion.h&lt;/code&gt; 를 직접 포함 합니다. 컴파일러는 패키지 데이터베이스 의 &lt;code&gt;rts&lt;/code&gt; 패키지에서 &lt;code&gt;ghcversion.h&lt;/code&gt; 파일 의 경로를 찾습니다 . 경우에 따라 컴파일러의 패키지 데이터베이스에 &lt;code&gt;rts&lt;/code&gt; 패키지가 포함되어 있지 않거나 포함 할 특정 &lt;code&gt;ghcversions.h&lt;/code&gt; 를 지정하려고합니다 . 이 옵션을 사용하여 포함 할 &lt;code&gt;ghcversions.h&lt;/code&gt; 파일 의 경로를 지정할 수 있습니다. 이것은 주로 GHC의 빌드 시스템에서 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">GHC는 제약 조건 &lt;code&gt;C Int Bool&lt;/code&gt; 을 해결 하려고 할 때 인스턴스 선언의 헤드를 인스턴스화하여 모든 인스턴스 선언을 제약 조건과 일치시킵니다. 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">GHCi가 중단 점에서 중지되고 프롬프트에 입력 된 표현식이 두 번째 중단 점을 트리거하면 새 중단 점이 &quot;현재&quot;가되고 이전 중단 점이 스택에 저장됩니다. 이러한 방식으로 임의의 수의 중단 점 컨텍스트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">GC가 시작되면 실행중인 모든 뮤 테이터 스레드가 중지되고 동기화되어야합니다. GC가 시작되고 모든 뮤 테이터 스레드가 중지되는 시점을 GC 동기화 단계라고합니다. 이 단계가 오래 걸리는 경우 (1ms보다 긴 것이 긴 것으로 간주 됨) 전체 처리량에 심각한 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">GHC 컴파일 프로그램이 &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS 옵션 과 함께 실행되면 &lt;code&gt;prog.prof&lt;/code&gt; 라는 파일이 생성됩니다 . 이 경우 파일에는 다음과 같은 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">Bare 유형 변수 &lt;code&gt;a&lt;/code&gt; 가 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 각각 &lt;code&gt;fmap&lt;/code&gt; 및 &lt;code&gt;traverse&lt;/code&gt; 정의에 대해 &lt;code&gt;f a&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">특정 행과 열에 중단 점이 설정되면 GHCi는 중단 점을 설정할 위치를 포함하는 가장 작은 하위 표현식을 선택합니다. 참고 : GHC는 TAB 문자의 너비가 1 인 것으로 간주합니다. 즉, 열이 아닌 문자를 계산합니다. 이것은 일부 편집자가하는 것과 일치하고 다른 편집자와는 일치하지 않습니다. 최선의 조언은 소스 코드에서 탭 문자를 모두 사용하지 않는 것입니다 ( &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">특정 행에 중단 점이 설정되면 GHCi는 해당 행에서 시작하고 끝나는 가장 왼쪽의 하위 표현식에 중단 점을 설정합니다. 동일한 열에서 두 개의 완전한 하위 표현식이 시작되면 가장 긴 하위 표현식이 선택됩니다. 줄에 완전한 하위 표현식이 없으면 줄에서 시작하는 가장 왼쪽에있는 표현식이 선택되고 해당 줄을 부분적으로 또는 완전히 덮는 가장 오른쪽에있는 표현식이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">데이터 형식의 경우 &lt;code&gt;T&lt;/code&gt; 는 모든 생성자, 즉 함께 가져 &lt;code&gt;T(..)&lt;/code&gt; 하지만, 추상적 즉 내 보낸 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 될 수있는 오류 코드 목록은 기본 기능에 대한 POSIX 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">hs-boot 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 컴파일 될 때 범위 및 유형 오류가 있는지 확인합니다. 상위 모듈 &lt;code&gt;A.hs&lt;/code&gt; 가 컴파일 될 때 두 모듈 이 비교되고 두 모듈 이 일치하지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하여 조치를 생성하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 결과 조치를 수행하며 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">현재 컴파일중인 패키지 (예 : &quot;홈&quot;패키지)에서 제공 한 모듈을 가져 오지만 명령 줄에 대상으로 명시 적으로 나열되지 않은 경우 Cabal이 GHC가 &lt;code&gt;exposed-modules&lt;/code&gt; 이나 &lt;code&gt;other-modules&lt;/code&gt; 모듈 에 나열되지 않은 모듈을 픽업하지 않도록하는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">이름이나 패키지가 범위 내에 없으면 대신 의미가있는 이름이나 패키지를 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">겹치는 인스턴스로 인해 특정 유형 클래스 메서드 호출이 안전하지 않은 것으로 간주되고 컴파일되는 모듈이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 를 사용하면 컴파일이 실패합니다. 들면 &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; , 제한은 적용되지 않고, 안전한 사용을 추론 모듈, 이들은 안전하지 않은 추론한다.</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나 &lt;code&gt;main&lt;/code&gt; 함수는 인수를 직접 가져 가지 않으므로 ghci에서 테스트하는 동안 단순히 &lt;code&gt;main&lt;/code&gt; 함수에 인수를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나, 우리는 간단히에 인수를 전달할 수 없습니다 &lt;code&gt;main&lt;/code&gt; 우리가 ghci에서 테스트하는 동안 같은 기능 &lt;code&gt;main&lt;/code&gt; 기능은 직접하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">문자열이이 플래그에 전달되면 이름이 문자열과 접두사를 공유하는 모든 함수에 대한 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식에 생성자가없는 경우 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스는 &lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수의 (아래) 값을 강제로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 재귀 적으로 &lt;code&gt;foldr&lt;/code&gt; 및 &lt;code&gt;foldMap&lt;/code&gt; 을 호출 합니다. 컨텍스트에 따라 &lt;code&gt;null&lt;/code&gt; 은 재귀 적으로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;all null&lt;/code&gt; 을 호출 할 수 있습니다 . 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 재귀 적으로 &lt;code&gt;traverse&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">유형 레벨 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하면 언급 된 각 유형 / 종류 변수도 범위 내에 있거나 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 특히 Haskell의 다른 장소와 달리 자유 변수는 암시 적으로 바인딩되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; - notation 에 값이 바인딩되면 &lt;code&gt;&amp;lt;-&lt;/code&gt; 의 왼쪽에있는 패턴 이 일치하지 않을 수 있습니다. 이 경우이 클래스는 복구 할 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">경고가 발생하면이를 제어하는 ​​특정 경고 플래그가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">와일드 카드가 단일 유형으로 인스턴스화되지 않으면 일반 유형으로 일반화됩니다. 예를 들어 새로운 유형 변수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명령문이 내 보내지 않은 엔티티를 숨길 때</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">연관된 데이터 또는 유형 동의어 패밀리 인스턴스가 유형 클래스 인스턴스 내에 선언되면 선택적으로 패밀리 키워드에서 &lt;code&gt;instance&lt;/code&gt; 키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하는 경우, 아직 범위 내에 있지 않은 언급 된 모든 &lt;em&gt;유형&lt;/em&gt; 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 필요한 경우 종류 변수는 암시 적으로 바인딩됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 인스턴스가 정의 된 경우 유형 클래스에 의해 정의 된 비트 단위 연산은 C on &lt;code&gt;t&lt;/code&gt; 의 해당 비트 단위 연산과 동일한 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">인스턴스 때 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 정의되어 &lt;code&gt;CT&lt;/code&gt; 의 값 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 가 일치 &lt;code&gt;t_MIN&lt;/code&gt; 및 &lt;code&gt;t_MAX&lt;/code&gt; C.에서</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 인스턴스 가 정의 되면 유형 클래스에 의해 정의 된 술어는 &lt;code&gt;t&lt;/code&gt; 의 C에서 해당 술어와 동일한 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">인스턴스 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 가 정의되어 &lt;code&gt;CT&lt;/code&gt; , Type 클래스에 의해 정의 된 산술 연산은상의 C에 대응하는 연산과 동일한 기능 (있는 경우)를 구현 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">적용 가능한 경우 특정 병리학 적 경우에는 조금 더 나쁠 수 있지만이 기능 대신 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 거의 항상 좋습니다 . 예를 들어, 문자 목록을 마비 시키려면</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">소스 파일을 컴파일하라는 요청을 받으면 GHC는 일반적으로 객체 파일과 인터페이스 파일의 두 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">데이터베이스를 수정하라는 메시지가 표시되면 &lt;code&gt;ghc-pkg&lt;/code&gt; 는 기본적으로 전역 데이터베이스를 수정합니다. &lt;code&gt;--user&lt;/code&gt; 를 지정 하면 사용자 데이터베이스에서 작동하거나 &lt;code&gt;--package-db&lt;/code&gt; 를 사용하여 다른 데이터베이스에서 완전히 작동 할 수 있습니다. 이러한 옵션이 여러 개 제공되면 가장 오른쪽 옵션이 작동 할 데이터베이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">두 플래그가 제공되면 &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 대체 하고 &lt;code&gt;+&lt;/code&gt; 는 공백을 대체합니다. &lt;code&gt;*&lt;/code&gt; 변환 에서 음의 너비 지정자는 양수로 취급되지만 왼쪽 조정 플래그를 암시합니다.</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">바운드 유형 / 종류 변수가 필요한 경우 두 변수를 모두 포함해야하지만 패턴 변수가 필요하지 않은 경우 두 번째 변수를 비워 둘 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">패키지를 공유 라이브러리로 빌드 할 때 GHC를 사용하여 링크 단계를 수행 할 수 있습니다. 기본 링커에서 일부 세부 정보를 숨기고 GHC (DLL, ELF DSO 및 Mac OS dylib)에서 지원하는 모든 공유 객체 변형에 대한 공통 인터페이스를 제공합니다. 공유 객체는 다음 두 가지 이유로 특정 방식으로 이름을 지정해야합니다. (1) 이름에 GHC 컴파일러 버전이 포함되어 있어야합니다. 따라서 두 버전의 라이브러리 변형이 서로 다른 버전의 GHC에 의해 컴파일되어 충돌 할 가능성이 거의 없습니다. 호출 규칙과 관련하여 (2) 정적 이름과 달라야합니다. 그렇지 않으면 &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그를 작동 시키는 데 필요한만큼 정확하게 링커를 제어 할 수 없습니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;연결에 영향을주는 옵션&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">호출시 &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; 가 인쇄 ⟨n⟩ &lt;sup&gt;번째&lt;/sup&gt; 행 ⟨m⟩ &lt;sup&gt;번째&lt;/sup&gt; ⟨type⟩ 붙이고 완료 도메인 부분 입력 ⟨string-literal⟩ 수료 후보. 현재 는 입력 프롬프트에서 GHCi가 대화식으로 제공 할 수있는 완료 종류를 나타내는 &lt;code&gt;repl&lt;/code&gt; 도메인 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 변환 할 때 &lt;code&gt;map toUpper&lt;/code&gt; 와 같은 결합 자를 사용하여 문자열의 각 문자를 개별적으로 변환 할 수 없습니다 . 일부 쓰기 시스템의 규칙에 따라 잘못된 결과가 발생하기 때문입니다. &lt;code&gt;toUpper&lt;/code&gt; 와 같은이 모듈의 전체 문자열 대 / 소문자 변환 함수 는 올바른 대 / 소문자 변환 규칙을 따릅니다. 결과적으로,이 기능들은 하나의 입력 문자를 두세 개의 출력 문자에 매핑 할 수 있습니다. 예를 들어, 각 기능의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">폐쇄 형 패밀리 방정식 쌍을 확인할 때 GHC는 RHS를 통합하려고했습니다. 그들이이 방정식 쌍을 통일하지 않으면 주입 주석을 위반하지 않습니다. RHS가 일부 치환 (통화 될 수 있음) 하에서 통일 될 수있는 경우, LHS가 동일한 치환 하에서 통일되거나 후자의 식의 LHS가 이전 식에 포함됩니다. 두 조건이 모두 충족되지 않으면 GHC는 유형 패밀리가 주입 적이 지 않다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 템플릿 Haskell 코드 를 컴파일 할 때 인터프리터에서 프로파일 링 된 객체 코드를 실행할 수 있으므로 먼저 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 없이 모듈을 컴파일 할 필요가 없습니다 ( &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;프로파일 링에 템플릿 Haskell 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 때 ⟨n⟩ 모듈을 병렬로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">Haskell 패키지에 대한 공유 객체를 생성 할 때 GHC가이 패키지에 대해 링크 될 때 공유 객체를 인식 할 수 있도록 공유 객체의 이름을 올바르게 지정해야합니다. 공유 객체 이름 맹 글링을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">이것이 올바른 데이터 구조인지를 결정할 때 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">GHCi 매크로를 정의 할 때, 특히 탭 완성과 관련하여 이름이 내장 명령과 충돌 할 수있는 경우에주의해야 할 중요한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">Haskell에 포함 된 도메인 특정 언어를 디자인 할 때 유형 수준에서 &lt;code&gt;error&lt;/code&gt; 와 같은 것이 유용 합니다. 이러한 방식으로, EDSL 설계자는 표준 GHC 유형 에러가 아니라 DSL에 특정한 타입 에러를 보여줄 수있다.</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">리스트로 표기하면 desugaring &lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt; GHC가 사용 &lt;code&gt;fromList&lt;/code&gt; 모듈로부터 (등) 방법 &lt;code&gt;GHC.Exts&lt;/code&gt; 를 . &lt;code&gt;GHC.Exts&lt;/code&gt; 를 가져올 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">그렇게 할 때, 선택적으로&amp;ldquo; &lt;code&gt;family&lt;/code&gt; &amp;rdquo;키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">사용 가능한 경우 GHC는 &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">활성화 된 경우 GHC는 유형 검사기에서 추가 정보를 경고로 인쇄합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">활성화되면 GHC는 형식 동의어 확장 형식을 형식 오류로 인쇄합니다. 예를 들어이 형식 동의어를 사용하면</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">활성화 된 경우, 신뢰할 수있는 모듈에 대한 추가 검사를 켜 &lt;code&gt;M&lt;/code&gt; 있는 패키지를 요구, &lt;code&gt;M&lt;/code&gt; 에 대한 고려에 상주 신뢰할 수있는 &lt;code&gt;M&lt;/code&gt; 이 신뢰할 고려되어야합니다.</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드를 생성 할 때 다른 모듈에서 가져온 엔티티가 동적으로 링크 될 수 있다고 가정하십시오. 이 플래그는 &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">여러 소스의 패키지를 통합 할 때 여러 패키지가 동일한 이름의 모듈을 게시하는 상황이 발생할 수 있습니다. 이전에는 이러한 모듈을 구별 할 수있는 유일한 방법은 &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt; 를 사용하는 것 입니다. 그러나 GHC 7.10부터 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 플래그 (및 해당 변형)가 확장되어 사용자가 모듈 가져 오기에 첨부 할 수있는 가져 오기 목록과 유사하게 패키지가 범위에 포함되는 모듈을 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수를 사용하면 마스크 된 비동기 예외 (있는 경우)가 발생할 수 있습니다. 인터럽트 가능한 작업을 수행하는 것과 같지만 (#interruptible 참조) 실제 차단은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 호출되면 런타임은 비용 중심 프로파일을 기계가 읽을 수있는 JSON 형식으로 생성합니다. 이 형식의 최상위 개체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">&lt;code&gt;-g&lt;/code&gt; 플래그 와 함께 호출되면 GHC는 표준 &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; 디버깅 정보를 생성 합니다. 이 형식은 거의 모든 POSIX 호환 대상에서 사용되며 디버깅 및 성능 도구 (예 : &lt;code&gt;gdb&lt;/code&gt; , &lt;code&gt;lldb&lt;/code&gt; 및 &lt;code&gt;perf&lt;/code&gt; )에서 GHC 컴파일 프로그램의 구조를 이해하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">시작시 &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt; 플래그를 지정 하지 않으면 GHCi 는 다음 파일에서 명령을 읽고 실행합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">GHC는 유형을 종류 검사 할 때 유형의 종류를 일반화하는 방법을 알아낼 때 해당 유형으로 작성된 내용 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">바이너리 실행 파일이 삽입 플래그 연결하지 않을 때 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 어떤 전에 &lt;code&gt;-l&lt;/code&gt; 하스켈 라이브러리에 대한 플래그를, 그리고 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 이후</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">바이너리 실행 파일을 링크 할 때,이 삽입 플래그 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 어떤 전에 &lt;code&gt;-l&lt;/code&gt; 하스켈 라이브러리에 대한 플래그 및 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; OS X에 (이후, 플래그가 없습니다 &lt;code&gt;-Wl,-all_load&lt;/code&gt; 에는 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 와 동등한 항목이 없습니다 . 이 플래그는 또한 &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; ( OS X의 경우 -Wl, -dead_strip )를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">최종 프로그램을 링크 할 때 GHC를 사용하여 링크를 수행하는 것이 일반적으로 가장 쉬운 방법이지만 필수는 아닙니다. GHC를 사용하는 경우 플래그 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; 을&lt;/a&gt; 잊지 마십시오 . 그렇지 않으면 GHC가 &lt;code&gt;Main&lt;/code&gt; Haskell 모듈에 연결을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결시 링커는 참조되지 않은 모든 섹션을 자동으로 제거하여 더 작은 실행 파일을 생성 할 수 있습니다. 효과는 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 다소 더 효율적입니다. 생성 된 라이브러리 파일은 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 보다 약 30 % 작습니다 .</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">로드 균형 조정시 스레드를 동일한 노드의 다른 기능으로 마이그레이션하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 를 사용&lt;/a&gt; 하여 소스 모듈을로드 할 때 GHCi는 일반적으로 컴파일 된 해당 객체 파일을 찾고 가능한 경우 소스를 해석하기 위해 우선적으로 파일을 사용합니다. 예를 들어, 모듈 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 로 구성된 4 모듈 프로그램이 있다고 가정하십시오 . 모듈 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 모두 가져 &lt;code&gt;D&lt;/code&gt; 만하고 수입 모두 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">프로그램 실행을위한 프로파일을 볼 때 종종 실행에서 특정 지점이나 단계를 표시하고 프로파일에서 시각적으로 볼 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">일치하는 경우 GHC는 인스턴스 선언의 컨텍스트 ( &lt;code&gt;context1&lt;/code&gt; 등)를 고려하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">클래스 선언을 병합 할 때 수퍼 클래스와 메소드가 정확히 일치해야합니다. 그러나 &lt;code&gt;MINIMAL&lt;/code&gt; pragma는 논리적으로 함께 OR되며 기본 서명이있는 메소드는 그렇지 않은 메소드와 성공적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">cfg 기반 blocklayout 레이아웃을 사용하지 않는 경우 기본 블록의 마지막 점프 또는 cfg에서 블록의 가장 큰 나가는 모서리에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">과부하가 관련되면 결과가 약간 직관적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">패턴 일치시 각 패턴 일치는 각 존재 유형 변수에 대해 새롭고 고유 한 유형을 도입합니다. 이러한 유형은 다른 유형과 통합 할 수 없으며 패턴 일치 범위에서 벗어날 수도 없습니다. 예를 들어, 이러한 조각은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">패턴 일치시 이러한 제한 조건은 일치 본문에서 제한 조건을 해제하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 표현과 같이 GADT에서 가져온 데이터 생성자와 패턴 일치하는 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">레코드 구성에 레코드 와일드 카드를 사용하는 경우 &lt;code&gt;f&lt;/code&gt; 가 범위 내에 있고 최상위 레벨에서 가져 오거나 바인드되지 않은 경우에만 필드 &lt;code&gt;f&lt;/code&gt; 가 초기화됩니다 . 예를 들어, &lt;code&gt;f&lt;/code&gt; 는 둘러싸는 패턴 일치 또는 let / where-binding에 의해 바인딩 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">입력 된 구멍을보고 할 때 범위 내에있는 구속 조건도 인쇄하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">프로그램에 &lt;code&gt;-hr&lt;/code&gt; 옵션 을 제공하여 보유자 프로파일 링을 요청하면 보유자 세트별로 분류 된 그래프가 생성됩니다. 리테이너 세트는 비용 중심 스택 세트로 표시됩니다. 이는 일반적으로 프로파일 그래프에 맞추기에는 너무 커서 각 보유자 세트의 번호가 매겨지고 그래프에 약어로 표시되며 보유자 세트의 전체 목록이 &lt;code&gt;prog.prof&lt;/code&gt; 파일에 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">대화식 콘솔 프로세스 (예 : 셸, 콘솔 기반 텍스트 편집기 또는 ghci)를 실행할 때 일반적으로 해당 프로세스가 Ctl-C 키보드 인터럽트를 처리하는 방법을 처리 할 수 ​​있기를 원합니다. 예를 들어, 대부분의 프로그램은 단순히 Ctl-C를 종료하지만 일부는 특수하게 처리합니다. 이를 가능하게하려면 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 옵션에서 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">이 파일에서 언어 옵션을 설정할 때 일반적으로 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 ( &lt;a href=&quot;#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">Safe Haskell 추론은 언제 사용해야하며 명시적인 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그 는 언제 사용해야 합니까? 후자의 경우는 모듈이 안전해야한다는 어려운 요구 사항이있을 때 사용해야합니다. &lt;a href=&quot;#safe-use-cases&quot;&gt;Safe Haskell&lt;/a&gt; 의 Safe Haskell 사용 : 신뢰할 수없는 코드 실행에 가장 유용 합니다. 안전한 추론은 일반 Haskell 프로그래머가 사용해야합니다. Safe Haskell에 관심이없는 사용자</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">경고를 제어하는 ​​플래그를 표시 할 때 경고가 포함 된 각 경고 그룹 플래그도 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">제약 조건을 해결할 때 사용 가능한 사전을 사용하여 수퍼 클래스를 열심히 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; pragma를 지정할 때 모든 패턴의 결과 유형이 서로 일치해야합니다. 유형이 일치하지 않으면 모든 패턴에서 일치하는 것이 불가능하므로 이는 완전성 점검입니다.</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">중단 점 또는 단일 단계에서 중지되면 GHCi는 변수 &lt;code&gt;_result&lt;/code&gt; 를 현재 활성 표현식의 값에 바인드합니다 . 평가를 중단했기 때문에 &lt;code&gt;_result&lt;/code&gt; 의 값은 아직 사용할 수 없지만 아마도 강제 될 수 있습니다. 유형이 알려지고 표시 가능한 경우 프롬프트에서 &lt;code&gt;_result&lt;/code&gt; 를 입력 하면 표시됩니다. 그러나이 작업을 수행 할 때 한 가지주의 할 사항이 있습니다. &lt;code&gt;_result&lt;/code&gt; 를 평가 하면 현재 중단 된 중단 점부터 시작하여 추가 중단 점을 트리거 할 가능성이 높습니다 ( &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; 아닌 실제 중단 점에서 중단 된 경우 ). 따라서 &lt;code&gt;_result&lt;/code&gt; 를 평가할 때 &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; 를&lt;/a&gt; 즉시 발행해야합니다 .. 또는 중단 점을 무시 하는 &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">중단 점에서 중지했을 때 이미 평가중인 변수를 평가하려고하면 두 번째 평가가 중단됩니다. 그 이유는 GHC가 변수가 평가 중이라는 것을 알고 있기 때문에 새로운 평가는 계속하기 전에 결과를 기다리지 만 첫 번째 평가가 중단 점에서 중단되기 때문에 발생하지 않습니다. Control-C는 중단 된 평가를 중단하고 프롬프트로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어, 모듈이 신뢰 여부를 특정 패키지가 신뢰할 수있는 경우에 따라 달라집니다. 패키지 신뢰는 GHC를 호출하는 클라이언트 C (즉, 귀하)에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 사용되는 &lt;em&gt;패키지 P에서 모듈 M을 클라이언트 C 신뢰&lt;/em&gt; 의 경우 만</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">때 &lt;code&gt;*&lt;/code&gt; 가 사용되고, GHCi는 미리 컴파일 된 오브젝트 코드를 해석하는 모듈을 무시한다. 이미 많은 수의 모듈을 객체 코드로로드하고 전체 모듈을 다시로드하는 대신 모듈 중 하나를 해석하려는 경우 &lt;code&gt;:add *M&lt;/code&gt; 을 사용하여 &lt;code&gt;M&lt;/code&gt; 을 해석 하도록 지정할 수 있습니다 ( 컴파일 된 모듈은 해석 된 모듈에 의존 할 수 없기 때문에 다른 모듈도 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">때 &lt;code&gt;GADTSyntax&lt;/code&gt; 의 확장이 활성화되어, GHC는 명시 적으로 생성자의 유형 서명을함으로써 대수 데이터 형식을 선언 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">때 &lt;code&gt;OverloadedLists&lt;/code&gt; 의 확장이 설정되어 다음과 같이 언급 한 일곱 표기법 desugared 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">컴파일러 유형이 소스 코드를 확인하면 &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices 및 &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; 은 소스 코드에서 생성 된 구문 트리 조각으로 대체됩니다. 그러나 소스 코드에서 작동하는 도구의 경우 코드 생성기는 일반적으로 생성 된 코드보다 더 흥미 롭습니다. 이러한 이유로 &lt;code&gt;spliceRunAction&lt;/code&gt; 을 포함 시켰 습니다 . 이 필드는 평가되기 전에 각 표현식에서 호출됩니다. 입력은 유형 검사되므로 이러한 구문 트리 조각에 대한 의미 정보가 사용 가능합니다. 다른 식을 반환하면 생성 된 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">플래그 경우 &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; 내지 An 설정된 &lt;code&gt;n&lt;/code&gt; 보다 큰 &lt;code&gt;0&lt;/code&gt; , GHC는 최대 필요한 유효 정공 적합하다 유효한 정제 정공 맞는 목록까지 제공한다 &lt;code&gt;n&lt;/code&gt; 추가적인 정교화 레벨 각 레벨은 구멍이 뚫려있는 구멍을 추가로 채워야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그 가 활성화되면 왼쪽 패턴에서 언급되었지만 오른쪽에서는 사용되지 않은 유형 변수가보고됩니다. 왼쪽에서 여러 번 발생하는 변수도 사용 된 것으로 간주됩니다. 경고를 표시하지 않으려면 사용하지 않는 변수를 밑줄로 바꾸거나 접두사를 붙여야합니다. 밑줄 ( &lt;code&gt;_x&lt;/code&gt; )로 시작하는 유형 변수 는 일반 유형 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">마지막 유형 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) 일반적인 알고리즘을 사용하여 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 생성되지 않습니다. 대신 전체 가치가 강요됩니다.</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">데이터 또는 형식 인스턴스 선언의 형식 인수 이름이 중요하지 않은 경우 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 와 링크되면 여러 OS 스레드에서 동시에 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출 할 수 있습니다 . 런타임 시스템은 &lt;code&gt;hs_init()&lt;/code&gt; 를 호출하여 평상시와 같이 초기화해야하며 ,이 호출은 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출하기 전에 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; 옵션 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )으로 링크 되면 런타임 이벤트는 여러 가지 방법으로 로그 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">세분화 수준을 설정하지 않으면 유효한 구멍 맞춤 제안 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 표현식 의 명령문 사이에 종속성이 있고 &lt;code&gt;ApplicativeDo&lt;/code&gt; 가 &lt;code&gt;Applicative&lt;/code&gt; 유형을 유추 할 수없는 경우 휴리스틱 알고리즘을 사용하여 가능한 한 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하려고 합니다. 이 알고리즘은 일반적으로 최상의 솔루션을 찾지 만 드문 복잡한 경우에는 기회를 놓칠 수 있습니다. 옵션으로 제공되는 최적의 솔루션을 찾는 알고리즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">형식에 생성자가 없으면 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 가능한 가장 느린 인스턴스를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 간단한 인스턴스를 파생합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 이&lt;/a&gt; 해당 인수를 강제합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">사용자가 쓸 때</target>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">일련의 명령문에서 엄격한 패턴 일치가있는 경우 &lt;code&gt;ApplicativeDo&lt;/code&gt; 는 해당 명령문과 그 뒤에 오는 명령문 사이에 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 를 배치 합니다. 시퀀스는 다른 곳에서 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하도록 변환 될 수 있지만 표준 패턴 표기법과 동일한 엄격 의미론을 유지하기 위해 엄격한 패턴 일치 및 다음 명령문은 항상 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 와 연결 됩니다. 이것을 원하지 않으면 단순히 패턴 일치에 &lt;code&gt;~&lt;/code&gt; 를 붙이면 게으르게됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">이 플래그가 활성화되고 &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt; 가 비활성화되면 블록 레이아웃은 8.6 이전 버전과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">이 플래그가 설정되면, 변수는 &lt;code&gt;it&lt;/code&gt; 더 이상 이전에 평가 식의 결과로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">이 최적화가 활성화되면 코드 생성기는 모든 자체 재귀 포화 테일 호출을 함수 호출이 아닌 로컬 점프로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 활성화되면, 기능 \ (i \)에 대한 OS 스레드는 스레드 선호도를 설정하기 위해 OS에서 제공하는 API를 사용하여 CPU 코어 \ (i \)에 바인딩됩니다. 예를 들어 Linux GHC에서는 &lt;code&gt;sched_setaffinity()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">이 옵션을 지정하면 중간 부동 소수점 값 이 최종 유형 &lt;em&gt;보다&lt;/em&gt; 정밀도 / 범위가 &lt;em&gt;더 클&lt;/em&gt; 수 있습니다 . 일반적으로 이것은 좋지만 일부 프로그램은 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 값 의 정확한 정밀도 / 범위에 의존 할 수 있으므로 컴파일에이 옵션을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">이 경고가 활성화되면 다음 조건이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">전원을 &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt; 하여 모듈별로 억제 할 수 있습니다 . 간혹 API를 변경하지 않고 구현을 변경할 수있는 공간을 남기기 위해 함수가 필요 이상으로 제한적인 서명을 갖기를 원할 수 있습니다. 이 경우 데드 바인딩의 호출을 사용하여 기능별로 경고를 표시하지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">모듈을 타입 검사 할 때, GHC는 제약 해결이 시작되기 전에 &lt;code&gt;tcPluginInit&lt;/code&gt; 를 한 번 호출 합니다. 이를 통해 플러그인은 컨텍스트에서 사물을 찾거나 변경 가능한 상태를 초기화하거나 외부 프로세스 (예 : 외부 SMT 솔버)에 대한 연결을 열 수 있습니다. 플러그인은 원하는 모든 유형의 결과를 반환 할 수 있으며 결과는 다른 두 필드로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">유형의 인스턴스 선언에 의하면 &lt;code&gt;F a&lt;/code&gt; , 우리는 슈퍼 클래스의 것을 확인해야 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;F&lt;/code&gt; 가 보유하고 있습니다. 따라서 다음을 포함하는 이론 하에서 제약 조건 &lt;code&gt;C a&lt;/code&gt; 를 수반하려고한다 .</target>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">safe 키워드를 사용하여 가져올 모듈을 사용하는 경우 신뢰할 수있는 모듈이어야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 안전한 가져 오기 확장은 &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; 또는 &lt;code&gt;-XUnsafe&lt;/code&gt; 플래그 중 하나에 의해 사용 가능 합니다. 때 &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하는 경우, &lt;code&gt;safe&lt;/code&gt; 모든 가져 오기가 안전한 수입으로 처리됩니다 같은 키워드는 허용하지만 의미한다.</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; A의 (해시 기호의 메이크업에 사용하는 등 확장) &lt;code&gt;.hsc&lt;/code&gt; 의 파일 (참조 &lt;a href=&quot;utils#hsc2hs&quot;&gt;C 코드 작성 하스켈 인터페이스 : hsc2hs을&lt;/a&gt; ), 해시 표지판 (쓰기 배가해야 &lt;code&gt;##foo&lt;/code&gt; 는 대신 &lt;code&gt;#foo&lt;/code&gt; 을 피하기 위해를) &lt;code&gt;hsc2hs&lt;/code&gt; 지시어 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">&lt;code&gt;-dynamic-too&lt;/code&gt; 를 사용할 때 &lt;code&gt;-dyno&lt;/code&gt; , &lt;code&gt;-dynosuf&lt;/code&gt; 및 &lt;code&gt;-dynhisuf&lt;/code&gt; 옵션 은 각각 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-osuf&lt;/code&gt; 및 &lt;code&gt;-hisuf&lt;/code&gt; 의 대응 항목 이지만 동적 컴파일에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">&lt;code&gt;capi&lt;/code&gt; 를 사용하면 함수가 아닌 값을 가져올 수도 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 를 사용할 때 일반적인 경험 규칙은 나중에 스파크 계산이 필요하지만 너무 빠르지는 않다는 것입니다. 또한 스파크 계산은 너무 작아서는 안됩니다. 그렇지 않으면 병렬로 계산하는 비용이 병렬 처리량에 비해 너무 클 것입니다. 이러한 요소를 올바르게 얻는 것은 실제로 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 입력 문자 바로 다음에 사용 가능한 경우 개행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 문자를 읽기 전에 &lt;code&gt;EOF&lt;/code&gt; 가 발생 하면 이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때이 기능은 입력 라인을 읽는 동안 에코를 끕니다.</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">레코드를 사용할 때는 다음과 같이 레코드 필드와 이름이 같은 변수를 바인딩하는 패턴을 작성하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">터미널 스타일의 상호 작용을 사용할 때 줄 바꿈을 기다리지 않고 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">터미널 스타일 상호 작용을 사용할 때 입력 텍스트가 비어있을 때 사용자가 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 누르면 이러한 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">그러나 다른 시스템에서 실행중인 다른 프로세스간에 값이 전달되면 각 프로세스가 다른 주소를 사용하여 지정된 값을 저장할 수 있으므로 주소가 더 이상 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">나중에 렌더링 할 때이 셀이 몇 개의 열 또는 행에 걸쳐 있는지 확인하고 올바른 colspan / rowspan 명령을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 레이블을 작성할 때 해시 부호와 다음 식별자 사이에 공백이 없어야합니다. &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 의&lt;/a&gt; 확장 차종은 접미사 해시 기호의 사용; 만약 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 이&lt;/a&gt; 둘은 활성화 &lt;code&gt;x#y&lt;/code&gt; 의미 &lt;code&gt;x# y&lt;/code&gt; 하지만에만 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 다음 수단 활성화 &lt;code&gt;x #y&lt;/code&gt; . &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장 차종 &lt;code&gt;(#&lt;/code&gt; 때 하나의 어휘, 그래서 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; 가&lt;/a&gt; 활성화되어 당신이 여는 괄호와 오버로드 된 라벨 사이에 공백을 작성해야합니다. 혼동을 피하기 위해, 당신은 강력하게 사용하는 경우 해시 앞에 공백을 넣어하는 것이 좋습니다 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">때 당신은 &lt;em&gt;정말&lt;/em&gt; 속도에 대한 절망, 당신은에서 오른쪽으로 내려 싶다 &quot;원시 비트를.&quot; 비 &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;박스형 유형 사용에&lt;/a&gt; 대한 자세한 내용은 비 박스형 유형 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">&lt;code&gt;safe&lt;/code&gt; (기본값)으로 주석이 달린 &lt;code&gt;foreign import&lt;/code&gt; 함수 를 호출 하고 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용하여 링크 된 경우, 호출은 실행중인 다른 Haskell 스레드와 동시에 실행됩니다. 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 없이 링크 된 경우 호출이 리턴 될 때까지 다른 Haskell 스레드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">템플릿 Haskell 스플 라이스가 포함 된 간단한 모듈을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">&lt;code&gt;Wibble&lt;/code&gt; 을 가져 오는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">지정된 엔티티를 가져오고 사용하는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; 을 사용하여 추상 유형을 정의 할 때 새 유형이 해당 표현에서 일부 인스턴스를 상속하도록 할 수 있습니다. Haskell 98에서는 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 인스턴스를 파생시켜 상속받을 수 있지만 다른 클래스의 경우 명시 적 인스턴스 선언을 작성해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">Haskell 소스 모듈을 GHCi에로드하면 일반적으로 바이트 코드로 변환되고 인터프리터를 사용하여 실행됩니다. 그러나 해석 된 코드는 GHCi에서 컴파일 된 코드와 함께 실행될 수도 있습니다. 실제로, GHCi가 시작될 때 , &lt;code&gt;Prelude&lt;/code&gt; 를 포함하는 &lt;code&gt;base&lt;/code&gt; 패키지 의 컴파일 된 사본을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">프롬프트에서 표현식을 입력하면 GHCi는 즉시 결과를 평가하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">프롬프트에서 표현식을 입력하면 범위에 속하는 식별자와 유형은 무엇입니까? GHCi는 표현식의 컨텍스트 구성 방식을 정확하게 제어 할 수있는 유연한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">패턴 일치를 사용하면 바운드 변수에 다형성 유형이있을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">소스 코드에 대한 의미 정보가 필요한 플러그인을 정의하려면 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 필드를 사용하십시오 . 예를 들어, 플러그인이 두 개의 이름이 동일한 정의를 참조하는지 여부를 결정해야하거나 의미 정보를 사용하는 함수의 유형을 확인해야하는 경우입니다. 이 경우 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 또는 &lt;code&gt;renamedResultAction&lt;/code&gt; 을 사용하여 구문 트리의 이름이 바뀌거나 유형이 확인 된 버전에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">소스 코드의 구문 트리를 사용하는 플러그인을 정의하려는 경우 &lt;code&gt;parsedResultAction&lt;/code&gt; 필드 를 대체 하려고 합니다. 이 액세스 포인트를 사용하면 소스 코드의 어휘 토큰 및 주석에 대한 정보와 컴파일 된 모듈의 원래 구문 트리에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">Haskell 프로그램이 시작되면 RTS는 &lt;code&gt;+RTS&lt;/code&gt; 와 &lt;code&gt;-RTS&lt;/code&gt; 사이에 괄호로 묶인 명령 줄 인수를 자체적 으로 추출 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">프롬프트에 표현식 (또는 비 바인드 명령문)이 입력 될 때마다 GHCi는 값을 변수에 내재적으로 바인드 &lt;code&gt;it&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">내보내기 목록이없고 데이터 인스턴스가 정의 될 때마다 데이터 패밀리가 로컬로 정의되어 있는지 또는 다른 모듈에 정의되어 있는지에 관계없이 해당 데이터 패밀리 유형 생성자가 새 데이터 생성자와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">어디 &lt;code&gt;@Int&lt;/code&gt; 이 보이는 유형의 응용 프로그램 (이용하여 &lt;a href=&quot;#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램&lt;/a&gt; 이 instantiate하는) &lt;code&gt;b&lt;/code&gt; 의 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 입니다. 이 형식 응용 프로그램이 작동 하려면 &lt;code&gt;bar&lt;/code&gt; 의 기본 형식 서명이 기본 이 아닌 서명과 형식 변수 순서가 같아야합니다! 그러나 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;C'&lt;/code&gt; 가 동일 해야 할 의무는 없습니다 ( 예 를 들어, 위 의 &lt;code&gt;Enum&lt;/code&gt; 예 참조).</target>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;v&lt;/code&gt; 는 이진 인코딩 된 데이터 구조입니다. 원본 데이터를 재구성하기 위해 우리는 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt; 을 사용합니다</target>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">GHC가 확장 인스턴스 선언을 허용하는 경우, 우리는이 새로운 &lt;code&gt;class&lt;/code&gt; 의 클래스 와 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; 를 사용 하면 구문이</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">가능한 경우 응용 프로그램은 대신 일반 공용 인터페이스 모듈 (예 : &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe)&lt;/a&gt; 의 기능을 사용해야합니다 . ByteString 시스템을 낮은 수준으로 확장하는 패키지는이 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">사용자 제공 라이브러리를 찾을 수있는 곳&amp;hellip; ⟨dir⟩ 디렉토리를 라이브러리 디렉토리 경로 앞에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">각 라인 입력 세션의 시작과 끝에서 히스토리를 읽고 쓰는 위치.</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">여기서 &quot;식별자&quot;는 현재 GHCi에로드 된 해석 된 모듈의 최상위 기능 이름을 나타냅니다 (자격이 지정된 이름이 사용될 수 있음). 중단 점은 함수가 완전히 적용되었지만 패턴 일치가 이루어지기 전에 함수 본문에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">Haskell에서는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 가 값을 포함하거나 생성하는 것으로 생각할 수있는 반면 , 반 변형 Functor는 &lt;em&gt;소비&lt;/em&gt; 가치 로 생각할 수있는 Functor입니다 .</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">리스트가 유한하거나 무한 할 수있는 반면, 시퀀스는 항상 유한합니다. 결과적으로 시퀀스의 길이는 엄격합니다. 효율성을 무시하고 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 가 정의 되었다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">하이퍼 스레딩 코어를 계산해야하는지 여부는 미심쩍은 질문입니다. 자유롭게 실험하고 찾은 결과를 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">비용 센터가 CAF (Constant Applicative Form)인지 여부</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">일치가 원래의 데이터 생성자 집합 또는 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 에서 발생하는지 (후자를 우선)</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">이것이 보류되는지 여부는 사용중인 GHC 버전, 작업중인 플랫폼, 작업중인 데이터 및 사용중인 인코딩에 따라 달라 지므로 직접 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">이 단어 뒤에 공백, 끝 따옴표 등이 와야하는지 여부</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">양수에 대해 더하기 부호를 요구할지 여부.</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">필드를 왼쪽으로 조정하거나 패드를 제로로할지 여부 &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; 가 우선적 으로 상호 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">원본 소스 코드의 스 니펫 표시 여부</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에서 패턴의 적용 범위를 확인할 때 어떤 &lt;code&gt;COMPLETE&lt;/code&gt; pragma를 사용해야 합니까? 우리가 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2&lt;/code&gt; , 다음 &lt;code&gt;f&lt;/code&gt; 철저한이지만, 우리는 다른 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2Internal&lt;/code&gt; 은 다음 &lt;code&gt;f&lt;/code&gt; 하다 &lt;em&gt;하지&lt;/em&gt; 가 일치하지 때문에, 철저한 &lt;code&gt;MkT2Internal&lt;/code&gt; 을 . 이 딜레마를 해결하는 직관적 인 방법은 이전의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 를 선택하면 발견되지 않은 패턴 절 수가 가장 적으므로 더 나은 선택 임을 인식하는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">보다 깔끔한 스타일로 함수를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">가비지 수집중인 세대</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">이는 구멍이 &lt;code&gt;foldl1 _&lt;/code&gt; 로 대체 될 수 있음을 보여줍니다 . 구멍을 고정시키지 않으면 서 사용자가 자신이 가진 옵션을 이해하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">다음과 같은 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 은 모든 목록 요소의 평가를 강제로 :</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; 인용 사용 허용 (즉, 많은 문자의 편리 이스케이프) 단일 또는 이중 따옴표의 매칭 세트를 가짐으로써는, &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; 는 항상 공백, 따옴표 및 백 슬래시를 이스케이프합니다 따라서 인용 mechasnism를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">하지만 &lt;code&gt;INLINE&lt;/code&gt; &quot;나 인라인하시기 바랍니다&quot;라고는 &lt;code&gt;INLINABLE&lt;/code&gt; 은 나를 인라인 주시기 바랍니다 &quot;라고; 재량을 사용하십시오&amp;rdquo;. 다시 말해, 선택은 pragma-free 기능과 동일한 규칙을 사용하는 GHC에 맡겨집니다. &lt;code&gt;INLINE&lt;/code&gt; 과 달리 결정은 &lt;em&gt;호출 사이트&lt;/em&gt; 에서 이루어 지므로 인라인 임계 값, 최적화 수준 등에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">상태 &lt;code&gt;a + b&lt;/code&gt; 로 파싱 &lt;code&gt;(+) a b&lt;/code&gt; 와 결합하는 위치로된다 &lt;code&gt;(+)&lt;/code&gt; 형 연산자, &lt;code&gt;a * b&lt;/code&gt; 로 파싱 &lt;code&gt;a (*) b&lt;/code&gt; 및 거부한다.</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">반면 &lt;code&gt;n&lt;/code&gt; 용도에 &lt;code&gt;k&lt;/code&gt; 따라서 도입하고없이 규칙을 위반 그것이 현재 허용된다. 이는 &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; 이 종류 시그니처에서 발생 하기 때문에 종류 변수로 간주 되기 때문 입니다. 실제로 다음 예제에서 볼 수 있듯이 형식 변수와 종류 변수 사이의 경계는 모호합니다.</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">GHC는 기능을 인라인하기를 원하지만 맹목적으로 그렇게하지는 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">Safe Haskell은 확장 기능이지만 실제로는 GHC를 사용하는 모든 컴파일에 대해 백그라운드에서 실행됩니다. Safe Haskell을 명시 적으로 사용하지 않는 경우에도 모듈의 유형 위반을 추적하여 안전을 유추합니다. 자세한 내용은 &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell 추론&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">Safe Haskell의 주요 사용 사례는 신뢰할 수없는 코드를 실행하지만 Safe Haskell은이를 직접 제공하지 않습니다. 대신 Safe Haskell은 엄격한 유형의 안전을 제공합니다. Safe Haskell이 없으면 GHC는 유형 시스템에 많은 예외를 허용하여 추상화를 전복시킬 수 있습니다. Safe Haskell은 엄격한 유형 안전성을 제공함으로써 개발자가 신뢰할 수없는 코드를 실행하기위한 자체 라이브러리 수준 샌드 박스 메커니즘을 구축 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">개발하는 동안 때로는 코드에 유형 오류가 있어도 컴파일이 성공하도록하는 것이 바람직합니다. 다음과 같은 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 으로 GHCi에로드 된 모듈 은 &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;static&lt;/code&gt; 표현식을 사용할 수 있지만 REPL에 입력 된 명령문은 그렇지 않을 수 있습니다. 이것은 GHCi의 한계입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;문제 # 12356&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">프로파일 링이 설정된 상태에서 프로그램을 실행하는 동안 GHC는 비용 중심 스택 스택을 유지하고 모든 비용 (메모리 할당 및 시간)을 현재 비용 중심 스택이 비용 발생 시점의 원인이되도록합니다.</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">앞에서 설정 한 2 번 줄의 중단 점에서 중단 된 상태에서 &lt;code&gt;:step qsort [1,3]&lt;/code&gt; 으로 새로운 평가를 시작했습니다 . 이 새로운 평가는 한 단계 후에 ( &lt;code&gt;qsort&lt;/code&gt; 정의에서) 중지되었습니다 . 현재 접두사를 넘어서 저장된 중단 점이 있음을 나타 내기 위해 프롬프트에 &lt;code&gt;...&lt;/code&gt; 접두사가 붙었습니다 . 컨텍스트 스택을 보려면 &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">다음과 같은 정의는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">이들은 플래그이지만 모듈이 가질 수있는 Safe Haskell 모듈 유형에도 해당합니다. 이것을 모듈이 가지고 있어야하는 명시 적 계약 (또는 유형)을 선언하는 것으로 생각할 수 있습니다. 유효하지 않으면 컴파일이 실패합니다. 또한 GHC는 Safe Haskell에 올바른 유형을 유추합니다 . 자세한 내용은 &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell 추론&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">이 예제는 비슷해 보이지만 컴파일되지는 않습니다. 이는 마지막 유형 매개 변수 &lt;code&gt;a&lt;/code&gt; 의 모든 항목이 공변량이 아닌 &lt;em&gt;반 변형&lt;/em&gt; 위치 에서 발생하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">이러한 함수에는 안정적인 API가 있으며 이러한 함수를 응용 프로그램에서 사용할 수 있지만 문서화 된 사전 조건을 신중하게 고려하십시오. 잘못 사용하면 참조 투명성이 손상되거나 악화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">이 수준은 다소 낮지 만 데이터 작성 방법에 대한 완전한 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">일반적인 패턴 동의어는 두 가지 방식으로 사용될 수 있지만 &lt;code&gt;Point&lt;/code&gt; 를 사용하는 일곱 가지 방법이 있습니다 . 정확하게 일반 레코드 생성자를 사용할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">왜 링크 오류가 발생 했습니까?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">왜 이것이 필요한가요? 외부 라이브러리가 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성된 스레드에서 호출 되면 각 OS 스레드에 대해 특정 값을 갖는 &lt;em&gt;스레드 로컬&lt;/em&gt; 상태 변수에 액세스 할 수 없습니다 (POSIX의 &lt;code&gt;pthread_key_create&lt;/code&gt; 또는 Win32의 &lt;code&gt;TlsAlloc&lt;/code&gt; 참조 ). 따라서 일부 라이브러리 (예 : OpenGL)는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성된 스레드에서 작동하지 않습니다 . 그것들은 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 사용하여 생성 된 스레드 에서 또는 &lt;code&gt;main&lt;/code&gt; 또는 &lt;code&gt;foreign export&lt;/code&gt; 에서 호출 될 때 정상적으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">왜 우리가 이것을하고 싶습니까? 주된 이유는 해석 된 코드를 실행하는 RTS가 GHC 자체와 다른 특징 (프로파일 링 또는 동적으로 링크 된) 일 수 있기 때문입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">왜 컴파일 된 코드를 실행해야합니까? 컴파일 된 코드는 해석 된 코드보다 약 10 배 빠르지 만 생성하는 데 약 2 배가 더 걸립니다 (최적화가 설정된 경우 더 길어질 수 있음). 따라서 자주 변경되지 않는 프로그램 부분을 컴파일하고 코드가 활발하게 개발되도록 인터프리터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">너비 자릿수는 수정 자 다음과 지정자 앞에 (여기서 &lt;code&gt;z&lt;/code&gt; 로 표시 ) 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">타입 시그니처의 모노 타입 (tau) 부분에서 발생하는 와일드 카드는 &lt;em&gt;타입 와일드 카드입니다&lt;/em&gt; (&amp;ldquo;타입&amp;rdquo;은 기본 와일드 카드 유형이므로 종종 생략 됨). 유형 와일드 카드는 &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; Int- &amp;gt; Bool) 또는 &lt;code&gt;Maybe&lt;/code&gt; 와 같은 고급 유형의 함수를 포함하여 &lt;code&gt;Bool&lt;/code&gt; 또는 &lt;code&gt;Maybe [Bool]&lt;/code&gt; 과 같은 모든 모노 타입으로 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">잘못 입력 한 용어가 잘 입력 된 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 뒤에 표시된다는 사실에도 불구하고 출력을 내 보내지 않습니다 . . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;문제 # 11197을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">때문에이 경고를 올릴 것이다 &lt;code&gt;Zero&lt;/code&gt; 와 &lt;code&gt;Succ&lt;/code&gt; 로 작성되지 않은 &lt;code&gt;'Zero&lt;/code&gt; 와 &lt;code&gt;'Succ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">Windows GUI 전용 프로그램에는 stdin, stdout 또는 stderr이 없으므로 일반적인 Haskell 입력 / 출력 기능을 사용하면 다음과 같은 IO 예외로 인해 프로그램이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">Windows 전용 : 디렉토리 링크</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Windows 경로가 모두 같지는 않습니다. 서로 다른 종류의 경로는 각각 다른 의미를 갖습니다. &lt;code&gt;MAX_PATH&lt;/code&gt; 의 제한은 운영 체제 나 파일 시스템의 제한이 없습니다. 이전 버전과의 호환성을 위해 Win32 API가 적용하는 기본 네임 스페이스의 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">Windows 시스템</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows 관련 오류 : 파일 시스템이 기호 링크를 지원하지 않으면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 으로 인해이 작업이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows 관련 오류 : 사용자에게 기호 링크를 작성할 권한이없는 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; 으로이 조작이 실패 할 수 있습니다. 파일 시스템이 기호 링크를 지원하지 않는 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 으로 실패 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC는 모든 데이터 유형을 자동으로 승격시키고 (값) 생성자를 유형 생성자로 승격시킵니다. 다음과 같은 유형</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 Haskell의 목록 및 튜플 유형은 기본적으로 종류로 승격되며 따옴표가 있지만 유형 수준에서 동일한 편리한 구문을 즐길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 위 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 당신은 다른 클래스를 파생 할 수 있습니다. 컴파일러는 명시 적으로 정의 된 메소드없이 인스턴스 선언을 생성합니다. 이 기능은 &lt;a href=&quot;#minimal-pragma&quot;&gt;최소 집합&lt;/a&gt; 이 비어 있는 클래스 , 특히 &lt;a href=&quot;#generic-programming&quot;&gt;일반 함수를&lt;/a&gt; 작성할 때 특히 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Data&lt;/code&gt; 에 정의 &lt;code&gt;Data.Data&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; 을&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대한 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Foldable&lt;/code&gt; 정의, &lt;code&gt;Data.Foldable&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 를&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대한 &lt;code&gt;Functor&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Functor&lt;/code&gt; 에 정의 &lt;code&gt;GHC.Base&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Generic&lt;/code&gt; 및 &lt;code&gt;Generic1&lt;/code&gt; 에 정의 &lt;code&gt;GHC.Generics&lt;/code&gt; 을 . &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍에&lt;/a&gt; 설명 된대로이를 사용하여 일반 기능을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; 를&lt;/a&gt; 사용 하면 &lt;code&gt;template-haskell&lt;/code&gt; 패키지 의 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;Lift&lt;/code&gt; 클래스의 인스턴스를 파생시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 을&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대해 &lt;code&gt;Traversable&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수 &lt;code&gt;Traversable&lt;/code&gt; 정의, &lt;code&gt;Data.Traversable&lt;/code&gt; 을 . 이후 &lt;code&gt;Traversable&lt;/code&gt; 인스턴스 지시의 인스턴스 &lt;code&gt;Functor&lt;/code&gt; 및 &lt;code&gt;Foldable&lt;/code&gt; , 그래서, 당신은 아마 그들도 도출 할 수 있습니다 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 의미 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 당신이 사용할 수있는 &lt;em&gt;자격이&lt;/em&gt; 해당 선택은 범위에있는 경우에도 필드 이름을 &lt;em&gt;자격을&lt;/em&gt; 예를 들어 같은 모듈 가정, &lt;code&gt;M&lt;/code&gt; 을 ,이 법적으로 우리의 이전의 예에서와 같이 :</target>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">&lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는 여러 분기로 조건식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;-maxN⟨x⟩&lt;/code&gt; , 즉 &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; , 런타임은 시스템의 프로세서 수에 의해 제한, 대부분의 (X)로 선택합니다. 기본 사용 옵션 &lt;code&gt;-N&lt;/code&gt; 이 필요한 경우 (x)를 생략하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">와 &lt;code&gt;hpc-tracer&lt;/code&gt; , 이는 (a 탭 여러 공간을 나타낸다) 8이다.</target>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">GHC에서 &lt;code&gt;ByteString&lt;/code&gt; 표현은 &lt;em&gt;고정 된&lt;/em&gt; 메모리를 사용하므로 GC로 이동할 수 없습니다. 이는 일반적으로 더 큰 문자열에 대해 올바른 작업이지만 고정 된 메모리를 사용하는 작은 문자열에 대해서는 힙 조각화가 발생하여 공간을 낭비 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 의 유형 (과 &lt;code&gt;Text&lt;/code&gt; 로부터 유형 &lt;code&gt;text&lt;/code&gt; 패키지)를 사용하여 &lt;em&gt;고정 해제&lt;/em&gt; 가 힙 단편화에 기여하지 않도록 메모리를. 또한 GHC를 사용하면 고정되지 않은 작은 문자열이 별도의 고정 영역이 아닌 일반 힙 할당과 동일한 방식으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">GHC를 사용하면 메모리 오버 헤드는 다음과 같이 단어와 바이트로 표시됩니다 (워드는 각각 32 또는 64 비트 시스템에서 4 및 8 바이트입니다).</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">유니 코드 텍스트의 경우, 문자열을 각 문자를 개별적으로 변환하기 위해 &lt;code&gt;map toUpper&lt;/code&gt; 와 같은 결합자를 사용하는 것은 올바르지 않습니다 . 대신이 모듈에서 전체 문자열 대 / 소문자 변환 함수를 사용하십시오. 다른 쓰기 시스템에서의 정확성을 위해 이러한 기능은 하나의 입력 문자를 두세 개의 출력 문자에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">운 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; C 스타일 사전 처리를 지원하는 다른 모든 구현 에서는 __GLASGOW_HASKELL__ 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">종속적으로 유형이 지정된 기능을 사용하면 더 유용합니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;문제 # 2431&lt;/a&gt; 참조 ). 예를 들어, &lt;code&gt;absurd&lt;/code&gt; 다음 두 후보 정의를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">친절한 다형성으로, Haskell 프로그래머에게는 보이지 않을 수있는이면에서 약간의 진행이 있습니다. GHC는 오류 메시지와 GHCi 프롬프트에서 유형이 인쇄되는 방법을 제어하는 ​​여러 플래그를 지원합니다. 자세한 내용은 &lt;a href=&quot;using#pretty-printing-types&quot;&gt;예쁜 인쇄 옵션&lt;/a&gt; 에 대한 설명을 참조하십시오. 친절한 다형성을 사용하고 왜 GHC가 프로그램을 거부 (또는 수락)하는지에 대해 혼란 &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; 이러한 플래그, 특히 -fprint-explicit-kinds를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">범위 내에서 여러 모듈, 특히 여러 &lt;code&gt;*&lt;/code&gt; 양식 모듈을 사용하면 이름 충돌이 발생할 수 있습니다. Haskell은 이름 충돌이 모호한 식별자가 사용될 때만보고되고 GHCi가 프롬프트에 입력 된 표현식에 대해 동일한 방식으로 동작하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">단지 1 세대 (예 &lt;code&gt;-G1&lt;/code&gt; 참조 &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt; )에 &lt;code&gt;-A&lt;/code&gt; 의 할당 영역의 실제 크기가 힙 데이터 량에 따라 크기가 조정되기 때문에 옵션이 최소 할당 영역을 지정한다 (참조 &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; 아래의 ⟩factor below).</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">일부 예외 (아래 참조)를 제외하고는 공격자가 사용자의 자격 증명을 사용하여 openTempFile이 파일 시스템의 다른 파일을 덮어 쓸 수 없도록하는 의미로 파일이 안전하게 생성됩니다. 임시 파일이 작성됩니다. Unix에서는 &lt;code&gt;O_CREAT&lt;/code&gt; 및 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그가이 공격을 방지하는 데 사용되지만 NFS 파일 시스템에서는 &lt;code&gt;O_EXCL&lt;/code&gt; 이 지원되지 않는 경우 가 있으므로이 동작에 의존하는 경우 로컬 파일 시스템 만 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는이 두 번째 논문에서 설명하는 화살표 표기법을 지원하며 &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈 의 결합기를 사용하여 번역합니다 . 다음은 표기법에 대한 간략한 소개입니다. 휴즈의 논문을 읽지 않으면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; 의&lt;/a&gt; 확장, GHC는 프로그램의 제약으로 받아들이는 것에 자유주의된다. 정확하게이 플래그를 사용하면 모든 &lt;em&gt;종류&lt;/em&gt; 의 새로운 종류 &lt;code&gt;Constraint&lt;/code&gt; 으로 사용할 수 있습니다. 다음과 같은 종류의 &lt;code&gt;Constraint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; 의&lt;/a&gt; 확장, GHC는없는 생성자와 데이터 유형을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC를 사용하여 모듈을 가져올 패키지 이름으로 가져 오기 선언을 규정 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 확장자 ( &lt;a href=&quot;#universal-quantification&quot;&gt;어휘 적 형 변수 범위&lt;/a&gt; ), 그 유형의 시작 아닌 다른 형태 인수를 선언 할 수있다. 예를 들어, &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; 을 가질 수 있습니다 . a-&amp;gt; forall b. b-&amp;gt; (a, b) 를 누른 다음 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 유형의 @Bool True @Char 쌍 을 말합니다 .</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 인스턴스 헤드에서 유형 동의어를 사용할 수 있습니다. 항상 그렇듯이, 유형 동의어를 사용하는 것은 유형 동의어 정의의 RHS를 작성하기위한 간단한 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">으로 &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; 언어 플래그, GHC는 옵션 취할 수있는 수입 신고 구문 확장 &lt;code&gt;safe&lt;/code&gt; 애프터 키워드 &lt;code&gt;import&lt;/code&gt; 키워드를. 이 기능은 Safe Haskell GHC 확장의 일부입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">&lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; 옵션을 사용하면 GHC는 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 자동으로 생성 할 수 있습니다 . 예를 들어 다음과 같이 선언하면</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">위의 &lt;code&gt;T&lt;/code&gt; 예제를 사용하면 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;다음 &lt;/em&gt;에 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 바인딩 할 수 있습니다 . 그렇게하면 종속성 문제를 위반하지 않습니다. 그러나 그것은 우리의 일반적인 원칙을 위반하므로 &lt;code&gt;k&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">위의 &lt;code&gt;(:~~:)&lt;/code&gt; 선언으로 모든 &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; 친절 합니다. k1-&amp;gt; k2-&amp;gt; 유형 . 따라서, 유형 &lt;code&gt;(:~~:) a&lt;/code&gt; 이 종류 &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; 일부 &lt;code&gt;k2&lt;/code&gt; . 그러면 GHC는 이 종류를 &lt;em&gt;재생성&lt;/em&gt; 하여 모든 &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; 가 될 수 없습니다 . k2-&amp;gt; 원하는대로 입력하십시오 . 따라서 인스턴스는 잘못된 것으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">&lt;a href=&quot;#constraint-kind&quot;&gt;일종의 제약 조건&lt;/a&gt; 을 추가하는 확장을 사용하면 더 이국적인 수퍼 클래스 정의를 작성할 수 있습니다. 이 경우 수퍼 클래스 사이클 점검이 훨씬 더 자유 롭습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tree&lt;/code&gt; 및 기타 데이터 유형 에 대한 &lt;code&gt;encode&lt;/code&gt; 작업을 목표로 , 이제 표현 유형 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 향상된 종류로 Vec &lt;code&gt;Vec Int Char&lt;/code&gt; 와 같은 것들이 잘못되어 GHC가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; &lt;/a&gt; 언어 확장을 통해 GHC는 수퍼 클래스 제약에 대한 모든 제한을 해제합니다. 실제로 루프 &lt;em&gt;가&lt;/em&gt; 있으면 GHC는 루프를 유한 깊이까지만 확장합니다.</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">이 확장을 설정하면 &lt;code&gt;static&lt;/code&gt; 은 더 이상 유효한 식별자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">이 플래그를 활성화하면 마지막 점프 명령을 블록 단위로 사용합니다. 이 플래그가 없으면 기존 알고리즘은 가장 무거운 발신 에지도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">이런 형태의 그룹 문장에서, f는 단순히 &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; 유형을 가져야합니다 . [a]-&amp;gt; [[a]] , 지금까지 이해를 그룹화하는 데 사용됩니다. 이 형식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;.ghci&lt;/code&gt; 파일 에이 매크로가 정의되어 있으면 &lt;code&gt;:source file&lt;/code&gt; 을 사용하여 &lt;code&gt;file&lt;/code&gt; 에서 GHCi 명령을 읽을 수 있습니다 . 이 Haskell 위키 페이지에서 &lt;code&gt;.ghci&lt;/code&gt; 파일에 대한 다른 제안을 찾아서 제공 할 수 있습니다 : &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">지그재그 컷.</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">이러한 이유로 힙 공간에 대한 메모리가 많을수록 GHC에 대한 가비지 수집이 줄어들어 컴파일 시간이 줄어 듭니다. &lt;code&gt;-Rghc-timing&lt;/code&gt; 옵션 을 사용하면 가비지 수집기 보고서가 표시됩니다. (또한 저렴하고 불쾌한 &lt;code&gt;+RTS -S -RTS&lt;/code&gt; 옵션을 사용하여 GC 통계를 표준 오류로 바로 보낼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot;&quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에서 교체를 수행합니다&quot;라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot;&quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에서 교체를 수행합니다&quot;라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 가&lt;/a&gt; 없으면 이러한 모든 정의가 범위 내에 있으면 &lt;code&gt;foo&lt;/code&gt; 를 언급하는 업데이트 가 항상 모호합니다. 확장 기능을 사용하면 명확하게 업데이트 할 수있는 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는 종류 변수에 대한 일반화를 거부합니다. 따라서 가능한 경우 종류 변수를 &lt;code&gt;Type&lt;/code&gt; 기본 설정 합니다. 이것이 불가능하면 오류가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt; 가 없으면 목록 이해력으로 해석됩니다. &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 를&lt;/a&gt; 사용하면 이를 준 따옴표로 분석합니다. 그러나이 구문 분석은 닫는 &lt;code&gt;|]&lt;/code&gt; 부족으로 인해 실패 합니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;문제 # 11679를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션이 없으면 &lt;code&gt;SCC&lt;/code&gt; 가 무시됩니다. &lt;code&gt;SCC&lt;/code&gt; 가 포함 된 코드를 변경하지 않고 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">인수없이 프롬프트에서 입력 한 표현식 및 명령에 적용되는 현재 옵션 세트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">손가락을 들어 올리지 않으면 &lt;code&gt;?cmp&lt;/code&gt; 파라미터가 &lt;code&gt;least&lt;/code&gt; 파라미터로 전파됩니다 . 명시 적 매개 변수를 사용하면 기본적으로 매개 변수가 항상 명시 적으로 전파되어야합니다. 암시 적 매개 변수를 사용하는 경우 기본값은 항상 해당 매개 변수를 전파하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">포함하지 않는 &lt;code&gt;MINIMAL&lt;/code&gt; 프라그 경고는 인스턴스가 구현도 방법에 대해 생성되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">&lt;code&gt;forall b&lt;/code&gt; 가 없으면 유형 변수 &lt;code&gt;b&lt;/code&gt; 는 전체 인스턴스 선언에 대해 수량화되며 이는 의도 된 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 접두사가 없으면 &lt;code&gt;Zero&lt;/code&gt; 은 내보내기 목록에서 유형 생성자로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">언 박스 (unboxed) &lt;code&gt;Proxy#&lt;/code&gt; 값에 대한 감시로 런타임 표현이 없습니다.</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">파괴의 흔적을 목격하십시오 :</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">단어 완성</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
