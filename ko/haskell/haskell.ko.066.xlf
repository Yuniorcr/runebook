<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="31ef00312f2e1ee7506655b11623866b09a38490" translate="yes" xml:space="preserve">
          <source>OddParity</source>
          <target state="translated">OddParity</target>
        </trans-unit>
        <trans-unit id="14ad9c3a886a6706b68193db972d3c2fd0f4dd48" translate="yes" xml:space="preserve">
          <source>Oddly enough, people really do use this option! Our pal in Durham (England), Paul Callaghan, writes: &amp;ldquo;Some people here use it for a variety of purposes&amp;mdash;honestly!&amp;mdash;e.g., confirmation that the code/machine is doing something, infinite loop detection, gauging cost of recently added code. Certain people can even tell what stage [the program] is in by the beep pattern. But the major use is for annoying others in the same office&amp;hellip;&amp;rdquo;</source>
          <target state="translated">이상하게도 사람들은 실제로이 옵션을 사용합니다! Paul Callaghan의 Durham (영국)에있는 우리 친구는 이렇게 말합니다.&amp;ldquo;여기서는 코드 / 기계가 무언가를하고 있다는 확인, 무한 루프 감지, 최근 추가 된 코드의 측정 비용과 같은 다양한 목적으로 정직하게 사용합니다. . 어떤 사람들은 경고음 패턴에 의해 어떤 프로그램이 어떤 단계에 있는지 알 수 있습니다. 그러나 주요 용도는 같은 사무실에서 다른 사람들을 성가 시게하는 것입니다&amp;hellip;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0c0b0b1a2080b74e19b756494638ec92162f2758" translate="yes" xml:space="preserve">
          <source>Odds and ends, mostly functions for reading and showing &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;-like kind of values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 와 끝. 대부분 RealFloat 와 같은 종류의 값 을 읽고 표시하는 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="fb4aa7843d0c5581b08750305cac08a18952a151" translate="yes" xml:space="preserve">
          <source>Of course when running another interactive program in the console then we want to let that program handle Ctl-C. Under Unix however, Ctl-C sends &lt;code&gt;SIGINT&lt;/code&gt; to every process using the console. The standard solution is that while running an interactive program, ignore &lt;code&gt;SIGINT&lt;/code&gt; in the parent, and let it be handled in the child process. If that process then terminates due to the &lt;code&gt;SIGINT&lt;/code&gt; signal, then at that point treat it as if we had recieved the &lt;code&gt;SIGINT&lt;/code&gt; ourselves and begin an orderly shutdown.</source>
          <target state="translated">물론 콘솔에서 다른 대화식 프로그램을 실행할 때 해당 프로그램이 Ctl-C를 처리하도록하려고합니다. 그러나 Unix에서는 Ctl-C 가 콘솔을 사용하여 모든 프로세스에 &lt;code&gt;SIGINT&lt;/code&gt; 를 보냅니다 . 표준 솔루션은 대화식 프로그램을 실행하는 동안 상위에서 &lt;code&gt;SIGINT&lt;/code&gt; 를 무시 하고 하위 프로세스에서 처리되도록하는 것입니다. 그 과정은 다음에 의한 종료되면 &lt;code&gt;SIGINT&lt;/code&gt; 의 우리가 받았다 것처럼 그 시점 치료 그것을 다음, 신호 &lt;code&gt;SIGINT&lt;/code&gt; 에게 자신을하고 순서대로 종료를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="13cbc7281dc8f2ba063030a73854a759868eae8d" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;UndecidableInstances&lt;/code&gt; lifts the Paterson Conditions, as now.</source>
          <target state="translated">물론, &lt;code&gt;UndecidableInstances&lt;/code&gt; 는 지금과 같이 패터슨 조건을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="bd80101b7867bda9e4de541e2013550d0cd09fca" translate="yes" xml:space="preserve">
          <source>Of course, if you have foreign calls in your program then all bets are off, because you can trash the heap, the stack, or whatever.</source>
          <target state="translated">물론, 프로그램에 외화 호출이 있으면 힙, 스택 등을 휴지통에 버릴 수 있기 때문에 모든 베팅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a37fd12339c76f03254c6a2485812a618d645f86" translate="yes" xml:space="preserve">
          <source>Of course, in this particular situation you can do even better:</source>
          <target state="translated">물론이 특별한 상황에서 더 잘 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="959274964b08ed6b64f4a784f4ffb9f800fb0e15" translate="yes" xml:space="preserve">
          <source>Of course, you can also bind normal non-IO expressions using the &lt;code&gt;let&lt;/code&gt;-statement:</source>
          <target state="translated">물론 &lt;code&gt;let&lt;/code&gt; -statement를 사용하여 일반 비 IO 표현식을 바인딩 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="ea2c1b968cb14580f767587f854d5b3baa84a1fa" translate="yes" xml:space="preserve">
          <source>Offset into first</source>
          <target state="translated">처음으로 오프셋</target>
        </trans-unit>
        <trans-unit id="5c4232ca426c972654e6acef0e24307e9bf01cdb" translate="yes" xml:space="preserve">
          <source>Offset into second</source>
          <target state="translated">두 번째로 오프셋</target>
        </trans-unit>
        <trans-unit id="f8e5c2c7cae1141a37276f0a36a8a63d24f1a869" translate="yes" xml:space="preserve">
          <source>Often a particular data structure is being retained by a chain of unevaluated closures, only the nearest of which will be reported by retainer profiling - for example &lt;code&gt;A&lt;/code&gt; retains &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; retains &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; retains a large structure. There might be a large number of &lt;code&gt;B&lt;/code&gt;s but only a single &lt;code&gt;A&lt;/code&gt;, so &lt;code&gt;A&lt;/code&gt; is really the one we&amp;rsquo;re interested in eliminating. However, retainer profiling will in this case report &lt;code&gt;B&lt;/code&gt; as the retainer of the large structure. To move further up the chain of retainers, we can ask for another retainer profile but this time restrict the profile to &lt;code&gt;B&lt;/code&gt; objects, so we get a profile of the retainers of &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">종종 특정 데이터 구조는 고정 프로파일로보고한다 만 가까운있는 미 평가 클로저의 체인에 의해 유지되고있다 - 예를 위해 &lt;code&gt;A&lt;/code&gt; 유지 &lt;code&gt;B&lt;/code&gt; 를 , &lt;code&gt;B&lt;/code&gt; 는 유지 &lt;code&gt;C&lt;/code&gt; 를 , 그리고 &lt;code&gt;C&lt;/code&gt; 가 큰 구조를 유지한다. 다수의 &lt;code&gt;B&lt;/code&gt; 가있을 수 있지만 단일 &lt;code&gt;A&lt;/code&gt; 만 있을 수 있으므로 &lt;code&gt;A&lt;/code&gt; 는 실제로 우리가 제거하고자하는 것입니다. 그러나이 경우 리테이너 프로파일 링은 &lt;code&gt;B&lt;/code&gt; 를 대형 구조의 리테이너로 보고 합니다. 리테이너 체인 위로 더 이동하려면 다른 리테이너 프로필을 요청할 수 있지만 이번에는 프로필을 &lt;code&gt;B&lt;/code&gt; 로 제한합니다. &lt;code&gt;B&lt;/code&gt; 의 리테이너 프로파일을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="69167169d72ddc29203b8842fec5ca3158c37c4a" translate="yes" xml:space="preserve">
          <source>Old API kept to avoid breaking clients</source>
          <target state="translated">이전 API는 클라이언트 중단을 피하기 위해 유지</target>
        </trans-unit>
        <trans-unit id="9ce5a70368f8243b3801e08794befe07bb9b0130" translate="yes" xml:space="preserve">
          <source>Old deprecated functions</source>
          <target state="translated">더 이상 사용되지 않는 이전 함수</target>
        </trans-unit>
        <trans-unit id="199b0ae233b01261174a40c433e452bd8e11764e" translate="yes" xml:space="preserve">
          <source>Old path</source>
          <target state="translated">오래된 길</target>
        </trans-unit>
        <trans-unit id="9b285d963737095a360d0a661d0df2fea803a4ac" translate="yes" xml:space="preserve">
          <source>Omit code generation</source>
          <target state="translated">코드 생성 생략</target>
        </trans-unit>
        <trans-unit id="06b348347f0fc6282795f8b8662b8c726c982724" translate="yes" xml:space="preserve">
          <source>Omit code generation (and all later phases) altogether. This is useful if you&amp;rsquo;re only interested in type checking code.</source>
          <target state="translated">코드 생성 (및 모든 이후 단계)을 모두 생략하십시오. 유형 검사 코드에만 관심이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="143759d6a82a6e782ba8b006ab52848e42762c71" translate="yes" xml:space="preserve">
          <source>Omit heap checks when no allocation is being performed.</source>
          <target state="translated">할당이 수행되지 않을 때 힙 검사를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="7e25f9708b019df5d840bb95bec43db511395b29" translate="yes" xml:space="preserve">
          <source>Omits the link step. This option can be used with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; to avoid the automatic linking that takes place if the program contains a &lt;code&gt;Main&lt;/code&gt; module.</source>
          <target state="translated">링크 단계를 생략합니다. 이 옵션을 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 프로그램에 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 경우 자동 연결이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60e957e3d9a735dd58ec78b95add59bf7dee68af" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;-N⟨x⟩&lt;/code&gt; entirely means &lt;code&gt;-N1&lt;/code&gt;.</source>
          <target state="translated">생략 &lt;code&gt;-N⟨x⟩&lt;/code&gt; 는 완전히 의미 &lt;code&gt;-N1&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="852085b8a1ca62c46bfcfacdf985dc281e39d842" translate="yes" xml:space="preserve">
          <source>Omitting generic instances</source>
          <target state="translated">일반 인스턴스 생략</target>
        </trans-unit>
        <trans-unit id="02a33c2d0537913c5f5350486a8c3f93ad4f4e57" translate="yes" xml:space="preserve">
          <source>Omitting ⟨x⟩, i.e. &lt;code&gt;+RTS -N -RTS&lt;/code&gt;, lets the runtime choose the value of ⟨x⟩ itself based on how many processors are in your machine.</source>
          <target state="translated">⟨x⟩ (예 : &lt;code&gt;+RTS -N -RTS&lt;/code&gt; )를 생략 하면 런타임은 머신에있는 프로세서 수에 따라 ⟨x⟩ 자체의 값을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d76fc4eb3563c85ec6bb33fc1966e50eaee83c" translate="yes" xml:space="preserve">
          <source>On 32-bit x86 platforms when using the native code generator, the &lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt;&lt;code&gt;-fexcess-precision&lt;/code&gt;&lt;/a&gt; option is always on. This means that floating-point calculations are non-deterministic, because depending on how the program is compiled (optimisation settings, for example), certain calculations might be done at 80-bit precision instead of the intended 32-bit or 64-bit precision. Floating-point results may differ when optimisation is turned on. In the worst case, referential transparency is violated, because for example &lt;code&gt;let x = E1 in E2&lt;/code&gt; can evaluate to a different value than &lt;code&gt;E2[E1/x]&lt;/code&gt;.</source>
          <target state="translated">원시 코드 생성기를 사용할 때 32 비트 x86 플랫폼에서 &lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt; &lt;code&gt;-fexcess-precision&lt;/code&gt; &lt;/a&gt; 옵션은 항상 켜져 있습니다. 즉, 부동 소수점 계산은 프로그램이 컴파일되는 방법 (예 : 최적화 설정)에 따라 의도 된 32 비트 또는 64 비트 정밀도 대신 80 비트 정밀도로 수행 될 수 있으므로 결정적이지 않습니다. . 최적화가 켜져 있으면 부동 소수점 결과가 다를 수 있습니다. 최악의 경우, 참조 투명도는 위반됩니다. 예를 들어 &lt;code&gt;let x = E1 in E2&lt;/code&gt; 이 &lt;code&gt;E2[E1/x]&lt;/code&gt; 와 다른 값으로 평가 될 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="1391cbd23623d8953378e909f91a6612b37b28fe" translate="yes" xml:space="preserve">
          <source>On 64-bit machines, the RTS needs to allocate memory in the low 2Gb of the address space. Support for this across different operating systems is patchy, and sometimes fails. This option is there to give the RTS a hint about where it should be able to allocate memory in the low 2Gb of the address space. For example, &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; would hint that the RTS should allocate starting at the 0.5Gb mark. The default is to use the OS&amp;rsquo;s built-in support for allocating memory in the low 2Gb if available (e.g. &lt;code&gt;mmap&lt;/code&gt; with &lt;code&gt;MAP_32BIT&lt;/code&gt; on Linux), or otherwise &lt;code&gt;-xm40000000&lt;/code&gt;.</source>
          <target state="translated">64 비트 시스템에서 RTS는 주소 공간의 낮은 2Gb에 메모리를 할당해야합니다. 여러 운영 체제에서이 기능에 대한 지원이 불완전하며 때때로 실패합니다. 이 옵션은 RTS에게 주소 공간의 낮은 2Gb에서 메모리를 할당 할 수있는 위치에 대한 힌트를 제공합니다. 예를 들어 &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; 는 RTS가 0.5Gb 표시에서 시작해야 함을 암시합니다. 기본 내장 지원 낮은 기가 바이트의 메모리를 할당하는 OS를 사용하는 것입니다 (예를 들어, 사용 가능한 경우 &lt;code&gt;mmap&lt;/code&gt; 에 와 &lt;code&gt;MAP_32BIT&lt;/code&gt; 리눅스), 또는 기타 &lt;code&gt;-xm40000000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56b14479147dc851f7df3c7d9e83023d77f4f785" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X, dynamic libraries are stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the ultimate install path of the library file. Any libraries or executables that subsequently link against it will pick up that path as their runtime search location for it. By default, ghc sets the install name to the location where the library is built. This option allows you to override it with the specified file path. (It passes &lt;code&gt;-install_name&lt;/code&gt; to Apple&amp;rsquo;s linker.) Ignored on other platforms.</source>
          <target state="translated">Darwin / OS X에서 동적 라이브러리는 빌드시 라이브러리 파일의 최종 설치 경로 인&amp;ldquo;설치 이름&amp;rdquo;으로 스탬프 처리됩니다. 이후에 링크되는 라이브러리 또는 실행 파일은 해당 경로를 런타임 검색 위치로 선택합니다. 기본적으로 ghc는 설치 이름을 라이브러리가 구축 된 위치로 설정합니다. 이 옵션을 사용하면 지정된 파일 경로로 대체 할 수 있습니다. ( &lt;code&gt;-install_name&lt;/code&gt; 을 Apple의 링커로 전달합니다 .) 다른 플랫폼에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c502a4721745da19ad3306edaec1023d6b7312d6" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, add ⟨dir⟩ to the list of directories searched for frameworks. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 프레임 워크를 검색 한 디렉토리 목록에 ⟨dir⟩을 추가하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-F&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="836aeb62038416ab5d18c1c4cccc6b7891cf00da" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨name⟩ 프레임 워크에 링크하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-framework&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2f8a49d8d4c58193d7bce9934ad90451e92201" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker. Please note that frameworks and packages are two different things - frameworks don&amp;rsquo;t contain any Haskell code. Rather, they are Apple&amp;rsquo;s way of packaging shared libraries. To link to Apple&amp;rsquo;s &amp;ldquo;Carbon&amp;rdquo; API, for example, you&amp;rsquo;d use &lt;code&gt;-framework Carbon&lt;/code&gt;.</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨name⟩ 프레임 워크에 링크하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-framework&lt;/code&gt; 옵션에 해당합니다 . 프레임 워크와 패키지는 서로 다른 두 가지입니다. 프레임 워크에는 Haskell 코드가 포함되어 있지 않습니다. 오히려 공유 라이브러리를 패키징하는 Apple의 방식입니다. 예를 들어 Apple의 &quot;Carbon&quot;API에 연결하려면 &lt;code&gt;-framework Carbon&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c57aabecc887720cc819888b560ff938ff24a471" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, prepend the directory ⟨dir⟩ to the framework directories path. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker (&lt;code&gt;-F&lt;/code&gt; already means something else for GHC).</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨dir⟩ 디렉토리를 프레임 워크 디렉토리 경로 앞에 추가하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-F&lt;/code&gt; 옵션에 해당합니다 ( &lt;code&gt;-F&lt;/code&gt; 는 이미 GHC의 다른 것을 의미 함).</target>
        </trans-unit>
        <trans-unit id="f6e8ba5a3fab15f9e41a75f470422c219a534bb8" translate="yes" xml:space="preserve">
          <source>On GHC, the runtime will ensure that any Haskell thread will only see &quot;its own&quot; &lt;code&gt;errno&lt;/code&gt;, by saving and restoring the value when Haskell threads are scheduled across OS threads.</source>
          <target state="translated">GHC에서 런타임은 Haskell 스레드가 OS 스레드에서 스케줄 될 때 값을 저장하고 복원하여 Haskell 스레드가 &quot;자체&quot; &lt;code&gt;errno&lt;/code&gt; 만 볼 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="40cc400d7871c058aaff05bc589d341778622e21" translate="yes" xml:space="preserve">
          <source>On POSIX platforms these two new handles will always be Nothing</source>
          <target state="translated">POSIX 플랫폼에서이 두 개의 새로운 핸들은 항상 아무것도 아닙니다</target>
        </trans-unit>
        <trans-unit id="078d3ef4757340184bdc802a0b2704173202e340" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this is equivalent to &lt;code&gt;stat&lt;/code&gt; followed by &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서 이는 &lt;code&gt;stat&lt;/code&gt; 다음에 &lt;code&gt;chmod&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e5150091903944c9e80b85e4f5491e74472f81c1" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this returns the result of &lt;code&gt;access&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서는 &lt;code&gt;access&lt;/code&gt; 결과를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0e1256ac8aafae1c7e4adb4ddae8c68c82e5af71" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this sets the &lt;em&gt;owner&lt;/em&gt; permissions.</source>
          <target state="translated">POSIX 시스템에서 이것은 &lt;em&gt;소유자&lt;/em&gt; 권한을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="15a6eb7d1aee9c1397492586a65a460c544dbaea" translate="yes" xml:space="preserve">
          <source>On POSIX, equivalent to &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX에서는 &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt; Posix와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6c168ab7b60c55fc5b0097e465ca6c5d25010787" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible platforms GHC&amp;rsquo;s runtime system (when built with &lt;code&gt;libdw&lt;/code&gt; support) will produce a stack trace on &lt;code&gt;stderr&lt;/code&gt; when a &lt;code&gt;SIGQUIT&lt;/code&gt; signal is received (on many systems this signal can be sent using &lt;code&gt;Ctrl-\&lt;/code&gt;). For instance (using the same &lt;code&gt;fib.hs&lt;/code&gt; as above),</source>
          <target state="translated">POSIX 호환 플랫폼에서 GHC의 런타임 시스템 ( &lt;code&gt;libdw&lt;/code&gt; 지원으로 구축 된 경우)은 &lt;code&gt;SIGQUIT&lt;/code&gt; 신호가 수신 될 때 &lt;code&gt;stderr&lt;/code&gt; 에서 스택 추적을 생성합니다 (많은 시스템에서이 신호는 &lt;code&gt;Ctrl-\&lt;/code&gt; 를 사용하여 전송 될 수 있음 ). 예를 들어 ( 위와 같은 &lt;code&gt;fib.hs&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="0422707a616b81e28b0b133b6079462f1cb7aac1" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; sends the process the SIGTERM signal. On Windows systems, if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; function is called to kill all processes associated with the job and passing the exit code of 1 to each of them. Otherwise if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; function is called, passing an exit code of 1.</source>
          <target state="translated">Unix 시스템에서 &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 는 프로세스에 SIGTERM 신호를 보냅니다. Windows 시스템에서 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 작업과 연관된 모든 프로세스를 종료하고 종료 코드 1을 각 프로세스에 전달하기 위해 Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; 함수가 호출됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이면 종료 코드 1을 전달 하여 Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="26000ccdb50e03ab1029e35d0df1776d18e9ab0e" translate="yes" xml:space="preserve">
          <source>On Unix systems, it sends the group the SIGINT signal.</source>
          <target state="translated">Unix 시스템에서는 그룹에 SIGINT 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c6d0966027827b87508cf93ba9e2a42091942bf2" translate="yes" xml:space="preserve">
          <source>On Unix systems, see &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for the meaning of exit codes when the process died as the result of a signal.</source>
          <target state="translated">Unix 시스템 에서 프로세스가 신호의 결과로 종료 된 경우 종료 코드의 의미는 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09629c83332620e6e6759db7b31141b99ca9c762" translate="yes" xml:space="preserve">
          <source>On Unix there are two mechanisms. Shared libraries can be installed into standard locations that the dynamic linker knows about. For example &lt;code&gt;/usr/lib&lt;/code&gt; or &lt;code&gt;/usr/local/lib&lt;/code&gt; on most systems. The other mechanism is to use a &amp;ldquo;runtime path&amp;rdquo; or &amp;ldquo;rpath&amp;rdquo; embedded into programs and libraries themselves. These paths can either be absolute paths or on at least Linux and Solaris they can be paths relative to the program or library itself. In principle this makes it possible to construct fully relocatable sets of programs and libraries.</source>
          <target state="translated">유닉스에는 두 가지 메커니즘이 있습니다. 동적 라이브러리가 알고있는 표준 위치에 공유 라이브러리를 설치할 수 있습니다. 예를 들어 대부분의 시스템에서 &lt;code&gt;/usr/lib&lt;/code&gt; 또는 &lt;code&gt;/usr/local/lib&lt;/code&gt; 입니다. 다른 메커니즘은 프로그램 및 라이브러리 자체에 포함 된 &quot;런타임 경로&quot;또는 &quot;rpath&quot;를 사용하는 것입니다. 이러한 경로는 절대 경로이거나 최소한 Linux 및 Solaris에서 프로그램 또는 라이브러리 자체에 대한 경로 일 수 있습니다. 원칙적으로 이것은 재배치 가능한 프로그램 및 라이브러리 세트를 구성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1aa9bf14869ffa0729b113a2919b90d3a99f83ea" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; behaves as follows:</source>
          <target state="translated">유닉스에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; 는 다음과 같이 동작합니다 :</target>
        </trans-unit>
        <trans-unit id="dbda9eb325b9c89423ab40811c09f445058a091b" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable or &quot;/tmp&quot; if the variable isn't defined. On Windows, the function checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Unix에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 또는 변수가 정의되지 않은 경우 &quot;/ tmp&quot; 의 값을 리턴합니다 . Windows에서 함수는 다음 순서로 환경 변수가 있는지 확인하고 발견 된 첫 번째 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db73ed697e88171697c761e2de6ba9e3b2fdb8f6" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;HOME&lt;/code&gt; environment variable. On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt;.</source>
          <target state="translated">Unix에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;HOME&lt;/code&gt; 환경 변수 의 값을 리턴합니다 . Windows에서 시스템은 적절한 경로를 조회합니다. 일반적인 경로는 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6aec3d6d90c1ca53af23e974fd0a1470d206561" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, permissions, access time, and modification time are preserved. If possible, the owner and group are also preserved. Note that the very act of copying can change the access time of the source file, hence the access times of the two files may differ after the operation completes.</source>
          <target state="translated">유닉스 계열 시스템에서는 권한, 액세스 시간 및 수정 시간이 유지됩니다. 가능하면 소유자와 그룹도 보존됩니다. 복사 작업으로 인해 소스 파일의 액세스 시간이 변경 될 수 있으므로 작업이 완료된 후 두 파일의 액세스 시간이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f67f27323ff913fec8fc3bce6fba0553de49353" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, the path is &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">유닉스 계열 시스템에서 경로는 &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2acf1d643c18794b5ab0d3288014560943c06f0b" translate="yes" xml:space="preserve">
          <source>On Unix: &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</source>
          <target state="translated">유닉스에서 : &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="686bba75bbf12a7e94f3f601b8b2b6f1c767e5b6" translate="yes" xml:space="preserve">
          <source>On Win32 platforms, &lt;code&gt;renameDirectory&lt;/code&gt; fails if the &lt;em&gt;new&lt;/em&gt; directory already exists.</source>
          <target state="translated">Win32 플랫폼 에서 &lt;em&gt;새&lt;/em&gt; 디렉토리가 이미 존재 하면 &lt;code&gt;renameDirectory&lt;/code&gt; 가 실패 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4cf66c11f13f8d5cfb30fa66ff975ad9d16e7224" translate="yes" xml:space="preserve">
          <source>On Windows XP or earlier systems, junction expansion is not performed due to their lack of &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt;.</source>
          <target state="translated">Windows XP 이하 시스템에서는 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 이 없어 접합 확장이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2645284c47be98a8acf2a83e433b0e66594a2f2" translate="yes" xml:space="preserve">
          <source>On Windows a second wait method can be used to block for event completion. This requires two handles. A process job handle and a events handle to monitor.</source>
          <target state="translated">Windows에서는 두 번째 대기 방법을 사용하여 이벤트 완료를 차단할 수 있습니다. 두 개의 핸들이 필요합니다. 프로세스 작업 핸들 및 모니터링 할 이벤트 핸들.</target>
        </trans-unit>
        <trans-unit id="9658f389cd47e6221668fd22bc06e990b9d9dd68" translate="yes" xml:space="preserve">
          <source>On Windows hs_init treats argv as UTF8-encoded. Passing other encodings might lead to unexpected results. Passing NULL as argv is valid but can lead to &amp;lt;unknown&amp;gt; showing up in error messages instead of the name of the executable.</source>
          <target state="translated">Windows에서 hs_init는 argv를 UTF8로 인코딩 된 것으로 취급합니다. 다른 인코딩을 전달하면 예기치 않은 결과가 발생할 수 있습니다. argv가 유효하지만 NULL을 전달하면 실행 파일 이름 대신 &amp;lt;unknown&amp;gt;이 오류 메시지에 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4698d639ab062d2aed61863bbaa5096920591d6" translate="yes" xml:space="preserve">
          <source>On Windows systems this flag indicates that we should wait for the entire process tree to finish before unblocking. On POSIX systems this flag is ignored. See $exec-on-windows for details.</source>
          <target state="translated">Windows 시스템에서이 플래그는 차단을 해제하기 전에 전체 프로세스 트리가 완료 될 때까지 기다려야 함을 나타냅니다. POSIX 시스템에서이 플래그는 무시됩니다. 자세한 내용은 $ exec-on-windows를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45e04fe208e77db2f230b90c671409e216534e94" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">Windows 시스템에서는 CTRL_BREAK_EVENT를 생성하며 &lt;code&gt;createProcess&lt;/code&gt; 를 사용하여 작성된 프로세스 및 &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 플래그를 설정하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d883d2ded3f33c4ac5277dea1b34c15e47204a0e" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">Windows 시스템에서는 CTRL_BREAK_EVENT를 생성하며 &lt;code&gt;createProcess&lt;/code&gt; 를 사용하여 작성된 프로세스 및 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 플래그를 설정하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1311c5b9754526fe0793423a543b261c1854ae36" translate="yes" xml:space="preserve">
          <source>On Windows systems, this calls &lt;code&gt;DeviceIoControl&lt;/code&gt; with &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also works on junction points. On POSIX systems, this calls &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템에서는 &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt; 를 사용 하여 &lt;code&gt;DeviceIoControl&lt;/code&gt; 을 호출합니다 . 심볼릭 링크 외에도이 기능은 접합점에서도 작동합니다. POSIX 시스템에서는 &lt;code&gt;readlink&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f1567544926c7445013dc0be717298582cb416b6" translate="yes" xml:space="preserve">
          <source>On Windows this has no effect.</source>
          <target state="translated">Windows에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f02d4da8e0b35ffd3d2c36f1392b357f6c5f8d8" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 Windows 명령 인터프리터 ( &lt;code&gt;CMD.EXE&lt;/code&gt; 또는 &lt;code&gt;COMMAND.COM&lt;/code&gt; )로 명령을 전달 하므로 Unixy 쉘 트릭은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48c350060f4cd8913452b9533ace5233eb42f47d" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; usually map to the same directory unless overridden.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; 는 대체되지 않는 한 일반적으로 동일한 디렉토리에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c2a5d7334002daf6e872673bc987f5bdaaf260" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; usually map to the same list of directories unless overridden.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; 는 대체되지 않는 한 일반적으로 동일한 디렉토리 목록에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8b25994ba9790bb8044b9cc7287876fc972fce5c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; calls the Win32 function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt;, which may search other places before checking the directories in the &lt;code&gt;PATH&lt;/code&gt; environment variable. Where it actually searches depends on registry settings, but notably includes the directory containing the current executable.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 Win32 함수 &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 에서 디렉토리를 확인하기 전에 다른 위치를 검색 할 수 있습니다 . 실제로 검색하는 위치는 레지스트리 설정에 따라 다르지만 특히 현재 실행 파일이 들어있는 디렉토리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dca5f3e83bb026318939bea1cd25a1940f11ff0f" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 Windows 명령 인터프리터 ( &lt;code&gt;CMD.EXE&lt;/code&gt; 또는 &lt;code&gt;COMMAND.COM&lt;/code&gt; )로 명령을 전달 하므로 Unixy 쉘 트릭은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df3c28898ffda6729df899cf284892444c82605a" translate="yes" xml:space="preserve">
          <source>On Windows, GHC normally generates a manifestmanifest file when linking a binary. The manifest is placed in the file &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the &amp;ldquo;installer detection&amp;rdquo; in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing &amp;ldquo;install&amp;rdquo;, &amp;ldquo;setup&amp;rdquo; or &amp;ldquo;patch&amp;rdquo;). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</source>
          <target state="translated">Windows에서 GHC는 일반적으로 바이너리를 연결할 때 manifestmanifest 파일을 생성합니다. 매니페스트는 파일 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; 위치합니다. 여기서 ⟨prog.exe⟩는 실행 파일의 이름입니다. 매니페스트 파일은 현재 한 가지 목적으로 만 사용됩니다. Windows Vista에서는 특정 이름 (예 : &quot;install&quot;, &quot;setup&quot;또는 &quot;patch&quot;가 포함 된 이름)을 가진 실행 파일에 대한 권한을 높이려고하는 &quot;설치 프로그램 검색&quot;을 비활성화합니다. 설치 프로그램 검색을 해제 할 매니페스트 파일이 없으면 Windows가 설치 프로그램 인 것으로 간주되는 실행 파일을 실행하려고하면 호출자에게 권한 오류 코드가 반환됩니다. 호출자에 따라 결과에 상승 된 권한을 요청하는 대화 상자가 표시되거나 권한 거부 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3857f1cd71ad0bc38aa45f3e4c0b66be30d8d39f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows의 경우 [1] : &quot;파일 이름이 디스크 지정 자로 만 시작하지만 콜론 뒤의 백 슬래시가 아닌 경우 지정된 문자를 사용하여 드라이브의 현재 디렉토리에 대한 상대 경로로 해석됩니다.&quot; &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00fab97cf532bb811e9f99b70b73e208825c5f0f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows의 경우 [1] : &quot;파일 이름이 디스크 지정 자로 만 시작하지만 콜론 뒤의 백 슬래시가 아닌 경우 지정된 문자를 사용하여 드라이브의 현재 디렉토리에 대한 상대 경로로 해석됩니다.&quot; &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a1fc027f89a30d75d09af18559914b65d210c7f" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows에서 파일 경로가 단일 슬래시로 시작하는 경우 현재 드라이브의 루트에 상대적입니다. [1]에서 이것은 (혼란스럽게) 절대 경로라고합니다. &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c91c78ad4fae4d53474ef709fdcd0ed43c7ee0a9" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows에서 파일 경로가 단일 슬래시로 시작하는 경우 현재 드라이브의 루트에 상대적입니다. [1]에서 이것은 (혼란스럽게) 절대 경로라고합니다. &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d3e5aee2864678aaa60dea89f1461abcedaa812" translate="yes" xml:space="preserve">
          <source>On Windows, it behaves like the Win32 function &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt;, which copies various kinds of metadata including file attributes and security resource properties.</source>
          <target state="translated">Windows에서는 파일 특성 및 보안 자원 특성을 포함하여 다양한 메타 데이터를 복사 하는 Win32 함수 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="abd019f889227ae682d9d79f35737ff6a44be1e1" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission corresponds to the &quot;read-only&quot; attribute. The &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; permission is set if the file extension is of an executable file type. The &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; permission is always set.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 권한은 &quot;읽기 전용&quot;속성에 해당합니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; 파일 확장명이 실행 파일 형식 인 경우 권한이 설정됩니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; 권한이 항상 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a82573349a58df428e5cf8f04f5449302de59c8f" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;^Z&lt;/code&gt; character is interpreted as an end-of-file character, so if you read a file containing this character the file will appear to end just before it. To avoid this, use &lt;code&gt;IOExts.openFileEx&lt;/code&gt; to open a file in binary (untranslated) mode or change an already opened file handle into binary mode using &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt;. The &lt;code&gt;IOExts&lt;/code&gt; module is part of the &lt;code&gt;lang&lt;/code&gt; package.</source>
          <target state="translated">Windows에서 &lt;code&gt;^Z&lt;/code&gt; 문자는 파일 끝 문자로 해석 되므로이 문자가 포함 된 파일을 읽으면 파일이 바로 앞에있는 것으로 나타납니다. 이를 방지하려면 &lt;code&gt;IOExts.openFileEx&lt;/code&gt; 를 사용하여 파일을 2 진 (번역되지 않은) 모드로 열거 나 이미 열린 파일 핸들을 &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt; 를 사용하여 2 진 모드로 변경 하십시오 . &lt;code&gt;IOExts&lt;/code&gt; 의 모듈의 일부 &lt;code&gt;lang&lt;/code&gt; 패키지.</target>
        </trans-unit>
        <trans-unit id="f4e0faedb7eb77e9f9303b4aee6bff531c17eba6" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt; with &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is also included if supported by the operating system. On POSIX, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">Windows &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt; 기능은 SYMBOLIC_LINK_FLAG_DIRECTORY 와 함께 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 를 사용하여 구현됩니다 . 1.3.3.0부터 운영 체제에서 지원하는 경우 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 플래그도 포함됩니다. POSIX에서 이것은 &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; 의 별명 이므로 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="a5bae1c687cf11ec3ed5ad2f9f8ff005ae0b6dfc" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is included if supported by the operating system. On POSIX, the function uses &lt;code&gt;symlink&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">Windows에서 함수는 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 를 사용하여 구현됩니다 . 1.3.3.0부터 운영 체제에서 지원하는 경우 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 플래그가 포함됩니다. POSIX에서 함수는 &lt;code&gt;symlink&lt;/code&gt; 를 사용 하므로 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="e855d866abccd89156106ea9ff5c5937f3c49ead" translate="yes" xml:space="preserve">
          <source>On Windows, the operation fails if &lt;em&gt;dir&lt;/em&gt; is a directory symbolic link.</source>
          <target state="translated">Windows에서 &lt;em&gt;dir&lt;/em&gt; 이 디렉토리 기호 링크 인 경우 조작이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e44cd211b73577bb580283a31fe9e11ec9d0f8fb" translate="yes" xml:space="preserve">
          <source>On Windows, the path is &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;)</source>
          <target state="translated">Windows에서 경로는 &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f11f1f05f568d29a8830243c65984fa477970a3c" translate="yes" xml:space="preserve">
          <source>On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 시스템은 적절한 경로를 조회합니다. 일반적인 경로는 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3e77adec84060bc903e2e912e15d0de80cff520" translate="yes" xml:space="preserve">
          <source>On Windows, there&amp;rsquo;s a GNU ld/BFD bug whereby it emits bogus PE object files that have more than 0xffff relocations. When GHCi tries to load a package affected by this bug, you get an error message of the form</source>
          <target state="translated">Windows에는 GNU ld / BFD 버그가있어 0xffff 재배치 이상의 가짜 PE 개체 파일을 생성합니다. GHCi가이 버그의 영향을받는 패키지를로드하려고하면 다음과 같은 형식의 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="85e22f23309dbf90a94129f8db64b297cbb2f916" translate="yes" xml:space="preserve">
          <source>On Windows, this &lt;em&gt;only returns the first ocurrence&lt;/em&gt;, if any. Its behavior is therefore equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;em&gt;첫 번째 발생 만 리턴합니다 (있는&lt;/em&gt; 경우). 따라서 동작은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="da36f078a8e10da6023ea1ab8024e74f1183e975" translate="yes" xml:space="preserve">
          <source>On Windows, this checks for &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also returns true on junction points. On POSIX systems, this checks for &lt;code&gt;S_IFLNK&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 를 확인합니다 . 심볼릭 링크 외에도이 함수는 접합점에서 true를 반환합니다. POSIX 시스템에서는 &lt;code&gt;S_IFLNK&lt;/code&gt; 를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="52cfb4329fc32c0d833a61183ba7721cc4129515" translate="yes" xml:space="preserve">
          <source>On Windows, this copies only the read-only attribute.</source>
          <target state="translated">Windows에서는 읽기 전용 속성 만 복사합니다.</target>
        </trans-unit>
        <trans-unit id="ed105f70828ccfdebad6090636cb8dc84666d5c9" translate="yes" xml:space="preserve">
          <source>On Windows, this encoding *should not* be used if possible because the use of code pages is deprecated: Strings should be retrieved via the &quot;wide&quot; W-family of UTF-16 APIs instead</source>
          <target state="translated">Windows에서는 코드 페이지 사용이 더 이상 사용되지 않으므로 가능한 경우이 인코딩을 사용해서는 안됩니다 * : 대신 &quot;와이드&quot;W 계열 UTF-16 API를 통해 문자열을 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac2cd505b24931f86258fdc4d09b1d6d6f31c478" translate="yes" xml:space="preserve">
          <source>On Windows, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt;. On POSIX systems, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 이는 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . POSIX 시스템에서 이는 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="721f4605ef1d86ca2dde42c37a045d3e3a154879" translate="yes" xml:space="preserve">
          <source>On Windows, this is only capable of changing the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission, which corresponds to the &quot;read-only&quot; attribute. Changing the other permissions has no effect.</source>
          <target state="translated">Windows에서는 &quot;읽기 전용&quot;속성에 해당하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 권한 만 변경할 수 있습니다. 다른 권한을 변경해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b5fedbf70c277d93381f0f283d73b921d80d6e3" translate="yes" xml:space="preserve">
          <source>On Windows, you can access supported code pages with the prefix &lt;code&gt;CP&lt;/code&gt;; for example, &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;CP&lt;/code&gt; 접두어를 사용하여 지원되는 코드 페이지에 액세스 할 수 있습니다 . 예를 들어 &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcbabe85dcb1f0f6be8be76732501ee39274fba1" translate="yes" xml:space="preserve">
          <source>On a 64-bit platform it is not always possible to acquire the top 64 bits of the result. Therefore, a recommended implementation is to take the absolute value of both operands, and return 0 iff bits[63:31] of them are zero, since that means that their magnitudes fit within 31 bits, so the magnitude of the product must fit into 62 bits.</source>
          <target state="translated">64 비트 플랫폼에서 결과의 상위 64 비트를 항상 획득 할 수있는 것은 아닙니다. 따라서 권장되는 구현은 두 피연산자의 절대 값을 가져오고 0 iff 비트 [63:31]를 0으로 리턴하는 것입니다. 즉, 크기가 31 비트 내에 들어가므로 제품의 크기가 62 비트</target>
        </trans-unit>
        <trans-unit id="ca55a4a165c97ee87021e748a5999af653eb1351" translate="yes" xml:space="preserve">
          <source>On a Core2 Duo 2.20GHz on a 32-bit Linux, the above code takes 1ms to generate the 22'500 bytes long lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Looking again at the definitions above, we see that we took care to avoid intermediate data structures, as otherwise we would sacrifice performance. For example, the following (arguably simpler) definition of &lt;code&gt;renderRow&lt;/code&gt; is about 20% slower.</source>
          <target state="translated">32 비트 Linux의 Core2 Duo 2.20GHz에서 위의 코드는 22'500 바이트 길이의 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성하는 데 1ms가 걸립니다 . 위의 정의를 다시 살펴보면 중간 데이터 구조를 피하기 위해주의를 기울였습니다. 그렇지 않으면 성능이 저하됩니다. 예를 들어, 다음의 &lt;code&gt;renderRow&lt;/code&gt; 정의는 20 % 정도 느립니다.</target>
        </trans-unit>
        <trans-unit id="c8a5a9af1eb8c360fd6ffff320585505f281c939" translate="yes" xml:space="preserve">
          <source>On both reading and writing, the platform's native newline conversion is performed.</source>
          <target state="translated">읽기와 쓰기 모두에서 플랫폼의 기본 개행 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="584fe990b6c406c5750b476c119e0a10d54a8c7d" translate="yes" xml:space="preserve">
          <source>On most UNIX platforms it is also possible to build executables that can be &lt;code&gt;dlopen&lt;/code&gt;&amp;lsquo;d like shared libraries using the &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt; flag during linking.</source>
          <target state="translated">대부분의 UNIX 플랫폼에서는 링크하는 동안 &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 공유 라이브러리처럼 &lt;code&gt;dlopen&lt;/code&gt; 할 수있는 실행 파일을 빌드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3ecb7f7003c5f8586cd3273747fd5240fdd03f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows 이외의 플랫폼에서 동작은 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 검색 디렉토리를 사용하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 의 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fb6c020bc093fa27959e91b43bb2cec678d112f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows 이외의 플랫폼에서 동작은 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 검색 디렉토리를 사용하고 각 파일에서 실행 권한을 테스트 하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8188af56fd6edcf23beb2e9dcf2382a4e4902ffd" translate="yes" xml:space="preserve">
          <source>On program termination, the standard &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; are flushed automatically; any other buffered &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s need to be flushed manually, otherwise the buffered data will be discarded.</source>
          <target state="translated">프로그램 종료시 표준 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; s &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 가 자동으로 플러시됩니다. 버퍼링 된 다른 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 수동으로 플러시해야합니다. 그렇지 않으면 버퍼링 된 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b458bc64e60c4d81db682d145a7fc32242bb3944" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe7652641a4b092db3389c67281410748d6204c1" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c440936ef0fa8d5c9fb4a5252385fb1aecb976b4" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="15cb1a56421815ce54b1980f31648be5dff8f144" translate="yes" xml:space="preserve">
          <source>On some platforms GHC supports building Haskell code into shared libraries. Shared libraries are also sometimes known as dynamic libraries, in particular on Windows they are referred to as dynamic link libraries (DLLs).</source>
          <target state="translated">일부 플랫폼에서 GHC는 공유 라이브러리에 Haskell 코드 작성을 지원합니다. 공유 라이브러리는 동적 라이브러리라고도하며, 특히 Windows에서는 동적 링크 라이브러리 (DLL)라고합니다.</target>
        </trans-unit>
        <trans-unit id="8eb8ce4db21a6bb265eeec2e7b65240ba8199bdd" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.dll&lt;/code&gt;-style shared libraries, the actual library loaded will be &lt;code&gt;lib.dll&lt;/code&gt;, &lt;code&gt;liblib.dll&lt;/code&gt;. GHCi also has full support for import libraries, either Microsoft style &lt;code&gt;.lib&lt;/code&gt;, or GNU GCC style &lt;code&gt;.a&lt;/code&gt; and &lt;code&gt;.dll.a&lt;/code&gt; libraries. If you have an import library it is advisable to always specify the import libary instead of the &lt;code&gt;.dll&lt;/code&gt;. e.g. use &lt;code&gt;-lgcc` instead of
``-llibgcc_s_seh-1&lt;/code&gt;. Again, GHCi will signal an error if it can&amp;rsquo;t find the library.</source>
          <target state="translated">&lt;code&gt;.dll&lt;/code&gt; 스타일 공유 라이브러리가있는 시스템에서 로드 된 실제 라이브러리는 &lt;code&gt;lib.dll&lt;/code&gt; , &lt;code&gt;liblib.dll&lt;/code&gt; 입니다. GHCi는 또한 가져 오기 라이브러리 (Microsoft 스타일 &lt;code&gt;.lib&lt;/code&gt; 또는 GNU GCC 스타일 &lt;code&gt;.a&lt;/code&gt; 및 &lt;code&gt;.dll.a&lt;/code&gt; 라이브러리) 를 완벽하게 지원합니다 . 가져 오기 라이브러리가있는 경우 항상 &lt;code&gt;.dll&lt;/code&gt; 대신 가져 오기 라이브러리를 지정하는 것이 좋습니다 . 예를 들어 &lt;code&gt;-lgcc` instead of ``-llibgcc_s_seh-1&lt;/code&gt; 사용 하십시오 . 다시 말하지만, GHCi는 라이브러리를 찾을 수 없으면 오류를 알립니다.</target>
        </trans-unit>
        <trans-unit id="79878901a3ff26ad9bef6e39ce6be8f5fbd886f1" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.so&lt;/code&gt;-style shared libraries, the actual library loaded will the &lt;code&gt;liblib.so&lt;/code&gt;. GHCi searches the following places for libraries, in this order:</source>
          <target state="translated">&lt;code&gt;.so&lt;/code&gt; 스타일 공유 라이브러리가있는 시스템에서 로드 된 실제 라이브러리는 &lt;code&gt;liblib.so&lt;/code&gt; 입니다. GHCi는 다음 위치에서 라이브러리를 순서대로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0fdf7f76740d047b5e3edd87cc87a6a11d2158f4" translate="yes" xml:space="preserve">
          <source>On the World-Wide Web, there are several URLs of likely interest:</source>
          <target state="translated">월드 와이드 웹에는 다음과 같은 몇 가지 URL이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05a6ef32800b6777916856b927d4f8bd9b77ba3" translate="yes" xml:space="preserve">
          <source>On the left or right (see &lt;code&gt;f4&lt;/code&gt;, for example) of a function arrow</source>
          <target state="translated">기능 화살표 의 왼쪽 또는 오른쪽 ( 예 : &lt;code&gt;f4&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="4f305cc5e3cb7028da9ff3cbac52003a8cb62b20" translate="yes" xml:space="preserve">
          <source>On the other hand, a derived &lt;code&gt;Functor&lt;/code&gt; instances for the &lt;code&gt;CovFun&lt;/code&gt;s are within the realm of possibility:</source>
          <target state="translated">반면 &lt;code&gt;CovFun&lt;/code&gt; 의 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스 는 가능한 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0c7bdbeeec14950364d5eba585fee5f46490af7" translate="yes" xml:space="preserve">
          <source>On the other hand, function &lt;code&gt;g&lt;/code&gt; works fine, because matching against &lt;code&gt;P2&lt;/code&gt; (which wraps the GADT &lt;code&gt;S&lt;/code&gt;) provides the local equality &lt;code&gt;(a~Bool)&lt;/code&gt;. If you were to give an explicit pattern signature &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt;, then &lt;code&gt;P2&lt;/code&gt; would become less polymorphic, and would behave exactly like &lt;code&gt;P1&lt;/code&gt; so that &lt;code&gt;g&lt;/code&gt; would then be rejected.</source>
          <target state="translated">반면 &lt;code&gt;P2&lt;/code&gt; (GADT &lt;code&gt;S&lt;/code&gt; 를 감싸는 )에 대한 일치는 로컬 평등 &lt;code&gt;(a~Bool)&lt;/code&gt; 제공 하기 때문에 함수 &lt;code&gt;g&lt;/code&gt; 는 제대로 작동합니다 . 명시 적 패턴 시그니처 &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt; 을 제공하면 &lt;code&gt;P2&lt;/code&gt; 가 덜 다형성이되고 &lt;code&gt;P1&lt;/code&gt; 과 똑같이 동작 하여 &lt;code&gt;g&lt;/code&gt; 가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="42d363a29721400db631067ea9cb7bd7ce4d4eea" translate="yes" xml:space="preserve">
          <source>On this score, GHC usually does pretty well, especially if you &amp;ldquo;allow&amp;rdquo; it to be off by one or two. In the case of an instance or class declaration, the line number may only point you to the declaration, not to a specific method.</source>
          <target state="translated">이 점수에서 GHC는 일반적으로 아주 잘 작동합니다. 특히 한두 가지씩&amp;ldquo;허용&amp;rdquo;할 경우 더욱 그렇습니다. 인스턴스 또는 클래스 선언의 경우 행 번호는 특정 메소드가 아니라 선언만을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea755dd39d492e55b9e34b0a111d2cfb8276cb3" translate="yes" xml:space="preserve">
          <source>On transcoding errors, an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; exception is thrown. You can use the API in &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; if you need more control over error handling or transcoding.</source>
          <target state="translated">트랜스 코딩 오류에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 예외가 발생합니다. 오류 처리 또는 코드 변환에 대한 추가 제어가 필요한 경우 &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; 에서 API를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56b1aac7c401101a39c4f55a428919092262060c" translate="yes" xml:space="preserve">
          <source>OnDecodeError</source>
          <target state="translated">OnDecodeError</target>
        </trans-unit>
        <trans-unit id="6f666943e43935b64269246162dcf5a1465ea5ff" translate="yes" xml:space="preserve">
          <source>OnEncodeError</source>
          <target state="translated">OnEncodeError</target>
        </trans-unit>
        <trans-unit id="1ec9c77019b9c571c284d11d62850d0be7f7d725" translate="yes" xml:space="preserve">
          <source>OnError</source>
          <target state="translated">OnError</target>
        </trans-unit>
        <trans-unit id="ed0ab25823975d83734fae1b6bd16e05190469eb" translate="yes" xml:space="preserve">
          <source>Once EOF is encountered, the Handle is closed.</source>
          <target state="translated">EOF가 발생하면 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="60e264a17495d5948da3fde8b611b62bef7e4a18" translate="yes" xml:space="preserve">
          <source>Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed. The contents of this final list is only partially specified: it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed.</source>
          <target state="translated">반 닫힌 핸들이 닫히면 관련 목록의 내용이 고정됩니다. 이 최종 목록의 내용은 부분적으로 만 지정됩니다. 핸들이 닫히기 전에 평가 된 스트림의 모든 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6cef81242bdb3dd15794848f47ffe89e35f13fea" translate="yes" xml:space="preserve">
          <source>Once again, the profiling facilities (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;) are the basic tool for demystifying the space behaviour of your program.</source>
          <target state="translated">다시 한 번, 프로파일 링 기능 ( &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; )은 프로그램의 공간 동작을 이해하기위한 기본 도구입니다.</target>
        </trans-unit>
        <trans-unit id="ffc00d55d5cade6b9732f3047fd68f9150e53462" translate="yes" xml:space="preserve">
          <source>Once the user declares type family to be injective GHC must verify that this declaration is correct, ie. type family equations don&amp;rsquo;t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way user claims and an error is reported. In the bullets below &lt;em&gt;RHS&lt;/em&gt; refers to the right-hand side of the type family equation being checked for injectivity. &lt;em&gt;LHS&lt;/em&gt; refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</source>
          <target state="translated">사용자가 타입 패밀리를 인젝 티브로 선언하면 GHC는이 선언이 올바른지 확인해야합니다. 타입 패밀리 방정식은 주입 주석을 위반하지 않습니다. 일반적인 아이디어는 적어도 하나의 방정식 (아래의 (1), (2) 및 (3)) 또는 한 쌍의 방정식 (아래의 (4) 및 (5))이 주입 주석을 위반하면 유형 군이 사용자가 주장하는 방식으로 주입하지 않고 오류가보고됩니다. 아래의 글 머리 기호에서 &lt;em&gt;RHS&lt;/em&gt; 는 주사율을 검사 할 유형 패밀리 방정식의 오른쪽을 나타냅니다. &lt;em&gt;LHS&lt;/em&gt; 는 해당 유형 패밀리 방정식의 인수를 나타냅니다. 다음은 유형 군의 주사율을 확인할 때 따라야 할 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="c50b67bca5fb4c6603a23fdfb82c3d73e171c099" translate="yes" xml:space="preserve">
          <source>Once you have a library of GHCi macros, you may want to source them from separate files, or you may want to source your &lt;code&gt;.ghci&lt;/code&gt; file into your running GHCi session while debugging it</source>
          <target state="translated">GHCi 매크로 라이브러리가 있으면 별도의 파일에서 소스를 제공하거나 디버깅하는 동안 실행중인 GHCi 세션에 &lt;code&gt;.ghci&lt;/code&gt; 파일 을 소스로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7e950f611ffeefb5dc8da946a455d9ce68ff45" translate="yes" xml:space="preserve">
          <source>Once you know the producer or the type of the heap in the drag or void states, the next step is usually to find the retainer(s):</source>
          <target state="translated">드래그 또는 빈 상태에서 생산자 또는 힙 유형을 알면 다음 단계는 일반적으로 리테이너를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="68e926d9c748359a8152a413a626288e329b3079" translate="yes" xml:space="preserve">
          <source>One can then use functions from &lt;code&gt;GHC.Stack&lt;/code&gt; to inspect or pretty print (as is done in &lt;code&gt;f&lt;/code&gt; below) the call stack.</source>
          <target state="translated">그런 다음 &lt;code&gt;GHC.Stack&lt;/code&gt; 의 기능을 사용 하여 호출 스택 을 검사하거나 인쇄 할 수 있습니다 ( 아래 &lt;code&gt;f&lt;/code&gt; 에서 수행됨 ).</target>
        </trans-unit>
        <trans-unit id="4023758f19beece83257d349668ba73b4a5f55d3" translate="yes" xml:space="preserve">
          <source>One can think of this instance being implemented with the same code as the &lt;code&gt;Num Int&lt;/code&gt; instance, but with &lt;code&gt;Dollars&lt;/code&gt; and &lt;code&gt;getDollars&lt;/code&gt; added wherever necessary in order to make it typecheck. (In practice, GHC uses a somewhat different approach to code generation. See the &lt;a href=&quot;#precise-gnd-specification&quot;&gt;A more precise specification&lt;/a&gt; section below for more details.)</source>
          <target state="translated">이 인스턴스가 &lt;code&gt;Num Int&lt;/code&gt; 인스턴스 와 동일한 코드로 구현되었다고 생각할 수 있지만 , &lt;code&gt;getDollars&lt;/code&gt; 를 위해 필요한 곳에 &lt;code&gt;Dollars&lt;/code&gt; 와 getDollars가 추가되었습니다. (실제로 GHC는 약간 다른 코드 생성 방식을 사용합니다. 자세한 내용은 아래 &lt;a href=&quot;#precise-gnd-specification&quot;&gt;의 더 정확한 사양&lt;/a&gt; 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="9743b7636df84ead47845f240cbbd477f19f70e0" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">리스트에서 (안전하게) 작동하는 함수와 결합 될 때 패턴 일치를 피하기 위해 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec55bf61d8ab5d04d04ebcb2ee2159a392ea14e" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">리스트에서 (안전하게) 작동하는 함수와 결합 될 때 패턴 일치를 피하기 위해 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d9ffa5463e1c26285c5e33a8e8a9504fd92ef8" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;-XEmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">Haskell 2010에서는 기본적으로 켜져 있는 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;-XEmptyDataDecls&lt;/code&gt; &lt;/a&gt; 플래그 ( &lt;a href=&quot;#nullary-types&quot;&gt;생성자가없는 데이터 유형&lt;/a&gt; 참조)를 사용하여 생성자가없는 데이터 유형을 작성할 수 있습니다 . 기본적으로 설정되지 않은 것은 이러한 유형에 대한 유형 클래스 인스턴스를 파생시키는 기능입니다. 이 기능은 &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 사용 가능합니다 . 예를 들어 다음과 같이 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3d496c6b9647ae6150efda24096b39fcf9eb1a86" translate="yes" xml:space="preserve">
          <source>One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the &lt;code&gt;Prelude&lt;/code&gt; and standard libraries such as &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt;. If you attempt to load a module for which GHCi can&amp;rsquo;t find a source file, even if there are object and interface files for the module, you&amp;rsquo;ll get an error message.</source>
          <target state="translated">GHCi가로드 할 모듈을 찾기 위해 종속성을 따르는 방식의 한 가지 결과는 모든 모듈에 소스 파일이 있어야한다는 것입니다. 규칙의 유일한 예외는 &lt;code&gt;Prelude&lt;/code&gt; 및 &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;Complex&lt;/code&gt; 와 같은 표준 라이브러리를 포함하여 패키지에서 제공되는 모듈입니다 . GHCi가 소스 파일을 찾을 수없는 모듈을로드하려고하면 모듈에 대한 객체 및 인터페이스 파일이 있어도 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5483c77e4f829cc17d6601c4ac4404068ce5302b" translate="yes" xml:space="preserve">
          <source>One could either pick the &lt;code&gt;DeriveAnyClass&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt; or the &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt;, both of which would be equally as valid. GHC defaults to favoring &lt;code&gt;DeriveAnyClass&lt;/code&gt; in such a dispute, but this is not a satisfying solution, since that leaves users unable to use both language extensions in a single module.</source>
          <target state="translated">하나는 중 하나를 선택할 수 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 의 유도에 접근 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 의 유도에 접근 &lt;code&gt;C&lt;/code&gt; 를 동등하게 유효한 것으로 될 것이다 둘을. GHC는 기본적으로 이러한 분쟁에서 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를 선호 하지만 사용자가 단일 모듈에서 두 가지 언어 확장을 사용할 수 없기 때문에 만족스러운 해결책이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="07da619a058ee72f68e35cbedda9fed2d2008eeb" translate="yes" xml:space="preserve">
          <source>One day in &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 에서 하루 .</target>
        </trans-unit>
        <trans-unit id="3d64ec6630f50a5fa3cc17dae6e273e1017ecb35" translate="yes" xml:space="preserve">
          <source>One equation of a type family instance or closed type family. The arguments are the left-hand-side type and the right-hand-side result.</source>
          <target state="translated">유형 패밀리 인스턴스 또는 닫힌 유형 패밀리의 하나의 방정식. 인수는 왼쪽 유형과 오른쪽 결과입니다.</target>
        </trans-unit>
        <trans-unit id="8ad7e9507f922f5c3971e0839b353cb5b01d4c7f" translate="yes" xml:space="preserve">
          <source>One final note: the &lt;code&gt;aaaa&lt;/code&gt;&lt;code&gt;bbbb&lt;/code&gt; example may not work too well on GHC (see Scheduling, above), due to the locking on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. Only one thread may hold the lock on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; at any one time, so if a reschedule happens while a thread is holding the lock, the other thread won't be able to run. The upshot is that the switch from &lt;code&gt;aaaa&lt;/code&gt; to &lt;code&gt;bbbbb&lt;/code&gt; happens infrequently. It can be improved by lowering the reschedule tick period. We also have a patch that causes a reschedule whenever a thread waiting on a lock is woken up, but haven't found it to be useful for anything other than this example :-)</source>
          <target state="translated">마지막 참고 사항 : &lt;code&gt;aaaa&lt;/code&gt; &lt;code&gt;bbbb&lt;/code&gt; 예제는 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 잠금으로 인해 GHC에서 너무 잘 작동하지 않을 수 있습니다 (위의 일정 참조) . 하나 개의 쓰레드가의 잠금 보유 할 수 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 일정 조정이 스레드가 잠금을 보유하는 동안, 다른 스레드를 실행할 수 없습니다 발생 그렇다면, 한 번에. 결론은 &lt;code&gt;aaaa&lt;/code&gt; 에서 &lt;code&gt;bbbbb&lt;/code&gt; 로의 전환이 드물게 발생 한다는 것입니다 . 일정 변경 시간을 줄임으로써 개선 할 수 있습니다. 또한 잠금 대기중인 스레드가 깨어날 때마다 일정을 변경하는 패치가 있지만이 예제 이외의 다른 용도로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ea55d691054154f178c4188946d4c03f7e9c26" translate="yes" xml:space="preserve">
          <source>One of these new quantified constraints can appear anywhere that any other constraint can, not just in instance declarations. Notably, it can appear in a type signature for a value binding, data constructor, or expression. For example</source>
          <target state="translated">이러한 새로운 정량화 된 제약 조건 중 하나는 인스턴스 선언뿐만 아니라 다른 제약 조건이 가능한 모든 위치에 나타날 수 있습니다. 특히 값 바인딩, 데이터 생성자 또는 식에 대한 형식 서명으로 나타날 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="61fc274a467ee7617c4b73c08349e4d3c37da810" translate="yes" xml:space="preserve">
          <source>One or more.</source>
          <target state="translated">하나 이상.</target>
        </trans-unit>
        <trans-unit id="4b9e1cd86b2ee828fde7016484a1c36fb1da2c89" translate="yes" xml:space="preserve">
          <source>One or none.</source>
          <target state="translated">하나도 아니고</target>
        </trans-unit>
        <trans-unit id="2e17f5233f1634abadabdb2fd410bbc1afa1bc70" translate="yes" xml:space="preserve">
          <source>One simplification allowed by combining types and kinds is that the type of &lt;code&gt;Type&lt;/code&gt; is just &lt;code&gt;Type&lt;/code&gt;. It is true that the &lt;code&gt;Type :: Type&lt;/code&gt; axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) &lt;em&gt;does&lt;/em&gt; mean that despite the expressiveness of GHC&amp;rsquo;s type system, a &amp;ldquo;proof&amp;rdquo; you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.</source>
          <target state="translated">유형과 종류를 결합하여 허용되는 한 가지 단순화는 유형의 &lt;code&gt;Type&lt;/code&gt; 이 단지 &lt;code&gt;Type&lt;/code&gt; 입니다. 사실이다 &lt;code&gt;Type :: Type&lt;/code&gt; 공리가 아닌 종료 될 수 있지만, 우리는 이미 형식과 표현 모두 종료되지 않는 프로그램의 다른 수단을 가지고이, GHC에서 문제가되지 않습니다. 이 결정 (많은 다른 많은 것 중에서도) &lt;em&gt;은&lt;/em&gt; GHC 유형 시스템의 표현성에도 불구하고 하스켈에서 작성하는&amp;ldquo;증거&amp;rdquo;는 반박 할 수없는 수학적 증거가 아님을 의미합니다. GHC는 부분적으로 만 정확성을 약속합니다. 프로그램이 컴파일되고 완료되면 결과에 실제로 유형이 지정됩니다. 유한 한 시간 안에 끝나지 않는 프로그램에 대해서는 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04e45da5d15f7b84f75303b148b0c58446719a7a" translate="yes" xml:space="preserve">
          <source>One solution would be to represent an occurrence of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; with 'Rec0 Int' instead. With this approach, however, the programmer has no way of knowing whether the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is actually an &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; in disguise.</source>
          <target state="translated">한 가지 해결책은 대신 'Rec0 Int'를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 의 발생을 나타내는 것입니다. 그러나이 방법을 사용하면 프로그래머는 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가 실제로 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 인지를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="71086252ab12cdaa049eefe6701cf95f5fcaa5cf" translate="yes" xml:space="preserve">
          <source>One stylistic reason for wanting to write a type signature is simple documentation. Another is that you may want to bring scoped type variables into scope. For example:</source>
          <target state="translated">형식 서명을 작성하려는 스타일 중 하나는 간단한 문서입니다. 또 다른 방법은 범위가 지정된 유형 변수를 범위로 가져올 수 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45133c20fc7ccdca10220b7b14632f7d9475ba07" translate="yes" xml:space="preserve">
          <source>One time when &lt;code&gt;Float&lt;/code&gt; might be a good idea is if you have a &lt;em&gt;lot&lt;/em&gt; of them, say a giant array of &lt;code&gt;Float&lt;/code&gt;s. They take up half the space in the heap compared to &lt;code&gt;Doubles&lt;/code&gt;. However, this isn&amp;rsquo;t true on a 64-bit machine.</source>
          <target state="translated">한 시간 &lt;code&gt;Float&lt;/code&gt; 좋은 생각이 될 수도 당신이있는 경우입니다 &lt;em&gt;많은&lt;/em&gt; 이들의를,의 거대한 배열 말 &lt;code&gt;Float&lt;/code&gt; 들. 그들은 &lt;code&gt;Doubles&lt;/code&gt; 에 비해 힙 공간의 절반을 차지합니다 . 그러나 64 비트 시스템에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a12bfceb7507e74d1f52bf5268e41928d787ee56" translate="yes" xml:space="preserve">
          <source>One way out is to define an extended &lt;code&gt;assert&lt;/code&gt; function which also takes a descriptive string to include in the error message and perhaps combine this with the use of a pre-processor which inserts the source location where &lt;code&gt;assert&lt;/code&gt; was used.</source>
          <target state="translated">한 가지 방법 은 오류 메시지에 포함 할 설명 문자열 을 사용하는 확장 된 &lt;code&gt;assert&lt;/code&gt; 함수 를 정의하고 이를 &lt;code&gt;assert&lt;/code&gt; 가 사용 된 소스 위치를 삽입하는 전 처리기의 사용과 결합하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fc58693ff257f4600136a2111c4960ba6926b129" translate="yes" xml:space="preserve">
          <source>One way to do this is to create a &lt;code&gt;foreign export&lt;/code&gt; that will do whatever needs to be done to wake up the Haskell thread - perhaps &lt;code&gt;putMVar&lt;/code&gt; - and then call this from our C callback. There are a couple of problems with this:</source>
          <target state="translated">이를 수행하는 한 가지 방법 은 Haskell 스레드 (아마 &lt;code&gt;putMVar&lt;/code&gt; ) 를 깨우기 위해 수행해야하는 모든 작업을 수행 하는 &lt;code&gt;foreign export&lt;/code&gt; 를 생성 한 다음 C 콜백에서 호출하는 것입니다. 이것에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="896496c9fe69e79ba2c5e72301d3696844b503d6" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; 을 사용하는 한 가지 방법 은 특수 함수 &lt;code&gt;inline&lt;/code&gt; ( &lt;a href=&quot;#special-ids&quot;&gt;특수 내장 함수&lt;/a&gt; ) 과 함께 사용하는 것 입니다 . 콜 &lt;code&gt;inline f&lt;/code&gt; 인라인에 열심히하려고 &lt;code&gt;f&lt;/code&gt; . 있는지 확인하기 위해 &lt;code&gt;f&lt;/code&gt; 는 인라인 할 수 있습니다,의 정의를 표시하는 좋은 아이디어입니다 &lt;code&gt;f&lt;/code&gt; 로 &lt;code&gt;INLINABLE&lt;/code&gt; 을 GHC는 그것이 얼마나 큰 상관없이 전개 노출 보장 그래서. 또한, &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;INLINABLE&lt;/code&gt; 로 주석 을 달면 임의의 최적화 된 &lt;code&gt;f&lt;/code&gt; GHC 옵티 마이저 버전이 아닌 &lt;code&gt;f&lt;/code&gt; 의 원래 RHS가 인라인 되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="4dba5747f4551a506f4292cb3c2030f7b24af891" translate="yes" xml:space="preserve">
          <source>One way to use this flag is to set a breakpoint on &lt;code&gt;LongGCSync()&lt;/code&gt; in the debugger, and find the thread that is delaying the sync. You probably want to use &lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt;&lt;code&gt;-g&lt;/code&gt;&lt;/a&gt; to provide more info to the debugger.</source>
          <target state="translated">이 플래그를 사용하는 한 가지 방법 은 디버거에서 &lt;code&gt;LongGCSync()&lt;/code&gt; 에 중단 점을 설정 하고 동기화를 지연시키는 스레드를 찾는 것입니다. 디버거에 더 많은 정보를 제공 하기 위해 &lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt; &lt;code&gt;-g&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c680b63b6bef62589b5937a565537e66960d46" translate="yes" xml:space="preserve">
          <source>One workaround is to use the &lt;a href=&quot;using#ghc-flag--msse2&quot;&gt;&lt;code&gt;-msse2&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;using#options-platform&quot;&gt;Platform-specific Flags&lt;/a&gt;), which generates code to use the SSE2 instruction set instead of the x87 instruction set. SSE2 code uses the correct precision for all floating-point operations, and so gives deterministic results. However, note that this only works with processors that support SSE2 (Intel Pentium 4 or AMD Athlon 64 and later), which is why the option is not enabled by default. The libraries that come with GHC are probably built without this option, unless you built GHC yourself.</source>
          <target state="translated">한 가지 해결 방법은 &lt;a href=&quot;using#ghc-flag--msse2&quot;&gt; &lt;code&gt;-msse2&lt;/code&gt; &lt;/a&gt; 명령어 세트 대신 SSE2 명령어 세트를 사용하는 코드를 생성 하는 -msse2 옵션 ( &lt;a href=&quot;using#options-platform&quot;&gt;플랫폼 별 플래그&lt;/a&gt; 참조 )을 사용하는 것입니다. SSE2 코드는 모든 부동 소수점 연산에 올바른 정밀도를 사용하므로 결정적인 결과를 제공합니다. 그러나 이는 SSE2 (Intel Pentium 4 또는 AMD Athlon 64 이상)를 지원하는 프로세서에서만 작동하므로이 옵션은 기본적으로 활성화되어 있지 않습니다. GHC와 함께 제공되는 라이브러리는 GHC를 직접 빌드하지 않는 한이 옵션없이 빌드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dfc86abc6a3fb1a97eebda069c8175f292ebd73" translate="yes" xml:space="preserve">
          <source>OneLineGCStats</source>
          <target state="translated">OneLineGCStats</target>
        </trans-unit>
        <trans-unit id="927d5cf27de83f9a93bc0c43d5e9992d0e575568" translate="yes" xml:space="preserve">
          <source>OneLineMode</source>
          <target state="translated">OneLineMode</target>
        </trans-unit>
        <trans-unit id="293e0ad51fda89c714a301db9fbb3d1d9e6c34d7" translate="yes" xml:space="preserve">
          <source>OneShot</source>
          <target state="translated">OneShot</target>
        </trans-unit>
        <trans-unit id="92340949cbfd5f6b38df2be19df951ad335baa8c" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;dynamic&lt;/em&gt; flags can be used in an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma 에는 &lt;em&gt;동적&lt;/em&gt; 플래그 만 사용할 수 있습니다 ( &lt;a href=&quot;#mode-dynamic-flags&quot;&gt;동적 및 모드 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5805ff05f15235a01101ac5b0cf4fe9284ddd19e" translate="yes" xml:space="preserve">
          <source>Only a subset of &lt;code&gt;.hsc&lt;/code&gt; syntax is supported by &lt;code&gt;--cross-compile&lt;/code&gt;. The following are unsupported:</source>
          <target state="translated">&lt;code&gt;--cross-compile&lt;/code&gt; 은 &lt;code&gt;.hsc&lt;/code&gt; 구문 의 하위 집합 만 지원합니다 . 다음은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c7ea9b4b424e7701e19b198d45f22f5ddc88ca" translate="yes" xml:space="preserve">
          <source>Only defined for &lt;code&gt;base-4.7.0.0&lt;/code&gt; and later</source>
          <target state="translated">만에 정의 된 &lt;code&gt;base-4.7.0.0&lt;/code&gt; 이상</target>
        </trans-unit>
        <trans-unit id="4a596037bffe0627dd076aba851bf6d728006681" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-fllvm&lt;/code&gt; is specified. When GHC is using version &lt;code&gt;x.y.z&lt;/code&gt; of LLVM, the value of &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example when using version 3.7 of LLVM, &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;-fllvm&lt;/code&gt; 이 지정된 경우에만 정의됩니다 . GHC가 LLVM의 버전 &lt;code&gt;x.y.z&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; 의 값은 정수 ⟨xyy⟩입니다 (⟨y⟩가 한 자리이면 앞에 0이 추가되므로 예를 들어 LLVM의 버전 3.7을 사용할 때 &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77501c9a6b02892b95f0d3d080f47d0f67625a4e" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-parallel&lt;/code&gt; is in use! This symbol is defined when pre-processing Haskell (input) and pre-processing C (GHC output).</source>
          <target state="translated">&lt;code&gt;-parallel&lt;/code&gt; 을 사용중인 경우에만 정의됩니다 ! 이 기호는 전처리 Haskell (입력) 및 전처리 C (GHC 출력)시 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff1cf96778de3d5827e74815c075270e8782040" translate="yes" xml:space="preserve">
          <source>Only one of the two class parameters is a parameter to the data family. Hence, the following instance declaration is invalid:</source>
          <target state="translated">두 클래스 매개 변수 중 하나만 데이터 패밀리에 대한 매개 변수입니다. 따라서 다음 인스턴스 선언이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2721baf97a0c4efdd138d61549b8c89209e4143c" translate="yes" xml:space="preserve">
          <source>Only the instance head counts. In the example above, it is not good enough for &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s declaration to be in module &lt;code&gt;A&lt;/code&gt;; it must be the declaration of &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">인스턴스 헤드 만 계산됩니다. 위의 예에서 &lt;code&gt;C&lt;/code&gt; 의 선언이 모듈 &lt;code&gt;A&lt;/code&gt; 에있는 것만으로는 충분하지 않습니다 . 반드시 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 선언이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e7998f0bdcbff51167fe5e1c42e1067cc0272867" translate="yes" xml:space="preserve">
          <source>Only the outer constructor is taken into consideration:</source>
          <target state="translated">외부 생성자 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="868f341dfb14a799178bbe260757188c4e090543" translate="yes" xml:space="preserve">
          <source>Only used internally</source>
          <target state="translated">내부에서만 사용</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="c637aebe3a2825fb1f2be997a9434f3ce48a4b93" translate="yes" xml:space="preserve">
          <source>Opaque</source>
          <target state="translated">Opaque</target>
        </trans-unit>
        <trans-unit id="ab610cf3766e2ab5ebbdef1c372c6423bceb9405" translate="yes" xml:space="preserve">
          <source>Open a file and make an &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; for it. Truncates the file to zero size when the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 열고 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 를 만드 십시오. &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 일 때 파일을 0 크기 로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="fb658d04e484f6ef351935e7a9b766b60debe2d4" translate="yes" xml:space="preserve">
          <source>Open a named semaphore with the given name, flags, mode, and initial value.</source>
          <target state="translated">주어진 이름, 플래그, 모드 및 초기 값으로 명명 된 세마포어를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f57c4790f7f34a8ca95eceb331923fb2088fdde1" translate="yes" xml:space="preserve">
          <source>Open a shared memory object with the given name, flags, and mode.</source>
          <target state="translated">지정된 이름, 플래그 및 모드로 공유 메모리 객체를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a4120aa06412e5adc4c600815d8ebb61aa98d422" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 파일을 열고 선택적으로 작성하십시오. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 유형 을 사용하는 방법에 대한 정보는 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="316640348a429645fef91dfb05b3196eb965850e" translate="yes" xml:space="preserve">
          <source>Open indexed type families are introduced by a signature, such as</source>
          <target state="translated">개방형 인덱스 유형 패밀리는 다음과 같은 서명으로 소개됩니다.</target>
        </trans-unit>
        <trans-unit id="62d19b763ce96acde6de1a0a0a137c190e97e371" translate="yes" xml:space="preserve">
          <source>Open type and data family declarations are exactly as in Haskell.</source>
          <target state="translated">개방형 및 데이터 패밀리 선언은 Haskell과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="345592cb9cc814b84d928db32f524bd68b8e8665" translate="yes" xml:space="preserve">
          <source>OpenExtHandle</source>
          <target state="translated">OpenExtHandle</target>
        </trans-unit>
        <trans-unit id="be4ef35b845f3f8742151ba042e927f175f32d3d" translate="yes" xml:space="preserve">
          <source>OpenFileFlags</source>
          <target state="translated">OpenFileFlags</target>
        </trans-unit>
        <trans-unit id="d4c5cbf148e8ab067ee8fcd91a86a68f327e2c93" translate="yes" xml:space="preserve">
          <source>OpenFileLimit</source>
          <target state="translated">OpenFileLimit</target>
        </trans-unit>
        <trans-unit id="b2a5470d265ed406614e0d033c4ebe86bf811418" translate="yes" xml:space="preserve">
          <source>OpenHandle</source>
          <target state="translated">OpenHandle</target>
        </trans-unit>
        <trans-unit id="f3dd14171959950898b3fb604b356ae109b6e608" translate="yes" xml:space="preserve">
          <source>OpenMode</source>
          <target state="translated">OpenMode</target>
        </trans-unit>
        <trans-unit id="528d57c38374a655a269ff7a2796f6152cc2b011" translate="yes" xml:space="preserve">
          <source>OpenPunctuation</source>
          <target state="translated">OpenPunctuation</target>
        </trans-unit>
        <trans-unit id="389682fb06c2c4c783f2fcf52cb3f6b658b5e3d8" translate="yes" xml:space="preserve">
          <source>OpenSemFlags</source>
          <target state="translated">OpenSemFlags</target>
        </trans-unit>
        <trans-unit id="8b0c300483c96f9ee4308ab45551ff569e61bab4" translate="yes" xml:space="preserve">
          <source>Opening and closing files</source>
          <target state="translated">파일 열기 및 닫기</target>
        </trans-unit>
        <trans-unit id="a535bff5bb480bbb6c0b709154409086b9fa6c12" translate="yes" xml:space="preserve">
          <source>Opening files</source>
          <target state="translated">파일 열기</target>
        </trans-unit>
        <trans-unit id="3ffea85c4926df7fcf793cfa4d81139f2c8578a1" translate="yes" xml:space="preserve">
          <source>Opens an editor to edit the file ⟨file⟩, or the most recently loaded module if ⟨file⟩ is omitted. If there were errors during the last loading, the cursor will be positioned at the line of the first error. The editor to invoke is taken from the &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; environment variable, or a default editor on your system if &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; is not set. You can change the editor using &lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt;&lt;code&gt;:set editor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">⟨file⟨ 파일 또는 ⟨file⟨이 생략 된 경우 가장 최근에로드 된 모듈을 편집하기 위해 편집기를 엽니 다. 마지막로드 중 오류가 발생한 경우 커서는 첫 번째 오류 행에 위치합니다. 호출 할 편집기는 &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; 환경 변수 또는 &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; 가 설정되지 않은 경우 시스템의 기본 편집기에서 가져옵니다 . &lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt; &lt;code&gt;:set editor&lt;/code&gt; 를&lt;/a&gt; 사용하여 편집기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab766ba42381e7e73d60b327225011551bd62285" translate="yes" xml:space="preserve">
          <source>Opens an existing file and creates mapping object to it.</source>
          <target state="translated">기존 파일을 열고 이에 대한 매핑 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b2e30baf3d135ff701a189f664d0aa02d8bc535e" translate="yes" xml:space="preserve">
          <source>Operate on the current user&amp;rsquo;s local package database. This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">현재 사용자의 로컬 패키지 데이터베이스에서 작동하십시오. 이 플래그는 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 및 &lt;code&gt;hide&lt;/code&gt; 명령에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="083cd84d11675eeddb18e443e875f6b6a3d95c50" translate="yes" xml:space="preserve">
          <source>Operate on the global package database (this is the default). This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">글로벌 패키지 데이터베이스에서 작동합니다 (기본값). 이 플래그는 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 및 &lt;code&gt;hide&lt;/code&gt; 명령에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="bf70e187ccc63f90f3e1fb5ec071ddb81220b4ff" translate="yes" xml:space="preserve">
          <source>Operating on the raw buffer as a Ptr</source>
          <target state="translated">원시 버퍼에서 Ptr로 작동</target>
        </trans-unit>
        <trans-unit id="212e24ce1fc682d740e1dca655f0849d8ec6b1da" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation (&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;).</source>
          <target state="translated">작업 설명에는 Big-O 표기법 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt; ) 의 작업 시간 복잡성이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30b4c034f9dfce3148616876e4eb785c3c71ce25" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">작업 설명에는 Big-O 표기법 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation)&lt;/a&gt; 의 작업 시간 복잡성이 포함되어 있습니다 . 많은 작업이 최악의 경우 O (min (n, W))의 복잡성을 갖습니다. 이는 최대 &lt;em&gt;W를&lt;/em&gt; 가진 요소 수에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수로 작업이 선형화 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1956fb1b777c2f5cb51b9aa2d865337af0a8590e" translate="yes" xml:space="preserve">
          <source>Operationally, in a dictionary-passing implementation, the constructors &lt;code&gt;Baz1&lt;/code&gt; and &lt;code&gt;Baz2&lt;/code&gt; must store the dictionaries for &lt;code&gt;Eq&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt; respectively, and extract it on pattern matching.</source>
          <target state="translated">작동 방식으로, 사전 전달 구현에서 생성자 &lt;code&gt;Baz1&lt;/code&gt; 및 &lt;code&gt;Baz2&lt;/code&gt; 는 각각 &lt;code&gt;Eq&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 에 대한 사전을 저장하고 패턴 일치에서 추출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="010424427c51ae459956824d4f41c5856a7d7600" translate="yes" xml:space="preserve">
          <source>Operations for composing transactions: &lt;code&gt;retry&lt;/code&gt;, and &lt;code&gt;orElse&lt;/code&gt;.</source>
          <target state="translated">: 구성 거래를위한 작업 &lt;code&gt;retry&lt;/code&gt; 및 &lt;code&gt;orElse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64c6bfa202489b3690a8497e85422b7af3c47ee6" translate="yes" xml:space="preserve">
          <source>Operations for creating and interacting with sub-processes.</source>
          <target state="translated">하위 프로세스를 만들고 상호 작용하는 작업</target>
        </trans-unit>
        <trans-unit id="63e9af41f1576e5aa52ffaa696122d209a87d569" translate="yes" xml:space="preserve">
          <source>Operations for injecting values of arbitrary type into a dynamically typed value, Dynamic, are provided, together with operations for converting dynamic values into a concrete (monomorphic) type.</source>
          <target state="translated">동적 유형을 구체적인 유형 (모노 타입)으로 변환하는 작업과 함께 임의 유형의 값을 동적 유형 값인 Dynamic에 주입하는 작업이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa672f70c432a2f16141a0afca1b4ff49e644e5" translate="yes" xml:space="preserve">
          <source>Operations on &lt;code&gt;Float&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; numbers are &lt;em&gt;unchecked&lt;/em&gt; for overflow, underflow, and other sad occurrences. (note, however, that some architectures trap floating-point overflow and loss-of-precision and report a floating-point exception, probably terminating the program)</source>
          <target state="translated">에 운영 &lt;code&gt;Float&lt;/code&gt; 와 &lt;code&gt;Double&lt;/code&gt; 번호는 &lt;em&gt;선택하지 않은&lt;/em&gt; 오버 플로우, 언더 플로우, 그리고 다른 슬픈 발생합니다. (그러나 일부 아키텍처는 부동 소수점 오버플로 및 정밀도 손실을 포착하고 부동 소수점 예외를보고하며 아마도 프로그램을 종료한다는 점에 유의하십시오)</target>
        </trans-unit>
        <trans-unit id="70b889a0601ca0e0323fbe3001c86239d52c2976" translate="yes" xml:space="preserve">
          <source>Operations on handles</source>
          <target state="translated">핸들 조작</target>
        </trans-unit>
        <trans-unit id="251fdb8c40a857d5de5aef3683ba18da16bd56ad" translate="yes" xml:space="preserve">
          <source>Operations on lists.</source>
          <target state="translated">목록 작업.</target>
        </trans-unit>
        <trans-unit id="a187376dc1defee65e37c92ba05a3b6fa77db72f" translate="yes" xml:space="preserve">
          <source>Operations whose result would be negative &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;
 (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt;,</source>
          <target state="translated">그 결과 작업은 음수가 될 것입니다 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt; (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="d4f31eb6a5e978c610c6b257f8e92dc5ac9b8f36" translate="yes" xml:space="preserve">
          <source>Operator symbols become type &lt;em&gt;constructors&lt;/em&gt; rather than type &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">연산자 기호 는 형식 &lt;em&gt;변수가&lt;/em&gt; 아닌 형식 &lt;em&gt;생성자&lt;/em&gt; 가 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df4aab8de9b7c877a7baeb4198669b3c5323bb26" translate="yes" xml:space="preserve">
          <source>Operator symbols in types can be written infix, both in definitions and uses. For example:</source>
          <target state="translated">유형의 연산자 기호는 정의와 용도 모두에서 접두사로 쓸 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="deefc1ebb8a6a9e9d71ba863ed305fcb6f2e73df" translate="yes" xml:space="preserve">
          <source>OperatorTable</source>
          <target state="translated">OperatorTable</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e8b0a981c3293cd72332580a9bfaa03f3df518cf" translate="yes" xml:space="preserve">
          <source>OptDescr</source>
          <target state="translated">OptDescr</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b293465e066906a2876636d4afb03e8ac6cf2ddc" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit from the current process)</source>
          <target state="translated">선택적 환경 (그렇지 않으면 현재 프로세스에서 상 속됨)</target>
        </trans-unit>
        <trans-unit id="dd55d6c6a66ab5ddbc36d53946c786320ec3587d" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit)</source>
          <target state="translated">선택적 환경 (그렇지 않으면 상속)</target>
        </trans-unit>
        <trans-unit id="0f14588d7b9710ada9394bfeaff05157c6f2476d" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory</source>
          <target state="translated">작업 디렉토리에 대한 선택적 경로</target>
        </trans-unit>
        <trans-unit id="d91392285a0151b95f54b71ab44e6f6e738b5437" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory for the new process</source>
          <target state="translated">새 프로세스의 작업 디렉토리에 대한 선택적 경로</target>
        </trans-unit>
        <trans-unit id="f439f2ba967862c2d5e67c16eed9a8d3ce132e3a" translate="yes" xml:space="preserve">
          <source>Optionally, the program may be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;. This provides two benefits:</source>
          <target state="translated">선택적으로 프로그램은 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션 과 연결될 수 있습니다 (연결에 &lt;a href=&quot;phases#options-linker&quot;&gt;영향을주는 옵션&lt;/a&gt; 참조) . 두 가지 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="150df3ba8f1d25b3d2442fb251bd0b8739a08f6c" translate="yes" xml:space="preserve">
          <source>Options can be forced through to a particular compilation phase, using the following flags:</source>
          <target state="translated">다음 플래그를 사용하여 옵션을 특정 컴파일 단계로 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07de4eb670ca9b55e22ab8e74a884db849e506ae" translate="yes" xml:space="preserve">
          <source>Options may also be modified from within GHCi, using the &lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 GHCi 내에서 옵션을 수정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbc525524ba745988196c2cf239dca851f2646d3" translate="yes" xml:space="preserve">
          <source>Or I could define a simple way to invoke &amp;ldquo;&lt;code&gt;ghc --make Main&lt;/code&gt;&amp;rdquo; in the current directory:</source>
          <target state="translated">또는 현재 디렉토리에서 &quot; &lt;code&gt;ghc --make Main&lt;/code&gt; &quot; 을 호출하는 간단한 방법을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed5f6d189422866d42c01faf2773a8db4acd9c2a" translate="yes" xml:space="preserve">
          <source>Or even simpler using applicative style:</source>
          <target state="translated">또는 적용 스타일을 사용하여 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c3af411739703165e3837288b0679427c0978621" translate="yes" xml:space="preserve">
          <source>Or in a standalone deriving declaration</source>
          <target state="translated">또는 독립형 파생 선언에서</target>
        </trans-unit>
        <trans-unit id="9e0ef2f0808aa7783d6cf8e9c6f90e88d912e8e1" translate="yes" xml:space="preserve">
          <source>Or using guards:</source>
          <target state="translated">또는 경비원 사용하기 :</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="2813ca76372ef7834dbf7b83dd19ec3f7be3b60a" translate="yes" xml:space="preserve">
          <source>Ord</source>
          <target state="translated">Ord</target>
        </trans-unit>
        <trans-unit id="f5167f3705089803c8512ac674241dfd7724cb93" translate="yes" xml:space="preserve">
          <source>Ord1</source>
          <target state="translated">Ord1</target>
        </trans-unit>
        <trans-unit id="a846bf09723a1322f808ad711f192bb56fbfbec4" translate="yes" xml:space="preserve">
          <source>Ord2</source>
          <target state="translated">Ord2</target>
        </trans-unit>
        <trans-unit id="f67c47b80d23bf9aafb12517fa70e43e75dc9ce1" translate="yes" xml:space="preserve">
          <source>Ordered ByteStrings</source>
          <target state="translated">정렬 된 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="6b5d4e1e91de3c24915fa410d3ac4a21868bffb0" translate="yes" xml:space="preserve">
          <source>Ordered list</source>
          <target state="translated">주문 된 목록</target>
        </trans-unit>
        <trans-unit id="9bed071603b37f170248ba8799e9c1e267fbd2f5" translate="yes" xml:space="preserve">
          <source>Ordered lists</source>
          <target state="translated">주문 된 목록</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="5ee1f118f806c2954ead1243461f8f5c2a0d2524" translate="yes" xml:space="preserve">
          <source>Ordering of &lt;code&gt;-l&lt;/code&gt; options matters: a library should be mentioned &lt;em&gt;before&lt;/em&gt; the libraries it depends on (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 옵션의 순서가 중요합니다. 라이브러리는 종속 된 라이브러리 &lt;em&gt;보다 먼저&lt;/em&gt; 언급 &lt;em&gt;해야&lt;/em&gt; 합니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="026197d403291a7a7c724e41228f7b3923b83a89" translate="yes" xml:space="preserve">
          <source>Orderings</source>
          <target state="translated">Orderings</target>
        </trans-unit>
        <trans-unit id="4cd6b596de672da2114ba27b5d0928eebf93910e" translate="yes" xml:space="preserve">
          <source>Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected results. Consider this (artificial) example</source>
          <target state="translated">규칙 재 작성과 동시에 일반 인라이닝이 발생하여 예기치 않은 결과가 발생할 수 있습니다. 이 (인공적인) 예를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="04b00cb26f97f959a02aa6ce19955a72b8bd0a5f" translate="yes" xml:space="preserve">
          <source>Ordinary single-threaded Haskell programs will not benefit from enabling SMP parallelism alone: you must expose parallelism to the compiler. One way to do so is forking threads using Concurrent Haskell (&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;), but the simplest mechanism for extracting parallelism from pure code is to use the &lt;code&gt;par&lt;/code&gt; combinator, which is closely related to (and often used with) &lt;code&gt;seq&lt;/code&gt;. Both of these are available from the &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;parallel library&lt;/a&gt;:</source>
          <target state="translated">일반적인 단일 스레드 Haskell 프로그램은 SMP 병렬 처리만으로는 이점을 얻지 못합니다. 컴파일러에 병렬 처리를 노출해야합니다. 이를 수행하는 한 가지 방법은 Concurrent Haskell ( &lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt; )을 사용하여 스레드를 분기하는 것입니다 . 그러나 순수 코드에서 병렬 처리를 추출하는 가장 간단한 메커니즘은 &lt;code&gt;seq&lt;/code&gt; 와 밀접한 관련이 있고 종종 사용되는 &lt;code&gt;par&lt;/code&gt; combinator 를 사용하는 것 입니다. 둘 다 &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;병렬 라이브러리&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e54f5fa5a278d112dceef67452d2651ffb1f7b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow의 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 다시 작성되었습니다 . 조각을 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 다시 작성되었습니다 . Don Stewart와 Duncan Coutts가 다시 작성하고 확장했습니다. Duncan Coutts와 Don Stewart의 게으른 변형.</target>
        </trans-unit>
        <trans-unit id="93598ac808fb05625f35e4f620de0f0e53817bdf" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow의 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 다시 작성되었습니다 . 조각을 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 다시 작성되었습니다 . Don Stewart와 Duncan Coutts가 다시 작성하고 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="1b9ce637b76a3e86159754092a5bff05de23030c" translate="yes" xml:space="preserve">
          <source>Originally designed by John Hughes's and Simon Peyton Jones's.</source>
          <target state="translated">원래 John Hughes와 Simon Peyton Jones가 설계했습니다.</target>
        </trans-unit>
        <trans-unit id="e0d11db984918c900a2e7615ec383a5f3eade238" translate="yes" xml:space="preserve">
          <source>Orphan instances</source>
          <target state="translated">고아 인스턴스</target>
        </trans-unit>
        <trans-unit id="5ad09dd090c8718838113f73d1171adb4a590c71" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">그러나 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 작업은 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 함수 와 충돌 하므로 다른 별칭으로 &lt;code&gt;qualified&lt;/code&gt; 해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d7d5fbcca333f989fd2b0f0cf8199618b39f1bd3" translate="yes" xml:space="preserve">
          <source>Other Haskell systems do not currently support multiple operating system threads.</source>
          <target state="translated">다른 Haskell 시스템은 현재 여러 운영 체제 스레드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="778e98a9766b655c4f188fb5d617327629ecdb0a" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">그래픽 Concurrent Haskell Debugger ( &lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt; ) 와 같은 다른 응용 프로그램 은 용도에 따라 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 를 오버로드하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9086a30a19ab20bd7cd31262ef8e704a3c0e4890" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">그래픽 Concurrent Haskell Debugger ( &lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt; ) 와 같은 다른 응용 프로그램 은 용도에 따라 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 를 오버로드하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31deb74a58fba669a7c2cb31b6bed8515ab85d00" translate="yes" xml:space="preserve">
          <source>Other combinators</source>
          <target state="translated">다른 조합기</target>
        </trans-unit>
        <trans-unit id="f717c91b4ff7b4e9135a9458b2f8146b78bb74a3" translate="yes" xml:space="preserve">
          <source>Other operations</source>
          <target state="translated">다른 작업</target>
        </trans-unit>
        <trans-unit id="82169c7fc5215cf20135048050c38ee826497c85" translate="yes" xml:space="preserve">
          <source>Other operations such as &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; as well as a dummy/place-holder value instead of &lt;code&gt;undefined&lt;/code&gt; since we can't throw exceptions. But that behaviour should not be relied upon.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; 과 같은 다른 연산은 예외 를 던질 수 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;undefined&lt;/code&gt; 대신 더미 / 자리 표시 자 값을 반환 할 수 있습니다. 그러나 그 행동에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9047c6f96c316a252e973efb632599db44d02ce4" translate="yes" xml:space="preserve">
          <source>Other special syntax: sequences of characters that have a different meaning when this particular option is turned on.</source>
          <target state="translated">다른 특수 구문 :이 특정 옵션이 켜져있을 때 다른 의미를 갖는 문자 시퀀스.</target>
        </trans-unit>
        <trans-unit id="91b29ffa8ce218d650e0c973969ab7a599e5a143" translate="yes" xml:space="preserve">
          <source>Other stuff</source>
          <target state="translated">다른 것들</target>
        </trans-unit>
        <trans-unit id="4b372c318a0ac15f1e50d7fd1a01e206248a8e63" translate="yes" xml:space="preserve">
          <source>Other than these two caveats, users can always expect that a finalizer will be run after its weak pointer's object becomes unreachable. However, the second caveat means that users need to trust that all of their transitive dependencies do not throw exceptions in finalizers, since any finalizers can end up queued together.</source>
          <target state="translated">이 두 가지 경고 이외에, 사용자는 항상 약한 포인터의 객체에 도달 할 수없는 후에 파이널 라이저가 실행될 것이라고 기대할 수 있습니다. 그러나 두 번째 경고는 사용자가 모든 전이 종속성이 종료 자에서 예외를 throw하지 않는다는 것을 신뢰해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="translated">다른 유형</target>
        </trans-unit>
        <trans-unit id="c871109d68307ac18e84ee307aacea963e4970b3" translate="yes" xml:space="preserve">
          <source>Other uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are undefined. In particular, you should not use &lt;code&gt;unsafeCoerce#&lt;/code&gt; to cast a T to an algebraic data type D, unless T is also an algebraic data type. For example, do not cast &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt;, even if you later cast that &lt;code&gt;Bool&lt;/code&gt; back to &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; before applying it. The reasons have to do with GHC's internal representation details (for the cognoscenti, data values can be entered but function closures cannot). If you want a safe type to cast things to, use &lt;code&gt;Any&lt;/code&gt;, which is not an algebraic data type.</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 의 다른 용도 는 정의되어 있지 않습니다. 특히 T가 대수 데이터 형식 이 아닌 경우 &lt;code&gt;unsafeCoerce#&lt;/code&gt; 을 사용 하여 T를 대수 데이터 형식 D로 캐스팅 해서는 안됩니다 . 예를 들어 나중에 적용하기 전에 해당 &lt;code&gt;Bool&lt;/code&gt; 을 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 로 캐스트하더라도 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 를 &lt;code&gt;Bool&lt;/code&gt; 로 캐스트하지 마십시오 . 그 이유는 GHC의 내부 표현 세부 사항과 관련이 있습니다 (공감력의 경우 데이터 값을 입력 할 수는 있지만 함수 클로저는 불가능합니다). 안전한 유형으로 물건을 캐스팅 하려면 대수 데이터 유형이 아닌 &lt;code&gt;Any&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cca89d1c6f9e6b7edb2c91666360061ed277fff" translate="yes" xml:space="preserve">
          <source>OtherError</source>
          <target state="translated">OtherError</target>
        </trans-unit>
        <trans-unit id="b004f25ba2f862ca69a0ad498024ce48dcec48b4" translate="yes" xml:space="preserve">
          <source>OtherLetter</source>
          <target state="translated">OtherLetter</target>
        </trans-unit>
        <trans-unit id="79976ff76f967e06eb59c60ae5e3d4d8d8f1dea8" translate="yes" xml:space="preserve">
          <source>OtherNumber</source>
          <target state="translated">OtherNumber</target>
        </trans-unit>
        <trans-unit id="2fe5dcff8470fff0318c0b5bff7bb23017100fe8" translate="yes" xml:space="preserve">
          <source>OtherPunctuation</source>
          <target state="translated">OtherPunctuation</target>
        </trans-unit>
        <trans-unit id="7d352f6a13bd8fb7c6cafa22cba1529a45d2c13e" translate="yes" xml:space="preserve">
          <source>OtherSymbol</source>
          <target state="translated">OtherSymbol</target>
        </trans-unit>
        <trans-unit id="a8f27da35e68a9f7a5a97f1703ac92769848a8d4" translate="yes" xml:space="preserve">
          <source>Others have execute permission.</source>
          <target state="translated">다른 사람에게는 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b5a656b29825a9211b83ccae7336ee695ce161" translate="yes" xml:space="preserve">
          <source>Others have read permission.</source>
          <target state="translated">다른 사람들에게는 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25f01ea5949b3e11544a08901cd4fc6b386f3f43" translate="yes" xml:space="preserve">
          <source>Others have read, write and execute permission.</source>
          <target state="translated">다른 사람들은 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0d4f6a481380e178acd3897e6a60f3ade59b6a" translate="yes" xml:space="preserve">
          <source>Others have write permission.</source>
          <target state="translated">다른 사람들은 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49385a99644f84243228dd0e51c68c048e901bf5" translate="yes" xml:space="preserve">
          <source>Otherwise GHC will solve the &lt;code&gt;HasCallStack&lt;/code&gt; constraint for the singleton &lt;code&gt;CallStack&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">그렇지 않으면 GHC는 현재 콜 사이트 만 포함 하는 싱글 톤 &lt;code&gt;CallStack&lt;/code&gt; 에 대한 &lt;code&gt;HasCallStack&lt;/code&gt; 제약 조건을 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="73b9866b09caa352e14869afa4a22348cbf03067" translate="yes" xml:space="preserve">
          <source>Otherwise there is exactly one non-incoherent candidate; call it the &amp;ldquo;prime candidate&amp;rdquo;.</source>
          <target state="translated">그렇지 않으면 정확히 하나의 비 일관성 후보가 있습니다. 그것을 &quot;프라임 후보&quot;라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="fb76a4f7af9550821f6b9b31e5732f8573d196f6" translate="yes" xml:space="preserve">
          <source>Otherwise uses home directory returned by &lt;code&gt;getpwuid_r&lt;/code&gt; using the UID of the current proccesses user. This basically reads the &lt;em&gt;etc&lt;/em&gt;passwd file. An empty home directory field is considered valid.</source>
          <target state="translated">그렇지 않으면 현재 프로세스 사용자의 UID를 사용하여 &lt;code&gt;getpwuid_r&lt;/code&gt; 에 의해 리턴 된 홈 디렉토리를 사용합니다. 기본적으로 &lt;em&gt;etc&lt;/em&gt; passwd 파일을 읽습니다 . 빈 홈 디렉토리 필드는 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="165546d2f6cedba70f1aef6539fe75331eec72db" translate="yes" xml:space="preserve">
          <source>Otherwise, in the common case of a simple type error such as typing &lt;code&gt;reverse True&lt;/code&gt; at the prompt, you would get a warning and then an immediately-following type error when the expression is evaluated.</source>
          <target state="translated">그렇지 않으면 프롬프트에서 &lt;code&gt;reverse True&lt;/code&gt; 를 입력하는 것과 같은 간단한 유형 오류의 일반적인 경우 에는 표현식을 평가할 때 경고가 표시되고 바로 다음 유형 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9328699bfa5be08b83f54b0c37225de2cd8e0bd2" translate="yes" xml:space="preserve">
          <source>Otherwise, it behaves like &lt;code&gt;ghc-pkg list&lt;/code&gt;, including options.</source>
          <target state="translated">그렇지 않으면 옵션을 포함하여 &lt;code&gt;ghc-pkg list&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="122c01da0c009875e86f7f7f7990dd90b8f65d05" translate="yes" xml:space="preserve">
          <source>Out of scope term variables</source>
          <target state="translated">범위를 벗어난 용어 변수</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dcd804196c4ab4c07a7fb9d32d6dd85f499cdd67" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 출력하십시오 . &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 버퍼에 직접 실행 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 버퍼가 너무 작거나 존재하지 않으면 충분히 큰 버퍼로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="faccf69b130383a7a701fa6e58ffeb062f573f54" translate="yes" xml:space="preserve">
          <source>Output errors in reverse order</source>
          <target state="translated">역순으로 출력 오류</target>
        </trans-unit>
        <trans-unit id="5218d9a3d99e1852dea200794dafd520fce146d7" translate="yes" xml:space="preserve">
          <source>Output full span in error messages</source>
          <target state="translated">오류 메시지에서 출력 전체 범위</target>
        </trans-unit>
        <trans-unit id="364167f7b761668d223893cadae4f828c7c2fa44" translate="yes" xml:space="preserve">
          <source>Output functions</source>
          <target state="translated">출력 기능</target>
        </trans-unit>
        <trans-unit id="fbd84c24ac8d22f5181f1bc88f9671c4344d5b53" translate="yes" xml:space="preserve">
          <source>Output is returned strictly, so this is not suitable for launching processes that require interaction over the standard file streams.</source>
          <target state="translated">출력이 엄격하게 리턴되므로 표준 파일 스트림을 통한 상호 작용이 필요한 프로세스를 시작하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e103798c3274cee279fa6992b0f5932f325fa5ac" translate="yes" xml:space="preserve">
          <source>Output the &lt;code&gt;ghc-pkg&lt;/code&gt; version number.</source>
          <target state="translated">&lt;code&gt;ghc-pkg&lt;/code&gt; 버전 번호를 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec3a20e9b85c9c73b5f9e136d68ee50ad77983fe" translate="yes" xml:space="preserve">
          <source>Output the HTML without adding newlines or spaces within the markup. This should be the most time and space efficient way to render HTML, though the ouput is quite unreadable.</source>
          <target state="translated">마크 업 내에 줄 바꿈이나 공백을 추가하지 않고 HTML을 출력하십시오. 출력을 읽을 수는 없지만 HTML을 렌더링하는 가장 시간과 공간 효율적인 방법이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed8e0c3be25bb282bdb7ed21575be0568a2ea8ce" translate="yes" xml:space="preserve">
          <source>Output version information and exit successfully.</source>
          <target state="translated">버전 정보를 출력하고 성공적으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="d76b710eda6d9732ae60ae3688eb9124d03137ca" translate="yes" xml:space="preserve">
          <source>OutputCap</source>
          <target state="translated">OutputCap</target>
        </trans-unit>
        <trans-unit id="3210573c1fb5e651cb8a6253bec6053d0ba32e16" translate="yes" xml:space="preserve">
          <source>OutputQueue</source>
          <target state="translated">OutputQueue</target>
        </trans-unit>
        <trans-unit id="1478d601c03c445a904d445d7c3e8cec48d16838" translate="yes" xml:space="preserve">
          <source>OutputUnderflow</source>
          <target state="translated">OutputUnderflow</target>
        </trans-unit>
        <trans-unit id="2bbfd1ba36d0c76586f52911ecb048b6eac561d8" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="fdabf64a0b25e97a2bcdfbcbab9832f9fb21a8e2" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="d2be19b4f59c90e2b571c4c57a78af1c21f19989" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 작성됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f34b67d163777be1cfe43137e0b8aa27949758" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 작성됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437c6c5b9e71301759333f52e620b482f7d4e6a3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e9342f2cf13303d6a47b5d18b92f9cf13b2e5169" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="19430befa515c2d9064f3110f0aa35abc26dd1f3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="582cb8658b32442aec042d63a5cfab472fe58413" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML. Because space matters in HTML, the output is quite messy.</source>
          <target state="translated">들여 쓰기 된 HTML을 출력합니다. HTML에서는 공간이 중요하기 때문에 출력이 매우 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="b7f803909184a1a75bdfd2d4f7c735bb61a3e949" translate="yes" xml:space="preserve">
          <source>Outputs indented XHTML. Because space matters in HTML, the output is quite messy.</source>
          <target state="translated">들여 쓰기 된 XHTML을 출력합니다. HTML에서는 공간이 중요하기 때문에 출력이 매우 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="eb7db7a58078fc2825bd0a031efa804f437af7c6" translate="yes" xml:space="preserve">
          <source>Outputs the command-line syntax.</source>
          <target state="translated">명령 줄 구문을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7119c6e28cbbe42a656bd510a3c7d9802856a05d" translate="yes" xml:space="preserve">
          <source>Outputting text</source>
          <target state="translated">텍스트 출력</target>
        </trans-unit>
        <trans-unit id="4da7bc9200c71949eae8135d4a25bb5b299cf7cc" translate="yes" xml:space="preserve">
          <source>Overflow</source>
          <target state="translated">Overflow</target>
        </trans-unit>
        <trans-unit id="86b5bfa21ad7befe5b7734642489ec9bc1748da2" translate="yes" xml:space="preserve">
          <source>Overlap</source>
          <target state="translated">Overlap</target>
        </trans-unit>
        <trans-unit id="2e8a35cfdb5657a597ecf6c9392cc4a625880c7a" translate="yes" xml:space="preserve">
          <source>Overlappable</source>
          <target state="translated">Overlappable</target>
        </trans-unit>
        <trans-unit id="4595ccd7bc9e0af583db794795f5853d40095221" translate="yes" xml:space="preserve">
          <source>Overlapping</source>
          <target state="translated">Overlapping</target>
        </trans-unit>
        <trans-unit id="66015fffae6c6a9653fc601aa127c669c9f7f142" translate="yes" xml:space="preserve">
          <source>Overlapping instances must be used with care. They can give rise to incoherence (i.e. different instance choices are made in different parts of the program) even without &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. Consider:</source>
          <target state="translated">겹치는 인스턴스는주의해서 사용해야합니다. &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; 없이도 일관성이 없어 질 수 있습니다 (즉, 프로그램의 다른 부분에서 다른 인스턴스 선택이 수행됨) . 치다:</target>
        </trans-unit>
        <trans-unit id="d1523bffa7a001e9a35e090d7fb6d2c81a06dbc6" translate="yes" xml:space="preserve">
          <source>OverlappingInstances</source>
          <target state="translated">OverlappingInstances</target>
        </trans-unit>
        <trans-unit id="a8f9e73a31d1ecafa5203f5b5c4b88f1a16e5e78" translate="yes" xml:space="preserve">
          <source>Overlaps</source>
          <target state="translated">Overlaps</target>
        </trans-unit>
        <trans-unit id="33bfb3c6026c4b45ecc7feb8aafe2ca9f3b3173c" translate="yes" xml:space="preserve">
          <source>Overlays are an experimental feature of HPC, a textual description of coverage. hpc draft is used to generate a draft overlay from a .tix file, and hpc overlay generates a .tix files from an overlay.</source>
          <target state="translated">오버레이는 적용 범위에 대한 텍스트 설명 인 HPC의 실험 기능입니다. hpc draft는 .tix 파일에서 초안 오버레이를 생성하는 데 사용되며 hpc overlay는 오버레이에서 .tix 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a8b4cac7022105ed5d28059687f452f232ee8a94" translate="yes" xml:space="preserve">
          <source>Overloaded functions are not your friend:</source>
          <target state="translated">과부하 된 기능은 친구가 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="97176dd8fcd9d1389997c9bc3e797197c3840bf4" translate="yes" xml:space="preserve">
          <source>Overloaded lists</source>
          <target state="translated">오버로드 된 목록</target>
        </trans-unit>
        <trans-unit id="e8bd3aa687e1a738e55c3636a509b286641773a4" translate="yes" xml:space="preserve">
          <source>Overloaded mutable array interface</source>
          <target state="translated">오버로드 된 가변 배열 인터페이스</target>
        </trans-unit>
        <trans-unit id="e60511daee4f7111180ca7e032a2951fd849e4ee" translate="yes" xml:space="preserve">
          <source>Overloaded string literals</source>
          <target state="translated">오버로드 된 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="d6d7cf52e6ad94223f1634444b6ca253e18d7307" translate="yes" xml:space="preserve">
          <source>OverloadedLabels</source>
          <target state="translated">OverloadedLabels</target>
        </trans-unit>
        <trans-unit id="bfc0c0637f5d2341f692e6b4349a28ae53c2ed8b" translate="yes" xml:space="preserve">
          <source>OverloadedLists</source>
          <target state="translated">OverloadedLists</target>
        </trans-unit>
        <trans-unit id="21198418d476e74157738de8ed502c9d0fdf2bb9" translate="yes" xml:space="preserve">
          <source>OverloadedStrings</source>
          <target state="translated">OverloadedStrings</target>
        </trans-unit>
        <trans-unit id="f8883c62e6c0e5fff7f6dbed0dfb6ac51a5a5e1f" translate="yes" xml:space="preserve">
          <source>Override default behaviour for source files</source>
          <target state="translated">소스 파일의 기본 동작 무시</target>
        </trans-unit>
        <trans-unit id="6d84840c6065dcaf391a05992267b78411ef4230" translate="yes" xml:space="preserve">
          <source>Owing to the vagaries of DLL linking, these hooks don&amp;rsquo;t work under Windows when the program is built dynamically.</source>
          <target state="translated">DLL 연결의 차이로 인해 프로그램이 동적으로 빌드되면 Windows에서 이러한 후크가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32e42d7cf1d8ef849a65b5a64f751115cac94630" translate="yes" xml:space="preserve">
          <source>Owner has execute permission.</source>
          <target state="translated">소유자에게 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3602226bffa2bf2cc1004ff7d38eed8270dc876b" translate="yes" xml:space="preserve">
          <source>Owner has read permission.</source>
          <target state="translated">소유자에게 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="77086e57cff582a02a6797d6af8ebc3a53898204" translate="yes" xml:space="preserve">
          <source>Owner has read, write and execute permission.</source>
          <target state="translated">소유자가 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7347b7f7b6214962e6cdded97a0459692c3eb4cb" translate="yes" xml:space="preserve">
          <source>Owner has write permission.</source>
          <target state="translated">소유자에게 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f821171aa7e9231ae6975fc208a27c4266781f" translate="yes" xml:space="preserve">
          <source>Owner, group and others have read and write permission.</source>
          <target state="translated">소유자, 그룹 및 기타 사람들은 읽기 및 쓰기 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e523f78f39ca6a4d4e48aaa4794b482ae4b16989" translate="yes" xml:space="preserve">
          <source>Owner, group and others have read, write and execute permission.</source>
          <target state="translated">소유자, 그룹 및 기타 사람들은 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="804c55046a7d6c2cc06d260ab90e0d6beedbce3b" translate="yes" xml:space="preserve">
          <source>P's complete type is of the following form</source>
          <target state="translated">P의 완전한 유형은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="b38cb0ee15cbdc945a4dd5af71e0ea5ff7337a56" translate="yes" xml:space="preserve">
          <source>PACL</source>
          <target state="translated">PACL</target>
        </trans-unit>
        <trans-unit id="048499ce23d04eb40ace8750a382f648336913e9" translate="yes" xml:space="preserve">
          <source>PAINTSTRUCT</source>
          <target state="translated">PAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="ad09b4bfdbe4d101135fff62d526064595a08512" translate="yes" xml:space="preserve">
          <source>PHANDLE</source>
          <target state="translated">PHANDLE</target>
        </trans-unit>
        <trans-unit id="1dd2c6c79f5967008b3710173dafb5d91bf6f2af" translate="yes" xml:space="preserve">
          <source>PHANDLER_ROUTINE</source>
          <target state="translated">PHANDLER_ROUTINE</target>
        </trans-unit>
        <trans-unit id="7e7f65d76167ed1ddaafc5081c1471db12872a25" translate="yes" xml:space="preserve">
          <source>PHARDWAREINPUT</source>
          <target state="translated">PHARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="85e8f21e7df070dfbfb33b827711de398d912fd4" translate="yes" xml:space="preserve">
          <source>PINPUT</source>
          <target state="translated">PINPUT</target>
        </trans-unit>
        <trans-unit id="0b9ca3c7e43bcb3e5b2891c4396b2710f3cbde31" translate="yes" xml:space="preserve">
          <source>PKEY</source>
          <target state="translated">PKEY</target>
        </trans-unit>
        <trans-unit id="1820a15854141d70e90716d788ea58c3c229d171" translate="yes" xml:space="preserve">
          <source>PMOUSEINPUT</source>
          <target state="translated">PMOUSEINPUT</target>
        </trans-unit>
        <trans-unit id="aa6c6e71142e2a18efab6e799dedaa71f848c830" translate="yes" xml:space="preserve">
          <source>POSIX IO support. These types and functions correspond to the unix functions open(2), close(2), etc. For more portable functions which are more like fopen(3) and friends from stdio.h, see &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt;.</source>
          <target state="translated">POSIX IO 지원. 이러한 유형과 함수는 open (2), close (2) 등의 유닉스 함수에 해당합니다. fopen (3) 및 stdio.h의 친구와 같은보다 이식 가능한 함수는 &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="079d0f57f2334c2adbdc7591a011db4dd709359a" translate="yes" xml:space="preserve">
          <source>POSIX Terminal support</source>
          <target state="translated">POSIX 터미널 지원</target>
        </trans-unit>
        <trans-unit id="22aca2377521adf00292736ce43c51b0c7e32ea3" translate="yes" xml:space="preserve">
          <source>POSIX Time support</source>
          <target state="translated">POSIX 시간 지원</target>
        </trans-unit>
        <trans-unit id="292baf4f2f262bc63b703e55a72343bbb3636618" translate="yes" xml:space="preserve">
          <source>POSIX data types</source>
          <target state="translated">POSIX 데이터 유형</target>
        </trans-unit>
        <trans-unit id="318e90ecf5469e2adbc593a53864478fbcf3bad5" translate="yes" xml:space="preserve">
          <source>POSIX data types: Haskell equivalents of the types defined by the &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt; C header on a POSIX system.</source>
          <target state="translated">POSIX 데이터 유형 : POSIX 시스템 의 &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt; C 헤더에 의해 정의 된 유형과 동일한 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="bb81ead9bcb349c7209884ed07f7695a7f46f32c" translate="yes" xml:space="preserve">
          <source>POSIX defines operations to get information, such as owner, permissions, size and access times, about a file. This information is represented by the &lt;code&gt;&lt;a href=&quot;system-posix-files#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">POSIX는 파일에 대한 소유자, 권한, 크기 및 액세스 시간과 같은 정보를 가져 오는 작업을 정의합니다. 이 정보는 &lt;code&gt;&lt;a href=&quot;system-posix-files#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a83136c082ba1746dcd67b3e4264fcabc3118b4" translate="yes" xml:space="preserve">
          <source>POSIX defines operations to get information, such as owner, permissions, size and access times, about a file. This information is represented by the &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">POSIX는 파일에 대한 소유자, 권한, 크기 및 액세스 시간과 같은 정보를 가져 오는 작업을 정의합니다. 이 정보는 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2247d636852d4974c20bc81cef3eee8f8693cb1" translate="yes" xml:space="preserve">
          <source>POSIX environment support</source>
          <target state="translated">POSIX 환경 지원</target>
        </trans-unit>
        <trans-unit id="77ab5f467c12abe5e944670123be671c69f9c1ad" translate="yes" xml:space="preserve">
          <source>POSIX error support</source>
          <target state="translated">POSIX 오류 지원</target>
        </trans-unit>
        <trans-unit id="577fae15c03302f9533fba712b949371600860a0" translate="yes" xml:space="preserve">
          <source>POSIX file control support</source>
          <target state="translated">POSIX 파일 제어 지원</target>
        </trans-unit>
        <trans-unit id="441cd303356e44c35c8b81962cf0dd9d836ac5e9" translate="yes" xml:space="preserve">
          <source>POSIX miscellaneous stuff, mostly from unistd.h</source>
          <target state="translated">대부분 unistd.h에서 POSIX 기타 물건</target>
        </trans-unit>
        <trans-unit id="0f6ec8374b30a1b5c96490a77a0ceae4de07fc7d" translate="yes" xml:space="preserve">
          <source>POSIX named semaphore support.</source>
          <target state="translated">POSIX라는 세마포어 지원.</target>
        </trans-unit>
        <trans-unit id="08bafc86e53a454435af5c1c18fc679a44dc565c" translate="yes" xml:space="preserve">
          <source>POSIX process support. See also the System.Cmd and System.Process modules in the process package.</source>
          <target state="translated">POSIX 프로세스 지원. 프로세스 패키지의 System.Cmd 및 System.Process 모듈도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="654e2e0f35661132458d5d0822add53293643b2a" translate="yes" xml:space="preserve">
          <source>POSIX resource support</source>
          <target state="translated">POSIX 자원 지원</target>
        </trans-unit>
        <trans-unit id="ebcc5225834879beb7456c935b043f8860521e53" translate="yes" xml:space="preserve">
          <source>POSIX shared memory support.</source>
          <target state="translated">POSIX 공유 메모리 지원.</target>
        </trans-unit>
        <trans-unit id="45920651e67f5412a47b9d8f7bc47165c18613b2" translate="yes" xml:space="preserve">
          <source>POSIX signal support</source>
          <target state="translated">POSIX 신호 지원</target>
        </trans-unit>
        <trans-unit id="4502a50a73e2d715093b7326bc2eb514a0e679e0" translate="yes" xml:space="preserve">
          <source>POSIX temporary file and directory creation functions.</source>
          <target state="translated">POSIX 임시 파일 및 디렉토리 생성 기능.</target>
        </trans-unit>
        <trans-unit id="3fab173d191fed500e90a6dee632c803a84facb1" translate="yes" xml:space="preserve">
          <source>POSIX time is the nominal time since 1970-01-01 00:00 UTC</source>
          <target state="translated">POSIX 시간은 1970-01-01 00:00 UTC 이후의 공칭 시간입니다.</target>
        </trans-unit>
        <trans-unit id="58f93d74398f0946ad737dd9368214ee4e669e99" translate="yes" xml:space="preserve">
          <source>POSIX time, if you need to deal with timestamps and the like. Most people won't need this module.</source>
          <target state="translated">POSIX 시간, 타임 스탬프 등을 처리해야하는 경우. 대부분의 사람들은이 모듈이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b94c2396f7667c2847b93362ca54298f2a041bb0" translate="yes" xml:space="preserve">
          <source>POSIX user/group support</source>
          <target state="translated">POSIX 사용자 / 그룹 지원</target>
        </trans-unit>
        <trans-unit id="1432f73e88b32fcc9fcbc2fc9541f54571421a18" translate="yes" xml:space="preserve">
          <source>POSIX: either file or directory link; Windows: file link</source>
          <target state="translated">POSIX : 파일 또는 디렉토리 링크; Windows : 파일 링크</target>
        </trans-unit>
        <trans-unit id="c5f7093efb2198f16b7b44117d72ea5f7c731b36" translate="yes" xml:space="preserve">
          <source>POSIXTime</source>
          <target state="translated">POSIXTime</target>
        </trans-unit>
        <trans-unit id="6fa84fb314e576ad58ab64235ec9f5692ff698e9" translate="yes" xml:space="preserve">
          <source>POSVERSIONINFOEX</source>
          <target state="translated">POSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="bb2083b91dbcda1acd7b19d79a3721e0e2c32aa6" translate="yes" xml:space="preserve">
          <source>PROPORTION</source>
          <target state="translated">PROPORTION</target>
        </trans-unit>
        <trans-unit id="48a6bb377c2d242262af4edce1280a39ef449e2a" translate="yes" xml:space="preserve">
          <source>PSID</source>
          <target state="translated">PSID</target>
        </trans-unit>
        <trans-unit id="3051dda3f76f70a2a56f76bf7a6055149e32138b" translate="yes" xml:space="preserve">
          <source>PUCHAR</source>
          <target state="translated">PUCHAR</target>
        </trans-unit>
        <trans-unit id="8baf870b616352faf6c7c0ecdaf54c8968a6fcff" translate="yes" xml:space="preserve">
          <source>Pack the elements of an unboxed tuple into a vector.</source>
          <target state="translated">박스형 튜플의 요소를 벡터로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="f1a7e630429c6941a869ac578c4e8fd6c98967d0" translate="yes" xml:space="preserve">
          <source>Package &lt;code&gt;P&lt;/code&gt; is trusted by C</source>
          <target state="translated">패키지 &lt;code&gt;P&lt;/code&gt; 는 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="632c494fdb55eaa49a7e790eda0b61cb93138010" translate="yes" xml:space="preserve">
          <source>Package environments can be modified by further command line arguments; for example, if you specify &lt;code&gt;-package foo&lt;/code&gt; on the command line, then package ⟨foo⟩ will be visible even if it&amp;rsquo;s not listed in the currently active package environment.</source>
          <target state="translated">추가 명령 행 인수로 패키지 환경을 수정할 수 있습니다. 예를 들어, 명령 행에 &lt;code&gt;-package foo&lt;/code&gt; 를 지정 하면 현재 활성화 된 패키지 환경에 나열되어 있지 않아도 패키지 listedfoo⟩가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="909c5fa9bb52d913940480e63569e9457c322a40" translate="yes" xml:space="preserve">
          <source>Package imports with thinning/renaming do not hide other versions of the package: e.g. if containers-0.9 is already exposed, &lt;code&gt;-package &quot;containers-0.8 (Data.List as ListV8)&quot;&lt;/code&gt; will only add an additional binding to the environment. Similarly, &lt;code&gt;-package &quot;base (Data.Bool as Bool)&quot; -package &quot;base (Data.List as List)&quot;&lt;/code&gt; is equivalent to &lt;code&gt;-package &quot;base (Data.Bool as Bool, Data.List as List)&quot;&lt;/code&gt;. Literal names must refer to modules defined by the original package, so for example &lt;code&gt;-package &quot;base (Data.Bool as Bool, Bool as Baz)&quot;&lt;/code&gt; is invalid unless there was a &lt;code&gt;Bool&lt;/code&gt; module defined in the original package. Hiding a package also clears all of its renamings.</source>
          <target state="translated">씨닝 / 이름 변경 기능이있는 패키지 가져 오기는 다른 버전의 패키지를 숨기지 않습니다. 예를 들어 컨테이너 &lt;code&gt;-package &quot;containers-0.8 (Data.List as ListV8)&quot;&lt;/code&gt; 가 이미 노출 된 경우 -package &quot;containers-0.8 (Data.List as ListV8)&quot; 은 환경에 추가 바인딩 만 추가합니다. 마찬가지로 &lt;code&gt;-package &quot;base (Data.Bool as Bool)&quot; -package &quot;base (Data.List as List)&quot;&lt;/code&gt; 는 &lt;code&gt;-package &quot;base (Data.Bool as Bool, Data.List as List)&quot;&lt;/code&gt; . 리터럴 이름은 원래 패키지에 의해 정의 된 모듈을 참조해야하므로 예를 들어 원래 패키지 에 &lt;code&gt;Bool&lt;/code&gt; 모듈이 정의되어 있지 않으면 &lt;code&gt;-package &quot;base (Data.Bool as Bool, Bool as Baz)&quot;&lt;/code&gt; 는 유효하지 않습니다 . 패키지를 숨기면 모든 이름 변경이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="5c9811b51086b6dfb42e84534c5b2b28e924b044" translate="yes" xml:space="preserve">
          <source>Package key of the package where the static pointer is defined</source>
          <target state="translated">정적 포인터가 정의 된 패키지의 패키지 키</target>
        </trans-unit>
        <trans-unit id="2218a05564cb586c32edc345988a8e44eb09178b" translate="yes" xml:space="preserve">
          <source>PackageImports</source>
          <target state="translated">PackageImports</target>
        </trans-unit>
        <trans-unit id="bd3f84301261878bbaaa34010d966279bf40adc1" translate="yes" xml:space="preserve">
          <source>Packed, unboxed, heap-resident arrays. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">팩형, 박스형, 힙 상주 형 어레이. 대량의 데이터 및 고속 측면에서 성능이 중요한 용도에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f01120d5c963de430516067cfc099589e4545ca8" translate="yes" xml:space="preserve">
          <source>Packing &lt;code&gt;CString&lt;/code&gt;s and pointers</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 및 포인터 패킹</target>
        </trans-unit>
        <trans-unit id="285f956c0084bc89a501b362eed07b802bf41e30" translate="yes" xml:space="preserve">
          <source>Packing CStrings and pointers</source>
          <target state="translated">CStrings 및 포인터 패킹</target>
        </trans-unit>
        <trans-unit id="a0c8d65ca6bc539ca2a1b96b6e86e38a5baa9898" translate="yes" xml:space="preserve">
          <source>PageMode</source>
          <target state="translated">PageMode</target>
        </trans-unit>
        <trans-unit id="7bf87bd02ae06b49144154cc04ef67e79107b5b6" translate="yes" xml:space="preserve">
          <source>PairS</source>
          <target state="translated">PairS</target>
        </trans-unit>
        <trans-unit id="a0ef17e085dcffd83b4ea0ed40152454a057e949" translate="yes" xml:space="preserve">
          <source>Pairs of format characters and the corresponding part of the input.</source>
          <target state="translated">형식 문자 쌍과 입력의 해당 부분.</target>
        </trans-unit>
        <trans-unit id="fa734be254acf2623327f645a9dcb22bb473a95a" translate="yes" xml:space="preserve">
          <source>Par1</source>
          <target state="translated">Par1</target>
        </trans-unit>
        <trans-unit id="5ef24093c55e5f8c5a103b53816f97bf24faf823" translate="yes" xml:space="preserve">
          <source>ParFlags</source>
          <target state="translated">ParFlags</target>
        </trans-unit>
        <trans-unit id="c48f526b9da677a33e39fdcf90d9349b58ca51c9" translate="yes" xml:space="preserve">
          <source>ParagraphSeparator</source>
          <target state="translated">ParagraphSeparator</target>
        </trans-unit>
        <trans-unit id="9588a94b078f52bbf1493d6bc87cb1b2c5cf0b63" translate="yes" xml:space="preserve">
          <source>Parallel list comprehensions are a natural extension to list comprehensions. List comprehensions can be thought of as a nice syntax for writing maps and filters. Parallel comprehensions extend this to include the &lt;code&gt;zipWith&lt;/code&gt; family.</source>
          <target state="translated">병렬 목록 이해는 이해를 나열하기위한 자연스러운 확장입니다. 리스트 이해는 맵과 필터를 작성하기위한 좋은 구문으로 생각할 수 있습니다. 병렬 이해는 &lt;code&gt;zipWith&lt;/code&gt; 제품군 을 포함하도록이를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="d2e51df32c5b57a230767d0f2b8d7fdcefacc103" translate="yes" xml:space="preserve">
          <source>Parallel statements (as with &lt;a href=&quot;#extension-ParallelListComp&quot;&gt;&lt;code&gt;ParallelListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">병렬 명령문 ( &lt;a href=&quot;#extension-ParallelListComp&quot;&gt; &lt;code&gt;ParallelListComp&lt;/code&gt; &lt;/a&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="fea4bc6e4f648852182893a472b471676de0d12f" translate="yes" xml:space="preserve">
          <source>Parallel statements are translated using the &lt;code&gt;mzip&lt;/code&gt; function, which requires a &lt;code&gt;MonadZip&lt;/code&gt; instance defined in &lt;a href=&quot;../libraries/base-4.13.0.0/control-monad-zip&quot;&gt;Control.Monad.Zip&lt;/a&gt;:</source>
          <target state="translated">병렬 명령문은 &lt;code&gt;mzip&lt;/code&gt; 함수를 사용하여 변환 되며 &lt;a href=&quot;../libraries/base-4.13.0.0/control-monad-zip&quot;&gt;Control.Monad.Zip에&lt;/a&gt; 정의 된 &lt;code&gt;MonadZip&lt;/code&gt; 인스턴스 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b857f551749600d7503643d97e6a057f00f03140" translate="yes" xml:space="preserve">
          <source>ParallelArrays</source>
          <target state="translated">ParallelArrays</target>
        </trans-unit>
        <trans-unit id="69e4ffd2f4416a199955cb75660e245acf30a524" translate="yes" xml:space="preserve">
          <source>ParallelListComp</source>
          <target state="translated">ParallelListComp</target>
        </trans-unit>
        <trans-unit id="26eaabc74e0ecdfad0e89f8cdfa1c0968e3e9ed4" translate="yes" xml:space="preserve">
          <source>Parameterizable list monad, with an inner monad.</source>
          <target state="translated">내부 모나드가있는 파라미터 목록 모나드.</target>
        </trans-unit>
        <trans-unit id="02627bceb378089ccc20d97b38e35aa601c5dccf" translate="yes" xml:space="preserve">
          <source>Parameters can also be given explicit kind signatures if needed. We call the number of parameters in a type family declaration, the family&amp;rsquo;s arity, and all applications of a type family must be fully saturated with respect to that arity. This requirement is unlike ordinary type synonyms and it implies that the kind of a type family is not sufficient to determine a family&amp;rsquo;s arity, and hence in general, also insufficient to determine whether a type family application is well formed. As an example, consider the following declaration:</source>
          <target state="translated">필요한 경우 매개 변수에 명시 적 종류 서명을 부여 할 수도 있습니다. 유형 패밀리 선언, 패밀리의 특성 및 유형 패밀리의 모든 응용 프로그램은 해당 특성과 관련하여 완전히 포화되어야합니다. 이 요구 사항은 일반적인 유형 동의어와 다르며 유형 패밀리의 종류가 패밀리의 특성을 결정하기에 충분하지 않으므로 일반적으로 유형 패밀리 응용 프로그램이 제대로 구성되어 있는지 여부를 판단하기에는 불충분합니다. 예를 들어, 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0a9ec76bad7b4461d4a1d8543c0eaec740e99cd7" translate="yes" xml:space="preserve">
          <source>Parameters concerning context switching</source>
          <target state="translated">컨텍스트 전환에 관한 파라미터</target>
        </trans-unit>
        <trans-unit id="cf4b1fc0bf92b4cc879c4bcbd45ef9ceab45e50c" translate="yes" xml:space="preserve">
          <source>Parameters of the cost-center profiler</source>
          <target state="translated">코스트 센터 프로파일 러의 매개 변수</target>
        </trans-unit>
        <trans-unit id="5457041fcc4bc9dce847560d14805ad2049bc05f" translate="yes" xml:space="preserve">
          <source>Parameters of the garbage collector.</source>
          <target state="translated">가비지 수집기의 매개 변수</target>
        </trans-unit>
        <trans-unit id="f5c5e2b2e3b21a175ea9ad3d8e177b1de7b7db91" translate="yes" xml:space="preserve">
          <source>Parameters of the runtime system</source>
          <target state="translated">런타임 시스템의 매개 변수</target>
        </trans-unit>
        <trans-unit id="070eab54f987bb88657d5187688919e26117fb36" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to event tracing</source>
          <target state="translated">이벤트 추적과 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="4c7921cf2c489ab76d8375681841d6fd080e0971" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to parallelism</source>
          <target state="translated">병렬 처리와 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="d33eae1bb8afa3f42df28e6f633413293fbaba1b" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to the cost-center profiler.</source>
          <target state="translated">코스트 센터 프로파일 러와 관련된 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c4c7a142cf5276b1d4ff46847b29bfe9297aa11a" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to ticky-ticky profiler</source>
          <target state="translated">틱 틱틱 프로파일 러와 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="23d692f07a3fb646a8e54fcd2dc724f4ea2ed2c6" translate="yes" xml:space="preserve">
          <source>Parent</source>
          <target state="translated">Parent</target>
        </trans-unit>
        <trans-unit id="955199855b34047564f59f6340738ac93b4a24c6" translate="yes" xml:space="preserve">
          <source>Parent window, used for modal logon dialog</source>
          <target state="translated">모달 로그온 대화 상자에 사용되는 부모 창</target>
        </trans-unit>
        <trans-unit id="dcdb885a7f7995a4ae5f7735e2dbf7dd0df6c82b" translate="yes" xml:space="preserve">
          <source>ParentName</source>
          <target state="translated">ParentName</target>
        </trans-unit>
        <trans-unit id="fc2a5e24ef9b291c16b2d7d017af998e3868317a" translate="yes" xml:space="preserve">
          <source>Parenthesize an value if the boolean is true.</source>
          <target state="translated">부울이 참이면 값을 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="f6fdd858f972c18cfc63e77f0f9f6ec35b5f5477" translate="yes" xml:space="preserve">
          <source>Parse a single lexeme</source>
          <target state="translated">하나의 exeme 구문 분석</target>
        </trans-unit>
        <trans-unit id="7d1ffbe57b690c268aa7d881a60c206e50319514" translate="yes" xml:space="preserve">
          <source>Parse a string using the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance. Succeeds if there is exactly one valid result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하여 문자열을 구문 분석하십시오 . 정확히 하나의 유효한 결과가 있으면 성공합니다.</target>
        </trans-unit>
        <trans-unit id="0be062266a17add68a7b668ce79822b3887a5efd" translate="yes" xml:space="preserve">
          <source>Parse a string using the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance. Succeeds if there is exactly one valid result. A &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value indicates a parse error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하여 문자열을 구문 분석하십시오 . 정확히 하나의 유효한 결과가 있으면 성공합니다. &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값은 구문 분석 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89b7b9c3cafacbc3fbfa8f182d03db0eb57615a7" translate="yes" xml:space="preserve">
          <source>Parse a time value given a format string. Fails if the input could not be parsed using the given format. See &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석하십시오. 주어진 형식을 사용하여 입력을 구문 분석 할 수 없으면 실패합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01b9f449ab6343ea54f02e26f1e9faf3b8a4900b" translate="yes" xml:space="preserve">
          <source>Parse a time value given a format string. See &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석하십시오. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2bcd9fc04842aba6ce12e98373cf3b96da5c978b" translate="yes" xml:space="preserve">
          <source>Parse a value in either extended or basic format</source>
          <target state="translated">확장 또는 기본 형식으로 값을 구문 분석</target>
        </trans-unit>
        <trans-unit id="2960f380b30894cf9484ebfaf5167a7bcf5265fb" translate="yes" xml:space="preserve">
          <source>Parse a value in the format</source>
          <target state="translated">형식으로 값을 구문 분석</target>
        </trans-unit>
        <trans-unit id="9f1ffb1644b47f32b305b727b8e2f0c4183a5335" translate="yes" xml:space="preserve">
          <source>Parse errors</source>
          <target state="translated">구문 분석 오류</target>
        </trans-unit>
        <trans-unit id="7d315fdee5a3dc981c3a0b2bb2a2a03e5b911e53" translate="yes" xml:space="preserve">
          <source>Parse the most commonly used ISO 8601 format.</source>
          <target state="translated">가장 일반적으로 사용되는 ISO 8601 형식을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="ba0d4aca2cb647cf93798740ced61a0bfc954e4c" translate="yes" xml:space="preserve">
          <source>Parse the specified lexeme and continue as specified. Esp useful for nullary constructors; e.g. &lt;code&gt;choose [(&quot;A&quot;, return A), (&quot;B&quot;, return B)]&lt;/code&gt; We match both Ident and Symbol because the constructor might be an operator eg &lt;code&gt;(:~:)&lt;/code&gt;</source>
          <target state="translated">지정된 lexeme를 구문 분석하고 지정된대로 계속하십시오. null 생성자에 유용한 Esp; 예를 들어 &lt;code&gt;choose [(&quot;A&quot;, return A), (&quot;B&quot;, return B)]&lt;/code&gt; 하십시오. 생성자가 연산자 일 수 있기 때문에 Ident와 Symbol을 모두 일치시킵니다 &lt;code&gt;(:~:)&lt;/code&gt; 예 : (: ~ :)</target>
        </trans-unit>
        <trans-unit id="df633b0d4b46131792d5ed485e94f872474b0ba2" translate="yes" xml:space="preserve">
          <source>ParseError</source>
          <target state="translated">ParseError</target>
        </trans-unit>
        <trans-unit id="e74c212b67cd9480fc62438093300cf8d7822087" translate="yes" xml:space="preserve">
          <source>ParseTime</source>
          <target state="translated">ParseTime</target>
        </trans-unit>
        <trans-unit id="6b8eadf238999f4577c899508ccf16700302cf3d" translate="yes" xml:space="preserve">
          <source>Parsec</source>
          <target state="translated">Parsec</target>
        </trans-unit>
        <trans-unit id="93d479a55d45ca812192b9c77cc2d7af365791e8" translate="yes" xml:space="preserve">
          <source>Parsec compatibility module</source>
          <target state="translated">파섹 호환성 모듈</target>
        </trans-unit>
        <trans-unit id="0ebbdba417d24c756ec9c6928e541e59b0910456" translate="yes" xml:space="preserve">
          <source>ParsecT</source>
          <target state="translated">ParsecT</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="7a7dcdbfe4da553cb0bcd34e1518876f24101cf8" translate="yes" xml:space="preserve">
          <source>Parser from ParseLib with Hugs:</source>
          <target state="translated">포옹으로 ParseLib 파서 :</target>
        </trans-unit>
        <trans-unit id="e72f7d0405a8ed6b01d53d0eb6448cf48e5195fa" translate="yes" xml:space="preserve">
          <source>ParserT monad transformer and Parser type</source>
          <target state="translated">파서 T 모나드 변압기 및 파서 유형</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="028c9661ab1e61cb4cec3408691389cf51931b07" translate="yes" xml:space="preserve">
          <source>Parses a CRLF (see &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:crlf&quot;&gt;crlf&lt;/a&gt;&lt;/code&gt;) or LF (see &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:newline&quot;&gt;newline&lt;/a&gt;&lt;/code&gt;) end-of-line. Returns a newline character ('\n').</source>
          <target state="translated">CRLF ( &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:crlf&quot;&gt;crlf&lt;/a&gt;&lt;/code&gt; 참조 ) 또는 LF ( &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:newline&quot;&gt;newline&lt;/a&gt;&lt;/code&gt; 참조 ) 끝 행을 구문 분석합니다 . 줄 바꿈 문자 ( '\ n')를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d0fe9ef051a87bd91f7557d4ccd0b8aa18260b8" translate="yes" xml:space="preserve">
          <source>Parses a alphabetic or numeric Unicode characters according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt; 에 따라 알파벳 또는 숫자 유니 코드 문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ec0ce986154232212bbae5b429b845073d2f256" translate="yes" xml:space="preserve">
          <source>Parses a carriage return character ('\r') followed by a newline character ('\n'). Returns a newline character.</source>
          <target state="translated">캐리지 리턴 문자 ( '\ r')와 개행 문자 ( '\ n')를 구문 분석합니다. 줄 바꿈 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fcd7bd8ab3c7f5c13d44837c892a5fb90c8df7f" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or 'A' and 'F'). Returns the parsed character.</source>
          <target state="translated">16 진 숫자 ( 'a'와 'f'또는 'A'와 'F'사이의 숫자 또는 문자)를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc1d6a166fc0a683ffa31ab7722f3e4d373d0800" translate="yes" xml:space="preserve">
          <source>Parses a lower case character (according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt; 에 따라 소문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fea022f0b2ddc5b11db2fc69fd4e212597b724d" translate="yes" xml:space="preserve">
          <source>Parses a newline character ('\n'). Returns a newline character.</source>
          <target state="translated">개행 문자 ( '\ n')를 구문 분석합니다. 줄 바꿈 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb63a33324f0ad8223e6e2bee48f6654bd369140" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the decimal system. Returns the value of the number.</source>
          <target state="translated">10 진수 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5df553864aa00be005f0685bbc7543dc85668e7b" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the hexadecimal system. The number should be prefixed with &quot;x&quot; or &quot;X&quot;. Returns the value of the number.</source>
          <target state="translated">16 진수 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 앞에 &quot;x&quot;또는 &quot;X&quot;를 붙여야합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fdb8835ffaf98232d803de2c75c7f642b6b9764" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the octal system. The number should be prefixed with &quot;o&quot; or &quot;O&quot;. Returns the value of the number.</source>
          <target state="translated">8 진법 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 앞에 &quot;o&quot;또는 &quot;O&quot;를 붙여야합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="702ae31de69c688b66eaaac89301521608613ccc" translate="yes" xml:space="preserve">
          <source>Parses a tab character ('\t'). Returns a tab character.</source>
          <target state="translated">탭 문자 ( '\ t')를 구문 분석합니다. 탭 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9324545ed792c080b35aa8a66315fcacf5866ec" translate="yes" xml:space="preserve">
          <source>Parses a time value given a format string. Supports the same %-codes as &lt;code&gt;formatTime&lt;/code&gt;, including &lt;code&gt;%-&lt;/code&gt;, &lt;code&gt;%_&lt;/code&gt; and &lt;code&gt;%0&lt;/code&gt; modifiers, however padding widths are not supported. Case is not significant in the input string. Some variations in the input are accepted:</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석합니다. &lt;code&gt;%-&lt;/code&gt; , &lt;code&gt;%_&lt;/code&gt; 및 &lt;code&gt;%0&lt;/code&gt; 수정자를 포함하여 &lt;code&gt;formatTime&lt;/code&gt; 과 동일한 % 코드를 지원 하지만 패딩 너비는 지원되지 않습니다. 입력 문자열에서 대소 문자가 중요하지 않습니다. 입력의 일부 변형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="05a240ec2c4ee54b0aafba8944a0f8fd2d337fdb" translate="yes" xml:space="preserve">
          <source>Parses a white space character (any character which satisfies &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt;) Returns the parsed character.</source>
          <target state="translated">공백 문자를 구문 분석합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt; 를 충족시키는 모든 문자 ) 구문 분석 된 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2249741f599993c9ad36b1f2a0b1cf7813b2acd1" translate="yes" xml:space="preserve">
          <source>Parses an ASCII digit. Returns the parsed character.</source>
          <target state="translated">ASCII 숫자를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c370ae0764a200203299326c366ffab380d2d3ab" translate="yes" xml:space="preserve">
          <source>Parses an alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">알파벳순의 유니 코드 문자 (소문자, 대문자 및 제목 문자와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt; 에 따른 대소 문자가없는 스크립트 및 수정 자 문자 ) 를 구문 분석 합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b02856d3ea3b460a7fe547f16d9711dbfd09488" translate="yes" xml:space="preserve">
          <source>Parses an octal digit (a character between '0' and '7'). Returns the parsed character.</source>
          <target state="translated">8 진수 ( '0'과 '7'사이의 문자)를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33366516b691b44fa5ef3fef5829a9e0268ab2e5" translate="yes" xml:space="preserve">
          <source>Parses an upper case letter (according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt; 에 따라 대문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f20d25499201ff10834936ff90921a8f64cf44d5" translate="yes" xml:space="preserve">
          <source>Parses and returns the specified character.</source>
          <target state="translated">지정된 문자를 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10734aa6302a05d65e718e02f8812ae26f28348b" translate="yes" xml:space="preserve">
          <source>Parses and returns the specified string.</source>
          <target state="translated">지정된 문자열을 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6fafa4ab77dbc509075d8350b5ba85d1892f213" translate="yes" xml:space="preserve">
          <source>Parses any white space. White space consists of &lt;em&gt;zero&lt;/em&gt; or more occurrences of a &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt;, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공백을 구문 분석합니다. 공백은 &lt;em&gt;0&lt;/em&gt; 개 이상의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt; 발생 , 행 주석 또는 블록 (다중 행) 주석으로 구성됩니다. 블록 주석은 중첩 될 수 있습니다. 주석이 시작되고 종료되는 방법은 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7901356594fa3bfff82ffd8d1edc90fccbbbe877" translate="yes" xml:space="preserve">
          <source>Parses any white space. White space consists of &lt;em&gt;zero&lt;/em&gt; or more occurrences of a &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt;, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공백을 구문 분석합니다. 공백은 &lt;em&gt;0&lt;/em&gt; 개 이상의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt; 발생 , 행 주석 또는 블록 (다중 행) 주석으로 구성됩니다. 블록 주석은 중첩 될 수 있습니다. 주석이 시작되고 종료되는 방법은 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e703e840a13f17d4e0aa6d6407f1c2c408c1f58" translate="yes" xml:space="preserve">
          <source>Parses one or more occurrences of the given parser.</source>
          <target state="translated">주어진 파서의 하나 이상의 발생을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9d53b4cf7f3be2a61b0e8567c529b4e5312e73c2" translate="yes" xml:space="preserve">
          <source>Parses the first one or more characters satisfying the predicate. Fails if none, else succeeds exactly once having consumed all the characters Hence NOT the same as (many1 (satisfy p))</source>
          <target state="translated">술어를 만족시키는 첫 번째 하나 이상의 문자를 구문 분석합니다. 하나도 없으면 모든 문자를 사용한 후 정확히 한 번 성공하므로 (many1 (satisfy p))와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ea87d4852d98a90a7eae890a816dda2be9b64c4" translate="yes" xml:space="preserve">
          <source>Parses the first zero or more characters satisfying the predicate. Always succeeds, exactly once having consumed all the characters Hence NOT the same as (many (satisfy p))</source>
          <target state="translated">술어를 만족시키는 처음 0 개 이상의 문자를 구문 분석합니다. 모든 캐릭터를 정확히 한 번 소비하면 항상 성공하므로 (많은 (만족스러운 p))</target>
        </trans-unit>
        <trans-unit id="572002c6d8895463e970cc35f3fcfe00a42feb77" translate="yes" xml:space="preserve">
          <source>Parses zero or more occurrences of the given parser.</source>
          <target state="translated">주어진 구문 분석기가 0 번 이상 발생하는 구문을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="22a3a9fff72c57faae1e1019e01bc253d1b1b0fd" translate="yes" xml:space="preserve">
          <source>Parsing and counting</source>
          <target state="translated">파싱과 카운팅</target>
        </trans-unit>
        <trans-unit id="ba8c1940ba355106d471b605df97a6aaed96283a" translate="yes" xml:space="preserve">
          <source>Parsing of &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, producing values.</source>
          <target state="translated">값을 생성하는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구문 분석 .</target>
        </trans-unit>
        <trans-unit id="d9978c1c7b4b043b4e8ba4d6fd699578663835c5" translate="yes" xml:space="preserve">
          <source>Parsing of &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, producing values.</source>
          <target state="translated">값을 생성하는 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구문 분석 .</target>
        </trans-unit>
        <trans-unit id="146ac34ef08d750fbdfddd6a4da5cec9cef4309b" translate="yes" xml:space="preserve">
          <source>Partial type signatures (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;) work nicely with visible type application. If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt;. The first argument is a wildcard, just like in a partial type signature. However, if used in a visible type application/visible kind application, it is &lt;em&gt;not&lt;/em&gt; necessary to specify &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; and your code will not generate a warning informing you of the omitted type.</source>
          <target state="translated">부분 유형 서명 ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )은 보이는 유형 응용 프로그램과 잘 작동합니다. 당신 만 두 번째 유형 인수 지정하려면 &lt;code&gt;wurble&lt;/code&gt; 을 , 당신은 말할 수 &lt;code&gt;wurble @_ @Int&lt;/code&gt; . 첫 번째 인수는 부분 형식 서명과 마찬가지로 와일드 카드입니다. 그러나 표시 유형 응용 프로그램 / 표시 유형 응용 프로그램에서 사용되는 경우 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 를 지정할 필요 가 &lt;em&gt;없으며&lt;/em&gt; 코드에서 생략 된 유형을 알리는 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fba127279063c3a22121b9b4cb6f20bc4417959" translate="yes" xml:space="preserve">
          <source>Partial type signatures are allowed for bindings, pattern and expression signatures, except that extra-constraints wildcards are not supported in pattern or expression signatures. In the following example a wildcard is used in each of the three possible contexts.</source>
          <target state="translated">패턴 또는 표현식 서명에서 추가 제약 조건 와일드 카드가 지원되지 않는 것을 제외하고 바인딩, 패턴 및 표현식 서명에 부분 유형 서명이 허용됩니다. 다음 예에서는 세 가지 가능한 컨텍스트 각각에 와일드 카드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99197905e62274bd86f62c48326e7d56161c0bff" translate="yes" xml:space="preserve">
          <source>Partial type signatures can also be used in &lt;a href=&quot;#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; splices.</source>
          <target state="translated">부분 유형 서명은 &lt;a href=&quot;#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; 스플 라이스 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd1d72bf2e9837a6f932897368ed11b7f1f0901d" translate="yes" xml:space="preserve">
          <source>PartialTypeSignatures</source>
          <target state="translated">PartialTypeSignatures</target>
        </trans-unit>
        <trans-unit id="edf72a43b1f566581c4c8c61fcedab5c2b680b1f" translate="yes" xml:space="preserve">
          <source>Partially-applied type synonym.</source>
          <target state="translated">부분적으로 적용되는 유형 동의어.</target>
        </trans-unit>
        <trans-unit id="cb737fe624c5231bedfcaa54cdb5adc3c111d709" translate="yes" xml:space="preserve">
          <source>Partitions a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; into two lists. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted, in order, to the first component of the output. Similarly the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted to the second component of the output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 의 목록을 두 개의 목록으로 분할 합니다. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소는 순서대로 출력의 첫 번째 구성 요소로 추출됩니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소가 출력의 두 번째 구성 요소로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7cd56f2a2a3f47830760edfb89946eb7b9e2cd1" translate="yes" xml:space="preserve">
          <source>Pass</source>
          <target state="translated">Pass</target>
        </trans-unit>
        <trans-unit id="b656895c2b247f1e0e70e028d10540d37d0e6599" translate="yes" xml:space="preserve">
          <source>Pass vector value in vector registers for function calls</source>
          <target state="translated">함수 호출을 위해 벡터 레지스터에 벡터 값 전달</target>
        </trans-unit>
        <trans-unit id="c54625ea849b5bef109f8ba0d861127d6f59b6f9" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to &lt;code&gt;windres&lt;/code&gt; when embedding manifests on Windows. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windows에 매니페스트를 포함 할 때 ⟨option⟨을 &lt;code&gt;windres&lt;/code&gt; 에 전달하십시오. &lt;a href=&quot;#options-linker&quot;&gt;연결에 영향을주는 옵션의 &lt;/a&gt; &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8e81975f1a1782e659196379fb59c4474c28b85" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to CPP (makes sense only if &lt;code&gt;-cpp&lt;/code&gt; is also on).</source>
          <target state="translated">⟨option⟩을 CPP로 전달하십시오 ( &lt;code&gt;-cpp&lt;/code&gt; 도 켜져있는 경우에만 의미 가 있습니다).</target>
        </trans-unit>
        <trans-unit id="1ea097fe05a9a04a2624d60c283feabd36342c47" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the C compiler.</source>
          <target state="translated">compileroption⟩을 C 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5f2245e044e2ee9c7852e79e8e7a89e223c413d0" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the DLL generator.</source>
          <target state="translated">⟨option⟩을 DLL 생성기로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3e2650a6a6f4302b3800e44c6e47bf2e4cf0ce70" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the LLVM compiler.</source>
          <target state="translated">⟨option⟩을 LLVM 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b7042edda33fdbf17c12be5107e2f71d34b5db58" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the LLVM optimiser.</source>
          <target state="translated">⟨옵션⟩을 LLVM 최적화 프로그램에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87ef00b3846b0862a7242d922be5b1f78c247481" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the assembler.</source>
          <target state="translated">⟨option⟩을 어셈블러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c14b71df065b66ba63fa6a047ddbfc4df7c5f0" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the custom pre-processor (see &lt;a href=&quot;#pre-processor&quot;&gt;Options affecting a Haskell pre-processor&lt;/a&gt;).</source>
          <target state="translated">⟨option⟩을 사용자 정의 전처리기에 전달하십시오 ( &lt;a href=&quot;#pre-processor&quot;&gt;Haskell 전처리&lt;/a&gt; 기에 영향을주는 옵션 참조 ).</target>
        </trans-unit>
        <trans-unit id="d4e91bac9331b7ddc74206f5303bffcecba44d00" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the interpreter sub-process (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). A common use for this is to pass RTS options e.g., &lt;code&gt;-opti+RTS -opti-A64m&lt;/code&gt;, or to enable verbosity with &lt;code&gt;-opti-v&lt;/code&gt; to see what messages are being exchanged by GHC and the interpreter.</source>
          <target state="translated">⟨option⟩을 인터프리터 서브 프로세스에 전달하십시오 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 이를위한 일반적인 용도는 RTS 옵션 (예 : &lt;code&gt;-opti+RTS -opti-A64m&lt;/code&gt; )을 전달하거나 &lt;code&gt;-opti-v&lt;/code&gt; 를 통해 자세한 정보 를 표시하여 GHC와 인터프리터가 어떤 메시지를 교환하고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7477215f28d252ddc7702887bc7fd7f09e390008" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the linker.</source>
          <target state="translated">⟨option⟩을 링커에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="ad6fb68d25dbefa94a70ca45187327b9fda1d37c" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the literate pre-processor</source>
          <target state="translated">preoption⟩을 문맹 퇴치 전처리기에 전달</target>
        </trans-unit>
        <trans-unit id="b3edfb19da259e0de688de612c935956f2c99d75" translate="yes" xml:space="preserve">
          <source>Passed to the C compiler.</source>
          <target state="translated">C 컴파일러에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="8be3c943b1609fffbfc51aad666d0a04adf83c9d" translate="yes" xml:space="preserve">
          <source>Password</source>
          <target state="translated">Password</target>
        </trans-unit>
        <trans-unit id="702f90f9120506c7fbea366d22307493c04740b3" translate="yes" xml:space="preserve">
          <source>Password -- may be empty or fake if shadow is in use (pw_passwd)</source>
          <target state="translated">비밀번호-섀도우를 사용중인 경우 비어 있거나 가짜 일 수 있습니다 (pw_passwd)</target>
        </trans-unit>
        <trans-unit id="22002d5b59087455e3e7a19bdb64f504fafce246" translate="yes" xml:space="preserve">
          <source>Pat</source>
          <target state="translated">Pat</target>
        </trans-unit>
        <trans-unit id="eb730bfcc87dd3826515b26e8682ec5987a8eee0" translate="yes" xml:space="preserve">
          <source>PatQ</source>
          <target state="translated">PatQ</target>
        </trans-unit>
        <trans-unit id="9b6958725be0676bc2831daffab79014db1e02d1" translate="yes" xml:space="preserve">
          <source>PatSynArgs</source>
          <target state="translated">PatSynArgs</target>
        </trans-unit>
        <trans-unit id="e528cddb6d761afbae92bc5520282c106e797b9b" translate="yes" xml:space="preserve">
          <source>PatSynArgsQ</source>
          <target state="translated">PatSynArgsQ</target>
        </trans-unit>
        <trans-unit id="fe6ca4a2046e9092fc8b91acbe65f2196eafaf25" translate="yes" xml:space="preserve">
          <source>PatSynDir</source>
          <target state="translated">PatSynDir</target>
        </trans-unit>
        <trans-unit id="a00df6fba9cdb213b7e8fda3d468202a26221183" translate="yes" xml:space="preserve">
          <source>PatSynDirQ</source>
          <target state="translated">PatSynDirQ</target>
        </trans-unit>
        <trans-unit id="f84514555442628f00d3e5269a9f8b67460106af" translate="yes" xml:space="preserve">
          <source>PatSynType</source>
          <target state="translated">PatSynType</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="de556ff45621853b72f3cba9bbc16ba72c53c17f" translate="yes" xml:space="preserve">
          <source>PathNameLimit</source>
          <target state="translated">PathNameLimit</target>
        </trans-unit>
        <trans-unit id="74b7902cc01d30f193138477b0b3be38408b6f9e" translate="yes" xml:space="preserve">
          <source>PathVar</source>
          <target state="translated">PathVar</target>
        </trans-unit>
        <trans-unit id="c605d6954cb5f7d896d41bcc8529b02fa99e63c3" translate="yes" xml:space="preserve">
          <source>Pathname conventions vary from system to system. In particular, the directory separator is &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; on Unix systems and &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo; on Windows systems. In the sections that follow, we shall consistently use &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; as the directory separator; substitute this for the appropriate character for your system.</source>
          <target state="translated">경로 이름 규칙은 시스템마다 다릅니다. 특히 디렉토리 구분 기호는 Unix 시스템에서 &amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;이고 Windows 시스템에서 &amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;입니다. 다음 섹션에서는 디렉토리 구분자로 &quot; &lt;code&gt;/&lt;/code&gt; &quot;를 일관되게 사용합니다 . 시스템에 적합한 문자로 이것을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="011311874049b892a9a1e123a9582477aceacecd" translate="yes" xml:space="preserve">
          <source>Paths specified using the &lt;code&gt;-L ⟨dir⟩&lt;/code&gt; command-line option,</source>
          <target state="translated">&lt;code&gt;-L ⟨dir⟩&lt;/code&gt; 명령 행 옵션을 사용하여 지정된 경로</target>
        </trans-unit>
        <trans-unit id="32c2dd7f8e76f04657fd849dcf202fe7562da7ba" translate="yes" xml:space="preserve">
          <source>Paths with a drive letter are &lt;em&gt;legacy&lt;/em&gt; paths. The drive letters are actually meaningless to the kernel. Just like Unix operating systems, drive letters are just a mount point. You can view your mount points by using the &lt;strong&gt;mountvol&lt;/strong&gt; command.</source>
          <target state="translated">드라이브 문자가있는 경로 는 &lt;em&gt;레거시&lt;/em&gt; 경로입니다. 드라이브 문자는 실제로 커널에게는 의미가 없습니다. Unix 운영 체제와 마찬가지로 드라이브 문자는 마운트 지점 일뿐입니다. &lt;strong&gt;mountvol&lt;/strong&gt; 명령 을 사용하여 마운트 지점을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="c986f82232ab7547ffc16ab2d32c4eed2d129027" translate="yes" xml:space="preserve">
          <source>Pattern &lt;code&gt;P1&lt;/code&gt; can only match against a value of type &lt;code&gt;Maybe Bool&lt;/code&gt;, so function &lt;code&gt;f&lt;/code&gt; is rejected because the type signature is &lt;code&gt;Maybe a&lt;/code&gt;. (To see this, imagine expanding the pattern synonym.)</source>
          <target state="translated">패턴 &lt;code&gt;P1&lt;/code&gt; 은 &lt;code&gt;Maybe Bool&lt;/code&gt; 유형의 값과 만 일치 할 수 있으므로 유형 서명이 &lt;code&gt;Maybe a&lt;/code&gt; 이므로 함수 &lt;code&gt;f&lt;/code&gt; 가 거부 됩니다. (이를 보려면 패턴 동의어를 확장한다고 가정하십시오.)</target>
        </trans-unit>
        <trans-unit id="02736a97b0f28b320047652ff9db6e4230fbb7da" translate="yes" xml:space="preserve">
          <source>Pattern Synonyms (sub constructs)</source>
          <target state="translated">패턴 동의어 (하위 구성)</target>
        </trans-unit>
        <trans-unit id="cc7430cf470514ab4cb77ac5dbdcb450d6be72dc" translate="yes" xml:space="preserve">
          <source>Pattern in Haskell given in &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 에 주어진 Haskell의 패턴</target>
        </trans-unit>
        <trans-unit id="006f91db2b8fd81b325a7a341c644b6d5a498639" translate="yes" xml:space="preserve">
          <source>Pattern match on a type constructor</source>
          <target state="translated">형식 생성자에서의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="429f1b07411fa0d99aa1398b100abdf4c33d79a4" translate="yes" xml:space="preserve">
          <source>Pattern match on a type constructor including its instantiated kind variables.</source>
          <target state="translated">인스턴스화 된 종류 변수를 포함하여 형식 생성자의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="6bca3430dd62bc5373edba36f1b7fdbacb161c1c" translate="yes" xml:space="preserve">
          <source>Pattern splices introduce variable binders but scoping of variables in expressions inside the pattern&amp;rsquo;s scope is only checked when a splice is run. Note that pattern splices that occur outside of any quotation brackets are run at compile time. Pattern splices occurring inside a quotation bracket are &lt;em&gt;not&lt;/em&gt; run at compile time; they are run when the bracket is spliced in, sometime later. For example,</source>
          <target state="translated">패턴 스플 라이스에는 가변 바인더가 도입되지만 패턴 범위 내 표현식의 변수 범위는 스플 라이스가 실행될 때만 확인됩니다. 따옴표 괄호 밖에서 발생하는 패턴 스플 라이스는 컴파일 타임에 실행됩니다. 따옴표로 묶는 패턴 스플 라이스 는 컴파일 타임에 실행 &lt;em&gt;되지 않습니다&lt;/em&gt; . 브라켓이 연결될 때, 나중에 언젠가 실행됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a6afa01cf2dd70cd7e0003f6ed14c46fc954840d" translate="yes" xml:space="preserve">
          <source>Pattern splices: anonymous and named wildcards can be used in pattern signatures. Note that &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; has to be enabled to allow pattern signatures. Extra-constraints wildcards are not supported, just like in regular pattern signatures.</source>
          <target state="translated">패턴 스플 라이스 : 익명 및 명명 된 와일드 카드를 패턴 서명에 사용할 수 있습니다. 참고 것을 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 패턴 서명을 할 수 있도록 활성화해야합니다. 일반 패턴 서명에서와 같이 추가 제약 조건 와일드 카드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f77741e8cc6b9f0b1d51a80487612daf3480f01" translate="yes" xml:space="preserve">
          <source>Pattern synonym declaration</source>
          <target state="translated">패턴 동의어 선언</target>
        </trans-unit>
        <trans-unit id="87f1062186506aaa4f45d8a2e88afacdc300284d" translate="yes" xml:space="preserve">
          <source>Pattern synonym declarations can only occur in the top level of a module. In particular, they are not allowed as local definitions.</source>
          <target state="translated">패턴 동의어 선언은 모듈의 최상위 레벨에서만 발생할 수 있습니다. 특히, 로컬 정의로 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2c3bb10828440ff7c7e123c5c710d07e5748ac9" translate="yes" xml:space="preserve">
          <source>Pattern synonym examples</source>
          <target state="translated">패턴 동의어 예</target>
        </trans-unit>
        <trans-unit id="c5e40750951e5693f88641df15605c5bd88c4b78" translate="yes" xml:space="preserve">
          <source>Pattern synonym type signature</source>
          <target state="translated">패턴 동의어 유형 서명</target>
        </trans-unit>
        <trans-unit id="51c5410ff060e342b214a06f194717b99df3b318" translate="yes" xml:space="preserve">
          <source>Pattern synonym types interact with TH when (a) reifying a pattern synonym, (b) pretty printing, or (c) specifying a pattern synonym's type signature explicitly:</source>
          <target state="translated">패턴 동의어 유형은 (a) 패턴 동의어 수정, (b) 예쁜 인쇄 또는 (c) 패턴 동의어의 유형 서명을 명시 적으로 지정할 때 TH와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="f1ad9c9cdb2599bd5e1fe2e83cbb8368c9be95f6" translate="yes" xml:space="preserve">
          <source>Pattern synonyms</source>
          <target state="translated">패턴 동의어</target>
        </trans-unit>
        <trans-unit id="f284b9c8384401a92e74a36de73bee9bba48c472" translate="yes" xml:space="preserve">
          <source>Pattern synonyms are enabled by the language extension &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt;, which is required for defining them, but &lt;em&gt;not&lt;/em&gt; for using them. More information and examples of pattern synonyms can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">패턴 동의어는 언어 확장 인 &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; 에&lt;/a&gt; 의해 사용 가능하며 이를 정의하는 데 필요하지만 사용 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 패턴 동의어에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0924abc7007f369091850e500801334d4015307f" translate="yes" xml:space="preserve">
          <source>Pattern synonyms are not supported.</source>
          <target state="translated">패턴 동의어는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34d581f8945b7df9b46a71872a91832ad9199e66" translate="yes" xml:space="preserve">
          <source>Pattern synonyms cannot be defined recursively.</source>
          <target state="translated">패턴 동의어는 재귀 적으로 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dc90cc727d872f8ad295d8c8e70891697a625b4" translate="yes" xml:space="preserve">
          <source>Pattern synonyms enable giving names to parametrized pattern schemes. They can also be thought of as abstract constructors that don&amp;rsquo;t have a bearing on data representation. For example, in a programming language implementation, we might represent types of the language as follows:</source>
          <target state="translated">패턴 동의어를 사용하면 매개 변수화 된 패턴 체계에 이름을 지정할 수 있습니다. 또한 데이터 표현과 관련이없는 추상 생성자로 생각할 수 있습니다. 예를 들어, 프로그래밍 언어 구현에서 다음과 같이 언어 유형을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21344d9f424a665540813e111458633c97a5bdc" translate="yes" xml:space="preserve">
          <source>Pattern synonyms permit abstracting from the representation to expose matchers that behave in a constructor-like manner with respect to pattern matching. We can create pattern synonyms for the known types we care about, without committing the representation to them (note that these don&amp;rsquo;t have to be defined in the same module as the &lt;code&gt;Type&lt;/code&gt; type):</source>
          <target state="translated">패턴 동의어는 표현에서 추상화하여 패턴 일치와 관련하여 생성자와 유사한 방식으로 동작하는 매처를 노출시킵니다. 우리는 관심있는 알려진 유형에 대한 표현 동의를 만들 수 있습니다 (표현을 커밋하지 않음 ). 이러한 &lt;code&gt;Type&lt;/code&gt; 은 유형 유형 과 동일한 모듈에서 정의 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b5e68af793661029a634f35b2a59b11f9b9320" translate="yes" xml:space="preserve">
          <source>PatternGuards</source>
          <target state="translated">PatternGuards</target>
        </trans-unit>
        <trans-unit id="b082623c56fa21b4be183e2556bcea6fc12a68f9" translate="yes" xml:space="preserve">
          <source>PatternMatchFail</source>
          <target state="translated">PatternMatchFail</target>
        </trans-unit>
        <trans-unit id="8b4c340e8567284d5ccd5a9a1b9deca1c715a890" translate="yes" xml:space="preserve">
          <source>PatternSynonyms</source>
          <target state="translated">PatternSynonyms</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="5aa426e2424e04e94a5a3e7b592a1b40bfa6724a" translate="yes" xml:space="preserve">
          <source>Pc: Punctuation, Connector</source>
          <target state="translated">PC : 문장 부호, 커넥터</target>
        </trans-unit>
        <trans-unit id="30297337298c9a17c0e9ce8ff4fbffe4052874dd" translate="yes" xml:space="preserve">
          <source>Pd: Punctuation, Dash</source>
          <target state="translated">Pd : 문장 부호, 대시</target>
        </trans-unit>
        <trans-unit id="a80098f29b2d23293bbe78beff8b9cdca1b4c011" translate="yes" xml:space="preserve">
          <source>Pe: Punctuation, Close</source>
          <target state="translated">Pe : 구두점, 닫기</target>
        </trans-unit>
        <trans-unit id="31566e3d063dad33b6e08c2f7f3e776d7e1473fd" translate="yes" xml:space="preserve">
          <source>Per default the events are written to &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; though the mechanism for writing event log data can be overriden with a custom &lt;code&gt;EventLogWriter&lt;/code&gt;.</source>
          <target state="translated">이벤트 로그 데이터 작성 메커니즘을 사용자 정의 &lt;code&gt;EventLogWriter&lt;/code&gt; 로 대체 할 수 있지만 기본적으로 이벤트는 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7ef19e5bbcb51e651936b58513fef51416adde3" translate="yes" xml:space="preserve">
          <source>Perform a series of STM actions atomically.</source>
          <target state="translated">일련의 STM 작업을 원자 적으로 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2c9ff4fe99f8968fc212ca25889a616ce793a23b" translate="yes" xml:space="preserve">
          <source>Perform compilation in parallel when possible. GHC will use up to ⟨N⟩ threads during compilation. If N is omitted, then it defaults to the number of processors. Note that compilation of a module may not begin until its dependencies have been built.</source>
          <target state="translated">가능하면 컴파일을 병렬로 수행하십시오. GHC는 컴파일하는 동안 최대 ⟨N⟩ 스레드를 사용합니다. N을 생략하면 기본값은 프로세서 수입니다. 종속 모듈이 빌드 될 때까지 모듈 컴파일이 시작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f08a49b25677e2e61a727558011649fabe0e79a8" translate="yes" xml:space="preserve">
          <source>Perform other memory allocation, including in the GC, from node-local memory.</source>
          <target state="translated">노드 로컬 메모리에서 GC를 포함하여 다른 메모리 할당을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c8aeaee99f19647da8cbc145bb54bbe2aea3ac7" translate="yes" xml:space="preserve">
          <source>Perform some computation without adding new entries to the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 새 항목을 추가하지 않고 계산을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc6f40aca7e3932befef5ea8a6cf34162fbd455b" translate="yes" xml:space="preserve">
          <source>Perform some simplification of a built up &lt;code&gt;GDoc&lt;/code&gt;.</source>
          <target state="translated">빌드 된 &lt;code&gt;GDoc&lt;/code&gt; 의 단순화를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="a40043065024f7a1212f7fbbfa9112c036c35b22" translate="yes" xml:space="preserve">
          <source>Performance information</source>
          <target state="translated">성능 정보</target>
        </trans-unit>
        <trans-unit id="2195bce8153488b859e69e630a7482f89cfcc5de" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;fdatasync(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;fdatasync(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="b7a0417e81aba8bc8d001bca03740cbc7548d90f" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;fsync(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;fsync(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="b29525a36bb807819b75d77b028444eec3dd3744" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;posix_fadvise(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 조작을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="abc537c00b7a43d3addf179337e100cbe868862f" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;posix_fallocate(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="979b1f14628086440e0d691aadba7221f17405ab" translate="yes" xml:space="preserve">
          <source>Performs completions from the given line state.</source>
          <target state="translated">주어진 회선 상태에서 완료를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d6f5806ebaf90276049ece561409944ce93d2f6e" translate="yes" xml:space="preserve">
          <source>PermParser</source>
          <target state="translated">PermParser</target>
        </trans-unit>
        <trans-unit id="4636c20125232583a78fcf9bd2b7beb3e0ee79a6" translate="yes" xml:space="preserve">
          <source>PermissionDenied</source>
          <target state="translated">PermissionDenied</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="d8940d325390445ba152697d12492c72d0b04785" translate="yes" xml:space="preserve">
          <source>Permit definition of instances which may lead to type-checker non-termination.</source>
          <target state="translated">유형 검사기가 종료되지 않을 수있는 인스턴스 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="393bb39440da7f4d26358355203d3146a3259f99" translate="yes" xml:space="preserve">
          <source>Permute</source>
          <target state="translated">Permute</target>
        </trans-unit>
        <trans-unit id="bf005fa540ff716e77993a2f382021660a60dc6a" translate="yes" xml:space="preserve">
          <source>Pf: Punctuation, Final quote</source>
          <target state="translated">Pf : 문장 부호, 최종 견적</target>
        </trans-unit>
        <trans-unit id="130c4886394ecb032566d46f2ceb00d5633b56b7" translate="yes" xml:space="preserve">
          <source>PhantomR</source>
          <target state="translated">PhantomR</target>
        </trans-unit>
        <trans-unit id="5c5efd35d4de06a56cd9d8bce7ff35054fbfb6e4" translate="yes" xml:space="preserve">
          <source>Phase of the compilation system</source>
          <target state="translated">컴파일 시스템의 단계</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="9e4383ed7770bf7128e27cfd3770dcc6a2f9ac77" translate="yes" xml:space="preserve">
          <source>Pi: Punctuation, Initial quote</source>
          <target state="translated">Pi : 문장 부호, 초기 견적</target>
        </trans-unit>
        <trans-unit id="6dc7779c6f76a5529f40811ad41c4010cc153569" translate="yes" xml:space="preserve">
          <source>Picking the right capability will help avoid unnecessary context switches. Ideally you should pass the capability that the thread that will be woken up last ran on, which you can find by calling &lt;code&gt;threadCapability&lt;/code&gt; in Haskell.</source>
          <target state="translated">올바른 기능을 선택하면 불필요한 컨텍스트 전환을 피할 수 있습니다. 이상적으로 마지막으로 깨어 난 스레드가 Haskell에서 &lt;code&gt;threadCapability&lt;/code&gt; 를 호출하여 찾을 수있는 기능을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b18587952820d0dbe6bad15e1dae415748031e5" translate="yes" xml:space="preserve">
          <source>Pico</source>
          <target state="translated">Pico</target>
        </trans-unit>
        <trans-unit id="f298de9cea75ea5230dda5d9d28b4989aaf746f4" translate="yes" xml:space="preserve">
          <source>Pid</source>
          <target state="translated">Pid</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="24a740d84ffcf739518c3074866ef1329aa79368" translate="yes" xml:space="preserve">
          <source>PipeBufferLimit</source>
          <target state="translated">PipeBufferLimit</target>
        </trans-unit>
        <trans-unit id="785af2a4ad3c4ee912623c6e0b6d4299ea305bf6" translate="yes" xml:space="preserve">
          <source>Pipes</source>
          <target state="translated">Pipes</target>
        </trans-unit>
        <trans-unit id="9e0a7d72506eac8eb62beb562cc0a99b2b58da61" translate="yes" xml:space="preserve">
          <source>PkgName</source>
          <target state="translated">PkgName</target>
        </trans-unit>
        <trans-unit id="323e26c5cebb97e7dbf03cace1de3f19bb3506f8" translate="yes" xml:space="preserve">
          <source>Place each generated function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section&amp;rsquo;s name in the output file.</source>
          <target state="translated">대상이 임의의 섹션을 지원하는 경우 생성 된 각 함수 또는 데이터 항목을 출력 파일의 자체 섹션에 배치하십시오. 함수 이름 또는 데이터 항목 이름에 따라 출력 파일의 섹션 이름이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7dccde26d3e873a5cc6c187e13a2e64082046864" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;INLINE&lt;/code&gt; pragmas on certain functions that are used a lot can have a dramatic effect. See &lt;a href=&quot;glasgow_exts#inline-pragma&quot;&gt;INLINE pragma&lt;/a&gt;.</source>
          <target state="translated">많이 사용되는 특정 기능 에 &lt;code&gt;INLINE&lt;/code&gt; pragma를 배치 하면 극적인 효과를 낼 수 있습니다. &lt;a href=&quot;glasgow_exts#inline-pragma&quot;&gt;인라인 pragma를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5104db6573a7bcd152469e6c86edf365a7ccbe8" translate="yes" xml:space="preserve">
          <source>Placing a &lt;code&gt;.ghci&lt;/code&gt; file in a directory with a Haskell project is a useful way to set certain project-wide options so you don&amp;rsquo;t have to type them every time you start GHCi: eg. if your project uses multi-parameter type classes, scoped type variables, and CPP, and has source files in three subdirectories A, B and C, you might put the following lines in &lt;code&gt;.ghci&lt;/code&gt;:</source>
          <target state="translated">Haskell 프로젝트가있는 디렉토리에 &lt;code&gt;.ghci&lt;/code&gt; 파일을 배치하는 것은 GHCi 를 시작할 때마다 입력하지 않아도되는 특정 프로젝트 전체 옵션을 설정하는 유용한 방법입니다. 프로젝트가 다중 매개 변수 유형 클래스, 범위 유형 변수 및 CPP를 사용하고 세 개의 서브 디렉토리 A, B 및 C에 소스 파일이있는 경우 다음 행을 &lt;code&gt;.ghci&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c995f73efb3edc21d7f6d4456e31809091cc4f7" translate="yes" xml:space="preserve">
          <source>Platform differences</source>
          <target state="translated">플랫폼 차이</target>
        </trans-unit>
        <trans-unit id="f47156297a84abbf7baa9ecfe8129e469a19a3f7" translate="yes" xml:space="preserve">
          <source>Please advise us of other &amp;ldquo;helpful hints&amp;rdquo; that should go here!</source>
          <target state="translated">여기에 가야 할 다른&amp;ldquo;유용한 힌트&amp;rdquo;를 알려주십시오!</target>
        </trans-unit>
        <trans-unit id="506c81a0d84a987facc6b6cad61df64acf77c49e" translate="yes" xml:space="preserve">
          <source>Please do not confuse &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, respectively. The latter are for exceptions built into GHC, by default, and are mostly used from within the IO monad. They do not interact with the &quot;exceptions&quot; in this package at all. This package allows you to define a new kind of exception control mechanism which does not necessarily need your code to be placed in the IO monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 를 각각 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 와 혼동하지 마십시오 . 후자는 기본적으로 GHC에 내장 된 예외에 대한 것이며 IO 모나드 내에서 주로 사용됩니다. 그들은이 패키지의 &quot;예외&quot;와 전혀 상호 작용하지 않습니다. 이 패키지를 사용하면 IO 모나드에 코드를 배치 할 필요가없는 새로운 종류의 예외 제어 메커니즘을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c73afae87542d6e8cd63fcf7f4fddd71f7004f" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5600a929920bed98ead548566e18fe4443f663d1" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e69690c3be83e6b82a76a0137695bb5c56adc7bc" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="11da447f43cf46de988876b5572b594db0d725d8" translate="yes" xml:space="preserve">
          <source>Please report any overly-slow GHC-compiled programs. Since GHC doesn&amp;rsquo;t have any credible competition in the performance department these days it&amp;rsquo;s hard to say what overly-slow means, so just use your judgement! Of course, if a GHC compiled program runs slower than the same program compiled with NHC or Hugs, then it&amp;rsquo;s definitely a bug.</source>
          <target state="translated">지나치게 느린 GHC 컴파일 프로그램을보고하십시오. GHC는 요즘 퍼포먼스 부서에서 경쟁이 치열하지 않기 때문에 너무 느리게 무엇을 의미하는지 말하기는 어렵 기 때문에 판단을 사용하십시오! 물론, GHC 컴파일 프로그램이 NHC 또는 Hugs로 컴파일 된 동일한 프로그램보다 느리게 실행된다면, 이는 분명히 버그입니다.</target>
        </trans-unit>
        <trans-unit id="fe030bc44cd445dd18c598d2cb1edf112abb8e3c" translate="yes" xml:space="preserve">
          <source>Please report line-number errors that you find particularly unhelpful.</source>
          <target state="translated">특히 도움이되지 않는 줄 번호 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="4bd277cac9b50a94c530d065fbd95d2bb254e2e7" translate="yes" xml:space="preserve">
          <source>Please see the GHC API documentation for more about how to use internal APIs, etc.</source>
          <target state="translated">내부 API 사용 방법 등에 대한 자세한 내용은 GHC API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cda26be1b0861c9ec0b102448fed676a99b6b48e" translate="yes" xml:space="preserve">
          <source>Please, oh please, use the &lt;code&gt;-v&lt;/code&gt; option when reporting bugs! Knowing that you ran the right bits in the right order is always the first thing we want to verify.</source>
          <target state="translated">버그를보고 할 때는 &lt;code&gt;-v&lt;/code&gt; 옵션을 사용하십시오 . 올바른 순서대로 올바른 비트를 실행했음을 아는 것이 항상 가장 먼저 확인하려는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f4d3ab5a5554b6ec4bae40adfb407a50ae52738" translate="yes" xml:space="preserve">
          <source>Plugin code runs in the &lt;code&gt;TcPluginM&lt;/code&gt; monad, which provides a restricted interface to GHC API functionality that is relevant for typechecker plugins, including &lt;code&gt;IO&lt;/code&gt; and reading the environment. If you need functionality that is not exposed in the &lt;code&gt;TcPluginM&lt;/code&gt; module, you can use &lt;code&gt;unsafeTcPluginTcM :: TcM a -&amp;gt; TcPluginM a&lt;/code&gt;, but are encouraged to contact the GHC team to suggest additions to the interface. Note that &lt;code&gt;TcPluginM&lt;/code&gt; can perform arbitrary IO via &lt;code&gt;tcPluginIO :: IO a -&amp;gt; TcPluginM a&lt;/code&gt;, although some care must be taken with side effects (particularly in &lt;code&gt;tcPluginSolve&lt;/code&gt;). In general, it is up to the plugin author to make sure that any IO they do is safe.</source>
          <target state="translated">플러그인 코드는 &lt;code&gt;TcPluginM&lt;/code&gt; 모나드 에서 실행되며 &lt;code&gt;IO&lt;/code&gt; 및 환경 읽기를 포함하여 유형 검사기 플러그인과 관련된 GHC API 기능에 대한 제한된 인터페이스를 제공 합니다. &lt;code&gt;TcPluginM&lt;/code&gt; 모듈에 노출되지 않은 기능이 필요한 경우 &lt;code&gt;unsafeTcPluginTcM :: TcM a -&amp;gt; TcPluginM a&lt;/code&gt; 를 사용할 수 있지만 GHC 팀에 연락하여 인터페이스 추가를 제안하는 것이 좋습니다. 참고 &lt;code&gt;TcPluginM&lt;/code&gt; 를 통해 임의의 IO 수행 &lt;code&gt;tcPluginIO :: IO a -&amp;gt; TcPluginM a&lt;/code&gt; 일부주의 (특히에 부작용주의해야하지만 &lt;code&gt;tcPluginSolve&lt;/code&gt; ). 일반적으로 플러그인 작성자는 IO가 안전한지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a02b13ee0dd37a4f7f44345efb7f4d0b31df1b9" translate="yes" xml:space="preserve">
          <source>Plugin modules live in a separate namespace from the user import namespace. By default, these two namespaces are the same; however, there are a few command line options which control specifically plugin packages:</source>
          <target state="translated">플러그인 모듈은 사용자 가져 오기 네임 스페이스와 별도의 네임 스페이스에 있습니다. 기본적으로이 두 네임 스페이스는 동일합니다. 그러나 특별히 플러그인 패키지를 제어하는 ​​몇 가지 명령 줄 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76e0a28ea1fdb9e9e6ad3248cf9ef3d98836e8e" translate="yes" xml:space="preserve">
          <source>Plugins are modules that export at least a single identifier, &lt;code&gt;plugin&lt;/code&gt;, of type &lt;code&gt;GhcPlugins.Plugin&lt;/code&gt;. All plugins should &lt;code&gt;import GhcPlugins&lt;/code&gt; as it defines the interface to the compilation pipeline.</source>
          <target state="translated">플러그인은 최소한 &lt;code&gt;GhcPlugins.Plugin&lt;/code&gt; 유형 의 단일 식별자 &lt;code&gt;plugin&lt;/code&gt; 을 내보내는 모듈입니다 . 모든 플러그인은 &lt;code&gt;import GhcPlugins&lt;/code&gt; 를 가져와야합니다 컴파일 파이프 라인에 대한 인터페이스를 정의 할 때 를 합니다.</target>
        </trans-unit>
        <trans-unit id="50a78f3b1666118502953351a9e4c0ece78555a4" translate="yes" xml:space="preserve">
          <source>Plugins are provided with all available constraints (including equalities and typeclass constraints), but it is easy for them to discard those that are not relevant to their domain, because they need return only those constraints for which they have made progress (either by solving or contradicting them).</source>
          <target state="translated">플러그인에는 사용 가능한 모든 제약 조건 (등식 및 유형 클래스 제약 조건 포함)이 제공되지만 도메인과 관련이없는 제약 조건은 버릴 수 있습니다. 모순).</target>
        </trans-unit>
        <trans-unit id="bcfecc84377584d4ad3cb1e967e83c8d968b6d81" translate="yes" xml:space="preserve">
          <source>Plugins can be added on the command line with the &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt; option where ⟨module⟩ is a module in a registered package that exports the plugin. Arguments can be passed to the plugins with the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; option. The list of enabled plugins can be reset with the &lt;a href=&quot;#ghc-flag--fclear-plugins&quot;&gt;&lt;code&gt;-fclear-plugins&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 명령 행에 추가 할 수 있습니다. 여기서 ⟨module⟩은 플러그인을 내보내는 등록 된 패키지의 모듈입니다. &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 인수를 플러그인에 전달할 수 있습니다 . 활성화 된 플러그인 목록은 &lt;a href=&quot;#ghc-flag--fclear-plugins&quot;&gt; &lt;code&gt;-fclear-plugins&lt;/code&gt; 를&lt;/a&gt; 사용하여 재설정 할 수 있습니다. 옵션을 .</target>
        </trans-unit>
        <trans-unit id="d3c33bcc738bc3d4e4633fbe0d574f0b8c7bf15d" translate="yes" xml:space="preserve">
          <source>Plugins cannot optimize/inspect C-\-, nor can they implement things like parser/front-end modifications like GCC, apart from limited changes to the constraint solver. If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">플러그인은 C-\-를 최적화 / 검사 할 수 없으며 제약 조건 솔버의 제한된 변경 외에 GCC와 같은 파서 / 프런트 엔드 수정과 같은 것을 구현할 수 없습니다. 이러한 제한 사항 중 하나라도 너무 성가 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;시다고 생각되면 GHC 팀에게 소리 지르십시오.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1acd4a0590b84ad78012a8281aa3759223cdd151" translate="yes" xml:space="preserve">
          <source>Plugins do not work with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;. If you need to run plugins with &lt;code&gt;-fexternal-interpreter&lt;/code&gt; let GHC developers know in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;Issue #14335&lt;/a&gt;.</source>
          <target state="translated">플러그인은 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 와 함께 작동하지 않습니다 . &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 를 사용 하여 플러그인을 실행해야하는 경우 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;문제 # 14335&lt;/a&gt; 에서 GHC 개발자에게 알리십시오. .</target>
        </trans-unit>
        <trans-unit id="0d1483c843780c87aec4fd3aa51d7d94a8b96a4e" translate="yes" xml:space="preserve">
          <source>Po: Punctuation, Other</source>
          <target state="translated">Po : 구두점, 기타</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="a7f9dff21b1ddcdcf80248743f347d8d0da9bd72" translate="yes" xml:space="preserve">
          <source>Pointer equality.</source>
          <target state="translated">포인터 평등.</target>
        </trans-unit>
        <trans-unit id="c8e8cc6922489fcddbf0a22dd3e2de7b10d8bd37" translate="yes" xml:space="preserve">
          <source>Polar form</source>
          <target state="translated">극지 형태</target>
        </trans-unit>
        <trans-unit id="08ec06c8c3d316a130a751bea478b9d8cd36463e" translate="yes" xml:space="preserve">
          <source>Poll the semaphore until it is available, then lock it. Unlike semWait, this will block only the current thread rather than the entire process.</source>
          <target state="translated">사용 가능할 때까지 세마포어를여십시오. 그런 다음 잠그십시오. semWait와 달리 전체 프로세스가 아닌 현재 스레드 만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="f60030530d452b22d889af65e4dbea1ad5231ba6" translate="yes" xml:space="preserve">
          <source>PolyKinds</source>
          <target state="translated">PolyKinds</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="41b680d741ab1eaec7b7f722d04d7131ec90b3b5" translate="yes" xml:space="preserve">
          <source>Pool management</source>
          <target state="translated">수영장 관리</target>
        </trans-unit>
        <trans-unit id="71deae26a59f4c366e9d565ae1eea4f3ace4a347" translate="yes" xml:space="preserve">
          <source>Pools are currently implemented using &lt;code&gt;malloc/free&lt;/code&gt;, so while they might be a more convenient way to structure your memory allocation than using one of the other forms of allocation, they won&amp;rsquo;t be any more efficient. We do plan to provide an improved-performance implementation of Pools in the future, however.</source>
          <target state="translated">풀은 현재 &lt;code&gt;malloc/free&lt;/code&gt; 를 사용하여 구현됩니다. 되므로 다른 형태의 할당 중 하나를 사용하는 것보다 메모리 할당을 구성하는 것이 더 편리한 방법 일 수 있지만 더 효율적이지 않습니다. 그러나 향후 개선 된 풀 구현을 제공 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="2df5eed666ad15052a9c4b2714990bcfc3e1bfe4" translate="yes" xml:space="preserve">
          <source>Pop the ByteString we have constructed so far, if any, yielding a new chunk in the result ByteString.</source>
          <target state="translated">지금까지 생성 한 ByteString을 팝하면 결과 ByteString에 새로운 청크가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fe9afec2cdc2c7d8517084a2d65a63864d25ccaa" translate="yes" xml:space="preserve">
          <source>Pop the most recent call-site off the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 가장 최근의 콜 사이트를 팝하십시오 .</target>
        </trans-unit>
        <trans-unit id="184d55340a7ea9436efac0e4b30658a294cc194c" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator on the tag, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 비교기를 사용하여 큐에서 가장 작은 요소를 팝하여 비교기가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치를 지연시킵니다 .</target>
        </trans-unit>
        <trans-unit id="2b8d7b36ba997a86666ef5b0a2e955a7f3121f1d" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator on the tag.</source>
          <target state="translated">제공된 비교기를 사용하여 대기열에서 가장 작은 요소를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d0305355484ccbf0a5332dd6a8f21a5cc2b3e243" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 비교기를 사용하여 비교기에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치를 지연시키면서 큐에서 가장 작은 요소를 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="ecde65687583e5067a6f236eb0adeaea9fb3c926" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator.</source>
          <target state="translated">제공된 비교기를 사용하여 큐에서 가장 작은 요소를 팝하십시오.</target>
        </trans-unit>
        <trans-unit id="b307b88c84327b1804aee227595be53342245965" translate="yes" xml:space="preserve">
          <source>Portability</source>
          <target state="translated">Portability</target>
        </trans-unit>
        <trans-unit id="1bacaf21b2fe90b21bbc565ba919a04acd5baee5" translate="yes" xml:space="preserve">
          <source>Portable</source>
          <target state="translated">Portable</target>
        </trans-unit>
        <trans-unit id="89d8f29ace289b18dbbef31338d9cf587f44295f" translate="yes" xml:space="preserve">
          <source>Portable to Hugs and GHC. Requires MPTCs</source>
          <target state="translated">포옹과 GHC에 휴대용. MPTC 필요</target>
        </trans-unit>
        <trans-unit id="d67331323a539f65439ac2219e811fa90a48d4a1" translate="yes" xml:space="preserve">
          <source>Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009</source>
          <target state="translated">저작권 : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009</target>
        </trans-unit>
        <trans-unit id="3db8887ea19a282f0bf7fbe5de701083bec25186" translate="yes" xml:space="preserve">
          <source>Portions obtained from hbc (c) Lennart Augusstson</source>
          <target state="translated">hbc (c) Lennart Augusstson에서 얻은 부분</target>
        </trans-unit>
        <trans-unit id="c9b1b30d011fe2b612eff7c95b1c553cdf039f7c" translate="yes" xml:space="preserve">
          <source>Pos</source>
          <target state="translated">Pos</target>
        </trans-unit>
        <trans-unit id="cf1c85adba548e8d681255278976584a7e4a44de" translate="yes" xml:space="preserve">
          <source>Position</source>
          <target state="translated">Position</target>
        </trans-unit>
        <trans-unit id="718239faf2c7ad4b5be8fc3d53f933e6298dd64c" translate="yes" xml:space="preserve">
          <source>Position in file</source>
          <target state="translated">파일에서의 위치</target>
        </trans-unit>
        <trans-unit id="a98f91ff888a0baac961ccc11866ac56d92f3491" translate="yes" xml:space="preserve">
          <source>Position independent executables are required by some platforms as they enable address-space layout randomization (ASLR), a common security measure. They can also be useful as they can be dynamically loaded and used as shared libraries by other executables.</source>
          <target state="translated">위치 독립적 인 실행 파일은 일반적인 보안 수단 인 ASLR (Address-space Layout Randomization)을 지원하므로 일부 플랫폼에서 필요합니다. 또한 다른 실행 파일에서 동적으로로드하여 공유 라이브러리로 사용할 수 있으므로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a42e40e7381223e58fc6699427898624e3d568b" translate="yes" xml:space="preserve">
          <source>Position independent executables should be dynamically-linked (e.g. built with &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and only loaded into other dynamically-linked executables to ensure that only one &lt;code&gt;libHSrts&lt;/code&gt; is present if loaded into the address space of another Haskell process.</source>
          <target state="translated">위치 독립적 실행 파일은 동적으로 연결되어야합니다 (예 : &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 으로&lt;/a&gt; 빌드 되고 다른 동적 연결 실행 파일에만로드되어 하나의 &lt;code&gt;libHSrts&lt;/code&gt; 만 보장됨) 다른 Haskell 프로세스의 주소 공간에로드 된 경우 존재 로드 됨).</target>
        </trans-unit>
        <trans-unit id="f21a0136d6ab8fb27cd7d944927f57c96bb35706" translate="yes" xml:space="preserve">
          <source>PosixVersion</source>
          <target state="translated">PosixVersion</target>
        </trans-unit>
        <trans-unit id="6662b9da87a72fea9bd249c0718c63c20d41c5e4" translate="yes" xml:space="preserve">
          <source>Postcomposition with a pure function (right-to-left variant).</source>
          <target state="translated">순수한 기능을 사용한 후 처리 (오른쪽에서 왼쪽으로 변형)</target>
        </trans-unit>
        <trans-unit id="68b34bc77c96ccaa5d23f02c3788537d21fd9171" translate="yes" xml:space="preserve">
          <source>Postcomposition with a pure function.</source>
          <target state="translated">순수한 기능으로 사후 구성.</target>
        </trans-unit>
        <trans-unit id="c4450a1082e97ad779541d6b592b90e8113cd10b" translate="yes" xml:space="preserve">
          <source>PostfixOperators</source>
          <target state="translated">PostfixOperators</target>
        </trans-unit>
        <trans-unit id="5190c068a9cfa9fe6dafeaa183d9b2aaef45c829" translate="yes" xml:space="preserve">
          <source>Ppr</source>
          <target state="translated">Ppr</target>
        </trans-unit>
        <trans-unit id="0c19dcec06f6c91c0f2eff83d377b3454295bda3" translate="yes" xml:space="preserve">
          <source>PprM</source>
          <target state="translated">PprM</target>
        </trans-unit>
        <trans-unit id="38f93d32853eca4603a582eb7a404079e10b855d" translate="yes" xml:space="preserve">
          <source>Pragma</source>
          <target state="translated">Pragma</target>
        </trans-unit>
        <trans-unit id="6a503249a0dda8aeffc97783a04cdefe488d7002" translate="yes" xml:space="preserve">
          <source>Pragmas all take the form &lt;code&gt;{-# word ... #-}&lt;/code&gt; where ⟨word⟩ indicates the type of pragma, and is followed optionally by information specific to that type of pragma. Case is ignored in ⟨word⟩. The various values for ⟨word⟩ that GHC understands are described in the following sections; any pragma encountered with an unrecognised ⟨word⟩ is ignored. The layout rule applies in pragmas, so the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">Pragma는 모두 &lt;code&gt;{-# word ... #-}&lt;/code&gt; 형식을 취합니다. 여기서 ⟨word⟩는 pragma의 유형을 나타내고 선택적으로 해당 유형의 pragma에 특정한 정보가옵니다. ⟨word⟩에서 대소 문자는 무시됩니다. GHC가 이해하는 &quot;word&quot;에 대한 다양한 값은 다음 섹션에 설명되어 있습니다. 인식 할 수없는 ⟨word⟩가있는 pragma는 무시됩니다. 레이아웃 규칙은 pragma에 적용되므로 닫는 &lt;code&gt;#-}&lt;/code&gt; 은 여는 &lt;code&gt;{-#&lt;/code&gt; 의 오른쪽 열에서 시작해야합니다 . .</target>
        </trans-unit>
        <trans-unit id="de91c36fde9f78913dd737b3ac96a872a8cf867b" translate="yes" xml:space="preserve">
          <source>Pre-defined directories</source>
          <target state="translated">사전 정의 된 디렉토리</target>
        </trans-unit>
        <trans-unit id="b7f5558e808991eda01cbcf863b6fb9f860df9c3" translate="yes" xml:space="preserve">
          <source>Pre-emption</source>
          <target state="translated">Pre-emption</target>
        </trans-unit>
        <trans-unit id="616e1d6e6f47b2dc96ac1a5ae54540016239b6ef" translate="yes" xml:space="preserve">
          <source>Pre-processing is optional, the &lt;a href=&quot;phases#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; flag turns it on. See &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt; for more details.</source>
          <target state="translated">사전 처리는 선택 사항이며 &lt;a href=&quot;phases#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt; 플래그는이를 설정합니다. &lt;a href=&quot;phases#c-pre-processor&quot;&gt;C 전처리기에 영향을주는 옵션을&lt;/a&gt; 참조하십시오. 하십시오.</target>
        </trans-unit>
        <trans-unit id="b56df0dc547f1c3c9c6bdf3cf6bc836ae75d592f" translate="yes" xml:space="preserve">
          <source>Prec</source>
          <target state="translated">Prec</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="69d353b33ac29db4cf194048bdbcd68112b6f57f" translate="yes" xml:space="preserve">
          <source>Precedence operations</source>
          <target state="translated">우선 순위 작업</target>
        </trans-unit>
        <trans-unit id="6e9db1fa77d52cf522ad8a7a915070250aa06a60" translate="yes" xml:space="preserve">
          <source>Precedences</source>
          <target state="translated">Precedences</target>
        </trans-unit>
        <trans-unit id="7d4c782369e2a524fee0cc4b706316c8a2f516ce" translate="yes" xml:space="preserve">
          <source>Precomposition with a pure function (right-to-left variant).</source>
          <target state="translated">순수한 기능으로 사전 구성 (오른쪽에서 왼쪽으로 변형)</target>
        </trans-unit>
        <trans-unit id="7efe8aecf7d7ec9a6579a56c2d3f073a07aea88e" translate="yes" xml:space="preserve">
          <source>Precomposition with a pure function.</source>
          <target state="translated">순수한 기능으로 사전 구성.</target>
        </trans-unit>
        <trans-unit id="754ba6611e7bacba5a9fb90876697ee505efa3e8" translate="yes" xml:space="preserve">
          <source>Pred</source>
          <target state="translated">Pred</target>
        </trans-unit>
        <trans-unit id="7b11e8e297f569849de36b44d30fcbbb4fbbe8ad" translate="yes" xml:space="preserve">
          <source>PredQ</source>
          <target state="translated">PredQ</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="5d3249c48d800f447f533f0fa317e54353a59d06" translate="yes" xml:space="preserve">
          <source>Predicate determining whether the first argument is inside the second argument.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수 안에 있는지 판별하는 술어.</target>
        </trans-unit>
        <trans-unit id="55b56b7a38f2aaf5493f86b3d26035da3508b3bb" translate="yes" xml:space="preserve">
          <source>Predicate to select exceptions</source>
          <target state="translated">예외를 선택하는 술어</target>
        </trans-unit>
        <trans-unit id="74ff649a3a1be6633677b33ec66e3623a45738d8" translate="yes" xml:space="preserve">
          <source>Predicates</source>
          <target state="translated">Predicates</target>
        </trans-unit>
        <trans-unit id="96b847cc7746c0d1f7662c2ba5e962da4df9bff5" translate="yes" xml:space="preserve">
          <source>Predicates on documents</source>
          <target state="translated">문서의 술어</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="10a0703c5e9784ab6072eefca5e5d67b8bab1aea" translate="yes" xml:space="preserve">
          <source>PrefixI</source>
          <target state="translated">PrefixI</target>
        </trans-unit>
        <trans-unit id="3d7f56ffea75d06f65599fca02fef48b1a3c121a" translate="yes" xml:space="preserve">
          <source>Prefs</source>
          <target state="translated">Prefs</target>
        </trans-unit>
        <trans-unit id="2d8e8af65e69e615c74499754307d13c9b3e4bab" translate="yes" xml:space="preserve">
          <source>Prelude</source>
          <target state="translated">Prelude</target>
        </trans-unit>
        <trans-unit id="17951797c095385f82b7ed2be1b0b9cbd50b504e" translate="yes" xml:space="preserve">
          <source>Prepares an empty write buffer. This lets the device decide how to set up a write buffer: the buffer may need to point to a specific location in memory, for example. This is typically used by the client when switching from reading to writing on a buffered read/write device.</source>
          <target state="translated">빈 쓰기 버퍼를 준비합니다. 이를 통해 장치는 쓰기 버퍼 설정 방법을 결정할 수 있습니다. 버퍼는 예를 들어 메모리의 특정 위치를 가리켜 야 할 수 있습니다. 이는 일반적으로 버퍼링 된 읽기 / 쓰기 장치에서 읽기에서 쓰기로 전환 할 때 클라이언트가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e756fbcebaf305207bf892820ae2fb41ad4bdd3f" translate="yes" xml:space="preserve">
          <source>Prepend an element to the stream.</source>
          <target state="translated">스트림 앞에 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="24451f10c39a033b9d567c3384a201089e447d0e" translate="yes" xml:space="preserve">
          <source>Present a visual alert using the &lt;code&gt;flash&lt;/code&gt; capability.</source>
          <target state="translated">&lt;code&gt;flash&lt;/code&gt; 사용하여 시각적 경고 표시 기능을 .</target>
        </trans-unit>
        <trans-unit id="0f1fbb34fcfce7c17bb348ece516318a4a36a3e4" translate="yes" xml:space="preserve">
          <source>Presently, only standard constraints, tuples and type synonyms for those two sorts of constraint are permitted in instance contexts and superclasses (without extra flags). The reason is that permitting more general constraints can cause type checking to loop, as it would with these two programs:</source>
          <target state="translated">현재, 두 가지 종류의 제약 조건에 대한 표준 제약 조건, 튜플 및 형식 동의어 만 인스턴스 컨텍스트 및 수퍼 클래스 (추가 플래그없이)에서 허용됩니다. 더 일반적인 제약 조건을 허용하면 다음 두 프로그램에서와 같이 유형 검사가 반복 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3a533287e20f4ecff2b1e94d9ecd624990690055" translate="yes" xml:space="preserve">
          <source>Preserve, unchanged, the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목은 변경하지 않고 그대로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f7adbbb69e916ea1927afb55f2ecddd2cc7a5f" translate="yes" xml:space="preserve">
          <source>Pretty</source>
          <target state="translated">Pretty</target>
        </trans-unit>
        <trans-unit id="9bfe234869187d35c7a0ae4cca314aded4bb1a5b" translate="yes" xml:space="preserve">
          <source>Pretty much anyone who uses this function is in a state of sin because whether or not a character is encodable will, in general, depend on the context in which it occurs.</source>
          <target state="translated">이 기능을 사용하는 사람은 거의 대부분 죄의 상태에 있습니다. 왜냐하면 캐릭터의 인코딩 가능 여부는 일반적으로 그것이 발생하는 상황에 달려 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9a3ba5e8fa76ce9f1f76507bf772a40b2714f091" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 인쇄 .</target>
        </trans-unit>
        <trans-unit id="6dedd939f5eb8f17de16de0deb9579148f161282" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 을 예쁘게 인쇄 .</target>
        </trans-unit>
        <trans-unit id="d2157c3e2c2e08e7d9469e18b1d6d2509fdc1116" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 인쇄 .</target>
        </trans-unit>
        <trans-unit id="24a5908c42be14f75c50cae9cb71fef066d896a2" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 을 예쁘게 인쇄 .</target>
        </trans-unit>
        <trans-unit id="296539186fb752a49f377917ff5a8b60910cd510" translate="yes" xml:space="preserve">
          <source>Pretty print a value with the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; 로 값을 예쁘게 인쇄 레벨 .</target>
        </trans-unit>
        <trans-unit id="dee0fe2bf13d7aeaf670d551f0f8e724a8229133" translate="yes" xml:space="preserve">
          <source>Pretty print a value with the &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; 로 값을 예쁘게 인쇄 레벨 .</target>
        </trans-unit>
        <trans-unit id="3902ef81760a73ba152aafba884456ad6ae55826" translate="yes" xml:space="preserve">
          <source>Pretty print the type. &lt;code&gt;ShowType :: k -&amp;gt; ErrorMessage&lt;/code&gt;</source>
          <target state="translated">유형을 예쁘게 인쇄하십시오. &lt;code&gt;ShowType :: k -&amp;gt; ErrorMessage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d1c61942f4d68589a44b45a71c4f04ff54f0e46" translate="yes" xml:space="preserve">
          <source>Pretty printing class, simlar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; but nicer looking.</source>
          <target state="translated">예쁜 인쇄 수업, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 것과 비슷 비슷하지만 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa35ad6c9b5033404eb8f0e2bfca62d78aef25b2" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 와 비슷한 방식으로 사용됩니다 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="6003344bfaa462ef2829aa012e40d0f204fd8d4b" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 와 비슷한 방식으로 사용됩니다 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="ce0b905e0e2fe34c10df06c3257897a0d4174db5" translate="yes" xml:space="preserve">
          <source>Pretty printing via &lt;code&gt;&lt;a href=&quot;language-haskell-th-ppr#v:pprPatSynType&quot;&gt;pprPatSynType&lt;/a&gt;&lt;/code&gt; abbreviates a pattern synonym's type unambiguously in concrete syntax: The rule of thumb is to print initial empty universals and the required context as &lt;code&gt;() =&amp;gt;&lt;/code&gt;, if existentials and a provided context follow. If only universals and their required context, but no existentials are specified, only the universals and their required context are printed. If both or none are specified, so both (or none) are printed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-ppr#v:pprPatSynType&quot;&gt;pprPatSynType&lt;/a&gt;&lt;/code&gt; 을 통한 예쁜 인쇄 는 구체적인 구문에서 패턴 동의어의 유형을 명확하게 줄여줍니다. &lt;code&gt;() =&amp;gt;&lt;/code&gt; 좋습니다. 유니버설과 필수 컨텍스트 만 있지만 실재가 지정되지 않은 경우 유니버설과 필수 컨텍스트 만 인쇄됩니다. 둘 다 지정하거나 지정하지 않으면 둘 다 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="913403112273ef6e2854bcf0f8c908964725c43b" translate="yes" xml:space="preserve">
          <source>Pretty prints a pattern synonym type signature</source>
          <target state="translated">패턴 동의어 형식 서명을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d4e682f695f1f2c1d3c722dd6d5b3b250860bb3f" translate="yes" xml:space="preserve">
          <source>Pretty prints a pattern synonym's type; follows the usual conventions to print a pattern synonym type compactly, yet unambiguously. See the note on &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:PatSynType&quot;&gt;PatSynType&lt;/a&gt;&lt;/code&gt; and the section on pattern synonyms in the GHC user's guide for more information.</source>
          <target state="translated">Pretty는 패턴 동의어 유형을 인쇄합니다. 일반적인 동의어에 따라 패턴 동의어 유형을 간결하면서도 명확하게 인쇄합니다. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:PatSynType&quot;&gt;PatSynType&lt;/a&gt;&lt;/code&gt; 에 대한 참고 사항을 참조하십시오 및 GHC 사용자 안내서의 패턴 동의어에 대한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7763808de129b1653f86f4b6c4478b1be06d267" translate="yes" xml:space="preserve">
          <source>Pretty typeclass</source>
          <target state="translated">예쁜 타입 클래스</target>
        </trans-unit>
        <trans-unit id="9e53c1cac90b48260e445d3942d8dc757e8a9ad1" translate="yes" xml:space="preserve">
          <source>Pretty-printer</source>
          <target state="translated">Pretty-printer</target>
        </trans-unit>
        <trans-unit id="299e09a4ecf7d0f0c71dd28f182c4640d6372f53" translate="yes" xml:space="preserve">
          <source>PrettyLevel</source>
          <target state="translated">PrettyLevel</target>
        </trans-unit>
        <trans-unit id="cfad1a2758e3a164bd5b4b3f7f8ff793ee9e089b" translate="yes" xml:space="preserve">
          <source>Prevent loading of the user&amp;rsquo;s local package database in the initial stack.</source>
          <target state="translated">초기 스택에서 사용자의 로컬 패키지 데이터베이스가로드되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="82f73f32fff7781aec7b0b514e54e58cf7551ee7" translate="yes" xml:space="preserve">
          <source>Prevents the compiler from applying the monomorphism restriction to bindings lacking explicit type signatures.</source>
          <target state="translated">컴파일러가 명시 적 형식 서명이없는 바인딩에 단일 제한을 적용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="9628fe995a8e090e6fd2edb95cb73c1eb15224d5" translate="yes" xml:space="preserve">
          <source>Previous versions of GHC accepted &lt;code&gt;OPTIONS&lt;/code&gt; rather than &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, but that is now deprecated.</source>
          <target state="translated">이전 버전의 GHC는 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 대신 &lt;code&gt;OPTIONS&lt;/code&gt; 를 허용 했지만 이제는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91406666c314d5f229091e983a7d1e2bee142e52" translate="yes" xml:space="preserve">
          <source>Previously we discussed annotation pragmas (&lt;a href=&quot;#annotation-pragmas&quot;&gt;Source annotations&lt;/a&gt;), which we mentioned could be used to give compiler plugins extra guidance or information. Annotations for a module can be retrieved by a plugin, but you must go through the modules &lt;code&gt;ModGuts&lt;/code&gt; in order to get it. Because annotations can be arbitrary instances of &lt;code&gt;Data&lt;/code&gt; and &lt;code&gt;Typeable&lt;/code&gt;, you need to give a type annotation specifying the proper type of data to retrieve from the interface file, and you need to make sure the annotation type used by your users is the same one your plugin uses. For this reason, we advise distributing annotations as part of the package which also provides compiler plugins if possible.</source>
          <target state="translated">이전에 우리는 주석 프라 그마 ( &lt;a href=&quot;#annotation-pragmas&quot;&gt;Source annotations&lt;/a&gt; )에 대해 논의 했는데, 우리는 컴파일러 플러그인에 추가적인 지침이나 정보를 제공하는 데 사용될 수 있다고 언급했다. 모듈에 대한 주석은 플러그인에 의해 검색 될 수 있지만, 모듈 을 얻으려면 &lt;code&gt;ModGuts&lt;/code&gt; 모듈을 거쳐야 합니다. 주석은 &lt;code&gt;Data&lt;/code&gt; 및 &lt;code&gt;Typeable&lt;/code&gt; 의 임의 인스턴스 일 수 있으므로 일 수 있으므로 인터페이스 파일에서 검색 할 적절한 데이터 유형을 지정하는 유형 주석을 제공해야하며 사용자가 사용하는 주석 유형이 플러그인과 동일한 지 확인해야합니다. 사용합니다. 따라서 가능한 경우 컴파일러 플러그인도 제공하는 패키지의 일부로 주석을 배포하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c4a698fc939e769737cd9fa4869e3c7f6a0dd613" translate="yes" xml:space="preserve">
          <source>Prim</source>
          <target state="translated">Prim</target>
        </trans-unit>
        <trans-unit id="097f7b8f054d460e64f528c1af758136a46531eb" translate="yes" xml:space="preserve">
          <source>PrimMVar</source>
          <target state="translated">PrimMVar</target>
        </trans-unit>
        <trans-unit id="b7683822a291cb2b58d760a6c293578f8d5053f1" translate="yes" xml:space="preserve">
          <source>Primality tests</source>
          <target state="translated">원시성 테스트</target>
        </trans-unit>
        <trans-unit id="82232b5d4e89a2db12db9f128d9da3055f65c345" translate="yes" xml:space="preserve">
          <source>Primarily, this module consists of an interface to the C-land dynamic linker.</source>
          <target state="translated">기본적으로이 모듈은 C-land 동적 링커에 대한 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0889b00639729e1c129ac932d18003c7a198375f" translate="yes" xml:space="preserve">
          <source>Primary format character.</source>
          <target state="translated">기본 형식 문자</target>
        </trans-unit>
        <trans-unit id="d2a03ab0b74a812f6fdc4dae75971c24107ba46b" translate="yes" xml:space="preserve">
          <source>Primary group ID (pw_gid)</source>
          <target state="translated">기본 그룹 ID (pw_gid)</target>
        </trans-unit>
        <trans-unit id="7607b51c8e1274c8fe1e933fecba18513d4f362a" translate="yes" xml:space="preserve">
          <source>PrimaryLANGID</source>
          <target state="translated">PrimaryLANGID</target>
        </trans-unit>
        <trans-unit id="cdd32e5e2d189473b1b0376cb2f1fe6ef6aad406" translate="yes" xml:space="preserve">
          <source>Primitive (unboxed) types cannot be defined in Haskell, and are therefore built into the language and compiler. Primitive types are always unlifted; that is, a value of a primitive type cannot be bottom. (Note: a &amp;ldquo;boxed&amp;rdquo; type means that a value is represented by a pointer to a heap object; a &amp;ldquo;lifted&amp;rdquo; type means that terms of that type may be bottom. See the next paragraph for an example.) We use the convention (but it is only a convention) that primitive types, values, and operations have a &lt;code&gt;#&lt;/code&gt; suffix (see &lt;a href=&quot;#magic-hash&quot;&gt;The magic hash&lt;/a&gt;). For some primitive types we have special syntax for literals, also described in the &lt;a href=&quot;#magic-hash&quot;&gt;same section&lt;/a&gt;.</source>
          <target state="translated">기본 (비 박스) 유형은 Haskell에서 정의 할 수 없으므로 언어 ​​및 컴파일러에 내장되어 있습니다. 기본 유형은 항상 해제됩니다. 즉, 기본 유형의 값은 맨 아래가 될 수 없습니다. (참고 : &quot;박스형&quot;유형은 값이 힙 객체에 대한 포인터로 표시됨을 의미하고 &quot;리프팅&quot;유형은 해당 유형의 용어가 하단 일 수 있음을 의미합니다. 예를 들어 다음 단락을 참조하십시오. (그러나 기본 형식, 값 및 작업에는 &lt;code&gt;#&lt;/code&gt; 접미사가 있습니다 ( &lt;a href=&quot;#magic-hash&quot;&gt;매직 해시&lt;/a&gt; 참조 )). 일부 기본 유형의 경우 리터럴에 대한 특수 구문이 있으며 &lt;a href=&quot;#magic-hash&quot;&gt;동일한 섹션&lt;/a&gt; 에도 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81e9ce0c637b5622aea322e7cbd9b861a8cb4dc6" translate="yes" xml:space="preserve">
          <source>Primitive Documents</source>
          <target state="translated">기본 문서</target>
        </trans-unit>
        <trans-unit id="f422d79426f666f61a7d39fe5b03b368a8e73a13" translate="yes" xml:space="preserve">
          <source>Primitive bytecode type.</source>
          <target state="translated">기본 바이트 코드 유형.</target>
        </trans-unit>
        <trans-unit id="c1c26c88e959f52e5cf4888bbad7bcf524b8820f" translate="yes" xml:space="preserve">
          <source>Primitive combinators</source>
          <target state="translated">기본 조합기</target>
        </trans-unit>
        <trans-unit id="2e21eceae717d39a08de608f7fc31fb7d5627808" translate="yes" xml:space="preserve">
          <source>Primitive movement capabilities</source>
          <target state="translated">원시 운동 기능</target>
        </trans-unit>
        <trans-unit id="c2de126cf4ab0cd60ff18f3b3c4a2455396c348e" translate="yes" xml:space="preserve">
          <source>Primitive operations</source>
          <target state="translated">원시 작업</target>
        </trans-unit>
        <trans-unit id="7e8cb2eba99c97514ca435a92c7b1f3eff1bdea3" translate="yes" xml:space="preserve">
          <source>Primitive values are often represented by a simple bit-pattern, such as &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;. But this is not necessarily the case: a primitive value might be represented by a pointer to a heap-allocated object. Examples include &lt;code&gt;Array#&lt;/code&gt;, the type of primitive arrays. Thus, &lt;code&gt;Array#&lt;/code&gt; is an unlifted, boxed type. A primitive array is heap-allocated because it is too big a value to fit in a register, and would be too expensive to copy around; in a sense, it is accidental that it is represented by a pointer. If a pointer represents a primitive value, then it really does point to that value: no unevaluated thunks, no indirections. Nothing can be at the other end of the pointer than the primitive value. A numerically-intensive program using unboxed types can go a &lt;em&gt;lot&lt;/em&gt; faster than its &amp;ldquo;standard&amp;rdquo; counterpart&amp;mdash;we saw a threefold speedup on one example.</source>
          <target state="translated">기본 값은 종종 &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; 과 같은 간단한 비트 패턴으로 표시됩니다 . 그러나 반드시 그런 것은 아닙니다. 프리미티브 값은 힙 할당 객체에 대한 포인터로 표시 될 수 있습니다. 예는 기본 배열 유형 인 &lt;code&gt;Array#&lt;/code&gt; 입니다. 따라서 &lt;code&gt;Array#&lt;/code&gt; 리프팅되지 않은 박스 형식입니다. 프리미티브 배열은 레지스터에 맞지 않는 값이 너무 커서 복사하기에는 너무 비싸기 때문에 힙 할당됩니다. 어떤 의미에서는 포인터로 표시되는 것이 우연입니다. 포인터가 프리미티브 값을 나타내는 경우 실제로는 해당 값을 가리 킵니다. 평가되지 않은 썽크가없고 간접적 인 것이 없습니다. 포인터의 다른 끝에는 기본 값 이외의 값이있을 수 없습니다. 박스 형태가 아닌 유형을 사용하는 수치 집약적 인 프로그램 은&amp;ldquo;표준&amp;rdquo; 프로그램 보다 &lt;em&gt;훨씬&lt;/em&gt; 빠를 수 있습니다 . 한 예에서 3 배의 속도 향상이있었습니다.</target>
        </trans-unit>
        <trans-unit id="ffafa88c6f976297b9421ad4171675a387b485a2" translate="yes" xml:space="preserve">
          <source>Primitives</source>
          <target state="translated">Primitives</target>
        </trans-unit>
        <trans-unit id="66914127445228947976717f3559fb76a49308ac" translate="yes" xml:space="preserve">
          <source>Primitives and basic combinators</source>
          <target state="translated">프리미티브 및 기본 콤비 네이터</target>
        </trans-unit>
        <trans-unit id="0f20585a9b902d862530a747335f7e0f0fd615e0" translate="yes" xml:space="preserve">
          <source>Primitives are available to decode words of various sizes, both big and little endian.</source>
          <target state="translated">프리미티브는 빅 엔디안과 리틀 엔디안 등 다양한 크기의 단어를 해독하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11324a450fecb745dc9a0165fed6d81224cd078" translate="yes" xml:space="preserve">
          <source>Print &lt;code&gt;RuntimeRep&lt;/code&gt; parameters as they appear; otherwise, they are defaulted to &lt;code&gt;'LiftedRep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RuntimeRep&lt;/code&gt; 매개 변수가 나타나는대로 인쇄 하십시오 . 그렇지 않으면 기본값은 &lt;code&gt;'LiftedRep&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eeb81239159c8f60639d490579db34ba47cedde5" translate="yes" xml:space="preserve">
          <source>Print &lt;code&gt;RuntimeRep&lt;/code&gt; variables in types which are runtime-representation polymorphic.</source>
          <target state="translated">&lt;code&gt;RuntimeRep&lt;/code&gt; 변수를 런타임 표현 다형성 유형으로 인쇄 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7f33c02cf627c59368ecbf1b10534cd5ee7098" translate="yes" xml:space="preserve">
          <source>Print GHC&amp;rsquo;s numeric version number only.</source>
          <target state="translated">GHC의 숫자 버전 번호 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="5a8565f8c11652d5f9aaf3cf4b7da14d30635811" translate="yes" xml:space="preserve">
          <source>Print a full list of the module dependencies to stdout. (This is the standard verbosity flag, so the list will also be displayed with &lt;code&gt;-v3&lt;/code&gt; and &lt;code&gt;-v4&lt;/code&gt;; see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;.)</source>
          <target state="translated">모듈 종속성의 전체 목록을 stdout에 인쇄하십시오. (이것은 표준 상세 표시 플래그이므로 목록도 &lt;code&gt;-v3&lt;/code&gt; 및 &lt;code&gt;-v4&lt;/code&gt; 와 함께 표시됩니다 . &lt;a href=&quot;using#options-help&quot;&gt;상세 옵션&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="80be7ba4189d5acb5419cc416166ad88b14a93ab" translate="yes" xml:space="preserve">
          <source>Print a one-line string including GHC&amp;rsquo;s version number.</source>
          <target state="translated">GHC의 버전 번호를 포함하여 한 줄짜리 문자열을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2bc805e229391602d4747b2b177e7eedc95c2396" translate="yes" xml:space="preserve">
          <source>Print a one-line summary of the size of the Core program at the end of the optimisation pipeline</source>
          <target state="translated">최적화 파이프 라인 끝에서 핵심 프로그램 크기의 한 줄 요약을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="568fb95ae04c3a3502b02cfb9ffd902745997992" translate="yes" xml:space="preserve">
          <source>Print a one-line summary of the size of the Core program at the end of the optimisation pipeline.</source>
          <target state="translated">최적화 파이프 라인 끝에서 핵심 프로그램 크기의 한 줄 요약을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="6606d0f053fe23bd0db8aac9087cd16974cb24e2" translate="yes" xml:space="preserve">
          <source>Print coercions in types</source>
          <target state="translated">유형의 강제 인쇄</target>
        </trans-unit>
        <trans-unit id="0432cd36a550ecbc08a2b9824c1b63189a9b6ee6" translate="yes" xml:space="preserve">
          <source>Print explicit &lt;code&gt;forall&lt;/code&gt; quantification in types. See also &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;-XExplicitForAll&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">명시 적으로 인쇄 &lt;code&gt;forall&lt;/code&gt; 종류 정량화. &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;-XExplicitForAll&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="43d90f3662f54252f7284d92a4b10054139a2658" translate="yes" xml:space="preserve">
          <source>Print explicit kind foralls and kind arguments in types. See also &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt;&lt;code&gt;-XKindSignatures&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">모든 종류의 종류와 종류에 대한 명백한 종류를 인쇄하십시오. &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt; &lt;code&gt;-XKindSignatures&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccc5df58f6562a5f05e5a96496e219a954a057a2" translate="yes" xml:space="preserve">
          <source>Print extra information from typechecker.</source>
          <target state="translated">형식 검사기에서 추가 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="1c689b67035c8c53f98145aff3c638fb305e66de" translate="yes" xml:space="preserve">
          <source>Print information about the compiler.</source>
          <target state="translated">컴파일러에 대한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c17674ed7a508bc28415982ff7aee239af184532" translate="yes" xml:space="preserve">
          <source>Print out each pass name as it happens</source>
          <target state="translated">각 패스 이름을 인쇄하십시오</target>
        </trans-unit>
        <trans-unit id="6346e07b56af6623e4a5cded288d10867e65bab0" translate="yes" xml:space="preserve">
          <source>Print out each pass name, its runtime and heap allocations as it happens. Note that this may come at a slight performance cost as the compiler will be a bit more eager in forcing pass results to more accurately account for their costs.</source>
          <target state="translated">각 패스 이름, 런타임 및 힙 할당을 인쇄하십시오. 컴파일러는 패스 결과를보다 정확하게 계산하기 위해 패스 결과를 조금 더 간절히 원하기 때문에 약간의 성능 비용이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4bdf4d18e7fa5c826928aec79e1ccb449c15ff" translate="yes" xml:space="preserve">
          <source>Print out summary of what kind of information the renamer had to bring in.</source>
          <target state="translated">이름 변경자가 가져와야 할 정보의 종류를 요약하여 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="bc9a53e87cca6954b36dc36c0f11d367ea1e424e" translate="yes" xml:space="preserve">
          <source>Print out usage information.</source>
          <target state="translated">사용법 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="b2c88a9f866c4e0f0dc02f44c6ee50187a966424" translate="yes" xml:space="preserve">
          <source>Print single alternative case expressions as strict lets.</source>
          <target state="translated">엄격한 대안으로 단일 대체 사례 표현식을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb7a347c6a4aa8013e70856b20c399cd1c29ff8" translate="yes" xml:space="preserve">
          <source>Print single alternative case expressions as though they were strict let expressions. This is helpful when your code does a lot of unboxing.</source>
          <target state="translated">단일 대체 사례 표현식이 엄격한 let 표현식 인 것처럼 인쇄하십시오. 이것은 코드가 많은 언 박싱을 수행 할 때 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2d376b6f72267ae8b071df5ba4178bc23f3f30f8" translate="yes" xml:space="preserve">
          <source>Print the name of each compilation phase as it is executed. (equivalent to &lt;a href=&quot;debugging#ghc-flag--dshow-passes&quot;&gt;&lt;code&gt;-dshow-passes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">실행될 때 각 컴파일 단계의 이름을 인쇄하십시오. ( &lt;a href=&quot;debugging#ghc-flag--dshow-passes&quot;&gt; &lt;code&gt;-dshow-passes&lt;/code&gt; &lt;/a&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="2d35a116b4eacba35aab727296180081e67d78e2" translate="yes" xml:space="preserve">
          <source>Print the path to GHC&amp;rsquo;s library directory. This is the top of the directory tree containing GHC&amp;rsquo;s libraries, interfaces, and include files (usually something like &lt;code&gt;/usr/local/lib/ghc-5.04&lt;/code&gt; on Unix). This is the value of &lt;code&gt;$libdir&lt;/code&gt; in the package configuration file (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;).</source>
          <target state="translated">GHC 라이브러리 디렉토리의 경로를 인쇄하십시오. 이것은 GHC의 라이브러리, 인터페이스 및 포함 파일 (일반적 으로 Unix의 &lt;code&gt;/usr/local/lib/ghc-5.04&lt;/code&gt; 와 같은 것)을 포함하는 디렉토리 트리의 최상위입니다 . 패키지 구성 파일 의 &lt;code&gt;$libdir&lt;/code&gt; 값입니다 ( &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7dddff095a26ddf9987f527bca4da1fdb41bb6b7" translate="yes" xml:space="preserve">
          <source>Print the supported command line options. This flag can be used for autocompletion in a shell.</source>
          <target state="translated">지원되는 명령 행 옵션을 인쇄하십시오. 이 플래그는 쉘에서 자동 완성에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de10c90956a31b467677165023124cbf6667b11" translate="yes" xml:space="preserve">
          <source>Print the supported language extensions.</source>
          <target state="translated">지원되는 언어 확장을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="0536d584c0b1d66d30f2000068d79cde18e65738" translate="yes" xml:space="preserve">
          <source>Print values of type &lt;code&gt;Word#&lt;/code&gt; and &lt;code&gt;Word64#&lt;/code&gt; (but not values of type &lt;code&gt;Int#&lt;/code&gt; and &lt;code&gt;Int64#&lt;/code&gt;) in hexadecimal instead of decimal. The hexadecimal is zero-padded to make the length of the representation a power of two. For example: &lt;code&gt;0x0A0A##&lt;/code&gt;, &lt;code&gt;0x000FFFFF##&lt;/code&gt;, &lt;code&gt;0xC##&lt;/code&gt;. This flag may be helpful when you are producing a bit pattern that to expect to work correctly on a 32-bit or a 64-bit architecture. Dumping hexadecimal literals after optimizations and constant folding makes it easier to confirm that the generated bit pattern is correct.</source>
          <target state="translated">10 진수 대신 16 진수로 &lt;code&gt;Word#&lt;/code&gt; 및 &lt;code&gt;Word64#&lt;/code&gt; 유형 ( &lt;code&gt;Int#&lt;/code&gt; 및 &lt;code&gt;Int64#&lt;/code&gt; 유형의 값이 아님)의 값을 인쇄하십시오 . 16 진수는 0으로 채워져 표현 길이를 2의 거듭 제곱으로 만듭니다. 예를 들어 &lt;code&gt;0x0A0A##&lt;/code&gt; , &lt;code&gt;0x000FFFFF##&lt;/code&gt; , &lt;code&gt;0xC##&lt;/code&gt; 입니다. 이 플래그는 32 비트 또는 64 비트 아키텍처에서 올바르게 작동 할 것으로 예상되는 비트 패턴을 생성 할 때 유용 할 수 있습니다. 최적화 및 상수 폴딩 후 16 진 리터럴을 덤프하면 생성 된 비트 패턴이 올바른지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8fc49ee76dfe430eaaae5d2c003a633432f9f0" translate="yes" xml:space="preserve">
          <source>Print values of type &lt;code&gt;Word#&lt;/code&gt; in hexadecimal.</source>
          <target state="translated">&lt;code&gt;Word#&lt;/code&gt; 유형의 값을 16 진수로 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7be34b673808f2d48e5ab2574882b799d823a21" translate="yes" xml:space="preserve">
          <source>PrintfArg</source>
          <target state="translated">PrintfArg</target>
        </trans-unit>
        <trans-unit id="7089bc7979848c154683cd0084ff2f7d3644e64b" translate="yes" xml:space="preserve">
          <source>PrintfType</source>
          <target state="translated">PrintfType</target>
        </trans-unit>
        <trans-unit id="78c20ed70f591c5b802ec52da8af22641a65cb47" translate="yes" xml:space="preserve">
          <source>Printing Functions</source>
          <target state="translated">인쇄 기능</target>
        </trans-unit>
        <trans-unit id="81c35c214270ee006f5c56860fe38a2f038e3898" translate="yes" xml:space="preserve">
          <source>Prints a one-line summary of timing statistics for the GHC run. This option is equivalent to &lt;code&gt;+RTS -tstderr&lt;/code&gt;, see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">GHC 실행에 대한 타이밍 통계의 한 줄 요약을 인쇄합니다. 이 옵션은 &lt;code&gt;+RTS -tstderr&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a32b1200253fea3bdcc41abafe3985fec209486" translate="yes" xml:space="preserve">
          <source>Prints a value without forcing its evaluation. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; may be used on values whose types are unknown or partially known, which might be the case for local variables with polymorphic types at a breakpoint. While inspecting the runtime value, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; attempts to reconstruct the type of the value, and will elaborate the type in GHCi&amp;rsquo;s environment if possible. If any unevaluated components (thunks) are encountered, then &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds a fresh variable with a name beginning with &lt;code&gt;_t&lt;/code&gt; to each thunk. See &lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt; for more information. See also the &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt;&lt;code&gt;:sprint&lt;/code&gt;&lt;/a&gt; command, which works like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; but does not bind new variables.</source>
          <target state="translated">평가하지 않고 값을 인쇄합니다. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 유형을 알 수 없거나 부분적으로 알려진 값에 사용될 수 있으며, 이는 중단 점에서 다형성 유형을 갖는 지역 변수의 경우 일 수 있습니다. 런타임 값을 검사하는 동안 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 값의 유형을 재구성하려고 시도하며 가능한 경우 GHCi 환경에서 유형을 정교하게합니다. 평가되지 않은 구성 요소 (썽크)가 발견되면 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 이름이 &lt;code&gt;_t&lt;/code&gt; 로 시작하는 새로운 변수 를 각 썽크에 바인딩합니다 . 자세한 내용은 &lt;a href=&quot;#breakpoints&quot;&gt;중단 점 및 변수 검사&lt;/a&gt; 를 참조하십시오. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 같이 작동 하지만 새 변수를 바인딩하지 않는 &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt; &lt;code&gt;:sprint&lt;/code&gt; &lt;/a&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1901cde8b08fed8941230e3f83f1c3cf4a834d5a" translate="yes" xml:space="preserve">
          <source>Prints a value without forcing its evaluation. &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt;&lt;code&gt;:sprint&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, with the difference that unevaluated subterms are not bound to new variables, they are simply denoted by &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">평가하지 않고 값을 인쇄합니다. &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt; &lt;code&gt;:sprint&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 유사하며 , 평가되지 않은 하위 용어가 새 변수에 바인딩되지 않는다는 점에서 차이는 단순히 &lt;code&gt;_&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac4afe4944ea3331a3d2c608c60d31227edcb709" translate="yes" xml:space="preserve">
          <source>Prints the latest available version of package ⟨P⟩.</source>
          <target state="translated">사용 가능한 최신 버전의 패키지 ⟨P⟩를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7595d277dda450dbba120e42b0d8f0d521de9f36" translate="yes" xml:space="preserve">
          <source>Prints the value of ⟨identifier⟩ in the same way as &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. Unlike &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; evaluates each thunk that it encounters while traversing the value. This may cause exceptions or infinite loops, or further breakpoints (which are ignored, but displayed).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 &quot;identifier&quot;값을 인쇄 합니다. 달리 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; 값을 통과하면서 발생하는 각 썽크을 평가한다. 이로 인해 예외 또는 무한 루프 또는 추가 중단 점 (무시되지만 표시됨)이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61486fb3c29083825fc530e85db902f694779e3" translate="yes" xml:space="preserve">
          <source>PrioIOAvailable</source>
          <target state="translated">PrioIOAvailable</target>
        </trans-unit>
        <trans-unit id="fabfc2adbe5a1490690f6f40c6d623b433df0934" translate="yes" xml:space="preserve">
          <source>Prior to version 1.4.0.0, the default implementation of the &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method was defined as</source>
          <target state="translated">버전 1.4.0.0 이전에는 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 메소드 의 기본 구현 이 다음과 같이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="cda4f4476ac13bb2ae7bc15ee6736ba96cc21c68" translate="yes" xml:space="preserve">
          <source>PrivateUse</source>
          <target state="translated">PrivateUse</target>
        </trans-unit>
        <trans-unit id="77a4e6819b3e432af8190d38019f1fa2de3878fb" translate="yes" xml:space="preserve">
          <source>Probalistic Miller-Rabin primality test.</source>
          <target state="translated">Probalistic Miller-Rabin 원시성 테스트.</target>
        </trans-unit>
        <trans-unit id="52ec5a32c2a80f826813962523827657c92e7c45" translate="yes" xml:space="preserve">
          <source>ProcRetHandles</source>
          <target state="translated">ProcRetHandles</target>
        </trans-unit>
        <trans-unit id="59240a07db79f390a176a1da2a0e4e73723df8cb" translate="yes" xml:space="preserve">
          <source>Proceed as normal, but do not delete any intermediate files.</source>
          <target state="translated">정상적으로 진행되지만 중간 파일은 삭제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3413e1941d2b768b5d94e902b36b50f24a0b9e21" translate="yes" xml:space="preserve">
          <source>Process completion</source>
          <target state="translated">프로세스 완료</target>
        </trans-unit>
        <trans-unit id="78730cfe630ab980fa7c67900c84883cadf329d1" translate="yes" xml:space="preserve">
          <source>Process environment</source>
          <target state="translated">공정 환경</target>
        </trans-unit>
        <trans-unit id="c650b71115a88a0c6c8c39f8cb70327da49c6469" translate="yes" xml:space="preserve">
          <source>Process groups</source>
          <target state="translated">프로세스 그룹</target>
        </trans-unit>
        <trans-unit id="e19a92ef9380a074cb7ab3ec33973d7ac5dd17b1" translate="yes" xml:space="preserve">
          <source>Process status</source>
          <target state="translated">공정 상태</target>
        </trans-unit>
        <trans-unit id="450d3838ec09ee134c6165b911e3bfce5c2da9f2" translate="yes" xml:space="preserve">
          <source>Process the command-line, and return the list of values that matched (and those that didn't). The arguments are:</source>
          <target state="translated">명령 행을 처리하고 일치하는 값과 일치하지 않는 값의 목록을 리턴하십시오. 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="165237f99277fa9f8a75372d3b27ef4e2226ebb6" translate="yes" xml:space="preserve">
          <source>Process times</source>
          <target state="translated">처리 시간</target>
        </trans-unit>
        <trans-unit id="b8940363e3104375a16f75f2a6c0076297b5bcc8" translate="yes" xml:space="preserve">
          <source>ProcessAccessRights</source>
          <target state="translated">ProcessAccessRights</target>
        </trans-unit>
        <trans-unit id="6feb0f0bc2fdaddeeb0ce66961c31fda1b5189f4" translate="yes" xml:space="preserve">
          <source>ProcessEntry32</source>
          <target state="translated">ProcessEntry32</target>
        </trans-unit>
        <trans-unit id="3c0317db948b70e6ca821af4a8b48f2b33ee6e46" translate="yes" xml:space="preserve">
          <source>ProcessGroupID</source>
          <target state="translated">ProcessGroupID</target>
        </trans-unit>
        <trans-unit id="21e8dd5d13542f0c6a51fa47c09f48b388d00925" translate="yes" xml:space="preserve">
          <source>ProcessHandle</source>
          <target state="translated">ProcessHandle</target>
        </trans-unit>
        <trans-unit id="2f4686b1023443590b468cf68975e34698d5dce7" translate="yes" xml:space="preserve">
          <source>ProcessHandle__</source>
          <target state="translated">ProcessHandle__</target>
        </trans-unit>
        <trans-unit id="5906efeedbc929caae1ebc56efbb67f6db7d732f" translate="yes" xml:space="preserve">
          <source>ProcessID</source>
          <target state="translated">ProcessID</target>
        </trans-unit>
        <trans-unit id="0e72272456a5dfc962478aaa4cd24c7dbdabd6cf" translate="yes" xml:space="preserve">
          <source>ProcessId</source>
          <target state="translated">ProcessId</target>
        </trans-unit>
        <trans-unit id="01ccef775dbbfe8438822cf4c77cb31753b62e29" translate="yes" xml:space="preserve">
          <source>ProcessId, number of threads, parent ProcessId, process base priority, path of executable file</source>
          <target state="translated">ProcessId, 스레드 수, 상위 ProcessId, 프로세스 기본 우선 순위, 실행 파일 경로</target>
        </trans-unit>
        <trans-unit id="14d4e6622d64799268058fe065228ec4cdce7733" translate="yes" xml:space="preserve">
          <source>ProcessInput</source>
          <target state="translated">ProcessInput</target>
        </trans-unit>
        <trans-unit id="b1f9a72a478a9193ff3d8c1d61ee84b82b8b55d5" translate="yes" xml:space="preserve">
          <source>ProcessOutput</source>
          <target state="translated">ProcessOutput</target>
        </trans-unit>
        <trans-unit id="b85a49842dd03687134a104f7f2c219a332fd41b" translate="yes" xml:space="preserve">
          <source>ProcessStatus</source>
          <target state="translated">ProcessStatus</target>
        </trans-unit>
        <trans-unit id="6f22a38212f7ae729981dc2920c82da11507b5bd" translate="yes" xml:space="preserve">
          <source>ProcessTimes</source>
          <target state="translated">ProcessTimes</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="d9138d8dd701d266606ca4c3ec53b292b58d6a6e" translate="yes" xml:space="preserve">
          <source>Processing Strings into Html friendly things.</source>
          <target state="translated">HTML 친화적 인 것으로 문자열 처리.</target>
        </trans-unit>
        <trans-unit id="31e08f0a5d6400f5a893fc895b0737af9fc1c866" translate="yes" xml:space="preserve">
          <source>Processor features</source>
          <target state="translated">프로세서 기능</target>
        </trans-unit>
        <trans-unit id="51346a24d3f29d2ffa996e556945ed4655cf318e" translate="yes" xml:space="preserve">
          <source>ProcessorFeature</source>
          <target state="translated">ProcessorFeature</target>
        </trans-unit>
        <trans-unit id="3fb1ad2abc3a670a4b947bec2fed69232206dac4" translate="yes" xml:space="preserve">
          <source>Produce &amp;ldquo;ticky-ticky&amp;rdquo; statistics at the end of the program run (only available if the program was linked with &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;). The ⟨file⟩ business works just like on the &lt;a href=&quot;#rts-flag--S%20%5B%E2%9F%A8file%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-S [⟨file⟩]&lt;/code&gt;&lt;/a&gt; RTS option, above.</source>
          <target state="translated">프로그램 실행이 끝날 때 &quot;ticky-ticky&quot;통계를 생성합니다 (프로그램이 &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt; 와 연결된 경우에만 사용 가능 ). ⟨file⟩ 비즈니스는 위의 &lt;a href=&quot;#rts-flag--S%20%5B%E2%9F%A8file%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; &lt;/a&gt; RTS 옵션과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6cf463b6f4624fb94cd58e7897c4e59d5fb1fb3f" translate="yes" xml:space="preserve">
          <source>Produce DWARF debug information in compiled object files. ⟨n⟩ can be 0, 1, or 2, with higher numbers producing richer output. If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">컴파일 된 객체 파일에서 DWARF 디버그 정보를 생성합니다. ⟨n⟩은 0, 1 또는 2 일 수 있으며 숫자가 많을수록 더 풍부한 출력을 생성합니다. ⟨n⟩을 생략하면 레벨 2로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="311b86090be24794748573ba1bb8b1841bef8144" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Frameset.</source>
          <target state="translated">XHTML 1.0 프레임 세트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f0bce322e51b0e5e1f30cc905d309ee358c3950a" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Strict.</source>
          <target state="translated">XHTML 1.0 Strict를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="feb762b8a956256336a4059b532f2566785ff8e7" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Transitional.</source>
          <target state="translated">XHTML 1.0 과도기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dd3b86d1ef21b9fb2e1edc30f524e7afb491b1ad" translate="yes" xml:space="preserve">
          <source>Product</source>
          <target state="translated">Product</target>
        </trans-unit>
        <trans-unit id="9436b2fdb0e7c34a33a3c91d959bba1406290a1a" translate="yes" xml:space="preserve">
          <source>ProductType</source>
          <target state="translated">ProductType</target>
        </trans-unit>
        <trans-unit id="0c7c0674cb4b4821337188133a7e093a0462c24f" translate="yes" xml:space="preserve">
          <source>Products, lifted to functors.</source>
          <target state="translated">펑터로 들어 올려 진 제품.</target>
        </trans-unit>
        <trans-unit id="45873739b5a096f14b6618d0351cf66a0fc902fa" translate="yes" xml:space="preserve">
          <source>Products: encode multiple arguments to constructors</source>
          <target state="translated">제품 : 생성자에 여러 인수를 인코딩</target>
        </trans-unit>
        <trans-unit id="3baa38b5927954f86d772798f9128466bb7cb156" translate="yes" xml:space="preserve">
          <source>ProfFlags</source>
          <target state="translated">ProfFlags</target>
        </trans-unit>
        <trans-unit id="684ae62f53358a3d6fa087ccc73007ad4415d51e" translate="yes" xml:space="preserve">
          <source>Profiling a program is a three-step process:</source>
          <target state="translated">프로그램 프로파일 링은 3 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="8b0bf225ec1be7116f5172952f591da561f081d7" translate="yes" xml:space="preserve">
          <source>Profiling call stacks</source>
          <target state="translated">프로파일 링 콜 스택</target>
        </trans-unit>
        <trans-unit id="182323e605505b651eaa881921e0342a44be8b4d" translate="yes" xml:space="preserve">
          <source>Program arguments</source>
          <target state="translated">프로그램 인수</target>
        </trans-unit>
        <trans-unit id="f0abc2008747749add9fef13512caaf5675a5840" translate="yes" xml:space="preserve">
          <source>Programmers using the &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API should be aware that EAGAIN exceptions may occur for non-blocking IO!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API를 사용하는 프로그래머 는 비 차단 IO에 대해 EAGAIN 예외가 발생할 수 있음을 알고 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="6e4856079c43518428585d9f6f55af53723c39a0" translate="yes" xml:space="preserve">
          <source>Programmers using the &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API should be aware that EAGAIN exceptions may occur for non-blocking IO!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API를 사용하는 프로그래머 는 비 차단 IO에 대해 EAGAIN 예외가 발생할 수 있음을 알고 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="f5db4bda11e8bec3e596786fc436f585dc33173f" translate="yes" xml:space="preserve">
          <source>Programs compiled with &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; may fail a bit more eagerly than one might expect. For instance,</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 프로그램 은 예상보다 조금 더 실패 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ec0bc39a0924b82acddd145c4bb3e23cd22b3bc0" translate="yes" xml:space="preserve">
          <source>Progress will usually be made by skipping the first element of the &lt;code&gt;from&lt;/code&gt; buffer. This function should only be called if you are certain that you wish to do this skipping and if the &lt;code&gt;to&lt;/code&gt; buffer has at least one element of free space. Because this function deals with decoding failure, it assumes that the from buffer has at least one element.</source>
          <target state="translated">일반적으로 &lt;code&gt;from&lt;/code&gt; 버퍼 의 첫 번째 요소를 건너 뛰어 진행 합니다. 이 함수는이 건너 뛰기를하려는 것이 확실하고 &lt;code&gt;to&lt;/code&gt; 버퍼에 여유 공간이 하나 이상있는 경우에만 호출해야 합니다. 이 함수는 디코딩 실패를 처리하기 때문에 from 버퍼에 하나 이상의 요소가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a01e7be7e338ce65feff32bc980eb7c0c7eb6754" translate="yes" xml:space="preserve">
          <source>Projection to the other functor.</source>
          <target state="translated">다른 functor로 투사.</target>
        </trans-unit>
        <trans-unit id="aaf4dfbf169435dac06d1f7571397f1db30f3f9a" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right (cf. &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">왼쪽에서 오른쪽으로 모나드 인수를 스캔하여 모나드에 함수를 승격하십시오 ( &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="90322d805d75363f5e2ba902de35d5fb3e329291" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right (cf. &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">왼쪽에서 오른쪽으로 모나드 인수를 스캔하여 모나드에 함수를 승격하십시오 ( &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5b1e023440a1d1251cab82a65c8a674a9ce8f45f" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right. For example,</source>
          <target state="translated">모나드 인수를 왼쪽에서 오른쪽으로 스캔하여 함수를 모나드로 승격하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f05ff30359fcf6d0cd737c9742b3ce528d2a61e0" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad.</source>
          <target state="translated">함수를 모나드로 승격하십시오.</target>
        </trans-unit>
        <trans-unit id="bb699540cce051f9cc1055d53e69e00d6ddd26ac" translate="yes" xml:space="preserve">
          <source>PromotedConsT</source>
          <target state="translated">PromotedConsT</target>
        </trans-unit>
        <trans-unit id="6c11a71a788afd02567c23eab945ff6f9118b661" translate="yes" xml:space="preserve">
          <source>PromotedNilT</source>
          <target state="translated">PromotedNilT</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="0cbea5295e2b199673171bae00d25211a4daa049" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only). The default definition uses &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 대체 할 것을 제안했습니다 (GHC 만 해당). 기본 정의는 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . 정의 인스턴스 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 이 또한 정의해야 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 을 로 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c383bc233d01d9f33a1db1df2275ceb34c0bb2c" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only).</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 대체 할 것을 제안했습니다 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="25cf3b2ae91b78e363c940dfba15d79fbbffe0a5" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only). The default definition uses &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 대체 할 것을 제안했습니다 (GHC 만 해당). 기본 정의는 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . 정의 인스턴스 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 이 또한 정의해야 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 을 로 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f8243ce4f1bb9b8bfb0f67f0f3ba9911430da3" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only).</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 대체 할 것을 제안했습니다 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="a22e8bd59e18b97a41af964d0ba41a98b37ab76a" translate="yes" xml:space="preserve">
          <source>Propositional equality</source>
          <target state="translated">제안 평등</target>
        </trans-unit>
        <trans-unit id="a96dd404b246333ac1350164ef1732587afa0abb" translate="yes" xml:space="preserve">
          <source>Propositional equality. If &lt;code&gt;a :~: b&lt;/code&gt; is inhabited by some terminating value, then the type &lt;code&gt;a&lt;/code&gt; is the same as the type &lt;code&gt;b&lt;/code&gt;. To use this equality in practice, pattern-match on the &lt;code&gt;a :~: b&lt;/code&gt; to get out the &lt;code&gt;Refl&lt;/code&gt; constructor; in the body of the pattern-match, the compiler knows that &lt;code&gt;a ~ b&lt;/code&gt;.</source>
          <target state="translated">제안 평등. 경우 &lt;code&gt;a :~: b&lt;/code&gt; 일부 종단 값 살고 다음 타입 &lt;code&gt;a&lt;/code&gt; 타입과 동일 &lt;code&gt;b&lt;/code&gt; . 실제로이 동등성을 사용하려면 &lt;code&gt;a :~: b&lt;/code&gt; 의 패턴 일치를 사용 하여 &lt;code&gt;Refl&lt;/code&gt; 생성자 를 가져옵니다 . 패턴 일치 본문에서 컴파일러는 &lt;code&gt;a ~ b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcb3452df3c76dae9ccbe4cb023c0ba8d83c8c7a" translate="yes" xml:space="preserve">
          <source>ProtectSectionFlags</source>
          <target state="translated">ProtectSectionFlags</target>
        </trans-unit>
        <trans-unit id="a48acfe3b05f29ef5d32e9c4686c610f7573d3ab" translate="yes" xml:space="preserve">
          <source>ProtocolError</source>
          <target state="translated">ProtocolError</target>
        </trans-unit>
        <trans-unit id="f505fd6f5c51f1f0eb05dff31b6b08cb2672b51b" translate="yes" xml:space="preserve">
          <source>Provide a Semigroup for an arbitrary Monoid.</source>
          <target state="translated">임의의 Monoid에 대한 세미 그룹을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d826fc994ddc518cced2dcde7f6017e636b0aac9" translate="yes" xml:space="preserve">
          <source>Provide an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action with the current value of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; will be empty for the duration that the action is running.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 현재 값으로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치를 제공하십시오 . &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 작업이 실행되고있는 기간 동안 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d318ed93837d829decf4e305a098deca627cd45c" translate="yes" xml:space="preserve">
          <source>Provide sendInput function and INPUT types.</source>
          <target state="translated">sendInput 기능 및 INPUT 유형을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="08b1b035b9a9a2acbcca06ac2bc748267d24aace" translate="yes" xml:space="preserve">
          <source>Provided for backwards compatibility. The tok type is ignored.</source>
          <target state="translated">이전 버전과의 호환성을 위해 제공됩니다. 톡 타입은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bc9561c0283aa709c213cb1d134bcbaf33279f" translate="yes" xml:space="preserve">
          <source>Provided that you also specify &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), the &lt;code&gt;forall b&lt;/code&gt; scopes over the definition of &lt;code&gt;foo&lt;/code&gt;, and in particular over the type signature for &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 지정할 것을 제공 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 을&lt;/a&gt; ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 적 유형 변수를 범위&lt;/a&gt; ) &lt;code&gt;forall b&lt;/code&gt; 의 정의를 통해 스코프 &lt;code&gt;foo&lt;/code&gt; 는 , 및의 형태 서명을 통해 특히 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e2d81ac00c42bbf57971469cfadfc86bb02898" translate="yes" xml:space="preserve">
          <source>Provided you compiled this plugin and registered it in a package (with cabal for instance,) you can then use it by just specifying &lt;code&gt;-fplugin=DoNothing.Plugin&lt;/code&gt; on the command line, and during the compilation you should see GHC say &amp;lsquo;Hello&amp;rsquo;.</source>
          <target state="translated">이 플러그인을 컴파일하고 패키지에 등록한 경우 (예 &lt;code&gt;-fplugin=DoNothing.Plugin&lt;/code&gt; 명령 행에 -fplugin = DoNothing.Plugin 을 지정하여 사용할 수 있으며 컴파일 중에 GHC에 'Hello'라고 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="91cdb89ab74dded95989b9c01dab7eab785914db" translate="yes" xml:space="preserve">
          <source>Provided you have compiled this plugin and registered it in a package, you can just use it by specifying &lt;code&gt;--frontend DoNothing.FrontendPlugin&lt;/code&gt; on the command line to GHC.</source>
          <target state="translated">이 플러그인을 컴파일하고 패키지에 등록한 경우 명령 행에서 &lt;code&gt;--frontend DoNothing.FrontendPlugin&lt;/code&gt; 을 GHC에 지정하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97713c7be8cb2223c431b97c899d5f61eca5a254" translate="yes" xml:space="preserve">
          <source>Provides a collection of pretty printer combinators, a set of API's that provides a way to easily print out text in a consistent format of your choosing.</source>
          <target state="translated">일관된 형식으로 텍스트를 쉽게 인쇄 할 수있는 API 세트 인 예쁜 프린터 조합기 모음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3569e2937eb1626a3038f9ca0b0bd6a7c4988dd" translate="yes" xml:space="preserve">
          <source>Provides one possible concrete representation for &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt;. For a version with &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt;&lt;code&gt;= [1,2,3]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt;&lt;code&gt;= [&quot;tag1&quot;,&quot;tag2&quot;]&lt;/code&gt;, the output will be &lt;code&gt;1.2.3-tag1-tag2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 에 대한 하나의 가능한 구체적인 표현을 제공합니다 . 와 버전 &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; &lt;code&gt;= [1,2,3]&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; &lt;code&gt;= [&quot;tag1&quot;,&quot;tag2&quot;]&lt;/code&gt; , 출력은 것 &lt;code&gt;1.2.3-tag1-tag2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f537eae177b03bcfe703fb9eae32845fd317076" translate="yes" xml:space="preserve">
          <source>Provides the standard warnings plus</source>
          <target state="translated">표준 경고와 함께 제공</target>
        </trans-unit>
        <trans-unit id="f8e9e18be4d476228c864a05eb9ce60a2f180d98" translate="yes" xml:space="preserve">
          <source>Providing input</source>
          <target state="translated">입력 제공</target>
        </trans-unit>
        <trans-unit id="e29e8eedc748840bd27ace9f3607818fa75df015" translate="yes" xml:space="preserve">
          <source>Provisional</source>
          <target state="translated">Provisional</target>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="2da1b11ef737c06a07580fdc89d729829ccbcd4b" translate="yes" xml:space="preserve">
          <source>Proxy can even hold types of higher kinds,</source>
          <target state="translated">프록시는 더 높은 종류의 유형을 보유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="010320dc44b945f1389c719222db299dcff6de12" translate="yes" xml:space="preserve">
          <source>Proxy#</source>
          <target state="translated">Proxy#</target>
        </trans-unit>
        <trans-unit id="1ba5ef48b66f74ab8376d1e1f5b429151921ef64" translate="yes" xml:space="preserve">
          <source>Ps: Punctuation, Open</source>
          <target state="translated">시 : 구두점, 공개</target>
        </trans-unit>
        <trans-unit id="aee53da1d005df2b730db32fdeb589f79f6dcef6" translate="yes" xml:space="preserve">
          <source>Pseudoterminal operations</source>
          <target state="translated">의사 터미널 연산</target>
        </trans-unit>
        <trans-unit id="90c83157f6f4a1cfac097841eb12dca4943e9e58" translate="yes" xml:space="preserve">
          <source>Ptr</source>
          <target state="translated">Ptr</target>
        </trans-unit>
        <trans-unit id="6ae22c161ea98cdfc51e0fe5643ee1613027f054" translate="yes" xml:space="preserve">
          <source>Public API</source>
          <target state="translated">퍼블릭 API</target>
        </trans-unit>
        <trans-unit id="7f59b284c28fa26b669e4ff42d0673d94b35db1d" translate="yes" xml:space="preserve">
          <source>Public representation of constructors</source>
          <target state="translated">생성자의 공개 표현</target>
        </trans-unit>
        <trans-unit id="b6c8b265dd1cdc6347d98f2b84d442a954eb9c33" translate="yes" xml:space="preserve">
          <source>Public representation of datatypes</source>
          <target state="translated">데이터 유형의 공개 표현</target>
        </trans-unit>
        <trans-unit id="3a2bbb378012d44dd1acf3c097c561543bbe6aa6" translate="yes" xml:space="preserve">
          <source>Punctuation or reserved symbol, e.g. &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">문장 부호 또는 예약 기호 (예 : &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dfef0dd557351856f42ce75d6f0e19c19a4c0ef" translate="yes" xml:space="preserve">
          <source>Puns and other patterns can be mixed in the same record:</source>
          <target state="translated">Puns 및 기타 패턴은 동일한 레코드에서 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="126aca4de6cf9f540218b2f37eb0a5ee3e8ee157" translate="yes" xml:space="preserve">
          <source>Puns are not necessarily supported:</source>
          <target state="translated">Puns가 반드시 지원되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9f539fc385ba1011d4c087559f3df068ae7d719" translate="yes" xml:space="preserve">
          <source>Puns can be used wherever record patterns occur (e.g. in &lt;code&gt;let&lt;/code&gt; bindings or at the top-level).</source>
          <target state="translated">기록 패턴이 발생하는 곳 말장난 (예에서 사용할 수 &lt;code&gt;let&lt;/code&gt; 바인딩 또는 최상위 레벨에서).</target>
        </trans-unit>
        <trans-unit id="6b611b1b174cd71f53f8fab72d5be8b17f1336a4" translate="yes" xml:space="preserve">
          <source>Purity</source>
          <target state="translated">Purity</target>
        </trans-unit>
        <trans-unit id="9a02d38905933d4f8be56965d4333c36eabb3bcc" translate="yes" xml:space="preserve">
          <source>Push a call-site onto the stack.</source>
          <target state="translated">콜 사이트를 스택에 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7fd768e4fe7bd6bb51e495079370749b0bfeabc8" translate="yes" xml:space="preserve">
          <source>Put</source>
          <target state="translated">Put</target>
        </trans-unit>
        <trans-unit id="31cfeabab1a1a50a1974ce9355eca97ad84b2ad5" translate="yes" xml:space="preserve">
          <source>Put a data item back onto a channel, where it will be the next item read.</source>
          <target state="translated">데이터 항목을 다시 채널에 넣고 다음 항목을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f2671cfd2bf701d44ddbd6aed0423a20b49e9b05" translate="yes" xml:space="preserve">
          <source>Put a data item back onto a channel, where it will be the next item read. Blocks if the queue is full.</source>
          <target state="translated">데이터 항목을 다시 채널에 넣고 다음 항목을 읽습니다. 큐가 가득 찬 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="0488379e7024b984e65d02dffd4763eb7cd460ed" translate="yes" xml:space="preserve">
          <source>Put a value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 현재 가득 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 는 것이다 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd93b0ceaf0ed39d5195f954abbfc8d76b2a79d6" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c94d281c3905d94e39b3d263b1cf9b6250c58bee" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="33e8d3ac33132ba689a91323286fa0c8d9cd0c54" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="73b3278fe6bb373e8f3ee5addd3728dbee9dc19b" translate="yes" xml:space="preserve">
          <source>Put merely lifts Builder into a Writer monad, applied to ().</source>
          <target state="translated">Put은 Builder를 Writer 모나드로 들어 올리고 ()에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="798e33a0a2f8665389e39345a5dfc2a745e465a9" translate="yes" xml:space="preserve">
          <source>Put something inside an HTML element.</source>
          <target state="translated">HTML 요소 안에 무언가를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="40d8d868890674e2158985b5244b5e97bbdc32ef" translate="yes" xml:space="preserve">
          <source>Put to run</source>
          <target state="translated">뛰다</target>
        </trans-unit>
        <trans-unit id="b438a3bf094fbf042e7f48cbd844a202bc700f5d" translate="yes" xml:space="preserve">
          <source>Put two pieces of error message next to each other.</source>
          <target state="translated">두 개의 오류 메시지를 나란히 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="353d5eefcc26e9ede7b76010beb4c768d6085770" translate="yes" xml:space="preserve">
          <source>PutM</source>
          <target state="translated">PutM</target>
        </trans-unit>
        <trans-unit id="f84ae14fa11d241b306d7b6dacccea9c11140d12" translate="yes" xml:space="preserve">
          <source>Putting a strictness annotation (&lt;code&gt;!&lt;/code&gt;) on a constructor field helps in two ways: it adds strictness to the program, which gives the strictness analyser more to work with, and it might help to reduce space leaks.</source>
          <target state="translated">생성자 필드에 엄격 주석 ( &lt;code&gt;!&lt;/code&gt; )을 넣으면 다음과 같은 두 가지 방법으로 도움이됩니다. 프로그램에 엄격을 추가하여 엄격 분석기를 더 많이 사용할 수있게하며 공간 누출을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d65a7ee4d88fd2fe1e2a7a6c25c43f4bace4b92" translate="yes" xml:space="preserve">
          <source>Putting info tables directly next to entry code is a useful performance optimisation that is not available on all platforms. This field tells you whether the program has been compiled with this optimisation. (Usually yes, except on unusual platforms.)</source>
          <target state="translated">입력 코드 바로 옆에 정보 테이블을 배치하는 것은 모든 플랫폼에서 사용할 수없는 유용한 성능 최적화입니다. 이 필드는 프로그램이이 최적화로 컴파일되었는지 여부를 알려줍니다. (특별한 플랫폼을 제외하고 일반적으로 예)</target>
        </trans-unit>
        <trans-unit id="fc4647bde0eb248bbe66e4e9d89dc56ee1bf2032" translate="yes" xml:space="preserve">
          <source>Putting inter-dependencies of the form &lt;code&gt;Foo.o : Bar.hi&lt;/code&gt; into your &lt;code&gt;Makefile&lt;/code&gt; by hand is rather error-prone. Don&amp;rsquo;t worry, GHC has support for automatically generating the required dependencies. Add the following to your &lt;code&gt;Makefile&lt;/code&gt;:</source>
          <target state="translated">형태의 상호 의존성 퍼팅 &lt;code&gt;Foo.o : Bar.hi&lt;/code&gt; 당신에 &lt;code&gt;Makefile&lt;/code&gt; 손으로 오히려 오류가 발생하기 쉬운입니다. 걱정하지 마십시오. GHC는 필요한 종속성을 자동으로 생성하도록 지원합니다. &lt;code&gt;Makefile&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="b1bf446133c15f6e0cfb6c252c0760ca97cc2113" translate="yes" xml:space="preserve">
          <source>QException</source>
          <target state="translated">QException</target>
        </trans-unit>
        <trans-unit id="5c3e1075bb5ff5f786a2750d2110c97ca76bdb40" translate="yes" xml:space="preserve">
          <source>QList</source>
          <target state="translated">QList</target>
        </trans-unit>
        <trans-unit id="5063349bbf20d077106dd5a047c6294b3d6faa07" translate="yes" xml:space="preserve">
          <source>QResult</source>
          <target state="translated">QResult</target>
        </trans-unit>
        <trans-unit id="1b9473a808c71ad809b076a8f41d58515d649af1" translate="yes" xml:space="preserve">
          <source>QSem</source>
          <target state="translated">QSem</target>
        </trans-unit>
        <trans-unit id="83666298382103e09a359d83713e8de361f9fe1b" translate="yes" xml:space="preserve">
          <source>QSemN</source>
          <target state="translated">QSemN</target>
        </trans-unit>
        <trans-unit id="5979a484b578a0eaaccbbaa187d6db5be875c706" translate="yes" xml:space="preserve">
          <source>QState</source>
          <target state="translated">QState</target>
        </trans-unit>
        <trans-unit id="a8e2772564815455b855b5402a2b67edaeece741" translate="yes" xml:space="preserve">
          <source>QualBinBox</source>
          <target state="translated">QualBinBox</target>
        </trans-unit>
        <trans-unit id="6e364224ed95e99cc9c0e9bc962a7e7788451d4f" translate="yes" xml:space="preserve">
          <source>Qualified names are not handled properly</source>
          <target state="translated">정규화 된 이름이 올바르게 처리되지 않습니다</target>
        </trans-unit>
        <trans-unit id="c78f05422fd2f2885a1a8363abe3991f2f66b957" translate="yes" xml:space="preserve">
          <source>Quantified</source>
          <target state="translated">Quantified</target>
        </trans-unit>
        <trans-unit id="98d966bd103c45a24b72c82c92fc882386ac5126" translate="yes" xml:space="preserve">
          <source>Quantified constraints can potentially lead to overlapping local axioms. Consider for instance the following example:</source>
          <target state="translated">정량화 된 구속 조건은 잠재적으로 국소 공리가 겹칠 수 있습니다. 예를 들어 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e07c2ce6f83e492712da4fb9336c9693d0145f90" translate="yes" xml:space="preserve">
          <source>Quantified constraints enable this property to be made explicit in the &lt;code&gt;Trans&lt;/code&gt; class declaration:</source>
          <target state="translated">정량화 된 제약 조건을 통해 &lt;code&gt;Trans&lt;/code&gt; 클래스 선언 에서이 속성을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="313f18ee6bfe32a684a3623fe9ec8d0285e1564b" translate="yes" xml:space="preserve">
          <source>QuantifiedConstraints</source>
          <target state="translated">QuantifiedConstraints</target>
        </trans-unit>
        <trans-unit id="38dd040ad4dd1961b970e417a446a2cd00ec0112" translate="yes" xml:space="preserve">
          <source>Quantity semaphores in which each thread may wait for an arbitrary &quot;amount&quot;.</source>
          <target state="translated">각 스레드가 임의의 &quot;금액&quot;을 기다릴 수있는 수량 세마포어.</target>
        </trans-unit>
        <trans-unit id="ef37116e9e2794514df2a30b389623e522929de7" translate="yes" xml:space="preserve">
          <source>Quasi</source>
          <target state="translated">Quasi</target>
        </trans-unit>
        <trans-unit id="78b42522f21485e6763e2011e69bf1fb6467d5cd" translate="yes" xml:space="preserve">
          <source>Quasi-quotation allows patterns and expressions to be written using programmer-defined concrete syntax; the motivation behind the extension and several examples are documented in &amp;ldquo;&lt;a href=&quot;http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf&quot;&gt;Why It&amp;rsquo;s Nice to be Quoted: Quasiquoting for Haskell&lt;/a&gt;&amp;rdquo; (Proc Haskell Workshop 2007). The example below shows how to write a quasiquoter for a simple expression language.</source>
          <target state="translated">준 따옴표는 프로그래머 정의 콘크리트 구문을 사용하여 패턴과 표현을 작성할 수 있도록합니다. 확장에 대한 동기 부여와 몇 가지 예는&amp;ldquo; &lt;a href=&quot;http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf&quot;&gt;인용하기 좋은 이유 : Haskell에 대한 Quaquota&lt;/a&gt; &amp;rdquo;(Proc Haskell Workshop 2007)에 설명되어 있습니다. 아래 예제는 간단한 표현 언어를위한 준 따옴표를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aeae4316f159225a12a41875ed5cda162b6be2c0" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for declarations, invoked by top-level quotes</source>
          <target state="translated">최상위 인용 부호로 호출 된 선언을위한 준 따옴표</target>
        </trans-unit>
        <trans-unit id="7c4eccaa645a118a37207f34bc767fc3a301a004" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for expressions, invoked by quotes like &lt;code&gt;lhs = $[q|...]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lhs = $[q|...]&lt;/code&gt; 와 같은 따옴표로 호출 된 표현식의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="cdfa152b402869c6f7ce110c7260465306996f0c" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for patterns, invoked by quotes like &lt;code&gt;f $[q|...] = rhs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f $[q|...] = rhs&lt;/code&gt; 와 같은 따옴표로 호출 된 패턴의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="2f1c81121c7c915fc9fe161e70133e5fd79fdc0f" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for types, invoked by quotes like &lt;code&gt;f :: $[q|...]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f :: $[q|...]&lt;/code&gt; 와 같은 따옴표로 호출 된 형식의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="654d8edecc919612fe0b6f4ce5f5f07b94d042af" translate="yes" xml:space="preserve">
          <source>QuasiQuoter</source>
          <target state="translated">QuasiQuoter</target>
        </trans-unit>
        <trans-unit id="36eafab474a9ed345234950640432af8a19c94cf" translate="yes" xml:space="preserve">
          <source>QuasiQuotes</source>
          <target state="translated">QuasiQuotes</target>
        </trans-unit>
        <trans-unit id="d4a0b7daa1a07138f6cd3dd945862252eb44e73e" translate="yes" xml:space="preserve">
          <source>Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in the example, &lt;code&gt;expr&lt;/code&gt; cannot be defined in &lt;code&gt;Main.hs&lt;/code&gt; where it is used, but must be imported.</source>
          <target state="translated">Quasquoters는 Template Haskell과 동일한 단계 제한을 준수해야합니다. 예를 들어 &lt;code&gt;expr&lt;/code&gt; 은 &lt;code&gt;Main.hs&lt;/code&gt; 에서 사용되는 곳 에서 정의 할 수 없지만 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="702b96b7b97e9c49a9631b74e04d25040710ddfc" translate="yes" xml:space="preserve">
          <source>Queries the current state of the stopped child flag.</source>
          <target state="translated">중지 된 자식 플래그의 현재 상태를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="6fafa7df09744bce9b17c8089123f793f4571cfc" translate="yes" xml:space="preserve">
          <source>Query the status of a breakpoint (True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; enabled)</source>
          <target state="translated">중단 점 상태 조회 (True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; enabled)</target>
        </trans-unit>
        <trans-unit id="ec6aec17edf79a10c680aff1016df32c0c809598" translate="yes" xml:space="preserve">
          <source>Querying file status</source>
          <target state="translated">파일 상태 조회</target>
        </trans-unit>
        <trans-unit id="e1568d2084e4729e281ef2ad2782d446f7281246" translate="yes" xml:space="preserve">
          <source>Querying sizes</source>
          <target state="translated">쿼리 크기</target>
        </trans-unit>
        <trans-unit id="ec159e90e6803b6d4ebd5f32c771f6ca6e6e74a9" translate="yes" xml:space="preserve">
          <source>Querying the compiler</source>
          <target state="translated">컴파일러 쿼리</target>
        </trans-unit>
        <trans-unit id="bfaa4612023c5d1f8ccc9c95a3472712517c8262" translate="yes" xml:space="preserve">
          <source>Querying the user environment</source>
          <target state="translated">사용자 환경 쿼리</target>
        </trans-unit>
        <trans-unit id="18607581d63ad915cd6c4d5d3071d782b7938ac8" translate="yes" xml:space="preserve">
          <source>Question: How does GHC find the filename which contains module ⟨M⟩? Answer: it looks for the file &lt;code&gt;M.hs&lt;/code&gt;, or &lt;code&gt;M.lhs&lt;/code&gt;. This means that for most modules, the module name must match the filename. If it doesn&amp;rsquo;t, GHCi won&amp;rsquo;t be able to find it.</source>
          <target state="translated">질문 : GHC는 모듈 ⟨M⟩을 포함하는 파일 이름을 어떻게 찾습니까? 답 : 파일 &lt;code&gt;M.hs&lt;/code&gt; 또는 &lt;code&gt;M.lhs&lt;/code&gt; 를 찾습니다 . 이는 대부분의 모듈에서 모듈 이름이 파일 이름과 일치해야 함을 의미합니다. 그렇지 않으면 GHCi가 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d325fcd919384f395c02751e03d2cd0288b98cca" translate="yes" xml:space="preserve">
          <source>Queue</source>
          <target state="translated">Queue</target>
        </trans-unit>
        <trans-unit id="2e03f68003ba792e4b7e5bce0358c5b5efca5a74" translate="yes" xml:space="preserve">
          <source>QueueSelector</source>
          <target state="translated">QueueSelector</target>
        </trans-unit>
        <trans-unit id="1a2285d8881f226e13430515a9dd2b9fb6294200" translate="yes" xml:space="preserve">
          <source>Quit</source>
          <target state="translated">Quit</target>
        </trans-unit>
        <trans-unit id="b074b09be2d5847dd9450d55b6f0788a6c3fd1b4" translate="yes" xml:space="preserve">
          <source>Quits GHCi. You can also quit by typing &lt;code&gt;Control-D&lt;/code&gt; at the prompt.</source>
          <target state="translated">GHCi를 종료합니다. 프롬프트에서 &lt;code&gt;Control-D&lt;/code&gt; 를 입력하여 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="fe89b57ca741803edb678214b1b10b8b1688ab79" translate="yes" xml:space="preserve">
          <source>R. N. Horspool: Practical Fast Searching in Strings. Software - Practice and Experience 10, 501-506 (1980)</source>
          <target state="translated">RN Horspool : 문자열에서 실용적인 빠른 검색. 소프트웨어-실습 및 경험 10, 501-506 (1980)</target>
        </trans-unit>
        <trans-unit id="3bb8e3918a18086493d1beb88c7c61f2cff4fd6b" translate="yes" xml:space="preserve">
          <source>R. S. Boyer, J. S. Moore: A Fast String Searching Algorithm. Communications of the ACM, 20, 10, 762-772 (1977)</source>
          <target state="translated">RS Boyer, JS Moore : 빠른 문자열 검색 알고리즘. ACM의 커뮤니케이션, 20, 10, 762-772 (1977)</target>
        </trans-unit>
        <trans-unit id="bcd7a25b27aa3490f6e6a5d52d0d7b57716a72c0" translate="yes" xml:space="preserve">
          <source>R.Paterson@city.ac.uk</source>
          <target state="translated">R.Paterson@city.ac.uk</target>
        </trans-unit>
        <trans-unit id="75248a6efd7ebc0c173be4c755f47f7ae4c4606a" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS ARROW</source>
          <target state="translated">오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="81f0ce7bb79894a5b7e3f20200c1491ae057a5b6" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS ARROW-TAIL</source>
          <target state="translated">오른쪽 화살표 화살표</target>
        </trans-unit>
        <trans-unit id="d43d55d9c58cbcc25eb6620ba1f32e960004091e" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS DOUBLE ARROW</source>
          <target state="translated">오른쪽 화살표 더블 화살표</target>
        </trans-unit>
        <trans-unit id="6140cdacfd2f40b8e8a4d0ef59628fa58ba4df25" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">오른쪽 화살표 더블 화살표</target>
        </trans-unit>
        <trans-unit id="54561fd891ee8d3bc3718283afdce5d24a9fb9d4" translate="yes" xml:space="preserve">
          <source>RS</source>
          <target state="translated">RS</target>
        </trans-unit>
        <trans-unit id="dff6d1ab4ff535388a3b81748b7e0a759af5b5d4" translate="yes" xml:space="preserve">
          <source>RTLDFlags</source>
          <target state="translated">RTLDFlags</target>
        </trans-unit>
        <trans-unit id="222fd2e5cef2e782850e7e961d3e145177fe55f7" translate="yes" xml:space="preserve">
          <source>RTLD_GLOBAL</source>
          <target state="translated">RTLD_GLOBAL</target>
        </trans-unit>
        <trans-unit id="596d9fed4ec6cd3691a13e454f91e5510fb9bd15" translate="yes" xml:space="preserve">
          <source>RTLD_LAZY</source>
          <target state="translated">RTLD_LAZY</target>
        </trans-unit>
        <trans-unit id="58a6bc97fe1b40864bb1226977041584bdd3246e" translate="yes" xml:space="preserve">
          <source>RTLD_LOCAL</source>
          <target state="translated">RTLD_LOCAL</target>
        </trans-unit>
        <trans-unit id="240dca00b5fccdf8eb9307a95d72a4564efd9a1f" translate="yes" xml:space="preserve">
          <source>RTLD_NOW</source>
          <target state="translated">RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="21a3039e72db0527495ff86a20122cd08a41b0ee" translate="yes" xml:space="preserve">
          <source>RTS options taken from the &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-6&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable can be overridden by options given on the command line.</source>
          <target state="translated">&lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-6&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; 환경 변수 에서 가져온 RTS 옵션 은 명령 행에 제공된 옵션으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12038ce4fed76d468c97d3909bb5fa9da8cf36c1" translate="yes" xml:space="preserve">
          <source>RTSFlags</source>
          <target state="translated">RTSFlags</target>
        </trans-unit>
        <trans-unit id="398bdf865c486238761fe9e04c7014d7a95a8878" translate="yes" xml:space="preserve">
          <source>RTSStats</source>
          <target state="translated">RTSStats</target>
        </trans-unit>
        <trans-unit id="173ca40143a1db6b32512b7856cb8403ae881b82" translate="yes" xml:space="preserve">
          <source>RWS</source>
          <target state="translated">RWS</target>
        </trans-unit>
        <trans-unit id="5ed8266ce8d63f9438aafb5e6787b68efadeccab" translate="yes" xml:space="preserve">
          <source>RWS computation to execute</source>
          <target state="translated">실행할 RWS 계산</target>
        </trans-unit>
        <trans-unit id="f1d8da392a9a97e4cb7c42ad2ccf6346e818ebc4" translate="yes" xml:space="preserve">
          <source>RWST</source>
          <target state="translated">RWST</target>
        </trans-unit>
        <trans-unit id="a618f78473842a7cf11f602fffdd35c35387d1a3" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="ce7820312231ab0cd45ab4d865cc302018e42e8e" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="280c8919cbe0b13ce2a3de884857678191c0df1d" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="933e208c50a30fc4995b36847c474fa5bd3740b5" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; with a printf-specific prefix on the message string.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 메시지 문자열의 printf와 특정 접두사를.</target>
        </trans-unit>
        <trans-unit id="00474a4582227a35d8a8ed6e6d74aed95e4bfcf8" translate="yes" xml:space="preserve">
          <source>Raises an error if given an empty list.</source>
          <target state="translated">빈 목록이 제공되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a21adad3deb90b02b29a429bf48fc817d912767f" translate="yes" xml:space="preserve">
          <source>Raising Errors</source>
          <target state="translated">오류 발생</target>
        </trans-unit>
        <trans-unit id="80befa94c0796e21097bf414e22daac761f1ac3a" translate="yes" xml:space="preserve">
          <source>Ralf Hinze and Ross Paterson, &lt;a href=&quot;http://staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;&quot;Finger trees: a simple general-purpose data structure&quot;&lt;/a&gt;, &lt;em&gt;Journal of Functional Programming&lt;/em&gt; 16:2 (2006) pp 197-217.</source>
          <target state="translated">Ralf Hinze와 Ross Paterson, &lt;a href=&quot;http://staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;&quot;핑거 트리 : 간단한 범용 데이터 구조&quot;&lt;/a&gt; , &lt;em&gt;Journal of Functional Programming&lt;/em&gt; 16 : 2 (2006) pp 197-217.</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="646152cf5c1a35e596164cfc5a137c57f6a78564" translate="yes" xml:space="preserve">
          <source>RangeQ</source>
          <target state="translated">RangeQ</target>
        </trans-unit>
        <trans-unit id="5f87625ea4411af78505260124c7f6d2a45e06b0" translate="yes" xml:space="preserve">
          <source>RankNTypes</source>
          <target state="translated">RankNTypes</target>
        </trans-unit>
        <trans-unit id="693f44324e1039b8be2752916af17049a0ad5dd9" translate="yes" xml:space="preserve">
          <source>Rather than generating code to call &lt;code&gt;f&lt;/code&gt; according to the platform&amp;rsquo;s ABI, we instead call &lt;code&gt;f&lt;/code&gt; using the C API defined in the header &lt;code&gt;header.h&lt;/code&gt;. Thus &lt;code&gt;f&lt;/code&gt; can be called even if it may be defined as a CPP &lt;code&gt;#define&lt;/code&gt; rather than a proper function.</source>
          <target state="translated">플랫폼의 ABI에 따라 &lt;code&gt;f&lt;/code&gt; 를 호출하는 코드를 생성하는 대신 header &lt;code&gt;header.h&lt;/code&gt; 에 정의 된 C API를 사용하여 &lt;code&gt;f&lt;/code&gt; 를 호출 합니다. 따라서 &lt;code&gt;f&lt;/code&gt; 는 적절한 함수가 아니라 CPP &lt;code&gt;#define&lt;/code&gt; 으로 정의되어 있어도 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09e0a509143e1597ce0e4b1a260f1ca99da1f7c7" translate="yes" xml:space="preserve">
          <source>Rather than using &lt;code&gt;(== &lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt;, use this. Test if something is a path separator.</source>
          <target state="translated">오히려 사용하지 않고 &lt;code&gt;(== &lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt; , 이것을 사용한다. 경로 구분 기호인지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ed194d2af1d0512a43b9882e2bf53085c69471c2" translate="yes" xml:space="preserve">
          <source>Rather than using &lt;code&gt;(== &lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt;, use this. Test if something is a path separator.</source>
          <target state="translated">오히려 사용하지 않고 &lt;code&gt;(== &lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt; , 이것을 사용한다. 경로 구분 기호인지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="794f65e9d2064ab6bfab0fa351dcff2763db23d3" translate="yes" xml:space="preserve">
          <source>Ratio</source>
          <target state="translated">Ratio</target>
        </trans-unit>
        <trans-unit id="06abf42877351e1e2ad74c308971eb560fc0aab7" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fffe46763de726cdd41fc5ca5f40572f607297e" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1304ccb2873b49ac5ad2857447e7d4958a9afc" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9365e2d43f2f4d7432550032b047d13acc7dc0" translate="yes" xml:space="preserve">
          <source>RatioZeroDenominator</source>
          <target state="translated">RatioZeroDenominator</target>
        </trans-unit>
        <trans-unit id="28f8f8c0856fcd5b648ff5e28234ee17ac5b1a2e" translate="yes" xml:space="preserve">
          <source>Rational</source>
          <target state="translated">Rational</target>
        </trans-unit>
        <trans-unit id="405213edafc737f5ab6efbcc9727c7dbc43be834" translate="yes" xml:space="preserve">
          <source>Rational numbers, with numerator and denominator of some &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 유형 의 분자 및 분모가있는 유리수입니다 .</target>
        </trans-unit>
        <trans-unit id="66898ef89145e3251520fcffa27276a730264b3d" translate="yes" xml:space="preserve">
          <source>Rational numbers, with numerator and denominator of some &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 유형 의 분자 및 분모가있는 유리수입니다 .</target>
        </trans-unit>
        <trans-unit id="998e2594b8623ea11ad1729045ff4b74f17b5bbb" translate="yes" xml:space="preserve">
          <source>Raw buffers</source>
          <target state="translated">원시 버퍼</target>
        </trans-unit>
        <trans-unit id="25fb73f383d3356e6e16bbb4088572623344a39b" translate="yes" xml:space="preserve">
          <source>Raw pointer of array version of &lt;code&gt;&lt;a href=&quot;system-win32-automation-input#v:sendInput&quot;&gt;sendInput&lt;/a&gt;&lt;/code&gt;. Use this function to support non-list sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-win32-automation-input#v:sendInput&quot;&gt;sendInput&lt;/a&gt;&lt;/code&gt; 배열 버전의 원시 포인터입니다 . 리스트가 아닌 순서를 지원하려면이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cee6901eb5dcf876205fb0f25887ebe12845d3fb" translate="yes" xml:space="preserve">
          <source>Raw read/write operations on file descriptors</source>
          <target state="translated">파일 디스크립터에 대한 원시 읽기 / 쓰기 조작</target>
        </trans-unit>
        <trans-unit id="157fea958671982fd82ff04ec9ed8c09a6ef6b39" translate="yes" xml:space="preserve">
          <source>RawBuffer</source>
          <target state="translated">RawBuffer</target>
        </trans-unit>
        <trans-unit id="a8a5d4f060e1544d5944caadfd158d5a2d980db6" translate="yes" xml:space="preserve">
          <source>RawCharBuffer</source>
          <target state="translated">RawCharBuffer</target>
        </trans-unit>
        <trans-unit id="8da7c86459d153b460979db3219ab54db7fdba1e" translate="yes" xml:space="preserve">
          <source>RawDevice</source>
          <target state="translated">RawDevice</target>
        </trans-unit>
        <trans-unit id="0f11c5246f5cfda145cd94cc2026acc7a8f85d00" translate="yes" xml:space="preserve">
          <source>RawFilePath</source>
          <target state="translated">RawFilePath</target>
        </trans-unit>
        <trans-unit id="84f85043304c606b67a09190e7260a74e66b4111" translate="yes" xml:space="preserve">
          <source>RawIO</source>
          <target state="translated">RawIO</target>
        </trans-unit>
        <trans-unit id="e601d52c0dfeb733b64b16fa8cfb0f09d668768c" translate="yes" xml:space="preserve">
          <source>RawObject</source>
          <target state="translated">RawObject</target>
        </trans-unit>
        <trans-unit id="64cb694cae0bed8753db87912cef88672b156273" translate="yes" xml:space="preserve">
          <source>RcBcc</source>
          <target state="translated">RcBcc</target>
        </trans-unit>
        <trans-unit id="8c924ffc452540914b6a5f1c353b075e91bb1bc7" translate="yes" xml:space="preserve">
          <source>RcCc</source>
          <target state="translated">RcCc</target>
        </trans-unit>
        <trans-unit id="af90b8ce4325e3befb6865f737325cee4b2f3074" translate="yes" xml:space="preserve">
          <source>RcOriginal</source>
          <target state="translated">RcOriginal</target>
        </trans-unit>
        <trans-unit id="4ad7b36332eb45b360b8020417e1bfa69bfb1958" translate="yes" xml:space="preserve">
          <source>RcTo</source>
          <target state="translated">RcTo</target>
        </trans-unit>
        <trans-unit id="8173c1f1a663cdea3e376c90c48dd90dcb46e19a" translate="yes" xml:space="preserve">
          <source>Re-compile your program for profiling with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, and probably one of the options for adding automatic annotations: &lt;a href=&quot;#ghc-flag--fprof-auto&quot;&gt;&lt;code&gt;-fprof-auto&lt;/code&gt;&lt;/a&gt; is the most common &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션으로 프로파일 링 할 프로그램 과 자동 주석 추가 옵션 중 하나를 다시 컴파일하십시오 . &lt;a href=&quot;#ghc-flag--fprof-auto&quot;&gt; &lt;code&gt;-fprof-auto&lt;/code&gt; &lt;/a&gt; 가 가장 일반적입니다 &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="436cf278924bc8efee40d02b4519461683e18994" translate="yes" xml:space="preserve">
          <source>Re-creates the binary cache file &lt;code&gt;package.cache&lt;/code&gt; for the selected database. This may be necessary if the cache has somehow become out-of-sync with the contents of the database (&lt;code&gt;ghc-pkg&lt;/code&gt; will warn you if this might be the case).</source>
          <target state="translated">선택한 데이터베이스에 대한 이진 캐시 파일 &lt;code&gt;package.cache&lt;/code&gt; 를 다시 만듭니다 . 캐시가 어떻게 든 데이터베이스의 내용과 동기화되지 않은 경우 필요할 수 있습니다 (이 경우 &lt;code&gt;ghc-pkg&lt;/code&gt; 가 경고합니다).</target>
        </trans-unit>
        <trans-unit id="7ed12af550b46e901d403b9d0f93291b0cf629f6" translate="yes" xml:space="preserve">
          <source>Re-exported monoids from Data.Monoid</source>
          <target state="translated">Data.Monoid에서 다시 내보내기 된 monoid</target>
        </trans-unit>
        <trans-unit id="34d929a541c0f1ece950e385b483a59027154870" translate="yes" xml:space="preserve">
          <source>Re-run your program with &lt;code&gt;+RTS -S&lt;/code&gt;, and remove all doubt! (You&amp;rsquo;ll see the heap usage get bigger and bigger...) (Hmmm... this might be even easier with the &lt;code&gt;-G1&lt;/code&gt; RTS option; so... &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;+RTS -S&lt;/code&gt; 로 프로그램을 다시 실행 하고 의심을 모두 제거하십시오! (힙 사용량이 점점 커짐을 알 수 있습니다 ...) (음 ... &lt;code&gt;-G1&lt;/code&gt; RTS 옵션을 사용하면 훨씬 쉬울 수 있습니다 . 그래서 .... / &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b39c69b57883ad20cea20e29a43c91838fc5dece" translate="yes" xml:space="preserve">
          <source>ReFS doesn't support hard link currently.</source>
          <target state="translated">ReFS는 현재 하드 링크를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="7e60df3ad56b5aa492c15c3cbc3edcd1117e2890" translate="yes" xml:space="preserve">
          <source>Read 16-bit int; offset in bytes.</source>
          <target state="translated">16 비트 정수 읽기; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="1a4eb9eb868bf67f4408ba141c666e2672927ff4" translate="yes" xml:space="preserve">
          <source>Read 16-bit integer; offset in 16-bit words.</source>
          <target state="translated">16 비트 정수를 읽습니다. 16 비트 워드로 오프셋.</target>
        </trans-unit>
        <trans-unit id="b0d87fc9401988038e38b59862ea5b5ccde17d68" translate="yes" xml:space="preserve">
          <source>Read 16-bit word; offset in 16-bit words.</source>
          <target state="translated">16 비트 단어를 읽습니다. 16 비트 워드로 오프셋.</target>
        </trans-unit>
        <trans-unit id="779a27810169b39b14218816baff4c582c906214" translate="yes" xml:space="preserve">
          <source>Read 16-bit word; offset in bytes.</source>
          <target state="translated">16 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="4f4589f1ce718b81895e29adc9bfbd6c1f69bec7" translate="yes" xml:space="preserve">
          <source>Read 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 비트 문자를 읽습니다. 4 바이트 단어로 오프셋합니다.</target>
        </trans-unit>
        <trans-unit id="3d7bb4f3250d94c66276a215dac19da0ee208ceb" translate="yes" xml:space="preserve">
          <source>Read 31-bit character; offset in bytes.</source>
          <target state="translated">31 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="25ab04b7ce5915f4baa82606d8db15948630ae37" translate="yes" xml:space="preserve">
          <source>Read 32-bit int; offset in bytes.</source>
          <target state="translated">32 비트 int를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="6fe96383ba999aacbde564c1a83fb114d382eaa7" translate="yes" xml:space="preserve">
          <source>Read 32-bit integer; offset in 32-bit words.</source>
          <target state="translated">32 비트 정수를 읽습니다. 32 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="60b8324b1d2cdc5721569c3a299a8daf64f2deb2" translate="yes" xml:space="preserve">
          <source>Read 32-bit word; offset in 32-bit words.</source>
          <target state="translated">32 비트 단어를 읽습니다. 32 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="62fb98bafc343247ad56086482aff05792ef6f4a" translate="yes" xml:space="preserve">
          <source>Read 32-bit word; offset in bytes.</source>
          <target state="translated">32 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="d25a05e0ae959c82425e5422cb88b2cc0c3499b2" translate="yes" xml:space="preserve">
          <source>Read 64-bit int; offset in bytes.</source>
          <target state="translated">64 비트 int를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="5ff8b18e5826d1303bd5d1539c0e10e751fc2467" translate="yes" xml:space="preserve">
          <source>Read 64-bit integer; offset in 64-bit words.</source>
          <target state="translated">64 비트 정수를 읽습니다. 64 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="950cbae1770d68c7ff3f938a1bb875fcf874e61e" translate="yes" xml:space="preserve">
          <source>Read 64-bit word; offset in 64-bit words.</source>
          <target state="translated">64 비트 단어를 읽습니다. 64 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="403ce44704144796890a2dd162b7d4b6bd35606a" translate="yes" xml:space="preserve">
          <source>Read 64-bit word; offset in bytes.</source>
          <target state="translated">64 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="9bda208a006c005a311a9525872635ddcfb5a7e7" translate="yes" xml:space="preserve">
          <source>Read 8-bit character; offset in bytes.</source>
          <target state="translated">8 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="74ea30c59bd47b466db1dd2696f98867a27d8056" translate="yes" xml:space="preserve">
          <source>Read 8-bit integer; offset in bytes.</source>
          <target state="translated">8 비트 정수를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="66a3f6514090ac475eac95df9cd8e70ae4d2125d" translate="yes" xml:space="preserve">
          <source>Read 8-bit word; offset in bytes.</source>
          <target state="translated">8 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="52978387bdf57684002ff4fbf9d9b0b3152378e4" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (without sign) from byte-array in base-256 representation.</source>
          <target state="translated">기본 -256 표현의 바이트 배열에서 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (부호 없음)를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="128adcb084eec4344924afe5344cdb69c152d311" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (without sign) from memory location at &lt;code&gt;&lt;em&gt;addr&lt;/em&gt;&lt;/code&gt; in base-256 representation.</source>
          <target state="translated">기본 256 표현으로 &lt;code&gt;&lt;em&gt;addr&lt;/em&gt;&lt;/code&gt; 의 메모리 위치에서 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (부호 없음)를 읽습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc13cfab1d6d4894e1d0814d5699acd61f42785d" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; from a given file. If there is an error reading the file, the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultPrefs&quot;&gt;defaultPrefs&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 파일에서 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 를 읽습니다 . 파일을 읽는 동안 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultPrefs&quot;&gt;defaultPrefs&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e82d63ab81fecdb435939dcaf6fe495b71d99f5" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9ab54e44cbd0dec1e70996cdb4b7e93cc2071d0a" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b3e5b42103757d24b17f7c7998ff8f3f963bcd" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">&lt;code&gt;.tix&lt;/code&gt; 파일을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6d077a34945c77709ea02aa252897b606577a202" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 및 호스트 엔디안을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2b511be32215f170b894b91b783fc72e7c9eff82" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e270fdae5bb0b921134960c127b008cca47ba123" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="31eb10e403ca406961ff361d1965030257ca16fd" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 와 호스트 엔디안을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ed181842c2d246c2be3b1cafa56c033e14b6ade7" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="450296dc083818a06097a7554a45768d187ae2a3" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="fed4ac78abb685c542391281d20196e4c779e56d" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 직접 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc2ed709a624a8004bd6878cf10a70498433b5d" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 직접 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="41385428cb32efc10102354ba6b654e89a2182a7" translate="yes" xml:space="preserve">
          <source>Read a Word16 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word16 읽기</target>
        </trans-unit>
        <trans-unit id="c7059262c6e0dd247842136bc035dbe7fac3eb07" translate="yes" xml:space="preserve">
          <source>Read a Word16 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word16 읽기</target>
        </trans-unit>
        <trans-unit id="325ed0dff978da255c416ca5e04ee8469ca4aade" translate="yes" xml:space="preserve">
          <source>Read a Word32 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word32 읽기</target>
        </trans-unit>
        <trans-unit id="9b384ff4a6ad39dcdd029a9762666669ec5b057f" translate="yes" xml:space="preserve">
          <source>Read a Word32 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word32 읽기</target>
        </trans-unit>
        <trans-unit id="91270ca67d57bd1bdbeb755930779fcca71583f5" translate="yes" xml:space="preserve">
          <source>Read a Word64 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word64 읽기</target>
        </trans-unit>
        <trans-unit id="5d9a29132fd85c218ab3569276165a1ce2167da2" translate="yes" xml:space="preserve">
          <source>Read a Word64 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word64 읽기</target>
        </trans-unit>
        <trans-unit id="1dbaa4f5cf708506376d639753739c1d852b4bf9" translate="yes" xml:space="preserve">
          <source>Read a Word8 from the monad state</source>
          <target state="translated">모나드 상태에서 Word8 읽기</target>
        </trans-unit>
        <trans-unit id="33687198d0edb29afd53e4ee85d109db96503e2f" translate="yes" xml:space="preserve">
          <source>Read a character from the standard input device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 문자를 읽습니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b45a0fa5c6ee23b88df0d595555f79b07588df7b" translate="yes" xml:space="preserve">
          <source>Read a character from the standard input device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 문자를 읽습니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="0719ab4b706ee893ead8217fca15c3f09a2af0ce" translate="yes" xml:space="preserve">
          <source>Read a decimal integer. The input must begin with at least one decimal digit, and is consumed until a non-digit or end of string is reached.</source>
          <target state="translated">십진 정수를 읽습니다. 입력은 하나 이상의 10 진수로 시작해야하며, 숫자가 아니거나 문자열 끝에 도달 할 때까지 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="54e6d350ae56550c44862ac311a367be600fae92" translate="yes" xml:space="preserve">
          <source>Read a file and return its contents as a string. The file is read lazily, as with &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 읽고 그 내용을 문자열로 반환하십시오. &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 와 같이 파일을 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d91c0d58a076465748276893ce00cc9dcf0e0387" translate="yes" xml:space="preserve">
          <source>Read a handle's entire contents strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들의 전체 내용을 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 엄격히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ddde23fb0886b2069060468faf3bddb7c72b3d9d" translate="yes" xml:space="preserve">
          <source>Read a handle's entire contents strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들의 전체 내용을 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 엄격히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7439e315f02f450400e229e67923aa01c829dd88" translate="yes" xml:space="preserve">
          <source>Read a hexadecimal integer, consisting of an optional leading &lt;code&gt;&quot;0x&quot;&lt;/code&gt; followed by at least one hexadecimal digit. Input is consumed until a non-hex-digit or end of string is reached. This function is case insensitive.</source>
          <target state="translated">선택적인 선행 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 와 하나 이상의 16 진수 로 구성되는 16 진 정수를 읽습니다 . 16 진수가 아닌 숫자 또는 문자열 끝에 도달 할 때까지 입력이 소비됩니다. 이 기능은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d6ef962b6540180679caac9f11ba078a87836f5" translate="yes" xml:space="preserve">
          <source>Read a line from a handle</source>
          <target state="translated">핸들에서 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5f19303cec3e7c471d3d195797816309df8f8f1f" translate="yes" xml:space="preserve">
          <source>Read a line from stdin.</source>
          <target state="translated">stdin에서 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c0d47f6d713637753c2bcc367aaff8c0fce318ee" translate="yes" xml:space="preserve">
          <source>Read a line from the standard input device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 라인을 읽습니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="5743e14432024dc17ab0cc94bee7428d51f61dfb" translate="yes" xml:space="preserve">
          <source>Read a line from the standard input device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 라인을 읽습니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="01c713600966b0fbf993236e350a166e304141fa" translate="yes" xml:space="preserve">
          <source>Read a mix file.</source>
          <target state="translated">믹스 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="be8f10751cbc4efc5cde4e6e7e38e5094e226876" translate="yes" xml:space="preserve">
          <source>Read a rational number.</source>
          <target state="translated">유리수를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="73f99dea456cdd98d70103431dec12bab6720d82" translate="yes" xml:space="preserve">
          <source>Read a single chunk of strict text from a buffer. Used by both the strict and lazy implementations of hGetContents.</source>
          <target state="translated">버퍼에서 하나의 엄격한 텍스트 덩어리를 읽습니다. hGetContents의 엄격하고 지연된 구현 모두에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3128563cca70a9b1fe0217abc816e305e4d7489c" translate="yes" xml:space="preserve">
          <source>Read a single line from a handle.</source>
          <target state="translated">핸들에서 한 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="adf69306cc90a31c382146419718b352ccd6cad6" translate="yes" xml:space="preserve">
          <source>Read a single line of input from a handle, constructing a list of decoded chunks as we go. When we're done, transform them into the destination type.</source>
          <target state="translated">핸들에서 한 줄의 입력을 읽고 디코딩 된 청크 목록을 구성합니다. 완료되면 대상 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="25654588f3da8aeac6ef5d8db3b62a836c06fa32" translate="yes" xml:space="preserve">
          <source>Read a single line of user input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 한 줄의 사용자 입력을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="dfdfe120d485085e70e78fc48c39eb13447bb5f0" translate="yes" xml:space="preserve">
          <source>Read a specific file after the usual startup files. Maybe be specified repeatedly for multiple inputs.</source>
          <target state="translated">일반적인 시작 파일 후에 특정 파일을 읽습니다. 여러 입력에 대해 반복적으로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbdbb8f86925718238233077f610fe66a832424a" translate="yes" xml:space="preserve">
          <source>Read a string representation of a character, using Haskell source-language escape conventions, and convert it to the character that it encodes. For example:</source>
          <target state="translated">Haskell 소스 언어 이스케이프 규칙을 사용하여 문자의 문자열 표현을 읽고이를 인코딩하는 문자로 변환하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f45ab2992a7f92c89c2d67b45445d7594627e828" translate="yes" xml:space="preserve">
          <source>Read a string representation of a character, using Haskell source-language escape conventions. For example:</source>
          <target state="translated">Haskell 소스 언어 이스케이프 규칙을 사용하여 문자의 문자열 표현을 읽으십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59574f2898f4af82703bca7202a821293d4ffcc1" translate="yes" xml:space="preserve">
          <source>Read a value from a memory area regarded as an array of values of the same kind. The first argument specifies the start address of the array and the second the index into the array (the first element of the array has index &lt;code&gt;0&lt;/code&gt;). The following equality holds,</source>
          <target state="translated">동일한 종류의 값 배열로 간주되는 메모리 영역에서 값을 읽습니다. 첫 번째 인수는 배열의 시작 주소를 지정하고 두 번째 인수는 배열의 색인을 지정합니다 (배열의 첫 번째 요소는 색인 &lt;code&gt;0&lt;/code&gt; ). 다음과 같은 평등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02dae23f91c992be0064ed7d86e41766eb8e894" translate="yes" xml:space="preserve">
          <source>Read a value from a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">기본 주소 및 오프셋으로 지정된 메모리 위치에서 값을 읽습니다. 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b0aa0bd28f22ee1301ca31df70c736ff3ee306" translate="yes" xml:space="preserve">
          <source>Read a value from an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 에서 값 읽기</target>
        </trans-unit>
        <trans-unit id="4d64cf50eadebd9d63f648489fffc060e93dade0" translate="yes" xml:space="preserve">
          <source>Read a value from the given memory location.</source>
          <target state="translated">주어진 메모리 위치에서 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c895abdcb0525ce203fd7be7a0c13f00f62176b5" translate="yes" xml:space="preserve">
          <source>Read a value in either extended or basic format</source>
          <target state="translated">확장 또는 기본 형식으로 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f6e13344b410105e46fe8c0c3bb31ba832250e46" translate="yes" xml:space="preserve">
          <source>Read a value in the format</source>
          <target state="translated">형식으로 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="dd0b7cb834d846fc1947e62e526ff39953f44c07" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of immutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">변경 불가능한 스칼라 배열의 지정된 인덱스에서 벡터를 읽습니다. 오프셋은 스칼라 요소입니다.</target>
        </trans-unit>
        <trans-unit id="f79c6c6b83c77de14c0bf3ded60c02c747a26da6" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of immutable array.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 벡터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5615bbd35bd929521c39374f2e2a2232ced11f9c" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">스칼라의 가변 배열의 지정된 인덱스에서 벡터를 읽습니다. 오프셋은 스칼라 요소입니다.</target>
        </trans-unit>
        <trans-unit id="4e9fe50a296114dc2b02bd5ca2a79c2f895b774b" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of mutable array.</source>
          <target state="translated">가변 배열의 지정된 인덱스에서 벡터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a7742b39ce7421c6d47b0effa4450918bdd45632" translate="yes" xml:space="preserve">
          <source>Read additional &lt;code&gt;.ghci&lt;/code&gt; files</source>
          <target state="translated">추가 &lt;code&gt;.ghci&lt;/code&gt; 파일 읽기</target>
        </trans-unit>
        <trans-unit id="d233243d198088b2c0450f8380c909a760fb25ad" translate="yes" xml:space="preserve">
          <source>Read address; offset in bytes.</source>
          <target state="translated">읽기 주소; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="3197b5d5666bc282a5115cbbd8185c4015503c26" translate="yes" xml:space="preserve">
          <source>Read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4df9c1fd5f4c008b55e24b1254682c338fd5c8b5" translate="yes" xml:space="preserve">
          <source>Read an Int16 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int16을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6f267e0ba7feb196316db561014fb8a100f37edc" translate="yes" xml:space="preserve">
          <source>Read an Int16 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int16을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="92b6e9e32f49c87b97a18f7e91eae119f1d1535e" translate="yes" xml:space="preserve">
          <source>Read an Int32 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int32를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="295f966253d453f4fa2a13a40bcdb60b3120732b" translate="yes" xml:space="preserve">
          <source>Read an Int32 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int32를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2a4319e745da1df1fb9ab6def619894697620e21" translate="yes" xml:space="preserve">
          <source>Read an Int64 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int64를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7bff0912bbb59ea521663a0f1057dd5874ce2fbf" translate="yes" xml:space="preserve">
          <source>Read an Int64 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int64를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9d00ac172a382dbde434bc4bef4d834e10046dba" translate="yes" xml:space="preserve">
          <source>Read an Int8 from the monad state</source>
          <target state="translated">모나드 상태에서 Int8 읽기</target>
        </trans-unit>
        <trans-unit id="29b4fc30960f16d120ae6224ddf706485760e8de" translate="yes" xml:space="preserve">
          <source>Read an element from a mutable array</source>
          <target state="translated">가변 배열에서 요소 읽기</target>
        </trans-unit>
        <trans-unit id="184940591a216fa9ea649f7763278eb44f8d0931" translate="yes" xml:space="preserve">
          <source>Read an entire file &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The Handle will be held open until EOF is encountered.</source>
          <target state="translated">전체 파일을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . EOF에 도달 할 때까지 핸들이 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="03f1e6feeff9a1725dd05ae88ec08afc7c1d72b9" translate="yes" xml:space="preserve">
          <source>Read an entire file &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The Handle will be held open until EOF is encountered.</source>
          <target state="translated">전체 파일을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . EOF에 도달 할 때까지 핸들이 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60570cd035ce237ccf2437d4bfb920a02e53853c" translate="yes" xml:space="preserve">
          <source>Read an entire file strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 파일을 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 완전히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="001be63528cff4e4b1bbe0b696c612c20323c3ab" translate="yes" xml:space="preserve">
          <source>Read an entire file strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 파일을 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 완전히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="cf17dfd1f6fadf4d500465addd8a6f58eeb87931" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we fail to parse an integer, we want to return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ab42205d653354d10c40dc2129358edaf0340a6a" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we fail to parse an integer, we want to return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8b7be0938cfa7ae7ce0d40e3b9c4c39227699e7a" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we succeed, return twice the integer; that is, apply &lt;code&gt;(*2)&lt;/code&gt; to it. If instead we fail to parse an integer, return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 성공하면 정수의 두 배를 반환합니다. 즉, &lt;code&gt;(*2)&lt;/code&gt; 를 적용 하십시오. 대신 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0e1b310d39697280b0ca5896c55c8f8ddd9e208" translate="yes" xml:space="preserve">
          <source>Read an optional leading sign character (&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'+'&lt;/code&gt;) and apply it to the result of applying the given reader.</source>
          <target state="translated">선택적인 선행 부호 문자 ( &lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'+'&lt;/code&gt; )를 읽고 주어진 리더를 적용한 결과에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="de974586f48684c65e0aed99e88a68bca9babb04" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in decimal notation.</source>
          <target state="translated">부호없는 숫자를 10 진수 표기법으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="edd8a422da79ea12a97bd88bd774c6fa6d5e779c" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in hexadecimal notation. Both upper or lower case letters are allowed.</source>
          <target state="translated">부호없는 숫자를 16 진수 표기법으로 읽으십시오. 대문자 또는 소문자 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5feb144c8f7999d7fc0752e59f4bdec2cd116666" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in octal notation.</source>
          <target state="translated">8 진수 표기법으로 부호없는 숫자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6ad141bb083704baa04592db003358950eddce08" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;MutVar#&lt;/code&gt;. Result is not yet evaluated.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 내용을 읽습니다 . 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="44f0e5c6fc9d1c23f9c6ed2b599b6b8d8e417ef0" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;TVar#&lt;/code&gt; outside an STM transaction</source>
          <target state="translated">STM 트랜잭션 외부에서 &lt;code&gt;TVar#&lt;/code&gt; 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5ff6ad28f98052f9fcd898c2d97970160ba11e64" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;TVar#&lt;/code&gt;. Result is not yet evaluated.</source>
          <target state="translated">&lt;code&gt;TVar#&lt;/code&gt; 내용을 읽으십시오 . 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3603a43d62483fa4679d6af07c238488c46786c9" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; and convert it to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using the locale encoding. Throws an exception if this is an invalid descriptor, or EOF has been reached.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽고 로케일 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 변환하십시오 . 디스크립터가 유효하지 않거나 EOF에 도달하면 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="43ab7f0c4f47fef128b100ea328372f14b6a3498" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; into memory. This is exactly equivalent to the POSIX &lt;code&gt;read&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 메모리로 데이터를 읽 습니다. 이것은 POSIX &lt;code&gt;read&lt;/code&gt; 기능 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f5bf8684c269a4820abae27741f614d296efe4c4" translate="yes" xml:space="preserve">
          <source>Read double; offset in bytes.</source>
          <target state="translated">이중 읽기; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="b0cca27f8a9fdef6889ea37c66301c876cab8ce6" translate="yes" xml:space="preserve">
          <source>Read entire handle contents &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Chunks are read on demand, using the default chunk size.</source>
          <target state="translated">전체 핸들 내용을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 청크는 기본 청크 크기를 사용하여 요청시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="101b8e34a22629aafaa1a8c5025821cec283fe82" translate="yes" xml:space="preserve">
          <source>Read entire handle contents &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Chunks are read on demand, using the default chunk size.</source>
          <target state="translated">전체 핸들 내용을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 청크는 기본 청크 크기를 사용하여 요청시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e54160b8e25354935fce10255c3e4543c690a8d3" translate="yes" xml:space="preserve">
          <source>Read float; offset in bytes.</source>
          <target state="translated">플로트를 읽습니다; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="db90f20fdb5334fdb03e7dc9053d0abf64c43f74" translate="yes" xml:space="preserve">
          <source>Read from specified index of immutable array. Result is packaged into an unboxed singleton; the result itself is not yet evaluated.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 읽습니다. 결과는 박스형 싱글 톤으로 패키지됩니다. 결과 자체는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0200070728a5fb343af81ee6afd180f318933176" translate="yes" xml:space="preserve">
          <source>Read from specified index of mutable array. Result is not yet evaluated.</source>
          <target state="translated">가변 배열의 지정된 인덱스에서 읽습니다. 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d1a39c4b6ea4cc164485bd240d4bd6cf1570e05c" translate="yes" xml:space="preserve">
          <source>Read from the specified index of an immutable array. The result is packaged into an unboxed unary tuple; the result itself is not yet evaluated. Pattern matching on the tuple forces the indexing of the array to happen but does not evaluate the element itself. Evaluating the thunk prevents additional thunks from building up on the heap. Avoiding these thunks, in turn, reduces references to the argument array, allowing it to be garbage collected more promptly.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 읽습니다. 결과는 박스형 단항 튜플에 패키지됩니다. 결과 자체는 아직 평가되지 않았습니다. 튜플의 패턴 일치는 배열의 색인 생성을 강제하지만 요소 자체는 평가하지 않습니다. 썽크를 평가하면 추가 썽크가 힙에 쌓이지 않습니다. 이러한 썽크를 피하면 인수 배열에 대한 참조가 줄어들어보다 신속하게 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36061d225788479538ce96083566a66df2c49724" translate="yes" xml:space="preserve">
          <source>Read input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;. Use terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), use file-style interaction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 터미널에 연결되어 있고 에코가 활성화 된 경우 터미널 스타일 상호 작용을 사용하십시오 . 그렇지 않으면 (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 파이프 인 경우) 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e2b87177b15201771ca07ee6fd67e9a5fc97ac6f" translate="yes" xml:space="preserve">
          <source>Read int; offset in bytes.</source>
          <target state="translated">int를 읽으십시오; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="509993ef463c0c211358fd0c0596577266fe2fb7" translate="yes" xml:space="preserve">
          <source>Read integer; offset in words.</source>
          <target state="translated">정수 읽기; 단어의 오프셋.</target>
        </trans-unit>
        <trans-unit id="e9087047c795daa1de0e7dba3f7e080b494418f8" translate="yes" xml:space="preserve">
          <source>Read some text. If the read succeeds, return its value and the remaining text, otherwise an error message.</source>
          <target state="translated">텍스트를 읽으십시오. 읽기에 성공하면 해당 값과 나머지 텍스트를 반환하고, 그렇지 않으면 오류 메시지를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="385971a1139a0bdb98d1292763e2b5ce86ca29ce" translate="yes" xml:space="preserve">
          <source>Read stable pointer; offset in bytes.</source>
          <target state="translated">안정적인 포인터를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="3fc7f5e6a842e6c7c7f4d5cd93c243638c0a22c7" translate="yes" xml:space="preserve">
          <source>Read the interface in ⟨file⟩ and dump it as text to &lt;code&gt;stdout&lt;/code&gt;. For example &lt;code&gt;ghc --show-iface M.hi&lt;/code&gt;.</source>
          <target state="translated">⟨file⟩의 인터페이스를 읽고 &lt;code&gt;stdout&lt;/code&gt; 에 텍스트로 덤프하십시오 . 예를 들어 &lt;code&gt;ghc --show-iface M.hi&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35fd8313e4529e013617beaafbd192823c6b704e" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;. Blocks when the channel is empty. Since the read end of a channel is an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, this operation inherits fairness guarantees of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s (e.g. threads blocked in this operation are woken up in FIFO order).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 . 채널이 비어있을 때 차단합니다. 채널의 읽기 끝 이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이므로이 작업은 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 공정성을 보장합니다 (예 :이 작업에서 차단 된 스레드는 FIFO 순서 로 깨어남 ).</target>
        </trans-unit>
        <trans-unit id="a3f42dd07bf605d27f73449bde07c7d88dd5a27e" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="219b4ebe09d71aecd989470d5600adac017a8f74" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0e07d0d1882240686a99adef17b39a619c1bef0f" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e007f69e1d890c7d542d9833535fb4b6a263ffd6" translate="yes" xml:space="preserve">
          <source>Read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; as a string. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 문자열로 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 내용을 읽은 후 폐쇄, 또는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85f565788b2b9a2c3728b76cecd24c45e236a991" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="e7780aaaf7afd886eedb902ae89adf47399d57fc" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="e675dd344452e999c38ed03687aca33c72e023cd" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="8e716a6f85aeaaaa890a3308400401bdff5d70c0" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="01bf80e08c343263e4bb151f8cf9ca8018bbad19" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="048e888435023fe10ac7481eb2d18a6767a2ae0e" translate="yes" xml:space="preserve">
          <source>Read up to the specified number of bytes, returning the number of bytes actually read, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the end of the stream has been reached.</source>
          <target state="translated">지정된 바이트 수까지 읽은 다음 실제로 읽은 바이트 수를 반환하거나 스트림 끝에 도달하면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ddb4092dc0454475d79a2caf656b95780da4b95" translate="yes" xml:space="preserve">
          <source>Read up to the specified number of bytes, returning the number of bytes actually read. This function should only block if there is no data available. If there is not enough data available, then the function should just return the available data. A return value of zero indicates that the end of the data stream (e.g. end of file) has been reached.</source>
          <target state="translated">지정된 바이트 수까지 읽고 실제로 읽은 바이트 수를 반환합니다. 이 기능은 사용 가능한 데이터가없는 경우에만 차단해야합니다. 사용 가능한 데이터가 충분하지 않으면 함수는 사용 가능한 데이터 만 반환해야합니다. 리턴 값이 0이면 데이터 스트림의 끝 (예 : 파일의 끝)에 도달했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29b7483916a09f80924395ee0d7b83ba6ab96615" translate="yes" xml:space="preserve">
          <source>Read word; offset in bytes.</source>
          <target state="translated">단어를 읽고; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="e12038f525002402b577d6fb2889e55cff2dfbae" translate="yes" xml:space="preserve">
          <source>Read word; offset in words.</source>
          <target state="translated">단어를 읽고; 단어의 오프셋.</target>
        </trans-unit>
        <trans-unit id="1b9d7709bfb533d78fbe0b84eb0c51db68ac6e05" translate="yes" xml:space="preserve">
          <source>Read1</source>
          <target state="translated">Read1</target>
        </trans-unit>
        <trans-unit id="81d8932de84f99268c4fd5f11aa697682044fa60" translate="yes" xml:space="preserve">
          <source>Read2</source>
          <target state="translated">Read2</target>
        </trans-unit>
        <trans-unit id="f1e077638634abc3662a6f0c89d3f406f31baa23" translate="yes" xml:space="preserve">
          <source>ReadBuffer</source>
          <target state="translated">ReadBuffer</target>
        </trans-unit>
        <trans-unit id="c5020e6d3d649435fd6a8008235ac63730a66a73" translate="yes" xml:space="preserve">
          <source>ReadEnable</source>
          <target state="translated">ReadEnable</target>
        </trans-unit>
        <trans-unit id="6de7f0656dc34507427ddc07a973f98f0bcc41df" translate="yes" xml:space="preserve">
          <source>ReadHandle</source>
          <target state="translated">ReadHandle</target>
        </trans-unit>
        <trans-unit id="54556afe3251c3e593a21d925fcc337a1e508750" translate="yes" xml:space="preserve">
          <source>ReadLock</source>
          <target state="translated">ReadLock</target>
        </trans-unit>
        <trans-unit id="c2f37f72692c3515483dfa8baf2cb80b52368faa" translate="yes" xml:space="preserve">
          <source>ReadMode</source>
          <target state="translated">ReadMode</target>
        </trans-unit>
        <trans-unit id="35b71d2407f50e29058b6e84ccdbdda494394136" translate="yes" xml:space="preserve">
          <source>ReadOnly</source>
          <target state="translated">ReadOnly</target>
        </trans-unit>
        <trans-unit id="46689621a240954e944093b728ea402ca810f9e1" translate="yes" xml:space="preserve">
          <source>ReadP</source>
          <target state="translated">ReadP</target>
        </trans-unit>
        <trans-unit id="4b68042bf88ac33a1e40bfc7d7f822fcd7009e90" translate="yes" xml:space="preserve">
          <source>ReadPrec</source>
          <target state="translated">ReadPrec</target>
        </trans-unit>
        <trans-unit id="9fe9c76a65059b5111bfa003358795f86d10951b" translate="yes" xml:space="preserve">
          <source>ReadS</source>
          <target state="translated">ReadS</target>
        </trans-unit>
        <trans-unit id="934e6375acc87422b86cc2cd6088641368f302ce" translate="yes" xml:space="preserve">
          <source>ReadWrite</source>
          <target state="translated">ReadWrite</target>
        </trans-unit>
        <trans-unit id="9b64792077a2e304ad52b88e180478893f260952" translate="yes" xml:space="preserve">
          <source>ReadWriteHandle</source>
          <target state="translated">ReadWriteHandle</target>
        </trans-unit>
        <trans-unit id="52f3ccd214d97eb22352b89cf6fab70f198121a0" translate="yes" xml:space="preserve">
          <source>ReadWriteMode</source>
          <target state="translated">ReadWriteMode</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="c63a28bc751310feb69d6d85675c8d7417374a2f" translate="yes" xml:space="preserve">
          <source>Reader operations</source>
          <target state="translated">리더 조작</target>
        </trans-unit>
        <trans-unit id="c6a6be791f6f7604b9585f870722f3f322f53e43" translate="yes" xml:space="preserve">
          <source>ReaderT</source>
          <target state="translated">ReaderT</target>
        </trans-unit>
        <trans-unit id="cffa2af0a3a67cf2123e3411d020161abc01fc05" translate="yes" xml:space="preserve">
          <source>Reading</source>
          <target state="translated">Reading</target>
        </trans-unit>
        <trans-unit id="c422c2c68b42e2bd58fbc1703fc83cd895932253" translate="yes" xml:space="preserve">
          <source>Reading a &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; value is always a parse error, considering &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; as a data type with no constructors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 값을 읽는 것은 생성자가없는 데이터 유형으로 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 를 고려할 때 항상 구문 분석 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f06f44f189a8a36daa4efe052b72e715b174b17d" translate="yes" xml:space="preserve">
          <source>Reading a &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; value is always a parse error, considering &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; as a data type with no constructors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 값을 읽는 것은 생성자가없는 데이터 유형으로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 를 고려할 때 항상 구문 분석 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="ceb93f69e25dd4f67fafd5c0c9bcf1b6c00353d6" translate="yes" xml:space="preserve">
          <source>Reading and writing</source>
          <target state="translated">읽고 쓰기</target>
        </trans-unit>
        <trans-unit id="4f18826bef9dfdb927570ae8ab6b9bec70524276" translate="yes" xml:space="preserve">
          <source>Reading and writing mutable arrays</source>
          <target state="translated">가변 배열 읽기 및 쓰기</target>
        </trans-unit>
        <trans-unit id="365b9ae589656ef49d750dc632c6d31ceb0c5361" translate="yes" xml:space="preserve">
          <source>Reading directories</source>
          <target state="translated">디렉토리 읽기</target>
        </trans-unit>
        <trans-unit id="96b64527dbce354910bf9627caf09e2a6cfc34cf" translate="yes" xml:space="preserve">
          <source>Reading from ByteStrings</source>
          <target state="translated">바이트 열에서 읽기</target>
        </trans-unit>
        <trans-unit id="e253f6b863facf4d77e612851b75f8717edbc34a" translate="yes" xml:space="preserve">
          <source>Reading user input</source>
          <target state="translated">사용자 입력 읽기</target>
        </trans-unit>
        <trans-unit id="6a32d6ca2eb1805847b13bc731bea17f663fa696" translate="yes" xml:space="preserve">
          <source>Reading/writing data</source>
          <target state="translated">데이터 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="c80f1cd51e818f0a4c3a4b8c5cf43e874d958e5a" translate="yes" xml:space="preserve">
          <source>Reads 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 비트 문자를 읽습니다. 4 바이트 단어로 오프셋합니다.</target>
        </trans-unit>
        <trans-unit id="921dc7c293431a3a64c3ded33915a5aa38ae62af" translate="yes" xml:space="preserve">
          <source>Reads 8-bit character; offset in bytes.</source>
          <target state="translated">8 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="a5b991e4a4379bd9b80c3767927105724a0875a1" translate="yes" xml:space="preserve">
          <source>Reads a &lt;em&gt;signed&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; value, given a reader for an unsigned value.</source>
          <target state="translated">부호없는 값에 대한 독자에게 주어진 &lt;em&gt;부호있는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="1fd583060d47ecdc99e4f5f0f86aaa58223cfd92" translate="yes" xml:space="preserve">
          <source>Reads a non-empty string of decimal digits.</source>
          <target state="translated">비어 있지 않은 10 진수 문자열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cbbbba4aaf9680cf8ac1a308bdb53817ab019a45" translate="yes" xml:space="preserve">
          <source>Reads a number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; directly into an array.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 여러 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 배열로 직접 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f07300e7dd09099ac84ef4f53f7fd7ce2c8ce883" translate="yes" xml:space="preserve">
          <source>Reads a package specification from ⟨file⟩ (which may be &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; to indicate standard input), and adds it to the database of installed packages. The syntax of ⟨file⟩ is given in &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: a package specification&lt;/a&gt;.</source>
          <target state="translated">⟨file⟩ ( 표준 입력을 나타 내기 위해 &amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo; 일 수 있음)에서 패키지 사양을 읽고 설치된 패키지의 데이터베이스에 추가합니다. ⟨file⟩의 구문은 &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo : package specification에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e64b7710b0f793ca4a73b1986230bc60e374cb" translate="yes" xml:space="preserve">
          <source>Reads an &lt;em&gt;unsigned&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value in an arbitrary base.</source>
          <target state="translated">임의의 기준으로 &lt;em&gt;부호없는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="df34a2a58d81dcca7a482cd5956785905a568c3f" translate="yes" xml:space="preserve">
          <source>Reads an &lt;em&gt;unsigned&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; value, expressed in decimal scientific notation.</source>
          <target state="translated">십진 과학 표기법으로 표현 된 &lt;em&gt;부호없는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ab426f1eb57de3cd53ffe87e3b87e21c773c64b0" translate="yes" xml:space="preserve">
          <source>Reads one character of input. Ignores non-printable characters.</source>
          <target state="translated">하나의 입력 문자를 읽습니다. 인쇄 할 수없는 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="8db8c0a51e77d5b8ce47a692479eb60e9ad3c1d1" translate="yes" xml:space="preserve">
          <source>Reads one line of input and fills the insertion space with initial text. When using terminal-style interaction, this function provides a rich line-editing user interface with the added ability to give the user default values.</source>
          <target state="translated">한 줄의 입력을 읽고 초기 텍스트로 삽입 공간을 채 웁니다. 터미널 스타일 상호 작용을 사용할 때이 기능은 풍부한 기본값을 제공하는 기능이 추가 된 풍부한 라인 편집 사용자 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33401a6d6df492bf1a176a021ff28fb4ff727341" translate="yes" xml:space="preserve">
          <source>Reads one line of input, without displaying the input while it is being typed. When using terminal-style interaction, the masking character (if given) will replace each typed character.</source>
          <target state="translated">입력하는 동안 입력을 표시하지 않고 한 줄의 입력을 읽습니다. 터미널 스타일의 상호 작용을 사용하는 경우 마스킹 문자 (제공된 경우)가 각 입력 된 문자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5e14c26e4702c8715ffc36b86faf8dd417b0a61b" translate="yes" xml:space="preserve">
          <source>Reads one line of input. The final newline (if any) is removed. When using terminal-style interaction, this function provides a rich line-editing user interface.</source>
          <target state="translated">한 줄의 입력을 읽습니다. 마지막 개행 (있는 경우)이 제거됩니다. 터미널 스타일 상호 작용을 사용할 때이 기능은 풍부한 라인 편집 사용자 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2fcf3b55305c70b8c82f22537db6b19a7a199aa5" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;FilePath&lt;/code&gt; pointed to by the symbolic link and returns it.</source>
          <target state="translated">심볼릭 링크가 가리키는 &lt;code&gt;FilePath&lt;/code&gt; 를 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b52ed1233e0f5b938bb0cd5a498ea44aaf2572ed" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;RawFilePath&lt;/code&gt; pointed to by the symbolic link and returns it.</source>
          <target state="translated">심볼릭 링크가 가리키는 &lt;code&gt;RawFilePath&lt;/code&gt; 를 읽고 이를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
