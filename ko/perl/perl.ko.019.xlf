<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="670b1ddc67f6054d3b05d014236af978c695794a" translate="yes" xml:space="preserve">
          <source>Additionally,</source>
          <target state="translated">Additionally,</target>
        </trans-unit>
        <trans-unit id="d13e57a8614451ac86ee80ef497567c6c1217ddd" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;reg()&lt;/code&gt; is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to &lt;code&gt;regbranch()&lt;/code&gt; , which is responsible for handling up to the first &lt;code&gt;|&lt;/code&gt; symbol it sees.</source>
          <target state="translated">또한 &lt;code&gt;reg()&lt;/code&gt; 는 패턴에서 하나 이상의 분기를 구문 분석하고 다음 포인터를 올바르게 설정하여 &quot;종료&quot;하는 역할을합니다. 구문 분석을 수행하기 위해 &lt;code&gt;regbranch()&lt;/code&gt; 를 반복적으로 호출합니다. regbranch () 는 첫 번째 &lt;code&gt;|&lt;/code&gt; 그것이 보이는 상징.</target>
        </trans-unit>
        <trans-unit id="e0e807bcf6cc2e8c544c361c110388bef7a27722" translate="yes" xml:space="preserve">
          <source>Additionally, extra colons can be used to control formatting. A trailing colon suppresses the linefeed and terminator &quot;;&quot;, allowing you to embed queries into shell commands. (mnemonic: PATH separator &quot;:&quot;.)</source>
          <target state="translated">또한 추가 콜론을 사용하여 서식을 제어 할 수 있습니다. 후행 콜론은 줄 바꿈 및 종결 자 &quot;;&quot;를 억제하여 쿼리를 쉘 명령에 포함시킬 수 있습니다. (니모닉 : PATH separator &quot;:&quot;)</target>
        </trans-unit>
        <trans-unit id="e495cf9a286350e9c50957cc8351f8f292fd0e8c" translate="yes" xml:space="preserve">
          <source>Additionally, if the &lt;code&gt;h_errno&lt;/code&gt; variable is supported in C, its value is returned via &lt;code&gt;$?&lt;/code&gt; if any &lt;code&gt;gethost*()&lt;/code&gt; function fails.</source>
          <target state="translated">또한 &lt;code&gt;h_errno&lt;/code&gt; 변수가 C에서 지원되면 &lt;code&gt;$?&lt;/code&gt; 를 통해 값이 반환됩니다 . 어떤 경우 &lt;code&gt;gethost*()&lt;/code&gt; 함수가 실패.</target>
        </trans-unit>
        <trans-unit id="f146d2cdc65cbc8a75b0db4de74950e484d62ea3" translate="yes" xml:space="preserve">
          <source>Additionally, if the identifier is preceded by a sigil -- that is, if the identifier is part of a variable name -- it may optionally be enclosed in braces.</source>
          <target state="translated">또한 식별자 앞에시길이있을 경우 (즉, 식별자가 변수 이름의 일부인 경우) 선택적으로 중괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9aa35376d4ff22f823726940db699aadebfdc8" translate="yes" xml:space="preserve">
          <source>Additionally, implementations of the standard &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam() and tmpfile() functions are provided if required.</source>
          <target state="translated">또한 필요한 경우 표준 &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; tmpnam () 및 tmpfile () 함수의 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ec069a599a9fe7b608d8c7621218dba9e34959bc" translate="yes" xml:space="preserve">
          <source>Additionally, it will create META.yml and META.json module meta-data file in the distdir and add this to the distdir's MANIFEST. You can shut this behavior off with the NO_META flag.</source>
          <target state="translated">또한 distdir에 META.yml 및 META.json 모듈 메타 데이터 파일을 작성하여 distdir의 MANIFEST에 추가합니다. NO_META 플래그를 사용하여이 동작을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdcb47de4e9258bc110d7122692a049db6fbb22a" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows NT not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">또한 Windows NT에서 stat ()에 의해 리턴되는 모든 필드를 비교할 수있는 것은 아닙니다. 예를 들어 C</target>
        </trans-unit>
        <trans-unit id="51fffd62248577e35b4f056a4c962f40c15d81d6" translate="yes" xml:space="preserve">
          <source>Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;, and the like are not supported in place of &lt;code&gt;''&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , and the only interpolation is for backslashing the quoting character:</source>
          <target state="translated">또한 문자열 끝 식별자에 대한 인용 규칙은 Perl의 인용 규칙과 관련이 없습니다. &lt;code&gt;''&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; 등은 지원되지 않으며 인용 문자 만 백 슬래시하기위한 유일한 보간입니다.</target>
        </trans-unit>
        <trans-unit id="60224bb897c08e69d3d354606005d24af0b374cd" translate="yes" xml:space="preserve">
          <source>Additionally, the following still works:</source>
          <target state="translated">또한 다음은 여전히 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="03aa6ebb82309c10827e49e960c12581e1baf1dc" translate="yes" xml:space="preserve">
          <source>Additionally, the type of each element is determined from the type of the array. If the array uses type &lt;code&gt;intArray *&lt;/code&gt; xsubpp will automatically work out that it contains variables of type &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and use that typemap entry to perform the copy of each element. All pointer '*' and 'Array' tags are removed from the name to determine the subtype.</source>
          <target state="translated">또한 각 요소의 유형은 배열 유형에서 결정됩니다. 배열이 &lt;code&gt;intArray *&lt;/code&gt; 유형을 사용하는 경우 xsubpp는 자동으로 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형의 변수를 포함하고 해당 유형 맵 항목을 사용하여 각 요소의 복사를 수행합니다. 하위 유형을 결정하기 위해 모든 포인터 '*'및 'Array'태그가 이름에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8c86e3562fdf5c9d82a5e93b3d4cafa347de77" translate="yes" xml:space="preserve">
          <source>Additionally, unless the &lt;code&gt;safe&lt;/code&gt; parameter is set (or the third parameter in the traditional interface is TRUE), should a &lt;code&gt;remove_tree&lt;/code&gt; be interrupted, files that were originally in read-only mode may now have their permissions set to a read-write (or &quot;delete OK&quot;) mode.</source>
          <target state="translated">또한 &lt;code&gt;safe&lt;/code&gt; 매개 변수가 설정 되지 않은 경우 (또는 기존 인터페이스의 세 번째 매개 변수가 TRUE 인 경우) &lt;code&gt;remove_tree&lt;/code&gt; 가 중단되면 원래 읽기 전용 모드 인 파일의 권한이 읽기 / 쓰기로 설정 될 수 있습니다 (또는 &quot; 삭제 OK &quot;) 모드로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="ec0f027d3baa565712bd5dc0ad0e80af4eb514d9" translate="yes" xml:space="preserve">
          <source>Additionally, you can enable and disable categories of warnings. You turn off the categories you want to ignore and you can still get other categories of warnings. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for the complete details, including the category names and hierarchy.</source>
          <target state="translated">또한 경고 범주를 활성화 및 비활성화 할 수 있습니다. 무시하려는 카테고리를 끄고 다른 카테고리의 경고를 계속받을 수 있습니다. 카테고리 이름 및 계층 구조를 포함한 전체 세부 사항 은 &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f10369c70dcbc4071416e4238c5876b81c9796c" translate="yes" xml:space="preserve">
          <source>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</source>
          <target state="translated">또한 자동 업그레이드 및 자동 다운 그레이드가 올바르게 작동하도록 다음 두 전역을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0595fe59d92f01dd8f2cab1ee0be7afe3d67ccd0" translate="yes" xml:space="preserve">
          <source>Additionaly, on Solaris 8 and 9 you also need:</source>
          <target state="translated">또한 Solaris 8 및 9에서도 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bf73559c41806dc25286227ff308976c154c29de" translate="yes" xml:space="preserve">
          <source>Additive Operators</source>
          <target state="translated">부가 연산자</target>
        </trans-unit>
        <trans-unit id="15668d6e15430dae7c65fa496b4f2aa5393ff6b7" translate="yes" xml:space="preserve">
          <source>Address family constants used by the socket address structures, to pass to such functions as inet_pton() or getaddrinfo(), or are returned by such functions as sockaddr_family().</source>
          <target state="translated">소켓 주소 구조에 의해 사용되거나 inet_pton () 또는 getaddrinfo ()와 같은 함수에 전달되거나 sockaddr_family ()와 같은 함수에 의해 리턴되는 주소 계열 상수.</target>
        </trans-unit>
        <trans-unit id="398491e08f855e6e51bbd01773f98e6f34b68ef0" translate="yes" xml:space="preserve">
          <source>Address to send copy of report to. Defaults to the address of the local perl administrator (recorded when perl was built).</source>
          <target state="translated">보고서 사본을 보낼 주소입니다. 로컬 perl 관리자의 주소가 기본값입니다 (perl이 빌드 될 때 기록됨).</target>
        </trans-unit>
        <trans-unit id="866089dee6e89f6a5b436348a98fb9411f98472d" translate="yes" xml:space="preserve">
          <source>Address to send the report to. Defaults to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">보고서를 보낼 주소입니다. 기본값은 &lt;b&gt;perlbug@perl.org&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b59857dd57932d5d50e4861a06a2080338435ed" translate="yes" xml:space="preserve">
          <source>Address-of operator. (But see the &lt;code&gt;&quot;\&quot;&lt;/code&gt; operator for taking a reference.)</source>
          <target state="translated">주소 연산자. (하지만 참조를 위해 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 연산자를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="875b1b8e40002002efb28f1a8fa46b6af7e34564" translate="yes" xml:space="preserve">
          <source>AddressSanitizer</source>
          <target state="translated">AddressSanitizer</target>
        </trans-unit>
        <trans-unit id="97d2869e530035313b88d71ffdc660bf28a9cf95" translate="yes" xml:space="preserve">
          <source>AddressSanitizer is a clang and gcc extension, included in clang since v3.1 and gcc since v4.8. It checks illegal heap pointers, global pointers, stack pointers and use after free errors, and is fast enough that you can easily compile your debugging or optimized perl with it. It does not check memory leaks though. AddressSanitizer is available for Linux, Mac OS X and soon on Windows.</source>
          <target state="translated">AddressSanitizer는 v3.1 이후 clang 및 v4.8 이후 gcc에 포함 된 clang 및 gcc 확장입니다. 불법 힙 포인터, 전역 포인터, 스택 포인터를 확인하고 빈 오류 발생 후 사용하며 디버깅 또는 최적화 된 펄을 쉽게 컴파일 할 수있을 정도로 빠릅니다. 메모리 누수는 확인하지 않습니다. AddressSanitizer는 Linux, Mac OS X 및 Windows에서 곧 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="975fc2f37ec74ac4dc4429c1af7095af2a49e10a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;#line&lt;/code&gt; directives to the C output so error messages will look like they came from the original XS file. Default is true.</source>
          <target state="translated">오류 메시지가 원래 XS 파일에서 온 것처럼 보이도록 &lt;code&gt;#line&lt;/code&gt; 지시문을 C 출력에 추가합니다 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="14f679936dccdbe9d754f57ef3015e396a6c5718" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; to the C code. Default is false.</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 를 C 코드에 추가합니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9fbaf45d7bbf38840f610cf2fa4335deddb3f4a7" translate="yes" xml:space="preserve">
          <source>Adds a list of items onto the end of the queue.</source>
          <target state="translated">대기열 끝에 항목 목록을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="973f265e0df96f52e35c5a95591ee9281a6a4277" translate="yes" xml:space="preserve">
          <source>Adds a name to a stash's internal list of effective names. See &lt;code&gt;hv_ename_delete&lt;/code&gt; .</source>
          <target state="translated">숨김의 유효 이름 목록에 이름을 추가합니다. &lt;code&gt;hv_ename_delete&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e689b98670881df4701aa3dac263f404709c80f2" translate="yes" xml:space="preserve">
          <source>Adds an action (Perl command) to happen after the prompt when you've just given a command to return to executing the script. A multi-line command may be entered by backslashing the newlines.</source>
          <target state="translated">스크립트 실행으로 돌아가라는 명령을 방금 주었을 때 프롬프트 후에 수행 할 조치 (Perl 명령)를 추가합니다. 줄 바꾸기를 백 슬래시하여 여러 줄 명령을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f66738644531c5b87f8955ebdca5064179de491" translate="yes" xml:space="preserve">
          <source>Adds an entry to an existing</source>
          <target state="translated">기존 항목을 추가합니다</target>
        </trans-unit>
        <trans-unit id="0de7670702a5255a31f66440c4b7be5b815e4074" translate="yes" xml:space="preserve">
          <source>Adds directives to point C preprocessor to the right place when handling #include &amp;lt;sys/foo.h&amp;gt; directives. Also constructs CC command line a bit differently than MM_Unix method.</source>
          <target state="translated">#include &amp;lt;sys / foo.h&amp;gt; 지시문을 처리 할 때 C 전처리기를 올바른 위치에 지시하는 지시문을 추가합니다. 또한 CC 명령 행을 MM_Unix 메소드와 조금 다르게 구성합니다.</target>
        </trans-unit>
        <trans-unit id="57db6ceb50b20e26da1bd06687e1abc05f545a8e" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code.</source>
          <target state="translated">C 코드에 예외 처리 스텁을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="75f4dd4f96db4d1994f4da6375a60458e7848772" translate="yes" xml:space="preserve">
          <source>Adds exception handling stubs to the C code. Default is false.</source>
          <target state="translated">C 코드에 예외 처리 스텁을 추가합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="4af44986ac261800435ec27f11809711c0f2176e" translate="yes" xml:space="preserve">
          <source>Adds magic to a hash. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">해시에 마법을 추가합니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d4c5e94cf59f9802d65e1e2f74c4b0b68104c99" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV, upgrading it if necessary. Applies the supplied vtable and returns a pointer to the magic added.</source>
          <target state="translated">SV에 마법을 추가하여 필요한 경우 업그레이드합니다. 제공된 vtable을 적용하고 추가 된 마법에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28665dcfafc5d1482673492d1c1b2b0ccfb32625" translate="yes" xml:space="preserve">
          <source>Adds magic to an SV. First upgrades &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; if necessary, then adds a new magic item of type &lt;code&gt;how&lt;/code&gt; to the head of the magic list.</source>
          <target state="translated">SV에 마법을 추가합니다. 먼저 업그레이드 &lt;code&gt;sv&lt;/code&gt; 입력 &lt;code&gt;SVt_PVMG&lt;/code&gt; 을 필요가 입력 한 다음의 새로운 마법 아이템을 추가하는 경우 &lt;code&gt;how&lt;/code&gt; 마법리스트의 머리에.</target>
        </trans-unit>
        <trans-unit id="542cadc025698f26c94694489350a3b0f8078ab7" translate="yes" xml:space="preserve">
          <source>Adds the UTF-8 representation of the native code point &lt;code&gt;uv&lt;/code&gt; to the end of the string &lt;code&gt;d&lt;/code&gt; ; &lt;code&gt;d&lt;/code&gt; should have at least &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (up to &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</source>
          <target state="translated">고유 코드 포인트 &lt;code&gt;uv&lt;/code&gt; 의 UTF-8 표현을 문자열 &lt;code&gt;d&lt;/code&gt; 의 끝에 추가합니다 . &lt;code&gt;d&lt;/code&gt; 는 사용 가능한 바이트 가 최소한 &lt;code&gt;UVCHR_SKIP(uv)+1&lt;/code&gt; (최대 &lt;code&gt;UTF8_MAXBYTES+1&lt;/code&gt; ) 이상 이어야 합니다. 리턴 값은 새 문자의 끝 이후 바이트에 대한 포인터입니다. 다시 말해,</target>
        </trans-unit>
        <trans-unit id="05920eaea07a3bf7b3235f61833114608d265ccb" translate="yes" xml:space="preserve">
          <source>Adds the list of items to the queue at the specified index position (0 is the head of the list). Any existing items at and beyond that position are pushed back past the newly added items:</source>
          <target state="translated">지정된 색인 위치에서 큐에 항목 목록을 추가합니다 (0은 목록의 헤드 임). 해당 위치에 있거나 그 밖의 기존 항목이 새로 추가 된 항목을지나 뒤로 밀립니다.</target>
        </trans-unit>
        <trans-unit id="0e0d3dac3482cf17fed1b9381fe12a1473ad738e" translate="yes" xml:space="preserve">
          <source>Adds the standard Module prologue lines</source>
          <target state="translated">표준 모듈 프롤로그 라인 추가</target>
        </trans-unit>
        <trans-unit id="e8de0b7636a50e6e023d32d6c6819a0178b632ba" translate="yes" xml:space="preserve">
          <source>Adds the supplied opset to the current opmask. Note that there is currently</source>
          <target state="translated">제공된 opset을 현재 opmask에 추가합니다. 현재는</target>
        </trans-unit>
        <trans-unit id="ad3dde36a3137b653e95b59ad8f34b7ac4e19623" translate="yes" xml:space="preserve">
          <source>Adjust the read pointer and count of bytes to match &lt;code&gt;ptr&lt;/code&gt; and/or &lt;code&gt;cnt&lt;/code&gt; . The application (or layer above) must ensure they are consistent. (Checking is allowed by the paranoid.)</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 및 / 또는 &lt;code&gt;cnt&lt;/code&gt; 와 일치하도록 읽기 포인터 및 바이트 수를 조정하십시오 . 응용 프로그램 (또는 위의 계층)은 일관성을 유지해야합니다. (편집은 편집증에 의해 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="02eff1841c4085ce501a79933ae5da5167e9d1b8" translate="yes" xml:space="preserve">
          <source>Adjusting the system clock (either manually or by services like ntp) may cause problems, especially for long running programs that assume a monotonously increasing time (note that all platforms do not adjust time as gracefully as UNIX ntp does). For example in Win32 (and derived platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily drift off from the system clock (and the original time()) by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate. Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system supports CLOCK_MONOTONIC).</source>
          <target state="translated">시스템 클럭을 수동으로 또는 ntp와 같은 서비스로 조정하면 특히 단시간에 시간이 오래 걸리는 장기 실행 프로그램의 경우 문제가 발생할 수 있습니다 (모든 플랫폼이 UNIX ntp만큼 우아하게 시간을 조정하지는 않습니다). 예를 들어 Win32 (및 Cygwin 및 MinGW와 같은 파생 플랫폼)에서 Time :: HiRes :: time ()은 시스템 시계 (및 원래 시간 ())에서 최대 0.5 초까지 일시적으로 벗어날 수 있습니다. Time :: HiRes가이 사실을 확인하고 다시 교정합니다. Time :: HiRes 1.77 이후 clock_gettime (CLOCK_MONOTONIC)이이를 지원할 수 있습니다 (시스템이 CLOCK_MONOTONIC를 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="e8d0942ed6347577c01feddee9c6edaf4ffde5a8" translate="yes" xml:space="preserve">
          <source>Adjustments are made for Borland's quirks needing -L to come first.</source>
          <target state="translated">-L이 필요한 볼랜드의 단점을 먼저 조정합니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="1eda23758be9e36e5e0d2a6a87de584aaca0193f" translate="yes" xml:space="preserve">
          <source>Administrator</source>
          <target state="translated">Administrator</target>
        </trans-unit>
        <trans-unit id="e6a9cb58c1721e13f0512658aa83841944c325f3" translate="yes" xml:space="preserve">
          <source>Admittedly, it's a little silly to use the curlies in this case, but the BLOCK can contain any arbitrary expression, in particular, subscripted expressions:</source>
          <target state="translated">분명히이 경우 curl을 사용하는 것은 약간 어리석은 일이지만 BLOCK은 임의의 표현, 특히 아래 첨자 표현을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="64e04a8cbc4193de6f65fd1544695b7f543269ac" translate="yes" xml:space="preserve">
          <source>Advanced Possibilities</source>
          <target state="translated">고급 가능성</target>
        </trans-unit>
        <trans-unit id="a79e7b92e71c562343b0e0c5c252eadade25490c" translate="yes" xml:space="preserve">
          <source>Advanced Semaphores</source>
          <target state="translated">고급 세마포어</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="5646362e1c7206c24de0aa69540a4070b9eef4ad" translate="yes" xml:space="preserve">
          <source>Affects screen appearance of the command line (see &lt;a href=&quot;term/readline&quot;&gt;Term::ReadLine&lt;/a&gt;). There is currently no way to disable these, which can render some output illegible on some displays, or with some pagers. This is considered a bug.</source>
          <target state="translated">명령 행의 화면 모양에 영향을줍니다 ( &lt;a href=&quot;term/readline&quot;&gt;Term :: ReadLine&lt;/a&gt; 참조 ). 현재 이들을 비활성화하는 방법이 없으므로 일부 디스플레이에서 또는 일부 호출기에서 일부 출력을 읽을 수 없게 만들 수 있습니다. 이것은 버그로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac09ae75b5fa764eed3b6f049863915415754f4" translate="yes" xml:space="preserve">
          <source>Affects the printing of messages upon entry and exit from subroutines. If &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; is false, messages are printed on entry only. (Printing on exit might be useful if interspersed with other messages.)</source>
          <target state="translated">서브 루틴 시작 및 종료시 메시지 인쇄에 영향을줍니다. 경우 &lt;code&gt;frame &amp;amp; 2&lt;/code&gt; 거짓 메시지는 항목 만 인쇄되어 있습니다. (종료시 인쇄는 다른 메시지와 함께 산재 할 경우 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1d35114b8f34bf6224a46dac8d98b4ed3594b7f5" translate="yes" xml:space="preserve">
          <source>Africa</source>
          <target state="translated">Africa</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="87099a71e0044f05a4ae4680480a6ca9151bafd1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; all the floating point constants in the given scope are converted to &lt;code&gt;Math::BigFloat&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigFloat ':constant'&lt;/code&gt; 가 지정된 범위에있는 모든 부동 소수점 상수로 변환됩니다 &lt;code&gt;Math::BigFloat&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="809e579562da8a6c62758fa5638ee2d5856559cc" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; all the &lt;b&gt;integer&lt;/b&gt; decimal, hexadecimal and binary constants in the given scope are converted to &lt;code&gt;Math::BigInt&lt;/code&gt; . This conversion happens at compile time.</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Math::BigInt ':constant'&lt;/code&gt; 모든 &lt;b&gt;정수&lt;/b&gt; 주어진 범위 진수, 16 진수 이진 상수로 변환됩니다 &lt;code&gt;Math::BigInt&lt;/code&gt; . 이 변환은 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc94e5687372ef5e696852ffc210ec8b3418a842" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 해시 또는 배열에 다음 호출에서 모든 항목 돌아왔다 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반환리스트 문맥과 빈리스트 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 스칼라 문맥을; 다음 전화</target>
        </trans-unit>
        <trans-unit id="655e7d0919e193463d83e3f9f9d5abefb149c7ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; has returned all entries from the hash or array, the next call to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; returns the empty list in list context and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context; the next call following</source>
          <target state="translated">후 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 해시 또는 배열에 다음 호출에서 모든 항목 돌아왔다 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반환리스트 문맥과 빈리스트 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 스칼라 문맥을; 다음 전화</target>
        </trans-unit>
        <trans-unit id="1d724f064157a1afcae77bb02216759e4c7bf880" translate="yes" xml:space="preserve">
          <source>After a match against some variable &lt;code&gt;$var&lt;/code&gt; :</source>
          <target state="translated">일부 변수 &lt;code&gt;$var&lt;/code&gt; 과 일치시킨 후 :</target>
        </trans-unit>
        <trans-unit id="b84c3333b0e2cfaba4160f029890fe89d06d1d06" translate="yes" xml:space="preserve">
          <source>After a proper &lt;code&gt;POSIX::setlocale()&lt;/code&gt; call, and within the scope of of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes numerics, Perl obeys the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability. In most implementations the only effect is to change the character used for the decimal point--perhaps from &quot;.&quot; to &quot;,&quot;. The functions aren't aware of such niceties as thousands separation and so on. (See &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt; if you care about these things.)</source>
          <target state="translated">적절한 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 호출 후 그리고 숫자를 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 내에서 Perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 정보를 준수하며 , 이는 사람이 읽을 수 있도록 숫자의 형식을 지정하는 방법에 대한 애플리케이션의 아이디어를 제어합니다. 대부분의 구현에서 유일한 효과는 소수점에 사용 된 문자를 변경하는 것입니다. 아마도 &quot;.&quot; &quot;,&quot; 함수는 수천 개의 분리와 같은 멋진 점을 인식하지 못합니다. ( 관심 사항이 있으면 &lt;a href=&quot;#The-localeconv-function&quot;&gt;localeconv 기능을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1775073c0fe50242e57a96b412a98f0e94cc679a" translate="yes" xml:space="preserve">
          <source>After a successful compilation, you'll be able to use</source>
          <target state="translated">성공적으로 컴파일 한 후 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f087a68cf0ba68c94dea17e31581c5258e5a685a" translate="yes" xml:space="preserve">
          <source>After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</source>
          <target state="translated">결국,이 pragma의 가장 좋은 점은 \ x {....}에 의존 할 필요가 없다는 것입니다. 이름을 기본 인코딩으로 철자하기 만하면됩니다. 따라서 문자열을 따옴표와 정규식으로 인코딩에 자유롭게 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="7593ddf636c03d07a5c407ca6961ab2d5ad931e8" translate="yes" xml:space="preserve">
          <source>After an environment variable is tied, merely use it like a normal variable. You may access its value</source>
          <target state="translated">환경 변수를 묶은 후에는 일반 변수처럼 사용하십시오. 당신은 그 가치에 접근 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="755e56a66bf3563f2fb9151f704977af6151c9b5" translate="yes" xml:space="preserve">
          <source>After an extension has been built and before it is installed it may be desirable to test it bypassing &lt;code&gt;make test&lt;/code&gt; . By adding</source>
          <target state="translated">확장을 빌드 한 후 설치하기 전에 &lt;code&gt;make test&lt;/code&gt; 거치지 않고 테스트하는 것이 바람직 할 수 있습니다 . 추가하여</target>
        </trans-unit>
        <trans-unit id="82f653c370563b01ec9f101f2aaad77e03914b8a" translate="yes" xml:space="preserve">
          <source>After command line parsing the following attributes reflect the values of the corresponding command line switches. They may be altered before calling &lt;code&gt;run&lt;/code&gt; .</source>
          <target state="translated">명령 행 구문 분석 후 다음 속성은 해당 명령 행 스위치의 값을 반영합니다. &lt;code&gt;run&lt;/code&gt; 호출하기 전에 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e251b544ae28a039470aaf55a5b7b59f40f8190" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file is compiled, but before it is executed, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; is called if the subroutine &lt;code&gt;DB::postponed&lt;/code&gt; exists. Here, the $filename is the expanded name of the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d file, as found in the values of %INC.</source>
          <target state="translated">각 후 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; D 파일을 컴파일하지만 실행되기 전에, &lt;code&gt;DB::postponed(*{&quot;_&amp;lt;$filename&quot;})&lt;/code&gt; 서브 루틴 경우라고 &lt;code&gt;DB::postponed&lt;/code&gt; 존재한다. 여기서 $ filename은 % INC 값에 있는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d 파일 의 확장 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="e73cebac8df604a03fa2c93d2c658b08259d94b6" translate="yes" xml:space="preserve">
          <source>After each subroutine &lt;code&gt;subname&lt;/code&gt; is compiled, the existence of &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; is checked. If this key exists, &lt;code&gt;DB::postponed(subname)&lt;/code&gt; is called if the &lt;code&gt;DB::postponed&lt;/code&gt; subroutine also exists.</source>
          <target state="translated">각 서브 루틴 서브 &lt;code&gt;subname&lt;/code&gt; 이 컴파일 된 후 &lt;code&gt;$DB::postponed{subname}&lt;/code&gt; 의 존재 가 점검됩니다. 이 키가 존재 하면 &lt;code&gt;DB::postponed&lt;/code&gt; 서브 루틴도 존재 하면 &lt;code&gt;DB::postponed(subname)&lt;/code&gt; 이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e09c67a58e395afd52ffb2f20be8dce115f5694f" translate="yes" xml:space="preserve">
          <source>After each such removal you need to rerun the &lt;code&gt;Makefile.PL&lt;/code&gt; /&lt;code&gt;make&lt;/code&gt; process; usually this procedure converges soon. (But be sure to convert all the necessary external C libraries from</source>
          <target state="translated">이러한 제거 후에는 &lt;code&gt;Makefile.PL&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 프로세스 를 다시 실행해야합니다 . 일반적으로이 절차는 곧 수렴됩니다. (그러나 필요한 모든 외부 C 라이브러리를</target>
        </trans-unit>
        <trans-unit id="eb84d48b7946333a20d799fbde5105dfdef9cef8" translate="yes" xml:space="preserve">
          <source>After extracting the archive you copy the whole directory tree to your EBCDIC filesystem. &lt;b&gt;This time you use I/O-conversion&lt;/b&gt;:</source>
          <target state="translated">아카이브를 추출한 후 전체 디렉토리 트리를 EBCDIC 파일 시스템에 복사합니다. &lt;b&gt;이번에는 I / O 변환을 사용합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="19dac0c58c8882858862b2f71b6cf8f32d646112" translate="yes" xml:space="preserve">
          <source>After having failed to remove a directory, &lt;code&gt;remove_tree&lt;/code&gt; was unable to restore its permissions from a permissive state back to a possibly more restrictive setting. (Permissions given in octal).</source>
          <target state="translated">디렉토리를 제거하지 못한 후 &lt;code&gt;remove_tree&lt;/code&gt; 가 권한을 허용 상태에서 더 제한적인 설정으로 복원 할 수 없습니다. (8 진수로 된 권한).</target>
        </trans-unit>
        <trans-unit id="82bcd3184999ba561b43a537f2cc4ce40931101a" translate="yes" xml:space="preserve">
          <source>After having failed to remove a file, &lt;code&gt;remove_tree&lt;/code&gt; was also unable to restore the permissions on the file to a possibly less permissive setting. (Permissions given in octal).</source>
          <target state="translated">파일 제거에 실패한 후, &lt;code&gt;remove_tree&lt;/code&gt; 는 파일에 대한 권한을 덜 허용되는 설정으로 복원 할 수도 없었습니다. (8 진수로 된 권한).</target>
        </trans-unit>
        <trans-unit id="23dac87df7f1fec6e0cffc03d2d5c4ff05ad76e5" translate="yes" xml:space="preserve">
          <source>After having this in the first part of .xs file, the &quot;Perl glue&quot; part becomes as simple as</source>
          <target state="translated">.xs 파일의 첫 번째 부분에서이 작업을 수행 한 후 &quot;Perl glue&quot;부분은 다음과 같이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="2a05093cdd7b4cafe419584a2ca96b5327589ac9" translate="yes" xml:space="preserve">
          <source>After importing this module, when you use localtime or gmtime in a scalar context, rather than getting an ordinary scalar string representing the date and time, you get a Time::Piece object, whose stringification happens to produce the same effect as the localtime and gmtime functions. There is also a new() constructor provided, which is the same as localtime(), except when passed a Time::Piece object, in which case it's a copy constructor. The following methods are available on the object:</source>
          <target state="translated">이 모듈을 가져온 후 날짜와 시간을 나타내는 일반 스칼라 문자열을 가져 오는 대신 스칼라 컨텍스트에서 localtime 또는 gmtime을 사용하면 현지화 시간과 동일한 효과를 생성하는 Time :: Piece 객체가 생성됩니다. gmtime 함수. 또한 time :: Piece 객체를 전달했을 때를 제외하고는 localtime ()과 동일한 new () 생성자가 제공됩니다.이 경우 복사 생성자입니다. 객체에서 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="989e7c432fe7873dedca66b4efcb012930902467" translate="yes" xml:space="preserve">
          <source>After initialisation @dl_library_path can be manipulated by an application using push and unshift before calling dl_findfile(). Unshift can be used to add directories to the front of the search order either to save search time or to override libraries with the same name in the 'normal' directories.</source>
          <target state="translated">초기화 후 @dl_library_path는 dl_findfile ()을 호출하기 전에 push 및 unshift를 사용하여 응용 프로그램에서 조작 할 수 있습니다. Unshift를 사용하여 검색 시간 앞에 디렉토리를 추가하여 검색 시간을 절약하거나 '정상'디렉토리에서 동일한 이름을 가진 라이브러리를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384ec4e8afa39c03a7ec5ccae79ea44f50b98953" translate="yes" xml:space="preserve">
          <source>After installation &amp;amp; testing processes will stabilize, information will be more precise.</source>
          <target state="translated">설치 및 테스트 프로세스가 안정화되면 정보가 더 정확 해집니다.</target>
        </trans-unit>
        <trans-unit id="2fb4a06d67a8330d3fbde3ddb1645d723c7e519d" translate="yes" xml:space="preserve">
          <source>After installing cpan-mac, drop the module archive on the &lt;b&gt;untarzipme&lt;/b&gt; droplet, which will decompress and unpack for you.</source>
          <target state="translated">cpan-mac을 설치 한 후 &lt;b&gt;untarzipme&lt;/b&gt; 드롭 릿 에 모듈 아카이브를 &lt;b&gt;놓아&lt;/b&gt; 압축을 풀고 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="ebf5ce736aa7d823aae94b0fbadad820a15f7f86" translate="yes" xml:space="preserve">
          <source>After locating your program, Perl compiles the entire program to an internal form. If there are any compilation errors, execution of the program is not attempted. (This is unlike the typical shell script, which might run part-way through before finding a syntax error.)</source>
          <target state="translated">프로그램을 찾은 후 Perl은 전체 프로그램을 내부 형식으로 컴파일합니다. 컴파일 오류가 있으면 프로그램 실행이 시도되지 않습니다. (이것은 구문 오류를 찾기 전에 부분적으로 실행될 수있는 일반적인 쉘 스크립트와 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="1f14adfb2016d61c246f44ef48217385e9787764" translate="yes" xml:space="preserve">
          <source>After much staring at the same piece of code and not seeing the wood for the trees for some time, we get a cup of coffee and try another approach. That is, we bring in the cavalry by giving perl the '&lt;b&gt;-d&lt;/b&gt;' switch on the command line:</source>
          <target state="translated">같은 코드 조각을 많이 쳐다보고 얼마 동안 나무의 나무를 보지 않으면 커피 한 잔을 마시고 다른 접근법을 시도합니다. 즉 , 명령 행에 perl에 ' &lt;b&gt;-d&lt;/b&gt; '스위치를 제공하여 기병대를 불러옵니다 .</target>
        </trans-unit>
        <trans-unit id="88dec92da58c74e4620b3cd18d97733f553fa72c" translate="yes" xml:space="preserve">
          <source>After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.</source>
          <target state="translated">TAP를 구문 분석 한 후 결과를 탐색하고 의미있는 사항을 결정하는 데 사용할 수있는 방법이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b702243123830daddfd7ae611e2d0a89f36745c6" translate="yes" xml:space="preserve">
          <source>After parsing, this method returns any warnings encountered during the parsing process.</source>
          <target state="translated">구문 분석 후이 메소드는 구문 분석 프로세스 중에 발생한 모든 경고를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cebf2b23cf8d6511ea00c15fa6633daadf530471" translate="yes" xml:space="preserve">
          <source>After positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:</source>
          <target state="translated">위치 매개 변수 이후에, 추가 인수는 거친 매개 변수로 캡처 될 수 있습니다. 가장 간단한 형태는 배열 변수입니다.</target>
        </trans-unit>
        <trans-unit id="79faa591ef4aa9c1048ecde8617caf4bb4f6e42f" translate="yes" xml:space="preserve">
          <source>After processing of the error using</source>
          <target state="translated">를 사용하여 오류를 처리 한 후</target>
        </trans-unit>
        <trans-unit id="de441b5d72f77ccdab32c953f236dc0929b26bfe" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; explaining how to use &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; we can write this Perl function copying a file to standard output:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 사용법을 설명하는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc를&lt;/a&gt; 읽은 후 파일을 표준 출력으로 복사하는이 Perl 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b88eddec153e8e34fbe3804e13971f48b0d9e3" translate="yes" xml:space="preserve">
          <source>After reading this document, you ought to read &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; too, then &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">이 문서를 읽은 &lt;a href=&quot;perlunifaq&quot;&gt;후에는 perlunifaq&lt;/a&gt; 도 읽은 다음 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 를 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="bde067e2f6a70b830351def3b30472931261a063" translate="yes" xml:space="preserve">
          <source>After that,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a6f21294ecc8bfb003384c79fe3378bc362230" translate="yes" xml:space="preserve">
          <source>After the call to &lt;code&gt;inflate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 전화 후</target>
        </trans-unit>
        <trans-unit id="82f20576e0d7a55f07ad388dd8a48aef5935809c" translate="yes" xml:space="preserve">
          <source>After the compile tree for a subroutine (or for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file) is created, an additional pass over the code is performed. This pass is neither top-down or bottom-up, but in the execution order (with additional complications for conditionals). Optimizations performed at this stage are subject to the same restrictions as in the pass 2.</source>
          <target state="translated">서브 루틴 (또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 파일)에 대한 컴파일 트리 가 작성된 후 코드에 대한 추가 패스가 수행됩니다. 이 패스는 하향식 또는 상향식이 아니라 실행 순서로 이루어집니다 (조건부에 대한 추가 합병증 포함). 이 단계에서 수행되는 최적화에는 패스 2와 동일한 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="030398b98f864699ff503816f85c07e82cf00fe5" translate="yes" xml:space="preserve">
          <source>After the match fails at the letter &lt;code&gt;a&lt;/code&gt; , perl resets &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; and the next match on the same string starts at the beginning.</source>
          <target state="translated">문자 &lt;code&gt;a&lt;/code&gt; 에서 일치가 실패하면 perl은 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 재설정 하고 같은 문자열에서 다음 일치가 처음에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="293c71dbddf34e425e567a76e0a301441dc6a8bc" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; environment variable and parses this as the remainder of a &quot;O ...&quot; line as one might enter at the debugger prompt. You may place the initialization options &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; , and &lt;code&gt;NonStop&lt;/code&gt; there.</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 환경 변수를 읽고 디버거 프롬프트에서 입력 할 수있는 나머지 &quot;O ...&quot;행으로 구문 분석합니다. 초기화 옵션 &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;noTTY&lt;/code&gt; , &lt;code&gt;ReadLine&lt;/code&gt; 및 &lt;code&gt;NonStop&lt;/code&gt; 을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e899e5cdac5e0e6b4bee21b7339405a7360957f3" translate="yes" xml:space="preserve">
          <source>After the rc file is read, the debugger reads the PERLDB_OPTS environment variable and uses it to set debugger options. The contents of this variable are treated as if they were the argument of an &lt;code&gt;o ...&lt;/code&gt; debugger command (q.v. in &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;Configurable Options in perldebug&lt;/a&gt;).</source>
          <target state="translated">rc 파일을 읽은 후 디버거는 PERLDB_OPTS 환경 변수를 읽고이를 사용하여 디버거 옵션을 설정합니다. 이 변수의 내용은 마치 &lt;code&gt;o ...&lt;/code&gt; 디버거 명령 의 인수 인 것처럼 처리됩니다 ( &lt;a href=&quot;perldebug#Configurable-Options&quot;&gt;perldebug의 구성 가능 옵션에서 qv&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="48e96da87f1b22f4a662b486f469bd089c2d194f" translate="yes" xml:space="preserve">
          <source>After this you can direct your browser the file</source>
          <target state="translated">이 후 브라우저에 파일을 지시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="047aa94c055cd198e88e38eec23f2d3fb520f816" translate="yes" xml:space="preserve">
          <source>After this you can either copy Perl from your operating system media (you will need at least the /System/Library/Perl and /usr/bin/perl), or rebuild Perl from the source code with &lt;code&gt;Configure -Dprefix=/usr
-Duseshrplib&lt;/code&gt; NOTE: the &lt;code&gt;-Dprefix=/usr&lt;/code&gt; to replace the system Perl works much better with Perl 5.8.1 and later, in Perl 5.8.0 the settings were not quite right.</source>
          <target state="translated">그런 다음 운영 체제 매체에서 Perl을 복사하거나 (적어도 / System / Library / Perl 및 / usr / bin / perl이 &lt;code&gt;Configure -Dprefix=/usr -Duseshrplib&lt;/code&gt; ) 또는 Configure -Dprefix = / usr -Duseshrplib 를 사용하여 소스 코드에서 Perl을 다시 빌드 하십시오. 참고 : 시스템 Perl을 대체하기 위한 &lt;code&gt;-Dprefix=/usr&lt;/code&gt; 은 Perl 5.8.1 이상에서 훨씬 더 잘 작동합니다. Perl 5.8.0에서는 설정이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="afc63f5dda4ecced4f5f45482623e56ea1f306ab" translate="yes" xml:space="preserve">
          <source>After you have built perl using the Configure script, ensure that you have modify and default write permission to &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; and all subdirectories. Then type</source>
          <target state="translated">Configure 스크립트를 사용하여 perl을 빌드 한 후 &lt;code&gt;&amp;gt;system&amp;gt;ported&lt;/code&gt; 및 모든 서브 디렉토리에 대한 수정 및 기본 쓰기 권한이 있는지 확인하십시오 . 그런 다음</target>
        </trans-unit>
        <trans-unit id="8aca2e8c01b81a07c6eb69c26b8265b8e7beb0f1" translate="yes" xml:space="preserve">
          <source>After you installed the components you needed and updated the</source>
          <target state="translated">필요한 구성 요소를 설치하고 업데이트 한 후</target>
        </trans-unit>
        <trans-unit id="61179f6b3dda7b5ee08dd7ce8f69dddb876677ab" translate="yes" xml:space="preserve">
          <source>Again assuming the existence of the &lt;code&gt;tree&lt;/code&gt; database</source>
          <target state="translated">다시 &lt;code&gt;tree&lt;/code&gt; 데이터베이스가 있다고 가정</target>
        </trans-unit>
        <trans-unit id="7c2b707160e59a8a50ca98c9028a92309952c8b9" translate="yes" xml:space="preserve">
          <source>Again like &lt;code&gt;cond_wait&lt;/code&gt; , waking up and reacquiring the lock are not atomic, and you should always check your desired condition after this function returns. Since the timeout is an absolute value, however, it does not have to be recalculated with each pass:</source>
          <target state="translated">다시 &lt;code&gt;cond_wait&lt;/code&gt; 와 같이 잠금을 해제하고 다시 획득하는 것은 원자 적이 지 않으므로이 함수가 반환 된 후에는 항상 원하는 조건을 확인해야합니다. 그러나 시간 초과는 절대 값이므로 각 패스와 함께 다시 계산할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1807d38160980407aafc2417f04ad9be3af89ae" translate="yes" xml:space="preserve">
          <source>Again, for elementary pieces there is no such question, since at most one match at a given position is possible. This section describes the notion of better/worse for combining operators. In the description below &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions.</source>
          <target state="translated">다시 말하지만, 기본 조각의 경우 주어진 위치에서 최대 하나의 일치가 가능하기 때문에 그러한 질문은 없습니다. 이 섹션에서는 연산자 결합에 대한 더 나은 / 나쁜 개념을 설명합니다. 아래 설명에서 &lt;code&gt;S&lt;/code&gt; 와 &lt;code&gt;T&lt;/code&gt; 는 정규 하위 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="5f5a18a4eff39b7d1528cf15b17087b5d8251fa1" translate="yes" xml:space="preserve">
          <source>Again, if you already have the data in memory or want to avoid the complexity of the above, you can use sv_setpvn().</source>
          <target state="translated">다시 말하지만 이미 메모리에 데이터가 있거나 위의 복잡성을 피하려면 sv_setpvn ()을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8e2e1b9b0e08a7a42ff9da61e6daf28394e96e" translate="yes" xml:space="preserve">
          <source>Again, the PERL_DL_NONLAZY thing.</source>
          <target state="translated">PERL_DL_NONLAZY도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cc9355813d20c04f9885340bd38f5820f772f6ef" translate="yes" xml:space="preserve">
          <source>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking &lt;code&gt;$ps&lt;/code&gt; with the same template returns the original integer value:</source>
          <target state="translated">다시 결과는 2 바이트를 포함하는 문자열입니다. 이 문자열을 인쇄하면 (일반적으로 권장되지 않음) &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; (시스템의 바이트 순서에 따라 다름) 또는 컴퓨터에서 ASCII 문자 인코딩을 사용하지 않는 경우 완전히 다른 것이 표시 될 수 있습니다. 동일한 템플릿으로 &lt;code&gt;$ps&lt;/code&gt; 를 풀면 원래 정수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1336fb8f59fe4c2604eb97dc0557c0ec454667ba" translate="yes" xml:space="preserve">
          <source>Again, the same rule about having a valid invocand applies -- use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block or &lt;code&gt;blessed&lt;/code&gt; if you need to be extra paranoid.</source>
          <target state="translated">다시 말하지만, 유효한 invocand있는에 관하여 같은 규칙이 적용됩니다 - 사용 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록 또는 &lt;code&gt;blessed&lt;/code&gt; 이 추가 편집증해야합니다.</target>
        </trans-unit>
        <trans-unit id="f032390a780d79dd005854d30b600a71dcbdee7e" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">다시, LIST를 생략 사이의 구분 (가 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 인수없이 호출) 및 명시 적 빈 LIST &lt;code&gt;()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 라고하지 않음). VERSION 이후에는 쉼표가 없습니다!</target>
        </trans-unit>
        <trans-unit id="150579942e699af9662ec748d7e74bb724b4dd49" translate="yes" xml:space="preserve">
          <source>Again, there is a distinction between omitting LIST (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; called with no arguments) and an explicit empty LIST &lt;code&gt;()&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; not called). Note that there is no comma after VERSION!</source>
          <target state="translated">다시, LIST를 생략 사이의 구분 (가 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 인수없이 호출) 및 명시 적 빈 LIST &lt;code&gt;()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 라고하지 않음). VERSION 이후에는 쉼표가 없습니다!</target>
        </trans-unit>
        <trans-unit id="245e36d26002b84ee14a1352ac81744d3ee557bd" translate="yes" xml:space="preserve">
          <source>Again, this allows for very dynamic code.</source>
          <target state="translated">다시 말하지만, 이것은 매우 역동적 인 코드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b538a15a09c26e00740fa45cdf77f8fdb9a0d9a7" translate="yes" xml:space="preserve">
          <source>Again, this procedure should not be absolutely smooth. Some &lt;code&gt;Makefile.PL&lt;/code&gt; 's in subdirectories may be buggy, and would not run as &quot;child&quot; scripts. The interdependency of modules can strike you; however, since non-XS modules are already installed, the prerequisites of most modules have a very good chance to be present.</source>
          <target state="translated">다시 말하지만이 절차는 절대적으로 매끄럽지 않아야합니다. 하위 디렉토리에있는 일부 &lt;code&gt;Makefile.PL&lt;/code&gt; 은 버그가있을 수 있으며 &quot;자식&quot;스크립트로 실행되지 않습니다. 모듈의 상호 의존성은 당신을 때릴 수 있습니다. 그러나 비 XS 모듈이 이미 설치되어 있기 때문에 대부분의 모듈의 필수 구성 요소가 존재할 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="d29cd93346e769552a8195aadabaa89c166d289b" translate="yes" xml:space="preserve">
          <source>Again, this should be a last resort only. Ideally, this should never happen, and every possible effort at cooperation and compromise should be made before doing this. If it does prove necessary to fork a module for the overall health of Perl, proper credit must be given to the original author in perpetuity and the decision should be constantly re-evaluated to see if a remerging of the two branches is possible down the road.</source>
          <target state="translated">다시 말하지만 이것은 최후의 수단 일 것입니다. 이상적으로는 이런 일이 발생하지 않아야하며이를 수행하기 전에 협력 및 타협에 가능한 모든 노력을 기울여야합니다. Perl의 전반적인 건강 상태를 위해 모듈을 포크해야하는 경우, 원래 작성자에게 영구적으로 적절한 크레딧을 제공해야하며, 두 지점의 재결합이 가능한지 확인하기 위해 결정을 지속적으로 재평가해야합니다. .</target>
        </trans-unit>
        <trans-unit id="3a830cc268120c6d62fd1503dae1fe4595320a8c" translate="yes" xml:space="preserve">
          <source>Aggregate TAP::Parser results</source>
          <target state="translated">TAP :: Parser 결과 집계</target>
        </trans-unit>
        <trans-unit id="c99323987b877f0729176ba94246c79d0ffee75d" translate="yes" xml:space="preserve">
          <source>Ah, but what if you wanted a</source>
          <target state="translated">아,하지만 만약 당신이 원한다면</target>
        </trans-unit>
        <trans-unit id="fc54c7321882850cd59ca3c898a45a1866c62d48" translate="yes" xml:space="preserve">
          <source>Alan Burlison &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</source>
          <target state="translated">앨런 벌 리슨 &amp;lt;Alan.Burlison@uk.sun.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28819c4f1ea8b8ef6efc038b761b2ce064e6ebed" translate="yes" xml:space="preserve">
          <source>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</source>
          <target state="translated">아아, 그러나 이것이 간단하게 보일 수 있지만, 그 아래에는 눈을 만나는 것보다 훨씬 더 정교한 구조가 있습니다!</target>
        </trans-unit>
        <trans-unit id="60deebc91420b65bfc5133938fc33e7af7cddcdc" translate="yes" xml:space="preserve">
          <source>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code &lt;code&gt;p&lt;/code&gt; is a repeat count, not a length as after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">길이가 문자열의 길이에 의해 암시되는 결과로, 팩 코드 &lt;code&gt;p&lt;/code&gt; 이후의 숫자 는 &lt;code&gt;P&lt;/code&gt; 이후의 길이가 아닌 반복 횟수 입니다.</target>
        </trans-unit>
        <trans-unit id="c375d17736d5ba75bae4628bbac2b8464ec67f67" translate="yes" xml:space="preserve">
          <source>Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</source>
          <target state="translated">Alex Waugh &amp;lt;alex@alexwaugh.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="98410e18a5313b84b52dba6923f79fa84662fc78" translate="yes" xml:space="preserve">
          <source>Algorithmic Complexity Attacks</source>
          <target state="translated">알고리즘 복잡성 공격</target>
        </trans-unit>
        <trans-unit id="880e348dcb112fd7762be969b0a0f638889a7979" translate="yes" xml:space="preserve">
          <source>Alias 'great_circle_bearing' for 'great_circle_direction' is also available.</source>
          <target state="translated">'great_circle_direction'에 대한 별칭 'great_circle_bearing'도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0898ef4b9ee98efd06a1a0a5dfd90a367c2cd721" translate="yes" xml:space="preserve">
          <source>Alias definitions to encodings</source>
          <target state="translated">인코딩에 대한 별명 정의</target>
        </trans-unit>
        <trans-unit id="38f722ea341fc11c96b38a2a9a95013e2024c780" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_codes&quot;&gt;accept_codes의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f3ca2b4415e7c30e7f132f19403b5bffd02f19e2" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets&quot;&gt;accept_targets의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="90cb0f686347b95e9bf9ac20dee8ecef9cc3e7cc" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/accept_targets_as_text&quot;&gt;accept_targets_as_text의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d8a37b728f269336ef2b0d916cf56f8cff9a7dab" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_codes&quot;&gt;unaccept_codes의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="55942451ef5112cddaa2996d9b3ade198613f3aa" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_directives&quot;&gt;unaccept_directives의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="fc63b361fbc74519b267bcb5465524b93139434d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;a href=&quot;http://search.cpan.org/perldoc/unaccept_targets&quot;&gt;unaccept_targets&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74c2c2daa5f5a0797029a2454513a78581202693" translate="yes" xml:space="preserve">
          <source>Alias overloading</source>
          <target state="translated">별칭 과부하</target>
        </trans-unit>
        <trans-unit id="f57cd105a2d625b230e3773e4d9ad4fd8007e4e8" translate="yes" xml:space="preserve">
          <source>Aliases are added either by the use of anonymous hashes:</source>
          <target state="translated">익명 해시를 사용하여 별칭을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a04d03e091eed69bf0cabdf08f34999597a31b63" translate="yes" xml:space="preserve">
          <source>Aliases have no effect on the return value of uncolor().</source>
          <target state="translated">별칭은 uncolor ()의 반환 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bde3b653ba60660ff94a6811c58e93a5bf93107d" translate="yes" xml:space="preserve">
          <source>Aliases must begin with a character that is alphabetic. After that, each may contain any combination of word (&lt;code&gt;\w&lt;/code&gt; ) characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have been allowed in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS currently deprecated and scheduled for removal in Perl v5.26; the other two may also be deprecated and removed in future releases of Perl, so don't use them for new names. (More precisely, the first character of a name you specify must be something that matches all of &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; , and &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; . This makes sure it is what any reasonable person would view as an alphabetic character. And, the continuation characters that match &lt;code&gt;\w&lt;/code&gt; must also match &lt;code&gt;\p{ID_Continue}&lt;/code&gt; .) Starting with Perl v5.18, any Unicode characters meeting the above criteria may be used; prior to that only Latin1-range characters were acceptable.</source>
          <target state="translated">별명은 알파벳 문자로 시작해야합니다. 그 후에는 각각 단어 ( &lt;code&gt;\w&lt;/code&gt; ) 문자, 스페이스 (U + 0020), 하이픈 마이너스 (U + 002D), 왼쪽 PARENTHESIS (U + 0028), RIGHT PARENTHESIS (U + 0029) 및 NO의 조합을 포함 할 수 있습니다. -BREAK SPACE (U + 00A0). 이 마지막 세 개는 이름으로 허용해서는 안되며 이전 버전과의 호환성을 위해서만 유지됩니다. NO-BREAK SPACE는 현재 더 이상 사용되지 않으며 Perl v5.26에서 제거 될 예정입니다. 다른 두 버전은 향후 Perl 릴리스에서 더 이상 사용되지 않고 제거 될 수 있으므로 새 이름으로 사용하지 마십시오. (더 정확하게, 지정한 이름의 첫 문자는 &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 및 &lt;code&gt;\p{Gc=Letter}&lt;/code&gt; 와 모두 일치해야합니다.. 이것은 합리적 인 사람이 알파벳 문자로 볼 수있는 것입니다. &lt;code&gt;\w&lt;/code&gt; 와 일치하는 연속 문자 도 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 와 일치해야합니다 .) Perl v5.18부터는 위의 기준을 충족하는 모든 유니 코드 문자를 사용할 수 있습니다. 그 전에는 라틴어 범위 문자 만 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="91f975513dec5dd8e68b29fb075833bd77c269b1" translate="yes" xml:space="preserve">
          <source>Alignment, Take 2</source>
          <target state="translated">정렬, 테이크 2</target>
        </trans-unit>
        <trans-unit id="a1ea8b54954e0fde287940a149a033befa43e6c8" translate="yes" xml:space="preserve">
          <source>Alignment, Take 3</source>
          <target state="translated">정렬, 테이크 3</target>
        </trans-unit>
        <trans-unit id="764199267e4fee8134969e2bb73e632b952ebdb3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;--sources&lt;/code&gt; are combined into a hash, and passed to &lt;a href=&quot;tap/harness#new&quot;&gt;new in TAP::Harness&lt;/a&gt;'s &lt;code&gt;sources&lt;/code&gt; parameter.</source>
          <target state="translated">모든 &lt;code&gt;--sources&lt;/code&gt; 는 해시로 결합되고 &lt;a href=&quot;tap/harness#new&quot;&gt;TAP :: Harness&lt;/a&gt; 의 &lt;code&gt;sources&lt;/code&gt; 매개 변수 에서 new로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f52d6e40e6d60dfb65b7ff9829f21ad743f4c4af" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;Digest::&lt;/code&gt; modules provide the same programming interface. A functional interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">모든 &lt;code&gt;Digest::&lt;/code&gt; 모듈은 동일한 프로그래밍 인터페이스를 제공합니다. 임의의 길이의 메시지를 처리 ​​할 수 ​​있고 파일을 직접 읽을 수있는 객체 지향 인터페이스뿐만 아니라 간단한 사용을위한 기능 인터페이스.</target>
        </trans-unit>
        <trans-unit id="457b3764fb61bab63f516bcecf7b3d7be10ba056" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;TAP::*&lt;/code&gt; objects inherit from &lt;a href=&quot;object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;TAP::*&lt;/code&gt; 객체는 &lt;a href=&quot;object&quot;&gt;TAP :: Object&lt;/a&gt; 에서 상속받습니다 .</target>
        </trans-unit>
        <trans-unit id="5afc429b1453c07f0d0baef120b89dcb6d31ac74" translate="yes" xml:space="preserve">
          <source>All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?</source>
          <target state="translated">내가하고 싶은 것은 파일 끝에 작은 양의 텍스트를 추가하는 것입니다. 여전히 잠금을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="364f430073ddd95c184ef6908813da97f63c8227" translate="yes" xml:space="preserve">
          <source>All NULs, returns, and newlines are removed from the result.</source>
          <target state="translated">모든 NUL, 리턴 및 줄 바꾸기가 결과에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3357b46fb83adc9becdcce6c42b795ffab969cd7" translate="yes" xml:space="preserve">
          <source>All Perl applications that make use of the script will need to be changed (slightly) if the script is converted into a module. Is it worth it unless you plan to make other changes at the same time?</source>
          <target state="translated">스크립트를 모듈로 변환 할 경우 스크립트를 사용하는 모든 Perl 응용 프로그램을 약간 변경해야합니다. 동시에 다른 변경을 계획하지 않는 한 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="c0556d5f4ef8cf5b2d75a71a511d88da552691b2" translate="yes" xml:space="preserve">
          <source>All Perl module files have the extension</source>
          <target state="translated">모든 Perl 모듈 파일의 확장자는</target>
        </trans-unit>
        <trans-unit id="c9df8c5103a954885f4c9cd5391cce1f658e5378" translate="yes" xml:space="preserve">
          <source>All Perl source filters are implemented as Perl classes and have the same basic structure as the example above.</source>
          <target state="translated">모든 Perl 소스 필터는 Perl 클래스로 구현되며 위 예제와 동일한 기본 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a24109cbe749713ab37960e5621fab63c25af84c" translate="yes" xml:space="preserve">
          <source>All SVs that contain strings should be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. If it is not &lt;code&gt;NUL&lt;/code&gt; -terminated there is a risk of core dumps and corruptions from code which passes the string to C functions or system calls which expect a &lt;code&gt;NUL&lt;/code&gt; -terminated string. Perl's own functions typically add a trailing &lt;code&gt;NUL&lt;/code&gt; for this reason. Nevertheless, you should be very careful when you pass a string stored in an SV to a C function or system call.</source>
          <target state="translated">문자열을 포함하는 모든 SV는 &lt;code&gt;NUL&lt;/code&gt; 문자 로 끝나야 합니다. &lt;code&gt;NUL&lt;/code&gt; 종료 가 아닌 경우 문자열을 C 함수 또는 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열 을 기대하는 시스템 호출로 전달하는 코드에서 코어 덤프 및 손상의 위험이 있습니다. 펄 자신의 함수는 일반적으로 이런 이유로 후행 &lt;code&gt;NUL&lt;/code&gt; 을 추가합니다 . 그럼에도 불구하고 SV에 저장된 문자열을 C 함수 나 시스템 호출에 전달할 때는 매우주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="48a5c9b581d8c7b87b13529ddc2ea4756cd71725" translate="yes" xml:space="preserve">
          <source>All Solaris documentation is available on-line at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;.</source>
          <target state="translated">모든 Solaris 설명서는 &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt; 에서 온라인으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="02a6fc4950c3ff395602f4e234c32b98fa8bbb9b" translate="yes" xml:space="preserve">
          <source>All Unicode-defined character properties may be written in these compound forms of &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt;, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</source>
          <target state="translated">모든 유니 코드 정의 문자 특성은 이러한 복합 형식의 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 또는 &lt;code&gt;\p{&lt;i&gt;property&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; 로 작성 될 수 있지만 Perl은 단일 형식뿐만 아니라 단일 형식으로 작성된 일부 추가 특성을 제공합니다. 속성 이름과 등호 또는 콜론 구분 기호를 생략 할 수있는 모든 이진 속성 및 아래 설명 된 특정 속성에 대한 바로 가기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="824a27b5a0842833d945bd7311a2e5202945d5f2" translate="yes" xml:space="preserve">
          <source>All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In this case</source>
          <target state="translated">위의 내용은 # stdio 함수로 정의되거나 stdio를 호출하는 간단한 래퍼 함수입니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="480b6099af5b199261a0cc5b0a69906525b8aab5" translate="yes" xml:space="preserve">
          <source>All are zero-width assertions.</source>
          <target state="translated">모두 폭이 0 인 어설 션입니다.</target>
        </trans-unit>
        <trans-unit id="ea4147392f071907aee8241573927949a9171c29" translate="yes" xml:space="preserve">
          <source>All arguments are optional. If the escape characters are not specified, every delimiter is escaped with a backslash (&lt;code&gt;\&lt;/code&gt; ). If the prefix is not specified, the pattern &lt;code&gt;'\s*'&lt;/code&gt; - optional whitespace - is used. If the delimiter set is also not specified, the set &lt;code&gt;/[&quot;'`]/&lt;/code&gt; is used. If the text to be processed is not specified either, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">모든 인수는 선택 사항입니다. 이스케이프 문자를 지정하지 않으면 모든 구분 기호가 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 이스케이프됩니다 . 접두사가 지정되지 않으면 패턴 &lt;code&gt;'\s*'&lt;/code&gt; 선택적 공백)가 사용됩니다. 분리 문자 세트도 지정되지 않으면 세트 &lt;code&gt;/[&quot;'`]/&lt;/code&gt; 가 사용되며 처리 할 텍스트도 지정되지 않으면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae556487b52756ee168bee18fdadcf299ff8eb4" translate="yes" xml:space="preserve">
          <source>All arguments passed to &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; are passed onto &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; with the exception of &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 인수 는 &lt;code&gt;import =&amp;gt;[qw(things to import)]&lt;/code&gt; 제외 하고 &lt;code&gt;Your::Module-&amp;gt;builder-&amp;gt;plan()&lt;/code&gt; 으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e982744f4ac0300218d6f294863226187db18a" translate="yes" xml:space="preserve">
          <source>All arguments passed to the &lt;b&gt;new()&lt;/b&gt; constructor will be treated as key/value pairs in a hash-table. The newly constructed object will be initialized by copying the contents of the given hash-table (which may have been empty). The &lt;b&gt;new()&lt;/b&gt; constructor for this class and all of its subclasses returns a blessed reference to the initialized object (hash-table).</source>
          <target state="translated">&lt;b&gt;new ()&lt;/b&gt; 생성자로 전달 된 모든 인수 는 해시 테이블에서 키 / 값 쌍으로 처리됩니다. 새로 생성 된 객체는 주어진 해시 테이블 (비어있을 수 있음)의 내용을 복사하여 초기화됩니다. &lt;b&gt;새로운 ()&lt;/b&gt; 이 클래스와 그 서브 클래스의 모든 생성자는 초기화 된 객체 (해시 테이블)에 축복 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec83cba8a792f2692f5daa6167d2d16a27e37ea4" translate="yes" xml:space="preserve">
          <source>All arguments to bootstrap() are passed to the module's bootstrap function. The default code generated by</source>
          <target state="translated">bootstrap ()에 대한 모든 인수는 모듈의 부트 스트랩 함수로 전달됩니다. 에 의해 생성 된 기본 코드</target>
        </trans-unit>
        <trans-unit id="0641330064a33946ad2abf69443076e60a765bfc" translate="yes" xml:space="preserve">
          <source>All bytes in a multi-byte UTF-8 character will have the high bit set, so you can test if you need to do something special with this character like this (the &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; is a macro that tests whether the byte is encoded as a single byte even in UTF-8):</source>
          <target state="translated">멀티 바이트 UTF-8 문자의 모든 바이트는 높은 비트 세트를 가지므로 다음과 &lt;code&gt;UTF8_IS_INVARIANT()&lt;/code&gt; 문자로 특별한 작업을 수행 해야하는지 테스트 할 수 있습니다 ( UTF8_IS_INVARIANT () 는 바이트가 다음과 같이 인코딩되는지 여부를 테스트하는 매크로입니다 ) UTF-8에서도 단일 바이트) :</target>
        </trans-unit>
        <trans-unit id="3518d33b42f2dc03b1a9ce5a7bf1630a8c432554" translate="yes" xml:space="preserve">
          <source>All classes automatically inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class, which is built-in to the Perl core. This class provides a number of methods, all of which can be called on either a class or an object. You can also choose to override some of these methods in your class. If you do so, we recommend that you follow the built-in semantics described below.</source>
          <target state="translated">모든 클래스 는 Perl 코어에 내장 된 &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 클래스 에서 자동으로 상속됩니다 . 이 클래스는 많은 메소드를 제공하며, 모두 클래스 또는 객체에서 호출 할 수 있습니다. 클래스에서 이러한 메소드 중 일부를 대체하도록 선택할 수도 있습니다. 그렇게하는 경우 아래 설명 된 내장 의미 체계를 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01913ce43f34cc16d63eaaa24a00e403aac3c548" translate="yes" xml:space="preserve">
          <source>All classes inherit from the &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class implicitly. The &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; class is implemented by the Perl core, and provides several default methods, such as &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , and &lt;code&gt;VERSION()&lt;/code&gt; . The &lt;code&gt;UNIVERSAL&lt;/code&gt; class will</source>
          <target state="translated">모든 클래스는 &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 클래스에서 암시 적으로 상속됩니다 . &lt;a href=&quot;universal&quot;&gt;UNIVERSAL의&lt;/a&gt; 클래스는 펄 코어로 구현하고 다음과 같은 몇 가지 기본 방법을 제공한다 &lt;code&gt;isa()&lt;/code&gt; , &lt;code&gt;can()&lt;/code&gt; , 및 &lt;code&gt;VERSION()&lt;/code&gt; . &lt;code&gt;UNIVERSAL&lt;/code&gt; 의 클래스 의지</target>
        </trans-unit>
        <trans-unit id="d7ed55b8e4e0eb9f903d01566d45c62ffc547221" translate="yes" xml:space="preserve">
          <source>All code points that would be matched by this are matched by either &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot;</source>
          <target state="translated">이 코드와 일치하는 모든 코드 포인트는 &quot;Script_Extensions = Katakana&quot;또는 &quot;Script_Extensions = Hiragana&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="68b93a9f8c08d5ea78bcf3b0d94efaeadf4ebfe0" translate="yes" xml:space="preserve">
          <source>All command paragraphs (which are typically only one line long) start with &quot;=&quot;, followed by an identifier, followed by arbitrary text that the command can use however it pleases. Currently recognized commands are</source>
          <target state="translated">모든 명령 단락 (일반적으로 한 줄 길이 임)은 &quot;=&quot;로 시작하고, 식별자와 명령이 사용할 수있는 임의의 텍스트가 뒤 따릅니다. 현재 인식되는 명령은</target>
        </trans-unit>
        <trans-unit id="982b67a682c875ad11cfce0a29c201661fc04837" translate="yes" xml:space="preserve">
          <source>All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference. In general, conversion from one form to another is transparent. Although a scalar may not directly hold multiple values, it may contain a reference to an array or hash which in turn contains multiple values.</source>
          <target state="translated">Perl의 모든 데이터는 스칼라, 스칼라 배열 또는 스칼라 해시입니다. 스칼라는 숫자, 문자열 또는 참조의 세 가지 맛 중 하나에 하나의 단일 값을 포함 할 수 있습니다. 일반적으로 한 형태에서 다른 형태로의 변환은 투명합니다. 스칼라는 여러 값을 직접 보유 할 수는 없지만 배열 또는 해시에 대한 참조를 포함 할 수 있으며이 값에는 여러 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="69c2eb01381ceb109c37169bc1329fc48f7a2dca" translate="yes" xml:space="preserve">
          <source>All decryption filters work on the principle of &quot;security through obscurity.&quot; Regardless of how well you write a decryption filter and how strong your encryption algorithm is, anyone determined enough can retrieve the original source code. The reason is quite simple - once the decryption filter has decrypted the source back to its original form, fragments of it will be stored in the computer's memory as Perl parses it. The source might only be in memory for a short period of time, but anyone possessing a debugger, skill, and lots of patience can eventually reconstruct your program.</source>
          <target state="translated">모든 암호 해독 필터는 &quot;모호함을 통한 보안&quot;원칙에 따라 작동합니다. 해독 필터를 얼마나 잘 작성하고 암호화 알고리즘이 얼마나 강력한 지에 관계없이 누구나 원본 소스 코드를 검색 할 수 있습니다. 그 이유는 매우 간단합니다. 일단 해독 필터가 소스를 원래 형태로 해독 한 후에는 Perl이 구문 분석 할 때 그 조각이 컴퓨터 메모리에 저장됩니다. 소스는 짧은 시간 동안 만 메모리에있을 수 있지만 디버거, 기술 및 인내심이 많은 사람은 결국 프로그램을 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba741a80f2a14355d94b77c4ceb115a27afc7f18" translate="yes" xml:space="preserve">
          <source>All defaults for Configure can be used.</source>
          <target state="translated">구성의 모든 기본값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfa01600fe34368d13dbcac106b2c8f27f49465" translate="yes" xml:space="preserve">
          <source>All development releases of perl since 5.9.0 are covered.</source>
          <target state="translated">5.9.0 이후 펄의 모든 개발 릴리스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="df049cfa442a524a56259811400e36eee4811c18" translate="yes" xml:space="preserve">
          <source>All diagnostic output is sent to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">모든 진단 출력은 &lt;code&gt;STDERR&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="93306c0ef9fe5f266a659b8a075c1bae7f08ce4e" translate="yes" xml:space="preserve">
          <source>All dollar signs must be doubled in the $perl_code if you expect them to be interpreted normally, otherwise it will be considered a make macro. Also remember to quote make macros else it might be used as a bareword. For example:</source>
          <target state="translated">정상적으로 해석 될 것으로 예상되면 모든 달러 기호는 $ perl_code에서 두 배가되어야합니다. 그렇지 않으면 make 매크로로 간주됩니다. 또한 매크로를 인용하면 다른 단어로 사용될 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a1f8634b122edec02ff5f85c8a73c5f24ae4096" translate="yes" xml:space="preserve">
          <source>All environment vars must be stored in HKLM\Environment as strings. They are read at process startup.</source>
          <target state="translated">모든 환경 변수는 HKLM \ Environment에 문자열로 저장해야합니다. 프로세스 시작시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="92b87396d02d1c058e99dc606debd7ebb31b0abf" translate="yes" xml:space="preserve">
          <source>All error reporting is done with exceptions (die'ing).</source>
          <target state="translated">모든 오류보고는 예외 (다이닝)와 함께 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3f297670f9579dd31a61d74a21533ee88a594f" translate="yes" xml:space="preserve">
          <source>All features that combine Unicode and I/O also require using the new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see whether yours is by running &quot;perl -V&quot; and looking for &lt;code&gt;useperlio=define&lt;/code&gt; .</source>
          <target state="translated">유니 코드와 I / O를 결합한 모든 기능은 새로운 PerlIO 기능을 사용해야합니다. 그러나 대부분의 모든 Perl 5.8 플랫폼은 PerlIO를 사용합니다. &quot;perl -V&quot;를 실행하고 &lt;code&gt;useperlio=define&lt;/code&gt; 을 검색 하여 사용 중인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad80d55320f9dffac4aa0255715379a201879293" translate="yes" xml:space="preserve">
          <source>All file tests (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) except for &lt;code&gt;-t&lt;/code&gt; , which defaults to STDIN. See &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 를 제외한 모든 파일 테스트 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; ) . 기본값은 STDIN입니다. &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="815b16d15ecd8197f8c89531e6b38bdaa59c037d" translate="yes" xml:space="preserve">
          <source>All files are stored internally as &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects. Please consult the &lt;a href=&quot;tar/file&quot;&gt;Archive::Tar::File&lt;/a&gt; documentation for details.</source>
          <target state="translated">모든 파일은 내부적으로 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 로 저장 됩니다. 자세한 내용은 &lt;a href=&quot;tar/file&quot;&gt;Archive :: Tar :: File&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f073482fc073c0918a2379dd16dc7865e1091f64" translate="yes" xml:space="preserve">
          <source>All files that match any regular expression in a file</source>
          <target state="translated">파일의 정규식과 일치하는 모든 파일</target>
        </trans-unit>
        <trans-unit id="cfa975a72f5514a96c923193276bf554b250a3e3" translate="yes" xml:space="preserve">
          <source>All files used by the program or function, normally presented as a list, and what it uses them for. File names should be enclosed in F&amp;lt;&amp;gt;. It's particularly important to document files that will be potentially modified.</source>
          <target state="translated">프로그램이나 기능에서 사용하는 모든 파일 (일반적으로 목록으로 표시됨) 파일 이름은 F &amp;lt;&amp;gt;로 묶어야합니다. 잠재적으로 수정 될 파일을 문서화하는 것이 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a2dd9a73e29796f6b2de6625428d9204a9270fdb" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">모든 필터 메소드는 기존 필터가있는 경우이를 리턴하거나 존재 하지 않는 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4139db9439a578bf12cb959a5143dbafa321c592" translate="yes" xml:space="preserve">
          <source>All filter methods return the existing filter, if present, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in not.</source>
          <target state="translated">모든 필터 메소드는 존재하는 경우 기존 필터를 리턴하거나 그렇지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="311ff967643c4d237a819b285dc4b5880471f22d" translate="yes" xml:space="preserve">
          <source>All forms of the pragma enable use of the following 3 functions:</source>
          <target state="translated">모든 형태의 pragma는 다음 3 가지 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74749eec650dc1a9457b607830f24533a5ba9c1c" translate="yes" xml:space="preserve">
          <source>All four routines return the number of arguments that the subroutine returned on the Perl stack.</source>
          <target state="translated">네 가지 루틴 모두 서브 루틴이 Perl 스택에서 리턴 한 인수 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e2132ad2da2d7aa2f6043aad2cc1232db0e47df" translate="yes" xml:space="preserve">
          <source>All functions have the following rules to decide what it thinks you want:</source>
          <target state="translated">모든 기능에는 원하는 규칙을 결정하기 위해 다음 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4768442025565f5f815b90b4d35c19d4f3c9c1" translate="yes" xml:space="preserve">
          <source>All functions return 1 on success, 0 on failure. $! will be set if an error was encountered.</source>
          <target state="translated">모든 함수는 성공하면 1을, 실패하면 0을 반환합니다. $! 오류가 발생하면 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff8d7d6682320cce258b48a2cf6142f6da6f3bb" translate="yes" xml:space="preserve">
          <source>All functions that are capable of creating filehandles (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) automatically create an anonymous filehandle if the handle passed to them is an uninitialized scalar variable. This allows the constructs such as &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; to be used to create filehandles that will conveniently be closed automatically when the scope ends, provided there are no other references to them. This largely eliminates the need for typeglobs when opening filehandles that must be passed around, as in the following example:</source>
          <target state="translated">파일 핸들 (open (), opendir (), pipe (), socketpair (), sysopen (), socket () 및 accept ())을 작성할 수있는 모든 함수는 핸들이 전달 된 경우 익명 파일 핸들을 자동으로 작성합니다. 초기화되지 않은 스칼라 변수 이렇게하면 다른 참조가없는 경우 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, ...)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $fh,...)&lt;/code&gt; 과 같은 구문을 사용하여 범위가 끝나면 자동으로 닫히는 파일 핸들을 만들 수 있습니다. 그들에게. 이렇게하면 다음 예제와 같이 전달해야하는 파일 핸들을 열 때 typeglob가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c0ff391fcad9c66a86b68973a78df205636b6ef" translate="yes" xml:space="preserve">
          <source>All information required to &quot;attach&quot; back to the shared resource object &lt;b&gt;must&lt;/b&gt; be contained &lt;b&gt;only&lt;/b&gt; in the &lt;code&gt;STORABLE_freeze&lt;/code&gt; return string. Otherwise, &lt;code&gt;STORABLE_freeze&lt;/code&gt; behaves as normal for &lt;code&gt;STORABLE_attach&lt;/code&gt; classes.</source>
          <target state="translated">공유 자원 오브젝트에 &quot;연결&quot;하는 데 필요한 모든 정보 는 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 리턴 문자열 &lt;b&gt;에만&lt;/b&gt; 포함 &lt;b&gt;되어야&lt;/b&gt; 합니다. 그렇지 않으면 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 는 &lt;code&gt;STORABLE_attach&lt;/code&gt; 클래스에서 정상적으로 동작 합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ca38b7907bcdd63b3829617b4fa2da1157cda75" translate="yes" xml:space="preserve">
          <source>All inputs to WriteMakefile are Unicode characters, not just octets. EUMM seeks to handle all of these correctly. It is currently still not possible to portably use Unicode characters in module names, because this requires Perl to handle Unicode filenames, which is not yet the case on Windows.</source>
          <target state="translated">WriteMakefile에 대한 모든 입력은 8 진수가 아닌 유니 코드 문자입니다. EUMM은이 모든 것을 올바르게 처리하려고합니다. Perl이 유니 코드 파일 이름을 처리해야하므로 아직 모듈 이름으로 유니 코드 문자를 이식 가능하게 사용할 수는 없습니다. 아직 Windows에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d69ebadb686cb973f8c2cd133297ec1e0e33a51b" translate="yes" xml:space="preserve">
          <source>All invokes of</source>
          <target state="translated">모든 호출</target>
        </trans-unit>
        <trans-unit id="4ffd0a2ad25e2bbb80e9fa8d007272b04eac86d9" translate="yes" xml:space="preserve">
          <source>All list elements are numeric and come straight out of the C `struct tm'. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; , and &lt;code&gt;$hour&lt;/code&gt; are the seconds, minutes, and hours of the specified time.</source>
          <target state="translated">모든리스트 요소는 숫자이고 C`struct tm '에서 바로 나옵니다. &lt;code&gt;$sec&lt;/code&gt; , &lt;code&gt;$min&lt;/code&gt; 및 &lt;code&gt;$hour&lt;/code&gt; 는 지정된 시간의 초, 분 및 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b0cbbd027f9d74998550632f8f717d3b9830f840" translate="yes" xml:space="preserve">
          <source>All memory meant to be used with the Perl API functions should be manipulated using the macros described in this section. The macros provide the necessary transparency between differences in the actual malloc implementation that is used within perl.</source>
          <target state="translated">Perl API 기능과 함께 사용되는 모든 메모리는이 섹션에서 설명하는 매크로를 사용하여 조작해야합니다. 매크로는 perl 내에서 사용되는 실제 malloc 구현의 차이점 사이에 필요한 투명성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a9e166f6a8a9986486a965b0218230a1bd88001" translate="yes" xml:space="preserve">
          <source>All methods provided are accessible in a programmer style and in an interactive shell style.</source>
          <target state="translated">제공된 모든 메소드는 프로그래머 스타일 및 대화식 쉘 스타일로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1459ac0067a9be1ca453815893a04263c9ab6fda" translate="yes" xml:space="preserve">
          <source>All modules should be tested before distribution (using &quot;make disttest&quot;), and the tests should also be available to people installing the modules (using &quot;make test&quot;). For Module::Build you would use the &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; .</source>
          <target state="translated">모든 모듈은 배포 전에 테스트해야하며 ( &quot;make disttest&quot;사용) 모듈을 설치하는 사용자 ( &quot;make test&quot;사용)도 테스트를 수행 할 수 있습니다. Module :: Build의 경우 &lt;code&gt;make test&lt;/code&gt; equivalent &lt;code&gt;perl Build test&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="45a75ffb3c37d77e5c140116de26483a43d3e7a6" translate="yes" xml:space="preserve">
          <source>All objects belong to a specific class. For example, our</source>
          <target state="translated">모든 객체는 특정 클래스에 속합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="758a43e77b8dfcfe840782d07ab7ccfb64e67a82" translate="yes" xml:space="preserve">
          <source>All of Perl's internal functions which will be exposed to the outside world are prefixed by &lt;code&gt;Perl_&lt;/code&gt; so that they will not conflict with XS functions or functions used in a program in which Perl is embedded. Similarly, all global variables begin with &lt;code&gt;PL_&lt;/code&gt; . (By convention, static functions start with &lt;code&gt;S_&lt;/code&gt; .)</source>
          <target state="translated">외부 세계에 노출 될 모든 Perl의 내부 함수는 &lt;code&gt;Perl_&lt;/code&gt; 이 앞에 붙어서 Perl이 내장 된 프로그램에서 사용되는 XS 함수 또는 함수와 충돌하지 않습니다. 마찬가지로 모든 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 로 시작합니다 . (일반적으로 정적 함수는 &lt;code&gt;S_&lt;/code&gt; 로 시작 합니다.)</target>
        </trans-unit>
        <trans-unit id="f0201779d13335d0611380b1efaab78cf7d99ae8" translate="yes" xml:space="preserve">
          <source>All of Perl's source code is kept centrally in a Git repository at</source>
          <target state="translated">Perl의 모든 소스 코드는 중앙의 Git 저장소에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="f5c3cc30932079fdea98918bb1694882d908dc3a" translate="yes" xml:space="preserve">
          <source>All of the above special cases can occasionally cause some problems. See &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;BUGS and CAVEATS&lt;/a&gt;.</source>
          <target state="translated">위의 모든 특수한 경우에 때때로 문제가 발생할 수 있습니다. &lt;a href=&quot;#BUGS-and-CAVEATS&quot;&gt;버그 및주의 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e73d4a25ee89208a71c06aba4a44554f2676c3f" translate="yes" xml:space="preserve">
          <source>All of the core documentation intended for end users lives in</source>
          <target state="translated">최종 사용자를위한 모든 핵심 문서</target>
        </trans-unit>
        <trans-unit id="8bb2fabac85e17c62678907ad7293e4a29bfd44a" translate="yes" xml:space="preserve">
          <source>All of the following SvREFCNT_inc* macros are optimized versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</source>
          <target state="translated">다음 SvREFCNT_inc * 매크로는 모두 SvREFCNT_inc의 최적화 된 버전이며 SvREFCNT_inc로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ef093e61dfa9c43730994ceca5ef32106472a3" translate="yes" xml:space="preserve">
          <source>All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.</source>
          <target state="translated">다음은 모두 도움이되었습니다. 버그 보고서, 패치, 도덕적 지원 또는 격려의 말이 다가올 것입니다.</target>
        </trans-unit>
        <trans-unit id="7491564d89215b867c8e0fd7859217a07aea983b" translate="yes" xml:space="preserve">
          <source>All of the following print &quot;ok&quot; or &quot;not ok&quot; depending on if the test succeeded or failed. They all also return true or false, respectively.</source>
          <target state="translated">테스트 성공 또는 실패 여부에 따라 다음 인쇄가 모두 &quot;확인&quot;또는 &quot;확인되지 않음&quot;입니다. 또한 모두 각각 true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41e3b701113b5066b37e3af11d04cea9cb6499ec" translate="yes" xml:space="preserve">
          <source>All of these functions will croak on read-only scalars (see the previous section for more on those).</source>
          <target state="translated">이러한 함수는 모두 읽기 전용 스칼라에서 작동하지 않습니다 (자세한 내용은 이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="4ff83273a3484775dac4d0e13bc9dfb2d37a34a0" translate="yes" xml:space="preserve">
          <source>All of these interact with or use &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; which is worth understanding the basics of when building a website in Perl (there is a lot of useful &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack::Middleware&lt;/a&gt;).</source>
          <target state="translated">이들 모두는 Perl에서 웹 사이트를 만들 때의 기본 사항을 이해할 가치가있는 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 상호 작용하거나 사용합니다 (유용한 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%253A%253Amiddleware&quot;&gt;Plack :: Middleware&lt;/a&gt; 가 많이 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="669764792c2fd17c1b68c9548896f6adc424fb5e" translate="yes" xml:space="preserve">
          <source>All of this is especially useful when perl is embedded in some other program, where output to STDOUT and STDERR may have to be redirected in some special way. See nvi and the Apache module for examples.</source>
          <target state="translated">이 모든 것은 특히 perl이 다른 프로그램에 임베드 될 때 특히 유용하며, STDOUT 및 STDERR 로의 출력을 특별한 방식으로 경로 재지 정해야 할 수도 있습니다. 예제는 nvi 및 Apache 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9469b3540381c36cb61f1bd013bbc92d5d1e0fa" translate="yes" xml:space="preserve">
          <source>All of this occurs in the routine &lt;code&gt;study_chunk()&lt;/code&gt; which uses a special structure &lt;code&gt;scan_data_t&lt;/code&gt; to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</source>
          <target state="translated">이 모든 것은 특별한 구조 &lt;code&gt;scan_data_t&lt;/code&gt; 를 사용하여 수행 한 분석을 저장하고 &quot;peep-hole&quot;최적화를 수행 하는 일반적인 &lt;code&gt;study_chunk()&lt;/code&gt; 에서 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="52f1e1f474a63fabc7410cc13bd34f20b84caea7" translate="yes" xml:space="preserve">
          <source>All of those strange functions with</source>
          <target state="translated">이상한 기능은 모두</target>
        </trans-unit>
        <trans-unit id="bd329654decca432a697c3105f88903a2261a243" translate="yes" xml:space="preserve">
          <source>All open handles are dup()-ed in pseudo-processes, so that closing any handles in one process does not affect the others. See below for some limitations.</source>
          <target state="translated">모든 열린 핸들은 의사 프로세스에서 dup ()으로 처리되므로 한 프로세스에서 핸들을 닫으면 다른 프로세스에는 영향을 미치지 않습니다. 몇 가지 제한 사항은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f714b09d9b62651db015cac63428a3e648501bda" translate="yes" xml:space="preserve">
          <source>All operations above are performed simultaneously, left to right.</source>
          <target state="translated">위의 모든 작업은 왼쪽에서 오른쪽으로 동시에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2c5dee63173bc6728f471c2ffbe6ede7b9622657" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</source>
          <target state="translated">큰 부동 소수점 숫자를 다음과 같이 선언하면 모든 연산자 (기본 수학 연산 포함)가 오버로드됩니다</target>
        </trans-unit>
        <trans-unit id="47240c2bd1c42148438e132fbe97c4470bd81a8b" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded if you declare your big integers as</source>
          <target state="translated">큰 정수를 다음과 같이 선언하면 모든 연산자 (기본 수학 연산 포함)가 오버로드됩니다</target>
        </trans-unit>
        <trans-unit id="8aea450e6db040db0c87b5e94c4f04af81589adb" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) are overloaded. Integer and floating-point constants are created as proper BigInts or BigFloats, respectively.</source>
          <target state="translated">모든 수학 연산자 (기본 수학 연산 포함)에 과부하가 걸렸습니다. 정수 및 부동 소수점 상수는 각각 적절한 BigInts 또는 BigFloats로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="97e8744f2aba4f4c5299d3315f0e922fa7662452" translate="yes" xml:space="preserve">
          <source>All operators (including basic math operations) except the range operator &lt;code&gt;..&lt;/code&gt; are overloaded. Integer constants are created as proper BigInts.</source>
          <target state="translated">범위 연산자 제외 (기본 수학 연산 포함) 모든 사업자는 &lt;code&gt;..&lt;/code&gt; 오버로드. 정수 상수는 적절한 BigInts로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d94d5908e53102da28ed793d2b7b1e3aac035e25" translate="yes" xml:space="preserve">
          <source>All options are passed either via the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, or via an explicit &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 옵션은 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 또는 명시 적 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 를 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6af1c2304a59b49a5e4c4bb3624f5d7d2569e662" translate="yes" xml:space="preserve">
          <source>All other arguments are optional and should correspond to filehandles to read from or the names of input files containing POD sections. A file name of &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; will be interpreted to mean standard input (which is the default if no arguments are given).</source>
          <target state="translated">다른 모든 인수는 선택 사항이며 읽을 파일 핸들 또는 POD 섹션이 포함 된 입력 파일 이름과 일치해야합니다. &quot;&quot;, &quot;-&quot;또는 &quot;&amp;lt;&amp;amp; STDIN&quot;파일 이름은 표준 입력을 의미하는 것으로 해석됩니다 (인수가 지정되지 않은 경우 기본값 임).</target>
        </trans-unit>
        <trans-unit id="7f44679a6de4260413fa97b63aefa6bbb62b1b1f" translate="yes" xml:space="preserve">
          <source>All other code points corresponding to Unicode characters, including private use and those yet to be assigned, are never considered malformed and never warn.</source>
          <target state="translated">개인용 및 아직 할당되지 않은 코드를 포함하여 유니 코드 문자에 해당하는 다른 모든 코드 포인트는 잘못된 것으로 간주되어 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9abb59ed9447dcd04c7f87e709793152669bc13e" translate="yes" xml:space="preserve">
          <source>All other errors may be trapped using the modern interface, otherwise they will be &lt;code&gt;carp&lt;/code&gt; ed about. Program execution will not be halted.</source>
          <target state="translated">다른 모든 오류는 그렇지 않은 경우가있을 것입니다, 현대적인 인터페이스를 사용하여 포획 할 수있다 &lt;code&gt;carp&lt;/code&gt; 에 대한 에디션. 프로그램 실행이 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87f6ed6f32251cf3d91bc227de27a29b35179c3f" translate="yes" xml:space="preserve">
          <source>All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &amp;lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.</source>
          <target state="translated">다른 모든 구현 된 반올림 스타일은 &quot;가장 가까운 자리&quot;로 반올림합니다. 반올림 자리 오른쪽에있는 숫자 D (소수점 건너 뛰기)가 5보다 큰 경우, 반올림 자리에서 숫자가 증가합니다 (증가 연속 발생 가능). 예를 들어 단위로 반올림하는 경우 0.9는 1로 반올림됩니다 -19.9는 -20으로 반올림됩니다. D &amp;lt;5 인 경우 반올림 위치에서 숫자가 비슷하게 잘립니다 (예 : 단위로 반올림 할 때 0.4는 0으로, -19.4는 -19로 반올림).</target>
        </trans-unit>
        <trans-unit id="0673283fae5e4cb931ef195f174d0d6b1d1f68b5" translate="yes" xml:space="preserve">
          <source>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</source>
          <target state="translated">다른 모든 메소드는 인수 중 하나 (또는 ​​모두)가 $ upgrade에 언급 된 클래스에 해당하는 경우에만 자체적으로 업그레이드됩니다 (이는 이후 버전에서보다 복잡한 스키마로 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="5e2040cfcc351c3e2d5a5185b8c874a98a40126c" translate="yes" xml:space="preserve">
          <source>All other object methods and overloaded functions can be directly inherited from the parent class.</source>
          <target state="translated">다른 모든 객체 메소드와 오버로드 된 함수는 부모 클래스에서 직접 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83a0c68243d6a9c451b88def8620109da8b38fe" translate="yes" xml:space="preserve">
          <source>All other parameters that control the content of the gzip header will be ignored if this parameter is set to 1.</source>
          <target state="translated">이 매개 변수가 1로 설정되면 gzip 헤더의 내용을 제어하는 ​​다른 모든 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c37ee1b0941f972f146000c72b7c3b6715243db" translate="yes" xml:space="preserve">
          <source>All possible messages the program can print out and what they mean. You may wish to follow the same documentation style as the Perl documentation; see perldiag(1) for more details (and look at the POD source as well).</source>
          <target state="translated">프로그램이 인쇄 할 수있는 모든 가능한 메시지와 그 의미. Perl 문서와 동일한 문서 스타일을 따르기를 원할 수 있습니다. 자세한 내용은 perldiag (1)를 참조하십시오 (및 POD 소스도 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="604e2a22c32db1e7a6f30a5a33e18c36a9822954" translate="yes" xml:space="preserve">
          <source>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</source>
          <target state="translated">인쇄 가능한 모든 문자 (모든 그래픽 문자 세트와 제어되지 않는 공백 문자)</target>
        </trans-unit>
        <trans-unit id="5f0cb252127c0b51324ce6af0cb1b37825719005" translate="yes" xml:space="preserve">
          <source>All questions related to building for WinCE devices could be asked in</source>
          <target state="translated">WinCE 장치 구축과 관련된 모든 질문은</target>
        </trans-unit>
        <trans-unit id="af228b0481468b2f1d341e2655d2bfbf46fb813b" translate="yes" xml:space="preserve">
          <source>All references to line numbers by the program (warnings, errors, ...) will treat the &lt;code&gt;#!&lt;/code&gt; line as the first line. Thus a warning on the 2nd line of the program, which is on the 100th line in the file will be reported as line 2, not as line 100. This can be overridden by using the &lt;code&gt;#line&lt;/code&gt; directive. (See &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;Plain Old Comments (Not!) in perlsyn&lt;/a&gt;)</source>
          <target state="translated">프로그램에서 행 번호에 대한 모든 참조 (경고, 오류 등)는 &lt;code&gt;#!&lt;/code&gt; 첫 줄로. 따라서 파일의 100 번째 행에있는 프로그램의 두 번째 행에 대한 경고는 100 행이 아니라 2 행으로보고됩니다 . &lt;code&gt;#line&lt;/code&gt; 지시문 을 사용하여이를 무시할 수 있습니다 . ( &lt;a href=&quot;perlsyn#Plain-Old-Comments-(Not!)&quot;&gt;perlsyn의 Plain Old Comments (Not!)&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e60ba7561109a1c032c7ac0364a6dfa0ffa088bc" translate="yes" xml:space="preserve">
          <source>All results share some common attributes:</source>
          <target state="translated">모든 결과는 몇 가지 공통된 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="1a067ae12ba3c0d999a29e551f40bb7142e1e1b0" translate="yes" xml:space="preserve">
          <source>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</source>
          <target state="translated">모든 반올림 함수는 'even', 'odd', '+ inf', '-inf', 'zero', 'trunc'또는 'common'중 하나에서 반올림 모드를 두 번째 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2b331c6fdc80ccf345de0513f8a62b9eab6492a7" translate="yes" xml:space="preserve">
          <source>All routines expect to be given real or complex numbers. Don't attempt to use BigFloat, since Perl has currently no rule to disambiguate a '+' operation (for instance) between two overloaded entities.</source>
          <target state="translated">모든 루틴에는 실수 또는 복소수가 부여됩니다. Perl은 현재 두 개의 오버로드 된 엔티티 사이에서 '+'조작을 명확하게하는 규칙이 없으므로 BigFloat를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e55cf27d1ee5fe9a7d51e12a991cd2052b26c3ef" translate="yes" xml:space="preserve">
          <source>All single forms are Perl extensions; a few compound forms are as well, and are noted as such.</source>
          <target state="translated">모든 단일 형식은 Perl 확장입니다. 소수의 화합물 형태도 마찬가지로 주목된다.</target>
        </trans-unit>
        <trans-unit id="47270bc8154b38c6bf8c6928d77cd1d441578544" translate="yes" xml:space="preserve">
          <source>All stable releases of perl since 5.6.0 are covered.</source>
          <target state="translated">5.6.0 이후 펄의 모든 안정된 릴리스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eab81422eaa753ceb04583bd0ca24dcc4c83f889" translate="yes" xml:space="preserve">
          <source>All subpatterns, either delivered as a list-context result or as &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="translated">목록 컨텍스트 결과 또는 &lt;code&gt;$1&lt;/code&gt; 로 전달되는 모든 하위 패턴</target>
        </trans-unit>
        <trans-unit id="48589ddd875d011fdf990744a29e7ccd3465ffa6" translate="yes" xml:space="preserve">
          <source>All subsequent characters can be letters, numbers (0-9), hyphens (-), underscores (_), colons (:), and periods (.).</source>
          <target state="translated">모든 후속 문자는 문자, 숫자 (0-9), 하이픈 (-), 밑줄 (_), 콜론 (:) 및 마침표 (.) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ba1038004475ab41cd7a5ef01656aad2449ad3" translate="yes" xml:space="preserve">
          <source>All systems use the virtual &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to represent a line terminator, called a &quot;newline&quot;. There is no such thing as an unvarying, physical newline character. It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Not all systems read &lt;code&gt;&quot;\r&quot;&lt;/code&gt; as ASCII CR and &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as ASCII LF. For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without a line terminator, printing &lt;code&gt;&quot;\n&quot;&lt;/code&gt; might emit no actual data. In general, use &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character. For example, most networking protocols expect and prefer a CR+LF (&lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; or &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; ) for line terminators, and although they often accept just &lt;code&gt;&quot;\012&quot;&lt;/code&gt; , they seldom tolerate just &lt;code&gt;&quot;\015&quot;&lt;/code&gt; . If you get in the habit of using &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for networking, you may be burned some day.</source>
          <target state="translated">모든 시스템은 가상 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하여 &quot;newline&quot;이라고하는 줄 종결자를 나타냅니다. 변치 않는 물리적 개행 문자와 같은 것은 없습니다. 운영 체제, 장치 드라이버, C 라이브러리 및 Perl이 모두 보존하기 위해 모방하는 것은 환상 일뿐입니다. 모든 시스템이 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 을 ASCII CR로 읽고 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 ASCII LF로 읽는 것은 아닙니다 . 예를 들어, 과거의 고대 Mac (MacOS X 이전)에서는 역전이 있었으며 줄 종결자가없는 시스템에서는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 인쇄시 실제 데이터가 출력 되지 않을 수 있습니다. 일반적으로 시스템에 &quot;줄 바꾸기&quot;를 의미 할 때는 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 사용하고 정확한 문자가 필요할 때는 리터럴 ASCII를 사용하십시오. 예를 들어대부분의 네트워킹 프로토콜은 CR + LF를 예상하고 선호합니다 ( &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 줄 종결 &lt;code&gt;&quot;\cM\cJ&quot;&lt;/code&gt; 경우에는 &quot;\ cM \ cJ&quot; )를 사용하고 종종 &lt;code&gt;&quot;\012&quot;&lt;/code&gt; 만 허용하지만 &lt;code&gt;&quot;\015&quot;&lt;/code&gt; 만 허용하는 경우는 거의 없습니다 . 네트워킹에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 사용하는 습관이 있으면 언젠가 화상을 입을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8ea7b6eceda9fa2e8d1025a7231d980eabe21a" translate="yes" xml:space="preserve">
          <source>All test functions take a name argument. It's optional, but highly suggested that you use it.</source>
          <target state="translated">모든 테스트 함수에는 이름 인수가 사용됩니다. 선택 사항이지만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="08563314f6fd252cfab4add5f5d112e141d01e88" translate="yes" xml:space="preserve">
          <source>All tests are run in scalar context. So this:</source>
          <target state="translated">모든 테스트는 스칼라 컨텍스트에서 실행됩니다. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="9e1df8eee4a1033ecd0a19707416e97c2ada1eab" translate="yes" xml:space="preserve">
          <source>All tests should succeed (with some of them skipped). If you have the same version of Perl installed, it is crucial that you have &lt;code&gt;.&lt;/code&gt; early in your LIBPATH (or in BEGINLIBPATH), otherwise your tests will most probably test the wrong version of Perl.</source>
          <target state="translated">모든 테스트는 성공해야합니다 (일부는 생략). 동일한 버전의 Perl이 설치되어 있으면 반드시 설치해야 &lt;code&gt;.&lt;/code&gt; 초기에 LIBPATH (또는 BEGINLIBPATH)에서 그렇지 않으면 테스트에서 잘못된 버전의 Perl을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="525c6957ea6de35e124ab99764227b6cdf29f16d" translate="yes" xml:space="preserve">
          <source>All tests were conducted on the oldest supported AIX technology level with the latest support package applied. If the tested AIX version is out of support (AIX 4.3.3, 5.1, 5.2) then the last available support level was used.</source>
          <target state="translated">모든 테스트는 최신 지원 패키지가 적용된 가장 오래된 지원되는 AIX 기술 수준에서 수행되었습니다. 테스트 된 AIX 버전이 지원되지 않는 경우 (AIX 4.3.3, 5.1, 5.2) 사용 가능한 마지막 지원 레벨이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="39ef06ab79291a214e8f7d5dbacda492f3f9bc96" translate="yes" xml:space="preserve">
          <source>All the</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="6adc75ada238ccb6959bf3be512aa6c8d041cf3e" translate="yes" xml:space="preserve">
          <source>All the DLLs built with the current versions of Perl have ID strings identifying the name of the extension, its version, and the version of Perl required for this DLL. Run &lt;code&gt;bldlevel DLL-name&lt;/code&gt; to find this info.</source>
          <target state="translated">현재 버전의 Perl로 빌드 된 모든 DLL에는 확장명, 버전 및이 DLL에 필요한 Perl 버전을 식별하는 ID 문자열이 있습니다. 이 정보를 찾으 &lt;code&gt;bldlevel DLL-name&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf0f04a776f7c27f1c272831fed2f282bc5d62df" translate="yes" xml:space="preserve">
          <source>All the above &quot;don't&quot;:s may look daunting, and they are, but the key is to degrade gracefully if one cannot reach the particular network service one wants. Croaking or hanging do not look very professional.</source>
          <target state="translated">위의 모든 &quot;하지 말아야 할 것&quot;는 어려워 보일 수 있지만, 핵심은 원하는 특정 네트워크 서비스에 도달 할 수없는 경우 우아하게 저하시키는 것입니다. 삐걱 거리거나 매달리는 것은 매우 전문적으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b15325c472386a4b2fcce8cfa22d048d90743b2" translate="yes" xml:space="preserve">
          <source>All the above operations</source>
          <target state="translated">위의 모든 작업</target>
        </trans-unit>
        <trans-unit id="18c65db4629a7b0de1b15db2854f6c3f0396dc3a" translate="yes" xml:space="preserve">
          <source>All the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.</source>
          <target state="translated">이 문서에 포함 된 모든 조언은 숙련 된 CPAN 작성자 및 사용자와의 광범위한 대화에서 수집되었습니다. 여기에 제공된 모든 조언은 이전 실수의 결과입니다. 이 정보는 동일한 실수와 실수를 해결하기 위해 필연적으로 필요한 추가 작업을 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="035cec5a0531d1b6a2296cd59ca2814d6d18a1bb" translate="yes" xml:space="preserve">
          <source>All the binary operators left associate; &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; is higher precedence than the others, which all have equal precedence. The unary operator right associates, and has highest precedence. Thus this follows the normal Perl precedence rules for logical operators. Use parentheses to override the default precedence and associativity.</source>
          <target state="translated">모든 이진 연산자는 연결되어 있습니다. &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 는 다른 것들보다 우선 순위가 높으며 모두 우선 순위가 동일합니다. 단항 연산자 권한이 연관되며 우선 순위가 가장 높습니다. 따라서 이것은 논리 연산자에 대한 일반적인 Perl 우선 순위 규칙을 따릅니다. 괄호를 사용하여 기본 우선 순위 및 연관성을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d917ce9244febe094ff576631bcd960c5f5696" translate="yes" xml:space="preserve">
          <source>All the common mathematical functions defined on real numbers that are extended to complex numbers share that same property of working</source>
          <target state="translated">복소수로 확장되는 실수로 정의 된 모든 일반적인 수학 함수는 동일한 작업 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c39940047cd8d69a382c58b19f467066fdda2d58" translate="yes" xml:space="preserve">
          <source>All the common operations that can be performed on a real number have been defined to work on complex numbers as well, and are merely</source>
          <target state="translated">실수로 수행 할 수있는 모든 공통 연산은 복소수에서도 작동하도록 정의되었으며 단지</target>
        </trans-unit>
        <trans-unit id="af40a4a3889be35304f9f526d3725dd711506782" translate="yes" xml:space="preserve">
          <source>All the constants defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.</source>
          <target state="translated">아래 정의 된 메소드의 플래그 매개 변수에 사용하기 위해 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; 에 정의 된 모든 상수도 사용 가능합니다. 플래그 값의 정확한 의미는 Berkeley DB 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90dde32e9abf15d2dcbf6ab5b218367d1761ce60" translate="yes" xml:space="preserve">
          <source>All the data uses to generate the &lt;code&gt;%Extensions&lt;/code&gt; hash is already present in the &lt;code&gt;Config&lt;/code&gt; module, but not in such a convenient format to quickly reference.</source>
          <target state="translated">&lt;code&gt;%Extensions&lt;/code&gt; 해시 를 생성하는 데 사용되는 모든 데이터 는 이미 &lt;code&gt;Config&lt;/code&gt; 모듈에 있지만 신속하게 참조 할 수있는 편리한 형식은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d00162e91300896732fceff8f7c85a986709fae" translate="yes" xml:space="preserve">
          <source>All the examples so far have shown objects based on a blessed hash. However, it's possible to bless any type of data structure or referent, including scalars, globs, and subroutines. You may see this sort of thing when looking at code in the wild.</source>
          <target state="translated">지금까지의 모든 예제는 복된 해시를 기반으로 객체를 보여주었습니다. 그러나 스칼라, 글로브 및 서브 루틴을 포함한 모든 유형의 데이터 구조 또는 참조를 축복 할 수 있습니다. 야생에서 코드를 볼 때 이런 종류의 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f288780205f670aaf71d07523bf6fc9a50b071fd" translate="yes" xml:space="preserve">
          <source>All the exportable functions are listed below -- you're free to import only some, or none at all. By default, none are imported. If you say:</source>
          <target state="translated">내보낼 수있는 모든 기능이 아래에 나열되어 있습니다. 일부만 가져 오거나 전혀 가져올 수 없습니다. 기본적으로 아무 것도 가져 오지 않습니다. 당신이 말하는 경우:</target>
        </trans-unit>
        <trans-unit id="dc02c5d731db84c233601bd3b09aab07385ecc22" translate="yes" xml:space="preserve">
          <source>All the functions defined in &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; are available except for close() and dbopen() itself. The &lt;b&gt;DB_File&lt;/b&gt; method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:</source>
          <target state="translated">close () 및 dbopen () 자체를 제외하고 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen에&lt;/a&gt; 정의 된 모든 함수를 사용할 수 있습니다. 지원되는 함수에 대한 &lt;b&gt;DB_File&lt;/b&gt; 메소드 인터페이스는 Berkeley DB가 가능할 때마다 작동하는 방식을 반영하도록 구현되었습니다. 특히 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="85af2ce50ee2f541004fc9d53df5f4d00e80abb3" translate="yes" xml:space="preserve">
          <source>All the functions may be imported using the &lt;code&gt;:ALL&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; 태그를 사용하여 모든 기능을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e17de002dfef54a49f116af6d04ace151f1db1a1" translate="yes" xml:space="preserve">
          <source>All the functions return an integer. This is a count of the number of items returned by the Perl subroutine. The actual items returned by the subroutine are stored on the Perl stack.</source>
          <target state="translated">모든 함수는 정수를 반환합니다. Perl 서브 루틴이 리턴 한 항목 수입니다. 서브 루틴이 리턴 한 실제 항목은 Perl 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="52532a7385f2fd6662a92f143b996eb16f224ae0" translate="yes" xml:space="preserve">
          <source>All the gzip headers defined in RFC 1952 can be created using this module.</source>
          <target state="translated">RFC 1952에 정의 된 모든 gzip 헤더는이 모듈을 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51037cd1e5bef0efdf785304da29a37a7b0cdc06" translate="yes" xml:space="preserve">
          <source>All the modules and switches just described can be used in v5.20 with just plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and, should the input locales not be UTF-8, you'll get the less than ideal behavior, described below, that you get with pre-v5.16 Perls, or when you use the locale pragma without the &lt;code&gt;:not_characters&lt;/code&gt; parameter in v5.16 and v5.18. If you are using exclusively UTF-8 locales in v5.20 and higher, the rest of this section does not apply to you.</source>
          <target state="translated">방금 설명한 모든 모듈과 스위치는 v5.20에서 평범한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로 사용할 수 있으며 입력 로케일이 UTF-8이 아닌 경우 아래에서 설명한 이상적이지 않은 동작을 얻을 수 있습니다. -v5.16 Perls 또는 v5.16 및 v5.18에서 &lt;code&gt;:not_characters&lt;/code&gt; 매개 변수 없이 로케일 pragma를 사용하는 경우 v5.20 이상에서 UTF-8 로케일을 독점적으로 사용하는 경우이 섹션의 나머지 부분은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcfac1e4c22e90a7b2f875c6b72f2c0d403c1be" translate="yes" xml:space="preserve">
          <source>All the operators which need an argument in the integer format treat the argument as in modular arithmetic, e.g., &lt;code&gt;mod 2**32&lt;/code&gt; on a 32-bit architecture. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; therefore provides the same result as &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; .</source>
          <target state="translated">정수 형식의 인수가 필요한 모든 연산자는 인수를 모듈 식 산술과 같이 취급합니다 (예 : 32 비트 아키텍처의 경우 &lt;code&gt;mod 2**32&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, -1&lt;/code&gt; 따라서 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; &quot;%u&quot;, ~0&lt;/code&gt; 과 동일한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a4fb9683d7bd9f1429d51b7805c318a33084783c" translate="yes" xml:space="preserve">
          <source>All the other macros which will be used in this example require you to have used this macro.</source>
          <target state="translated">이 예제에서 사용될 다른 모든 매크로는이 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b08b2f77f4eeb817def95bb1cac60c09fd5e4ffe" translate="yes" xml:space="preserve">
          <source>All the others are scalar types, that is, things that can be bound to a &lt;code&gt;$&lt;/code&gt; variable. For these, the internal types are mostly orthogonal to types in the Perl language.</source>
          <target state="translated">다른 모든 것은 스칼라 유형, 즉 &lt;code&gt;$&lt;/code&gt; 변수에 바인딩 할 수있는 것입니다 . 이를 위해 내부 유형은 대부분 Perl 언어의 유형과 직교합니다.</target>
        </trans-unit>
        <trans-unit id="813e0349f99be3e1ec9a99a0d6e9329cddd2f012" translate="yes" xml:space="preserve">
          <source>All the properties that begin with &lt;code&gt;\p&lt;/code&gt; (and its inverse &lt;code&gt;\P&lt;/code&gt; ) are actually character classes that are Unicode-aware. There are dozens of them, see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 시작하는 모든 속성 (및 그 역 &lt;code&gt;\P&lt;/code&gt; )은 실제로 유니 코드를 인식하는 문자 클래스입니다. 수십 가지가 있습니다 ( &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="0b65a75a2da1466ad79df3a0e8287f617c933054" translate="yes" xml:space="preserve">
          <source>All the sequences and escapes</source>
          <target state="translated">모든 순서와 탈출</target>
        </trans-unit>
        <trans-unit id="6f5a47adb9e53e6ad59a65ed39b02f84d8f84ac1" translate="yes" xml:space="preserve">
          <source>All the supported functions should be called as methods, i.e., either as</source>
          <target state="translated">지원되는 모든 함수는 메소드로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e345efa9c5194482201d78c3449d77663639ae8" translate="yes" xml:space="preserve">
          <source>All the talk in the world is useless without an implementation. In almost every case, the person or people who argue for a new feature will be expected to be the ones who implement it. Porters capable of coding new features have their own agendas, and are not available to implement your (possibly good) idea.</source>
          <target state="translated">세상의 모든 대화는 구현 없이는 쓸모가 없습니다. 거의 모든 경우에, 새로운 기능을 주장하는 사람 또는 사람들은 그것을 구현하는 사람 일 것으로 예상됩니다. 새로운 기능을 코딩 할 수있는 포터는 자신의 의제를 가지고 있으며 (아마도 좋은) 아이디어를 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a484c468483007c96c3a2efbbc829000cb69672" translate="yes" xml:space="preserve">
          <source>All the usual warnings about file locking apply here. In particular, note that file locking in Perl is &lt;b&gt;advisory&lt;/b&gt;, which means that holding a lock will not prevent anyone else from reading, writing, or erasing the file; it only prevents them from getting another lock at the same time. Locks are analogous to green traffic lights: If you have a green light, that does not prevent the idiot coming the other way from plowing into you sideways; it merely guarantees to you that the idiot does not also have a green light at the same time.</source>
          <target state="translated">파일 잠금에 대한 모든 일반적인 경고가 여기에 적용됩니다. 특히, Perl의 파일 잠금은 &lt;b&gt;권고&lt;/b&gt; 사항입니다. 잠금 을 유지한다고해서 다른 사람이 파일을 읽거나 쓰거나 지우는 것을 막을 수는 없습니다. 단지 동시에 다른 잠금을 얻지 못하게합니다. 자물쇠는 초록색 신호등과 유사합니다. 초록색 표시등이 있어도 반대 방향으로 오는 바보가 옆으로 쟁기질하는 것을 막을 수는 없습니다. 단지 바보가 동시에 녹색 빛을 가지고 있지 않다는 것을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="7e349ac65c026bbc32c4eb141cc9c0c2c6c1c9d7" translate="yes" xml:space="preserve">
          <source>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</source>
          <target state="translated">숫자 변환의 모든 작업은 % subr 및 num ()에서 수행됩니다. 물론 % subr은 완전하지 않으며 아래 예제에 사용 된 연산자 만 포함합니다. 여기에 여분의 질문이 있습니다 : 왜 num ()에서 명시적인 재귀가 필요한가요? (이 섹션의 끝에 답변이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0f15e65c6cfe10e49621033c9085af7927a8ea20" translate="yes" xml:space="preserve">
          <source>All these commands are callable via method interface and have names which conform to standard conventions with the leading &lt;code&gt;rl_&lt;/code&gt; stripped.</source>
          <target state="translated">이러한 모든 명령은 메소드 인터페이스를 통해 호출 할 수 있으며 선행 &lt;code&gt;rl_&lt;/code&gt; 을 제거한 표준 규칙을 따르는 이름을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1a68fff09705709c0c5d238842991f6619aad537" translate="yes" xml:space="preserve">
          <source>All these flags require &lt;b&gt;-DDEBUGGING&lt;/b&gt; when you compile the Perl executable (but see &lt;code&gt;:opd&lt;/code&gt; in &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; or &lt;a href=&quot;re#'debug'-mode&quot;&gt;'debug' mode in re&lt;/a&gt; which may change this). See the</source>
          <target state="translated">이러한 모든 플래그는 필요 &lt;b&gt;-DDEBUGGING&lt;/b&gt; 는 펄 실행 파일을 컴파일 (하지만 볼 때 &lt;code&gt;:opd&lt;/code&gt; 에서 &lt;a href=&quot;devel/peek&quot;&gt;(STABLE) : 픽&lt;/a&gt; 또는 &lt;a href=&quot;re#'debug'-mode&quot;&gt;재에서 '디버그'모드&lt;/a&gt; 이 변경 될 수 있습니다). 참조</target>
        </trans-unit>
        <trans-unit id="4fa65daee4b35c0bdf01aba1673c1bba399f82d9" translate="yes" xml:space="preserve">
          <source>All these lines will have the same effect on the state of the $md5 object:</source>
          <target state="translated">이 모든 행은 $ md5 객체의 상태에 동일한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9bcd9b22dce2b631b5e9d54d48830f4469977758" translate="yes" xml:space="preserve">
          <source>All these variables have no effect on a newer Perl which supports the relevant feature.</source>
          <target state="translated">이러한 모든 변수는 관련 기능을 지원하는 최신 Perl에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75179ef80cbabbf7cf9ad45aff86010dedc268e1" translate="yes" xml:space="preserve">
          <source>All this obviously requires a way for the Perl internal functions to be either subroutines taking some kind of structure as the first argument, or subroutines taking nothing as the first argument. To enable these two very different ways of building the interpreter, the Perl source (as it does in so many other situations) makes heavy use of macros and subroutine naming conventions.</source>
          <target state="translated">이 모든 것은 분명히 Perl 내부 함수가 어떤 종류의 구조를 첫 번째 인수로 사용하는 서브 루틴이거나 첫 번째 인수로 아무것도 수행하지 않는 서브 루틴이어야합니다. 이 두 가지 매우 다른 방식으로 인터프리터를 빌드하기 위해 Perl 소스는 다른 많은 상황에서와 같이 매크로 및 서브 루틴 이름 지정 규칙을 많이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="05bb57d634b2fcc45dc9babcad96740ee2e8f313" translate="yes" xml:space="preserve">
          <source>All this should be handled automatically by the hints file, if requested.</source>
          <target state="translated">요청 된 경우이 모든 것이 힌트 파일에 의해 자동으로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7381ecad8164c50156cc34405ade99393869ea97" translate="yes" xml:space="preserve">
          <source>All those functions (red(), blue(), green(), etc.) appear to be separate, but the real code in the closure actually was compiled only once.</source>
          <target state="translated">모든 함수 (red (), blue (), green () 등)는 별개의 것으로 보이지만 클로저의 실제 코드는 실제로 한 번만 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="1eb3cfb093a32021b17dfa327362fe2a1ecb7499" translate="yes" xml:space="preserve">
          <source>All threads blocking on &lt;code&gt;dequeue()&lt;/code&gt; calls will be unblocked with any remaining items in the queue and/or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned. Any subsequent calls to &lt;code&gt;dequeue()&lt;/code&gt; will behave like &lt;code&gt;dequeue_nb()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dequeue()&lt;/code&gt; 호출 에 대한 모든 스레드 차단은 대기열에 남아있는 항목 및 / 또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환 되어 차단 해제됩니다 . 이후의 &lt;code&gt;dequeue()&lt;/code&gt; 호출 은 &lt;code&gt;dequeue_nb()&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="31b59027aac85c24edba2402c4b5479124b0b5b8" translate="yes" xml:space="preserve">
          <source>All three APIs &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; , and &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; are designed to allocate no memory if used</source>
          <target state="translated">세 가지 API &lt;code&gt;fill_mstats($buf)&lt;/code&gt; , &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 및 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 는 모두 사용되는 경우 메모리를 할당하지 않도록 설계되었습니다</target>
        </trans-unit>
        <trans-unit id="93f405b3f1113c619eaa3ff8cf11a04161308e3b" translate="yes" xml:space="preserve">
          <source>All three types, namely &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; , and &lt;code&gt;requires&lt;/code&gt; are supported in the way specified in the META.yml specification. The current implementation</source>
          <target state="translated">모든 세 가지 유형, 즉 &lt;code&gt;configure_requires&lt;/code&gt; , &lt;code&gt;build_requires&lt;/code&gt; 및 &lt;code&gt;requires&lt;/code&gt; META.yml 규격에 규정 된 방법으로 지원됩니다. 현재 구현</target>
        </trans-unit>
        <trans-unit id="e69868d20db4582400a5d6cd9bcd656e5299ed1b" translate="yes" xml:space="preserve">
          <source>All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use a single character to end each line in the external representation of text (even though that single character is CARRIAGE RETURN on old, pre-Darwin flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other systems like OS/2, DOS, and the various flavors of MS-Windows, your program sees a &lt;code&gt;\n&lt;/code&gt; as a simple &lt;code&gt;\cJ&lt;/code&gt; , but what's stored in text files are the two characters &lt;code&gt;\cM\cJ&lt;/code&gt; . That means that if you don't use binmode() on these systems, &lt;code&gt;\cM\cJ&lt;/code&gt; sequences on disk will be converted to &lt;code&gt;\n&lt;/code&gt; on input, and any &lt;code&gt;\n&lt;/code&gt; in your program will be converted back to &lt;code&gt;\cM\cJ&lt;/code&gt; on output. This is what you want for text files, but it can be disastrous for binary files.</source>
          <target state="translated">VMS의 모든 Unix, Mac OS (이전 및 신규) 및 Stream_LF 파일의 모든 변형은 단일 문자를 사용하여 텍스트의 외부 표현에서 각 줄을 종료합니다 (단일 문자는 이전의 다윈 이전 Mac 버전에서 캐리지 리턴 임에도 불구하고) OS이며 Unix 및 대부분의 VMS 파일에서 LINE FEED입니다). OS / 2, DOS 및 다양한 종류의 MS-Windows와 같은 다른 시스템에서 프로그램은 &lt;code&gt;\n&lt;/code&gt; 을 간단한 &lt;code&gt;\cJ&lt;/code&gt; 로 인식하지만 텍스트 파일에 저장되는 것은 &lt;code&gt;\cM\cJ&lt;/code&gt; 두 문자 입니다. 즉, 이러한 시스템에서 binmode ()를 사용하지 않으면 디스크의 &lt;code&gt;\cM\cJ&lt;/code&gt; 시퀀스 는 입력시 &lt;code&gt;\n&lt;/code&gt; 으로 변환되고 프로그램의 &lt;code&gt;\n&lt;/code&gt; 은 &lt;code&gt;\cM\cJ&lt;/code&gt; 로 다시 변환됩니다.출력시. 이것은 텍스트 파일에서 원하는 것이지만 바이너리 파일의 경우 비참 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad579c08df3b605d9bcdf2dd854aada4ff50f1d7" translate="yes" xml:space="preserve">
          <source>All warnings are enabled in a block by either of these:</source>
          <target state="translated">모든 경고는 다음 중 하나에 의해 블록에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ac638dedbe9b121696313ec4c1b744224313d7b2" translate="yes" xml:space="preserve">
          <source>All warnings from these class elements are fatal, as well as some practices that don't currently warn. For example you cannot say</source>
          <target state="translated">이러한 클래스 요소의 모든 경고는 치명적이며 현재 경고하지 않는 일부 관행입니다. 예를 들어 말할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="370cb67fce7c69dd6b28a7668dbdd050522c81c2" translate="yes" xml:space="preserve">
          <source>All we send is -nologo to nmake to prevent it from printing its damned banner.</source>
          <target state="translated">우리가 보내는 것은 nmake에 -nologo입니다. 배너가 인쇄되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="89ae61e8070c7c0925079d83f7934e0eb3357598" translate="yes" xml:space="preserve">
          <source>All writes should be appends.</source>
          <target state="translated">모든 글은 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="d673c2e10445ecd4d4244da3c2339308139938ca" translate="yes" xml:space="preserve">
          <source>All you need to be able to use this is a C compiler than generates BSD/GCC-style stabs. The &lt;b&gt;-g&lt;/b&gt; option on native BSD compilers and GCC should get this for you.</source>
          <target state="translated">이것을 사용하려면 BSD / GCC 스타일 스테 이브를 생성하는 것보다 C 컴파일러 만 있으면됩니다. 네이티브 BSD 컴파일러와 GCC 의 &lt;b&gt;-g&lt;/b&gt; 옵션이이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3703c85b2e19a742cbffc3e68e850016eb81f530" translate="yes" xml:space="preserve">
          <source>All you need to do is post a short summary of the module, its purpose and interfaces. A few lines on each of the main methods is probably enough. (If you post the whole module it might be ignored by busy people - generally the very people you want to read it!)</source>
          <target state="translated">모듈, 목적 및 인터페이스에 대한 간단한 요약을 게시하기 만하면됩니다. 각 주요 방법에 대한 몇 줄이 충분할 것입니다. (전체 모듈을 게시하면 바쁜 사람들에 의해 무시 될 수 있습니다. 일반적으로 읽고 싶은 사람들이 있습니다!)</target>
        </trans-unit>
        <trans-unit id="42dd47aab008353520f505d14f8982da5b7ec66c" translate="yes" xml:space="preserve">
          <source>All you need to do is turn on caching outside of the lexicon hash itself like so:</source>
          <target state="translated">렉시콘 해시 자체 외부에서 캐싱을 켜면됩니다.</target>
        </trans-unit>
        <trans-unit id="97cf0e2918a9254a0eafa0498166116f753c3eef" translate="yes" xml:space="preserve">
          <source>All-in-one interface</source>
          <target state="translated">올인원 인터페이스</target>
        </trans-unit>
        <trans-unit id="6fee78bc0546aa696412ff85a7bc963fbc9ca7d4" translate="yes" xml:space="preserve">
          <source>Allocate (if not already done so) the read buffer for this layer and return pointer to it. Return NULL on failure.</source>
          <target state="translated">이 계층에 대한 읽기 버퍼를 할당하고 (아직 그렇게하지 않은 경우) 포인터를 리턴하십시오. 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b2ee334827d425691fcbfb9ca0bc34e49168fb9" translate="yes" xml:space="preserve">
          <source>Allocates a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">새로운 Perl 인터프리터를 할당합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="204757b0500eb920f73e23856bcfacd06d0f5f77" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt;) for an anonymous function that is lexically scoped inside the currently-compiling function. The function</source>
          <target state="translated">현재 컴파일중인 함수 내에서 어휘 범위가 지정된 익명 함수 에 대해 현재 컴파일중인 패드 ( &lt;a href=&quot;#pad_alloc&quot;&gt;pad_alloc&lt;/a&gt; 를 통해 ) 의 위치를 ​​할당 합니다. 함수</target>
        </trans-unit>
        <trans-unit id="cbc8fd0f139e1ed3d083e8bda55cb3c680701f85" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad (via &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;pad_alloc in perlapi&lt;/a&gt;) and then stores a name for that entry.</source>
          <target state="translated">현재 컴파일중인 패드에 장소를 할당하고 ( &lt;a href=&quot;perlapi#pad_alloc&quot;&gt;perlapi의 pad_alloc을&lt;/a&gt; 통해 ) 해당 항목의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5c5b44a37c6737cadc335e0a4b7b826b48bad95f" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad for a named lexical variable. Stores the name and other metadata in the name part of the pad, and makes preparations to manage the variable's lexical scoping. Returns the offset of the allocated pad slot.</source>
          <target state="translated">명명 된 어휘 변수에 대해 현재 컴파일중인 패드의 위치를 ​​할당합니다. 패드의 이름 부분에 이름 및 기타 메타 데이터를 저장하고 변수의 어휘 범위를 관리 할 준비를합니다. 할당 된 패드 슬롯의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7b59f013b83c5b7e66a9f56292d13c76f0cfbe1" translate="yes" xml:space="preserve">
          <source>Allocates a place in the currently-compiling pad, returning the offset of the allocated pad slot. No name is initially attached to the pad slot.</source>
          <target state="translated">현재 컴파일중인 패드에 위치를 할당하여 할당 된 패드 슬롯의 오프셋을 반환합니다. 처음에는 패드 슬롯에 이름이 붙어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="2e2f6a9fe9c75300156ed8faa2846a84de58e28c" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;+&lt;/code&gt; to start options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;getopt_compat&lt;/code&gt; is disabled.</source>
          <target state="translated">허용 &lt;code&gt;+&lt;/code&gt; 옵션을 시작합니다. 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값이 사용되며,이 경우 &lt;code&gt;getopt_compat&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a59030efa024b93a6e819c9cb26054addbab292b" translate="yes" xml:space="preserve">
          <source>Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;auto_abbrev&lt;/code&gt; is disabled.</source>
          <target state="translated">옵션 이름을 고유성으로 축약 할 수 있습니다. 환경 변수 POSIXLY_CORRECT가 설정되어 있지 않으면 기본값이 사용되며,이 경우 &lt;code&gt;auto_abbrev&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="daa78d2843413d350c8af8e2659c80ab1cc32bed" translate="yes" xml:space="preserve">
          <source>Allowing &quot;.&quot; as a version delimiter is simply incompatible with determining whether a pathname is in VMS format or in Unix format with extended file syntax. There is no way to know whether &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when passing it to unixify() or vmsify().</source>
          <target state="translated">&quot;.&quot;허용 버전 구분 기호는 경로 이름이 VMS 형식인지 아니면 확장 파일 구문을 사용하는 Unix 형식인지를 결정하는 데 단순히 호환되지 않습니다. unixify () 또는 vmsify ()에 전달할 때 &quot;perl-5.8.6&quot;이 Unix &quot;perl-5.8.6&quot;인지 또는 VMS &quot;perl-5.8; 6&quot;인지 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c408189be3311ef544fc6916d88f93932d6bdffc" translate="yes" xml:space="preserve">
          <source>Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.</source>
          <target state="translated">악의적 인 tar 아카이브가 추출하는 사용자에게 권한이있는 파일을 변경하거나 대체 할 수 있으므로이를 허용하면 보안에 영향을 줄 수 있습니다. 따라서 기본값은 안전하지 않은 추출을 허용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddbc44ff2a879d62f5a15a25c82d1c43a6e19ca9" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;. This can be used to implement user-defined codes.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 &lt;a href=&quot;../perlpod#Formatting-Codes&quot;&gt;perlpod&lt;/a&gt; 의 형식화 코드 목록을 승인 할 수 있습니다. 사용자 정의 코드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101aab8a8afb357465320bb5f121a4ac661795be" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;Verbatim Paragraph in perlpod&lt;/a&gt;. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 &lt;a href=&quot;../perlpod#Verbatim-Paragraph&quot;&gt;perlpod의 Verbatim 단락에&lt;/a&gt; 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a410a266e9f220f21c4f8d80b7768daa7e08ef" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for data paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A data paragraph is one delimited by &lt;code&gt;=begin/=for/=end&lt;/code&gt; directives. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 데이터 단락에 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 데이터 단락은 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 지시문으로 구분되는 단락입니다 . 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0abf6fb24aebd1865d65a4df47fe30a801298ce2" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;$parser&lt;/code&gt; to accept a list of directives for processed paragraphs. A directive is the label of a &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. A processed paragraph is also known as &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;Ordinary Paragraph in perlpod&lt;/a&gt;. This can be used to implement user-defined directives.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 처리 된 단락에 대한 지시문 목록을 승인 할 수 있습니다. 지시문은 &lt;a href=&quot;../perlpod#Command-Paragraph&quot;&gt;perlpod&lt;/a&gt; 의 명령 단락 레이블입니다 . 처리 된 단락은 &lt;a href=&quot;../perlpod#Ordinary-Paragraph&quot;&gt;perlpod의 일반 단락이라고도&lt;/a&gt; 합니다. 이것은 사용자 정의 지시문을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3735b17f2c2eb4921645bcf6a4d22392282447c" translate="yes" xml:space="preserve">
          <source>Allows a pre-existing extension directory to be overwritten.</source>
          <target state="translated">기존 확장 디렉토리를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9153c7965fe5ac4319d07a3a1e17ae8bc10ce3" translate="yes" xml:space="preserve">
          <source>Allows an extension to be created for a header even if that header is not found in standard include directories.</source>
          <target state="translated">표준 포함 디렉토리에 해당 헤더가없는 경우에도 헤더에 대한 확장을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf02b11ffbf9506236d387546a93a50fc62cc0a" translate="yes" xml:space="preserve">
          <source>Allows files and directories to be moved to the Trashcan/Recycle Bin (where they may later be restored if necessary) if the operating system supports such functionality. This feature may one day be made available directly in &lt;code&gt;File::Path&lt;/code&gt; .</source>
          <target state="translated">운영 체제가 해당 기능을 지원하는 경우 파일 및 디렉토리를 휴지통 / 휴지통으로 이동시킬 수 있습니다 (필요한 경우 나중에 복원 할 수 있음). 이 기능은 언젠가 &lt;code&gt;File::Path&lt;/code&gt; 에서 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="559ebf2a9218f8c70716cdc11eee2f4b586a5213" translate="yes" xml:space="preserve">
          <source>Allows multiple concatenated compressed streams to be treated as a single compressed stream. Decompression will stop once either the end of the file/buffer is reached, an error is encountered (premature eof, corrupt compressed data) or the end of a stream is not immediately followed by the start of another stream.</source>
          <target state="translated">여러 개의 연결된 압축 스트림을 단일 압축 스트림으로 처리 할 수 ​​있습니다. 파일 / 버퍼의 끝에 도달하거나 오류가 발생하거나 (압축 된 데이터가 손상됨) 스트림의 끝이 즉시 다른 스트림의 시작으로 이어지지 않으면 압축 해제가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5261df1ca0e4f1432538fbf7dfbe931383691e" translate="yes" xml:space="preserve">
          <source>Allows newName to be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an encoding object (as described in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;).</source>
          <target state="translated">newName을 ENCODING의 별명으로 사용할 수 있습니다. ENCODING은 인코딩 이름 또는 인코딩 객체 일 수 있습니다 ( &lt;a href=&quot;../encode&quot;&gt;Encode에&lt;/a&gt; 설명 된대로 ).</target>
        </trans-unit>
        <trans-unit id="76b238c6a405ca46725f72efca71d3c55969afb7" translate="yes" xml:space="preserve">
          <source>Allows source endpoint verification to be enabled or disabled. This is useful for those remote destinations with multiples interfaces where the response may not originate from the same endpoint that the original destination endpoint was sent to. This only affects udp and icmp protocol pings.</source>
          <target state="translated">소스 엔드 포인트 확인을 활성화하거나 비활성화 할 수 있습니다. 이는 원래 대상 엔드 포인트가 전송 된 동일한 엔드 포인트에서 응답이 시작되지 않을 수있는 다중 인터페이스가있는 원격 대상에 유용합니다. 이것은 udp 및 icmp 프로토콜 핑에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b46332805263e8790df0747eb20b444ed87a43b7" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Mostly similar in effect to</source>
          <target state="translated">하나 이상의 모듈을로드하고 동시에 해당 모듈에서 상속을 설정할 수 있습니다. 대체로 비슷한 효과</target>
        </trans-unit>
        <trans-unit id="c9da0fc905ccf60ade5ca9f7c49a801a55f4a1c8" translate="yes" xml:space="preserve">
          <source>Allows you to both load one or more modules, while setting up inheritance from those modules at the same time. Roughly similar in effect to</source>
          <target state="translated">하나 이상의 모듈을로드하고 동시에 해당 모듈에서 상속을 설정할 수 있습니다. 대략 비슷한 효과</target>
        </trans-unit>
        <trans-unit id="22f08aec036591ac3a4e81d90d5af18a1bd7db2a" translate="yes" xml:space="preserve">
          <source>Allows you to choose the character encoding will be store in the DBM file.</source>
          <target state="translated">문자 인코딩이 DBM 파일에 저장되도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab85f86a937e724bd3f8c905ebc9700e2dbc47d" translate="yes" xml:space="preserve">
          <source>Allows you to write your script in non-ASCII and non-UTF-8</source>
          <target state="translated">비 ASCII 및 비 UTF-8로 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce4c63a4fe0fe7df493313e47b4aaa4d8491416" translate="yes" xml:space="preserve">
          <source>Almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. And the second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; 's.)</source>
          <target state="translated">거의 모든 속성은 대소 문자를 구분하지 않습니다. 즉, &lt;code&gt;/i&lt;/code&gt; 정규식 수정자를 추가해도 일치하는 내용은 변경되지 않습니다. 영향을받는 두 세트가 있습니다. 첫 번째 세트는 &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; 및 &lt;code&gt;Titlecase_Letter&lt;/code&gt; 일치, 모두 &lt;code&gt;Cased_Letter&lt;/code&gt; 를 아래 &lt;code&gt;/i&lt;/code&gt; 정합. 그리고, 두 번째 세트는 &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; 및 &lt;code&gt;Titlecase&lt;/code&gt; 모두 매치 그중 &lt;code&gt;Cased&lt;/code&gt; 아래 &lt;code&gt;/i&lt;/code&gt; 매칭. 이 세트에는 &lt;code&gt;PosixUpper&lt;/code&gt; 및 &lt;code&gt;PosixLower&lt;/code&gt; 하위 세트도 포함 되어 있습니다. &lt;code&gt;/i&lt;/code&gt; 는 &lt;code&gt;PosixAlpha&lt;/code&gt; 와 일치 합니다 . (이 세트의 차이는 로마 숫자로 몇 가지, 그들은 그래서 모두 소문자로 제공한다는 것입니다 &lt;code&gt;Cased&lt;/code&gt; 가되지 않도록,하지만, 문자로 간주되지 않습니다 &lt;code&gt;Cased_Letter&lt;/code&gt; 의를.)</target>
        </trans-unit>
        <trans-unit id="e26025e2ac0ac02421707ba70eeed5ab6641b4e6" translate="yes" xml:space="preserve">
          <source>Almost definitely only useful to people hacking on the offsets part of the debug engine.</source>
          <target state="translated">디버그 엔진의 오프셋 부분을 해킹하는 사람들에게만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38d90c72fc98727ed772fa67692cb8b8e8e09948" translate="yes" xml:space="preserve">
          <source>Along the same lines, just because you</source>
          <target state="translated">같은 줄을 따라</target>
        </trans-unit>
        <trans-unit id="bfe689be701eb0f2bfb705a857c3ee07252b9d77" translate="yes" xml:space="preserve">
          <source>Along with the Perl interpreter itself, the Perl distribution installs a range of utilities on your system. There are also several utilities which are used by the Perl distribution itself as part of the install process. This document exists to list all of these utilities, explain what they are for and provide pointers to each module's documentation, if appropriate.</source>
          <target state="translated">Perl 인터프리터 자체와 함께 Perl 분배는 시스템에 다양한 유틸리티를 설치합니다. 설치 프로세스의 일부로 Perl 배포 자체에서 사용되는 몇 가지 유틸리티도 있습니다. 이 문서는 이러한 유틸리티를 모두 나열하고 해당 유틸리티의 기능을 설명하고 필요한 경우 각 모듈 설명서에 대한 포인터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e9e4db05fa3da393c5842e003969195c59714caf" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing of Perl Functions</source>
          <target state="translated">펄 함수의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="35100f76a7dd5f19974c02f54724529e98b1eb3a" translate="yes" xml:space="preserve">
          <source>Alphabetical index of Unicode characters</source>
          <target state="translated">유니 코드 문자의 알파벳순 색인</target>
        </trans-unit>
        <trans-unit id="834177335506d3ec099968dc2393bf176b00318d" translate="yes" xml:space="preserve">
          <source>Also Perl gives access to various C library functions through the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module. Some of those functions are always affected by the current locale. For example, &lt;code&gt;POSIX::strftime()&lt;/code&gt; uses &lt;code&gt;LC_TIME&lt;/code&gt; ; &lt;code&gt;POSIX::strtod()&lt;/code&gt; uses &lt;code&gt;LC_NUMERIC&lt;/code&gt; ; &lt;code&gt;POSIX::strcoll()&lt;/code&gt; and &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; use &lt;code&gt;LC_COLLATE&lt;/code&gt; ; and character classification functions like &lt;code&gt;POSIX::isalnum()&lt;/code&gt; use &lt;code&gt;LC_CTYPE&lt;/code&gt; . All such functions will behave according to the current underlying locale, even if that locale isn't exposed to Perl space.</source>
          <target state="translated">또한 Perl은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 통해 다양한 C 라이브러리 기능에 액세스 할 수 있습니다 . 이러한 기능 중 일부는 항상 현재 로캘의 영향을받습니다. 예를 들어 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 은 &lt;code&gt;LC_TIME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strtod()&lt;/code&gt; 는 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 사용합니다 . &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 및 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 사용합니다 . &lt;code&gt;POSIX::isalnum()&lt;/code&gt; 과 같은 문자 분류 함수는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 사용 합니다. 해당 로케일이 Perl 공간에 노출되지 않더라도 이러한 기본 기능은 모두 현재 기본 로케일에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="80beb22d4bec02699379f749d87a910462f32ef7" translate="yes" xml:space="preserve">
          <source>Also add the following code segment to Mytest.t while incrementing the &quot;9&quot; tests to &quot;11&quot;:</source>
          <target state="translated">또한 &quot;9&quot;테스트를 &quot;11&quot;로 늘리면서 다음 코드 세그먼트를 Mytest.t에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ac140b9c3d4faf5ff89331ade5065ee26ad2ce5b" translate="yes" xml:space="preserve">
          <source>Also available in the CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode::CaseFold&lt;/a&gt; module, the new &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &amp;ldquo;foldcase&amp;rdquo; function from v5.16 grants access to the same Unicode casefolding as the &lt;code&gt;/i&lt;/code&gt; pattern modifier has always used:</source>
          <target state="translated">CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::CaseFold&quot;&gt;Unicode :: CaseFold&lt;/a&gt; 모듈 에서도 사용 가능하며, v5.16 의 새로운 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; &quot;foldcase&quot;함수는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정자가 항상 사용 했던 것과 동일한 Unicode casefolding에 대한 액세스 권한을 부여합니다 .</target>
        </trans-unit>
        <trans-unit id="46cd58b57422283c68d064857c29c9de3e394325" translate="yes" xml:space="preserve">
          <source>Also change</source>
          <target state="translated">또한 변경</target>
        </trans-unit>
        <trans-unit id="c0abeeb67d5f473db892c8e04d0607c1def48eaa" translate="yes" xml:space="preserve">
          <source>Also compare &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;SAVEMORTALIZESV&lt;/code&gt; 를 비교 하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e4ad005c5681ba47d1d566b8e0cb49ffb2ad43" translate="yes" xml:space="preserve">
          <source>Also consider this valid structure:</source>
          <target state="translated">이 유효한 구조도 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b339961adc2d21b9a876670a45b1f1d855a3be" translate="yes" xml:space="preserve">
          <source>Also create a file mylib.c that looks like this:</source>
          <target state="translated">또한 다음과 같은 mylib.c 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c401faba028e376c88469287989685e42d637510" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; ): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt; .</source>
          <target state="translated">또한 부동 소수점 숫자에는 엔디안이 있습니다. 일반적으로 (항상 그런 것은 아니지만) 이것은 정수 엔디안과 일치합니다. 요즘 대부분의 플랫폼에서 IEEE 754 이진 형식을 사용하지만 특히 Long Double이 포함 된 경우 차이점이 있습니다. 당신이 볼 수있는 &lt;code&gt;Config&lt;/code&gt; 변수가 &lt;code&gt;doublekind&lt;/code&gt; 및 &lt;code&gt;longdblkind&lt;/code&gt; (또한 &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; )은 &quot;종류&quot;값은 달리 열거 있습니다 &lt;code&gt;byteorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a0632d09aa67f7c933563807a5dc4e1be43b5e" translate="yes" xml:space="preserve">
          <source>Also good for one-liners:</source>
          <target state="translated">하나의 라이너에도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="801a4731c98561cdcf16aa86d636dfa32a54b0ca" translate="yes" xml:space="preserve">
          <source>Also keep around the old $(SAY) macro in case somebody's using it.</source>
          <target state="translated">누군가가 그것을 사용하고 있다면 이전 $ (SAY) 매크로를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2c84ea90ff2c682d2dfed6ff8b041df2e7877e52" translate="yes" xml:space="preserve">
          <source>Also like the &quot;strict&quot; pragma, if there is more than one instance of the &lt;code&gt;warnings&lt;/code&gt; pragma in a given scope the cumulative effect is additive.</source>
          <target state="translated">또한 &quot;엄격한&quot;프라 그마처럼, 주어진 범위에 &lt;code&gt;warnings&lt;/code&gt; 프라그 마가 두 개 이상있는 경우 누적 효과는 부가 적입니다.</target>
        </trans-unit>
        <trans-unit id="8b1ee43d27cd54e3a73fd0b027a7a33d6ab24281" translate="yes" xml:space="preserve">
          <source>Also make sure that you have</source>
          <target state="translated">또한 당신이 가지고 있는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="ccf329915f222131778e86ee9fd087f89f391e81" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">또한 이 포트의 알려진 제한 사항은 아래의 &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;버그 및주의 사항&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="fe06cc0daccf4654b8c81c8f1faee5e0b7783c69" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">또한 이 검색 중에 &lt;code&gt;\c\&lt;/code&gt; (multichar control char 구문)에 주의를 기울이지 않습니다 . 따라서 두 번째 &lt;code&gt;\&lt;/code&gt; 에있는 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; 의 일환으로 해석됩니다 &lt;code&gt;\/&lt;/code&gt; , 및 다음 &lt;code&gt;/&lt;/code&gt; 구분 기호로 인식되지 않습니다. 대신 인용 된 구문의 끝에 &lt;code&gt;\034&lt;/code&gt; 또는 &lt;code&gt;\x1c&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73a9b46957654b20ec65fb83845a1d68f2c4bbed" translate="yes" xml:space="preserve">
          <source>Also note that</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="674fbb1e5f8c5ba4d4b18a90ede292ece92dabf5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명령 행 인수를 &lt;a href=&quot;functions/open&quot;&gt;open에&lt;/a&gt; 전달하므로 반드시 파일 이름으로 해석 할 필요는 없습니다. 가능한 보안 영향에 대해서는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93e48d832329c669ef467acfbb855710b1f11c32" translate="yes" xml:space="preserve">
          <source>Also note that in order to be compatible with the shell command, &lt;code&gt;basename()&lt;/code&gt; does not strip off a suffix if it is identical to the remaining characters in the filename.</source>
          <target state="translated">또한 쉘 명령과 호환되도록 &lt;code&gt;basename()&lt;/code&gt; 은 파일 이름의 나머지 문자와 동일한 접미어를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d4f64c4ffda1e49198c526880412a3685e89bbb" translate="yes" xml:space="preserve">
          <source>Also note that in some platforms trying to use the infinity in arithmetic operations may result in Perl crashing because using an infinity causes SIGFPE or its moral equivalent to be sent. The way to ignore this is</source>
          <target state="translated">또한 일부 플랫폼에서 산술 연산에 무한대를 사용하려고하면 무한대를 사용하면 SIGFPE 또는 그와 동등한 도덕적 결과가 전송되므로 Perl 충돌이 발생할 수 있습니다. 이것을 무시하는 방법은</target>
        </trans-unit>
        <trans-unit id="e93493c0471e07df3c4c3cbce58bbf69cdead50b" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">또한 STD 이외의 파일 핸들은 영향을받지 않습니다. 사용은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 사람들의 층을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8343e14f16aa3f23ee42ee984961cfee3da48f48" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt; , but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">또한 앞에서 설명한 &lt;code&gt;sv_set*()&lt;/code&gt; 및 &lt;code&gt;sv_cat*()&lt;/code&gt; 함수는 대상에서 'set'마술을 호출 하지 &lt;b&gt;않습니다&lt;/b&gt; . 이 함수를 호출 한 후 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 매크로를 호출하거나 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 또는 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 함수 중 하나를 사용하여 사용자가 수행해야합니다 . 마찬가지로, 일반 C 코드는 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 매크로를 호출하여 매직을 처리하지 않는 함수의 외부 소스에서 얻은 SV를 사용하는 경우 'get'매직을 호출해야합니다. 이 기능에 대한 설명은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 . 예를 들어 &lt;code&gt;sv_cat*()&lt;/code&gt; 함수를 호출하면 일반적으로 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 가 와야합니다.하지만 구현시 'get'매직을 처리하므로 이전 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e7be1aad912cf4ad5fcf4064cf6ab4309ca326be" translate="yes" xml:space="preserve">
          <source>Also note that the bval option only allows you to specify a single byte as a delimiter.</source>
          <target state="translated">또한 bval 옵션을 사용하면 단일 바이트 만 구분 기호로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">또한 UNITCHECK 블록에는 값이 없습니다. 각 컴파일 단위마다 개별적으로 실행되므로 전역 인터프리터 단계가 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">또한이 지침은 시스템의 Perl 모듈 리포지토리에 모듈을 설치하도록되어 있지만 원하는 디렉토리에 모듈을 설치할 수 있습니다. 예를 들어, &lt;code&gt;perl Makefile.PL&lt;/code&gt; 이라고 말하면 perl &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 를 대체 하여 모듈을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">또한 이것이 모든 구성에서 작동하지는 않지만 64 비트 버전의 GCC에서는 실패하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">또한 현재 구현에서 공유 변수는 메모리를 조금 더 사용하고 일반 변수보다 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">또한 열거 형을 암시 적으로 int로 변경할 수 있는지 여부는 컴파일러마다 다르므로 (int)해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">또한, 해시 요소의 순서는 무작위 될 수 있지만,이 &quot;의사 순서&quot;는 것을주의 &lt;b&gt;하지&lt;/b&gt; 무작위 (사용 목록을 셔플과 같은 응용 프로그램에 사용되는 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 그것을 위해, 참조 &lt;a href=&quot;list/util&quot;&gt;목록 :: 백분율&lt;/a&gt; , Perl 5.8.0 이후의 표준 코어 모듈 또는 CPAN 모듈 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ) 또는 순열 생성 (예 : CPAN 모듈 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 또는 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ) 또는 모든 암호화 응용 프로그램 .</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">또한 로컬 파일 시스템의 수퍼 유저에 대해 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 테스트는 항상 1을 리턴하고 실행 비트가 모드에서 설정되면 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 가 1을 리턴합니다. 따라서 수퍼 유저가 실행하는 스크립트는 파일의 실제 모드를 결정하기 위해 stat ()를 수행하거나 유효 uid를 일시적으로 다른 것으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">또한 로컬 파일 시스템의 수퍼 유저에 대해 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 테스트는 항상 1을 리턴하고 실행 비트가 모드에서 설정되면 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 가 1을 리턴합니다. 따라서 수퍼 유저가 실행하는 스크립트는 파일의 실제 모드를 결정하기 위해 stat ()를 수행하거나 유효 uid를 일시적으로 다른 것으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">또한 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">또한 모든 ASCII 문자가 UTF-8로 변하지 않기 때문에 (UTF-8로 인코딩되었는지 여부에 관계없이 동일한 바이트 (항상 단일 바이트) &lt;code&gt;isASCII&lt;/code&gt; 을 의미 함 ) isASCII 는 임의의 바이트로 호출 될 때 올바른 결과를 제공합니다. UTF-8로 인코딩되거나 인코딩되지 않은 문자열 마찬가지로 &lt;code&gt;isASCII_utf8&lt;/code&gt; 은 UTF-8로 인코딩되거나 인코딩되지 않은 모든 문자열에서 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">또한 perl_parse ()에 전달하는 인수에 관계없이 C main () argc, argv 및 env에서 PERL_SYS_INIT3 ()을 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">또한 표준 배포판의 &lt;code&gt;File::Basename&lt;/code&gt; 을 사용 하여 경로 이름을 조각으로 분할합니다 (기본 파일 이름, 디렉토리의 전체 경로 및 파일 접미사).</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 구문, 서브 루틴 및 메소드 호출, 익명 생성자 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 등의 용어로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 가 오류가보고되는 위치를 결정 하는 방법에 대한 위 의 &lt;a href=&quot;#DESCRIPTION&quot;&gt;설명&lt;/a&gt; 섹션 도 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">또한 &quot;|&quot; 는 대괄호 안에 리터럴로 해석되므로 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; 를 &lt;code&gt;[feio|]&lt;/code&gt; 실제로 [feio |] 만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">또한 C는 &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; . 컴파일러에서는 작동하지만 모든 사람에게 작동하지는 않습니다. 이러한 종류의 진술을 별도의 과제로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">또한 &lt;code&gt;%p&lt;/code&gt; 형식에는 실제로 void 포인터가 필요 하다는 것을 기억하십시오 .</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; 또는 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">참조 :</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">또한 v5.8.1부터 &lt;code&gt;DATA&lt;/code&gt; 의사 파일 핸들이 인코딩에서 UTF-8로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">또한 운영 체제, 파일 시스템, 문자 집합 등에 대한 잘못된 가정을 피하기 위해 &lt;a href=&quot;perlport&quot;&gt;perlport를&lt;/a&gt; 신중하게 연구 하십시오 .</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 의 범위를 벗어난 비 UTF-8 문자열 인용은 변경되지 않으며 이는 상위 Latin1 범위의 모든 문자를 인용합니다. 이것은 유니 코드를 사용하지 않는 구식 프로그램에 대한 완전한 하위 호환성을 제공합니다. ( &lt;code&gt;unicode_strings&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 이상의 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 범위 내에서 자동으로 활성화됩니다 .)</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 의 범위를 벗어난 비 UTF-8 문자열 인용은 변경되지 않으며 이는 상위 Latin1 범위의 모든 문자를 인용합니다. 이것은 유니 코드를 사용하지 않는 구식 프로그램에 대한 완전한 하위 호환성을 제공합니다. ( &lt;code&gt;unicode_strings&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 이상의 &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 범위 내에서 자동으로 활성화됩니다 .)</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">또한 달리 &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; 의 반환 경로에 후행 슬래시를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">또한 VMS에서 Perl 프로그램을 작업 할 때 특정 운영 체제 형식의 구문이 필요한 경우 적절한 DECC $ 기능 논리를 확인하거나 변환 루틴을 호출하여 해당 형식으로 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">또한 AV 또는 HV의 값으로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용할 때주의해야합니다 ( &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV, HV 및 정의되지 않은 값 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">또한 &lt;b&gt;Perl 5.8.x 및 이전 버전&lt;/b&gt; 에서이 pragma는 유사 해시를 사용합니다. 결과적으로 객체가 올바르게 입력 된 변수를 통해 액세스되는 한 액세스 가능한 컴팩트하고 빠른 배열 인 명명 된 필드를 가진 객체를 가질 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">또한 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 산출 합니다. &quot; &lt;i&gt;X&lt;/i&gt; &quot; 는</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">또한 Case_Folding은 &lt;code&gt;/i&lt;/code&gt; 수정자를 통해 정규식, &lt;code&gt;\F&lt;/code&gt; 음역 이스케이프 및 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 연산자를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">또한 구성이 중단 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">또한 백 슬래시 다음에 두 세 자리의 8 진수가 8 진수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">또한이 두 가지 방법 모두 현재 단일 문자 만 이름 지정할 수 있습니다. 일련의 문자 이름을 지정하려면 &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;사용자 정의 번역기를&lt;/a&gt; 사용하십시오 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">또한 &amp;amp; $ coderef ($ lh, ... parameters ...)를 호출하면 모든 종류의 예외가 발생할 수 있습니다 (예 : 해당 하위의 코드가 0으로 나누려고 시도하는 경우). 그러나 &quot;foo&quot;메소드를 호출하는 브라켓 표기법 텍스트가있을 때 매우 일반적인 예외가 발생하지만 그러한 메소드는 없습니다. (예 : &quot;[qua &lt;b&gt;tn&lt;/b&gt; , _1, ball].&quot;은 $ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt; ($ _ [1], 'ball') 을 호출 할 때 예외가 발생 합니다. 아마도 &quot;quant&quot;를 의미했을 것입니다. ) &lt;code&gt;maketext&lt;/code&gt; 는 이러한 예외를 포착하지만 오류 메시지를 더 읽기 쉽게하기 위해 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">또한 다음과 같은 항목</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">또한 Perl을 사용하는 모든 C 프로그램은</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">또한 실험적인 기능으로 자유롭게 연주하십시오. 운영</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">또한 ASCII 범위를 넘어 프로그래밍 언어 식별자에있는 좀 더 세밀한 문자 집합의 경우보다 사용자 지정된 &lt;a href=&quot;#Unicode-Properties&quot;&gt;유니 코드 속성&lt;/a&gt; , &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; 및 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">또한 _AUTO 사전을 설정하면 유효한 값을 키로 사용하는 것이 매우 유용합니다. _AUTO 사전은 이후 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">또한, SV가 &lt;code&gt;mg_find&lt;/code&gt; 또는 &lt;code&gt;mg_findext&lt;/code&gt; 로 전달 된 SV가 SVt_PVMG 유형이 아닌 경우, Perl은 코어 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">또한 이진 속성에서 'Yes', 'T'및 'True'는 모두 'Y'의 동의어입니다. '아니오', 'F'및 '거짓'은 모두 'N'의 동의어입니다. 표는이를 나타내는 'Y *'및 'N *'을 보여 주며 다른 가능성에 대한 별도의 항목이 없습니다. 값이 'Yes'및 'No'인 모든 특성이 이진은 &lt;code&gt;NOT&lt;/code&gt; ,이 와일드 카드를 사용하지 않고 모든 값을 철자 하고 설명에서 NOT 절은 이진이 아님을 강조 표시합니다. 이것들은 또한 그것들과 일치하는 복합 형태를 요구하는 반면, 진정한 이진 특성은 단일 및 복합 형태를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">또한 &lt;b&gt;유니 코드&lt;/b&gt; 와 관련하여 그리스어, 벵골어 또는 텡와 르와 같은 특정 언어 또는 언어 그룹에 대한 쓰기 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">또한, 이런 방식으로 정의 된 패턴은 아마 옵티마이 저가 그 패턴을 다루는 것에 대해 영리하지 않기 때문에 비효율적 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;code&gt;CRLF&lt;/code&gt; 내에서 행을 분할해서는 안됩니다 (예 : &lt;code&gt;\r&lt;/code&gt; 과 &lt;code&gt;\n&lt;/code&gt; 사이에 빈 행이 없음 ). 들어 &lt;code&gt;CRLF&lt;/code&gt; 의 시도 &lt;code&gt;:crlf&lt;/code&gt; (참조 계층 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">또한 음의 신호 값은 VMS에서 특별한 작업을 수행하지 않습니다. 그들은 단지 해당 양수 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">또한 보안 목적으로 파일 테스트를 사용하는 것은 시작부터 잃어버린 원인입니다. 경쟁 조건에 대한 창이 열려 있습니다 (누가 테스트와 실제 작업간에 권한이 변경되지 않습니까?). 따라서 보안에 대해 진지한 경우 실제 작업을 시도하고 성공 여부를 테스트하십시오. 원자 작업 측면에서 생각하십시오. 파일 테스트는 디스크의 요소 내용이 필요없는 파일 시스템 관리 작업에 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">또한 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">또한 프로젝트가 완료되고 현지화가 시작되면 사용하는 다양한 키를 모두 긁어 번역기에 전달할 수 있습니다. 그리고 그가 제시 한 내용이 다음과 같으면 번역사의 작업이 더 빨라질 것입니다.</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">또한 perl은 이전 버전의 유니 코드 표준에서 작동하도록 재 컴파일 될 수 있습니다. 자세한 내용은 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">또한 &lt;code&gt;$x&lt;/code&gt; 는 어휘이므로 외부의 Perl 코드로 도달하거나 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">또한 현재 버전의 perl에서 opcode의 수는 정확히 8의 배수가 아닐 수 있으므로, 마지막 바이트에는 사용되지 않은 비트가있을 수 있습니다. 이로 인해 문제가 발생하지 않아야합니다 (오퍼 코드 함수는 추가 비트를 무시합니다). ~ 연산자를 사용하면 일반적으로 invert_opset 함수와 동일한 '물리적'옵셋 '문자열'이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">또한 일반적인 소켓 &quot;개행&quot;상수가 제공됩니다. 상수 &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; 및 &lt;code&gt;CRLF&lt;/code&gt; 뿐만 아니라 &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; 및 &lt;code&gt;$CRLF&lt;/code&gt; 는 &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015\012&lt;/code&gt; 매핑됩니다 . 프로그램에서 리터럴 문자를 사용하지 않으려면 여기에 제공된 상수를 사용하십시오. 기본적으로 내보내지는 않지만 &lt;code&gt;:crlf&lt;/code&gt; 내보내기 태그를 사용하여 개별적으로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">또한 Linux에서 Sun Studio를 사용하여 Perl을 빌드하는 데 필요한 특별 지시 사항이 있습니다. 일반적인 &lt;code&gt;Configure&lt;/code&gt; 다음에 다음과 같이 make를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">또한 서브 루틴은 서브 루틴에 대한 액세스를 직렬화 하는 &lt;code&gt;:locked&lt;/code&gt; 속성 으로 선언 할 수 있지만 다른 스레드가 동시에 액세스 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">또한 개체는 임시 파일 이름으로 문자열 화되어 파일 이름과 직접 비교 될 수 있도록 구성됩니다. 그것은 C로 번호를 매 깁니다</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">또한 ASCII에서 'A'- 'Z'범위는 26 자의 대문자 알파벳 문자로 구성됩니다. EBCDIC에서는 그렇지 않습니다. 'a'에서 'z'도 마찬가지입니다. 그러나 '0'- '9'는 두 시스템 모두에서 중단되지 않은 범위입니다. 다른 범위에 대해서는 아무 것도 가정하지 마십시오. (정규 표현식 패턴에서 범위를 특수하게 처리하면 위에서 언급 한 범위가 모두 깨지지 않은 것이 Perl 코드에 나타납니다.)</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">또한 유니 코드를 사용하면 명확하지 않은 보안 문제가 발생할 수 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;유니 코드 보안 고려 사항을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">또한이 수정 자에서 대소 문자를 구분하지 않는 일치는 전체 유니 코드 문자 세트에서 작동합니다. &lt;code&gt;KELVIN SIGN&lt;/code&gt; 예에서는, 문자 &quot;K&quot;및 &quot;K&quot;를 일치; 및 &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; , 당신이 준비하지 않는 경우, 또 다른 잠재적 인 보안 문제를 제시, 16 진수 상수처럼 보이게 수있는 순서 &quot;FF&quot;를 일치합니다. 유니 코드 보안 문제에 대한 자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">또한, 같은 다양한 동의어 &lt;code&gt;\p{Alpha}&lt;/code&gt; 위한 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 속성에 모두 나열 됨</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">또한 공백, 하이픈 및 밑줄은 일반적으로 {braces} 사이의 모든 곳에서 무시되므로 정규식에 &lt;code&gt;/x&lt;/code&gt; 수정자가 지정되지 않은 경우에도 자유롭게 추가하거나 제거 할 수 있습니다 . 그러나 아래 표 에서 항목 시작 부분의 ' &lt;b&gt;T&lt;/b&gt; '는 해당 항목에 대해 더 엄격한 (더 엄격한) 규칙이 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">정규식 동작 변경</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">대체 스택 조작</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">또는 복된 참조 인 SV가있는 경우 다음을 사용하여 숨김 포인터를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">또는 &lt;code&gt;:constants&lt;/code&gt; 를 가져 오는 경우 다음 상수를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">또는 CMD 또는 4os2와 같은 OS / 2-ish 쉘을 사용하는 경우 perl 스크립트의 시작 부분에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">또는 pod2text를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">또는 기존 핸들에서이 방법으로 이진 모드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">또는 전역 변수 &lt;code&gt;$Carp::Verbose&lt;/code&gt; 를 true로 설정할 수 있습니다 . 아래의 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">다른 방법으로, make 설치 후 (또는 make-brain Dead 버전이있는 경우 make와 install 사이에) &quot;PREFIX = / destination / directory&quot;를 배치하여 확장 파일을 배치 할 정확한 디렉토리를 지정할 수 있습니다. 이것은 결국 여러 시스템에 배포 될 확장을 구축 할 때 매우 유용합니다. 그런 다음 대상 디렉토리에 파일을 보관하고 대상 시스템에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">또는 스크립트의 #! / usr / bin / perl 구문 을 따르는 시스템의 &lt;b&gt;Execute&lt;/b&gt; 명령을 대체 하고 스크립트의 s-Bit을 설정할 수 있습니다. 그런 다음 UNIX에서와 같이 스크립트를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">또는 정규 표현식 따옴표 연산자 인 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조). 패턴을 인용하고 컴파일하고 패턴에 정규식 플래그를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">대체는 정규 표현식이 다른 대안 중에서 선택할 수 있지만 그 자체로는 만족스럽지 않습니다. 그 이유는 각 대안이 전체 정규 표현식이지만 때로는 정규 표현식의 일부에 대한 대안을 원하기 때문입니다. 예를 들어, 가정 고양이 나 가정부를 검색한다고 가정 해 봅시다. 정규식 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 는 계산서에 적합하지만 &lt;code&gt;house&lt;/code&gt; 두 번 입력해야했기 때문에 비효율적 입니다. 정규 표현식의 일부를 &lt;code&gt;house&lt;/code&gt; 와 같이 일정하게 유지하는 것이 좋으며 일부 부분에는 &lt;code&gt;cat|keeper&lt;/code&gt; 과 같은 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">대체는 그룹에서와 동일한 방식으로 동작합니다. 주어진 문자열 위치에서 정규 표현식을 일치시키는 가장 왼쪽의 대안이 사용됩니다. 따라서 첫 번째 문자열 위치의 마지막 예에서 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 은 두 번째 대안과 일치하지만 다음 두 자리 &lt;code&gt;\d\d&lt;/code&gt; 와 일치하는 항목은 없습니다 . 따라서 Perl은 다음 대안으로 넘어갑니다. &lt;code&gt;&quot;20&quot;&lt;/code&gt; 이 두 자리 이기 때문에 null 대안이며 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">대체 캡처 그룹 번호 매기기</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">대체 수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">대체 옵션 스타터</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">테스트 대안 :: 더보기 :: use_ok</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">모듈에 대한 대체 경고 및 다이</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">또는 세 번째 마우스 버튼-&amp;gt; 새 디스플레이-&amp;gt; 편집 메뉴를 통해 대화식으로 init 파일을 편집하십시오</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">또는 여기를보십시오 : &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">또는 서브 필드 목록을 스칼라로 제공하여</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">또는 컴파일러 지시문 our ()를 사용하여 동적 변수를 현재 어휘 범위로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">또는 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">또는 &lt;code&gt;CPAN&lt;/code&gt; 에서 이러한 문서를 미리 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">또는 CPAN에서 이러한 문서를 미리 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">또는 Berkeley DB 버전 1은 가까운 CPAN 아카이브에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">또는 섹션 사양의 배열 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">또는 버전 2.24부터 구성 옵션이 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문과 함께 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">또는 perlglob.exe가 필요없고 USE_SETARGV 옵션을 활성화 할 필요가없는 경우 win32 / Makefile에서 $ (GLOBEXE)에 대한 모든 언급을 안전하게 제거 할 수 있으며 setargv.obj는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">또는 &lt;code&gt;gunzip&lt;/code&gt; 프로그램을 사용할 수있는 경우이를 사용하여 압축 파일을 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">또는 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 멤버를 메모리 로 읽으려면 &lt;code&gt;output&lt;/code&gt; 매개 변수에 스칼라 참조를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">또는 이것을 스크립트의 첫 줄로 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">또는 압축하려는 각 파일의 이름을 명시 적으로 지정하지 않고 다음과 같이 fileglob를 사용 하여 현재 디렉토리의 모든 &lt;code&gt;txt&lt;/code&gt; 파일 을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">또는 단순히 비교 를 위해 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 를 사용 하면 항상 올바르게 얻을 수 있습니다. Perl이 나타내는 방식과 정확히 일치하는 문자열로 숫자를 자동으로 표시하는 방법은 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">또는 &lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; 모듈 (표준 Perl 배포의 일부)을 통해 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">또는 GNU libc의 암호화 라이브러리가 Cygwin으로 포팅되었습니다.</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">또는 처음에 목적에 맞는 사용자 정의 유형 맵을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">또는 &lt;code&gt;C&lt;/code&gt; 를 사용하여 개별적으로 액세스 가능한 바이트 레지스터 FL, FH, AL, AH 등의 압축을 풀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">또는 스택으로 직접 바이올린을 사용할 수 있습니다. &lt;code&gt;SP&lt;/code&gt; 는 스택 부분의 첫 번째 요소를 제공 하고 &lt;code&gt;TOP*&lt;/code&gt; 는 최상위 SV / IV / NV / etc를 제공합니다. 스택에. 예를 들어 정수의 단항 부정을 수행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">또는 클래스 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">또는 &quot;@&quot;를 추가하여 옵션이 여러 값을 가질 수 있도록 지정하고 스칼라 참조를 대상으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">또는 &lt;code&gt;plan()&lt;/code&gt; 함수를 사용할 수 있습니다 . 테스트 횟수를 계산해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">또는 GCC_EXEC_PREFIX 환경 변수를 사용하여 Sun의 as 및 ld가 사용되도록 할 수 있습니다. -B 옵션 및 GCC_EXEC_PREFIX 변수에 대한 자세한 내용은 gcc 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">또는 POSIX 모듈 의 &lt;code&gt;W*()&lt;/code&gt; 호출 로 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 값을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">대안은 왼쪽에서 오른쪽으로 시도되므로 전체 표현식과 일치하는 첫 번째 대안이 선택됩니다. 이것은 대안이 욕심 일 필요는 없다는 것을 의미합니다. 예를 들어 , &quot;barefoot&quot;과 &lt;code&gt;foo|foot&lt;/code&gt; 을 일치시킬 때 , &quot;foo&quot;부분 만 첫 번째 대안이므로 일치하며 대상 문자열과 성공적으로 일치합니다. (이것은 중요하지 않을 수도 있지만 괄호를 사용하여 일치하는 텍스트를 캡처 할 때 중요합니다.)</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">raw에 대한 대안</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt; 또는 다른 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack 인증&lt;/a&gt; 옵션 중 하나를 번갈아보십시오 .</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 이이를 직접 수행 할 수는 없지만 &lt;b&gt;DB_File&lt;/b&gt; 위에 투명하게 &lt;b&gt;계층화&lt;/b&gt; 하여이 위업을 달성 할 수있는 모듈이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 에는 Perl 라이센스가 적용 되지만 Berkeley DB가 사용하는 라이브러리는 그렇지 않습니다. 버클리 DB는 자체 저작권 및 라이센스를 보유하고 있습니다. 시간을내어 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">비록 &lt;b&gt;DB_File는&lt;/b&gt; 버클리 DB 버전 1과 함께 사용하기위한 것이다, 그것은 또한이 경우 버전 2, 3 또는 4와 함께 사용할 수있는 인터페이스는 버클리 DB 1.x에서 제공하는 기능에 한정되고 버전 2 이상의 인터페이스가 다른 곳에서는 &lt;b&gt;DB_File&lt;/b&gt; 이 버전 1처럼 작동하도록 정렬합니다.이 기능을 사용하면 버전 1로 작성된 &lt;b&gt;DB_File&lt;/b&gt; 스크립트를 변경하지 않고 버전 2 이상으로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">하지만 &lt;code&gt;$_&lt;/code&gt; 실제로 위의 샘플 필터에 명시 적으로 표시되지 않습니다, 그것은 암시 적으로 자주 사용되었다.</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 일반 없습니다 아직 사용되는 해시에 허위, 그것은 후에도 진정한 남아, 반복자, 약한 참조, 숨겨 놓은 이름을 포함하여 여러 확실치 않은 상황에서 참이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . 이러한 것들로 인해 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 가 실제로 쓸모 없게되므로 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">&lt;code&gt;cmp_ok()&lt;/code&gt; 가 0.40에 도입 되었지만 0.86은 오버로드 된 객체에 안전하도록 중요한 버그를 수정했습니다. 고정은 Test :: More 0.92의 일부로 5.10.1에서 Perl과 함께 처음 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">FileCache를 파이프 열기 ( '-|'또는 '|-')와 함께 사용할 수 있지만 그렇게하지 않는 것이 좋습니다. FileCache가 파이프를 닫았다가 다시 열어야하는 경우 파이프 맨 끝에있는 명령이 다시 실행됩니다. FileCache 파이프에서 IO를 수행 한 결과가 예상과 다를 수 있습니다. 파이프에서 FileCache를 사용하는 기능은 다음 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">난 단지의 사용으로 만든 있지만 &lt;code&gt;POP*&lt;/code&gt; 펄 서브 루틴에서 반환 된 액세스 값으로 매크로를, 이러한 매크로 바이 패스도 가능하며 사용하여 스택을 읽을 &lt;code&gt;ST&lt;/code&gt; 의 매크로 (참조 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 의 자세한 설명에 대한 &lt;code&gt;ST&lt;/code&gt; 의 매크로).</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">PA-RISC 바이너리는 Itanium 시스템에서 실행될 수 있지만 Itanium 시스템에서 Perl의 PA-RISC 버전을 사용해서는 안됩니다. PA-RISC 실행 파일을 실행하는 동안 Itanium 시스템에서 생성 된 공유 라이브러리를로드 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">Perl은 자동으로 문자열을 증가 시키지만, SV에 더 많은 메모리를 할당하도록 Perl을 강제 실행해야하는 경우 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">Plan 9 Perl은 현재 정적로드 만 제공하지만 여러 유용한 확장으로 빌드됩니다. 여기에는 Opcode, FileHandle, Fcntl 및 POSIX가 포함됩니다. 앞으로 다른 사람들 (및 DynaLoading!)을 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">Test :: More는 5.6.2부터 Perl 버전의 핵심 모듈 이었지만 Test :: More는 그 이후로 발전했으며, 제공되는 Test :: 버전에 모든 기능이 포함되어 있지는 않습니다. 더. 모듈을 작성하는 경우 패키지 메타 데이터에 필요한 최소 버전의 Test :: More를 표시해야합니다. 예를 들어 &lt;code&gt;done_testing()&lt;/code&gt; 을 사용 하고 싶지만 테스트 스크립트를 Perl 5.10.0에서 실행하려면 명시 적으로 Test :: More&amp;gt; 0.88이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">5.14부터는 다음과 같이 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">관리자가 엉뚱한 코드를 통해 직업 보안 (또는 급격한 불안감)을 추구한다고 비난하더라도 주장하기는 어렵습니다. :-) 내가 당신이라면, 나는 그것을 기능에 넣을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">C에서 직접적으로 동등한 것은 아니지만 Perl의 &lt;code&gt;//&lt;/code&gt; 연산자는 C 스타일 &quot;또는&quot;과 관련이 있습니다. 실제로, 그것은 &lt;code&gt;||&lt;/code&gt; 사실 대신 왼쪽의 정의를 테스트한다는 점을 제외하고. 따라서 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 는 정의 된 경우 &lt;code&gt;EXPR1&lt;/code&gt; 의 값을 리턴하고 , 그렇지 않으면 &lt;code&gt;EXPR2&lt;/code&gt; 의 값을 리턴합니다. ( &lt;code&gt;EXPR1&lt;/code&gt; 은 스칼라 컨텍스트에서 평가되고, &lt;code&gt;//&lt;/code&gt; 자체 컨텍스트에서 &lt;code&gt;EXPR2&lt;/code&gt; 입니다 ). 일반적으로 이것은 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; 결과와 같습니다 (EXPR1)? EXPR1 : EXPR2 (3 진 연산자 양식을 lvalue로 사용할 수있는 것을 제외하고 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 할 수 없습니다). 변수에 기본값을 제공하는 데 매우 유용합니다. 실제로 &lt;code&gt;$x&lt;/code&gt; 및 &lt;code&gt;$y&lt;/code&gt; 중 하나 이상 이 정의되어 있는지 테스트하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">C에서와 같은 우선 순위를 갖지만 Perl의 &lt;code&gt;?:&lt;/code&gt; 연산자는 lvalue를 생성합니다. $ maybe의 진실성에 따라 $ x를 $ if_true 또는 $ if_false에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">약간 혼란스럽고 일부 사람들은 용어에 반대하지만, 그 의견을 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">불법은 아니지만 비 차단 모드 인 소켓 에서 &lt;code&gt;MultiHomed&lt;/code&gt; 를 사용하는 것은 거의 쓸모 가 없습니다 . 이는 연결 호출이 차단되지 않기 때문에 첫 번째 연결이 시간 초과로 실패하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">이 모듈을 사용하여 .zip 파일에 액세스 할 수는 있지만 (모든 노력을 기울일 수있는) 다른 펄 모듈이 있습니다. 확인 &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">내부적으로 간주 될 수 있지만 클래스 계층은 사용자와 프로그래머 모두에게 중요합니다. CPAN.pm은 위에서 언급 한 4 가지 클래스를 다루며, 이러한 클래스는 모두 일련의 메소드를 공유합니다. 고전적인 단일 다형성이 적용됩니다. 메타 클래스 객체는 모든 종류의 모든 객체를 등록하고 문자열로 색인을 생성합니다. 객체를 참조하는 문자열에는 분리 된 네임 스페이스가 있습니다 (완전히 분리되지는 않음).</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">위의 코드에서 즉시 알 수는 없지만 연관 배열 인터페이스를 사용하여 중복 키로 값을 쓸 수 있지만 데이터베이스에서 다시 읽을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">그것은 진짜 고통처럼 보일지 모르지만, 모든 스크립트에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하려는 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">더 큰 버킷의 메모리 오버 헤드는 버킷 내부에 유지되지만 더 작은 버킷의 경우 별도의 영역에 유지됩니다. 이 필드는이 영역의 총 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">현재 경고가 발생하지 않지만 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 ) 또는 비트 열 ( &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 별 문자열 연산자&lt;/a&gt; 참조) 이 아닌 피연산자에서 이러한 연산이 수행 될 때 결과가 제대로 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">희미한 마음은 아니지만 Perl은 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 선언문을 지원합니다 . : 세 가지 형태가있다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR, 그리고 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME은. 루프의 LABEL은 실제로 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 의 유효한 대상이 아닙니다 . 루프의 이름 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">위의 리터럴 문자열 정규 표현식으로 이미 많은 것을 할 수는 있지만 정규 표현식 기술의 표면을 긁어 냈습니다. 이 섹션과 이후 섹션에서는 정규 표현식이 단일 문자 시퀀스뿐만 아니라 a를 나타내는 정규 표현식 개념 (및 관련 메타 문자 표기법)을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">비록 $ y와 $ z의 수량이 같고 100000과 같을 것으로 기대할지라도 그것들은 다르고 대신에 각각 0과 100000이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">단 하나의 값만 반환 될 것으로 예상되었지만</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">매크로는 다중 스레드 Perl과 함께 사용하도록 설계되었지만 매크로는 스레드가 아닌 Perl에서도 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">비슷하지만 파일 경로 사양은 Unix, Windows, Mac OS, OS / 2, VMS, VOS, RISC OS 및 아마도 다를 수 있습니다. 예를 들어 유닉스는 단일 루트 디렉토리에 대한 우아한 아이디어를 가진 몇 안되는 OS 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">테스트 실패는 충분해야하지만 테스트 실행이 끝나면 추가 진단이 트리거 될 수 있습니다. &lt;code&gt;onfail&lt;/code&gt; 에는 각 테스트 실패를 설명하는 해시 참조의 배열 참조가 전달됩니다. 각 해시에는 최소한 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;repetition&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 필드가 포함됩니다 . (현재 존재하는 다른 필드에 의존해서는 안됩니다.) 테스트에 예상 값이나 진단 (또는 &quot;주&quot;) 문자열이 있으면 이것도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">이 형식은 네트워크 전송 (8 비트 문자로 인해) 또는 ISO- 라틴 문자 이외의 문자 집합에서 문제가 발생할 수 있습니다. 그러나 &lt;code&gt;Is_c1&lt;/code&gt; 을 다시 작성하여 &lt;code&gt;'unicode_strings'&lt;/code&gt; (v5.14 이전) 가없는 Perls에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 코드는 &quot;체크섬&quot;을 반환하는 것으로 문서화되어 있지만 이러한 값을 신뢰하지 마십시오! 적은 수의 바이트에 적용 되더라도 눈에 띄는 해밍 거리를 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">위의 내용은 처음에는 약간 혼란스러워 보일 수 있지만 일반적으로 대부분의 상황에서 &quot;옳은 일&quot;을합니다. 사용할 기본값의 결정은 다음과 같은 일반적인 Unix 규칙을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">위의 오류 메시지는 스크립트의 두 번째 tie () 문을 참조하지만 문제의 원인은 실제로 앞에 나오는 untie () 문입니다.</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">이 플래그가 제공하는 기능은 간단 해 보일 수 있지만 그럴만한 이유가있는 경우에만 사용해야합니다. 주의해야 할 이유는 G_NOARGS 플래그를 지정한 경우에도 호출 된 Perl 서브 루틴이 매개 변수를 전달했다고 생각할 가능성이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">무시 된 인수는 변수로 들어 가지 않지만 호출자가 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">Perl 보안 문제에 대한 주요 논의는 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 에서 찾을 수 있지만 , 로케일 종속 보안 문제에주의를 기울이지 않으면 Perl의 로케일 처리에 대한 논의는 불완전합니다. 권한이없는 사용자가 자신의 로캘을 만들 수있는 시스템의 로캘은 특히 신뢰할 수 없습니다. 악의적 인 (또는 단절된) 로캘은 로캘 인식 응용 프로그램에서 예기치 않은 결과를 제공 할 수 있습니다. 몇 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">가장 깊게 중첩 된 배열 또는 해시 요소는 존재 여부가 테스트 되었기 때문에 존재하지 않을 것이지만, 어떤 중간 요소도 존재합니다. 따라서 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 및 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 는 위의 $ key 요소에 대한 존재 테스트로 인해 존재하게됩니다. 여기에도 화살표 연산자가 사용되는 모든 곳에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">optree는 읽기 전용이지만 다양한 B :: * OP 메소드가 특정 op에 대해 리턴하는 값을 대체 할 수있는 오버레이 기능이 있습니다. &lt;code&gt;$B::overlay&lt;/code&gt; 는 OP 주소로 색인화 된 2 개의 깊은 해시와 메소드 이름을 참조하도록 설정해야합니다. op 메소드가 호출 될 때마다 해시의 값이 있으면 리턴됩니다. 이 기능은 B :: Deparse에서 일부 최적화를 &quot;실행 취소&quot;하기 위해 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">&lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; 의 기본 목적 은 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; 모듈에서 사용하기위한 것이지만 간단한 압축 / 압축 해제 작업을 위해 자체적으로 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">여기에 설명 된 기술은 Perl을 C 프로그램에 임베드 할 때 적용 할 수 있지만이 문서의 기본 목표는 아닙니다. 고려해야 할 다른 세부 사항이 있으며 Perl 포함과 관련이 있습니다. C에서 Perl을 임베드하는 것에 대한 자세한 내용은 &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">주어진 시간에 여러 소스 스트림이 존재할 수 있지만 하나만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">이들은 가족별로 그룹화되어 있지만 모두 우선 순위가 있습니다. 이 결합 된 할당 연산자는 스칼라에서만 작동 할 수있는 반면 일반 할당 연산자는 배열, 해시, 목록 및 참조에 할당 할 수 있습니다. ( &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata의 &lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;컨텍스트&lt;/a&gt; 및 목록 값 생성자 및 &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref의 참조에 지정 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">이 기능은 펄 인수 스택에 그 값을 반환하지만, 그 스택에서 매개 변수를 고려하지 않습니다 (따라서 특히 달리를 호출하기 전에 푸쉬 마크를 할 필요가 없습니다 &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; 예를 들어는).</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">이 키워드는 선택 사항이며 경우에 따라 중복 정보를 제공하지만 항상 사용해야합니다. 이 키워드는 XSUB가 원하는 패키지에 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">이 옵션은 OO 인터페이스와 함께 사용할 수 있지만 대부분 원샷 인터페이스와 함께 사용됩니다. 예를 들어, 아래 코드는 &lt;code&gt;FilterName&lt;/code&gt; 을 사용하여 &lt;code&gt;$zipfile&lt;/code&gt; 저장되기 전에 일련의 파일 이름에서 경로 구성 요소를 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">이 내용은 예제를 사용하여 설명하기가 쉽지만 먼저 몇 가지 중요한 정의를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">매우 유용하지만 경고를 활성화하기 위해 명령 줄에서 &lt;b&gt;-w&lt;/b&gt; 를 사용하는 데있어 큰 문제 는 전부 또는 아무것도 없다는 것입니다. Perl 프로그램을 작성할 때 일반적인 시나리오를 수행하십시오. 코드의 일부는 스스로 작성하지만 미리 작성된 Perl 모듈을 사용할 가능성이 큽니다. 이 경우 &lt;b&gt;-w&lt;/b&gt; 플래그 를 사용하면 작성하지 않은 코드 조각에 경고를 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">최대한의 구성 가능성과 보안을 위해 항상 소스 코드에서 자신의 Perl을 빌드 할 것을 제안하지만, 급한 경우 &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; 을 확인할 수 있습니다 . 이진 분포.</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">쓰기가 어휘 또는 패키지 변수와 함께 작동 할 수 있지만 사용하는 모든 변수는 형식으로 범위를 지정해야합니다. 아마도 대부분의 패키지 변수를 현지화하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 분배는이 모듈에서 이름을 가져 왔지만 이제는 &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx 와 다소 역 호환되는 인터페이스 만 제공하기 위해 존재합니다. 새 코드를 작성하는 경우 대신 &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness를&lt;/a&gt; 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">항상 시민이 되십시오.</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">항상 시스템 호출의 리턴 코드를 확인하십시오. 좋은 오류 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동해야합니다. 어떤 프로그램이 문제를 일으켰는지, 실패한 시스템 호출 및 인수가 무엇인지, (매우 중요 함)에는 무엇이 잘못되었는지에 대한 표준 시스템 오류 메시지가 포함되어야합니다. 간단하지만 충분한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">항상 구성 변수에 대한 변경 사항을 디스크에 커밋합니까?</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">항상 도중에 분해 한 다음 밖으로 나갈 때 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">해당 프로세스가 실제로 파이프에 쓰지 않는 한 파이프의 쓰기 가능한 끝에서 항상 명시적이고 즉시 close ()를 호출하십시오. 명시 적으로 close ()를 호출하지 않더라도 Perl은 전역 삭제 중에 모든 파일 핸들을 닫습니다 (). 앞에서 설명한 것처럼 해당 파일 핸들이 Safe Pipe Open으로 열린 경우 waitpid ()가 호출되어 다시 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">항상 직접 선언 후 START_MY_CXT 매크로를 배치 &lt;code&gt;my_cxt_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">항상 이전에 출시 된 버전과 호환되도록 노력하십시오. 그렇지 않으면 사람들이 의존하는 경우 이전 동작으로 되돌릴 메커니즘을 추가하십시오. 호환되지 않는 변경 사항을 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">SIGNATURE 파일이 패키지에 있고 Module :: Signature가 설치된 경우 항상 서명을 확인하고 확인하려고합니까 (예 / 아니오)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">항상 'd'및 'm'명령으로 업로드 날짜를 표시하려고합니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">항상 &lt;b&gt;-w를&lt;/b&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">항상 하위 태그와 함께 사용하십시오. 주목할만한 형태 : {sgn-gb} 영국 수화 (BSL); {sgn-ie} 아일랜드 수화 (ESL); {sgn-ni} 니카라과 수화 (ISN); {sgn-us} 미국 수화 (ASL).</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">모호한 현지 시간 (DST)</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">아미가 개발자 환경</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">IBM EBCDIC 문자 코드 세트 중에는 종종 다른 정수 값에 맵핑되는 13 개의 문자가 있습니다. 이러한 문자는 13 개의 &quot;변형&quot;문자로 알려져 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">OS / 2에서 변경된 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">&quot;= 항목&quot;단락을 전혀 포함하지 않고 몇 개의 일반 / 언어 단락과 일부 중첩 된 &quot;= over&quot;... &quot;= back&quot;을 포함하는 &quot;= over&quot;... &quot;= back&quot;영역 region, &quot;= for ...&quot;단락 및 &quot;= begin&quot;... &quot;= end&quot;영역 포드에서 이러한 항목이없는 &quot;= over&quot;... &quot;= back&quot;영역은 HTML의 &quot;&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;&quot;요소와 의미가 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;= item *&quot;명령 만 포함하는 &quot;= over&quot;... &quot;= back&quot;영역으로, 각각 몇 개의 일반 / verbatim 단락이 있고 다른 중첩 된 &quot;= over&quot;... &quot;= back&quot;영역, &quot;= for ... &quot;단락 ​​및&quot;= 시작 &quot;...&quot;= 종료 &quot;영역</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;= overm ...&quot;= back &quot;영역에는&quot;= item [text] &quot;명령 만 포함되며, 각 명령 (또는 각 그룹) 뒤에 몇 개의 일반 / verbatim 단락이 있고 다른 중첩 된&quot;= over &quot;가 있습니다. .. &quot;= back&quot;영역 또는 &quot;= for ...&quot;단락 및 &quot;= begin&quot;... &quot;= end&quot;영역</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 단락 만 포함하는 &quot;= over&quot;... &quot;= back&quot;영역 , 각 단락 (또는 각 그룹) 뒤에 몇 개의 일반 / 언어 단락, 기타 중첩 된 &quot;= over&quot;... &quot;= back&quot;영역, &quot;= for ...&quot;단락 및 / 또는 &quot;= begin&quot;... &quot;= end&quot;코드 번호는 각 섹션에서 1부터 시작해야하며 번호를 건너 뛰지 않고 순서대로 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">&quot;독립적 인&quot;하위 식, 하위 문자열과 일치하는 하위 식</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">&quot;perlio&quot;의 &quot;내부&quot;파생물로 버퍼가 없거나 귀찮게 할 수없는 레이어에 Unread () 함수를 제공하는 데 사용할 수 있습니다. (기본적으로이 레이어의 &lt;code&gt;Fill()&lt;/code&gt; 은 스택에서 스스로 터져서 아래 레이어에서 다시 읽습니다.)</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">변경 될 &quot;내부&quot;메소드는 현재 대체 클래스가 정보를 캐시하여 모든 &lt;code&gt;*param*&lt;/code&gt; 호출에 전달할 수 있도록 현재 호출됩니다 . (예,이를 이해하기 위해 소스를 읽어야하는 것은 알려진 버그로 간주됩니다).</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">&quot;&quot;(빈 문자열)의 $ eol은 특별합니다. 이 경우 &quot;소프트 라인 나누기&quot;가 도입되지 않고 이진 모드가 효과적으로 활성화되어 원본 데이터의 &quot;\ n&quot;도 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">&lt;b&gt;XSUB는&lt;/b&gt; XS를 인터페이스의 기본 단위를 형성한다. &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에 의해 컴파일 된 후 , 각 XSUB는 Perl 호출 규칙과 C 호출 규칙 사이의 결합을 제공하는 C 함수 정의에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">&lt;b&gt;익명&lt;/b&gt; 에 대한 참조는 실행시에 생성되는 경우, 외부에서 볼의 신원을 추적 유지 루틴 &lt;b&gt;어휘 변수&lt;/b&gt; 그 어휘 변수 아마 외가 후에도 &lt;b&gt;범위&lt;/b&gt; . 이런 종류의 행동은 수학자에게 폐쇄 감을 부여하기 때문에&amp;ldquo;폐쇄&amp;rdquo;라고 불립니다.</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;형식 인수&lt;/b&gt; 가 &lt;b&gt;실제 인수를&lt;/b&gt; 직접 참조 하고 &lt;b&gt;서브 루틴&lt;/b&gt; 이 형식 인수를 변경하여 실제 인수를 변경할 수 있는 &lt;b&gt;인수&lt;/b&gt; 전달 메커니즘 . 즉, 형식 인수는 실제 인수 의 &lt;b&gt;별명&lt;/b&gt; 입니다. &lt;b&gt;value by call&lt;/b&gt; 도 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;인수&lt;/b&gt; -passing기구되는 &lt;b&gt;정규 인수&lt;/b&gt; 의 복사본을 참조 &lt;b&gt;실제 인수&lt;/b&gt; 및 &lt;b&gt;서브 루틴은&lt;/b&gt; 정규 인수를 변경함으로써 실제 인수를 변경할 수 없다. 참조로 &lt;b&gt;전화&lt;/b&gt; 하기도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">&lt;b&gt;주장&lt;/b&gt; 받는 문자열에서 엿봄 현재 경기 위치의 왼쪽있다.</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">&lt;b&gt;주장은&lt;/b&gt; 현재의 경기 위치의 오른쪽에있는 문자열에서 그 피킹합니다.</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;주장&lt;/b&gt; 뭔가를 말한다 존재 아마도 그것은에 어디에서 어떻게 당신이 그것을 사용할 것이다 어떠한 노력을 포기하지 않고, 어떤 건지 설명합니다. 선언은 말한다 조리법의 일부 &quot;두 잔 가루, 하나의 큰 계란, 네다섯 올챙이 ...&quot;를 참조 같다 &lt;b&gt;문&lt;/b&gt; 은 반대합니다. 일부 선언은 명령문으로도 작동합니다. 본문이 제공되는 경우 서브 루틴 선언도 정의의 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">&lt;b&gt;속성&lt;/b&gt; 의 &lt;b&gt;물체&lt;/b&gt; ; 클래스 전체가 아닌 특정 객체와 함께 저장된 데이터.</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">&lt;b&gt;파일 핸들&lt;/b&gt; 로 사용할 수있는 것으로 평가 되는 &lt;b&gt;표현식&lt;/b&gt; : &lt;b&gt;문자열&lt;/b&gt; (filehandle 이름), &lt;b&gt;typeglob&lt;/b&gt; , typeglob &lt;b&gt;참조&lt;/b&gt; 또는 저수준 &lt;b&gt;IO&lt;/b&gt; 객체.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 산출 &lt;b&gt;값&lt;/b&gt; 것을 &lt;b&gt;오퍼레이터&lt;/b&gt; 에 동작한다. &lt;b&gt;우선 순위&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">ASCII 알파벳과 숫자를 부딪 치는 방법을 알고 있는 &lt;b&gt;증분&lt;/b&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">&lt;b&gt;예를&lt;/b&gt; 의 &lt;b&gt;클래스&lt;/b&gt; . 어떤 사용자 정의 형식 (클래스)인지, 어떤 클래스인지에 따라 무엇을 할 수 있는지 &quot;알고있는 것&quot;. 프로그램은 객체에게 작업을 수행하도록 요청할 수 있지만 객체는 객체를 수행할지 여부를 결정합니다. 어떤 물체는 다른 물체보다 더 수용 적입니다.</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">&lt;b&gt;목적은&lt;/b&gt; 함께 그 데이터를 조작 데이터 및 서브 루틴 번들 데이터 구조이다. 객체의 데이터를 &lt;b&gt;속성&lt;/b&gt; 이라고 하고 서브 루틴을 &lt;b&gt;메소드&lt;/b&gt; 라고 &lt;b&gt;합니다&lt;/b&gt; . 객체는 명사 (사람, 웹 서비스, 컴퓨터)로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;b&gt;오퍼레이터&lt;/b&gt; X &lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; `&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 세 복용 &lt;b&gt;피연산자&lt;/b&gt; . 때로는 발음 &lt;b&gt;삼원&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;오퍼레이터&lt;/b&gt; 의 사이에 오는 &lt;b&gt;오퍼랜드&lt;/b&gt; 등의 곱셈으로서, &lt;code&gt;24 * 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 와 같은 값 목록으로 무언가를 수행 하는 &lt;b&gt;연산자&lt;/b&gt; 입니다 . 일반적으로 &lt;b&gt;인수&lt;/b&gt; 목록 주위에 괄호가 필요없는 명명 된 내장 연산자 (예 : &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; )에 사용 됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 는 다음과 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;$x++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 의 앞에 &lt;b&gt;피연산자를&lt;/b&gt; 같이 &lt;code&gt;++$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;운영자&lt;/b&gt; 특정 순서 관계가 있는지 여부를 말한다 &lt;b&gt;사실&lt;/b&gt; 의 쌍에 대한 &lt;b&gt;피연산자&lt;/b&gt; . Perl에는 숫자 및 문자열 관계 연산자가 있습니다. &lt;b&gt;조합 순서를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 그 주변 &lt;b&gt;피연산자&lt;/b&gt; 각도 운영자 또는 괄호 또는 포옹처럼.</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 두 얻어 &lt;b&gt;피연산자&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;연산자&lt;/b&gt; 그 할당 임무 생활에서이 값으로 변경하는 &lt;b&gt;변수&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">&lt;b&gt;일반 단락&lt;/b&gt; . 첫 번째 줄이 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; 와 일치하지 않으면 단락은 일반적인 단락입니다 .</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수없이 마지막 파일 읽기를 사용합니다. 빈 괄호와 함께 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 다릅니다. 명령 행에 나열되고 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 통해 액세스되는 파일로 구성된 의사 파일을 나타냅니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명시 적으로 열리지 않기 때문에 일반적인 파일 핸들처럼 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이전 의 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;@ARGV&lt;/code&gt; 를 검사하여 입력이 가능한지 확인합니다. 마찬가지로 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 파일 끝을 반환 한 후 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리한다고 가정 하고 &lt;code&gt;@ARGV&lt;/code&gt; 를 설정하지 않은 경우 &lt;code&gt;STDIN&lt;/code&gt; 에서 입력을 읽습니다.; &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; 패키지에 정의 된 서브 루틴 내에서 실행 된 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 은 일반적인 주변 어휘 범위가 아니라이를 호출 한 최초의 비 DB 조각 코드의 범위를 봅니다. Perl 디버거를 작성하지 않으면 일반적으로 이것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수없이 마지막 파일 읽기를 사용합니다. 빈 괄호와 함께 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 다릅니다. 명령 행에 나열되고 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 통해 액세스되는 파일로 구성된 의사 파일을 나타냅니다 . &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 명시 적으로 열리지 않기 때문에 일반적인 파일 핸들처럼 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이전 의 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;@ARGV&lt;/code&gt; 를 검사하여 입력이 가능한지 확인합니다. 마찬가지로 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이 파일 끝을 반환 한 후 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 는 다른 &lt;code&gt;@ARGV&lt;/code&gt; 목록을 처리한다고 가정 하고 &lt;code&gt;@ARGV&lt;/code&gt; 를 설정하지 않은 경우 &lt;code&gt;STDIN&lt;/code&gt; 에서 입력을 읽습니다.; &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 이름이 선언 내에 숨겨져되지 않는 한, 그러나, 그렇게 긴가 평가되는 범위의 어휘 변수를 볼 수 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 자체. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; 패키지에 정의 된 서브 루틴 내에서 실행 된 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 은 일반적인 주변 어휘 범위가 아니라이를 호출 한 최초의 비 DB 조각 코드의 범위를 봅니다. Perl 디버거를 작성하지 않으면 일반적으로 이것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 심지어 패키지 경계를 넘어, 전체 어휘 범위에서 볼 수 있습니다 패키지 변수에 대한 별칭을 선언합니다. 변수가 입력 된 패키지는 사용 시점이 아닌 선언 시점에서 결정됩니다. 이것은 다음과 같은 동작을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 그와 관련된 속성의 목록을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 심지어 패키지 경계를 넘어, 전체 어휘 범위에서 볼 수 있습니다 패키지 변수에 대한 별칭을 선언합니다. 변수가 입력 된 패키지는 사용 시점이 아닌 선언 시점에서 결정됩니다. 이것은 다음과 같은 동작을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 그와 관련된 속성의 목록을 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; 또는 &lt;code&gt;=back&lt;/code&gt; A는 외부 명령이 발견되었다 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 의 코드 블록은 다이 () 함수의 결과, 종료 된 경우에도, 펄이 프로그램 실행 완료과 통역자가 종료되기 직전 후, 즉, 가능한 한 늦게 실행된다. (그러나 그것이 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 통해 다른 프로그램으로 변형 되거나 신호에 의해 물에서 날아가는 경우가 아니라면 자신을 잡아야합니다 (가능한 경우). 파일 내에 여러 개의 &lt;code&gt;END&lt;/code&gt; 블록 이있을 수 있습니다. 정의의 역순으로 실행; 즉 : 마지막, 먼저 (LIFO). &lt;code&gt;-c&lt;/code&gt; 스위치를 사용하여 perl을 실행 하거나 컴파일이 실패하면 &lt;code&gt;END&lt;/code&gt; 블록이 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; 객체는 심볼 / GLOB 참조에 대한 참조합니다 (참조입니다 &lt;code&gt;Symbol&lt;/code&gt; 패키지). &lt;code&gt;IO::Handle&lt;/code&gt; 에서 상속 된 일부 모듈 은 GLOB의 해시 테이블 부분에 객체 관련 변수를 유지하려고 할 수 있습니다. 모듈이 서로 짓밟히는 것을 막기 위해 그러한 모듈은 변수 앞에 _로 구분 된 고유 이름을 붙여야한다고 제안합니다. 예를 들어 IO :: Socket 모듈 은 'io_socket_timeout'에 &lt;code&gt;timeout&lt;/code&gt; 변수를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">더 똑똑하고 안전한 코드</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">예-NULL 종료 문제</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">예 : NULL 종료 문제</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">설치 파일이 포함되어야하며 간단한 설치 지침이 포함되어 있어야합니다. ExtUtils :: MakeMaker를 사용할 때 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">읽은 데이터를 시작 이외의 문자열의 특정 위치에 배치하도록 OFFSET을 지정할 수 있습니다. 음수의 OFFSET은 문자열 끝에서부터 거꾸로 세는 많은 문자의 배치를 지정합니다. SCALAR 길이보다 큰 양의 OFFSET 은 읽기 결과가 추가되기 전에 문자열이 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 바이트로 필요한 크기로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">문자열의 시작 부분 이외의 일부에서 데이터를 쓰도록 OFFSET을 지정할 수 있습니다. 음의 OFFSET은 많은 문자가 문자열의 끝에서부터 거꾸로 세는 것을 쓰도록 지정합니다. SCALAR의 길이가 0이면 OFFSET 0 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">객체는 단순히 데이터 구조입니다</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">SV (또는 AV, HV 등)는 두 부분으로 할당됩니다. head (struct sv, av, hv ...)는 유형 및 참조 횟수 정보를 포함하며 많은 유형의 경우 본문에 대한 포인터 (struct xrv) , xpv, xpviv ...), 각 유형에 특정한 필드를 포함합니다. 어떤 유형은 머리에 필요한 모든 것을 저장하므로 몸이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">하나의 명령으로 SV를 생성하고로드 할 수 있습니다. 로드 할 수있는 값에는 정수 값 (IV), 부호없는 정수 값 (UV), 이중 (NV), 문자열 (PV) 및 다른 스칼라 (SV)의 5 가지 유형이 있습니다. ( &quot;PV&quot;는 &quot;포인터 값&quot;을 나타냅니다. 문자열 만 가리키는 것으로 설명 되었기 때문에 이름이 잘못되었다고 생각할 수도 있지만 다른 것을 가리킬 수도 있습니다. 예를 들어 배열을 가리킬 수 있습니다 그러나 내부의 많은 부분의 기본 가정은 PV가 단지 문자열에 대한 것이라는 가정이기 때문에주의해야합니다. 예를 들어, 후행 &lt;code&gt;NUL&lt;/code&gt; 은 자동으로 고정됩니다. 이 단락에만 문서화되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">SV는 두 번째 인수로 전달 될 수 있습니다. 그렇다면 이름이 할당되어 반환됩니다. 그렇지 않으면 반환 된 SV는 새로운 필멸자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">XSUB 섹션은 다른 section-start 키워드가 발견 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">추상 문자의 정수 값입니다. &lt;b&gt;codepoint&lt;/b&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">값 등을 추가로 확인하기 위해 접근 자 함수를 재정의 할 수 있습니다. 여기서는 &lt;code&gt;count&lt;/code&gt; 요소가 항상 음수가 아닌 것을 원 하므로 그에 따라 &lt;code&gt;count&lt;/code&gt; 접근 자를 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">접근자는 속성 액세스 주위에 추가 코드를 추가 할 수 있습니다. 예를 들어, 생성자에 설정되지 않은 속성에 기본값을 적용하거나 속성의 새 값이 허용되는지 유효성을 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">프로세스를 종료하는 작업은 종료됩니다</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">모든 변수, 참조, 키, 인덱스, 연산자 및 값에 액세스해야하는 것과 대조되는 실제 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;lvalue&lt;/b&gt; 의 의미를 일부 선언적인 방식으로 왜곡하는 형용사 의사 함수 . 현재 세 개의 lvalue 수정 자 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">별명은 공식 유니 코드 문자 이름 (느슨한 일치 이름이 아님) 또는 숫자 코드 포인트 (정수)에 맵핑 될 수 있습니다. 후자는 U + E800에서 U + F8FF와 같은 유니 코드 개인 사용 영역의 코드 포인트에 이름을 지정하는 데 유용합니다. 숫자 코드 포인트는 음이 아닌 정수이거나 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 로 시작하는 문자열 이어야하며 나머지는 16 진수 정수로 간주됩니다. 리터럴 숫자 상수는 부호가 없어야합니다. 앞에 0이 있거나 16 진이 아닌 16 진수가 포함 된 경우 16 진으로 해석됩니다. 그렇지 않으면 십진수로 해석됩니다. &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 시작 하면 유니 코드 코드 포인트로 해석됩니다. 그렇지 않으면 기본으로 해석됩니다. (256 미만의 코드 포인트 만 유니 코드와 네이티브간에 다를 수 있습니다.) 따라서 &lt;code&gt;U+41&lt;/code&gt; 은 항상 라틴 문자 &quot;A&quot;입니다. 그러나 EBCDIC 플랫폼 에서는 &lt;code&gt;0x41&lt;/code&gt; 이 &quot;NO-BREAK SPACE&quot;일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">성명 별명</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn ()의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">스택에서 값을 푸시하는 또 다른 방법은 아마도 매크로를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">대체 구분 기호는 &lt;b&gt;-F를&lt;/b&gt; 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">또 다른 파일 이름이 실제 포인트 &lt;b&gt;파일 이름&lt;/b&gt; 의 실제에 지점을 설정, &lt;b&gt;파일&lt;/b&gt; . &lt;b&gt;운영 체제&lt;/b&gt; 가 기호 링크가 포함 된 &lt;b&gt;경로 이름&lt;/b&gt; 을 구문 분석하려고 할 때마다 새 이름을 대체하고 구문 분석을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Call에 대한 대체 인터페이스를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">캐시 플러시에 대한 다른 방법은 &lt;code&gt;HASH&lt;/code&gt; 옵션 (위 참조)을 사용하여 &lt;code&gt;Memoize&lt;/code&gt; 가 특정 해시 변수를 캐시로 사용 하도록 요청하는 것 입니다. 그런 다음 언제든지 원하는 방식으로 해시를 검사하거나 수정할 수 있습니다. &lt;code&gt;%hash = ()&lt;/code&gt; 사용하여 캐시를 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">대안으로 CamelBones는 Foundation 및 AppKit 클래스와 객체 모두에 액세스 할 수있는 프레임 워크로 Perl에서 전체 GUI 응용 프로그램을 빌드 할 수 있습니다. CamelBone은 SourceForge ( &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt; )에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">정규 표현식 을 디버깅하는 다른 방법은 정규 표현식 내에 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 문 을 포함시키는 것 입니다. 이것은 교대로 역 추적에 대한 한 번에 한 번의 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">substr ()을 lvalue로 사용하는 대신 대체 문자열을 4 번째 인수로 지정하는 것입니다. 이를 통해 splice ()와 마찬가지로 EXPR의 일부를 교체하고 한 번의 작업으로 이전에 있던 것을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">C로 필터를 작성하는 대안은 원하는 언어로 별도의 실행 파일을 작성하는 것입니다. 별도의 실행 파일은 표준 입력에서 읽고 필요한 처리를 수행하며 필터링 된 데이터를 표준 출력에 씁니다. &lt;code&gt;Filter::cpp&lt;/code&gt; 는 별도의 실행 파일로 구현 된 소스 필터의 예입니다. 실행 파일은 C 컴파일러와 함께 번들로 제공되는 C 프리 프로세서입니다.</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">보다 쉽게 ​​무언가를 작성하는 다른 방법; 바로 가기.</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">기본 정규 표현식에 유용한 앵커는</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">최소한 하나의 라이브러리를 찾을 때까지 (순서대로) 검색 할 대체 라이브러리 스펙의 익명 배열. 예 :</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">&lt;code&gt;LC_MONETARY&lt;/code&gt; 에서 정보를 사용하는 데 어려움을 겪는 응용 프로그램은 차변이 신용 인 것처럼 차변 에 서식을 지정할 수 있으며 그 로케일이 전복 된 경우에는 그 반대의 경우도 가능합니다. 또는 홍콩 달러 대신 미국 달러로 지불 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">모듈을 사용하는 응용 프로그램은 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">보다 정확하게 &lt;b&gt;list context&lt;/b&gt; 라고하는 것에 대한 구식 입니다.</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">인수는 매개 변수 선언에서 이름의 주요 부분을 생략하고 그냥 맨손으로 남겨 둠으로써 무시 될 수 &lt;code&gt;$&lt;/code&gt; 의 인장을. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">이전 그림 줄에 연결할 값을 제공하는 인수 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">배열은 길이를 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">배열은 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 배열 이름 (앞에 &lt;code&gt;@&lt;/code&gt; 이없는 ), 대괄호 안에있는 첨자 를 지정하여 한 번에 한 스칼라에 액세스 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">배열의 배열은 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 와 같이 두 개의 아래 첨자로 얻을 수있는 일반적인 오래된 배열 @AoA입니다 . 배열의 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">이름을 포함하는 스칼라 또는 C_constant에 자세히 설명 된 &lt;a href=&quot;#C_constant&quot;&gt;해시&lt;/a&gt; 참조 인 상수 이름의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">로드 된 공유 객체의 파일 이름 배열입니다.</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">부트 스트랩 된 모듈 (패키지) 이름의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">외부 패치 프로그램을 통해 순서대로 적용 할 CPAN 또는 로컬 디스크의 패치 배열. &lt;code&gt;-p&lt;/code&gt; 매개 변수 의 값 이 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 인 경우, 패치를 미리 읽음으로써 결정됩니다. 각 패치의 경로는 로컬 파일 시스템의 절대 경로이거나, &lt;code&gt;patches_dir&lt;/code&gt; 구성 변수에 지정된 패치 디렉토리 또는 표준 배포 이름 형식의 상대 경로입니다 . 예를 들어 CPAN.pm 배포의 distroprefs / 디렉토리를 참조하십시오 (이 예제는 기본적으로 설치되지 않음).</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">부트 스트랩이 작성한 dl_load_file ()에 대한 호출이로드 된 순서대로 리턴 된 핸들의 배열입니다. 로드 된 파일에서 기호를 찾기 위해 dl_find_symbol ()과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">배열은 값 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">단일 요소를 찾기위한 여러 첨자가있는 배열입니다. Perl은 &lt;b&gt;참조를&lt;/b&gt; 사용하여이를 구현합니다. Camel 9 장 &quot;데이터 구조&quot; 를 &lt;b&gt;참조&lt;/b&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">확장 목록에서 성공해야한다고 표시했지만 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;평가&lt;/a&gt; 시도가 실패했습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">메모리 할당 시도가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">인식 할 수없는 속성을 설정하려는 시도는 치명적인 오류입니다. (오류는 트랩 가능하지만 여전히 해당 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 컴파일을 중지합니다 .) 기본 제공 속성이 아닌 모든 소문자 이름으로 속성을 설정하면 (예 : &quot;foo&quot;) &lt;b&gt;-w&lt;/b&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">속성 핸들러가 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 으로 지정 되었지만 처리하도록 정의 된 참조 유형이 &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;ANY&lt;/code&gt; 중 하나가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">속성은 특정 객체에 속하는 데이터입니다. 대부분의 객체 지향 언어와 달리 Perl은 속성을 선언하고 조작하기위한 특별한 구문이나 지원을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">속성 목록은 공백 또는 콜론으로 구분 된 일련의 속성 사양입니다 (선택적 공백 포함). 각 속성 스펙은 간단한 이름이며 선택적으로 괄호로 묶은 매개 변수 목록이 뒤에옵니다. 이러한 매개 변수 목록이 있으면 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 연산자 의 규칙에 대해 과거에 스캔됩니다 . ( &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 인용 및 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .) 그러나 매개 변수 목록은 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 아니라 발견 된대로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 을 쓰면 (?&amp;gt; pattern) 과 비슷한 효과를 얻을 수 있습니다 . 이것은 독립형 &lt;code&gt;a+&lt;/code&gt; 와 동일한 하위 문자열과 일치하며 다음 &lt;code&gt;\g{-1}&lt;/code&gt; 은 일치하는 문자열을 먹는다. 따라서 길이가 0 인 어설 션을 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 의 유사체로 만듭니다 . (이 두 구성의 차이점은 두 번째 구성은 캡처 그룹을 사용하여 나머지 정규 표현식에서 역 참조 순서를 이동한다는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">EXPR 시작시 양의 너비가 일치하면 빈 선행 필드가 생성됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">명시적인 &lt;code&gt;break&lt;/code&gt; 이 발생 하자마자 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">반면에 빈 후행 필드는 일치하는 길이에 관계없이 EXPR의 끝에 일치가있을 때 생성됩니다 (물론 0이 아닌 LIMIT가 명시 적으로 지정되지 않은 경우 이러한 필드는 다음과 같이 제거됩니다). 마지막 예에서). 그러므로:</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">마법, 환상, 환상 또는 저글링. Perl의 마법 같은 &lt;b&gt;dwimmer&lt;/b&gt; 효과가 당신이 기대하는 것을하지 않고 오히려 비전의 산물 인 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">전화 또는 우체국 상자와 매우 유사한 여러 &lt;b&gt;프로세스&lt;/b&gt; 간의 네트워크 통신을위한 엔드 포인트입니다 . 소켓의 가장 중요한 점은 전화 번호와 같은 &lt;b&gt;네트워크 주소&lt;/b&gt; 입니다. 다른 종류의 소켓에는 다른 종류의 주소가 있습니다. 일부는 파일 이름처럼 보이지만 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">전체 컴퓨터 프로그램이 한 줄의 텍스트로 채워졌습니다.</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">숫자 (dec, hex, oct)로 지정된 엔터티가 범위 (1-255)를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">&lt;code&gt;-La:\foo&lt;/code&gt; 형식의 항목은 뒤에 오는 라이브러리를 찾기 위해 &lt;code&gt;a:\foo&lt;/code&gt; 디렉토리를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; 형식의 항목은 라이브러리 &lt;code&gt;foo&lt;/code&gt; 를 지정하며 , 사용중인 컴파일러 종류에 따라 철자가 다르게 입력 될 수 있습니다. GCC를 사용하고 있다면 &lt;code&gt;libfoo.a&lt;/code&gt; 로 변환 되지만 다른 win32 컴파일러에서는 &lt;code&gt;foo.lib&lt;/code&gt; 가 됩니다. 번역 된 이름으로 파일을 찾지 못하면 GCC 또는 다른 win32 컴파일러가 사용되는지 여부에 따라 &lt;code&gt;foo.a&lt;/code&gt; 또는 &lt;code&gt;libfoo.lib&lt;/code&gt; 를 사용하여 파일을 찾기 위해 한 번 더 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">&lt;code&gt;/:nodefault/i&lt;/code&gt; 와 일치하는 항목 은 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 있는 기본 라이브러리 추가를 비활성화합니다 (이것은 매우 드물게 필요합니다).</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리에 대한 모든 검색을 비활성화합니다. &lt;code&gt;-Lfoo&lt;/code&gt; 및 &lt;code&gt;-lfoo&lt;/code&gt; 의 변환은 여전히 적절하게 수행되지만 ( &lt;code&gt;$Config{cc}&lt;/code&gt; 의해 반영된대로 사용중인 컴파일러에 따라 ) 항목이 유효한 파일 또는 디렉토리인지 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; 와 일치하는 항목은 그 뒤에 지정된 라이브러리를 검색 할 수있게합니다. &lt;code&gt;$Config{perllibs}&lt;/code&gt; 지정된 기본 라이브러리를 검색 할 수 있도록 마지막에 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perl 타입의 플래그의 열거입니다. 이러한 파일에서 발견되는 &lt;b&gt;sv.h&lt;/b&gt; 에서 &lt;code&gt;svtype&lt;/code&gt; 의 열거. &lt;code&gt;SvTYPE&lt;/code&gt; 매크로를 사용 하여이 플래그를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">열거 형 값입니다. C에서 열거 형 구성 요소를 전송하는 데 사용됩니다. 열거 형 값을 C로 전달할 이유가 없습니다. perl 내부에 IV로 저장되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 는 개별 비 충돌 테스트 스크립트 자체를 예약 할 수 있어야 &lt;code&gt;make&lt;/code&gt; 유틸리티가 작업 스케줄러와 상호 작용할 수 있도록하는 표준 인터페이스가 없기 때문에 병렬 변수 대신 환경 변수가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">오류가 발생했습니다 ( &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">올바른 개발 프로세스의 필수 부분은 적절한 정보 메시지를 사용하여 적절한 오류 처리를하는 것이지만 로그 파일이 있어야한다고 제안하는 학교가 있습니다.</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">심지어 낯선 템플릿 코드는 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">&lt;b&gt;핸들러&lt;/b&gt; 를 실행 시키는 이벤트입니다 .</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">타입 맵 된 구조체 &lt;code&gt;foo_t *&lt;/code&gt; 에 대한 변환 함수의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">소켓에서 Nagle 알고리즘을 비활성화하는 예 :</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">키릴 문자를 사용하는 러시아어 및 일부 언어의 예 :</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">Perl 코드의 모든 단계의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">이것을 사용하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">출력 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">예외</target>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">이에 대한 예외 는 목록에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 할당 할 수 있다는 것 입니다. 이것은 함수의 반환 값 중 일부를 버릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">PA-RISC 2.0 플랫폼에서 컴파일 된 실행 파일은 동일한 HP-UX 버전을 실행하더라도 PA-RISC 1.1 플랫폼에서 실행되지 않습니다. PA-RISC 2.0 플랫폼에서 Perl을 빌드하고 있고 Perl이 PA-RISC 1.1에서도 실행되도록하려면 컴파일러 플래그 + DAportable 및 + DS32를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">종료 상태 0은 &quot;성공&quot;을 의미합니다. 예를 들어, 두 파일의 내용이 동일한 경우 &lt;b&gt;diff (1)&lt;/b&gt; 은 상태 0으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">종료 상태 1은 비정상이지만 결함이없는 프로그램 종료를 의미합니다. 예를 들어, &lt;b&gt;grep (1)&lt;/b&gt; 은 1 인 상태에서 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">종료 상태가 2 이상이면 치명적인 오류가 발생합니다. 예를 들어, 명령 줄에 잘못된 (알 수없는) 옵션을 지정하면 &lt;b&gt;ls (1)&lt;/b&gt; 은 상태 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">최상층을 제거하는 실험적 의사 층. 니트로 글리세린과 동일한주의를 기울여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">VMS 파일 사양에 대한 설명은 &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">명시 적 형식 매개 변수 지수 등 &lt;code&gt;2$&lt;/code&gt; . 기본적으로 sprintf는 목록에서 사용되지 않은 다음 인수의 형식을 지정하지만 인수를 순서에 맞지 않게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">EBCDIC 기반 컴퓨터에서 Perl 프로그래머가 직면 한 일부 문제에 대한 탐구.</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">값이 변경 될 때 Perl 디버거에서 중단 점을 유발하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">확장은 Perl에서 컴파일 된 C 코드를 호출하는 방법입니다. &lt;a href=&quot;perlxstut&quot;&gt;perlxstut를&lt;/a&gt; 읽는 것은 확장에 대해 더 배울 수있는 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">위 단계로 빌드 된 확장은 동적로드를 지원하는 시스템에서 사용할 수 있습니다. 동적로드를 지원하지 않는 시스템에서는 새로 작성된 확장을 사용 가능한 자원과 연결해야합니다. MakeMaker는 확장 프로그램이 빌드 될 때마다 Makefile에 적절한 대상을 만들어 연결 프로세스를 지원합니다. 다음과 같이 makefile의 해당 섹션을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS에&lt;/b&gt; 정의 된 외부 &lt;b&gt;서브 루틴&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">추가 필드는 0 개 이상의 서브 필드로 구성됩니다. 각 서브 필드는 2 바이트 헤더와 서브 필드 데이터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">기존의 C 또는 C ++ 또는 XS (Experperatingly)라는 확장 언어로 실행되는 매우 뛰어난 익스포트, 매우 우수한 eXternal 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">데이터베이스를 연결하기 전에 잠금 파일을 간단하게 정리하고 연결 해제 후 잠금을 삭제하는 초경량 &lt;b&gt;DB_File&lt;/b&gt; 래퍼입니다. 원하는 경우 교착 상태 문제점을 피하기 위해 여러 데이터베이스에 동일한 잠금 파일을 사용할 수 있습니다. 업데이트를 읽는 데이터베이스가 빠르고 읽기 쉬운 데이터베이스 잠금 시맨틱이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">파일을 닫을 때까지 파일을 여는 특정 인스턴스를 나타내는 식별자 (파일의 실제 이름과 반드시 ​​관련된 것은 아님). 여러 개의 다른 파일을 연속으로 열고 닫을 경우 동일한 파일 핸들로 각 파일을 여는 것이 좋습니다. 따라서 각 파일을 처리하기 위해 별도의 코드를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">즉시 필터를 사용하면 필터가 dbm에 적용되는 지점에서 사용할 필터 코드를 지정할 수 있습니다. 이 모드에서 Filter _ * _ Push 메소드는 정확히 두 개의 매개 변수를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">불완전한 표준</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">다이제스트 알고리즘의 중요한 속성은 다이제스트가</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">옵션 이름 뒤에 &lt;code&gt;+&lt;/code&gt; 를 사용하여 증분 옵션을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">문자 이름 색인은 유니 코드 컨소시엄 ( &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html)&lt;/a&gt; 에서 온라인으로 제공됩니다 . &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where의&lt;/a&gt; 다른 자료에 대한 링크가 포함 된 설명 자료 .</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">간접 파일 핸들은 파일 핸들이 예상되는 장소에서 심볼 이외의 다른 것을 사용하는 것입니다. 간접 파일 핸들링을 얻는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; 를 통해 액세스 할 수있는 유익한 해시 가 수행하는 각 테스트마다 저장됩니다. 따라서 메모리 사용량은 각 테스트 실행마다 선형으로 확장됩니다. 이것은 대부분의 테스트 스위트에서 문제가되지는 않지만 동일한 실행에서 대규모 (수백에서 수백만)의 조합 테스트를 수행하면 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">소스 필터링을 사용하는 입력 파일은 실행 가능한 코드로 파싱되지 않을 것 입니다. 생성 된 코드가 이미 일반 펄이더라도 다시 필터링하지 않아도 소스 필터링 모듈에 대한 &lt;b&gt;사용&lt;/b&gt; 선언이 포함되기 때문에 실행 가능한 코드로 파싱되지 않을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">설치시 유니 코드 데이터베이스를 &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; 에서 &lt;code&gt;$Config{privlib}&lt;/code&gt; / 로 다운로드하여 이들 중 하나를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">실행중인 프로그램의 인스턴스 Unix와 같은 멀티 태스킹 시스템에서 두 개 이상의 개별 프로세스가 동일한 프로그램을 동시에 독립적으로 실행할 수 있습니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 기능은이 행복한 상황을 가져 오도록 설계되었습니다. 다른 운영 체제에서는 프로세스를 종종 &quot;스레드&quot;, &quot;작업&quot;또는 &quot;작업&quot;이라고하며 약간의 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">몫 대신 나머지에 관심이있는 경우 정수 제수입니다.</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">0에서 1까지의 정수입니다. 가장 작은 정보 저장 단위. &lt;b&gt;바이트&lt;/b&gt; 또는 달러 의 8 분의 1 (&amp;ldquo;여덟 조각&amp;rdquo;이라는 용어는 오래된 스페인 달러를 8 비트로 나눌 수 있으며 각각은 여전히 ​​돈으로 계산됩니다. 이것이 오늘날 25 센트짜리 조각이 여전히&amp;ldquo;2 비트&amp;rdquo;입니다.)</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII 테이블에서 32 개의 C0 제어 문자의 흥미로운 특성은 Perl에서 제어 문자로 &quot;문자 그대로&quot;구성 될 수 있다는 것입니다. 예 : &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt; , 등등. EBCDIC 플랫폼의 Perl은 &lt;code&gt;\c@&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;\cA&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; 로 가져 오도록 포팅되었습니다.등이 있지만 결과 문자는 사용중인 코드 페이지에 따라 다릅니다. 아래 표는 컨트롤에 표준 약어를 사용합니다. POSIX-BC 및 1047 세트는이 범위에서 동일하며 한 지점 (십진 21 자)에서만 0037 세트와 다릅니다. 줄 끝 문자에 의해 발생 될 수 있습니다 &lt;code&gt;\cJ&lt;/code&gt; ASCII 플랫폼 만에 의해 &lt;code&gt;\cU&lt;/code&gt; 1047 또는 POSIX-BC 플랫폼에서와 같이 생성 할 수 없습니다 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037 플랫폼에서 제어 문자. 또한 &lt;code&gt;\c\&lt;/code&gt; 는 종결자를 흡수하므로 문자열 또는 정규식의 마지막 요소가 될 수 없습니다. 그러나 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 와 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">내부 &quot;글로브 값&quot;형식 정의는 지주 &lt;b&gt;타입 글로브를&lt;/b&gt; . &lt;code&gt;GV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">내부 I / O 객체 &lt;b&gt;간접 객체를&lt;/b&gt; 의미 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">상수 서브 루틴을 재생성 할 임베디드 펄 코드를 생성하는 내부 함수.</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">상수 서브 루틴을 재생성 할 임베디드 펄 코드를 생성하는 내부 함수. 매개 변수는 C_constant와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C_constant&lt;/code&gt; 에 의해 호출되는 적절한 &lt;code&gt;switch&lt;/code&gt; 절 을 생성하는 내부 메소드</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">하위 레벨 &lt;b&gt;구조&lt;/b&gt; 가 상위 레벨 구조를 둘러싼 프로그램의 내부 표현 .</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">&quot;푸시 팝&quot;코드의 내부 속기. 즉, Perl의 스택 머신을 구현하는 C 코드입니다.</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIO에서 사용하는 내부 변수입니다. 두 부분으로 된 문자열은 &lt;code&gt;\0&lt;/code&gt; 바이트로 구분되며 첫 번째 부분은 입력 레이어를 나타내고 두 번째 부분은 출력 레이어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">잘못된 POD 명령이 발견되었습니다. 유효한 것은 &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">잘못된 마크 업 명령이 발생했습니다. 유효 : &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">&quot;_ *&quot;항목은 &quot;$ _ [0]을 (를) 제외한 모든 _&quot;을 의미하는 것으로 해석됩니다. 즉, &lt;code&gt;@_[1..$#_]&lt;/code&gt; 입니다. $ lh-&amp;gt; maketext (와 같은 호출의 경우에는 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">&quot;_ 인 항목</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">반환 할 최대 필드 수를 지정하는 숫자입니다. 이 인수를 생략하면 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 가능한 한 split이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">언어 클래스에 속하는 개체를 &quot;언어 핸들&quot;이라고합니다. 일반적으로 플라이급 객체입니다.</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD 입력 텍스트의 단락에 해당하는 객체입니다. 일반 단락, 축약 형 단락 또는 명령 단락 일 수 있습니다 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">구문 분석 된 POD 텍스트 트리에 해당하는 객체입니다. 구문 분석 트리의 각 &quot;노드&quot;</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD 입력 텍스트의 내부 시퀀스 명령에 해당하는 객체입니다 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">객체는 단순히 어떤 클래스에 속하는지를 알고있는 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">이름과 성을 두 개의 인수로 초기화하는 객체 메소드입니다. 클래스 메소드로 호출되면, &lt;code&gt;init()&lt;/code&gt; 는 주어진 클래스에 객체를 생성하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">첫 번째 및 세 번째 양식으로 작성된 클래스의 오브젝트는 배열을 기반으로하는 반면 두 번째 양식으로 작성된 클래스의 오브젝트는 해시를 기반으로합니다. 배열 기반 형식은 다소 빠르며 작습니다. 해시 기반 양식이 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive :: Tar 클래스의 객체는 파일과 사물로 가득 찬 .tar (.gz) 아카이브를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">POD 내부 시퀀스 명령을 나타내는 객체입니다. 다음과 같은 방법 / 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">POD 입력 텍스트의 단락을 나타내는 객체입니다. 다음과 같은 방법 / 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">객체는 하나의 별개의 것을 나타냅니다. 예를 들어, 객체는 파일을 나타낼 수 있습니다. 파일 객체의 속성에는 경로, 내용 및 마지막 수정 시간이 포함될 수 있습니다. 표시 할 객체를 만든 경우</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">할당 연산자를 오버로드하는 객체는 해당 객체에 대한 할당에 대해서만 그렇게합니다. 즉, Perl은 세 번째 인수 ( &quot;스왑&quot;인수)를 TRUE로 설정하여 해당 메소드를 호출하지 않습니다. 예를 들어, 작업</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">객체의 멤버는 변수로 액세스 할 수 없습니다. &lt;code&gt;with(object) { method() }&lt;/code&gt; 가장 가까운 Perl 은 &lt;code&gt;for&lt;/code&gt; 이며, &lt;code&gt;$_&lt;/code&gt; 를 객체에 별칭으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">그러나 객체는 축복 된 데이터에 대한 참조이므로 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 가 객체 인 경우 할당 &lt;code&gt;$a = $b&lt;/code&gt; 는 참조 만 복사하므로 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 는 동일한 객체 데이터를 참조합니다. 하나는 따라서 동작 예상 &lt;code&gt;--$a&lt;/code&gt; 감소하는 &lt;code&gt;$b&lt;/code&gt; 뿐만 아니라 같은 &lt;code&gt;$a&lt;/code&gt; . 그러나 이것은 수학 연산자가 작동하는 방식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">오래된 스타일은 다음과 같이 파일 핸들로 베어 워드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">op는 Perl이 수행 할 수있는 기본 조작입니다. 모든 내장 함수와 연산자는 op입니다. 인터프리터가 내부적으로 필요로하는 개념을 처리하는 일련의 ops가 있습니다. 변수 등.</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 처럼 &lt;b&gt;피연산자가&lt;/b&gt; 하나 뿐인 연산자 또는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; . 단항 연산자는 일반적으로 접두사 연산자입니다. 즉, 피연산자보다 앞에옵니다. &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 연산자는 하나 접두사 나 접미사가 될 수 있습니다. (그들의 위치</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname 또는 optag 앞에 느낌표 (예 :! mkdir)를 접두어로 붙일 수 있습니다. opname 또는 optag를 무효화한다는 것은 해당 시점에서 누적 된 op 세트에서 해당 op를 제거하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 와 같은 패턴 또는 대체 옵션 을 사용하여 패턴을 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">프로그램이 작동하는 방식에 영향을주기 위해 명령 행에 제공하는 옵션으로, 일반적으로 빼기 부호가 있습니다. 이 단어는 또한 &lt;b&gt;switch 문의&lt;/b&gt; 별명으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN 배포에서 제공하는 선택적 기능</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">출력이 인쇄 될 선택적 파일 핸들 (또는 IO :: Handle)입니다.</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">출력 문자열이 인쇄 될 선택적 파일 핸들 (또는 IO :: Handle)입니다.</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">선택적 매개 변수는 필수 매개 변수처럼 이름이 없을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; 선언 의 선택적 부분으로 Perl 컴파일러에게 &lt;b&gt;실제 인자&lt;/b&gt; 로 전달할 수있는 인자의 수와 종류를 알려주 므로 내장 함수와 매우 유사하게 구문 분석되는 서브 루틴 호출을 작성할 수 있습니다. (또는 경우에 따라 구문 분석하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">선택적 세 번째 매개 변수를 사용하여 복사에 사용되는 버퍼 크기를 지정할 수 있습니다. 이것은 첫 번째 파일의 바이트 수이며 두 번째 파일에 기록되기 전에 주어진 시간에 메모리에 보유됩니다. 기본 버퍼 크기는 파일에 따라 다르지만 일반적으로 전체 파일 (최대 2MB)이거나 파일을 참조하지 않는 파일 핸들 (예 : 소켓)의 경우 1k입니다.</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">정렬 된 일련의 &lt;b&gt;값&lt;/b&gt; 으로 저장된 값을 사용하여 값에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">순서가 지정된 스칼라 값 집합입니다.</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">Perl 인터프리터 소스 코드 개요 및 Perl의 기능에 대한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl 소스 트리의 개요 원하는 파일을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">포착되지 않은 &lt;b&gt;예외로 &lt;/b&gt;&lt;b&gt;표준 오류&lt;/b&gt; 스트림 에 메시지를 인쇄 한 후 &lt;b&gt;프로세스&lt;/b&gt; 가 종료됩니다 . &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 발생하는 오류는 치명적이지 않습니다. 대신, 예외 메시지를 &lt;code&gt;$@&lt;/code&gt; ( &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) 변수에 놓은 후 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 종료됩니다 . &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 치명적인 오류를 유발하려고 시도 할 수 있지만 (예외 발생 또는 예외 발생) 동적으로 둘러싸인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 의해 발생할 수 있습니다 . 잡히지 않으면 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 치명적인 오류가됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">정의되지 않은 값은 레코드 분리 자로 허용되지 않습니다. Perl의 특수 &quot;단락 모드&quot;시맨틱 (a la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; )은 에뮬레이션되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">프로그램 내에서 목록 생성 함수에서 &lt;b&gt;목록 컨텍스트&lt;/b&gt; 를 제공하는 함수 또는 구문으로 전달 될 수있는 이름없는 임시 스칼라 값 &lt;b&gt;목록&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">문자열 &lt;b&gt;키&lt;/b&gt; 를 사용하여 관련 데이터 &lt;b&gt;값&lt;/b&gt; 을 쉽게 찾을 수 있도록 저장된 &lt;b&gt;키&lt;/b&gt; / &lt;b&gt;값&lt;/b&gt; 쌍 의 정렬되지 않은 연관 . 이 용어집은 해시와 같습니다. 여기서 정의 할 단어가 핵심이고 정의는 값입니다. 해시는 때로는 분리 적으로&amp;ldquo;연관 배열 (associative array)&amp;rdquo;이라고도하는데,이를 단순히&amp;ldquo;해시&amp;rdquo;라고 부르는 아주 좋은 이유입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">설정되지 않거나 비어있는 PERLIO는 플랫폼의 기본 레이어 세트와 같습니다. 예를 들어, Unix 계열 시스템의 경우 &lt;code&gt;:unix:perlio&lt;/code&gt; , Windows 및 기타 DOS 계열 시스템의 경우 &lt;code&gt;:unix:crlf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">부호없는 바이트</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">PA-RISC 설계로의 업그레이드로 수년 동안 다양한 시스템으로 출하되었습니다.</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; 와 유사하게 매크로가 여러 인수에서 첫 번째 또는 마지막 인 경우와 동등한 형식이 있습니다. 밑줄은 &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; 및 &lt;code&gt;pMY_CXT_&lt;/code&gt; 와 같이 쉼표를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">Boyer-Moore 알고리즘 인 fbm_instr ()을 사용하여 빠르게 검색하기 위해 문자열을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">아 난타 케 사리 HY (hyanantha@novell.com) Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xs 파일 분석</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">타입 맵 분석</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">그리고 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 는 홀수 비트 수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">현재 사용중인 값을 보여주는 인쇄 :</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">그리고 &quot;11&quot;테스트를 &quot;13&quot;으로 늘리면서 Mytest.t에 다음 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">또한 .xs 파일 끝에 다음 함수 정의를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">그리고 짝수 패리티 비트는 다음과 같이 결정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">그리고 &lt;code&gt;=encoding&lt;/code&gt; 이외의 모든 명령 은 끝날 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">그리고 다른 곳 :</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">그리고 위의 모든 사항을 고려하더라도 ANSI는 여전히 이것을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">마지막으로 다음과 같은 Makefile.PL 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">마지막으로 &lt;code&gt;U&lt;/code&gt; 가 첫 번째 활성 형식 이 &lt;b&gt;아닌&lt;/b&gt; 경우 유니 코드 문자열을 만들지 않는지 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">마지막으로 CHAR OF CHARMAP은 섹션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">마지막으로 &lt;code&gt;//&lt;/code&gt; 일치하는 기본 구분 기호는 &lt;code&gt;'m'&lt;/code&gt; 을 앞에 두어 임의의 구분 기호로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">마지막으로 UNICODE_WARN_ILLEGAL_INTERCHANGE 플래그는 위의 WARN 플래그 4 개를 모두 선택합니다. UNICODE_DISALLOW_ILLEGAL_INTERCHANGE는 4 개의 DISALLOW 플래그를 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">정확한 결과를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">그리고 반환 값을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">그리고 그것들을 쓸 수있는 다른 휴대용 방법들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">그리고 여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">그리고 여기 펄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">그리고 &lt;code&gt;comment&lt;/code&gt; 메소드 (연결된 객체가 필요함) 를 사용하도록 수정 된 이전 예제 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">그리고 여기에 위의 모델을 모델로 한 서브 루틴이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">그리고 여기에 해당 서버가 있습니다. 커널이 멀티 홈 호스트에서 적절한 인터페이스를 선택할 수 있도록 주소를 &lt;code&gt;INADDR_ANY&lt;/code&gt; 로 그대로 둡니다 . 게이트웨이 나 방화벽 시스템의 외부와 같은 특정 인터페이스에 앉아 싶다면 실제 주소로 대신 채우십시오.</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">그리고 여기 해당 서버가 있습니다. 유닉스 도메인 소켓이 로컬 호스트에 보장되므로 모든 것이 올바르게 작동하기 때문에 바보 같은 네트워크 터미네이터에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">그리고 멀티 태스킹 버전이 있습니다. 가장 일반적인 서버와 마찬가지로 멀티 태스킹되어 마스터 서버가 신속하게 새 클라이언트 서비스를 다시 시작할 수 있도록 클라이언트 요청을 처리하기 위해 슬레이브 서버를 생성 (fork ())합니다.</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">다음은 Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 연산자를 다시 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">그리고 여기에는 글을 쓸 수있는 안전한 파이프가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">그리고 그것이 어떻게 사용되는지는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">그리고 읽으려는 자식 프로세스를 시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">그리고 여기 에 POSIX termios 구조를 조작하기위한 다소 신비로운 호출을 숨기는 &lt;code&gt;HotKey&lt;/code&gt; 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">그리고 정수라면</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">그리고 사용중인 프로토콜이 수신자에게 사용중인 문자 인코딩을 알려주는 방법을 지원하는 경우 해당 기능을 사용하여 수신 끝을 도와주세요! 예를 들어 전자 메일 및 HTTP는 MIME 헤더를 지원하므로 &lt;code&gt;Content-Type&lt;/code&gt; 헤더를 사용할 수 있습니다 . 또한 &lt;code&gt;Content-Length&lt;/code&gt; 를 사용하여</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">그리고 내부 그룹에서 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 0 ~ 5 일치로 제한하지 않으면 영원히 또는 스택 공간이 부족해질 때까지 시간이 걸립니다. 또한 이러한 내부 최적화가 항상 적용 가능한 것은 아닙니다. 예를 들어, 외부 그룹 에 &lt;code&gt;*&lt;/code&gt; 대신 &lt;code&gt;{0,5}&lt;/code&gt; 를 입력하면 현재 최적화가 적용되지 않으며 일치하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">이전 명령을 반복하려면 느낌표를 사용하십시오. ' &lt;b&gt;! &lt;/b&gt;':</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">5 행을 다시 나열하려면 'l 5'를 입력하십시오 (공백에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">그리고 포매터 클래스를 작성하지 않고 대신 Pod :: PullParser 객체 (하위 클래스의 객체가 아님)를 사용하여 간단한 작업을 수행하는 프로그램을 작성하는 경우 하위 클래스를 작성하여 &lt;code&gt;run&lt;/code&gt; 을 추가 할 이유가 없습니다. 방법.</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">그리고 gdb에서 :</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">그리고 gdb에서 :</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">그리고 유닉스 값 1의 특별한 경우 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">그리고 그것은 효과가 있었다. 오늘날에는 이러한 레거시 표준이 거의 사용되지 않습니다. 대부분의 사람들은 유니 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">또한 프로그램이 끝날 때까지 기다리지 않고 프로그램의 stdout 처리를 즉시 시작할 수 있기 때문에 속도도 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">루프를 시작하기 직전에 &lt;code&gt;patcopy&lt;/code&gt; 를 &lt;code&gt;pat&lt;/code&gt; 의 시작으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">다단계 해시를 사용하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">그리고 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">그리고 몇 달 동안 현지에서 :</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">'| 1'또는 '| 3'항목이 '| 0'항목을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">그리고 &lt;code&gt;SHELL&lt;/code&gt; 환경 변수가 이것을 가리 키도록하십시오</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">그리고 더 많은 기타 기능 :</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">그리고 이제리스트 연산자로서 몇 가지 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">이제 &lt;code&gt;tzname&lt;/code&gt; 을 호출하는 Perl 프로그램 에서 두 값이 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">그리고 우리가 그것을 실행할 때, 우리는 여전히 &quot;\ n&quot;을 얻지 만, 최소한 이유를 알고 있습니다. 이 스크립트를 컴파일하면 '$ varl'(문자 'l') 변수가 노출되고 $ varl을 $ var1로 변경하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">이제 이러한 변수 중 하나에 액세스 할 때마다 현재 시스템 우선 순위가 검색되어 리턴됩니다. 해당 변수가 설정되면 프로세스 우선 순위가 변경됩니다!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">이제는 키 자체가 완전히 동일한 경우에만 복제본을 갖게됩니다. (참고 : 1996 년 11 월 이전의 db 라이브러리 버전에서는 이러한 중복 키가 유지되므로 동일한 키 세트로 원래 키를 복구 할 수있었습니다).</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">물론 매우 기본적인 테스트 :</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">그리고 오프 기회에 당신은 대괄호 표현에 문자 물결표가 필요합니다, 당신은 그것을 &quot;~~&quot;로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">또한 Solaris 8에서만 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">그리고이 중 마지막 두 개만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">다른 할당 변형은 &lt;code&gt;'+='&lt;/code&gt; 및 &lt;code&gt;'-='&lt;/code&gt; 와 유사합니다 (위의 &lt;code&gt;'.='&lt;/code&gt; 및 &lt;code&gt;'x='&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">그리고 아마도 가장 중요한 것은 항목을 일관성있게 유지하는 것입니다. 모든 항목에 &quot;= item *&quot;를 사용하여 글 머리 기호를 생성하십시오. 또는 &quot;= 항목 1&quot;, &quot;= 항목 2&quot;등을 사용하여 번호 매기기 목록을 생성하십시오. 또는 &quot;= item foo&quot;, &quot;= item bar&quot;등을 사용하십시오. 즉, 글 머리 기호 나 숫자처럼 보이지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">그리고 우리가 그 주제에 있기 때문에 ...</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">그리고 이것도 마찬가지입니다 :</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">그리고 모든 행동에서 성공은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">그런 다음 $ greetings {$ wanted}를 조회하여 $ wanted 언어에 대한 클라이언트 요청에 응답한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">그리고 해당 파일을 읽고 데몬으로 실행하는 프로그램을 작성하여 언어 태그를 지정하는 클라이언트 요청에 응답 한 다음 해당 언어로 인사하는 방법을 나타내는 문자열을 기대한다고 가정하십시오. 상호 작용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">그리고 그것은 옳은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">그리고 첫 번째 단점은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 템플릿에 여분의 채우기 바이트를 얻기 위해 &lt;code&gt;x&lt;/code&gt; 코드 가 채워져 있어야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">그리고 제거 :</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">그런 다음 적어도 keys () 대신 values ​​()를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">그런 다음 하드 코딩하여 후임자에게 연습으로 남겨 두십시오.</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">그리고 어휘집에 컴파일 된 값을 저장하는 대신 $ lh-&amp;gt; { '_ external_lex_cache'}에 저장합니다</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">그런 다음 필요에 따라 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 를 선택하여 이전과 같이 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">그런 다음 밑줄을 이중 콜론 (: :)으로 매핑 하는 형식 맵 항목 &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; 을 제공하고 &lt;code&gt;Net_Config&lt;/code&gt; 를 해당 유형으로 선언 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">그런 다음 해시 이름을 참조로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">그런 다음 PERL5LIB를</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">그리고 당신이 찾고있는 것을 칠 때까지 밟으십시오. 특정 반복에서만 중단하려는 경우 루프에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">그리고이 조건들은</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">그리고 그것들은 모두 이것과 정확히 같은 의미입니다 :</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">그리고이 예제는 익명 서브 루틴을 사용하여 별도의 카운터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">그리고 이것은 XS 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">그리고 이것은 위의 스크립트가 인쇄 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">그리고 이것은 전체 이야기가 아닙니다. Perl v5.12부터 UTF-8로 인코딩되지 않은 문자열은 다양한 조건에서 유니 코드로 취급 될 수 있습니다 ( &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode의 ASCII 규칙 대 유니 코드 규칙&lt;/a&gt; 참조 ). 이것은 서 수가 128과 255 사이 인 문자에만 실제로 문제가되며 ASCII와 유니 코드 규칙에 따라 코드가 신경 쓰는 방식에 따라 동작이 달라집니다 ( &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 유니 코드 버그&lt;/a&gt; 참조 ). 변경 될 수 있으므로이를 처리하기위한 게시 된 API는 없지만 &lt;code&gt;pp_lc&lt;/code&gt; 의 코드는 다음에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">그리고 이것은 아이에게서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">그리고 이것도 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">이:</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">perl이 라이브러리 디렉토리를 검색하는 순서를 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">그리고 대리하여;</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">그리고 다시 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">그리고 우리는 프로그램으로 끝납니다 :</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 UTF-8의 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">그리고 호출자 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">이전 예제에서 알 수 있듯이 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 재정의 하면 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob 연산자도 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">또한 Name 및 Name_Aliases 속성은 큰 따옴표로 묶인 문자열과 정규식에서 &lt;code&gt;\N{}&lt;/code&gt; 보간을 통해 액세스 할 수 있습니다 . 그리고 함수 &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; 및 &lt;code&gt;charnames::string_vianame()&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; 이 필요합니다).</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">또한 Perl 5.10 이상에서는 개체가 역할을 처리 할 수 ​​있는지 상속을 확인할 필요가 없습니다. 이를 위해 &lt;code&gt;UNIVERSAL&lt;/code&gt; 에서 제공되는 &lt;code&gt;DOES&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">앤디 암스트롱 &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">앤디 암스트롱, &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; 의 VMS 지원 . Ilya Zakharevich의 OS / 2 지원 &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">소스에서 컴파일 된 코드 팽창에 대한 일화적인 추정치가 8 배 증가한 것으로 나타났습니다. 이는 합법적 인 (일반적으로 주석을 달고 올바르게 들여 쓰기 된) 코드의 컴파일 된 형태가 코드가 디스크에서 차지하는 것보다 메모리에서 약 8 배 더 많은 공간을 차지함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; 로 작성되지 않은 꺾쇠 괄호 는 마크 업 명령으로 잘못 해석 될 수 있으므로 잠재적으로 오류를 일으킬 수 있습니다. 경고 수준이 1보다 큰 경우에만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel (ANNO)은 xs 코드를 작성했으며 Perl의 Jerry Jedden (JDHEDDEN)의 변경으로 인해 더 빨랐습니다.</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads/shared&quot;&gt;스레드에&lt;/a&gt; 대한 주석이 달린 POD :: shared : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">주석이 달린 문자 목록</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">이와 같은 익명의 해시 및 배열 작성기를 자유롭게 혼합하여 원하는만큼 복잡한 구조를 만들 수 있습니다. 아래에 설명 된 다차원 구문은 이것들에도 적용됩니다. 위의 값은 리터럴이지만 Perl의 할당 연산자 (local () 또는 my () 내)도 컴파일 타임 선언이 아닌 실행 가능한 명령문이기 때문에 변수와 표현식도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">익명 서브 루틴은 my () 변수, 즉 현재 범위 내에서 어휘 적으로 볼 수있는 변수와 관련하여 클로저 역할을합니다. 클로저는 특정 어휘 컨텍스트에서 익명 함수를 정의하면 컨텍스트 외부에서 호출되는 경우에도 해당 컨텍스트에서 실행되는 것처럼 가장하는 Lisp 세계의 개념입니다.</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">익명 서브 루틴은 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 오퍼레이터가 즉시 작성 되므로 서브 오퍼레이터 를 실행할 때마다 캡처됩니다 . 고유 한 개인 변수를 가진 다른 프로그래밍 언어에서 중첩 서브 루틴을 사용하는 데 익숙하다면 Perl에서 약간의 작업을 수행해야합니다. 이 유형의 것을 직관적으로 코딩하면 위에서 설명한 이유 때문에 &quot;공유하지 않습니다&quot;라는 이상한 경고가 발생합니다. 예를 들어, 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">또 다른 예-키는 C int입니다.</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">다른 예 : 키는 C int입니다.</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">또 다른 휴대용 이진 인코딩</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">약간 더 유용한 또 다른 간단한 디버거는 다음 줄만 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">또 다른 일반적인 오류는 일반 괄호를 사용하여 대괄호 또는 중괄호를 사용해야 할 때 목록 참조를 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">이 구조의 또 다른 일반적인 용도는 쉘의 간섭없이 무언가를 실행해야 할 때입니다. system ()을 사용하면 간단하지만 파이프 개방 또는 백틱을 안전하게 사용할 수 없습니다. 쉘이 당신의 주장에 손을 대지 못하게 막을 방법이 없기 때문입니다. 대신 하위 수준 컨트롤을 사용하여 exec ()를 직접 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">또 다른 문제는 유니 코드를 저장해야하는 경우 프로그램에 사용 된 표현이 다르지만 구문 분석 중반까지 수행되는지 여부를 항상 알 수있는 것은 아닙니다. 프로그램의 유니 코드 표현이 더 커서 효율적으로 일치시킬 수 없습니다. ( 이유에 대한 자세한 내용은 아래의 &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;유니 코드 및 현지화 지원&lt;/a&gt; 을 참조하십시오.) 패턴에 리터럴 유니 코드가 포함 된 경우 프로그램에서 유니 코드를 저장해야합니다. 그렇지 않으면 파서는 더 효율적인 표현을 사용할 수 있다고 낙관적으로 가정하고이를 기준으로 크기 조정을 시작합니다. 그러나 패턴에서 &lt;code&gt;\x{...}&lt;/code&gt; 와 같이 유니 코드로 저장해야하는 무언가가 발생하면문자 리터럴을 나타내는 이스케이프 시퀀스 인 경우 이는 유니 코드 표현에 적절한 값을 사용하여 이전에 계산 된 모든 크기를 다시 실행해야 함을 의미합니다. 현재 이것을 트리거 할 수있는 모든 정규 표현식 구성은 &lt;code&gt;regatom()&lt;/code&gt; 코드로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">이 두 속성을 혼동하는 또 다른 혼동은 그 정의가 코드 포인트가 아니라는 것입니다</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">binmode () 사용 (일부 시스템에서)의 또 다른 결과는 특수 파일 끝 마커가 데이터 스트림의 일부로 표시된다는 것입니다. Microsoft 제품군의 시스템에서 이는 바이너리 데이터에 &lt;code&gt;\cZ&lt;/code&gt; 포함 된 경우 binmode ()를 사용하지 않는 한 I / O 서브 시스템이이를 파일의 끝으로 간주 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">주의해야 할 또 다른 구문 은 정규식에서 16 진 ( &lt;code&gt;\N{U+...}&lt;/code&gt; 을 사용하지 않는 한 ) 또는 8 진 상수를 부적절하게 사용하는 것입니다 . 다음과 같은 서브 세트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">또 다른 설명은 &quot;더 나은&quot;/ &quot;나쁜&quot;이라는 개념으로 시작합니다. 주어진 정규 표현식과 일치 할 수있는 모든 하위 문자열은 &quot;최고&quot;일치에서 &quot;최악&quot;일치로 정렬 될 수 있으며 선택된 &quot;최고&quot;일치입니다. 이것은 &quot;무엇을 선택합니까?&quot;라는 문제를 대체합니다. &quot;어떤 경기가 더 좋고 어떤 것이 더 나빠?&quot;</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">또 다른 단점은 5.6.0 이전의 Perl 버전에만 유효합니다. 이 단점은 찾기 및 말하기 기능 (내장 버전 및 POSIX 모듈 버전 모두)이 올바르게 수행되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">또 다른 더미 층. 푸시되면 자체적으로 팝업 되고 스택의 맨 위에 있던 레이어에 &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">데이터 단락의 다른 예 :</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">다른 예제는 포드 파일에서 &quot;utf8&quot;로 찾은 첫 번째 &quot;latin1&quot;인코딩을 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">또 다른 예:</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">코드 표현의 다른 형태는</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">발생할 수있는 또 다른 형태의 최적화는 분석 후 &quot;핍홀&quot;최적화인데, 여기서 비효율적 인 구조는보다 효율적인 구조로 대체됩니다. &lt;code&gt;TAIL&lt;/code&gt; 에 가지 끝에 및 그룹의 끝을 표시하기 위해 분석하는 동안 사용되는 regops 이것의 예이다. 이 regops는 건설 기간 동안 위치 표시기로 사용 그들이 가리킨 있다는 것을하여 &quot;멀리 최적화&quot;할 수 있도록 &quot;항상 일치&quot;하는 &lt;code&gt;TAIL&lt;/code&gt; 의 물건을 가리키고 있음을 &lt;code&gt;TAIL&lt;/code&gt; 의 점, 따라서 노드를 &quot;건너 뛰기&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">상대 역 참조를 사용하기위한 가독성 및 유지 관리성에 대한 또 다른 좋은 이유는 다음 예에 설명되어 있습니다. 여기서 고유 한 문자열을 일치시키기위한 간단한 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC에 대한 또 다른 흥미로운 접근 방식은 단일 프로그램을 다중 프로세스로 전환하여 서로간에 또는 심지어 서로간에 통신하게하는 것입니다. open () 함수는 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 의 파일 인수를 허용합니다. 또는 매우 흥미로운 일을하기 위해 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; : 열린 파일 핸들에 연결된 자식을 포크합니다. 자식이 부모와 같은 프로그램을 실행하고 있습니다. 예를 들어, 가정 된 UID 또는 GID에서 실행할 때 파일을 안전하게 여는 데 유용합니다. 파이프를 열면</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">전송할 또 다른 흥미로운 신호는 신호 번호 0입니다. 이것은 실제로 자식 프로세스에 영향을 미치지 않지만 대신 활성 상태인지 또는 UID를 변경했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">로케일 종속 정보를 조회하기위한 또 다른 인터페이스는 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 함수이며, 적어도 유닉스 계열 시스템 및 VMS에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">다른 종류의 클라이언트-서버 설정은 연결이 아니라 메시지를 사용하는 것입니다. UDP 통신은 오버 헤드가 훨씬 낮아 지지만 메시지의 순서와 무관심은 물론 메시지가 도착할 것이라는 약속이 없기 때문에 안정성이 떨어집니다. 그럼에도 불구하고 UDP는 한 번에 (대개 로컬 서브넷에서) 전체 대상 호스트에 &quot;브로드 캐스트&quot;또는 &quot;멀티 캐스트&quot;할 수있는 등 TCP보다 몇 가지 이점을 제공합니다. 안정성에 대해 지나치게 우려하고 메시지 시스템에 대한 검사를 시작하려면 TCP 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">확인해야 할 다른 메모리 제한 항목은 'SYS1.PARMLIB (BPXPRMxx)'데이터 세트의 MAXASSIZE 매개 변수입니다 (RACF 프로파일의 USS 세그먼트에서 V2R8 주소 공간 한계를 사용자 ID별로 설정할 수 있음에 유의하십시오) . 사람들은 503316480만큼 작은 MAXASSIZE 매개 변수로 성공적인 Perl 빌드를보고했습니다 (그리고 MAXASSIZE보다 작은 Perl을 빌드하는 것이 가능할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">이 수정 자의 또 다른 니모닉은 &quot;의존&quot;입니다. 실제로 사용되는 규칙은 여러 가지에 따라 달라 지므로 예기치 않은 결과를 얻을 수 있습니다. &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode의 유니 코드 버그를&lt;/a&gt; 참조하십시오 . 유니 코드 버그는 다소 악명이 높아져이 수정자인 &quot;Dodgy&quot;의 또 다른 이름 (인쇄 가능)으로 이어졌습니다.</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">템플릿 알파벳의 또 다른 홀드 아웃은 &lt;code&gt;u&lt;/code&gt; 로 , &quot;uuencoded string&quot;을 포함합니다. ( &quot;uu&quot;는 Unix-to-Unix의 줄임말입니다.) 단순한 ASCII 데이터 이외의 다른 지원하지 않는 구식 전송 매체의 단점을 극복하기 위해 고안된이 인코딩 기술이 필요 없을 것입니다. 필수 레시피는 간단합니다. 3 바이트 또는 24 비트를 사용하십시오. 4 개의 6 팩으로 나누고 각각에 공백 (0x20)을 추가하십시오. 모든 데이터가 혼합 될 때까지 반복하십시오. 4 바이트 그룹을 60 개 이하의 행으로 접고 원래 바이트 수 (0x20 씩 증가)와 끝에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 붙입니다 . - 메뉴 에서 팩 코드 &lt;code&gt;u&lt;/code&gt; 를 선택하면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 셰프가 단시간 내에이를 준비 합니다.</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">우선 순위가 놀라운 또 다른 연산자는 지수입니다. 이 값은 단항 마이너스보다 더 밀접하게 바인딩되므로 &lt;code&gt;-2**2&lt;/code&gt; 는 양수가 아닌 음수 4를 생성합니다. 또한 오른쪽 연관입니다. 즉, &lt;code&gt;2**3**2&lt;/code&gt; 는 8 제곱이 아니라 9 제곱으로 올립니다.</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">발생할 수있는 또 다른 최적화 는 두 개의 연속 &lt;code&gt;EXACT&lt;/code&gt; 노드가 단일 regop으로 병합 되는 &quot; &lt;code&gt;EXACT&lt;/code&gt; merging&quot;입니다 . 이것의 더욱 공격적인 형태는 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; 형식의 분기 시퀀스를 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 정규 표현식 으로 변환 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">또 다른 옵션은 &lt;code&gt;iter&lt;/code&gt; 클래스 메소드를 사용하여 메모리에서 모든 파일을 한 번에 읽지 않고 tarball의 파일을 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">다른 옵션은 CPAN에서 사용 가능한 Perl로 작성된 make를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist의 또 다른 특징은 우리가 마지막 파일을 성공적으로 가져올 수있는 사이트가 자동으로 기본 설정 토큰을 가져 와서 다음 요청의 첫 번째 사이트로 시도한다는 것입니다. 따라서 런타임에 새 사이트를 추가하면 이전에 선호했던 사이트가 다시 시도 될 수 있습니다. 즉, 다음 전송을 위해 사이트를 허용하지 않으려면 urllist에서 명시 적으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">주목할만한 또 다른 요점은 첫 번째 예제 시리즈에서</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; 위한 또 다른 일반적인 용도 는 펄이 바이너리 호환성을 깨뜨릴 경우 구조하는 것입니다. CPAN이 사용하는 모듈 중 하나가 이진 호환성에 따라 (CPAN 명령을 실행할 수없는 경우) 복구를 위해 CPAN :: Nox 모듈을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">또 다른 가능성은 백 슬래시를 잊었을 수 있습니다. 펄은 당신이 실제로 무엇을 의미하는지 알아낼만큼 똑똑하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">문제가 발생할 수있는 또 다른 이유는 Perl이 그러한 패키지가 존재하기 전에 클래스 이름에 간접 객체 구문 (예 : &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; 사용했기 때문입니다 . 패키지를 사용하기 전에 패키지가 모두 정의되어 있는지 확인하는 것이 가장 좋습니다 . &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 을 사용하면 처리 됩니다 . 그렇지 않은 경우 화살표 표기법 (예 : &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; )을 대신 사용하십시오. 객체 표기법은 &lt;a href=&quot;perlobj&quot;&gt;perlobj에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">내부 클래스에서 발생하는 또 다른 문제는 직렬화입니다. 객체 데이터가 일반적인 위치에 있지 않기 때문에 &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; 및 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 와 같은 표준 루틴 은 자체적으로 처리 할 수 ​​없습니다. 두 &lt;code&gt;Data::Dumper&lt;/code&gt; 및 &lt;code&gt;Storable&lt;/code&gt; 가지 작업을하는 데 필요한 후크를 제공하지만, 후크가 사용하는 기능이나 방법은 각각의 내부 아웃 클래스에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">이 접근법의 또 다른 문제점은 단일 바이트 / 다중 바이트 경계를 넘는 조작이 잘 정의되지 않아서 허용되지 않는다는 것입니다. (이 경계는 코드 포인트 255/256 사이에 있습니다.) 예를 들어, 하부 케이싱이있는 라틴 대문자 문자 Y가 DIAERESIS (U + 0178)이면 라틴 문자가 Y 인 DIAERESIS (U + 00FF)를 반환해야합니다. 그러나 그리스어 로케일의 경우 0xFF에는 문자가 없으며 Perl은 0xFF의 문자가 실제로 무엇을 나타내는 지 알 수 없습니다. 따라서 작업을 허용하지 않습니다. 이 모드에서 U + 0178의 소문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">사람들이 변수에 변수 이름을 포함시키고 싶어하는 또 다른 이유는 해시를 사용하여 적절한 데이터 구조를 만드는 방법을 모르기 때문입니다. 예를 들어, 프로그램에서 % fred와 % barney라는 두 개의 해시를 원했고 다른 스칼라 변수를 사용하여 이름으로 참조한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">&lt;code&gt;HASH&lt;/code&gt; 를 사용해야하는 또 다른 이유 는 고유 한 해시 변수를 제공하기위한 것입니다. 그런 다음 해시의 내용을 검사하거나 수정하여 캐시 관리를보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">다른 샘플 모듈 인 &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt; 는 CPAN에서 별도의 배포판으로 제공됩니다. 특정 기능 값을 항상 새로 검색하도록 지정할 수있는 정책을 구현합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">시도해야 할 또 다른 것은 Perl이 시스템 malloc 또는 Perl의 내장 malloc으로 컴파일되었는지 여부를 배우는 것입니다. 어느 쪽이든, 다른 쪽을 사용해보고 차이가 있는지 확인하십시오. malloc에 ​​대한 정보는</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">명심해야 할 또 다른 사항은 개인 영역에 설치할 때 UNINST 매개 변수가 위험 할 수 있다는 것입니다. 개인 영역을 사용하지 않는 다른 사람들이 의존하는 모듈을 실수로 제거 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">해당 런타임과 컴파일 타임 트랩에 대한 또 다른 해결책은 &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt; 를 사용하는 것입니다. Exporter :: Easy 는 Exporter의 래퍼로, 모든 상용구 코드를 use 문에서 단일 gulp로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">redispatch의 또 다른 일반적인 사용은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed 메소드입니다. 그러한 메소드가 특정 호출을 처리 할 수 ​​없다고 판단한 경우, 다른 &lt;code&gt;AUTOLOAD&lt;/code&gt; (위 또는 왼쪽)가 더 좋을 수 있기를 희망하여 해당 호출을 재발송 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">비공식 데이터의 또 다른 출처. 현재는 데이터를 얻는 데 사용되지 않지만 참고와 설명 자료는 소스 간의 불일치를 이해하는 데 매우 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 의 또 다른 용도 는 동일한 디스크 파일에 두 종류의 반환 값을 모두 저장하려는 경우입니다. 이렇게하면 하나 대신 두 개의 디스크 파일을 처리하지 않아도됩니다. 노멀 라이저 함수를 사용하여 두 세트의 리턴 값을 별도로 유지할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">클로저의 또 다른 용도는 변수를 만드는 것입니다</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">노멀 라이저의 또 다른 용도는 함수가 인수의 데이터 이외의 데이터에 의존하는 경우입니다. 현재 시간에 따라 값을 반환하는 함수가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT : 섹션의 또 다른 용도는 C 함수를 호출하기 전에 사전 조건을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">typeglobs의 또 다른 용도는 파일 핸들을 함수에 전달하거나 새 파일 핸들을 만드는 것입니다. typeglob을 사용하여 파일 핸들을 저장해야하는 경우 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">심볼 테이블의 또 다른 용도는 &quot;일정한&quot;스칼라를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">일반 객체의 또 다른 용도는 템플릿입니다. 실제 객체 초기화에 사용되는 다양한 필드에 대한 클래스 별 기본값을 저장하는 편리한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 의 인수로 리터럴 배열이나 해시 를 사용하면 참조로 바뀐다 는 또 다른 유용한 단축키가 있습니다. 그래서 &lt;code&gt;given(@foo)&lt;/code&gt; 동일하다 &lt;code&gt;given(\@foo)&lt;/code&gt; 예를 들어,.</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">테마의 또 다른 변형. 이번에는 &lt;code&gt;Subst&lt;/code&gt; 필터를 수정하여 시작 및 중지 패턴과</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">다른 버전에서는 목록 컨텍스트에서 전역 일치를 사용한 다음 결과를 스칼라에 할당하여 일치 횟수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">또 다른 방법은 문자열의 끝 부분에있는 substr ()에 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">다른 방법은 전체 파일을 배열로 취급하는 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 모듈 을 사용하는 것 입니다. 임의의 배열 요소에 간단히 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">다른 방법은 undef를 왼쪽의 요소로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">익명의 파일 핸들을 만드는 또 다른 방법은 Symbol 모듈이나 IO :: Handle 모듈 및 해당 ilk를 사용하는 것입니다. 이 모듈은 local () 중에 같은 이름의 다른 유형을 숨기지 않는 이점이 있습니다. 예를 들어 &lt;a href=&quot;functions/open&quot;&gt;오픈&lt;/a&gt; 하단을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">컴파일 타임 코드를 디버깅하는 또 다른 방법은 디버거를 시작하고 중단 점을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 를 선언하는 또 다른 방법 은 CODE : 섹션에서 C 블록을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">안전 신호 동작을 로컬로 비활성화하는 다른 방법 은 CPAN 의 &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; 모듈 을 사용하여 모든 신호에 영향을주는 것입니다.</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">트리를 검사하는 또 다른 방법은 &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 컴파일러 백엔드 모듈을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">기본 객체를 참조하는 또 다른 방법은 tied () 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">그것을 보는 또 다른 방법은 비트를 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">프로그램 을 수정 &lt;code&gt;@INC&lt;/code&gt; 않고 @INC 를 수정하는 다른 방법 은 다음과 같이 &lt;code&gt;lib&lt;/code&gt; pragma 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">PM 프로그램의 출력을 보는 다른 방법은 다음과 같이 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8 문자열에서 문자를 건너 뛰는 또 다른 방법은 &lt;code&gt;utf8_hop&lt;/code&gt; 을 사용하는 것입니다. utf8_hop 는 문자열과 건너 뛰기 위해 여러 문자를 사용합니다. 당신은 경계 검사에 대해 스스로하고 있으므로 가볍게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">단일 매개 변수로 많은 INSTALL 디렉토리를 지정하는 다른 방법은 LIB입니다.</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">&lt;code&gt;Is_latin_1()&lt;/code&gt; 을 작성하는 또 다른 방법 은 범위 내의 문자를 명시 적으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">예제에서 사용 된 $ (FOO)는 Perl이 아닌 make 변수입니다.</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">사용되는 모든 &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;사용자 정의 속성&lt;/a&gt; 은 정규식을 컴파일 할 때 이미 정의되어 있어야합니다 (그러나 이러한 속성 대신이 구문을 사용할 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 를 구성, 초기화, 축복 및 반환하는 모든 &lt;b&gt;클래스 메소드&lt;/b&gt; , &lt;b&gt;인스턴스&lt;/b&gt; 또는 &lt;b&gt;서브 루틴&lt;/b&gt; . 때때로 우리는 &lt;b&gt;작곡가&lt;/b&gt; 를 의미하기 위해 느슨하게 사용합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">모든 &lt;code&gt;\&lt;/code&gt; (백 슬래시)는 &lt;code&gt;/&lt;/code&gt; (슬래시)로 변환 된 다음 File :: Spec :: Unix canonpath ()가 결과에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">모든 &lt;code&gt;make&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 는 무조건 실행됩니다. 안</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">모든 SV는 마법적일 수 있습니다. 즉, 일반 SV에는없는 특별한 기능이 있습니다. 이러한 기능은 SV 구조에 &lt;code&gt;struct magic&lt;/code&gt; 의 링크 된 목록 으로 &lt;code&gt;MAGIC&lt;/code&gt; 에 typedef로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">추가 인수는 코드를 생성 할 모듈의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">&lt;b&gt;-&lt;/b&gt; 토큰 이전에 발견 된 추가 인수 는 코드를 생성 할 모듈의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">링커에 전달하려는 추가 플래그</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">신호 이름처럼 보이는 인수 (즉, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; )는 &lt;b&gt;sigtrap&lt;/b&gt; 이 해당 이름의 핸들러를 설치해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">두 번째 '-'토큰 다음의 인수는 잠재적 인 충돌이 있는지 검사 할 추가 링커 인수입니다. 충돌이 없으면 추가 인수가 출력의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">전달 된 인수는 배열 &lt;code&gt;@_&lt;/code&gt; 에 표시됩니다 . (그들은 또한 서명에 의해 도입 된 어휘 변수에 표시 할 수있다; 참조 &lt;a href=&quot;#Signatures&quot;&gt;서명&lt;/a&gt; . 아래)을 따라서 두 개의 인자를 가진 함수를 호출하는 경우, 그가에 저장됩니다 &lt;code&gt;$_[0]&lt;/code&gt; 과 &lt;code&gt;$_[1]&lt;/code&gt; . 배열 &lt;code&gt;@_&lt;/code&gt; 은 로컬 배열이지만 해당 요소는 실제 스칼라 매개 변수의 별칭입니다. 특히 &lt;code&gt;$_[0]&lt;/code&gt; 요소가업데이트되면 해당 인수가 업데이트됩니다 (또는 업데이트 할 수없는 경우 오류가 발생 함). 인수가 함수가 호출 될 때 존재하지 않은 배열 또는 해시 요소 인 경우, 해당 요소는 수정되거나 참조 될 때만 작성됩니다. (이전 버전의 Perl은 요소의 할당 여부에 관계없이 요소를 작성했습니다.) 전체 배열에 할당하면 &lt;code&gt;@_&lt;/code&gt; 이 해당 앨리어싱을 제거하고 인수를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">구획에 의해 허용되지 않는 연산자를 사용하여 STRING의 코드로 시도하면 오류가 발생합니다 (기본 프로그램의 런타임에는 STRING의 코드에 대해 컴파일 타임). 오류는 &quot; '% s'작업 마스크에 의해 트랩되었습니다 ...&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">백 슬래시 프로토 타입 문자는 &lt;code&gt;$&lt;/code&gt; 을 제외 하고 해당 문자로 시작해야하는 실제 인수 (선택적으로 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; )를 나타내며 &lt;code&gt;$foo = 7&lt;/code&gt; 또는 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 과 같은 스칼라 lvalue 표현식을 허용합니다. &amp;gt; [0] . &lt;code&gt;@_&lt;/code&gt; 의 일부로 전달 된 값은 해당 인수에 &lt;code&gt;\&lt;/code&gt; 를 적용하여 얻은 서브 루틴 호출에 제공된 실제 인수에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">패키지에서 자체로의 모든 호출은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">내부 Perl 모듈의 모든 호출은 안전합니다. (사용자 모듈이 자신을 Perl의 내부로 표시하는 것을 막는 것은 없지만이 방법은 권장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">Perl의 경고 시스템 (예 : 잉어 자체)에 대한 전화는 안전합니다. (이 규칙은 &lt;code&gt;carp&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 이라고하는 지점에서 오류를보고하지 못하게합니다 .)</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\D&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\S&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 와 일치하지 않는 문자 는 &lt;code&gt;\W&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">65 자 base64 부분 집합에 속하지 않는 문자는 자동으로 무시됩니다. '='패딩 문자 다음에 나오는 문자는 절대 디코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">모든 문자</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">간격이 있거나 공백이 아닐 수 있는 일반 범주의 결합 표시 ( &lt;code&gt;\p{GC=M}&lt;/code&gt; )가있는 문자. 일부는 보이지 않습니다. 그래 핀의 기본 문자 다음과 같은 결합 문자의 순서는 함께라는 단일 사용자가 볼 수있는 문자를 구성하는 &lt;b&gt;그래 핀을&lt;/b&gt; . 모든 분음 부호가 아닌 대부분의 문자는 문자를 결합하며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">오버로드 된 클래스에서 파생 된 모든 클래스도 오버로드되어 해당 연산자 구현을 상속합니다. 동일한 연산자가 둘 이상의 조상에 오버로드되면 구현은 일반적인 상속 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">이 함수가 true를 리턴하는 클래스는 모든 클래스가 잠재적으로 메소드를 상속한다는 의미에서 &quot;유니버설&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">모든 클래스는 직렬화 및 역 직렬화 프로세스 중에 해당 클래스의 인스턴스 인 객체에 대해 호출 될 후크를 정의 할 수 있습니다. 이러한 후크는 직렬화가 수행되는 방식을 다시 정의 할 수 있습니다 (따라서 대칭 역 직렬화가 수행되는 방법).</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">디버거가 인식하지 못하는 모든 명령 은 현재 패키지에서 Perl 코드로 직접 실행됩니다 ( &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd). 디버거는 자체 ​​상태 정보를 유지하기 위해 DB 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">커미터는 perl5 포터에게 메일을 보내면 커밋에 대한 근거와 함께 특정 커밋을 선택하고 적어도 두 명의 다른 커미터가 목록 제공에 응답하면 블리드에서 메인 브랜치로 커밋을 선택할 수 있습니다. 그들의 동의. (이 정책은 현재 및 이전 호박과 다른 커미터에 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\D&lt;/code&gt; 와 같은 것을 포함하여 포함 된 POSIX 문자 클래스 는 &lt;code&gt;/a&lt;/code&gt; (및 &lt;code&gt;/aa&lt;/code&gt; ) 수정자를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;threads :: shared에서&lt;/a&gt; 지원하는 모든 데이터 유형 은 큐를 통해 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">추출 경로 접두어가있는 디렉토리 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">기존의 모든</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUB를 포함하는 확장을 포함하여 Perl에 대한 확장에는 확장을 Perl로 가져 오는 부트 스트랩 역할을하는 Perl 모듈이 있어야합니다. 이 모듈은 확장 기능과 변수를 Perl 프로그램으로 내보내고 확장의 XSUB가 Perl에 링크되게합니다. 다음 모듈은이 문서에서 대부분의 예제에 사용되며 앞에서 표시된 것처럼 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 명령과 함께 Perl에서 사용해야 합니다. Perl 모듈에 대해서는이 문서의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; 으로 전달되어서는 안되는 추가 인수는 이 메소드로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">fork () 시점에 열린 모든 파일 핸들은 dup ()-ed입니다. 따라서 파일은 부모와 자식에서 독립적으로 닫힐 수 있지만 dup () 핸들이 여전히 동일한 탐색 포인터를 공유한다는 점에주의하십시오. 부모의 탐색 위치를 변경하면 자식의 탐색 위치가 변경되고 그 반대도 마찬가지입니다. 자식에서 별도의 탐색 포인터가 필요한 파일을 열어서 이것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">아래 목록의 함수는 인수 주위에 괄호를 사용하거나 사용하지 않고 사용할 수 있습니다. (구문 설명은 괄호를 생략합니다.) 괄호를 사용하는 경우 단순하지만 때로는 놀라운 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">값이있는 모든 키 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">값이있는 모든 키 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">모든 대형 IRC 네트워크 (Dalnet, EFnet)는 다양한 활동 수준의 #perl 채널을 가질 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">사이에 어떤 문자가 &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; 와 같이 플래그 수정 자 역할을합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 작성된 객체에 대한 모든 메소드 호출 은 일반 객체로 패키지에 발송됩니다.</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">표시된 모든 방법</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">여기에 나열되지 않은 방법은 Math :: BigFloat (또는 Math :: BigInt)에서 파생 된 것이므로 자세한 내용은이 두 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">임의의 혼합물이 가능하다. 예를 들어 가장 자주 사용되는 옵션은 변수에 저장하고 다른 모든 옵션은 해시에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">태그에 추가되지 않은 이름 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 변화하지만, (와 경고를 트리거 &lt;code&gt;-w&lt;/code&gt; 잘못 철자 태그 이름을 피하기 위해)를 자동으로 추가되는 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; . 이후 버전에서는이 오류가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">$ perl_code의 모든 줄 바꿈은 이스케이프됩니다. 선행 및 후행 줄 바꿈이 제거됩니다. 이 관용구를 훨씬 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">공백이 아닌 분리 문자는 슬래시를 대체 할 수 있습니다. 식별자에 허용되는 문자를 사용할 때 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 뒤에 공백을 추가하십시오 . 작은 따옴표를 사용하면 대체 문자열에 대한 해석이 수행되지 않습니다 ( 그러나 &lt;code&gt;/e&lt;/code&gt; 수정자가이를 대체합니다). Perl은 백틱을 일반 구분 기호로 취급합니다. 대체 텍스트는 명령으로 평가되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">임의의 수의 &lt;code&gt;(*PRUNE)&lt;/code&gt; 어설 션이 패턴에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">배열 앞의 목록에서 여러 인수가 발생할 수 있지만 입력 및 출력 배열은 목록의 마지막 요소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">여러 개의 물결표와 주변 공백이 단일 공간으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">비트 마스크 중 하나라도 정의 할 수 없습니다. 지정된 경우 제한 시간은 초 단위이며 소수 일 수 있습니다. 참고 : 모든 구현이 $ timeleft를 반환 할 수있는 것은 아닙니다. 그렇지 않으면 항상 $ timeleft를 제공된 $ timeout과 동일하게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">이 수정의 어떤은의 범위 내에서 컴파일 된 모든 정규 표현식에 전 세계적으로 적용하도록 설정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re의 '/ flags'모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">이러한 진술은 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 대체하는 훌륭한 대안입니다. { require Exporter; @ISA = qw (수출 업체); } 컴파일 시간 효과가 동일합니다. 기본 차이점은 &lt;code&gt;base&lt;/code&gt; 코드가 선언 된 &lt;code&gt;fields&lt;/code&gt; 와 상호 작용하는 반면 &lt;code&gt;parent&lt;/code&gt; 는 IS-A 관계를 설정하기 위해 이전 &lt;code&gt;base&lt;/code&gt; 코드 의 간소화 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">생략되거나 비어있는 정규 표현식의 기본값은 &quot;. *&quot;입니다. 주어진 각 정규 표현식은 시작과 끝에 &quot;^&quot;와 &quot;$&quot;를 추가하여 암시 적으로 고정됩니다. 또한 주어진 정규 표현식이 &quot;!&quot;로 시작하면 문자, 식은</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">문자 그대로 찍은 다른 문자.</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">방법에 특정한 다른 매개 변수</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">다른 리턴 코드는 플러시 지점을 찾을 수 없음을 의미합니다. 더 많은 데이터를 사용할 수있는 경우 플러시 지점을 찾을 때까지 더 압축 된 데이터로 &lt;code&gt;inflateSync&lt;/code&gt; 를 반복적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">스택에 푸시되는 모든 매개 변수는 &lt;code&gt;PUSHMARK&lt;/code&gt; 및 &lt;code&gt;PUTBACK&lt;/code&gt; 매크로로 묶어야 합니다. 이 문맥에서이 두 매크로의 목적은 자동으로 푸시하는 매개 변수의 수를 계산하는 것입니다. 그런 다음 Perl이 서브 루틴에 대한 &lt;code&gt;@_&lt;/code&gt; 배열을 작성할 때마다 얼마나 큰지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">인수를 허용하는 특수 역 &lt;code&gt;$REGERROR&lt;/code&gt; 동사를 포함하는 패턴은 실행될 때 현재 패키지의 $ REGERROR 및 &lt;code&gt;$REGMARK&lt;/code&gt; 변수를 설정하는 특수 동작을 갖습니다 . 그렇게 할 때 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">전달 된 참조 중 하나와 동일한 참조는 이름이 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 정규 표현식 특수 문자 는 여전히 특별하며 패턴이 여전히 유효해야합니다. 그렇지 않으면 Perl이 불평합니다. 예를 들어,이 패턴에는 짝이없는 괄호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">하지 않는 스칼라 값은 0 이상으로 평가 &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">모든 스칼라 변수에는 변수의 스칼라 데이터가 포함 된 PERL_MAGIC_collxfrm 매직이 있지만 일반 메모리 비교를 사용하여 로케일 설정에 따라 데이터를 비교할 수있는 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">임의의 간단한 문장 뒤에 선택적으로</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">모든 단일 문자는</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">동적로드에 적합한 공유 라이브러리를 작성하기 위해 ld로 전달해야하는 특수 플래그. 그것을 사용하는 것은 makefile에 달려 있습니다. ( &lt;a href=&quot;../config#lddlflags&quot;&gt;구성의 lddlflags&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">루프 본문 내에서 루프가 조기에 루프를 중지하거나 &lt;b&gt;반복을&lt;/b&gt; 건너 뛸 수있는 명령문 . 일반적으로 롤러 코스터에서는 시도하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">구획에서 실행되는 코드 또는 구획에서 실행되는 코드에서 호출 된 코드에 의해 실행되는 모든 문자열 평가는 구획의 네임 스페이스에서 평가됩니다. 이것은 잠재적으로 심각한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 환경 변수 의 모든 스위치 는 명령 행 인수 앞에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl이 메인 프로그램을 실행하기 시작한 후 언제든지 &lt;b&gt;컴파일 단계&lt;/b&gt; 도 참조하십시오 . 실행 단계는 대부분에 소요되는 &lt;b&gt;런타임&lt;/b&gt; 뿐만 아니라에서 소비 할 수있다 &lt;b&gt;컴파일 타임&lt;/b&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl이 메인 프로그램을 실행하기 전에는 언제든지. &lt;b&gt;run phase&lt;/b&gt; 도 참조하십시오 . 컴파일 단계는 대부분 &lt;b&gt;컴파일 시간에&lt;/b&gt; 소비 되지만 &lt;code&gt;BEGIN&lt;/code&gt; 블록이 있거나 선언을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 사용 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 않거나 상수 하위 표현식을 평가할 때 &lt;b&gt;런타임에&lt;/b&gt; 사용될 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 선언 의 시작 및 가져 오기 코드 도 컴파일 단계에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-여러 DBM을위한 프레임 워크 제공</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">이 파일을 부활시키는 데 관심이있는 사람은 MakeMaker CVS 저장소에서 이전 버전을 가져와 makemaker@perl.org에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">이 줄 다음에 나오는 것은 XSUB 함수에 대한 설명입니다. 이 설명은 &lt;b&gt;xsubpp&lt;/b&gt; 에 의해 Perl 호출 규칙을 사용하여 이러한 함수를 구현하고 이러한 함수를 Perl 인터프리터에서 볼 수있게하는 C 코드로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">이 줄 앞의 내용은 포함 할 헤더를 설명하고 편리한 기능을 정의하는 일반 C 코드입니다. 임베드 된 POD 문서를 건너 뛰고 ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 ) 생성 된 출력 C 파일로 그대로 들어가는 것 외에는이 파트에서 변환이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">&lt;code&gt;MANIFEST&lt;/code&gt; 파일 내 공백과 줄 끝 사이의 모든 것은 주석으로 간주됩니다. #으로 시작하는 줄도 주석입니다. ExtUtils :: Manifest 1.52부터는 작은 따옴표로 묶인 파일 이름에 공백 문자가 포함될 수 있습니다. 해당 파일 이름의 작은 따옴표 나 백 슬래시는 백 슬래시 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">다른 것은 Perl 특정 편의 약어입니다. 스크립트 별 짧은 이름을 원하면 이름으로 하나 이상의 스크립트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">PATTERN과 일치하는 EXPR의 모든 항목은 EXPR을 하위 문자열 ( &quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">BE로 표시된 것은 Big Endian (또는 네트워크 바이트 순서)이고 LE는 Little Endian (일명 VAX 바이트 순서)입니다. BE 또는 LE로 표시되지 않은 항목의 경우 엔디안을 나타내는 BOM (Byte Order Mark)이라는 문자가 문자열 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">여기에있는 것은 MY :: postamble ()이 있으면 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 다음에 나오는 것은 주석으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">&lt;b&gt;가치&lt;/b&gt; 가 필요한 장소에서 합법적으로 말할 수있는 모든 것 . 일반적으로 &lt;b&gt;리터럴&lt;/b&gt; , &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;연산자&lt;/b&gt; , &lt;b&gt;함수&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 호출 로 구성되며 반드시 순서대로는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">어쨌든 여기 있습니다. perl v4 이상에서 실행해야합니다. 아마 적을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">어쨌든, 이것은 당신이 스스로 도울 수 없다면 할 수있는 일입니다.</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">변수 또는 서브 루틴 이름의 일부로 식별자 (또는 일련의 식별자)를 배치 할 때마다 식별자를 올바른 유형의 참조를 반환하는 BLOCK으로 바꿀 수 있습니다. 즉, 이전 예제는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">변수 또는 서브 루틴 이름의 일부로 식별자 (또는 일련의 식별자)를 배치 할 때마다 올바른 유형의 참조를 포함하는 간단한 스칼라 변수로 식별자를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache :: GZip 재 방문</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">일부 운영 체제에서 이식 할 수없는 것 외에도 파일을 여러 번 열고 닫을 필요없이 더 큰 파일에 포함 된 gzip 데이터 스트림을 추출 / 생성하려는 상황에서 &lt;code&gt;gzopen&lt;/code&gt; 을 사용하기가 어려웠습니다. 타임스.</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">콜백을 작성하기 위해 Perl에서 제공 한 C 인터페이스를 논의하는 것 외에도이 문서는 일련의 예제를 사용하여 실제로 실제로 인터페이스가 작동하는 방식을 보여줍니다. 또한 콜백 코딩을위한 일부 기술이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">현재 부울 인 것 외에도 &lt;code&gt;$^W&lt;/code&gt; 변수는 기본 경고를 비활성화 / 활성화 할 수 없다는 점을 제외하고는 똑같이 끔찍한 제어되지 않는 전역 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">위에서 설명한 동작 외에도 Perl은 여러 수준의 보간을 확장하지 않습니다. 특히, 쉘 프로그래머의 기대와 달리, 역 따옴표는</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">첫 번째 매개 변수 외에도 가져 오기는 선택적 매개 변수 목록을 승인 할 수 있습니다. 이것들은 파라미터를 필터에 전달하는데 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">오버 스트라이크 외에도 모든 방식으로 포드 : 텍스트와 같은 기능을 수행합니다. 자세한 내용과 사용 가능한 옵션 은 &lt;a href=&quot;../text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove- &lt;code&gt;prove&lt;/code&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; 명령의 상태 저장소입니다 .</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App :: Prove :: State :: Result-개별 테스트 스위트 결과.</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App :: Prove :: State :: Result :: Test-개별 테스트 결과.</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">분명히 IBM은 FP 마스크를 좌우로 바꾸는 컴파일러를 사용했습니다 (약 95 년 정도?). 이것은 아니다</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">자기 관심에 호소하십시오! Perl이 그들에게 새롭고 무서운 경우, Perl이 문제 중 하나를 해결하기 위해 할 수있는 것을 찾으십시오. 그것은 Perl이 그들에게 무언가 (시간, 두통, 돈)를 절약하거나 무언가 (유연성, 힘, 테스트 가능성)를 제공한다는 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">목록 유형 op 내에 직접 포함 된 op 목록에 항목을 추가하여 확장 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">요소 추가</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">LIST의 요소를 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">각 테스트의 출력 시간을 추가하십시오. 사용 &lt;a href=&quot;../../time/hires&quot;&gt;시간 :시 HiRes를&lt;/a&gt; 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">각 테스트의 출력 시간을 추가하십시오. 사용 &lt;a href=&quot;../time/hires&quot;&gt;시간 :시 HiRes를&lt;/a&gt; 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">G_KEEPERR 플래그를 추가하여</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">지정된 문자열 또는 구문 분석 트리 또는 시퀀스 객체를이 내부 시퀀스의 구문 분석 트리에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">패치 적용</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">응용 프로그램 릴리즈 2001 년 9 월, HP-UX 11.00은 Perl과 함께 처음 제공됩니다. 당시에는 / opt / perl에서 perl-5.6.1이었습니다. 첫 번째는 CD 5012-7954에 있으며 다음을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">표현식을 나타내는 op 트리에 구문 컨텍스트를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">dl_find_symbol ()을 @dl_librefs의 멤버에 적용하고 발견 된 첫 번째 일치를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">임의의 소수 대신 임의의 정수를 원할 경우 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 가 리턴 한 값에 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 . 예를 들어</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
