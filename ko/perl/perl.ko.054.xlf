<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="466f242a777ff54f7c93093c4d90a137e616e30f" translate="yes" xml:space="preserve">
          <source>incremental</source>
          <target state="translated">incremental</target>
        </trans-unit>
        <trans-unit id="3cc46d20365996efe5ff1d4a9e0d401d68f186ed" translate="yes" xml:space="preserve">
          <source>indent</source>
          <target state="translated">indent</target>
        </trans-unit>
        <trans-unit id="bb563dfba453db67bbec56ac010da0ffa7c3928b" translate="yes" xml:space="preserve">
          <source>indentlevel</source>
          <target state="translated">indentlevel</target>
        </trans-unit>
        <trans-unit id="5db560de5f46f68f2cf6566c95097f8e2f035630" translate="yes" xml:space="preserve">
          <source>independent subexpression</source>
          <target state="translated">독립 하위 식</target>
        </trans-unit>
        <trans-unit id="e540cdd1328b2b21e29a95405c301b9313b7c346" translate="yes" xml:space="preserve">
          <source>index</source>
          <target state="translated">index</target>
        </trans-unit>
        <trans-unit id="43f884af0bc6ff4672586657430c850be72e55ba" translate="yes" xml:space="preserve">
          <source>index STR,SUBSTR</source>
          <target state="translated">인덱스 STR, SUBSTR</target>
        </trans-unit>
        <trans-unit id="99e8de47a322ff3d13bd1a7ab53b04a9be460a7c" translate="yes" xml:space="preserve">
          <source>index STR,SUBSTR,POSITION</source>
          <target state="translated">인덱스 STR, SUBSTR, POSITION</target>
        </trans-unit>
        <trans-unit id="bd7ea36f65e58c5c7bbf8dd9aceaaa73c4fd1c3b" translate="yes" xml:space="preserve">
          <source>indicate an exceptional condition: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when its argument is an empty array,</source>
          <target state="translated">예외 상황을 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 인수가 빈 배열 일 때 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48ba91ecc2fdf08cfe5fd27747c3c8e58cadd255" translate="yes" xml:space="preserve">
          <source>indicate an exceptional condition: &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when its argument is an empty array,</source>
          <target state="translated">예외 상황을 나타냅니다. &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 인수가 빈 배열 일 때 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a89f7b99b7459c3e3a376ab2fa2510f98bafcc8" translate="yes" xml:space="preserve">
          <source>indicates a problem with the permissions on your /tmp directory within the HFS. To correct that problem issue the command:</source>
          <target state="translated">HFS 내의 / tmp 디렉토리에 대한 권한에 문제가 있음을 나타냅니다. 이 문제를 해결하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="46adef8d549f47ce21751c1f181a46c1b9f28795" translate="yes" xml:space="preserve">
          <source>indicates that the name is a corrected form for the original name (which remains valid) for the same code point.</source>
          <target state="translated">이름이 동일한 코드 포인트의 원래 이름 (유효한 상태)에 대해 올바른 형식임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aafce730a5c69801b1cd038fde73b5890228164a" translate="yes" xml:space="preserve">
          <source>indicates that the t/io/openpid.t test of Perl has passed but done so with extraneous messages on stderr from CEE.</source>
          <target state="translated">Perl의 t / io / openpid.t 테스트가 통과되었지만 CEE의 stderr에 외부 메시지가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8beeb2fce58d3cf706cd79c74605d5f6cec09a88" translate="yes" xml:space="preserve">
          <source>indicates that we're running this test as part of the perl core test suite. This is useful for modules that have a dual life on CPAN.</source>
          <target state="translated">펄 코어 테스트 스위트의 일부로이 테스트를 실행하고 있음을 나타냅니다. CPAN에 이중 수명이있는 모듈에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f809e25f7ab91ace25f0a3090dbe01b370226459" translate="yes" xml:space="preserve">
          <source>indicates the kind of subroutine:</source>
          <target state="translated">서브 루틴의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b02c8cb9a48d2ffe0d568aa710cf9a12f602ddf6" translate="yes" xml:space="preserve">
          <source>indicates whether to use effective (true) or real (false) ids. The method interprets the &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; and &lt;code&gt;gid&lt;/code&gt; fields, and returns whether or not the current process would be allowed the specified access.</source>
          <target state="translated">유효 (true) 또는 실제 (false) ID를 사용할지 여부를 나타냅니다. 이 메소드는 &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; 및 &lt;code&gt;gid&lt;/code&gt; 필드를 해석하고 현재 프로세스에 지정된 액세스가 허용되는지 여부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="483df761d9cb026b9fc15456c941640572afafa1" translate="yes" xml:space="preserve">
          <source>indirect filehandle</source>
          <target state="translated">간접 파일 핸들</target>
        </trans-unit>
        <trans-unit id="fcda6fabde0a3b0d0a1cfb866dfe701d0a8396cb" translate="yes" xml:space="preserve">
          <source>indirs</source>
          <target state="translated">indirs</target>
        </trans-unit>
        <trans-unit id="0cedd5bbf169e21b494623b26255ee592a3b4610" translate="yes" xml:space="preserve">
          <source>inetd(8)</source>
          <target state="translated">inetd(8)</target>
        </trans-unit>
        <trans-unit id="d6dbadb30700039562565904023976ef1620b170" translate="yes" xml:space="preserve">
          <source>infers</source>
          <target state="translated">infers</target>
        </trans-unit>
        <trans-unit id="f11b6d2142b8785dcbce524760b8a5eefaf8a51c" translate="yes" xml:space="preserve">
          <source>inflate</source>
          <target state="translated">inflate</target>
        </trans-unit>
        <trans-unit id="2f55f97803b98ce7727f4f32861d8b9d60ec8076" translate="yes" xml:space="preserve">
          <source>inflate $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">팽창 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [, OPTS]</target>
        </trans-unit>
        <trans-unit id="b6aa8886133566b84aa50528606b6d86540c9b75" translate="yes" xml:space="preserve">
          <source>inflateInit2</source>
          <target state="translated">inflateInit2</target>
        </trans-unit>
        <trans-unit id="f5442a6076f59c3a613b48a99fadcb1f1fb6506c" translate="yes" xml:space="preserve">
          <source>inflateSync</source>
          <target state="translated">inflateSync</target>
        </trans-unit>
        <trans-unit id="554b53fb93ab9b3811936a10d5be83b8a3f3155d" translate="yes" xml:space="preserve">
          <source>info is indented with respect to the backtracking level. Other incidental information appears interspersed within.</source>
          <target state="translated">역 추적 수준에 따라 정보가 들여 쓰기됩니다. 다른 부수적 인 정보가 내부에 산재되어있는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="57d5da7aaccaec3f7654dc61728d28ae4e5d6035" translate="yes" xml:space="preserve">
          <source>ing dynamically loading extensions would not work with</source>
          <target state="translated">확장 프로그램을 동적으로로드하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e93b4a3fb9f2ae1924b54eb33df09d70945cd655" translate="yes" xml:space="preserve">
          <source>inherits from &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exporter&quot;&gt;수출자&lt;/a&gt; 로부터 상속 .</target>
        </trans-unit>
        <trans-unit id="0e39975c1cdd0e165540e4c4297a8811904a676b" translate="yes" xml:space="preserve">
          <source>init_ABSTRACT</source>
          <target state="translated">init_ABSTRACT</target>
        </trans-unit>
        <trans-unit id="7cda590f08b4740a6590d7c44f166ba347919601" translate="yes" xml:space="preserve">
          <source>init_DIRFILESEP</source>
          <target state="translated">init_DIRFILESEP</target>
        </trans-unit>
        <trans-unit id="022f97d2b72f11b72258f24adb9af75996565df6" translate="yes" xml:space="preserve">
          <source>init_INST</source>
          <target state="translated">init_INST</target>
        </trans-unit>
        <trans-unit id="5cadb1507731d78b120c5b699141c83cf1ebcdb1" translate="yes" xml:space="preserve">
          <source>init_INSTALL</source>
          <target state="translated">init_INSTALL</target>
        </trans-unit>
        <trans-unit id="f607f848017aa48f552d6587df059baa8185c0c1" translate="yes" xml:space="preserve">
          <source>init_INSTALL_from_PREFIX</source>
          <target state="translated">init_INSTALL_from_PREFIX</target>
        </trans-unit>
        <trans-unit id="6d4ca819ebd448eadb26fae424a1daafae5538db" translate="yes" xml:space="preserve">
          <source>init_MAKE</source>
          <target state="translated">init_MAKE</target>
        </trans-unit>
        <trans-unit id="9375d2ed65f4648645abb14f2a07f4d4bfc7513c" translate="yes" xml:space="preserve">
          <source>init_VERSION</source>
          <target state="translated">init_VERSION</target>
        </trans-unit>
        <trans-unit id="9a0421852ea0c4dcae1cfa28534cd586cdf0e7d5" translate="yes" xml:space="preserve">
          <source>init_dist</source>
          <target state="translated">init_dist</target>
        </trans-unit>
        <trans-unit id="7d0fbcbecc897f6ad65c1d6d94207049fabca61c" translate="yes" xml:space="preserve">
          <source>init_from_INSTALL_BASE</source>
          <target state="translated">init_from_INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="d7c9b833e00c346f0bab160ef687e581517f1629" translate="yes" xml:space="preserve">
          <source>init_linker</source>
          <target state="translated">init_linker</target>
        </trans-unit>
        <trans-unit id="e3ab6049dd8bbaac48b18159b44f042e9d537459" translate="yes" xml:space="preserve">
          <source>init_others</source>
          <target state="translated">init_others</target>
        </trans-unit>
        <trans-unit id="e31881026ec06ae1c137294de90fc6573deb157b" translate="yes" xml:space="preserve">
          <source>init_platform</source>
          <target state="translated">init_platform</target>
        </trans-unit>
        <trans-unit id="019990422924c9d39c643c5b10dac864649676c5" translate="yes" xml:space="preserve">
          <source>init_tools</source>
          <target state="translated">init_tools</target>
        </trans-unit>
        <trans-unit id="8ad7d21c71b049b7003ba31b5f1322974df77ac8" translate="yes" xml:space="preserve">
          <source>initial</source>
          <target state="translated">initial</target>
        </trans-unit>
        <trans-unit id="d01e6b638f63d0ce474e5d2056a42868e8e743f1" translate="yes" xml:space="preserve">
          <source>initial special characters (denoting hashes, subroutines and typeglobs), and you said something like &lt;code&gt;*foo * foo&lt;/code&gt; that might be interpreted as either of them. We assumed you meant the infix operator, but please try to make it more clear -- in the example given, you might write &lt;code&gt;*foo * foo()&lt;/code&gt; if you really meant to multiply a glob by the result of calling a function.</source>
          <target state="translated">초기 특수 문자 (해시, 서브 루틴 및 타입 글로브 표시)를 나타내며 &lt;code&gt;*foo * foo&lt;/code&gt; 와 같이 말로 해석 될 수 있습니다. 우리는 당신이 infix 연산자를 의미한다고 가정했지만, 더 명확하게하려고 노력하십시오. 주어진 예제에서, 실제로 함수 호출의 결과에 glob를 곱하려는 경우 &lt;code&gt;*foo * foo()&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="398108d3cc7ae14b27f679220599912f6c8a2948" translate="yes" xml:space="preserve">
          <source>inplace operation (the -i switch) without backup file</source>
          <target state="translated">백업 파일이없는 인플레 이스 조작 (-i 스위치)</target>
        </trans-unit>
        <trans-unit id="140f86aae51ab9e1cda9b4254fe98a74eb54c1a1" translate="yes" xml:space="preserve">
          <source>input</source>
          <target state="translated">input</target>
        </trans-unit>
        <trans-unit id="075102130b9c2bee418af0f0abf0c05eb6428b5b" translate="yes" xml:space="preserve">
          <source>input fileglob string</source>
          <target state="translated">입력 파일 글로브 문자열</target>
        </trans-unit>
        <trans-unit id="14fafbea21b2afc4ac197a41c562da03ba2fd623" translate="yes" xml:space="preserve">
          <source>input_line_number</source>
          <target state="translated">input_line_number</target>
        </trans-unit>
        <trans-unit id="44b7f604ecb19d542ee06bc079099d93cfbfd8e9" translate="yes" xml:space="preserve">
          <source>inputfile</source>
          <target state="translated">inputfile</target>
        </trans-unit>
        <trans-unit id="dbf3f1e65ed994aafa92d37f106f81eb0f116b8d" translate="yes" xml:space="preserve">
          <source>insert is the first of a chain of nodes to be inserted in place of the nodes. If NULL, no nodes are inserted.</source>
          <target state="translated">insert는 노드 대신 삽입 할 노드 체인 중 첫 번째입니다. NULL이면 노드가 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc537881cd1d5bcddabf48fa8809c7471176de0" translate="yes" xml:space="preserve">
          <source>inside</source>
          <target state="translated">inside</target>
        </trans-unit>
        <trans-unit id="0d1a9a751997ac8a3af8a0e66a529b769c64f9e8" translate="yes" xml:space="preserve">
          <source>inside a &quot;=begin</source>
          <target state="translated">&quot;= 시작된 내부</target>
        </trans-unit>
        <trans-unit id="0404efe3ff82a89c15bd12e264f4ad6b4b5b9a26" translate="yes" xml:space="preserve">
          <source>inside a 5th eval in the program;</source>
          <target state="translated">프로그램에서 5 번째 평가판 내부;</target>
        </trans-unit>
        <trans-unit id="42069c6395d15e1204e32a0c3d074ee53152dec6" translate="yes" xml:space="preserve">
          <source>inside a given script</source>
          <target state="translated">주어진 스크립트 안에서</target>
        </trans-unit>
        <trans-unit id="89e02e198979d4b18ae44228f038f8bbcc90e3f2" translate="yes" xml:space="preserve">
          <source>inside out</source>
          <target state="translated">뒤집어서</target>
        </trans-unit>
        <trans-unit id="1318be358545620d758b5fbfc720522057898255" translate="yes" xml:space="preserve">
          <source>inside-out</source>
          <target state="translated">inside-out</target>
        </trans-unit>
        <trans-unit id="ffae41ad3ecb9c4be51654fdbdec2294d08ba3a9" translate="yes" xml:space="preserve">
          <source>inside-out classes</source>
          <target state="translated">인사이드 아웃 클래스</target>
        </trans-unit>
        <trans-unit id="89fb511ffe93ee7826661ca1e3bb468dc1ad0ff2" translate="yes" xml:space="preserve">
          <source>install</source>
          <target state="translated">install</target>
        </trans-unit>
        <trans-unit id="40e1b335d61258d5a48f641159e6957a1ff5ea0a" translate="yes" xml:space="preserve">
          <source>install.exe</source>
          <target state="translated">install.exe</target>
        </trans-unit>
        <trans-unit id="e1e2b964389a44069f6393f7f404e4082b21b782" translate="yes" xml:space="preserve">
          <source>installation</source>
          <target state="translated">installation</target>
        </trans-unit>
        <trans-unit id="cc1194708f9e63bdff55fc192202228c34612f10" translate="yes" xml:space="preserve">
          <source>installed already, make sure that no copies or perl are currently running. Later steps of the build may fail since an older version of</source>
          <target state="translated">이미 설치되어 있으면 현재 실행중인 사본 또는 perl이 없는지 확인하십시오. 이전 버전의 빌드 이후의 빌드 단계가 실패 할 수 있음</target>
        </trans-unit>
        <trans-unit id="50ce7e3f521a0c513361fb30e1f4fe7052c98c9b" translate="yes" xml:space="preserve">
          <source>installed as</source>
          <target state="translated">로 설치</target>
        </trans-unit>
        <trans-unit id="3a29dc65c6a5ec09f964c6e29d915690b9661711" translate="yes" xml:space="preserve">
          <source>installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">시스템에 설치하고 perl 맨 페이지를 설치 한 경우 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2907a7c430f00ce076d72256002da217245f85b6" translate="yes" xml:space="preserve">
          <source>installed under another name.</source>
          <target state="translated">다른 이름으로 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="b211760ff4348121f2719ef634ab34586418d866" translate="yes" xml:space="preserve">
          <source>installed, you can follow WWW links from this document in</source>
          <target state="translated">이 문서에서 WWW 링크를 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b6c2e3cc55e3bb4fce5a65f78016fe2471ddee9" translate="yes" xml:space="preserve">
          <source>installprefix.U</source>
          <target state="translated">installprefix.U</target>
        </trans-unit>
        <trans-unit id="637fb636ffe280ca72d9b5ea3567bce61300bc40" translate="yes" xml:space="preserve">
          <source>installs the memoized version of &lt;code&gt;fib&lt;/code&gt; as &lt;code&gt;fastfib&lt;/code&gt; ; without the &lt;code&gt;INSTALL&lt;/code&gt; option it would have replaced the old &lt;code&gt;fib&lt;/code&gt; with the memoized version.</source>
          <target state="translated">&lt;code&gt;fastfib&lt;/code&gt; 된 버전의 &lt;code&gt;fib&lt;/code&gt; 를 fastfib 로 설치합니다 . &lt;code&gt;INSTALL&lt;/code&gt; 옵션이 없으면 기존 &lt;code&gt;fib&lt;/code&gt; 를 메모 된 버전으로 대체했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1f09b06690d13eb940215681daf48fc97f3a138c" translate="yes" xml:space="preserve">
          <source>installstyle.U</source>
          <target state="translated">installstyle.U</target>
        </trans-unit>
        <trans-unit id="4eb977bcd33ca38c1e0b488eac44ee25547efd26" translate="yes" xml:space="preserve">
          <source>installvars</source>
          <target state="translated">installvars</target>
        </trans-unit>
        <trans-unit id="213d3b87dbe505b0072f3929805c83c8a5257052" translate="yes" xml:space="preserve">
          <source>instantiate an Expect object that reads from the console, waits for some regular expressions and enters some answers</source>
          <target state="translated">콘솔에서 읽고 Expect 객체를 인스턴스화하고 일부 정규 표현식을 기다린 후 응답을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="6d20c05e1fc41e487c521873baf51d86fd2da739" translate="yes" xml:space="preserve">
          <source>instead do it thru maketext, using no variable interpolation in the key:</source>
          <target state="translated">대신 키에 변수 보간을 사용하지 않고 maketext를 통해 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="2f1647312ffbefd675d8f528a8e37c5009e71a69" translate="yes" xml:space="preserve">
          <source>instead of WriteMakefile().</source>
          <target state="translated">WriteMakefile () 대신.</target>
        </trans-unit>
        <trans-unit id="eba0c6725752796c17e07a2937a561d006b6b15d" translate="yes" xml:space="preserve">
          <source>instead of as equivalent to a &quot;C&quot; formatting code containing only &quot;$foo-&quot;, and then a &quot;bar&amp;gt;&quot; outside the &quot;C&quot; formatting code. This problem has since been solved by the addition of syntaxes like this:</source>
          <target state="translated">&quot;$ foo-&quot;만 포함하고 &quot;C&quot;형식 코드 외부의 &quot;bar&amp;gt;&quot;만 포함하는 &quot;C&quot;형식 코드와 동일합니다. 이 문제는 다음과 같은 구문을 추가하여 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="339af1c38f4492cc861c0d877b7a58adb6e97b45" translate="yes" xml:space="preserve">
          <source>instead of directory names (strictly speaking, a string like &quot;:a&quot; is a path, but not a name, since it contains a punctuation character &quot;:&quot;).</source>
          <target state="translated">디렉토리 이름 대신 (엄격히 말해서, &quot;: a&quot;와 같은 문자열은 경로이지만 문장 부호 문자 &quot;:&quot;를 포함하므로 이름이 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="71c621eff819164ca1ecdbe04a4dc834c714be8e" translate="yes" xml:space="preserve">
          <source>instead of file for the source of text.</source>
          <target state="translated">텍스트 소스 파일 대신.</target>
        </trans-unit>
        <trans-unit id="88c26c2da878553e470eabd76716a5185e744b60" translate="yes" xml:space="preserve">
          <source>instead of having to write these:</source>
          <target state="translated">이것을 쓰지 말고 :</target>
        </trans-unit>
        <trans-unit id="91a313e739687b01fbf17ae071a8b7960e77caf3" translate="yes" xml:space="preserve">
          <source>instead of importing it from &lt;code&gt;Scalar::Util&lt;/code&gt; . It should now be possible to disable DESTROY and CLONE. Note that while it isn't disabled, DESTROY will be called before the garbage collection of field hashes, so it will be invoked with a functional object and will continue to function.</source>
          <target state="translated">&lt;code&gt;Scalar::Util&lt;/code&gt; 에서 가져 오는 대신 . 이제 DESTROY 및 CLONE을 비활성화 할 수 있습니다. 비활성화되어 있지는 않지만 필드 해시의 가비지 수집 전에 DESTROY가 호출되므로 기능적 개체로 호출되어 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ca19eef2eb91cd974e6c0056c5fddda19bfec434" translate="yes" xml:space="preserve">
          <source>instead of this:</source>
          <target state="translated">이 대신에 :</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="bcd1c0a3df4642e2147982d69e49b696e53ddfb8" translate="yes" xml:space="preserve">
          <source>instead since</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="55e45921eb338b868da29d4463e5c0b1a7fa032c" translate="yes" xml:space="preserve">
          <source>instead). All tests are run from the</source>
          <target state="translated">대신). 모든 테스트는</target>
        </trans-unit>
        <trans-unit id="6568964b0e39083c6acb94093d9e6cd117dbe508" translate="yes" xml:space="preserve">
          <source>instead.</source>
          <target state="translated">instead.</target>
        </trans-unit>
        <trans-unit id="5864cc31660892914a70fe91105e62ed75ab49ed" translate="yes" xml:space="preserve">
          <source>instead. Accepted for backward compatibility; this option no longer does anything.</source>
          <target state="translated">대신에. 이전 버전과의 호환성을 위해 허용됩니다. 이 옵션은 더 이상 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef03d77059a00bfd1c11d4cbfef75cdec7cdddf4" translate="yes" xml:space="preserve">
          <source>instead. Example:</source>
          <target state="translated">대신에. 예:</target>
        </trans-unit>
        <trans-unit id="204889318f37ff1d1f1f6f99292b41699b359695" translate="yes" xml:space="preserve">
          <source>instead. The first argument is the modulus, the second is the angle (in radians, the full circle is 2*pi). (Mnemonic: &lt;code&gt;e&lt;/code&gt; is used as a notation for complex numbers in the polar form).</source>
          <target state="translated">대신에. 첫 번째 인수는 계수이고, 두 번째 인수는 각도입니다 (라디안, 전체 원은 2 * pi입니다). (니모닉 : &lt;code&gt;e&lt;/code&gt; 는 극수 형태의 복소수 표기법으로 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="7645f7261302e0c93107f96c3a0a2f2e386a7465" translate="yes" xml:space="preserve">
          <source>instmodsh</source>
          <target state="translated">instmodsh</target>
        </trans-unit>
        <trans-unit id="70e40b33ec9352c176bca23475fd76d8a67b5973" translate="yes" xml:space="preserve">
          <source>instmodsh - A shell to examine installed modules</source>
          <target state="translated">instmodsh-설치된 모듈을 검사하는 쉘</target>
        </trans-unit>
        <trans-unit id="1d52ae13ac6814d64753bd650c8b9eb068671b1f" translate="yes" xml:space="preserve">
          <source>instrumenting</source>
          <target state="translated">instrumenting</target>
        </trans-unit>
        <trans-unit id="cf024bf7ff5c78f4291e2a56cf869c898842d0fd" translate="yes" xml:space="preserve">
          <source>instubperl.U</source>
          <target state="translated">instubperl.U</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="6c36204b30c264dd8c654c40f76b604c80780842" translate="yes" xml:space="preserve">
          <source>int EXPR</source>
          <target state="translated">int EXPR</target>
        </trans-unit>
        <trans-unit id="1178cafbd64bbbfa77f5ac0a9d5032ed88162781" translate="yes" xml:space="preserve">
          <source>integer</source>
          <target state="translated">integer</target>
        </trans-unit>
        <trans-unit id="81edaa310efa3869e0192600c26c36ecc2b41f19" translate="yes" xml:space="preserve">
          <source>integer - Perl pragma to use integer arithmetic instead of floating point</source>
          <target state="translated">integer-부동 소수점 대신 정수 산술을 사용하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="1f7eb7b938a62fcc0eef0f61d44ced570ecec276" translate="yes" xml:space="preserve">
          <source>integer subscript</source>
          <target state="translated">정수 첨자</target>
        </trans-unit>
        <trans-unit id="5cbf2e209eef789477d4a083088b0b6f85e093bb" translate="yes" xml:space="preserve">
          <source>integers and numbers with decimal points are allowed in front of an exponent. Then exponents, like the overall sign, are independent of whether we are matching numbers with or without decimal points, and can be 'decoupled' from the mantissa. The overall form of the regexp now becomes clear:</source>
          <target state="translated">소수점 앞에 정수와 숫자가 지수 앞에 허용됩니다. 그런 다음 지수는 전체 부호와 같이 소수점이 있거나없는 숫자와 일치하는지 여부와 무관하며 가수에서 '분리'될 수 있습니다. 정규식의 전체 형태가 이제 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="8530773c89ade420faa71319e7ce6daa712ea89c" translate="yes" xml:space="preserve">
          <source>intended as a general cross-platform interface to all your C building needs. That would have been a much more ambitious goal!</source>
          <target state="translated">모든 C 건물 요구에 대한 일반적인 크로스 플랫폼 인터페이스로 설계되었습니다. 훨씬 야심 찬 목표였습니다!</target>
        </trans-unit>
        <trans-unit id="41b2a346afcb03862127323893afda0250576026" translate="yes" xml:space="preserve">
          <source>intention</source>
          <target state="translated">intention</target>
        </trans-unit>
        <trans-unit id="e5d84f3be36511b9cf0c6417bb410c050384d434" translate="yes" xml:space="preserve">
          <source>interface (see &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;) to make very customized executables.</source>
          <target state="translated">인터페이스 ( &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; 참조 )는 매우 사용자 정의 된 실행 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="34b8b656f661dde4a485cdae2859f84de092702d" translate="yes" xml:space="preserve">
          <source>interface (see &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;), such things are easy to do repeating the steps outlined in &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;Making executables with a custom collection of statically loaded extensions&lt;/a&gt;, and doing more comprehensive edits to main() of</source>
          <target state="translated">인터페이스 ( &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; 참조 )를 사용하면 &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;정적으로로드 된 확장의 사용자 정의 콜렉션으로 실행 파일 작성&lt;/a&gt; 및 main ()에 대한보다 포괄적 인 편집 수행에 설명 된 단계를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9404540d9f00d3c17c19b97f44fa1073b9f1c94f" translate="yes" xml:space="preserve">
          <source>interface provided by zlib.</source>
          <target state="translated">zlib에서 제공하는 인터페이스.</target>
        </trans-unit>
        <trans-unit id="46e1a61d83495a69cfaa8d84253bec174db2a0fe" translate="yes" xml:space="preserve">
          <source>interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement cheap automatic dynamic loading of Perl modules.</source>
          <target state="translated">많은 플랫폼에서 사용 가능한 동적 연결 메커니즘에 대한 인터페이스. 주요 목적은 Perl 모듈의 저렴한 자동 동적 로딩을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="902ee24d0f5c369c83561e631220c869f56c159a" translate="yes" xml:space="preserve">
          <source>interface_hairy.h</source>
          <target state="translated">interface_hairy.h</target>
        </trans-unit>
        <trans-unit id="58abb7dae834bec7c2231a51b0e43d7b2f1dcd1e" translate="yes" xml:space="preserve">
          <source>interface_simple.h</source>
          <target state="translated">interface_simple.h</target>
        </trans-unit>
        <trans-unit id="c48322cd43b3f5db0aa919df16088078ec067df7" translate="yes" xml:space="preserve">
          <source>interior-sequence storage will not be reclaimed upon destruction!</source>
          <target state="translated">파괴시 내부 순서 저장은 회수되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="9f33a7c798af6fd6abb28049d9c1b3edfa2fd24a" translate="yes" xml:space="preserve">
          <source>internal</source>
          <target state="translated">internal</target>
        </trans-unit>
        <trans-unit id="e51ec2956340bd90ad015ad9b1a44eb41fe13048" translate="yes" xml:space="preserve">
          <source>internal error: useconds &amp;lt; 0 (unsigned ... signed ...)</source>
          <target state="translated">내부 오류 : useconds &amp;lt;0 (부호없는 ... 부호있는 ...)</target>
        </trans-unit>
        <trans-unit id="8bc675a4bbcb339a374caa4cff4d8cc8a867b3a0" translate="yes" xml:space="preserve">
          <source>internally. &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is just a synonym for &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; , which is magical. (The pseudo code above doesn't work because it treats &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; as non-magical.)</source>
          <target state="translated">내부적으로. &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 마법 같은 &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; 와 동의어입니다 . (위의 의사 코드는 &lt;code&gt;&amp;lt;ARGV&amp;gt;&lt;/code&gt; 를 마술이 아닌 것으로 취급하기 때문에 작동하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="f95a7232cfa16eef01e2e32a3d063b6807475100" translate="yes" xml:space="preserve">
          <source>interp</source>
          <target state="translated">interp</target>
        </trans-unit>
        <trans-unit id="dd17e57867fd7c7c09f592d502367e7a72bee660" translate="yes" xml:space="preserve">
          <source>interp.c</source>
          <target state="translated">interp.c</target>
        </trans-unit>
        <trans-unit id="5ec54f35edbea363d07d169d7643fe49322214d6" translate="yes" xml:space="preserve">
          <source>interpolate within double quotes, nor do single quotes impede evaluation of variables when used within double quotes.</source>
          <target state="translated">큰 따옴표 안에 보간하거나 작은 따옴표는 큰 따옴표 안에 사용될 때 변수의 평가를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21842adaec06e4938f4774dc8dc13c419d06b021" translate="yes" xml:space="preserve">
          <source>interpolate, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">보간하려면 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7365365ce3b1fe060f6c2b335e7ead37819acbe2" translate="yes" xml:space="preserve">
          <source>interpreted as a signed integer</source>
          <target state="translated">부호있는 정수로 해석</target>
        </trans-unit>
        <trans-unit id="22798399388200f939f1d84f974aacbf98336d00" translate="yes" xml:space="preserve">
          <source>interpreter has to be &lt;b&gt;compiled&lt;/b&gt; differently for each platform because it is implemented in C, but programs written in the Perl language are largely platform independent.</source>
          <target state="translated">인터프리터는 C로 구현되기 때문에 각 플랫폼마다 다르게 &lt;b&gt;컴파일&lt;/b&gt; 되어야 하지만 Perl 언어로 작성된 프로그램은 대부분 플랫폼 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="09d29e0b1909ff0aa3805759c7f1db36d575f073" translate="yes" xml:space="preserve">
          <source>interpreter threads</source>
          <target state="translated">인터프리터 스레드</target>
        </trans-unit>
        <trans-unit id="d897bf481c6d3038f32cd50b3a8b5f6cf56b6348" translate="yes" xml:space="preserve">
          <source>interrupted</source>
          <target state="translated">interrupted</target>
        </trans-unit>
        <trans-unit id="5e40097f4262a60de6a010dd128b47db45b0fccb" translate="yes" xml:space="preserve">
          <source>intflags</source>
          <target state="translated">intflags</target>
        </trans-unit>
        <trans-unit id="a379c85f8c69a0d3679d831f2b58817f66b078af" translate="yes" xml:space="preserve">
          <source>into</source>
          <target state="translated">into</target>
        </trans-unit>
        <trans-unit id="80a3fceeaea68858a65bb33607e442ea25c1e2b4" translate="yes" xml:space="preserve">
          <source>into UTF-8, and similarly converts character code points. This is used when the script is a combination of ASCII (for the variable names and punctuation,</source>
          <target state="translated">UTF-8로 변환하고 문자 코드 포인트를 유사하게 변환합니다. 스크립트가 ASCII의 조합 인 경우 (변수 이름과 문장 부호,</target>
        </trans-unit>
        <trans-unit id="5efbb46a90ecb3ca1fecc85280ad96184eda7b36" translate="yes" xml:space="preserve">
          <source>into Unix format before being written to the zip file.</source>
          <target state="translated">압축 파일에 기록되기 전에 유닉스 형식으로.</target>
        </trans-unit>
        <trans-unit id="5a8ec964fb55903ea9af77229da3a4f176eca61a" translate="yes" xml:space="preserve">
          <source>into a &lt;code&gt;lineseq&lt;/code&gt; list op, which is returned.</source>
          <target state="translated">에 &lt;code&gt;lineseq&lt;/code&gt; 의 반환 목록 작전.</target>
        </trans-unit>
        <trans-unit id="09bdc6967275516d660dcb43a692aac47b477ffa" translate="yes" xml:space="preserve">
          <source>into a list op if it is not one already, and then converts it into the specified</source>
          <target state="translated">목록 op가 아닌 경우 op로 지정한 다음 지정된 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0e21ff0e56d846baee28d588470952974dd44859" translate="yes" xml:space="preserve">
          <source>into the package by &lt;code&gt;filter_add&lt;/code&gt; , unless the reference was already blessed.</source>
          <target state="translated">참조가 이미 축복되지 않은 경우 &lt;code&gt;filter_add&lt;/code&gt; 로 패키지에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="4f339c3e14932662ae9d0559ad77c63d4936a2d3" translate="yes" xml:space="preserve">
          <source>into this:</source>
          <target state="translated">이것으로 :</target>
        </trans-unit>
        <trans-unit id="760aebbce7f663b4ebc868367cc05da9ede071dc" translate="yes" xml:space="preserve">
          <source>intrpvar.h</source>
          <target state="translated">intrpvar.h</target>
        </trans-unit>
        <trans-unit id="ad345dd991761a50f9adb9059b18cd2ed01ff85e" translate="yes" xml:space="preserve">
          <source>intsize.U</source>
          <target state="translated">intsize.U</target>
        </trans-unit>
        <trans-unit id="2bb8530511b63a0c151d59eadae559d3b4f9fc74" translate="yes" xml:space="preserve">
          <source>intuit</source>
          <target state="translated">intuit</target>
        </trans-unit>
        <trans-unit id="b712b0f1d2c4286763eab08ade92c1091ec6dd8d" translate="yes" xml:space="preserve">
          <source>invalid, potentially earning a different error message than the error message (or warning, or event) generated by a merely unknown (but theoretically valid) htmlname, as in &quot;E&amp;lt;qacute&amp;gt;&quot; [sic]. However, Pod parsers are not required to make this distinction.</source>
          <target state="translated">&quot;E &amp;lt;qacute&amp;gt;&quot;[sic]에서와 같이 단순히 알 수없는 (그러나 이론적으로 유효한) htmlname으로 생성 된 오류 메시지 (또는 경고 또는 이벤트)와 다른 오류 메시지가 표시 될 수 있습니다. 그러나 포드 파서는 이러한 구분을 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1292ad671fbfc4d35ca913ab3b9a0129dc90d413" translate="yes" xml:space="preserve">
          <source>inverse operation should be applied in the Fetch method.</source>
          <target state="translated">Fetch 방법에서는 역 연산이 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d2aa1cd14486c3a4a5f5b5f91ebfce00891a815" translate="yes" xml:space="preserve">
          <source>invoke the method call like this:</source>
          <target state="translated">다음과 같이 메소드 호출을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9d2e89cb161a40179909f64d20244135bf4c608d" translate="yes" xml:space="preserve">
          <source>invoke the overload method with &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; as an argument. Instead the above table is consulted as normal, and based on the type of &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt;, overloading may or may not be invoked. For simple strings or numbers, &quot;in&quot; becomes equivalent to this:</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 를 인수로 사용 하여 오버로드 메소드를 호출하십시오 . 대신 위의 표를 정상적으로 참조하고 &lt;code&gt;&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 유형에 따라 오버로드를 호출하거나 호출하지 않을 수 있습니다. 간단한 문자열이나 숫자의 경우 &quot;in&quot;은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5f53a1db4bd0284aa3660bede417a2b6d5db51f" translate="yes" xml:space="preserve">
          <source>invokes the &lt;b&gt;parse_from_filehandle()&lt;/b&gt; method passing it the corresponding input and output filehandles.</source>
          <target state="translated">&lt;b&gt;parse_from_filehandle ()&lt;/b&gt; 메소드를 호출하여 해당 입력 및 출력 파일 핸들을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="271383556324a922b015d9d5abb777b3b680293a" translate="yes" xml:space="preserve">
          <source>invoking it for the directory's contents. It does a postorder traversal instead of a preorder traversal, working from the bottom of the directory tree up where &lt;code&gt;find()&lt;/code&gt; works from the top of the tree down.</source>
          <target state="translated">디렉토리 내용을 위해 호출합니다. 디렉토리 트리의 맨 아래부터 &lt;code&gt;find()&lt;/code&gt; 가 트리의 맨 위에서 작동 하는 프리오더 순회 대신 포스트 오더 순회를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="1eb7e48254406f0ad58f032dc48fe49432e4957e" translate="yes" xml:space="preserve">
          <source>io/pipe.t</source>
          <target state="translated">io/pipe.t</target>
        </trans-unit>
        <trans-unit id="1ad14cf4402c59fea497f745d3df4a52f09e403b" translate="yes" xml:space="preserve">
          <source>ioctl</source>
          <target state="translated">ioctl</target>
        </trans-unit>
        <trans-unit id="ac706755d569c148cde69cf903fa0e404d5fb464" translate="yes" xml:space="preserve">
          <source>ioctl FILEHANDLE,FUNCTION,SCALAR</source>
          <target state="translated">ioctl 파일 핸들, 기능, 스칼라</target>
        </trans-unit>
        <trans-unit id="81c3f83f167f0c364e4d909401dd2fbced2eb5c4" translate="yes" xml:space="preserve">
          <source>ioctl.h</source>
          <target state="translated">ioctl.h</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="463b46fb59560ec9a4f45c2879fbeca62bdbadb9" translate="yes" xml:space="preserve">
          <source>is #included, it redefines the aTHX and aTHX_ macros to call a function that will return the context. Thus, something like:</source>
          <target state="translated">#included, aTHX 및 aTHX_ 매크로를 재정 의하여 컨텍스트를 리턴하는 함수를 호출합니다. 따라서 다음과 같은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="869c55ae7392038ca2ada25a5b705659a6fc2134" translate="yes" xml:space="preserve">
          <source>is - and it has the same effect.)</source>
          <target state="translated">-와 같은 효과가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="83b4bd82f5c3073fcab6cd52e2b883488c825747" translate="yes" xml:space="preserve">
          <source>is 0, encoding and decoding replace any malformed character with a</source>
          <target state="translated">0, 인코딩 및 디코딩은 잘못된 문자를 a로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0bda6c393b81ec62986133bc68d16a600e5376b4" translate="yes" xml:space="preserve">
          <source>is 0, or the routine croaks if</source>
          <target state="translated">0이거나 일상적인 경우</target>
        </trans-unit>
        <trans-unit id="9433dff76d69aeb49c9f1b1e6a810eef80d46303" translate="yes" xml:space="preserve">
          <source>is 1, methods immediately die with an error message. Therefore, when</source>
          <target state="translated">1이면 메소드가 즉시 오류 메시지와 함께 종료됩니다. 따라서 언제</target>
        </trans-unit>
        <trans-unit id="a4d2c83b695d00259b2771edae5aa2d42137fabb" translate="yes" xml:space="preserve">
          <source>is 1, you should trap exceptions with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;, unless you really want to let it &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신과 함께 트랩 예외해야 1 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 당신이 정말로 수 있도록하려는 경우가 아니면, 그것은 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08b01d36edc2dd6fddbc0756fbe9c5513a659ab8" translate="yes" xml:space="preserve">
          <source>is 1.</source>
          <target state="translated">1입니다.</target>
        </trans-unit>
        <trans-unit id="8c0ff8e969bcd171ef8d6c4cddc51856c058ecf8" translate="yes" xml:space="preserve">
          <source>is 1. When a character whose ord value is larger than 0xFFFF is encountered, its place is filled with \x{FFFD} if</source>
          <target state="translated">ord 값이 0xFFFF보다 큰 문자가 발견되면 해당 위치는 \ x {FFFD}로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="79d529e67b476b62851937c5b23067cd4ce1b5bd" translate="yes" xml:space="preserve">
          <source>is 3 and</source>
          <target state="translated">3이고</target>
        </trans-unit>
        <trans-unit id="9522c6460c5f6f20c4307e7bed6822d3f2d77897" translate="yes" xml:space="preserve">
          <source>is 3. A single &lt;code&gt;ITEM&lt;/code&gt; is always inlined.</source>
          <target state="translated">단일 &lt;code&gt;ITEM&lt;/code&gt; 은 항상 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c84ec496d8b224c85fc14573a3862152ff5122" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;C&lt;/code&gt; (for &lt;code&gt;common&lt;/code&gt; ) if the best possible fold is a single code point (</source>
          <target state="translated">인 &lt;code&gt;C&lt;/code&gt; (위한 &lt;code&gt;common&lt;/code&gt; 최상의 배 단일 코드 포인트 인 경우) (</target>
        </trans-unit>
        <trans-unit id="939984a83e875f30897be52391d8f5b35e2e83eb" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;FooPtr&lt;/code&gt;</source>
          <target state="translated">이다 &lt;code&gt;FooPtr&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="65816c93586e4c56d14bdf38227bc0d35e22af9d" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;Foo__Bar&lt;/code&gt;</source>
          <target state="translated">이다 &lt;code&gt;Foo__Bar&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="9e4470db40e21830b033effb525cbd3a1872e1d1" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;I&lt;/code&gt; , and</source>
          <target state="translated">인 &lt;code&gt;I&lt;/code&gt; , 그리고</target>
        </trans-unit>
        <trans-unit id="c6bcb94dd29106e50e5e67679cd655c28bdf7f7a" translate="yes" xml:space="preserve">
          <source>is &lt;code&gt;OP_ANDASSIGN&lt;/code&gt; , &lt;code&gt;OP_ORASSIGN&lt;/code&gt; , or &lt;code&gt;OP_DORASSIGN&lt;/code&gt; , then a suitable conditional optree is constructed. If</source>
          <target state="translated">인 &lt;code&gt;OP_ANDASSIGN&lt;/code&gt; , &lt;code&gt;OP_ORASSIGN&lt;/code&gt; 또는 &lt;code&gt;OP_DORASSIGN&lt;/code&gt; 후 적합한 조건 optree가 구성된다. 만약</target>
        </trans-unit>
        <trans-unit id="ce21611a14027ecfce0b71f876f7d06f5a1d8b5b" translate="yes" xml:space="preserve">
          <source>is NULL).</source>
          <target state="translated">NULL입니다).</target>
        </trans-unit>
        <trans-unit id="4ad590898ac06ec587af8f66311fb1bbc1535303" translate="yes" xml:space="preserve">
          <source>is a GV supplying the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">는 진단을 수행해야하는 경우 &lt;code&gt;entersub&lt;/code&gt; op 의 수신자를 참조하기 위해 확인 기능에서 사용해야하는 이름을 제공하는 GV 입니다. 다른 서브 루틴에 대한 호출 또는 메소드 호출과 같은 비표준 상황에서 점검 기능을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d3d68a728efcdd2ab6530d7d5ecfbfb371a2be" translate="yes" xml:space="preserve">
          <source>is a Perl</source>
          <target state="translated">펄입니다</target>
        </trans-unit>
        <trans-unit id="130739bc618160f7f1fc5c5a9ff8b4322613f98e" translate="yes" xml:space="preserve">
          <source>is a Perl subroutine that takes no arguments (that's the</source>
          <target state="translated">인수를 취하지 않는 Perl 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="b8059014bc71acfd20332d69515ec64768947e28" translate="yes" xml:space="preserve">
          <source>is a blessed reference or a package name</source>
          <target state="translated">복된 참조 또는 패키지 이름입니다</target>
        </trans-unit>
        <trans-unit id="37b225c02472425d591d858f478440711108fafc" translate="yes" xml:space="preserve">
          <source>is a combination of the &lt;code&gt;&quot;al&quot;&lt;/code&gt; type and the &lt;code&gt;&quot;ae&quot;&lt;/code&gt; type. Some of the map array elements have the forms given by &lt;code&gt;&quot;al&quot;&lt;/code&gt; , and the rest are the empty string. The property &lt;code&gt;NFKC_Casefold&lt;/code&gt; has this form. An example slice is:</source>
          <target state="translated">&lt;code&gt;&quot;al&quot;&lt;/code&gt; 유형과 &lt;code&gt;&quot;ae&quot;&lt;/code&gt; 유형 의 조합입니다 . 일부지도 배열 요소에는 &lt;code&gt;&quot;al&quot;&lt;/code&gt; 로 지정된 형식이 있으며 나머지는 빈 문자열입니다. &lt;code&gt;NFKC_Casefold&lt;/code&gt; 특성 은이 양식을 갖습니다. 슬라이스 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61c94ee116f6a0b02686534706f14ab4ac28cf95" translate="yes" xml:space="preserve">
          <source>is a command-line interface to CPAN.pm. It allows you to install modules or distributions from CPAN, or just get information about them, and a lot more. It is similar to the command line mode of the &lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt; module,</source>
          <target state="translated">CPAN.pm에 대한 명령 행 인터페이스입니다. CPAN에서 모듈 또는 배포판을 설치하거나 모듈에 대한 정보 등을 얻을 수 있습니다. &lt;a href=&quot;cpan&quot;&gt;CPAN&lt;/a&gt; 모듈 의 명령 행 모드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="8330f641c616959b5dc4d2a1018e6e7abd8aea60" translate="yes" xml:space="preserve">
          <source>is a command-line interface to the test-running functionality of</source>
          <target state="translated">테스트 실행 기능에 대한 명령 행 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="a3f3d9feee7e7a4f2fbdd3512e2a38e4a55fb2b5" translate="yes" xml:space="preserve">
          <source>is a common abbreviation for a character</source>
          <target state="translated">문자의 일반적인 약어입니다</target>
        </trans-unit>
        <trans-unit id="9febe7f9f7abef798cc6a59cd722795b25995da6" translate="yes" xml:space="preserve">
          <source>is a compiler to convert Perl XS code into C code. It is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">Perl XS 코드를 C 코드로 변환하는 컴파일러입니다. 일반적으로 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker에&lt;/a&gt; 의해 작성된 makefile에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="90882a351b430362ddbaa59a277b7ed39fa5a7e3" translate="yes" xml:space="preserve">
          <source>is a computer science term with a precise but hard-to-explain meaning. Usually, closures are implemented in Perl as anonymous subroutines with lasting references to lexical variables outside their own scopes. These lexicals magically refer to the variables that were around when the subroutine was defined (deep binding).</source>
          <target state="translated">정확하지만 설명하기 어려운 컴퓨터 과학 용어입니다. 일반적으로 클로저는 자체 범위 밖의 어휘 변수에 대한 지속적인 참조를 가진 익명 서브 루틴으로 Perl에서 구현됩니다. 이 어휘는 마 법적으로 서브 루틴이 정의되었을 때의 주변 변수 (딥 바인딩)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bff47d2ce40b707b0845e92b4a96b5d4dc076d28" translate="yes" xml:space="preserve">
          <source>is a cpp token indicating which entry to return. If the member is not set this will return a default value. The return type depends on</source>
          <target state="translated">반환 할 항목을 나타내는 cpp 토큰입니다. 멤버가 설정되어 있지 않으면 기본값이 반환됩니다. 반품 유형은</target>
        </trans-unit>
        <trans-unit id="e5f9de05e11db96a337f0d1eb38539a88b5409b2" translate="yes" xml:space="preserve">
          <source>is a cpp token indicating which entry to set. See &lt;a href=&quot;perlguts#Custom-Operators&quot;&gt;Custom Operators in perlguts&lt;/a&gt; for details about the available members and how they are used. This macro evaluates its argument more than once.</source>
          <target state="translated">설정할 항목을 나타내는 cpp 토큰입니다. 사용 가능한 멤버 및 사용 방법에 대한 자세한 내용은 &lt;a href=&quot;perlguts#Custom-Operators&quot;&gt;perlguts의 사용자 정의 연산자를&lt;/a&gt; 참조하십시오 . 이 매크로는 인수를 두 번 이상 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8b175b89be18442a11782bc701cae16d7d0a17b0" translate="yes" xml:space="preserve">
          <source>is a decimal number, and XML uses &lt;code&gt;&amp;amp;#x&lt;i&gt;HHHH&lt;/i&gt;;&lt;/code&gt; where</source>
          <target state="translated">는 10 진수이며 XML은 &lt;code&gt;&amp;amp;#x&lt;i&gt;HHHH&lt;/i&gt;;&lt;/code&gt; 어디</target>
        </trans-unit>
        <trans-unit id="867e37e0ad95e37a79d195114de1a83f0d632684" translate="yes" xml:space="preserve">
          <source>is a fixed string that must appear at a particular offset from the beginning of the match. A</source>
          <target state="translated">일치하는 시작 부분에서 특정 오프셋에 표시되어야하는 고정 문자열입니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="61f3bde037bf2172e594d6db29ca0978f1c08a37" translate="yes" xml:space="preserve">
          <source>is a flag indicating whether we're in a dclone() or a regular de-serialization via thaw(), and</source>
          <target state="translated">dclone () 또는 thaw ()를 통한 일반 직렬화 해제 여부를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="177a8f74fbd5fb5c45bffdbce71939307bad58c8" translate="yes" xml:space="preserve">
          <source>is a flag indicating whether we're in a dclone() or a regular serialization via store() or freeze().</source>
          <target state="translated">dclone () 또는 store () 또는 freeze ()를 통한 일반 직렬화 여부를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="6e2e892937bca1eea5ee9c95d0d5e5e5f11395dd" translate="yes" xml:space="preserve">
          <source>is a form of if-then-else statement that allows one to choose which patterns are to be matched, based on some condition. There are two types of conditional expression: &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; and &lt;code&gt;(?(condition)yes-regexp|no-regexp)&lt;/code&gt;. &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; is like an &lt;code&gt;'if () {}'&lt;/code&gt; statement in Perl. If the &lt;code&gt;condition&lt;/code&gt; is true, the &lt;code&gt;yes-regexp&lt;/code&gt; will be matched. If the &lt;code&gt;condition&lt;/code&gt; is false, the &lt;code&gt;yes-regexp&lt;/code&gt; will be skipped and Perl will move onto the next regexp element. The second form is like an &lt;code&gt;'if () {} else {}'&lt;/code&gt; statement in Perl. If the &lt;code&gt;condition&lt;/code&gt; is true, the &lt;code&gt;yes-regexp&lt;/code&gt; will be matched, otherwise the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-regexp&lt;/a&gt;&lt;/code&gt; will be matched.</source>
          <target state="translated">if-then-else 문의 형태로 어떤 조건에 따라 일치시킬 패턴을 선택할 수 있습니다. 조건식에는 &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; 와 &lt;code&gt;(?(condition)yes-regexp|no-regexp)&lt;/code&gt; 두 가지 유형이 있습니다 . &lt;code&gt;(?(condition)yes-regexp)&lt;/code&gt; 는 Perl 의 &lt;code&gt;'if () {}'&lt;/code&gt; 문과 같습니다. 는 IF &lt;code&gt;condition&lt;/code&gt; 사실의 &lt;code&gt;yes-regexp&lt;/code&gt; 매치됩니다. 는 IF &lt;code&gt;condition&lt;/code&gt; 거짓의 &lt;code&gt;yes-regexp&lt;/code&gt; 건너 뛰고 펄은 다음 정규 표현식 요소로 이동합니다. 두 번째 형식은 Perl 의 &lt;code&gt;'if () {} else {}'&lt;/code&gt; 문과 같습니다. 는 IF &lt;code&gt;condition&lt;/code&gt; 사실의 &lt;code&gt;yes-regexp&lt;/code&gt; 일치하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-regexp&lt;/a&gt;&lt;/code&gt; 이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f9a2da8cb2cec1f20323fe27b5dacfdea89a7e07" translate="yes" xml:space="preserve">
          <source>is a hashref (as passed to &lt;code&gt;C_constant&lt;/code&gt; and &lt;code&gt;match_clause&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;C_constant&lt;/code&gt; 및 &lt;code&gt;match_clause&lt;/code&gt; 로 전달되는 해시 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="792c669ddbc9146f9c82edec4f8d983c193844e7" translate="yes" xml:space="preserve">
          <source>is a hexadecimal number, also inserts a character into a string. The character it inserts is the one whose Unicode code point (ordinal value) is equal to the number. For example, &lt;code&gt;&quot;\N{U+263a}&quot;&lt;/code&gt; is the Unicode (white background, black foreground) smiley face equivalent to &lt;code&gt;&quot;\N{WHITE SMILING FACE}&quot;&lt;/code&gt; . Also note, &lt;code&gt;\N{&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; can mean a regex quantifier instead of a character name, when the</source>
          <target state="translated">16 진 숫자이며 문자열에 문자를 삽입합니다. 삽입하는 문자는 유니 코드 코드 포인트 (정수 값)가 숫자와 같은 문자입니다. 예를 들어, &lt;code&gt;&quot;\N{U+263a}&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;\N{WHITE SMILING FACE}&quot;&lt;/code&gt; 와 동일한 유니 코드 (흰색 배경, 검은 색 전경) 웃는 얼굴 입니다. 또한 &lt;code&gt;\N{&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; 은 문자 이름 대신 정규식 수량자를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0370087df9b1f80bb3aab519d6395ef994f93a7f" translate="yes" xml:space="preserve">
          <source>is a module meta-data file pioneered by Module::Build and automatically generated as part of the 'distdir' target (and thus 'dist'). See &lt;a href=&quot;../makemaker#Module-Meta-Data&quot;&gt;Module Meta-Data in ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">는 Module :: Build에 의해 개척 된 모듈 메타 데이터 파일이며 'distdir'대상 (및 'dist')의 일부로 자동 생성됩니다. &lt;a href=&quot;../makemaker#Module-Meta-Data&quot;&gt;ExtUtils :: MakeMaker의 모듈 메타 데이터를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb5615f55577e2ec9ec2ce738441f4f048adaa11" translate="yes" xml:space="preserve">
          <source>is a name for a character that has been documented but was never in any actual standard.</source>
          <target state="translated">문서화되었지만 실제 표준에는 없었던 캐릭터의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a64ade54cc01a4b8ab579c03320b508d3b51d58b" translate="yes" xml:space="preserve">
          <source>is a name for the Unicode character, as specified in the Unicode standard. For instance, if we wanted to represent or match the astrological sign for the planet Mercury, we could use</source>
          <target state="translated">유니 코드 표준에 지정된 유니 코드 문자의 이름입니다. 예를 들어, 행성 수성에 대한 점성 학적 표시를 나타내거나 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="2afe30cfa025d1ad86d16c1371192737e35d27e5" translate="yes" xml:space="preserve">
          <source>is a not-very-meaningful hex checksum), and run</source>
          <target state="translated">의미없는 16 진 체크섬입니다.)</target>
        </trans-unit>
        <trans-unit id="fc99a02b05cb226b1a73a69a63bbd1617e2aa050" translate="yes" xml:space="preserve">
          <source>is a number (or comma separated pair of numbers (see &lt;a href=&quot;perlreref#QUANTIFIERS&quot;&gt;QUANTIFIERS in perlreref&lt;/a&gt;), and is not related to this pragma.</source>
          <target state="translated">는 숫자 (또는 쉼표로 구분 된 숫자 쌍 ( &lt;a href=&quot;perlreref#QUANTIFIERS&quot;&gt;perlreref의 QUANTIFIERS&lt;/a&gt; 참조) 이며이 pragma와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a38b8230fcc77e55d3807d6b5a4aaef15592a7b" translate="yes" xml:space="preserve">
          <source>is a number in hexadecimal that gives the code point that Unicode has assigned to the desired character. It is customary but not required to use leading zeros to pad the number to 4 digits. Thus &lt;code&gt;\N{U+0041}&lt;/code&gt; means &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; , and you will rarely see it written without the two leading zeros. &lt;code&gt;\N{U+0041}&lt;/code&gt; means &quot;A&quot; even on EBCDIC machines (where the ordinal value of &quot;A&quot; is not 0x41).</source>
          <target state="translated">유니 코드가 원하는 문자에 할당 한 코드 포인트를 제공하는 16 진수 숫자입니다. 관례이지만 선행 0을 사용하여 숫자를 4 자리로 채울 필요는 없습니다. 따라서 &lt;code&gt;\N{U+0041}&lt;/code&gt; 은 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 의미 하며 두 개의 0이 없으면 쓰여지지 않습니다. &lt;code&gt;\N{U+0041}&lt;/code&gt; 은 EBCDIC 시스템에서도 &quot;A&quot;를 의미합니다 ( &quot;A&quot;의 서수 값이 0x41이 아님).</target>
        </trans-unit>
        <trans-unit id="9f403a1abf70edece08e0c80d52724deac025b2c" translate="yes" xml:space="preserve">
          <source>is a number.</source>
          <target state="translated">숫자입니다.</target>
        </trans-unit>
        <trans-unit id="6d72cdfe9071b403de5c891b1782a09bdb8b7a77" translate="yes" xml:space="preserve">
          <source>is a numeric suffix), and other duplicate references to substructures within &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">숫자 접미사) 및 &lt;code&gt;$VAR&lt;/code&gt; 내의 하위 구조에 대한 다른 중복 참조</target>
        </trans-unit>
        <trans-unit id="1caf25c615a60e7db02057f097ce6ef82bd0a961" translate="yes" xml:space="preserve">
          <source>is a numeric suffix. Will return a list of strings in a list context.</source>
          <target state="translated">숫자 접미사입니다. 목록 컨텍스트에서 문자열 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5450267d9d9934e68cfc043e8aa906ed9b69bfee" translate="yes" xml:space="preserve">
          <source>is a package name</source>
          <target state="translated">패키지 이름입니다</target>
        </trans-unit>
        <trans-unit id="a6b5bcbb54d5f0f80b9f08f8fbaf2ea009b106b5" translate="yes" xml:space="preserve">
          <source>is a pointer to the &lt;code&gt;entersub&lt;/code&gt; op, which may be replaced by the check function, and</source>
          <target state="translated">확인 기능으로 대체 될 수 있는 &lt;code&gt;entersub&lt;/code&gt; op에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="4e118cb5d55603d5852d3f949969f69eb230e7be" translate="yes" xml:space="preserve">
          <source>is a pointer to the C function that is to be added to that opcode's check chain, and</source>
          <target state="translated">해당 opcode의 검사 체인에 추가 될 C 함수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="8f2f096033e5e09b15119337208eeca0b44d4133" translate="yes" xml:space="preserve">
          <source>is a pointer.</source>
          <target state="translated">포인터입니다.</target>
        </trans-unit>
        <trans-unit id="dece3ef8f9c2a4f9d52c4c4c5d98bb83ab5bfede" translate="yes" xml:space="preserve">
          <source>is a positive (unsigned) decimal number of any length is an absolute reference to a capturing group.</source>
          <target state="translated">모든 길이의 양수 (부호없는) 10 진수는 캡처 그룹에 대한 절대 참조입니다.</target>
        </trans-unit>
        <trans-unit id="4edbb45f32f48cd1511fdfb6115d66414ec1fbfb" translate="yes" xml:space="preserve">
          <source>is a positive integer and</source>
          <target state="translated">양의 정수이고</target>
        </trans-unit>
        <trans-unit id="165f46eaddab8fb19180056f4de237d41d7417b2" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="translated">키 문자열의 사전 계산 된 해시이거나 사전 계산되지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="7069eb9cb165fec523e6308bce4b06c05a39cb8c" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar copy of the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="translated">키 문자열의 사전 계산 된 해시이거나 사전 계산되지 않은 경우 0입니다. 키와 연관된 값의 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 스칼라 사본 또는 키와 연관된 값이없는 경우 &amp;amp; PL_sv_placeholder를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="5da7fecbae6781f458a7622c0a97efc463b638d6" translate="yes" xml:space="preserve">
          <source>is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="translated">키 문자열의 사전 계산 된 해시이거나 사전 계산되지 않은 경우 0입니다. 키와 연관된 값을 나타내는 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 스칼라 또는 키와 연관된 값이없는 경우 &amp;amp; PL_sv_placeholder를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="1da3d543f80049c240b6604f0deb64866fbd0017" translate="yes" xml:space="preserve">
          <source>is a preprocessing token indicating which entry to set. The type of</source>
          <target state="translated">설정할 항목을 나타내는 전처리 토큰입니다. 유형</target>
        </trans-unit>
        <trans-unit id="d9012ca0d0ddb846debfb4395c94c7b45828744f" translate="yes" xml:space="preserve">
          <source>is a preprocessing token; the type of</source>
          <target state="translated">전처리 토큰입니다. 의 유형</target>
        </trans-unit>
        <trans-unit id="a7b7145b8e2f4d29a4eac42b3b05b4ed146ab52f" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to disable.</source>
          <target state="translated">비활성화 할 항목을 나타내는 전 처리기 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="fbe9b4cd270e1fcc591a419f6eee763dc9c340d8" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to enable. This will assert (under -DDEBUGGING) if the entry doesn't contain a valid pointer.</source>
          <target state="translated">활성화 할 항목을 나타내는 전 처리기 토큰입니다. 항목에 유효한 포인터가 없으면 -DDEBUGGING 아래에서 주장합니다.</target>
        </trans-unit>
        <trans-unit id="ea5ce0a59c714754786219bdd5275aeb9e974151" translate="yes" xml:space="preserve">
          <source>is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return NULL. The type of the return value depends on which entry you ask for.</source>
          <target state="translated">반환 할 항목을 나타내는 전 처리기 토큰입니다. 적절한 플래그를 설정하지 않으면 NULL을 반환합니다. 반환 값의 유형은 요청한 항목에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="38ca9aff9fa5b538144546880af0d48a59e862b4" translate="yes" xml:space="preserve">
          <source>is a profiling tool available in many Unix platforms which uses</source>
          <target state="translated">많은 유닉스 플랫폼에서 사용할 수있는 프로파일 링 도구입니다.</target>
        </trans-unit>
        <trans-unit id="d57a2c635ead24e8cb41d2f62c0df6efe7ec2d7c" translate="yes" xml:space="preserve">
          <source>is a pure</source>
          <target state="translated">순수한</target>
        </trans-unit>
        <trans-unit id="c05fe253a73eaf5c843bec936db4e04771e23194" translate="yes" xml:space="preserve">
          <source>is a reference to a hash, keyed by name, values being the hashrefs in the</source>
          <target state="translated">이름으로 키가 붙은 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9987d31f4281509d0e0c9da093d035205a293365" translate="yes" xml:space="preserve">
          <source>is a regex that matches</source>
          <target state="translated">일치하는 정규식입니다</target>
        </trans-unit>
        <trans-unit id="3dca816cf7d96a1f946c0cb0d43d7b15ae0dd1ff" translate="yes" xml:space="preserve">
          <source>is a sequence of digits (not starting with 0) whose value reflects the paren-number of the capture group to recurse to. &lt;code&gt;(?R)&lt;/code&gt; recurses to the beginning of the whole pattern. &lt;code&gt;(?0)&lt;/code&gt; is an alternate syntax for &lt;code&gt;(?R)&lt;/code&gt;. If</source>
          <target state="translated">는 일련의 숫자 (0으로 시작하지 않음)이며 값은 재귀 할 캡처 그룹의 paren-number를 반영합니다. &lt;code&gt;(?R)&lt;/code&gt; 은 전체 패턴의 시작 부분으로 반복됩니다. &lt;code&gt;(?0)&lt;/code&gt; 은 &lt;code&gt;(?R)&lt;/code&gt; 의 대체 구문입니다 . 만약</target>
        </trans-unit>
        <trans-unit id="bba78d1bb88089201797aae5c1cab963b9424243" translate="yes" xml:space="preserve">
          <source>is a set of flags indicating the kind of pad entry required, which will be set in the value SV for the allocated pad entry:</source>
          <target state="translated">필요한 패드 엔트리의 종류를 나타내는 플래그 세트이며, 할당 된 패드 엔트리의 값 SV에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="91abdb027092f65d2c1008ca97d5e66bca8c6cd6" translate="yes" xml:space="preserve">
          <source>is a simple matter of writing:</source>
          <target state="translated">간단한 글입니다.</target>
        </trans-unit>
        <trans-unit id="60d1efccf0a496e682102a0ca23ae84351984489" translate="yes" xml:space="preserve">
          <source>is a single Han ideograph).</source>
          <target state="translated">단일 한 표의 문자입니다.)</target>
        </trans-unit>
        <trans-unit id="7f0804766ef794c650875e5cd6577f8ca62d3808" translate="yes" xml:space="preserve">
          <source>is a single character, it is used as both the left and right quote; if</source>
          <target state="translated">단일 문자이며 왼쪽 및 오른쪽 따옴표로 사용됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="40a10a304b7ecaf941deb45a42636381388f5a3b" translate="yes" xml:space="preserve">
          <source>is a single user-visible &lt;b&gt;character&lt;/b&gt;, which may in turn be several characters (&lt;b&gt;codepoints&lt;/b&gt;) long. For example, a carriage return plus a line feed is a single grapheme but two characters, while a &amp;ldquo;ȫ&amp;rdquo; is a single grapheme but one, two, or even three characters, depending on &lt;b&gt;normalization&lt;/b&gt;.</source>
          <target state="translated">사용자가 볼 수있는 단일 &lt;b&gt;문자로&lt;/b&gt; , 여러 문자 ( &lt;b&gt;코드 포인트&lt;/b&gt; ) 길이 일 수 있습니다. 예를 들어 캐리지 리턴에 줄 바꿈을 더한 것은 단일 grapheme이지만 두 문자이지만&amp;ldquo;ȫ&amp;rdquo;은 &lt;b&gt;정규화&lt;/b&gt; 에 따라 하나, 두 개 또는 세 개의 문자 입니다.</target>
        </trans-unit>
        <trans-unit id="94a42c80703dda187cbf9d8dc635962500cae627" translate="yes" xml:space="preserve">
          <source>is a small utility that produces a diff between an extracted archive and an unextracted one. (Note that this utility requires the &lt;code&gt;Text::Diff&lt;/code&gt; module to function properly; this module isn't distributed with perl, but is available from the CPAN.)</source>
          <target state="translated">압축 해제 된 아카이브와 압축 해제 된 아카이브 사이에 차이를 생성하는 작은 유틸리티입니다. (이 유틸리티를 사용하려면 &lt;code&gt;Text::Diff&lt;/code&gt; 모듈이 제대로 작동해야합니다.이 모듈은 perl과 함께 배포되지 않지만 CPAN에서 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0317915857aed0b904067e1c9f03cf0d3827f112" translate="yes" xml:space="preserve">
          <source>is a space-separated list of the login names of the members of the group.</source>
          <target state="translated">공백으로 구분 된 그룹 구성원의 로그인 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="94df1f18f1035b39bcc002ff85383c1903d30b19" translate="yes" xml:space="preserve">
          <source>is a special case of</source>
          <target state="translated">특별한 경우입니다</target>
        </trans-unit>
        <trans-unit id="1e4503fa2022262b8888da1041ba3a96a491c954" translate="yes" xml:space="preserve">
          <source>is a strictly positive integer. There are exactly</source>
          <target state="translated">엄격하게 양의 정수입니다. 정확히있다</target>
        </trans-unit>
        <trans-unit id="22b4d0a1706395e3dc8904448c577180ebc49623" translate="yes" xml:space="preserve">
          <source>is a string of three octal digits, matches the character whose coded character set value is</source>
          <target state="translated">3 자리 8 진수 문자열로, 코드화 된 문자 세트 값이 다음과 같은 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9237185425d334578430573eb80cfb1d7070152b" translate="yes" xml:space="preserve">
          <source>is a string value that will be printed if the test fails. This should be some useful information about the test, pertaining to why it failed, and/or a description of the test. For example:</source>
          <target state="translated">테스트에 실패하면 인쇄 될 문자열 값입니다. 이것은 실패한 이유 및 / 또는 테스트에 대한 설명과 관련된 테스트에 대한 유용한 정보 여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d49daf4b07c85bc3e9c9ef9d8fffc8d3e3f192" translate="yes" xml:space="preserve">
          <source>is a string, it is interpreted as a method name - which may (in the usual way) be inherited from another class.</source>
          <target state="translated">는 문자열이며, 메소드 이름으로 해석되며 (일반적인 방법으로) 다른 클래스에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3586b680080fd5641b2ceb505391e64b157c6d54" translate="yes" xml:space="preserve">
          <source>is a string.</source>
          <target state="translated">문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4ed0c07d66bccd475fa1593c086fc3fa98dec2eb" translate="yes" xml:space="preserve">
          <source>is a subclass of Pod::Simple.</source>
          <target state="translated">Pod :: Simple의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0c003c50abcb5c5b0264289df696a4d0a86e8994" translate="yes" xml:space="preserve">
          <source>is a syntax error. The &lt;code&gt;&lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;&lt;/code&gt; module (standard as of v5.8, and from CPAN before then) is able to do this properly.</source>
          <target state="translated">구문 오류입니다. &lt;code&gt;&lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;&lt;/code&gt; 모듈 (v5.8의 표준, 그리고 그 전에 CPAN에서)가 제대로이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2876ee2f7992b444410c106ba7451d0d11add079" translate="yes" xml:space="preserve">
          <source>is a tar-like program, written in pure Perl.</source>
          <target state="translated">순수한 Perl로 작성된 타르와 같은 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="789ff2609c0abca97040f597d9fb835495dbcb55" translate="yes" xml:space="preserve">
          <source>is a type.</source>
          <target state="translated">유형입니다.</target>
        </trans-unit>
        <trans-unit id="ffb330a620d2c555f748134ae75b69f801c184e1" translate="yes" xml:space="preserve">
          <source>is a utility to apply pattern matching to the contents of files in a tar archive.</source>
          <target state="translated">tar 아카이브의 파일 내용에 패턴 일치를 적용하는 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="5a8daa6bdde6d599bc39901138a55ee1a90e8f3c" translate="yes" xml:space="preserve">
          <source>is actually</source>
          <target state="translated">실제로</target>
        </trans-unit>
        <trans-unit id="18ace8663c11e15c7ea7af0769d0b51ea8be5d9e" translate="yes" xml:space="preserve">
          <source>is actually a wrapper to call &lt;code&gt;nmake -f makefile.ce&lt;/code&gt; with appropriate parameters and it accepts extra parameters and forwards them to &lt;code&gt;nmake&lt;/code&gt; command as additional arguments. You should pass target this way.</source>
          <target state="translated">실제로 적절한 매개 변수를 사용하여 &lt;code&gt;nmake -f makefile.ce&lt;/code&gt; 를 호출하는 래퍼 이며 추가 매개 변수를 허용 하고 추가 인수 로 &lt;code&gt;nmake&lt;/code&gt; 명령에 전달합니다 . 이 방법으로 대상을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fbb21c8780d25c2d62c14d525ba4493fed3f009" translate="yes" xml:space="preserve">
          <source>is actually nothing more than a link to the (executable)</source>
          <target state="translated">실제로는 (실행 파일)에 대한 링크 일뿐입니다</target>
        </trans-unit>
        <trans-unit id="5c143cd7b595ecaec566bd11322616c254969521" translate="yes" xml:space="preserve">
          <source>is adopted and becomes the name entry; it must already contain the name string.</source>
          <target state="translated">채택되어 이름 입력이됩니다. 이름 문자열이 이미 포함되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0396ad875d583a36bd13679febb8581f2d969c0" translate="yes" xml:space="preserve">
          <source>is aggregate (eg</source>
          <target state="translated">집계</target>
        </trans-unit>
        <trans-unit id="bb8fcae34915a333a3718d00db6629dab07f6c3d" translate="yes" xml:space="preserve">
          <source>is aliased to a constant in the look</source>
          <target state="translated">모양에서 상수에 별칭이 지정됨</target>
        </trans-unit>
        <trans-unit id="ef7ecbbb686b7c87fdcabe5489a7fa8b747a3327" translate="yes" xml:space="preserve">
          <source>is all lowercase, then the &lt;code&gt;CAPITAL&lt;/code&gt; variant is ignored, otherwise the &lt;code&gt;SMALL&lt;/code&gt; variant is ignored, and both</source>
          <target state="translated">모두 소문자이면 &lt;code&gt;CAPITAL&lt;/code&gt; 변형이 무시되고, 그렇지 않으면 &lt;code&gt;SMALL&lt;/code&gt; 변형이 무시되며 둘 다</target>
        </trans-unit>
        <trans-unit id="33ba30df2d642bce79e623dcea9beec8c9b22ce4" translate="yes" xml:space="preserve">
          <source>is allowed so that &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;$AUTOLOAD&lt;/code&gt; would not break under stricture.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;$AUTOLOAD&lt;/code&gt; 가 엄격 하게 중단되지 않도록 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="46fdc8e9a838eea8febbedf9514625b10566e73a" translate="yes" xml:space="preserve">
          <source>is almost exactly like saying:</source>
          <target state="translated">거의 정확히 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a5481b3e3d73092971b7b67886c83a33452d0d4" translate="yes" xml:space="preserve">
          <source>is already stored as</source>
          <target state="translated">이미로 저장되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e58ea1e0a6e29d9ef790e92565bf38a0d8bec6a6" translate="yes" xml:space="preserve">
          <source>is already stored as native 8 bit, then this is a no-op. Can be used to make sure that the UTF-8 flag is off, e.g. when you want to make sure that the substr() or length() function works with the usually faster byte algorithm.</source>
          <target state="translated">이미 네이티브 8 비트로 저장되어 있다면 이것은 작동하지 않습니다. substr () 또는 length () 함수가 일반적으로 더 빠른 바이트 알고리즘과 작동하는지 확인하려는 경우 UTF-8 플래그가 꺼져 있는지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac0b49408848578e35ac08e94a2eb89181b4b85" translate="yes" xml:space="preserve">
          <source>is also checked if it exists in any of the given search directories. This ensures that e.g. &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; is found.</source>
          <target state="translated">주어진 검색 디렉토리에 존재하는지 확인합니다. 이것은 예를 들어 &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; 가 발견 되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="7a6684732c17ab02c8bf39ac150678f88574a5f9" translate="yes" xml:space="preserve">
          <source>is also run unconditionally. But for</source>
          <target state="translated">무조건 실행됩니다. 이 아니라면</target>
        </trans-unit>
        <trans-unit id="4b33a9f079edd28e14aa0e8744a90b1c55a32145" translate="yes" xml:space="preserve">
          <source>is always interpreted exactly as specified. Otherwise, if the</source>
          <target state="translated">항상 지정된대로 정확하게 해석됩니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="91b6c84b698378cb0b4e7eec5833aff6a0180f6a" translate="yes" xml:space="preserve">
          <source>is always non-negative, so &lt;code&gt;[x,pi]&lt;/code&gt; is really &lt;code&gt;-x&lt;/code&gt; , a negative number) and the above definition states that</source>
          <target state="translated">항상 음수가 아니므로 &lt;code&gt;[x,pi]&lt;/code&gt; 는 실제로 &lt;code&gt;-x&lt;/code&gt; , 음수입니다) 위의 정의는</target>
        </trans-unit>
        <trans-unit id="2da11ce46f8ece756162bb2bd4909c483184c069" translate="yes" xml:space="preserve">
          <source>is always used instead of</source>
          <target state="translated">항상 대신 사용됩니다</target>
        </trans-unit>
        <trans-unit id="da8ff8262fd46aff0c9a7c13fdec487e6709caf8" translate="yes" xml:space="preserve">
          <source>is an &lt;code&gt;enum&lt;/code&gt; . If a reference an array is passed then the first element is used in place of the &lt;code&gt;#ifdef&lt;/code&gt; line, and the second element in place of the &lt;code&gt;#endif&lt;/code&gt; . This allows pre-processor constructions such as</source>
          <target state="translated">입니다 &lt;code&gt;enum&lt;/code&gt; . 참조가 배열을 전달하면 &lt;code&gt;#ifdef&lt;/code&gt; 행 대신 첫 번째 요소가 사용되고 &lt;code&gt;#endif&lt;/code&gt; 대신 두 번째 요소가 사용됩니다 . 이를 통해 다음과 같은 전 처리기 구성이 가능합니다</target>
        </trans-unit>
        <trans-unit id="e407c507e8202b86ad93aac32e3005d18c456577" translate="yes" xml:space="preserve">
          <source>is an abstract entity. It is not bound to any particular integer width, especially not to the C language &lt;code&gt;char&lt;/code&gt; . Unicode is language-neutral and display-neutral: it does not encode the language of the text, and it does not generally define fonts or other graphical layout details. Unicode operates on characters and on text built from those characters.</source>
          <target state="translated">추상 엔티티입니다. 특정 정수 너비, 특히 C 언어 &lt;code&gt;char&lt;/code&gt; 에 바인딩되지 않습니다 . 유니 코드는 언어 중립적이고 표시 중립적입니다. 텍스트의 언어를 인코딩하지 않으며 일반적으로 글꼴이나 기타 그래픽 레이아웃 세부 정보를 정의하지 않습니다. 유니 코드는 문자 및 해당 문자로 작성된 텍스트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5b08b5f167ddd80c250223169363f388a08ecb4a" translate="yes" xml:space="preserve">
          <source>is an alias of Encode::Encoder-&amp;gt;new(). This one is exported on demand.</source>
          <target state="translated">Encode :: Encoder-&amp;gt; new ()의 별칭입니다. 요청시 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="72d90656006280a94921d89ee421ad3991654b7e" translate="yes" xml:space="preserve">
          <source>is an alternate name for a character</source>
          <target state="translated">캐릭터의 대체 이름입니다</target>
        </trans-unit>
        <trans-unit id="25511ab968aa9c3ee55dc28d290edd3e8efa06cf" translate="yes" xml:space="preserve">
          <source>is an appropriate suffix for the platform.</source>
          <target state="translated">플랫폼에 적합한 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="7c8e05cc3c89a308a1e47e52a0132a344b0c0867" translate="yes" xml:space="preserve">
          <source>is an array of all the layers destined for the &lt;code&gt;PerlIO *&lt;/code&gt; , and any arguments passed to them,</source>
          <target state="translated">&lt;code&gt;PerlIO *&lt;/code&gt; 로 향하는 모든 레이어의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="0d1781574c62d77c8d78bcf079651e77516db6c7" translate="yes" xml:space="preserve">
          <source>is an executable image containing the main entry point for Perl, as well as some initialization code. It should be placed in a public directory, and made world executable. In order to run Perl with command line arguments, you should define a foreign command to invoke this image.</source>
          <target state="translated">Perl의 기본 진입 점과 일부 초기화 코드를 포함하는 실행 가능 이미지입니다. 공용 디렉토리에 위치시키고 월드 실행 파일을 만들어야합니다. 명령 행 인수로 Perl을 실행하려면이 이미지를 호출하는 외부 명령을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="da2e040dacc739036641a30943ec92d4d35fb00f" translate="yes" xml:space="preserve">
          <source>is an executable image which contains all of the basic functionality of Perl, but cannot take advantage of Perl XS extensions and has a hard-wired list of library locations for loading pure-Perl modules. It is used extensively to build and test Perl and various extensions, but is not installed.</source>
          <target state="translated">Perl의 모든 기본 기능을 포함하지만 Perl XS 확장을 이용할 수 없으며 순수 Perl 모듈을로드하기위한 라이브러리 위치 목록이있는 실행 가능 이미지입니다. Perl 및 다양한 확장을 빌드하고 테스트하는 데 광범위하게 사용되지만 설치되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="295e5d231e93271cf2e87ff53177a2085d57895e" translate="yes" xml:space="preserve">
          <source>is an interface to &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; - paste in your error message to it, and it'll explain it for you.</source>
          <target state="translated">&lt;a href=&quot;perldiag&quot;&gt;perldiag에&lt;/a&gt; 대한 인터페이스입니다 -오류 메시지에 붙여 넣으면 설명해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="03aebc26e2a8086c7faa0ae9cd0a6e9a5014db91" translate="yes" xml:space="preserve">
          <source>is an older tool, originally intended for the development of XS modules, which comes packaged with the Perl distribution.</source>
          <target state="translated">Perl 배포판과 함께 제공되는 XS 모듈 개발을위한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="c81e7450f22acc425e61712a1eaf2d872d794637" translate="yes" xml:space="preserve">
          <source>is an op that has been optimized away by perl. They're displayed with a sequence-number of '-', because they are not executed (they don't appear in previous example), they're printed here because they reflect the parse.</source>
          <target state="translated">perl에 의해 최적화 된 op입니다. 실행되지 않기 때문에 (이전 예제에서는 표시되지 않음) 시퀀스 번호 '-'로 표시되며 구문 분석을 반영하기 때문에 여기에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="9d5e6dcb345ffb1eb11d5479427e9235760d76bd" translate="yes" xml:space="preserve">
          <source>is an optional preconstructed &lt;code&gt;enterloop&lt;/code&gt; op to use in the loop; if it is null then a suitable op will be constructed automatically.</source>
          <target state="translated">루프에서 사용하기 위한 선택적 사전 &lt;code&gt;enterloop&lt;/code&gt; op입니다. null 인 경우 적절한 op가 자동으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="acf27be8c27b564ea715f62509eb99be46454cb1" translate="yes" xml:space="preserve">
          <source>is another German-speaking magazine for Perl beginners (see &lt;a href=&quot;http://perl-zeitung.at.tf&quot;&gt;http://perl-zeitung.at.tf&lt;/a&gt; ).</source>
          <target state="translated">Perl 초보자를위한 또 다른 독일어권 잡지입니다 ( &lt;a href=&quot;http://perl-zeitung.at.tf&quot;&gt;http://perl-zeitung.at.tf&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="aa85c7e6136b506253070be8f818e9007d9cfdee" translate="yes" xml:space="preserve">
          <source>is any integer.</source>
          <target state="translated">정수입니다.</target>
        </trans-unit>
        <trans-unit id="be3f59631fae1d8b0922b826e41efeee4ec99b4a" translate="yes" xml:space="preserve">
          <source>is any integer. atan2(0, 0) is undefined, and if the complex arguments are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.</source>
          <target state="translated">정수입니다. atan2 (0, 0)은 정의되어 있지 않으며 atan2 ()에 복잡한 인수를 사용하는 경우 z1 ** 2 + z2 ** 2 == 0 인 경우 0으로 나누기가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5783bc43b68f92b02879e3b2c43e9bdd7ca36459" translate="yes" xml:space="preserve">
          <source>is any of the above or an unblessed reference</source>
          <target state="translated">위의 또는 축복되지 않은 참조 중 하나입니다</target>
        </trans-unit>
        <trans-unit id="30e4914477a91ec9b94e791e584cbb65619eeac2" translate="yes" xml:space="preserve">
          <source>is as above. Note that it is possible for calls to &lt;code&gt;pre_&lt;/code&gt; and &lt;code&gt;post_end&lt;/code&gt; to nest, if there is something on the save stack that calls string eval.</source>
          <target state="translated">위와 같습니다. 저장 스택에 문자열 eval을 호출하는 것이 있으면 &lt;code&gt;pre_&lt;/code&gt; 및 &lt;code&gt;post_end&lt;/code&gt; 에 대한 호출이 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36eb847ac03124888eb9b23e1494c3b3077980d8" translate="yes" xml:space="preserve">
          <source>is asking for trouble, since</source>
          <target state="translated">문제를 요구하고 있기 때문에</target>
        </trans-unit>
        <trans-unit id="df9814075a8a9994907bb7e926342f5cd51701bc" translate="yes" xml:space="preserve">
          <source>is associated with the matched string, and is reset by each assignment to pos(). Zero-length matches at the end of the previous match are ignored during &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일치하는 문자열과 연관되며 pos ()에 대한 각 지정으로 재설정됩니다. 이전 일치의 끝에서 길이가 0 인 일치는 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 동안 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6941b5c781a0a521041b5c1dd8c16baced227b53" translate="yes" xml:space="preserve">
          <source>is at &lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc2277.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc2277.html&lt;/a&gt; -- much of it is just things of interest to protocol designers, but it explains some basic concepts, like the distinction between locales and language-tags.</source>
          <target state="translated">에있다 &lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc2277.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc2277.html&lt;/a&gt; -이 프로토콜 설계자들에게 관심의 단지 일이지만 로케일과 언어 태그의 구분과 같은 몇 가지 기본 개념을 설명 훨씬의.</target>
        </trans-unit>
        <trans-unit id="3695a320bebe6f3e9a28f189a22d75b358931b52" translate="yes" xml:space="preserve">
          <source>is at least 3, &lt;code&gt;for&lt;/code&gt; loops will be translated into equivalent while loops with continue blocks; for instance</source>
          <target state="translated">적어도 3 &lt;code&gt;for&lt;/code&gt; 루프가 블록을 계속 동등한 동안 루프로 변환됩니다; 예를 들어</target>
        </trans-unit>
        <trans-unit id="a932359d1eeb1e12e4da8b3878fa5ee714a70634" translate="yes" xml:space="preserve">
          <source>is at least 5, &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations will be translated into &lt;code&gt;BEGIN&lt;/code&gt; blocks containing calls to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;; for instance,</source>
          <target state="translated">5 적어도되어 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 선언이로 번역됩니다 &lt;code&gt;BEGIN&lt;/code&gt; 호출을 포함하는 블록 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ; 예를 들어</target>
        </trans-unit>
        <trans-unit id="c119f702a61cc525d7584c5eac4566db8774adc2" translate="yes" xml:space="preserve">
          <source>is at least 512kbyte (you can check this with: &lt;code&gt;stubedit cc1.exe&lt;/code&gt; ).</source>
          <target state="translated">최소 512kbyte입니다 (stubedit cc1.exe로 확인할 수 &lt;code&gt;stubedit cc1.exe&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f1edba509463471e4477759e68744d683b69a1f8" translate="yes" xml:space="preserve">
          <source>is at least 7, &lt;code&gt;if&lt;/code&gt; statements will be translated into equivalent expressions using &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?:&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; ; for instance</source>
          <target state="translated">적어도 7 &lt;code&gt;if&lt;/code&gt; 문이 사용 동등한 표현으로 변환됩니다 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;?:&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; ; 예를 들어</target>
        </trans-unit>
        <trans-unit id="3ebcba5300e1807510d46aa9590e6c6a47b91326" translate="yes" xml:space="preserve">
          <source>is basically equivalent to</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="f2a370a954d86dc4cfe469a68c83fd68b9353b30" translate="yes" xml:space="preserve">
          <source>is basically equivalent to this:</source>
          <target state="translated">기본적으로 이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="ffc0ffcd2f24cb5977dd7a038df50d731e24c9b9" translate="yes" xml:space="preserve">
          <source>is basically equivalent to:</source>
          <target state="translated">기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efa6ff7d8cd2f270c8d3889d8b02bcd7a2b0379a" translate="yes" xml:space="preserve">
          <source>is be a hashref of types the constant function will return. In ExtUtils::Constant::XS this method is used to returns a hashref keyed IV NV PV SV to show which combination of pointers will be needed in the C argument list generated by C_constant_other_params_definition and C_constant_other_params</source>
          <target state="translated">상수 함수가 반환하는 형식의 해시 참조입니다. ExtUtils :: Constant :: XS에서이 메소드는 해시 참조 키 IV NV PV SV를 반환하여 C_constant_other_params_definition 및 C_constant_other_params에 의해 생성 된 C 인수 목록에 필요한 포인터 조합을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="beed228bb7571f61ef1254143747172d93f725df" translate="yes" xml:space="preserve">
          <source>is because &quot;:&quot; often comes up in paths, like &lt;code&gt;&quot;c:/perl/lib&quot;&lt;/code&gt; .)</source>
          <target state="translated">&quot;:&quot;은 종종 &lt;code&gt;&quot;c:/perl/lib&quot;&lt;/code&gt; 와 같은 경로에 나타나기 때문 입니다.)</target>
        </trans-unit>
        <trans-unit id="b00405322d6959fc080131bfe766ce7448452d15" translate="yes" xml:space="preserve">
          <source>is being compiled you may (depending on the operating system release) see an additional compiler flag being used: &lt;code&gt;-DNO_EFF_ONLY_OK&lt;/code&gt; . This is normal and refers to a feature that is relevant only if you use the &lt;code&gt;filetest&lt;/code&gt; pragma. In older releases of the operating system the feature was broken and the NO_EFF_ONLY_OK instructs Perl not to use the feature.</source>
          <target state="translated">컴파일 중입니다 (운영 체제 릴리스에 따라 다름) &lt;code&gt;-DNO_EFF_ONLY_OK&lt;/code&gt; 사용중인 추가 컴파일러 플래그가 표시 될 수 있습니다. 이것은 정상이며 &lt;code&gt;filetest&lt;/code&gt; pragma 를 사용하는 경우에만 관련된 기능을 나타냅니다 . 이전 버전의 운영 체제에서는 기능이 손상되었으며 NO_EFF_ONLY_OK는 Perl에게 기능을 사용하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="5a7b7ea63bcfd4e7e919847cbe05a532d715b559" translate="yes" xml:space="preserve">
          <source>is being used, false if not.</source>
          <target state="translated">사용 중입니다. 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="46adb9ce162b644638d5f6ea5ff817ff62b057cb" translate="yes" xml:space="preserve">
          <source>is being used, the Perl subroutine is specified as a C string. In this case the subroutine name has been 'hard-wired' into the code.</source>
          <target state="translated">사용중인 경우 Perl 서브 루틴은 C 문자열로 지정됩니다. 이 경우 서브 루틴 이름이 코드에 '고정'되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a77723c3a569791ba0daaaeffeea04df4037001" translate="yes" xml:space="preserve">
          <source>is better than</source>
          <target state="translated">~보다 낫다</target>
        </trans-unit>
        <trans-unit id="e0502ca9d9f39e4be66fbcd074913732a28c22e5" translate="yes" xml:space="preserve">
          <source>is bigger then the group level.</source>
          <target state="translated">그룹 수준보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="343082504b9a0655ece30e29661825f00250e1d3" translate="yes" xml:space="preserve">
          <source>is built using</source>
          <target state="translated">사용하여 구축</target>
        </trans-unit>
        <trans-unit id="0854b2a1714cc6445ab7e4ddf8c2db426ce57837" translate="yes" xml:space="preserve">
          <source>is built,</source>
          <target state="translated">지어진</target>
        </trans-unit>
        <trans-unit id="cf600e83596fbcfa5796fa75f5e47d5ff1240570" translate="yes" xml:space="preserve">
          <source>is built. This is a single executable (without DLL), intended to run on Win32, and it will facilitate remaining build process; all binaries built after it are foreign and should not run locally.</source>
          <target state="translated">내장되어 있습니다. Win32에서 실행되도록 의도 된 단일 실행 파일 (DLL 제외)이며 나머지 빌드 프로세스를 용이하게합니다. 외부 바이너리 이후에 빌드 된 모든 바이너리는 로컬로 실행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5255e100819691e64fa9b4a02162efc6ad2a7971" translate="yes" xml:space="preserve">
          <source>is called</source>
          <target state="translated">라는</target>
        </trans-unit>
        <trans-unit id="0226beba7cd0e825fb4e38da5573e429bdef0536" translate="yes" xml:space="preserve">
          <source>is called like this</source>
          <target state="translated">이렇게 불립니다</target>
        </trans-unit>
        <trans-unit id="01efdfc207c40685a40505df8a8c6de053fd276d" translate="yes" xml:space="preserve">
          <source>is called thus</source>
          <target state="translated">이렇게 불린다</target>
        </trans-unit>
        <trans-unit id="d6879492c8d67c42189022fa109e24255ed0a45a" translate="yes" xml:space="preserve">
          <source>is called, the interpreter's syntax parse tree and symbol tables are cleaned up, and global variables are reset. The second assignment to &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is needed because perl_construct resets it to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">인터프리터 구문 구문 분석 트리 및 기호 테이블이 정리되고 전역 변수가 재설정됩니다. &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 재설정하기 때문에 PL_perl_destruct_level에 대한 두 번째 지정 이 필요합니다. .</target>
        </trans-unit>
        <trans-unit id="0e0ec575b76e364e00644cc1e1456d4682a0ca12" translate="yes" xml:space="preserve">
          <source>is called. If</source>
          <target state="translated">호출됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="ec4d308b2a7ec41f333fa7e39a6baafd8199536a" translate="yes" xml:space="preserve">
          <source>is completed, control reverts back to Perl more or less immediately.</source>
          <target state="translated">완료되면 제어는 즉시 Perl로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9808d99a48eef922543021cb1dd28efe676ff96c" translate="yes" xml:space="preserve">
          <source>is computed to be</source>
          <target state="translated">~로 계산된다</target>
        </trans-unit>
        <trans-unit id="26d5193d0879df7801befc090d32f16dea7f62bc" translate="yes" xml:space="preserve">
          <source>is considerably slower.)</source>
          <target state="translated">상당히 느립니다.)</target>
        </trans-unit>
        <trans-unit id="7457b7ec85de496d14e61652a0482492c7d41031" translate="yes" xml:space="preserve">
          <source>is considered an octal escape (but something like &lt;code&gt;\18&lt;/code&gt; is the same as &lt;code&gt;\0018&lt;/code&gt; ; that is, the octal escape &lt;code&gt;&quot;\001&quot;&lt;/code&gt; followed by a literal digit &lt;code&gt;&quot;8&quot;&lt;/code&gt; ).</source>
          <target state="translated">8 진수 이스케이프로 간주됩니다 (그러나 &lt;code&gt;\18&lt;/code&gt; 과 같은 것은 &lt;code&gt;\0018&lt;/code&gt; 과 동일합니다 . 즉, 8 진수 이스케이프 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 뒤에 문자 숫자 &lt;code&gt;&quot;8&quot;&lt;/code&gt; 이옵니다. .</target>
        </trans-unit>
        <trans-unit id="0c6c59d53731eb4d62ce728fe5d323178a21c69a" translate="yes" xml:space="preserve">
          <source>is consumed by this function and becomes part of the returned op tree.</source>
          <target state="translated">이 함수에 의해 소비되며 반환 된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="dc258a7b37a09c5a513defc7421c502e2dfc41b4" translate="yes" xml:space="preserve">
          <source>is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the &lt;code&gt;refcounted_he&lt;/code&gt; . Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="translated">이 함수에 의해 복사되므로 참조에 대한 소유권을 갖지 않으며 나중에 스칼라에 대한 변경 사항은 &lt;code&gt;refcounted_he&lt;/code&gt; 에 표시된 값에 반영되지 않습니다 . 복잡한 유형의 스칼라는 참조 무결성으로 저장되지 않지만 문자열로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fbf2c8c541938c6077a677f840135912410a3a25" translate="yes" xml:space="preserve">
          <source>is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the cop hints hash. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="translated">이 함수에 의해 복사되므로 참조에 대한 소유권을 갖지 않으며 나중에 스칼라에 대한 변경 사항은 경찰 힌트 해시에 표시되는 값에 반영되지 않습니다. 복잡한 유형의 스칼라는 참조 무결성으로 저장되지 않지만 문자열로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="30e3ef0b8ff559774ec5ed938edd84b1f238cb9b" translate="yes" xml:space="preserve">
          <source>is copied to a new hash, which has the &lt;code&gt;%^H&lt;/code&gt; -specific magic added to it. A pointer to the new hash is returned.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; 관련 매직이 추가 된 새 해시에 복사됩니다 . 새로운 해시에 대한 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="747f6e21ce3daf93f93dd4472373d8de083a21bc" translate="yes" xml:space="preserve">
          <source>is created using &lt;code&gt;TMP&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt; environment variable, via &lt;code&gt;tempnam&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;tempnam&lt;/code&gt; 을 통해 &lt;code&gt;TMP&lt;/code&gt; 또는 &lt;code&gt;TEMP&lt;/code&gt; 환경 변수를 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a61d9fe71ed76708341c4ca0d849865f0cdc3b4" translate="yes" xml:space="preserve">
          <source>is currently unused and ignored. In future it may be used to pass in information used to change the C indentation style used.] The best way to maintain consistency is to pass in a hash reference and let this function update it.</source>
          <target state="translated">현재 사용되지 않고 무시됩니다. 앞으로는 사용 된 C 들여 쓰기 스타일을 변경하는 데 사용되는 정보를 전달하는 데 사용될 수 있습니다.] 일관성을 유지하는 가장 좋은 방법은 해시 참조를 전달하고이 함수가이를 업데이트하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9813a16c1f4cea91b9c2c265d663c4bd1846f7de" translate="yes" xml:space="preserve">
          <source>is currently unused and must be zero.</source>
          <target state="translated">현재 사용되지 않으며 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="99e47089baf7bf5a97290b50bc31baafb3fecfdf" translate="yes" xml:space="preserve">
          <source>is currently unused and should always be 1.</source>
          <target state="translated">현재 사용되지 않으며 항상 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e342eb67743e357f6c505cac08784c21c4ae08f3" translate="yes" xml:space="preserve">
          <source>is dead simple: for given cross-architecture places in @INC a path where perl modules are, and right</source>
          <target state="translated">@INC의 주어진 교차 아키텍처 장소에 대해 perl 모듈이있는 경로와 올바른</target>
        </trans-unit>
        <trans-unit id="c705d4c7e0b74c44541c11aa71e1a8a9918a05c8" translate="yes" xml:space="preserve">
          <source>is defined as a fixed string that can appear at any point in a range of positions relative to the start of the match. For example,</source>
          <target state="translated">는 일치하는 시작과 관련하여 어떤 위치에서나 나타날 수있는 고정 문자열로 정의됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ecb2ca25d83a1d9ea96055686343475429c34ffd" translate="yes" xml:space="preserve">
          <source>is defined as being a substring that must appear for the pattern to match. An</source>
          <target state="translated">패턴이 일치하기 위해 나타나야하는 하위 문자열로 정의됩니다. 안</target>
        </trans-unit>
        <trans-unit id="1da1038b5104f0f95e494512f9adf3b8d6beaf10" translate="yes" xml:space="preserve">
          <source>is defined, such as when running under GNV bash.</source>
          <target state="translated">GNV bash에서 실행될 때와 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="deb74afad5c0f4e11684626863d8cd55cb9bdeee" translate="yes" xml:space="preserve">
          <source>is defined, then it is used to avoid &lt;code&gt;memEQ&lt;/code&gt; for short names, or to generate a comment to highlight the position of the character in the &lt;code&gt;switch&lt;/code&gt; statement.</source>
          <target state="translated">이 정의 된 경우 짧은 이름의 &lt;code&gt;memEQ&lt;/code&gt; 를 피 하거나 &lt;code&gt;switch&lt;/code&gt; 문 에서 문자의 위치를 ​​강조 표시하는 주석을 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="991181f3df7a8cdf4f7168cba333bb5158ffb3d9" translate="yes" xml:space="preserve">
          <source>is delimited by bracketing quotes, the</source>
          <target state="translated">괄호로 묶고</target>
        </trans-unit>
        <trans-unit id="0aab59497e397eb628c4ae4e65530bcc8256b5ef" translate="yes" xml:space="preserve">
          <source>is designed to test whether a particular code snippet has been compiled into an optree containing specified numbers of particular op types. This is good for testing whether optimisations which alter ops, such as converting an &lt;code&gt;aelem&lt;/code&gt; op into an &lt;code&gt;aelemfast&lt;/code&gt; op, are really doing that.</source>
          <target state="translated">특정 코드 스 니펫이 특정 수의 특정 op 유형을 포함하는 optree로 컴파일되었는지 테스트하도록 설계되었습니다. 이것은 &lt;code&gt;aelem&lt;/code&gt; op를 aelemfast op로 변환하는 것과 같이 op를 변경하는 최적화 가 실제로 그렇게 하는지 테스트 하는 데 &lt;code&gt;aelemfast&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="416051867536031c9c339fabd2716eb40c91334e" translate="yes" xml:space="preserve">
          <source>is directed to &lt;b&gt;STDOUT&lt;/b&gt;, unlike the pragma.</source>
          <target state="translated">pragma와 달리 &lt;b&gt;STDOUT으로&lt;/b&gt; 보내 집니다.</target>
        </trans-unit>
        <trans-unit id="9553c90ac38c53c0080494be25343dc34ae22d57" translate="yes" xml:space="preserve">
          <source>is effectively</source>
          <target state="translated">효과적으로</target>
        </trans-unit>
        <trans-unit id="73b6c5e895538dd2917ae4f7b4e4274c97cfa6db" translate="yes" xml:space="preserve">
          <source>is empty if</source>
          <target state="translated">만약 비어 있다면</target>
        </trans-unit>
        <trans-unit id="f685ee609385b240742c6531d09c2e99375d25df" translate="yes" xml:space="preserve">
          <source>is empty). Note that this describes the contents of</source>
          <target state="translated">비었다). 이것은 내용을 설명합니다</target>
        </trans-unit>
        <trans-unit id="c70ff529c1678e6d6f8a86a860dfe6b90b65a6d1" translate="yes" xml:space="preserve">
          <source>is empty, or is exactly one code with at least four hexdigits which can be used as an alternative case folding when the calling program cannot cope with the fold being a sequence of multiple code points. If</source>
          <target state="translated">비어 있거나, 또는 호출 프로그램이 여러 코드 포인트의 시퀀스 인 접기를 처리 할 수 ​​없을 때 대체 케이스 접기로 사용할 수있는 16 진수가 4 자리 이상인 정확히 하나의 코드입니다. 만약</target>
        </trans-unit>
        <trans-unit id="b82f1aa4dc1e11bb0291658e76619710db88ea38" translate="yes" xml:space="preserve">
          <source>is empty, the</source>
          <target state="translated">비어있다</target>
        </trans-unit>
        <trans-unit id="0e207ae2f0db5023f32cc9020e3ddf2c71a2b3cc" translate="yes" xml:space="preserve">
          <source>is equal to the C variable &lt;code&gt;name&lt;/code&gt; . If</source>
          <target state="translated">C 변수 &lt;code&gt;name&lt;/code&gt; 과 같습니다 . 만약</target>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="bc2b09c98193f0e5662cbf8b53fad07d5e736c01" translate="yes" xml:space="preserve">
          <source>is equivalent to the following Perl-like pseudo code:</source>
          <target state="translated">다음 Perl과 유사한 의사 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="32a86d7541273833cc59233715d55c78fd068962" translate="yes" xml:space="preserve">
          <source>is equivalent to the more verbose</source>
          <target state="translated">더 장황한 것과 같습니다</target>
        </trans-unit>
        <trans-unit id="058019ba79ba28b16d81510fd9c7be6426e9a31b" translate="yes" xml:space="preserve">
          <source>is equivalent to the original path for all systems but VMS.</source>
          <target state="translated">VMS를 제외한 모든 시스템의 원래 경로와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a799343991654a6923d4110f493e02c300d895c" translate="yes" xml:space="preserve">
          <source>is equivalent to this Perl code:</source>
          <target state="translated">이 Perl 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c01ad008c1dcafb297a57e15952c3a221508e1b" translate="yes" xml:space="preserve">
          <source>is evaluated in &lt;b&gt;list context&lt;/b&gt; and interpolated into the list value.</source>
          <target state="translated">&lt;b&gt;목록 컨텍스트&lt;/b&gt; 에서 평가되고 목록 값으로 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="304cd7bde8c8a066e9ddc11f5d17d8c69ab28cfc" translate="yes" xml:space="preserve">
          <source>is exactly equivalent to</source>
          <target state="translated">정확히</target>
        </trans-unit>
        <trans-unit id="5868f5f052497727f3a75d03017159c24abf653a" translate="yes" xml:space="preserve">
          <source>is explicitly used, false if an external</source>
          <target state="translated">명시 적으로 사용되며 외부인 경우 false</target>
        </trans-unit>
        <trans-unit id="9f231ca4498f5e3002502cfac3a6b5698c2f1ac4" translate="yes" xml:space="preserve">
          <source>is extracted and decoded for</source>
          <target state="translated">추출 및 디코딩</target>
        </trans-unit>
        <trans-unit id="c507073afeb7ab580d7916aa3aef230ed3bfced7" translate="yes" xml:space="preserve">
          <source>is false then &lt;code&gt;decode&lt;/code&gt; should make a &quot;best effort&quot; to convert the string - for example by using Unicode's &quot;\x{FFFD}&quot; as a replacement character.</source>
          <target state="translated">false 인 경우 &lt;code&gt;decode&lt;/code&gt; 은 문자열을 변환하기 위해 &quot;최선의 노력&quot;을해야합니다 (예 : 유니 코드의 &quot;\ x {FFFD}&quot;를 대체 문자로 사용).</target>
        </trans-unit>
        <trans-unit id="66ef51ab90721c11c96b9fd1112297ae5c3bc612" translate="yes" xml:space="preserve">
          <source>is false then &lt;code&gt;encode&lt;/code&gt; MUST make a &quot;best effort&quot; to convert the string - for example, by using a replacement character.</source>
          <target state="translated">false이면 &lt;code&gt;encode&lt;/code&gt; 는 문자열을 변환하기 위해 &quot;최선의 노력&quot;을해야합니다 (예 : 대체 문자 사용).</target>
        </trans-unit>
        <trans-unit id="85c8ac4c204bffb12a6b2e5264aea8475c7fa00f" translate="yes" xml:space="preserve">
          <source>is false unless the old $x happened to have the value &lt;code&gt;123&lt;/code&gt; .</source>
          <target state="translated">이전 $ x가 &lt;code&gt;123&lt;/code&gt; 값을 갖지 않는 한 false 입니다.</target>
        </trans-unit>
        <trans-unit id="59641b07163bb2532f0e133b6081758f8b622aff" translate="yes" xml:space="preserve">
          <source>is find. The returned object is what does the actual encoding or decoding.</source>
          <target state="translated">찾을 수 있습니다. 반환 된 객체는 실제 인코딩 또는 디코딩이 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="19134d8f14cf9efb45a39a603eab01b599496a36" translate="yes" xml:space="preserve">
          <source>is first looked up in the list of standard Unicode character names.</source>
          <target state="translated">표준 유니 코드 문자 이름 목록에서 먼저 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="28844e6770c7541b46bf5769a48ab89a32b3a220" translate="yes" xml:space="preserve">
          <source>is formatted as:</source>
          <target state="translated">형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5bf27e9e737c2b17d8bda56643008ebf40f5d55" translate="yes" xml:space="preserve">
          <source>is found, &lt;code&gt;Z_OK&lt;/code&gt; is returned and &lt;code&gt;$buffer&lt;/code&gt; will be have all data up to the flush point removed. This can then be passed to the &lt;code&gt;deflate&lt;/code&gt; method.</source>
          <target state="translated">이 발견되면 &lt;code&gt;Z_OK&lt;/code&gt; 가 반환되고 &lt;code&gt;$buffer&lt;/code&gt; 는 플러시 포인트까지 모든 데이터를 제거합니다. 그런 다음 &lt;code&gt;deflate&lt;/code&gt; 메소드 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b39d821e927a0c9d0363f2727cc57c75893ba1d" translate="yes" xml:space="preserve">
          <source>is found, &lt;code&gt;Z_OK&lt;/code&gt; is returned and &lt;code&gt;$input&lt;/code&gt; will be have all data up to the flush point removed. This data can then be passed to the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method to be uncompressed.</source>
          <target state="translated">이 발견되면 &lt;code&gt;Z_OK&lt;/code&gt; 가 반환되고 &lt;code&gt;$input&lt;/code&gt; 에는 플러시 포인트까지의 모든 데이터가 제거됩니다. 그런 다음이 데이터를 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 메소드로 전달하여 압축을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad43a18a515527a341bfc4d3a6681a6fd357b43" translate="yes" xml:space="preserve">
          <source>is found, Perl will investigate its first line etc. The only hardwired limit on the recursion depth is implicit: there is a limit 4 on the number of additional arguments inserted before the actual arguments given to system(). In particular, if no additional arguments are specified on the &quot;magic&quot; first lines, then the limit on the depth is 4.</source>
          <target state="translated">Perl은 첫 번째 행 등을 조사합니다. 재귀 깊이에 대한 고정 배선 제한은 암시 적입니다. system ()에 제공된 실제 인수 앞에 삽입 된 추가 인수의 수에는 제한 4가 있습니다. 특히, &quot;매직&quot;첫 번째 줄에 추가 인수가 지정되지 않은 경우 깊이 제한은 4입니다.</target>
        </trans-unit>
        <trans-unit id="1f1b1a9afa41f162ae23bb3a01d9f047e652e6e1" translate="yes" xml:space="preserve">
          <source>is four characters, the first two are used as the left quote and the second two as the right quote.</source>
          <target state="translated">는 4 개의 문자이며 처음 두 개는 왼쪽 따옴표로, 두 번째는 오른쪽 따옴표로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9a16a4dd16d307d04182c223f1289cfcd07c67" translate="yes" xml:space="preserve">
          <source>is generated automatically from</source>
          <target state="translated">에서 자동으로 생성됩니다</target>
        </trans-unit>
        <trans-unit id="bd2a87dbabce881cfa0ac191619b95b7f30ff0e2" translate="yes" xml:space="preserve">
          <source>is generated by &lt;code&gt;ExtUtils::Miniperl&lt;/code&gt; from</source>
          <target state="translated">에 의해 생성 &lt;code&gt;ExtUtils::Miniperl&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="97061dcc49398ed7873f16a75d7351365d5bd949" translate="yes" xml:space="preserve">
          <source>is greater than 10, the digit for 11 will be 'a', and so on. If</source>
          <target state="translated">10보다 크면 11의 숫자는 'a'가됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="c6cff08bd14f0967385302adf53b41c3a3d439b0" translate="yes" xml:space="preserve">
          <source>is greater than 36, the digit for 37 will be 'A', and so on until 62. Values greater than 62 are not currently supported. The default is 36.</source>
          <target state="translated">36보다 크면 37의 숫자는 'A'가되고 62까지 계속됩니다. 62보다 큰 값은 현재 지원되지 않습니다. 기본값은 36입니다.</target>
        </trans-unit>
        <trans-unit id="ffe49080789a404d2d720870ea3296af02ff6123" translate="yes" xml:space="preserve">
          <source>is greater than zero then it gives the number of arguments passed to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, otherwise it will be 1 if for example &lt;code&gt;PerlIO_open&lt;/code&gt; was called. In simple cases SvPV_nolen(*args) is the pathname to open.</source>
          <target state="translated">0보다 크면 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에 전달 된 인수의 수를 제공합니다 . 그렇지 않으면 &lt;code&gt;PerlIO_open&lt;/code&gt; 과 같이 호출 된 경우 1이됩니다 . 간단한 경우 SvPV_nolen (* args)는 열 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b7ead90991363b6d52dd34fbbeb13fb170062d0a" translate="yes" xml:space="preserve">
          <source>is held as bytes (both these states are 'consistent'). Main reason for this routine is to allow Perl's test suite to check that operations have left strings in a consistent state. You most probably want to use utf8::is_utf8() instead.</source>
          <target state="translated">바이트로 유지됩니다 (두 상태 모두 '일관 적'임). 이 루틴의 주된 이유는 Perl의 테스트 스위트가 조작이 문자열을 일관된 상태로 두 었는지 점검 할 수 있도록하기위한 것입니다. utf8 :: is_utf8 ()을 대신 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6524de4ede507c0f25877cf9853d0bde2075a2e" translate="yes" xml:space="preserve">
          <source>is hex, as in &lt;code&gt;E&amp;lt;0x201E&amp;gt;&lt;/code&gt; . A leading &quot;0&quot; means that</source>
          <target state="translated">&lt;code&gt;E&amp;lt;0x201E&amp;gt;&lt;/code&gt; 에서와 같이 16 진수 입니다. 선행 &quot;0&quot;은</target>
        </trans-unit>
        <trans-unit id="ee2f8650f57b54260f06fc232faca4874614507a" translate="yes" xml:space="preserve">
          <source>is identical to</source>
          <target state="translated">~와 동일하다</target>
        </trans-unit>
        <trans-unit id="22ee8461739b14ea02f3b9c0b9c9eb44d2a1409e" translate="yes" xml:space="preserve">
          <source>is implemented as a Perl module. The structure of the module can take one of two broadly similar formats. To distinguish between them, the first will be referred to as</source>
          <target state="translated">Perl 모듈로 구현됩니다. 모듈의 구조는 크게 유사한 두 가지 형식 중 하나를 취할 수 있습니다. 그것들을 구별하기 위해 첫 번째는</target>
        </trans-unit>
        <trans-unit id="b176c796440a7e55c89af58d299f53bc936cfeff" translate="yes" xml:space="preserve">
          <source>is implemented using the Perl module &lt;a href=&quot;digest/sha&quot;&gt;Digest::SHA&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest::SHA::PurePerl&lt;/a&gt;.</source>
          <target state="translated">Perl 모듈 &lt;a href=&quot;digest/sha&quot;&gt;Digest :: SHA&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest :: SHA :: PurePerl을&lt;/a&gt; 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1e051efb59784127a6ed01a9c76c742681c671e" translate="yes" xml:space="preserve">
          <source>is implemented, but bugs remain in &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//i&lt;/a&gt;&lt;/code&gt; with them, mostly fixed by 5.14, and essentially entirely by 5.18.</source>
          <target state="translated">구현되었지만 버그는 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//i&lt;/a&gt;&lt;/code&gt; 남아 있으며 주로 5.14에 의해 수정되며 본질적으로 5.18에 의해 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="608c8bcda4c8d3f4fd99afdca20fc7d478aadc35" translate="yes" xml:space="preserve">
          <source>is implied if neither a template nor a directory are supplied.</source>
          <target state="translated">템플리트 나 디렉토리가 제공되지 않으면 내재됩니다.</target>
        </trans-unit>
        <trans-unit id="029ccc41ee21c1341d1578997e21239d4d69dd57" translate="yes" xml:space="preserve">
          <source>is in a consistent state regarding UTF-8. Will return true if it is well-formed UTF-8 and has the UTF-8 flag on &lt;b&gt;or&lt;/b&gt; if</source>
          <target state="translated">UTF-8과 관련하여 일관된 상태입니다. 잘 구성된 UTF-8이고 UTF-8 플래그가 켜져 &lt;b&gt;있거나&lt;/b&gt; 아니면</target>
        </trans-unit>
        <trans-unit id="6da1d29c95b983c26f31a22e5a9c05d88563966c" translate="yes" xml:space="preserve">
          <source>is in effect:</source>
          <target state="translated">효력이있다 :</target>
        </trans-unit>
        <trans-unit id="fca20ec285ed27cbaefdb07ee844b5ac0358c904" translate="yes" xml:space="preserve">
          <source>is in fact</source>
          <target state="translated">실제로</target>
        </trans-unit>
        <trans-unit id="e384cbeffbac9cd924ef4dc73d622e1a5322584a" translate="yes" xml:space="preserve">
          <source>is in the customary packed binary format used for Perl strings.</source>
          <target state="translated">Perl 문자열에 사용되는 일반적인 압축 이진 형식입니다.</target>
        </trans-unit>
        <trans-unit id="cac7c1be39dca233019b8ffda50806e1b4a70009" translate="yes" xml:space="preserve">
          <source>is included. Other possible values include</source>
          <target state="translated">포함되어 있습니다. 다른 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5138f4117c88d0c0de8e325485d990c34725fde1" translate="yes" xml:space="preserve">
          <source>is intended to rhyme with</source>
          <target state="translated">운율</target>
        </trans-unit>
        <trans-unit id="18bc197f96cca45c02a3aaa837ac2696dd0f97ab" translate="yes" xml:space="preserve">
          <source>is interpolated in the usual way. Something like &lt;code&gt;&quot;\Q\\E&quot;&lt;/code&gt; has no &lt;code&gt;\E&lt;/code&gt; inside. Instead, it has &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\\&lt;/code&gt; , and &lt;code&gt;E&lt;/code&gt; , so the result is the same as for &lt;code&gt;&quot;\\\\E&quot;&lt;/code&gt; . As a general rule, backslashes between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; may lead to counterintuitive results. So, &lt;code&gt;&quot;\Q\t\E&quot;&lt;/code&gt; is converted to &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta(&quot;\t&quot;)&lt;/a&gt;&lt;/code&gt;, which is the same as &lt;code&gt;&quot;\\\t&quot;&lt;/code&gt; (since TAB is not alphanumeric). Note also that:</source>
          <target state="translated">일반적인 방식으로 보간됩니다. &lt;code&gt;&quot;\Q\\E&quot;&lt;/code&gt; 와 같은 것은 내부에 &lt;code&gt;\E&lt;/code&gt; 가 없습니다 . 대신 &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\\&lt;/code&gt; 및 &lt;code&gt;E&lt;/code&gt; 가 있으므로 결과는 &lt;code&gt;&quot;\\\\E&quot;&lt;/code&gt; 와 동일 합니다. 일반적으로 &lt;code&gt;\Q&lt;/code&gt; 와 &lt;code&gt;\E&lt;/code&gt; 사이의 백 슬래시는 직관적이지 않은 결과를 초래할 수 있습니다. 따라서 &lt;code&gt;&quot;\Q\t\E&quot;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta(&quot;\t&quot;)&lt;/a&gt;&lt;/code&gt; 로 변환되며 이는 &lt;code&gt;&quot;\\\t&quot;&lt;/code&gt; 와 같습니다 (TAB가 영숫자가 아니므로). 또한 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="77a8d3d60ed8be450c9ffcc1d60689ed94aa9704" translate="yes" xml:space="preserve">
          <source>is interpolated the same way as</source>
          <target state="translated">같은 방법으로 보간됩니다</target>
        </trans-unit>
        <trans-unit id="6645e23e420237e998b6d2cedfb1dc6622827f9f" translate="yes" xml:space="preserve">
          <source>is interpreted as being in decimal, as in &lt;code&gt;E&amp;lt;181&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;E&amp;lt;181&amp;gt;&lt;/code&gt; 과 같이 10 진수로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="22c75022beb252e282558c71e996793c6d980a55" translate="yes" xml:space="preserve">
          <source>is invalid as</source>
          <target state="translated">로 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e8ffd60ca890c4ec9f93077049a6c161e0914d97" translate="yes" xml:space="preserve">
          <source>is invoked to create right</source>
          <target state="translated">바로 만들기 위해 호출됩니다</target>
        </trans-unit>
        <trans-unit id="29af8a8fa79689fd5e71210eb1c3ba564cdffa85" translate="yes" xml:space="preserve">
          <source>is invoked, which in turn steps in</source>
          <target state="translated">단계적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cfee822da79f87e0f9bf29a70b1f7e186da8af5d" translate="yes" xml:space="preserve">
          <source>is just a funny way to write</source>
          <target state="translated">재미있는 재미있는 방법입니다</target>
        </trans-unit>
        <trans-unit id="b044360009bd48fa7435baabf472b05cb3e2087e" translate="yes" xml:space="preserve">
          <source>is just an alias for</source>
          <target state="translated">에 대한 별칭입니다</target>
        </trans-unit>
        <trans-unit id="a1bbe39e9abe31cecf6dbbe9e345b36bee6a8e2e" translate="yes" xml:space="preserve">
          <source>is just one code point, then</source>
          <target state="translated">하나의 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="fb4747d98d1d42af6b094401a12cd8de28b86f5d" translate="yes" xml:space="preserve">
          <source>is kept open without a name while the output is redirected to a new file with the original</source>
          <target state="translated">출력이 원본이없는 새 파일로 리디렉션되는 동안 이름없이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2943b59aed5e708de53a3b73d4947169b635ec4" translate="yes" xml:space="preserve">
          <source>is largely like</source>
          <target state="translated">대체로 같다</target>
        </trans-unit>
        <trans-unit id="9188ab140ad2e7ca45c0eacb2137ae4084f8e251" translate="yes" xml:space="preserve">
          <source>is latitude (northward positive, southward negative) and</source>
          <target state="translated">위도 (북쪽으로 긍정적, 남쪽으로 부정)</target>
        </trans-unit>
        <trans-unit id="9f6334181abd08a5e5386bd949a39504d56e205a" translate="yes" xml:space="preserve">
          <source>is like</source>
          <target state="translated">처럼</target>
        </trans-unit>
        <trans-unit id="48ed010598288313ecc15c5c568a57c8a8397db8" translate="yes" xml:space="preserve">
          <source>is like &lt;code&gt;&quot;s&quot;&lt;/code&gt; in that all the map array elements are scalars, but here they are restricted to all being integers, and some have to be adjusted (hence the name &lt;code&gt;&quot;a&quot;&lt;/code&gt; ) to get the correct result. For example, in:</source>
          <target state="translated">는 모든지도 배열 요소가 스칼라 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 에서 &quot;s&quot; 와 비슷 하지만 여기서는 모든 정수로 제한되며 일부는 올바른 결과를 얻기 위해 조정되어야합니다 (따라서 이름 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f732dd47aa6f4ff2876b84adc0d6e54cc3222968" translate="yes" xml:space="preserve">
          <source>is like doing this:</source>
          <target state="translated">이 작업을 수행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59b5273750d4d23e41112610a3e421f40227d715" translate="yes" xml:space="preserve">
          <source>is linked into the pad, and its &lt;code&gt;CvOUTSIDE&lt;/code&gt; link to the outer scope is weakened to avoid a reference loop.</source>
          <target state="translated">는 패드에 연결되고 외부 루프에 대한 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 링크는 약화되어 참조 루프를 피합니다.</target>
        </trans-unit>
        <trans-unit id="f78b503f16d85a9efd1beacafcdfdaf3f270807f" translate="yes" xml:space="preserve">
          <source>is located in</source>
          <target state="translated">에 위치하고 있습니다</target>
        </trans-unit>
        <trans-unit id="fa07b54f5a9fd2750d4f4d0986e9e9fdb812fef7" translate="yes" xml:space="preserve">
          <source>is longitude (eastward positive, westward negative).</source>
          <target state="translated">경도 (동쪽 긍정적, 서쪽 부정)입니다.</target>
        </trans-unit>
        <trans-unit id="8e42e7821439f1d14a05038b954f5c84e7ed25c3" translate="yes" xml:space="preserve">
          <source>is looked up as a letter in script</source>
          <target state="translated">스크립트에서 문자로 조회</target>
        </trans-unit>
        <trans-unit id="cb4ca3c72721f7c4253dd2277262b9ddc4ed46e6" translate="yes" xml:space="preserve">
          <source>is looked up as a letter in the given scripts (in the specified order). Customized aliases can override these, and are explained in &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES&lt;/a&gt;.</source>
          <target state="translated">지정된 스크립트에서 지정된 순서대로 문자로 조회됩니다. 사용자 정의 별명은이를 대체 할 수 있으며 &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a9de9318bd902cd3babdefa5b0b92ad233e720" translate="yes" xml:space="preserve">
          <source>is made active via fork()/exec(), which may lead to some resources taken from the system (even if we do not count extra work needed for fork()ing).</source>
          <target state="translated">fork () / exec ()를 통해 활성화되어 시스템에서 가져온 일부 리소스로 이어질 수 있습니다 (fork ()에 필요한 추가 작업을 계산하지 않더라도).</target>
        </trans-unit>
        <trans-unit id="239548bf60aa08580ca32f625ff4309e8f81b542" translate="yes" xml:space="preserve">
          <source>is made equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="70f7caafd49cafb298f6bed5bd8a09a8a7b6e1f0" translate="yes" xml:space="preserve">
          <source>is marked internally as encoded in UTF-8. Functionally the same as Encode::is_utf8().</source>
          <target state="translated">내부적으로 UTF-8로 인코딩 된 것으로 표시됩니다. 기능적으로 Encode :: is_utf8 ()과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cafeb6d4161aa2a759fa9cb04517c81a82e79352" translate="yes" xml:space="preserve">
          <source>is merely a shortcut for</source>
          <target state="translated">단지 바로 가기입니다</target>
        </trans-unit>
        <trans-unit id="cc1707c0c187b01916ee3df94ec53bf20d5e805b" translate="yes" xml:space="preserve">
          <source>is mirrored in bidirectional text</source>
          <target state="translated">양방향 텍스트로 미러링됩니다</target>
        </trans-unit>
        <trans-unit id="2ed56127ce2edce69beb7e4554959d32a6773da2" translate="yes" xml:space="preserve">
          <source>is more appropriate. The process of converting the complex number into a string that can be displayed is known as</source>
          <target state="translated">더 적절합니다. 복소수를 표시 할 수있는 문자열로 변환하는 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df959619050e76c8841c515d15b08c043ee77963" translate="yes" xml:space="preserve">
          <source>is more sophisticated, and uses the &lt;a href=&quot;test/harness&quot;&gt;Test::Harness&lt;/a&gt; module, thus using this test target supposes that perl mostly works. The main advantage for our purposes is that it prints a detailed summary of failed tests at the end. Also, unlike</source>
          <target state="translated">보다 정교하고 &lt;a href=&quot;test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 모듈을 사용하므로이 테스트 대상을 사용하면 perl이 대부분 작동한다고 가정합니다. 우리의 목적에 대한 주요 장점은 마지막에 실패한 테스트에 대한 자세한 요약을 인쇄한다는 것입니다. 또한 달리</target>
        </trans-unit>
        <trans-unit id="0858c3a91f7c4ca07fe54237280827493469443b" translate="yes" xml:space="preserve">
          <source>is more than just a C header. It's also a Perl script that can check your source code. It will suggest hints and portability notes, and can even make suggestions on how to change your code. You can run it like any other Perl program:</source>
          <target state="translated">C 헤더 이상입니다. 소스 코드를 확인할 수있는 Perl 스크립트이기도합니다. 힌트와 이식성 노트를 제안하고 코드 변경 방법에 대한 제안도 할 수 있습니다. 다른 Perl 프로그램처럼 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73b99ca814cd9f3692bee8c058c4c6db3425b4f7" translate="yes" xml:space="preserve">
          <source>is much more memory-efficient than either</source>
          <target state="translated">어느 것보다 훨씬 메모리 효율적입니다</target>
        </trans-unit>
        <trans-unit id="f364fbd6a7a0be0bd077f092be562b8bbd3797f6" translate="yes" xml:space="preserve">
          <source>is needed to get through the test suite.</source>
          <target state="translated">테스트 스위트를 통과하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a14b970b88d3b4ba0134624be5559b774fcc9e5" translate="yes" xml:space="preserve">
          <source>is needed.</source>
          <target state="translated">필요합니다.</target>
        </trans-unit>
        <trans-unit id="9d94e3f31359c70b6973e6ab915dd0761fd3dfe4" translate="yes" xml:space="preserve">
          <source>is never checked (so if it does not exists when its content is needed, the user of %hash may be confused).</source>
          <target state="translated">확인되지 않습니다 (따라서 내용이 필요할 때 존재하지 않으면 % hash 사용자가 혼동 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="d1c931dd86f631640926b9290e424da1679547cd" translate="yes" xml:space="preserve">
          <source>is non-&lt;code&gt;NULL&lt;/code&gt; , it will be set to a pointer to the frame for the sub call itself.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우, 하위 호출 자체의 프레임에 대한 포인터로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5e581b526692a62a2e9311d15e92a68ee14d4cf1" translate="yes" xml:space="preserve">
          <source>is non-null, it supplies the name of a label to attach to the state op; this function takes ownership of the memory pointed at by</source>
          <target state="translated">널이 아닌 경우 상태 op에 첨부 할 레이블의 이름을 제공합니다. 이 함수는</target>
        </trans-unit>
        <trans-unit id="10e7f3d3e39943812d42aa325a0624806d73fc1d" translate="yes" xml:space="preserve">
          <source>is non-null, it's a lexical reference to a package variable, and this identifies the package. The following flags can be OR'ed together:</source>
          <target state="translated">null이 아닌 패키지 변수에 대한 어휘 참조이며 패키지를 식별합니다. 다음 플래그는 함께 OR 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de6591eb61d37cb2280e26d54c5fd16117e3fea" translate="yes" xml:space="preserve">
          <source>is non-null, the name is for a typed lexical, and this identifies the type. If</source>
          <target state="translated">널이 아닌 경우, 이름은 입력 된 어휘에 대한 것이며, 이는 유형을 식별합니다. 만약</target>
        </trans-unit>
        <trans-unit id="57de99dddfaf807ff4ccc5d2881dd47c080db528" translate="yes" xml:space="preserve">
          <source>is non-zero then</source>
          <target state="translated">0이 아닌</target>
        </trans-unit>
        <trans-unit id="e82fdbe87df063bbd6188f48b5ff47c8f53b5e5b" translate="yes" xml:space="preserve">
          <source>is not</source>
          <target state="translated">아니다</target>
        </trans-unit>
        <trans-unit id="2442a9efabb42df6d9155ee7e736901c656341f1" translate="yes" xml:space="preserve">
          <source>is not &lt;code&gt;NULL&lt;/code&gt; then this is a &lt;code&gt;PerlIO_reopen&lt;/code&gt; . Perl itself does not use this (yet?) and semantics are a little vague.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 는 &lt;code&gt;PerlIO_reopen&lt;/code&gt; 입니다. 펄 자체는 이것을 사용하지 않고 (아직?) 의미론은 약간 모호하다.</target>
        </trans-unit>
        <trans-unit id="5dbf0d4a2783568bc0ec6653623e5d748ba64d73" translate="yes" xml:space="preserve">
          <source>is not NULL. Since we don't have to check the NULLness, it's faster and smaller.</source>
          <target state="translated">NULL이 아닙니다. NULL을 확인할 필요가 없으므로 더 빠르고 작습니다.</target>
        </trans-unit>
        <trans-unit id="09afe42e6e5a8f0e386f1909d4abd2a189d4f310" translate="yes" xml:space="preserve">
          <source>is not NULL. The macro doesn't need to return a meaningful value, or check for NULLness, so it's smaller and faster.</source>
          <target state="translated">NULL이 아닙니다. 매크로는 의미있는 값을 반환하거나 NULL을 검사 할 필요가 없으므로 작고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1ffb843df2c6536477027470d90d6811acce8f6a" translate="yes" xml:space="preserve">
          <source>is not a directory that you can chdir to, possibly because it doesn't exist.</source>
          <target state="translated">존재하지 않기 때문에 chdir 할 수있는 디렉토리가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cd05864506055467d4c1543f9ab79897eee73f31" translate="yes" xml:space="preserve">
          <source>is not a full pathname found in the values of %INC, it is considered a regex.</source>
          <target state="translated">% INC 값에있는 전체 경로 이름이 아니며 정규식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ca37ad081732791ac7c3c488d1b688611146a3d5" translate="yes" xml:space="preserve">
          <source>is not a multiple of 8, use the</source>
          <target state="translated">8의 배수가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="90cfc06661f28638ad5685d595f94c84092a1299" translate="yes" xml:space="preserve">
          <source>is not a reference, it is &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in order to allow &lt;code&gt;$1&lt;/code&gt; etc. to be substituted. The example is one way to alias names as used in X11 fonts to the MIME names for the iso-8859-* family. Note the double quotes inside the single quotes.</source>
          <target state="translated">참조가 아닌 경우 &lt;code&gt;$1&lt;/code&gt; 등을 대체 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 됩니다. 이 예는 X11 글꼴에 사용 된 이름을 iso-8859- * 제품군의 MIME 이름으로 별칭을 지정하는 한 가지 방법입니다. 작은 따옴표 안에 큰 따옴표가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc27d44385271fc935f660f9829b5e1b57bf2fba" translate="yes" xml:space="preserve">
          <source>is not a string.</source>
          <target state="translated">문자열이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fe97c6a25e6e10b05fea34af623f7790fa5fba36" translate="yes" xml:space="preserve">
          <source>is not a string. Do not treat the return value as indicative of success or failure, because that isn't what it means: it is only the previous setting.</source>
          <target state="translated">문자열이 아닙니다. 반환 값을 성공 또는 실패를 나타내는 것으로 취급하지 마십시오. 이것이 의미하는 것은 아니기 때문입니다. 이전 설정일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="da2c1159c594f4eb414e53a0a7777f80e553cdef" translate="yes" xml:space="preserve">
          <source>is not allowed, but</source>
          <target state="translated">허용되지 않지만</target>
        </trans-unit>
        <trans-unit id="606701e8f5f91b1f859064528c6c90e0850405fe" translate="yes" xml:space="preserve">
          <source>is not already a list of the right type, it will be upgraded into one. If either</source>
          <target state="translated">아직 올바른 유형의 목록이 아닌 경우 한 유형으로 업그레이드됩니다. 어느 쪽이든</target>
        </trans-unit>
        <trans-unit id="8d605d2cddd686b63627dcedefd81881d4aede9c" translate="yes" xml:space="preserve">
          <source>is not available.</source>
          <target state="translated">사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e07acfe6e445415bc80f4539e83f2e5479627c6" translate="yes" xml:space="preserve">
          <source>is not defined, then Perl defaults to consulting first the logical name tables specified by</source>
          <target state="translated">을 정의하지 않으면 Perl의 기본값은 다음으로 지정된 논리적 이름 테이블을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="3b35dc3fb767643d25e161d97495375b6c8925d3" translate="yes" xml:space="preserve">
          <source>is not empty, and it is the same as</source>
          <target state="translated">비어 있지 않으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="133cd8c37eb7f1bc84f3898facc206421e336545" translate="yes" xml:space="preserve">
          <source>is not found in any of $lh's %Lexicon hashes. What happens if a key is not found, is discussed in a later section, &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">$ lh의 % Lexicon 해시에서 찾을 수 없습니다. 키를 찾을 수없는 경우 발생하는 상황은 이후 섹션 &quot;조회 ​​실패 제어&quot;에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="20608bdf427071b3f2b3bc63e3ca5ad5dba32b48" translate="yes" xml:space="preserve">
          <source>is not found, then Perl looks for an executable</source>
          <target state="translated">찾을 수 없으면 Perl이 실행 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="33010be083ed65d0281dbcb74bf9325a0f99e09d" translate="yes" xml:space="preserve">
          <source>is not given, skip all constants that are defined in a C enumeration. Otherwise skip only those constants that are defined in an enum whose name matches</source>
          <target state="translated">C 열거에 정의 된 모든 상수를 건너 뛰십시오. 그렇지 않으면 이름이 일치하는 열거 형에 정의 된 상수 만 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3339d9443dad98ccb99bf9de00b6ef263750537d" translate="yes" xml:space="preserve">
          <source>is not in PERL5LIB.</source>
          <target state="translated">PERL5LIB에 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ee2f3e24f21d916d1b9f7d8d204a62832704191" translate="yes" xml:space="preserve">
          <source>is not necessary,</source>
          <target state="translated">필요가 없습니다,</target>
        </trans-unit>
        <trans-unit id="3f84e0c82fe1616e060e2332dff93b4abd3bb7e3" translate="yes" xml:space="preserve">
          <source>is not ok, as the regex engine will end up trying to compile the pattern &lt;code&gt;\&lt;/code&gt; , which it will consider a syntax error.</source>
          <target state="translated">정규식 엔진이 패턴 &lt;code&gt;\&lt;/code&gt; 을 컴파일하려고 할 때 구문 오류를 고려할 것이므로 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="1de141eaa0f30aab49d63c7c0d6cb5d7b40c44a8" translate="yes" xml:space="preserve">
          <source>is not passed if the layer is at the bottom of the stack, for this reason and to maintain some level of &quot;compatibility&quot; with TIEHANDLE classes it is passed last.</source>
          <target state="translated">레이어가 스택의 맨 아래에있는 경우 전달되지 않습니다. 이러한 이유로 TIEHANDLE 클래스와의 &quot;호환성&quot;수준을 유지하기 위해 마지막에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="14ca5e3fc9da5c9523747e734197510c25796d8c" translate="yes" xml:space="preserve">
          <source>is not portable. Leave out the last comma.</source>
          <target state="translated">휴대용이 아닙니다. 마지막 쉼표를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="f5ac0afcf1f3987905381d9349d990f0a6872ecc" translate="yes" xml:space="preserve">
          <source>is not required and not implemented.</source>
          <target state="translated">필요하지 않으며 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a5cf5f3c675f9c2d68cf66e1262d7c525fab832d" translate="yes" xml:space="preserve">
          <source>is not returned explicitly from &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에서 명시 적으로 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="461edf58bab13d0e289e3fd343d9a0a8b3513001" translate="yes" xml:space="preserve">
          <source>is not returned explicitly from &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에서 명시 적으로 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0d97eb902a0ef031b420e6b9b05fccbf862f0b26" translate="yes" xml:space="preserve">
          <source>is not specified: &lt;b&gt;xsubpp&lt;/b&gt; can see that it needs to generate a function call section, and will autogenerate the OUTPUT section too. Thus one can shortcut the XSUB to become:</source>
          <target state="translated">지정되지 않은 : &lt;b&gt;은 xsubpp는&lt;/b&gt; 이 함수 호출 섹션을 생성 할 필요가 있음을 볼 수 있고, 너무 OUTPUT 부분을 자동 생성됩니다. 따라서 XSUB를 바로 가기로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d1ac57316dccf7b303f8434af4c18ee03b0a0b" translate="yes" xml:space="preserve">
          <source>is not supported).</source>
          <target state="translated">지원되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="660e55295ec134f5c48bc724bc723675d1a1b8fd" translate="yes" xml:space="preserve">
          <source>is not the same as</source>
          <target state="translated">와 같지 않다</target>
        </trans-unit>
        <trans-unit id="c20017ff75bdfb50ee3a50480bd863b1895d08c4" translate="yes" xml:space="preserve">
          <source>is not transparent. The</source>
          <target state="translated">투명하지 않습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="a2f7dc60b1a7a427469f140199570b1bd8f899c4" translate="yes" xml:space="preserve">
          <source>is not yet implemented (dummy function). (Perl has a workaround.)</source>
          <target state="translated">아직 구현되지 않았습니다 (더미 기능). (펄은 해결 방법이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8e0d75ab66ac6c358071d7ce5aa3ae1d338105d6" translate="yes" xml:space="preserve">
          <source>is nothing to worry about at all.</source>
          <target state="translated">전혀 걱정할 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7206590a99801f0070757ea643074d99c5330488" translate="yes" xml:space="preserve">
          <source>is now different from</source>
          <target state="translated">지금과 다르다</target>
        </trans-unit>
        <trans-unit id="296c2ce8ed25f67f0112e54c6f7348b8ee269520" translate="yes" xml:space="preserve">
          <source>is now misinterpreted as</source>
          <target state="translated">이제는 다음과 같이 잘못 해석됩니다</target>
        </trans-unit>
        <trans-unit id="784e257d270f346aebf3530a8118df2e3e970f3c" translate="yes" xml:space="preserve">
          <source>is null, the other is returned unchanged.</source>
          <target state="translated">null의 경우는, 다른 쪽은 변경되지 않고 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="1cd25b0094b3720a6cc3ba23740121d376548889" translate="yes" xml:space="preserve">
          <source>is null, the state op is returned. Otherwise the state op is combined with</source>
          <target state="translated">null의 경우, 상태 op가 돌려 주어집니다 그렇지 않으면 상태 op가</target>
        </trans-unit>
        <trans-unit id="bfd34bbffb3bec2ae854bed4fe93b5b4df09d7c5" translate="yes" xml:space="preserve">
          <source>is octal, as in &lt;code&gt;E&amp;lt;075&amp;gt;&lt;/code&gt; . Otherwise</source>
          <target state="translated">&lt;code&gt;E&amp;lt;075&amp;gt;&lt;/code&gt; 는 0에서와 같이 8 진수 이다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="e59f8572639c6d7abe84f59ed23f115265c34830" translate="yes" xml:space="preserve">
          <source>is officially available in gcc 3.0 and later. You can build a profiled version of</source>
          <target state="translated">gcc 3.0 이상에서 공식적으로 제공됩니다. 당신은 프로파일 버전을 구축 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bb3335ba98001fe8c8858bb517435edad14df2ff" translate="yes" xml:space="preserve">
          <source>is often the quickest way to compute SHA message digests. The user simply feeds data to the script through files or standard input, and then collects the results from standard output.</source>
          <target state="translated">SHA 메시지 요약을 계산하는 가장 빠른 방법입니다. 사용자는 파일이나 표준 입력을 통해 스크립트에 데이터를 공급 한 다음 표준 출력에서 ​​결과를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="7c869452ca51dc4f4b90e7e682e32efa15fa5d08" translate="yes" xml:space="preserve">
          <source>is often used interchangeably with it.</source>
          <target state="translated">종종 그것과 상호 교환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5031d72b525717047dc6fd15f90430cc40172acd" translate="yes" xml:space="preserve">
          <source>is omitted,</source>
          <target state="translated">생략</target>
        </trans-unit>
        <trans-unit id="59383e02842c6ecb450610847b00c5496ed1ae05" translate="yes" xml:space="preserve">
          <source>is omitted, list them all.</source>
          <target state="translated">생략하고 모두 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="bed8ec63611bd49c0e67878865bfd9f59745945e" translate="yes" xml:space="preserve">
          <source>is omitted, set an action on the line about to be executed. The sequence of steps taken by the debugger is</source>
          <target state="translated">생략 할 행에 대해 조치를 설정하십시오. 디버거가 수행하는 일련의 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1454936324f5b838ad8702f3a4e912fdb73181b3" translate="yes" xml:space="preserve">
          <source>is omitted, sets &lt;code&gt;$\&lt;/code&gt; to the current value of &lt;code&gt;$/&lt;/code&gt; . For instance, to trim lines to 80 columns:</source>
          <target state="translated">생략하면 &lt;code&gt;$\&lt;/code&gt; 를 현재 값 &lt;code&gt;$/&lt;/code&gt; 합니다. 예를 들어 선을 80 열로 자르려면</target>
        </trans-unit>
        <trans-unit id="4bb3e6d01d8abb5873707a404b01ed088d627c52" translate="yes" xml:space="preserve">
          <source>is omitted. If that viewer is &lt;b&gt;man&lt;/b&gt;, the current &lt;code&gt;Config&lt;/code&gt; information is used to invoke &lt;b&gt;man&lt;/b&gt; using the proper MANPATH or &lt;b&gt;-M&lt;/b&gt;</source>
          <target state="translated">생략됩니다. 해당 뷰어가 &lt;b&gt;man&lt;/b&gt; 인 경우 현재 &lt;code&gt;Config&lt;/code&gt; 정보는 올바른 MANPATH 또는 &lt;b&gt;-M을&lt;/b&gt; 사용하여 &lt;b&gt;man&lt;/b&gt; 을 호출하는 데 사용됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="808a9a0b7d1e742f272682180efba6d96e49b61e" translate="yes" xml:space="preserve">
          <source>is one of &lt;code&gt;S_IRUSR&lt;/code&gt; , &lt;code&gt;S_IWUSR&lt;/code&gt; or &lt;code&gt;S_IXUSR&lt;/code&gt; from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, and</source>
          <target state="translated">중 하나 &lt;code&gt;S_IRUSR&lt;/code&gt; , &lt;code&gt;S_IWUSR&lt;/code&gt; 또는 &lt;code&gt;S_IXUSR&lt;/code&gt; 로부터 &lt;a href=&quot;../fcntl&quot;&gt;으로 fcntl&lt;/a&gt; 모듈 및</target>
        </trans-unit>
        <trans-unit id="774717fd7c9c7ce3270b72d058c209e6053fc8a0" translate="yes" xml:space="preserve">
          <source>is one of the 10 exceptional cases (or things like them) listed below, it is used directly as a boolean.</source>
          <target state="translated">아래에 열거 된 10 가지 예외적 인 경우 (또는 이와 유사한 것) 중 하나이며 부울로 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c53bf86436bbbd29af464847d3f11c3b0b08cbf8" translate="yes" xml:space="preserve">
          <source>is one of those defined in the Unicode standard. For Unicode 5.1, they are defined in Section 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; available at &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt;. These are for context-sensitive casing.</source>
          <target state="translated">유니 코드 표준에 정의 된 것 중 하나입니다. 유니 코드 5.1의 경우 &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt; 에서 제공되는 3.13 절 &lt;code&gt;Default Case Operations&lt;/code&gt; 정의되어 있습니다 . 상황에 맞는 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="840b280f15a6b38ff8c9a2baa67e8c9188a87b38" translate="yes" xml:space="preserve">
          <source>is open, or use &quot;r+&quot; to indicate a read/write stream.</source>
          <target state="translated">열려 있거나 &quot;r +&quot;를 사용하여 읽기 / 쓰기 스트림을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c683506eb9e31819d71640bdc2f2478d3f6ce65d" translate="yes" xml:space="preserve">
          <source>is opened for writing.</source>
          <target state="translated">쓰기 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="79749dba2b390bb7475fce2507f0f4eb5987e332" translate="yes" xml:space="preserve">
          <source>is optional and defaults to rest of the array.</source>
          <target state="translated">선택 사항이며 기본값은 나머지 배열입니다.</target>
        </trans-unit>
        <trans-unit id="915a141436744a90f3e02d0dd1d609a72b2c593a" translate="yes" xml:space="preserve">
          <source>is optional and defaults to zero, negative values count back from the end of the array.</source>
          <target state="translated">선택 사항이며 기본값은 0이며, 음수 값은 배열 끝에서 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="df5063ae13199d816cf6966e77f57c23f1e15e7b" translate="yes" xml:space="preserve">
          <source>is optional, make sure that this switch is followed by at least one other switch if you omit</source>
          <target state="translated">선택 사항입니다. 생략하면이 스위치 뒤에 다른 스위치가 하나 이상 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6dd01b70fcde3901a9b8cd6f99e52b559931ae66" translate="yes" xml:space="preserve">
          <source>is optional.</source>
          <target state="translated">선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d3403c1182056f32036e1b0b051b43fe6e7e8805" translate="yes" xml:space="preserve">
          <source>is optional. If omitted, the encoding specified in the environment variable &lt;a href=&quot;perlrun#PERL_ENCODING&quot;&gt;PERL_ENCODING &lt;/a&gt; is used. If this isn't set, or the resolved-to encoding is not known to &lt;code&gt;&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;&lt;/code&gt;, the error &lt;code&gt;Unknown encoding '&lt;i&gt;ENCNAME&lt;/i&gt;'&lt;/code&gt; will be thrown.</source>
          <target state="translated">선택 사항입니다. 생략하면 환경 변수 &lt;a href=&quot;perlrun#PERL_ENCODING&quot;&gt;PERL_ENCODING에&lt;/a&gt; 지정된 인코딩 이 사용됩니다. 이것이 설정되지 않았거나 해결 된 인코딩이 &lt;code&gt;&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;&lt;/code&gt; 로 알려지지 않은 경우 , &lt;code&gt;Unknown encoding '&lt;i&gt;ENCNAME&lt;/i&gt;'&lt;/code&gt; 오류 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="460daaa5dcc2cb35dc81c46bff6ccd69c45e1b70" translate="yes" xml:space="preserve">
          <source>is passed to &lt;code&gt;SvPV_flags&lt;/code&gt; , and usually should be &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; to handle magic.</source>
          <target state="translated">은 &lt;code&gt;SvPV_flags&lt;/code&gt; 로 전달 되며 일반적으로 마법을 처리하려면 &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd20141170d229f9cc0136383909cd4f633a749b" translate="yes" xml:space="preserve">
          <source>is passed to the RE engine for compilation.</source>
          <target state="translated">컴파일을 위해 RE 엔진으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a9eb96dfee227401a57fda9e8cbf3aa10f225974" translate="yes" xml:space="preserve">
          <source>is platform specific and may not be available for a specific port of Perl.</source>
          <target state="translated">플랫폼에 따라 다르며 Perl의 특정 포트에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25efb0ba5cb2478bde4a9a44864c9da4f454d8ed" translate="yes" xml:space="preserve">
          <source>is possible</source>
          <target state="translated">가능하다</target>
        </trans-unit>
        <trans-unit id="523f09771ac3cf4731742b1c80be3d254a1ba53f" translate="yes" xml:space="preserve">
          <source>is preceded by a plus or minus sign then it is assumed to be relative, with negative numbers indicating preceding capture groups and positive ones following. Thus &lt;code&gt;(?-1)&lt;/code&gt; refers to the most recently declared group, and &lt;code&gt;(?+1)&lt;/code&gt; indicates the next group to be declared. Note that the counting for relative recursion differs from that of relative backreferences, in that with recursion unclosed groups &lt;b&gt;are&lt;/b&gt; included.</source>
          <target state="translated">앞에 플러스 또는 마이너스 부호가 붙은 다음 상대 캡처 된 것으로 간주되며, 음수는 선행 캡처 그룹과 양수를 나타냅니다. 따라서 &lt;code&gt;(?-1)&lt;/code&gt; 은 가장 최근에 선언 된 그룹을 나타내고 &lt;code&gt;(?+1)&lt;/code&gt; 은 선언 할 다음 그룹을 나타냅니다. 상대 재귀 수는 재귀 닫힘 그룹 &lt;b&gt;이&lt;/b&gt; 포함되어 있다는 점에서 상대 역 참조 수와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e7ca6ab06ff93674a9f398734b75e0712f956c08" translate="yes" xml:space="preserve">
          <source>is preferred over the system malloc. Otherwise the value is null. This variable is intended for generating Makefiles.</source>
          <target state="translated">시스템 malloc보다 선호됩니다. 그렇지 않으면 값은 null입니다. 이 변수는 Makefile을 생성하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd9425232ec1477789dd62e49cd5398771156271" translate="yes" xml:space="preserve">
          <source>is preferred over the system malloc. Otherwise the value is null. This variable is intended for generating Makefiles. See mallocsrc.</source>
          <target state="translated">시스템 malloc보다 선호됩니다. 그렇지 않으면 값은 null입니다. 이 변수는 Makefile을 생성하기위한 것입니다. mallocsrc를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f67f67cd9d10cfa55835748252e70c39d94e9642" translate="yes" xml:space="preserve">
          <source>is present but is not a positive number matching &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A(\d*\.)?\d+\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">존재하지만 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A(\d*\.)?\d+\z/&lt;/a&gt;&lt;/code&gt; 일치하는 양수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="cd6cfac1ce57b9138644859e222534e07b64b3f7" translate="yes" xml:space="preserve">
          <source>is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt; .</source>
          <target state="translated">EMX에 있지만 기능하지는 않으며 perl에 의해 에뮬레이트됩니다. 에뮬레이션을 비활성화하려면 환경 변수 &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt; 을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eb8a82dec3aea4891c7d0fdc7c4040cbf80deac" translate="yes" xml:space="preserve">
          <source>is present. On Unix, this means that &lt;code&gt;$no_file&lt;/code&gt; true makes this return ( '', $path, '' ).</source>
          <target state="translated">존재합니다. 유닉스에서 이것은 &lt;code&gt;$no_file&lt;/code&gt; true가이 리턴 ( '', $ path, '')을 만든다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="fae39eb0e249041dca8ecd4c4e5c73741b3158c8" translate="yes" xml:space="preserve">
          <source>is printed with proper indentation.</source>
          <target state="translated">적절한 들여 쓰기로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b801d1d0e729e303069ae25d8e485d81ece8ba" translate="yes" xml:space="preserve">
          <source>is probably overkill for this. Something as simple as a &lt;code&gt;#define&lt;/code&gt; will do too:</source>
          <target state="translated">아마 이것에 대해 과잉 일 것입니다. &lt;code&gt;#define&lt;/code&gt; 처럼 간단한 것도 역시 그렇게 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="c75e0ceb23f1e1bd5d1ae898ae5b3a046e750c35" translate="yes" xml:space="preserve">
          <source>is processed before processing &lt;code&gt;PERLDB_OPTS&lt;/code&gt; . If</source>
          <target state="translated">&lt;code&gt;PERLDB_OPTS&lt;/code&gt; 를 처리하기 전에 처리 됩니다 . 만약</target>
        </trans-unit>
        <trans-unit id="dd2e5ec393361241bdf00bf003cfd5d912213a01" translate="yes" xml:space="preserve">
          <source>is replicated. This latter is useful for counting characters in a class or for squashing character sequences in a class.</source>
          <target state="translated">복제됩니다. 후자는 클래스의 문자 수를 계산하거나 클래스의 문자 시퀀스를 축소하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5127b5091f9438f482f3b3e9a135487ed542c34c" translate="yes" xml:space="preserve">
          <source>is reported by mkmanifest() if $Verbose is set and a file is added to MANIFEST. $Verbose is set to 1 by default.</source>
          <target state="translated">$ Verbose가 설정되고 파일이 MANIFEST에 추가되면 mkmanifest ()에 의해보고됩니다. $ Verbose는 기본적으로 1로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb20d2b460123fa620831fa74f056496b2769aa8" translate="yes" xml:space="preserve">
          <source>is reported if &lt;code&gt;MANIFEST&lt;/code&gt; could not be opened.</source>
          <target state="translated">&lt;code&gt;MANIFEST&lt;/code&gt; 를 열 수없는 경우보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="328906540cfc4914dc5ef9e9058dee50029d2b82" translate="yes" xml:space="preserve">
          <source>is reported if a file is found which is not in &lt;code&gt;MANIFEST&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;MANIFEST&lt;/code&gt; 에 없는 파일이 발견되면보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="552d792cd22a56b9bb40ff5d893f66da4e73233e" translate="yes" xml:space="preserve">
          <source>is reported if a file is skipped due to an entry in &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;MANIFEST.SKIP&lt;/code&gt; 의 항목으로 인해 파일을 건너 뛴 경우보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="aeed03f4804268d15748142d4e8831e16972eca4" translate="yes" xml:space="preserve">
          <source>is reported if a file mentioned in a &lt;code&gt;MANIFEST&lt;/code&gt; file does not exist.</source>
          <target state="translated">&lt;code&gt;MANIFEST&lt;/code&gt; 파일에 언급 된 파일이 존재하지 않는 경우보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="62f90f7410ef6025437546070986df3097b81356" translate="yes" xml:space="preserve">
          <source>is requested, Perl will not look for</source>
          <target state="translated">펄은 찾지 않을 것이다</target>
        </trans-unit>
        <trans-unit id="732d7871b8b24cfa3bee53313dd1156e83c03669" translate="yes" xml:space="preserve">
          <source>is required if you want to start your program without a VIO window present, but not &lt;code&gt;detach&lt;/code&gt; ed (run &lt;code&gt;help detach&lt;/code&gt; for more info). Very useful for extensions which use PM, like &lt;code&gt;Perl/Tk&lt;/code&gt; or &lt;code&gt;OpenGL&lt;/code&gt; .</source>
          <target state="translated">VIO 창이없는 상태에서 프로그램을 시작하지만 &lt;code&gt;detach&lt;/code&gt; 하지 않은 경우 필요합니다 ( 자세한 내용 &lt;code&gt;help detach&lt;/code&gt; ). &lt;code&gt;Perl/Tk&lt;/code&gt; 또는 &lt;code&gt;OpenGL&lt;/code&gt; 과 같이 PM을 사용하는 확장에 매우 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6d5c50073dedc878c0bb174986728a65c26611" translate="yes" xml:space="preserve">
          <source>is reserved and must be zero. If it is not in the current pad but appears in the pad of any lexically enclosing scope, then a pseudo-entry for it is added in the current pad. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if no such lexical is in scope.</source>
          <target state="translated">예약되어 있으며 0이어야합니다. 현재 패드에 없지만 어휘 포함 범위의 패드에 나타나는 경우 의사 입력이 현재 패드에 추가됩니다. 현재 패드의 오프셋 또는 해당 어휘가 범위에없는 경우 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dab1f8b59686974bbcd2707bc651d6707dac406f" translate="yes" xml:space="preserve">
          <source>is returned.</source>
          <target state="translated">반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b418f45ad77bc3826b32d08799dfded45d89432" translate="yes" xml:space="preserve">
          <source>is roughly equivalent to:</source>
          <target state="translated">대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b84a5263098f0e0c514dc8fe7d67295e56c987dc" translate="yes" xml:space="preserve">
          <source>is run on source code files, like this</source>
          <target state="translated">이 같은 소스 코드 파일에서 실행됩니다</target>
        </trans-unit>
        <trans-unit id="505ded7fa9f0c714268c66ac7bb3b81302192c94" translate="yes" xml:space="preserve">
          <source>is semantically ambiguous, in a way that makes formatting decisions a bit difficult. On the one hand, it could be mention of an item &quot;Neque&quot;, mention of another item &quot;Porro&quot;, and mention of another item &quot;Quisquam Est&quot;, with just the last one requiring the explanatory paragraph &quot;Qui dolorem ipsum quia dolor...&quot;; and then an item &quot;Ut Enim&quot;. In that case, you'd want to format it like so:</source>
          <target state="translated">형식 결정을 조금 어렵게 만드는 방식으로 의미 상 모호합니다. 한편으로는 &quot;Neque&quot;항목, 다른 항목 &quot;Porro&quot;및 다른 항목 &quot;Quisquam Est&quot;, 마지막 항목 인 &quot;Qui dolorem ipsum quia dolor&quot;항목이 언급 될 수 있습니다. .. &quot;; 그런 다음 &quot;Ut Enim&quot;항목입니다. 이 경우 다음과 같이 형식을 지정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7722d64cd0eafe5303c971058e1fcb33e1d6e14c" translate="yes" xml:space="preserve">
          <source>is semantically equivalent to the list:</source>
          <target state="translated">의미 적으로 목록과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2126556a279c8048a27fc92ce2d017bedadfc33a" translate="yes" xml:space="preserve">
          <source>is set accordingly.</source>
          <target state="translated">그에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa2db030f6de6d0d8d463059f009a0bd838f324" translate="yes" xml:space="preserve">
          <source>is set explicitly. Additionally, C</source>
          <target state="translated">명시 적으로 설정됩니다. 또한 C</target>
        </trans-unit>
        <trans-unit id="f33cd6497df379b7aa55e16988255762f6cc5079" translate="yes" xml:space="preserve">
          <source>is set to 2 if it isn't set already (see &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;PERL_DESTRUCT_LEVEL in perlhacktips&lt;/a&gt;).</source>
          <target state="translated">아직 설정되지 않은 경우 2로 설정됩니다 ( &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;perlhacktips의 PERL_DESTRUCT_LEVEL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2b4d53f643e8f5289626164f0873fffe60309f8d" translate="yes" xml:space="preserve">
          <source>is set to &lt;code&gt;Encode::FB_QUIET&lt;/code&gt; , encoding and decoding immediately return the portion of the data that has been processed so far when an error occurs. The data argument is overwritten with everything after that point; that is, the unprocessed portion of the data. This is handy when you have to call &lt;code&gt;decode&lt;/code&gt; repeatedly in the case where your source data may contain partial multi-byte character sequences, (that is, you are reading with a fixed-width buffer). Here's some sample code to do exactly that:</source>
          <target state="translated">를 &lt;code&gt;Encode::FB_QUIET&lt;/code&gt; 설정하면 인코딩 및 디코딩은 오류가 발생할 때까지 처리 된 데이터 부분을 즉시 반환합니다. 데이터 인수는 그 시점 이후의 모든 것으로 덮어 씁니다. 즉, 데이터의 처리되지 않은 부분입니다. 소스 데이터에 부분 멀티 바이트 문자 시퀀스가 ​​포함 된 경우 (즉, 고정 너비 버퍼로 읽는 경우) &lt;code&gt;decode&lt;/code&gt; 반복적 으로 호출해야 할 때 편리 합니다. 다음은 정확히 수행하기위한 샘플 코드입니다.</target>
        </trans-unit>
        <trans-unit id="fbfb9653688f76b59517a59a6f2dc20d0b7fcf79" translate="yes" xml:space="preserve">
          <source>is set to MEDIUM or higher.</source>
          <target state="translated">MEDIUM 이상으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ad4f726f3cb1586df04ee0538b5e72441b3f80" translate="yes" xml:space="preserve">
          <source>is set to the length of the scanned string, and</source>
          <target state="translated">스캔 한 문자열의 길이로 설정되고</target>
        </trans-unit>
        <trans-unit id="1cee3f4a0dcf9c9aac5c7b81e0001cba5602885c" translate="yes" xml:space="preserve">
          <source>is set up so that the logical name &lt;code&gt;story&lt;/code&gt; is found, rather than a CLI symbol or CRTL &lt;code&gt;environ&lt;/code&gt; element with the same name.</source>
          <target state="translated">CLI 이름 또는 동일한 이름의 CRTL &lt;code&gt;environ&lt;/code&gt; 요소가 아닌 논리적 이름 &lt;code&gt;story&lt;/code&gt; 를 찾 도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca6947993695dc137eeb97b7855ecc954a5db745" translate="yes" xml:space="preserve">
          <source>is set, then the source string to encode() or decode() will be overwritten in place. If you're not interested in this, then bitwise-OR it with the bitmask.</source>
          <target state="translated">이 설정되면 encode () 또는 decode ()에 대한 소스 문자열을 덮어 씁니다. 관심이 없다면 비트 마스크로 비트 단위 또는 비트 마스크를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bbdac3cf799e738c5a8da93062efb7bc674a7966" translate="yes" xml:space="preserve">
          <source>is shorter than the</source>
          <target state="translated">보다 짧다</target>
        </trans-unit>
        <trans-unit id="09e367c3fc5cc8d794bb19d7c88ac5b3dbdeee84" translate="yes" xml:space="preserve">
          <source>is similar to:</source>
          <target state="translated">비슷하다:</target>
        </trans-unit>
        <trans-unit id="252ba6878cfe0ead48b091a1c7b126be1c7dff77" translate="yes" xml:space="preserve">
          <source>is simply a named option of &lt;b&gt;Pod::Parser&lt;/b&gt; with a value that corresponds to a certain specified behavior. These various behaviors of &lt;b&gt;Pod::Parser&lt;/b&gt; may be enabled/disabled by setting or unsetting one or more</source>
          <target state="translated">지정된 특정 동작에 해당하는 값을 가진 &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 명명 된 옵션입니다 . &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 이러한 다양한 동작은 하나 이상의 설정 또는 설정 해제에 의해 활성화 / 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a84848b3c3eaf21ad8fc8af050d6c81e580ed346" translate="yes" xml:space="preserve">
          <source>is simply opened and read; no special modes or I/O disciplines are used. To change this, set the optional</source>
          <target state="translated">단순히 열리고 읽습니다. 특수 모드 나 I / O 분야는 사용되지 않습니다. 이를 변경하려면 옵션을 설정하십시오</target>
        </trans-unit>
        <trans-unit id="fbcaf1a2e7b687efcdea29a64a0429d2d73c416e" translate="yes" xml:space="preserve">
          <source>is skipped, including all its sub-directories. The default is to 'die' in such a case.</source>
          <target state="translated">모든 하위 디렉토리를 포함하여 건너 뜁니다. 이 경우 기본값은 'die'입니다.</target>
        </trans-unit>
        <trans-unit id="57e430e116971e873eefc3dde4fa051e8cf43562" translate="yes" xml:space="preserve">
          <source>is slower than</source>
          <target state="translated">보다 느리다</target>
        </trans-unit>
        <trans-unit id="d049167d37668316c130f710bc1870b3a57a2719" translate="yes" xml:space="preserve">
          <source>is something that produces a stream of TAP for the parser to consume, such as an executable file, a text file, an archive, an IO handle, a database, etc. &lt;code&gt;TAP::Parser::Source&lt;/code&gt; s encapsulate these</source>
          <target state="translated">실행 파일, 텍스트 파일, 아카이브, IO 핸들, 데이터베이스 등과 같이 파서가 사용할 TAP 스트림을 생성하는 것입니다. &lt;code&gt;TAP::Parser::Source&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="e9ef489bd0e8e4faddde7bba7424e123d5cb2cdf" translate="yes" xml:space="preserve">
          <source>is substituted, and resulting binaries will be a mess.</source>
          <target state="translated">대체되고 결과 바이너리는 엉망이됩니다.</target>
        </trans-unit>
        <trans-unit id="598b73ec92930dcb2052eb812846ae6b23e7a9f4" translate="yes" xml:space="preserve">
          <source>is suggested instead. See also &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;PERL_MEM_LOG in perlhacktips&lt;/a&gt;.</source>
          <target state="translated">대신 제안됩니다. &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips의 PERL_MEM_LOG&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f36c7e47ba89397191d8268fee1d7e7b3176375" translate="yes" xml:space="preserve">
          <source>is supported by Encode, any source encoding is fine.</source>
          <target state="translated">Encode에서 지원하므로 모든 소스 인코딩이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f26f422c33326b47a62f1cb9a45fdcf68258f29a" translate="yes" xml:space="preserve">
          <source>is that it indiscriminately applies the specified transformation to the entire text of your source program. So something like:</source>
          <target state="translated">지정된 변환을 소스 프로그램의 전체 텍스트에 무차별 적으로 적용한다는 것입니다. 그래서 같은 :</target>
        </trans-unit>
        <trans-unit id="988ce70c85eae79d0fe25b4054ce79630b89879b" translate="yes" xml:space="preserve">
          <source>is the OP that needs optimizing;</source>
          <target state="translated">최적화가 필요한 OP입니다.</target>
        </trans-unit>
        <trans-unit id="338540b0e9d83bd77bd1013d1cc68e0e7753e278" translate="yes" xml:space="preserve">
          <source>is the OP that requested the eval, and will normally be an &lt;code&gt;OP_ENTEREVAL&lt;/code&gt; , &lt;code&gt;OP_DOFILE&lt;/code&gt; or &lt;code&gt;OP_REQUIRE&lt;/code&gt; .</source>
          <target state="translated">eval을 요청한 OP이며 일반적으로 &lt;code&gt;OP_ENTEREVAL&lt;/code&gt; , &lt;code&gt;OP_DOFILE&lt;/code&gt; 또는 &lt;code&gt;OP_REQUIRE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="503522920752d3b808908bb7e985e21cf9217310" translate="yes" xml:space="preserve">
          <source>is the Unicode code point (in any number of hex digits) of the character that cannot be found in the character repertoire of the encoding.</source>
          <target state="translated">인코딩의 문자 레퍼토리에서 찾을 수없는 문자의 유니 코드 코드 포인트 (16 진 숫자)입니다.</target>
        </trans-unit>
        <trans-unit id="b435409a7d8e12b8eb19aeb5a153ffd1f9f409bc" translate="yes" xml:space="preserve">
          <source>is the access mode and the encoding format to open the file with;</source>
          <target state="translated">파일을 여는 액세스 모드 및 인코딩 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5fa370b47b540f6499c736b9b14daa48b0750be8" translate="yes" xml:space="preserve">
          <source>is the body of the block. Returns the block, possibly modified.</source>
          <target state="translated">블록의 본문입니다. 수정 된 블록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ae28d04d97b4db2036c9e56276e357f10acc52e" translate="yes" xml:space="preserve">
          <source>is the class we are attaching to,</source>
          <target state="translated">우리가 연결하는 수업입니다.</target>
        </trans-unit>
        <trans-unit id="88c2f81141fada39655c45626c041dad52ddc90e" translate="yes" xml:space="preserve">
          <source>is the debugging one. When called with an argument, switches to debugging or non-debugging dispatcher depending on the argument (active for newly-entered subs/etc only). (The returned value is for the dispatcher before the modification.)</source>
          <target state="translated">디버깅 중 하나입니다. 인수와 함께 호출하면 인수에 따라 디버깅 또는 논 디버거 디스패처로 전환됩니다 (새로 입력 한 서브 / 등에 만 활성화). (반환 된 값은 수정하기 전에 디스패처에 대한 것입니다.)</target>
        </trans-unit>
        <trans-unit id="82c52d1d716f93b650732617909547f222352c02" translate="yes" xml:space="preserve">
          <source>is the direct equivalent of this bit of Perl</source>
          <target state="translated">이 Perl 비트와 직접적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1fb2b7c32e3e6b82afdc74d9253d0b3262b0d7c9" translate="yes" xml:space="preserve">
          <source>is the empty string. Otherwise, it is an inferior, but still better-than-nothing alternative folding to</source>
          <target state="translated">빈 문자열입니다. 그렇지 않으면, 그것은 열등하지만 여전히 낫지 않은 대안입니다.</target>
        </trans-unit>
        <trans-unit id="b4e2abd936326e926d92e153325a90b9130254a2" translate="yes" xml:space="preserve">
          <source>is the external name of the file you want opened.</source>
          <target state="translated">열려고하는 파일의 외부 이름입니다.</target>
        </trans-unit>
        <trans-unit id="acae083d8f7267d56411d4d8123fe8329504c47b" translate="yes" xml:space="preserve">
          <source>is the famous imaginary number introduced above. Conversion between this form and the cartesian form &lt;code&gt;a + bi&lt;/code&gt; is immediate:</source>
          <target state="translated">위에서 소개 된 유명한 허수입니다. 이 형식과 데카르트 형식 &lt;code&gt;a + bi&lt;/code&gt; 간의 변환 은 즉시 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="e5958b1e8af4ba98be9cc22430ff29e15f04e50c" translate="yes" xml:space="preserve">
          <source>is the file to read for POD source (the POD can be embedded in code). If</source>
          <target state="translated">POD 소스를 읽을 파일입니다 (POD를 코드에 포함 할 수 있음). 만약</target>
        </trans-unit>
        <trans-unit id="4a902a3b5a686c36c34a6d4895c350e6d72563d5" translate="yes" xml:space="preserve">
          <source>is the hex representation of the octet that could not be decoded to utf8. When you encode, &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; will be inserted, where</source>
          <target state="translated">utf8로 디코딩 할 수없는 옥텟의 16 진 표현입니다. 인코딩하면 &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; 가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="504ac0735ae10a95e2b5ee3e369194696677007c" translate="yes" xml:space="preserve">
          <source>is the hexadecimal number.</source>
          <target state="translated">16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="98790fd2c6f05473e5c44b7acdc0f6b4506f2f5e" translate="yes" xml:space="preserve">
          <source>is the index into that array of the layer being called. The macro &lt;code&gt;PerlIOArg&lt;/code&gt; will return a (possibly &lt;code&gt;NULL&lt;/code&gt; ) SV * for the argument passed to the layer.</source>
          <target state="translated">호출되는 레이어의 해당 배열에 대한 인덱스입니다. 매크로 &lt;code&gt;PerlIOArg&lt;/code&gt; 는 레이어에 전달 된 인수에 대해 (아마도 &lt;code&gt;NULL&lt;/code&gt; ) SV *를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="142db92371cc5426856fa3d444ddae687efa8615" translate="yes" xml:space="preserve">
          <source>is the last argument in the list.</source>
          <target state="translated">목록의 마지막 인수입니다.</target>
        </trans-unit>
        <trans-unit id="a14b49226b3bbb81004f3cb1f765bb5fef97f5a8" translate="yes" xml:space="preserve">
          <source>is the list-type op, and</source>
          <target state="translated">목록 유형 op이며</target>
        </trans-unit>
        <trans-unit id="f82606a57221f2b4b38ede02bc6cd6626d56d5e3" translate="yes" xml:space="preserve">
          <source>is the list-type op.</source>
          <target state="translated">목록 유형 op입니다.</target>
        </trans-unit>
        <trans-unit id="cafab01435fe922ebcb5d5cff02f00617e1abe22" translate="yes" xml:space="preserve">
          <source>is the mapped drive to the sys: volume of the server where Perl on NetWare is installed. Now typing</source>
          <target state="translated">NetWare의 Perl이 설치된 서버의 sys : 볼륨에 맵핑 된 드라이브입니다. 이제 입력</target>
        </trans-unit>
        <trans-unit id="5fa4a40ee43f92498170d49135ea24ebd1ead4cd" translate="yes" xml:space="preserve">
          <source>is the moral equivalent of these two:</source>
          <target state="translated">이 둘의 도덕적 가치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b3a81aac7cf79ce51c3e68af0806f7f4937ca7" translate="yes" xml:space="preserve">
          <source>is the most popular. UTF-8 is a variable length encoding that encodes Unicode characters as 1 to 4 bytes. Other encodings include UTF-16 and UTF-32 and their big- and little-endian variants (UTF-8 is byte-order independent). The ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding forms.</source>
          <target state="translated">가장 인기가 있습니다. UTF-8은 유니 코드 문자를 1-4 바이트로 인코딩하는 가변 길이 인코딩입니다. 다른 인코딩으로는 UTF-16 및 UTF-32와 빅 엔디안 및 리틀 엔디안 변형이 있습니다 (UTF-8은 바이트 순서와 무관). ISO / IEC 10646은 UCS-2 및 UCS-4 인코딩 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0b4974b8d2e6f377f9801c3b800b1ac0b7c4207d" translate="yes" xml:space="preserve">
          <source>is the name of the extension, with all &lt;code&gt;::&lt;/code&gt; replaced by &lt;code&gt;.&lt;/code&gt; (e.g. the library module for extension Foo::Bar would be copied to a</source>
          <target state="translated">확장자의 이름이며 all &lt;code&gt;::&lt;/code&gt; 은로 대체됩니다 &lt;code&gt;.&lt;/code&gt; (예 : 확장 Foo :: Bar 용 라이브러리 모듈은</target>
        </trans-unit>
        <trans-unit id="fdcdffe2e65ad3302d98757411e195b4ad6675af" translate="yes" xml:space="preserve">
          <source>is the name of the module to load. If the string specified does not contain the package separator characters &quot;::&quot;, it is assumed to refer to the full module name &quot;DBM_Filter::name&quot;. This means that the full names for canned filters, &quot;null&quot; and &quot;utf8&quot;, included with this module are:</source>
          <target state="translated">로드 할 모듈의 이름입니다. 지정된 문자열에 패키지 구분 문자 &quot;::&quot;가 포함되어 있지 않으면 전체 모듈 이름 &quot;DBM_Filter :: name&quot;을 참조하는 것으로 간주됩니다. 이는이 모듈에 포함 된 통조림 필터 &quot;null&quot;및 &quot;utf8&quot;의 전체 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0de37e5050d6ab02ac54039af959dc47e7ba20d0" translate="yes" xml:space="preserve">
          <source>is the name of the package, and is only used in comments inside the generated C code.</source>
          <target state="translated">패키지 이름이며 생성 된 C 코드 내의 주석에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45440de46c4177a6572cf02f38585860def2ca1a" translate="yes" xml:space="preserve">
          <source>is the name, and the &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; delimiters. POSIX character classes only appear</source>
          <target state="translated">이름과 &lt;code&gt;[:&lt;/code&gt; 및 &lt;code&gt;:]&lt;/code&gt; 구분 기호입니다. POSIX 문자 클래스 만 나타남</target>
        </trans-unit>
        <trans-unit id="896190cdbc3b73377c85418c4564a09f6ac5486e" translate="yes" xml:space="preserve">
          <source>is the number assigned to a character: for example, in EBCDIC the character &quot;A&quot; is usually assigned the number 193. In Unicode, the character &quot;A&quot; is assigned the number 65. All the code points in ASCII and Latin-1 (ISO 8859-1) have the same meaning in Unicode. All three of the recognized EBCDIC code sets have 256 code points, and in each code set, all 256 code points are mapped to equivalent Latin1 code points. Obviously, &quot;A&quot; will map to &quot;A&quot;, &quot;B&quot; =&amp;gt; &quot;B&quot;, &quot;%&quot; =&amp;gt; &quot;%&quot;, etc., for all printable characters in Latin1 and these code pages.</source>
          <target state="translated">예를 들어, EBCDIC에서 문자 &quot;A&quot;는 일반적으로 숫자 193으로 지정됩니다. 유니 코드에서 문자 &quot;A&quot;는 숫자 65로 지정됩니다. ASCII 및 Latin-1의 모든 코드 포인트 ( ISO 8859-1)은 유니 코드에서 동일한 의미를 갖습니다. 인식 된 EBCDIC 코드 세트 중 세 개 모두 256 개의 코드 포인트를 가지며, 각 코드 세트에서 모든 256 코드 포인트는 동등한 Latin1 코드 포인트에 매핑됩니다. 분명히 &quot;A&quot;는 Latin1 및 이러한 코드 페이지의 모든 인쇄 가능 문자에 대해 &quot;A&quot;, &quot;B&quot;=&amp;gt; &quot;B&quot;, &quot;%&quot;=&amp;gt; &quot;%&quot;등으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="44a3ced633aa8e3d881613e20fe3ca4570b01d8e" translate="yes" xml:space="preserve">
          <source>is the number of spaces to indent, defaulting to 6.</source>
          <target state="translated">들여 쓰기 할 공백 수이며 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="f35768e77df2a6fcb46d380fc0c5c7af5c55fc6d" translate="yes" xml:space="preserve">
          <source>is the object to serialize,</source>
          <target state="translated">직렬화 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="490225a54a9ac66bcdb59f92017f41f299257ed1" translate="yes" xml:space="preserve">
          <source>is the op being considered, normally an &lt;code&gt;rv2cv&lt;/code&gt; op. A pointer to the identified subroutine is returned, if it could be determined statically, and a null pointer is returned if it was not possible to determine statically.</source>
          <target state="translated">op가 고려되는 op, 일반적으로 &lt;code&gt;rv2cv&lt;/code&gt; op입니다. 식별 된 서브 루틴에 대한 포인터는 정적으로 판별 될 수 있으면 리턴되며 정적으로 판별 할 수없는 경우 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="346d72197b82381e3d135c3fd096d1560c48b51d" translate="yes" xml:space="preserve">
          <source>is the op to append to the list.</source>
          <target state="translated">목록에 추가 할 op입니다.</target>
        </trans-unit>
        <trans-unit id="2c471482064fafead892cdf7b22397b6be3fe1e9" translate="yes" xml:space="preserve">
          <source>is the op to prepend to the list, and</source>
          <target state="translated">목록 앞에 추가하는 op입니다.</target>
        </trans-unit>
        <trans-unit id="aaf68fac1b03ed7c6353ab95af2dd6b8cc61684c" translate="yes" xml:space="preserve">
          <source>is the op tree, and</source>
          <target state="translated">op 트리이며</target>
        </trans-unit>
        <trans-unit id="3684b3a23a1a941786c7c86346c047661fcfe052" translate="yes" xml:space="preserve">
          <source>is the opcode of a binary operator, such as &lt;code&gt;OP_BIT_OR&lt;/code&gt; , then an op is constructed that performs the binary operation and assigns the result to the left argument. Either way, if</source>
          <target state="translated">&lt;code&gt;OP_BIT_OR&lt;/code&gt; 과 같은 이진 연산자의 opcode 인 경우 이진 연산을 수행하고 결과를 왼쪽 인수에 할당하는 op가 구성됩니다. 어느 쪽이든</target>
        </trans-unit>
        <trans-unit id="a0a985ac039d3d2ad165d51298ff6ea64e498ec2" translate="yes" xml:space="preserve">
          <source>is the opcode.</source>
          <target state="translated">opcode입니다.</target>
        </trans-unit>
        <trans-unit id="185ceb5c9d854b05a21926141803af21e0fce555" translate="yes" xml:space="preserve">
          <source>is the outer pad name that this one mirrors. The returned pad name has the PADNAMEt_OUTER flag already set.</source>
          <target state="translated">이 것이 미러링하는 외부 패드 이름입니다. 반환 된 패드 이름에 PADNAMEt_OUTER 플래그가 이미 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ee3b580c0eceeeca1f85f9032f86a8c10b6343" translate="yes" xml:space="preserve">
          <source>is the pad offset of the scalar lexical variable that will be affected. If it is 0, the global $_ will be used.</source>
          <target state="translated">영향을받는 스칼라 사전 변수의 패드 오프셋입니다. 0이면 글로벌 $ _가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="075349611fc93d2e62829ba77d41e494ad441dd4" translate="yes" xml:space="preserve">
          <source>is the perl version the code should be backwards compatible with. It defaults to the version of perl running the subroutine. If</source>
          <target state="translated">코드가 이전 버전과 호환되어야하는 펄 버전입니다. 서브 루틴을 실행하는 perl의 버전이 기본값입니다. 만약</target>
        </trans-unit>
        <trans-unit id="2e519216b0de8348846fa9b4a5055de6958ae755" translate="yes" xml:space="preserve">
          <source>is the point whose coordinates are (a, b). Actually, it would be the vector originating from (0, 0) to (a, b). It follows that the addition of two complex numbers is a vectorial addition.</source>
          <target state="translated">좌표가 (a, b) 인 점입니다. 실제로는 (0, 0)에서 (a, b)까지의 벡터가됩니다. 두 개의 복소수를 더하는 것이 벡터를 더한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2cc4f790eddde04d02f931089ea9bbb40ba3a6a4" translate="yes" xml:space="preserve">
          <source>is the portion of the extension's name after the last &lt;code&gt;::&lt;/code&gt; , which translates to the full file specification of the shareable image.</source>
          <target state="translated">마지막 &lt;code&gt;::&lt;/code&gt; 다음의 확장자 이름 부분은 공유 가능한 이미지의 전체 파일 사양으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d16c45482f74eb9930301a0ecafdb6a012a8de5" translate="yes" xml:space="preserve">
          <source>is the portion of the extension's name following the last &lt;code&gt;::&lt;/code&gt; ), containing the XS code,</source>
          <target state="translated">XS 코드를 포함하는 마지막 &lt;code&gt;::&lt;/code&gt; ) 다음의 확장자 이름 부분입니다.</target>
        </trans-unit>
        <trans-unit id="ff4bfee209d75ed4a7ac713cfc5d716f2c1e2be4" translate="yes" xml:space="preserve">
          <source>is the previous OP optimized, whose &lt;code&gt;op_next&lt;/code&gt; points to</source>
          <target state="translated">그 최적화 이전 OP입니다 &lt;code&gt;op_next&lt;/code&gt; 포인트</target>
        </trans-unit>
        <trans-unit id="7959ce09f1e3e9e7ae880e926860f28302895b7e" translate="yes" xml:space="preserve">
          <source>is the primary name of this option. When a program executes under &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (recommended), these variables must be pre-declared with our() or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; .</source>
          <target state="translated">이 옵션의 기본 이름입니다. 프로그램이 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; (권장)에서 실행될 때 이러한 변수는 our ()로 미리 선언되거나 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dc92b1dcb6d32cc02b0b929328d0aa4e792bcfc8" translate="yes" xml:space="preserve">
          <source>is the property of a particular build of perl, and does not depend on the current process. If you do not provide the optional argument to the functions mstats_fillhash(), fill_mstats(), mstats2hash(), then the information in fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; is not updated.</source>
          <target state="translated">펄의 특정 빌드의 속성이며 현재 프로세스에 의존하지 않습니다. mstats_fillhash (), fill_mstats (), mstats2hash () 함수에 선택적 인수를 제공하지 않으면 &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; 필드의 정보 가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a2bbcb355a7bdbc9b5d8f8dbd1d6a1892216c8" translate="yes" xml:space="preserve">
          <source>is the reason for version-specific mangling of the DLL name for perl DLL.</source>
          <target state="translated">perl DLL에 대한 DLL 이름의 버전 별 관리 이유입니다.</target>
        </trans-unit>
        <trans-unit id="533e118d459a0417538dc17219094be54c0e410e" translate="yes" xml:space="preserve">
          <source>is the recommended way to report bugs in the perl interpreter itself or any of the standard library modules back to the developers; please read through the documentation for</source>
          <target state="translated">perl 인터프리터 자체 또는 표준 라이브러리 모듈의 버그를 개발자에게 다시보고하는 데 권장되는 방법입니다. 에 대한 설명서를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="059ae99546fd6d2b968c421a21e81f0cc4cf52d3" translate="yes" xml:space="preserve">
          <source>is the recommended wide native character-aware way of saying</source>
          <target state="translated">권장되는 광범위한 기본 문자 인식 방식입니다.</target>
        </trans-unit>
        <trans-unit id="b99ef0d01d54e7d02d4e29eb81f05081577ed0c4" translate="yes" xml:space="preserve">
          <source>is the root of the optree representing the scope; it is a double pointer so you can replace the OP if you need to.</source>
          <target state="translated">범위를 나타내는 optree의 루트입니다. 이중 포인터이므로 필요한 경우 OP를 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">와 같다</target>
        </trans-unit>
        <trans-unit id="5664826178886ed6dc31d7a56be756161e89003e" translate="yes" xml:space="preserve">
          <source>is the same as this:</source>
          <target state="translated">이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="ea9ca7dc351fef7638a53b6e78fc2c745436b2f0" translate="yes" xml:space="preserve">
          <source>is the same as using the program:</source>
          <target state="translated">프로그램을 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c789dc7dbbbae7937501c4047bbd4ca49aed4ac3" translate="yes" xml:space="preserve">
          <source>is the savestack index returned by &lt;code&gt;block_start&lt;/code&gt; , and</source>
          <target state="translated">savestack 지수에 의해 반환 &lt;code&gt;block_start&lt;/code&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="4a63caa46b829fcb01fe4a8c31e68b7e20d84a2f" translate="yes" xml:space="preserve">
          <source>is the scalar value to store for this key.</source>
          <target state="translated">이 키에 저장할 스칼라 값입니다.</target>
        </trans-unit>
        <trans-unit id="cb053ed2ecf771fb84e4c68638f701622bf37193" translate="yes" xml:space="preserve">
          <source>is the serialized string you returned to the engine in &lt;code&gt;STORABLE_freeze&lt;/code&gt; , and there may be an optional list of references, in the same order you gave them at serialization time, pointing to the deserialized objects (which have been processed courtesy of the Storable engine).</source>
          <target state="translated">는 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 에서 엔진에 반환 한 직렬화 된 문자열 이며 직렬화 시간에 지정한 순서대로 선택적 참조 목록이 직렬화 해제 된 오브젝트 (Storable 엔진으로 처리됨)를 가리키는 경우가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681d5ca1a6522883a0d7e74c2ad38f23f79e4445" translate="yes" xml:space="preserve">
          <source>is the shortest distance between two points on a sphere. The distance is in &lt;code&gt;$rho&lt;/code&gt; units. The &lt;code&gt;$rho&lt;/code&gt; is optional, it defaults to 1 (the unit sphere), therefore the distance defaults to radians.</source>
          <target state="translated">구의 두 점 사이의 최단 거리입니다. 거리는 &lt;code&gt;$rho&lt;/code&gt; 단위입니다. &lt;code&gt;$rho&lt;/code&gt; (1) (단위 영역)에 대한 선택적, 기본값, 라디안 때문에 거리 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bb152e814624de7f776388475643c5915a6bbc02" translate="yes" xml:space="preserve">
          <source>is the stored string for the resource object.</source>
          <target state="translated">자원 오브젝트의 저장된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7666856489819ec07e5e68fda7968ecdf4b7481e" translate="yes" xml:space="preserve">
          <source>is the string &lt;code&gt;&quot;\0X\0\0YZ&quot;&lt;/code&gt; .</source>
          <target state="translated">문자열 &lt;code&gt;&quot;\0X\0\0YZ&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4af45b7011bdf9dc23ddbc9ab955c3a70b8a6852" translate="yes" xml:space="preserve">
          <source>is the string length, not the number of strings. With an explicit repeat count for pack, the packed string is adjusted to that length. For example:</source>
          <target state="translated">문자열 수가 아니라 문자열 길이입니다. 팩에 대해 명시적인 반복 횟수를 사용하면 묶음 문자열이 해당 길이로 조정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a38238d720532a1187dfe70331e701543f8d69a2" translate="yes" xml:space="preserve">
          <source>is the type returned by &lt;code&gt;ITEM&lt;/code&gt; s that don't specify their type. It defaults to the value of &lt;code&gt;default_type()&lt;/code&gt; .</source>
          <target state="translated">유형을 지정하지 않은 &lt;code&gt;ITEM&lt;/code&gt; 에서 리턴 한 유형입니다. 기본값은 &lt;code&gt;default_type()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="62dd259d4f7a6605999861260db4a925294adb84" translate="yes" xml:space="preserve">
          <source>is the unknown layer.</source>
          <target state="translated">알 수없는 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="7ebb9cb388028784d1ffeb685835e29c39c8a750" translate="yes" xml:space="preserve">
          <source>is the version of Perl you're using, as supplied in &lt;code&gt;$]&lt;/code&gt; , with '.' converted to '_'), or</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; 에 제공된 '.'과 함께 사용중인 Perl의 버전입니다 . '_'로 변환) 또는</target>
        </trans-unit>
        <trans-unit id="334b91284c73938e4e816a510966fc314842a93e" translate="yes" xml:space="preserve">
          <source>is translated once when Perl starts up; any changes you make while Perl is running do not affect the behavior of &lt;code&gt;%ENV&lt;/code&gt; . If</source>
          <target state="translated">Perl이 시작될 때 한 번 번역됩니다. Perl이 실행되는 동안 변경 한 내용은 &lt;code&gt;%ENV&lt;/code&gt; 의 동작에 영향을 미치지 않습니다 . 만약</target>
        </trans-unit>
        <trans-unit id="a86d775dd40947cb031e2e57ff35692497a46818" translate="yes" xml:space="preserve">
          <source>is treated as number of spaces to indent by. If &lt;code&gt;declare_types&lt;/code&gt; is true a &lt;code&gt;$types&lt;/code&gt; is always declared in the perl code generated, if defined and false never declared, and if undefined &lt;code&gt;$types&lt;/code&gt; is only declared if the values in</source>
          <target state="translated">들여 쓰기 할 공백 수로 처리됩니다. 경우 &lt;code&gt;declare_types&lt;/code&gt; 이 사실 인 &lt;code&gt;$types&lt;/code&gt; 정의와 거짓 선언하지 않을 경우 항상 생성 된 펄 코드에 선언하고, 경우에 정의되지 않은 &lt;code&gt;$types&lt;/code&gt; 단지 값의 경우 선언</target>
        </trans-unit>
        <trans-unit id="10fa8676748c59212055af40992e63bcbc7c643b" translate="yes" xml:space="preserve">
          <source>is true (not empty or zero), generates the value of</source>
          <target state="translated">true (비어 있거나 0이 아님) 인 경우</target>
        </trans-unit>
        <trans-unit id="48302db9668c7d7b445abda36a22e6062f411e8f" translate="yes" xml:space="preserve">
          <source>is true on all platforms. If you want native code points for the low 256, use the &lt;code&gt;&quot;W&quot;&lt;/code&gt; template. This means that the equivalences</source>
          <target state="translated">모든 플랫폼에서 적용됩니다. 낮은 256의 기본 코드 포인트를 원하면 &lt;code&gt;&quot;W&quot;&lt;/code&gt; 템플릿을 사용하십시오 . 이것은 동등성이</target>
        </trans-unit>
        <trans-unit id="067d235b3d6dbb909f945abdb70f31cbc437b930" translate="yes" xml:space="preserve">
          <source>is true when we're part of a deep clone operation,</source>
          <target state="translated">딥 클론 작업의 일부인 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="779d38fac96628c599fdd2384e085d60ba46ca15" translate="yes" xml:space="preserve">
          <source>is true, also checks whether</source>
          <target state="translated">사실인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="45f8f7c6ce5b54b9230f2a84836b12d460e6184b" translate="yes" xml:space="preserve">
          <source>is true, ignore case. The default is to honour case.</source>
          <target state="translated">사실입니다, 대소 문자를 무시하십시오. 기본값은 대소 문자를 존중하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4056d1d8ea1ba0fdc400bcac4f4b8f6e5cb5bd11" translate="yes" xml:space="preserve">
          <source>is true, it SHOULD modify</source>
          <target state="translated">사실입니다, 수정해야합니다</target>
        </trans-unit>
        <trans-unit id="e01d069b2f9d59305c080956514566b0ca93db4c" translate="yes" xml:space="preserve">
          <source>is true, returns false.</source>
          <target state="translated">true이면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c6f61c4a55f03174097ae702fb602dd769db21e" translate="yes" xml:space="preserve">
          <source>is true, search by dictionary order (ignore anything but word characters and whitespace). The default is honour all characters.</source>
          <target state="translated">사전 순으로 검색합니다 (단어 문자 및 공백 제외). 기본값은 모든 문자를 존중합니다.</target>
        </trans-unit>
        <trans-unit id="ec9b11fcd9e9d4abe8ffa5611c1f06b9f3b4638a" translate="yes" xml:space="preserve">
          <source>is true, the AUTOLOAD subroutine falls back on AutoLoader::AUTOLOAD for all names that the constant() routine doesn't recognise.</source>
          <target state="translated">true, AUTOLOAD 서브 루틴은 constant () 루틴이 인식하지 못하는 모든 이름에 대해 AutoLoader :: AUTOLOAD로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="1c557d39d34bad4891cbefb6c9ce51864c16f310" translate="yes" xml:space="preserve">
          <source>is true, the scheme above allows the encoding to do as much as it can and tell the layer above how much that was. What is lacking at present is a mechanism to report what went wrong. The most likely interface will be an additional method call to the object, or perhaps (to avoid forcing per-stream objects on otherwise stateless encodings) an additional parameter.</source>
          <target state="translated">사실, 위의 체계는 인코딩이 가능한 한 많은 것을 수행하고 레이어에 그 정도를 알려주는 것을 허용합니다. 현재 부족한 것은 무엇이 잘못되었는지보고하는 메커니즘입니다. 가장 가능성이 높은 인터페이스는 객체에 대한 추가 메소드 호출이거나 (아마도 상태 비 저장 인코딩에서 스트림 당 객체를 강제로 피하기 위해) 추가 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="a5fb713f23256ce8adf865a7bb140abb92cbc783" translate="yes" xml:space="preserve">
          <source>is two characters, the first character is used as the left quote and the second as the right quoted; and if</source>
          <target state="translated">두 문자이며, 첫 번째 문자는 왼쪽 따옴표로 사용되고 두 번째 문자는 오른쪽 따옴표로 사용됩니다. 그리고 만약</target>
        </trans-unit>
        <trans-unit id="da08ff0a55825cc7ad3dbe2e4beefb9e6a6ab73b" translate="yes" xml:space="preserve">
          <source>is unlinked.</source>
          <target state="translated">연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99206005453caddd66236543e24f39a90d1fd368" translate="yes" xml:space="preserve">
          <source>is used &lt;b&gt;instead&lt;/b&gt; of &lt;code&gt;Compress::Zlib&lt;/code&gt; .</source>
          <target state="translated">사용하는 &lt;b&gt;대신&lt;/b&gt; 의 &lt;code&gt;Compress::Zlib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf7ac9ae1725690fb609a1273cc9ea666cc709" translate="yes" xml:space="preserve">
          <source>is used instead of &lt;code&gt;\x{&lt;i&gt;XXXX&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\x{&lt;i&gt;XXXX&lt;/i&gt;}&lt;/code&gt; 대신에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="db853bb4b5bdcd8035b1c491d509b51c38d42af0" translate="yes" xml:space="preserve">
          <source>is used instead. So we have</source>
          <target state="translated">대신 사용됩니다. 그래서 우리는</target>
        </trans-unit>
        <trans-unit id="38f21bebe9090675b3b7c95faffad6681c98ff75" translate="yes" xml:space="preserve">
          <source>is used to call a method from a Perl class. The parameter &lt;code&gt;methname&lt;/code&gt; corresponds to the name of the method to be called. Note that the class that the method belongs to is passed on the Perl stack rather than in the parameter list. This class can be either the name of the class (for a static method) or a reference to an object (for a virtual method). See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more information on static and virtual methods and &lt;a href=&quot;#Using-call_method&quot;&gt;Using call_method&lt;/a&gt; for an example of using</source>
          <target state="translated">Perl 클래스에서 메소드를 호출하는 데 사용됩니다. &lt;code&gt;methname&lt;/code&gt; 매개 변수는 호출 할 메소드의 이름에 해당합니다. 메서드가 속한 클래스는 매개 변수 목록이 아닌 Perl 스택에 전달됩니다. 이 클래스는 클래스 이름 (정적 메서드의 경우)이거나 객체에 대한 참조 (가상 메서드의 경우) 일 수 있습니다. 정적 및 가상 메소드에 대한 자세한 정보는 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조 하고 &lt;a href=&quot;#Using-call_method&quot;&gt;사용&lt;/a&gt; 예제는 call_method 사용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="174c45b58d93e19a1bf9b115b40967fdc9b93c7c" translate="yes" xml:space="preserve">
          <source>is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class에&lt;/a&gt; 전달 되는 &lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; 를 작성하는 데 사용됩니다 . iterator_factory_class 는 소스를 처리하는 방법을 파악하고이를위한 &amp;lt;TAP :: Parser :: Iterator&amp;gt;를 작성합니다. 이터레이터는 파서에서 TAP 스트림을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d08f94f5cb97d407acf7f344990711fbd64478a" translate="yes" xml:space="preserve">
          <source>is used to refer to UTF-8 on ASCII and ISO Latin based platforms and UTF-EBCDIC on EBCDIC based platforms.</source>
          <target state="translated">ASCII 및 ISO 라틴 기반 플랫폼에서 UTF-8을, EBCDIC 기반 플랫폼에서 UTF-EBCDIC을 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="caef3d98540ddc9f2f1ce1a294bcbe58f435fe11" translate="yes" xml:space="preserve">
          <source>is used to store this status.</source>
          <target state="translated">이 상태를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d148088d7797718280b1177b22c2c5191737877f" translate="yes" xml:space="preserve">
          <source>is used, the following &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;s are used:</source>
          <target state="translated">다음과 같은 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6839d76bbb7783af5dc7927fd3ea8c02821e91c" translate="yes" xml:space="preserve">
          <source>is used.</source>
          <target state="translated">사용.</target>
        </trans-unit>
        <trans-unit id="0c7240c81a5b6100a1329f457d83532b0ff32851" translate="yes" xml:space="preserve">
          <source>is used. If no password is given and the login is</source>
          <target state="translated">사용. 비밀번호가없고 로그인이</target>
        </trans-unit>
        <trans-unit id="fe97f79326aa164bdecbb65e7fb757c2dd7af24b" translate="yes" xml:space="preserve">
          <source>is used. When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is used. If the data is supposed to be UTF-8, an optional lexical warning of warning category &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; is given.</source>
          <target state="translated">사용. 디코딩 할 때 코드 포인트 U + FFFD 인 Unicode REPLACEMENT CHARACTER가 사용됩니다. 데이터가 UTF-8 인 경우 경고 범주 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 선택적 어휘 경고 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="12235ad06fa18edfce70787b2cda7be75ef01ddb" translate="yes" xml:space="preserve">
          <source>is useful because it allows other code (typically parser support code or caching variables) to be defined before the filter is invoked. However, there is often no need for such a separation.</source>
          <target state="translated">필터를 호출하기 전에 다른 코드 (일반적으로 파서 지원 코드 또는 캐싱 변수)를 정의 할 수 있기 때문에 유용합니다. 그러나 종종 이러한 분리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e47b26bd8204f22d84b37cecf46b2ae865ef9fd" translate="yes" xml:space="preserve">
          <source>is useful.</source>
          <target state="translated">유용합니다.</target>
        </trans-unit>
        <trans-unit id="40a7b397fd325b5ecbf0d373914724c1f6367724" translate="yes" xml:space="preserve">
          <source>is usually 1 for on, but higher values trigger additional warnings. See &lt;a href=&quot;#Warnings&quot;&gt;Warnings&lt;/a&gt;.</source>
          <target state="translated">일반적으로 켜져 있으면 1이지만 값이 높을수록 추가 경고가 발생합니다. &lt;a href=&quot;#Warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69bc4bb7fd74f861f5b8bca772f152dcc604661a" translate="yes" xml:space="preserve">
          <source>is valid and matches '0', '1', any alphabetic character, and the percent sign.</source>
          <target state="translated">유효하며 '0', '1', 알파벳 문자 및 퍼센트 기호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d231156292aeca125ab2ff401f5be71547c7f695" translate="yes" xml:space="preserve">
          <source>is where the main processing for the filter is done.</source>
          <target state="translated">필터의 기본 처리가 수행되는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="30e01163fe1949f10b45b91d1e13f0c7637e25e7" translate="yes" xml:space="preserve">
          <source>is written into the &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt; array, while the value previously stored there is written to</source>
          <target state="translated">에 기록 &lt;a href=&quot;#PL_check&quot;&gt;PL_check의&lt;/a&gt; 값이 이전에 저장하는 동안, 어레이가 기록된다</target>
        </trans-unit>
        <trans-unit id="680b8b11b1f1a95b7c654104af2981b4c44a0974" translate="yes" xml:space="preserve">
          <source>is your blessed reference for this particular instance.</source>
          <target state="translated">이 특별한 사례에 대한 여러분의 축복 된 참조입니다.</target>
        </trans-unit>
        <trans-unit id="637ede9f0bac88412365638ad04d0f903dece281" translate="yes" xml:space="preserve">
          <source>is zero or</source>
          <target state="translated">0 또는</target>
        </trans-unit>
        <trans-unit id="da78c7a4809cb6ce24ac8e29b2195288ba32cd34" translate="yes" xml:space="preserve">
          <source>is zero, then a plain scalar or list assignment is constructed. Which type of assignment it is is automatically determined.</source>
          <target state="translated">0이면 일반 스칼라 또는 목록 할당이 구성됩니다. 할당 유형은 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="623d50572aae446dc358fd966327ce8c9a0ed204" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the lowercase mapping for</source>
          <target state="translated">비어 있지 않은 경우,</target>
        </trans-unit>
        <trans-unit id="3d7682c10121c3528254ad891855f87cf827fae6" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the titlecase mapping for</source>
          <target state="translated">비어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="17656293490b52e28e817d6f958f58501e80a596" translate="yes" xml:space="preserve">
          <source>is, if non-empty, the uppercase mapping for</source>
          <target state="translated">비어 있지 않은 경우에 대한 대문자 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="cb18cfba59a431e4fe8a80b174c133778446c806" translate="yes" xml:space="preserve">
          <source>is, in short, an idhash with auto-registry. When an object (or, indeed, any reference) is used as a fieldhash key, the fieldhash is automatically registered for garbage collection with the object, as if &lt;code&gt;register $obj, \ %fieldhash&lt;/code&gt; had been called.</source>
          <target state="translated">간단히 말해서 자동 등록 기능이있는 idhash입니다. 객체 (또는 실제로 참조)가 필드 해시 키로 사용될 때, 필드 &lt;code&gt;register $obj, \ %fieldhash&lt;/code&gt; 가 호출 된 것처럼 fieldhash 가 객체와 함께 가비지 수집을 위해 자동으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="2eb3ddf53a44d0014465dbf2511b96e2ca53542f" translate="yes" xml:space="preserve">
          <source>is_even()</source>
          <target state="translated">is_even()</target>
        </trans-unit>
        <trans-unit id="11dbccec36ef1a03c703d514dd31a8d0c0798066" translate="yes" xml:space="preserve">
          <source>is_int()</source>
          <target state="translated">is_int()</target>
        </trans-unit>
        <trans-unit id="81c4be558fcd3af8cca4b285c2962c5989f928f3" translate="yes" xml:space="preserve">
          <source>is_make_type</source>
          <target state="translated">is_make_type</target>
        </trans-unit>
        <trans-unit id="5e192aa23e81e4d04b32a6b074858b9c768cac41" translate="yes" xml:space="preserve">
          <source>is_neg()/is_negative()</source>
          <target state="translated">is_neg()/is_negative()</target>
        </trans-unit>
        <trans-unit id="2ffcb1a862f4b027f0ab6152305df1200860e1b3" translate="yes" xml:space="preserve">
          <source>is_odd()</source>
          <target state="translated">is_odd()</target>
        </trans-unit>
        <trans-unit id="70c8f014e9c6a6d99e78620643d9bc507b9fb363" translate="yes" xml:space="preserve">
          <source>is_one()</source>
          <target state="translated">is_one()</target>
        </trans-unit>
        <trans-unit id="aeee4fc11afe65037967eaa9c965d8912ecf4589" translate="yes" xml:space="preserve">
          <source>is_pos()/is_positive()</source>
          <target state="translated">is_pos()/is_positive()</target>
        </trans-unit>
        <trans-unit id="e07cc517821b5551e950dff4acb3c80a32d29930" translate="yes" xml:space="preserve">
          <source>is_utf8</source>
          <target state="translated">is_utf8</target>
        </trans-unit>
        <trans-unit id="1ddb13cfa4feb404c5ec5eefd16e3616cef8e112" translate="yes" xml:space="preserve">
          <source>is_zero()</source>
          <target state="translated">is_zero()</target>
        </trans-unit>
        <trans-unit id="8ffda1fa78645c009ffa2b7d1f049da6785b1dfd" translate="yes" xml:space="preserve">
          <source>isdual</source>
          <target state="translated">isdual</target>
        </trans-unit>
        <trans-unit id="ee2ebf5133051bf39cd49d499acea403e44a4978" translate="yes" xml:space="preserve">
          <source>isn't</source>
          <target state="translated">isn't</target>
        </trans-unit>
        <trans-unit id="9d94e5f09ea80b838abc637f6cc2137bf9b40766" translate="yes" xml:space="preserve">
          <source>isn't available,</source>
          <target state="translated">사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="b643075840def260815468ce095b78f495761c52" translate="yes" xml:space="preserve">
          <source>isn't available, it converts it to plain text with the external command</source>
          <target state="translated">사용할 수 없으면 외부 명령을 사용하여 일반 텍스트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e16b96ecf693e658c2424ac211a1dfdc920c5a12" translate="yes" xml:space="preserve">
          <source>isn't given, it defaults to &lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">제공되지 않으면 기본값은 &lt;code&gt;STDIN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75e52afea6c5f5fb7c62edc35d62baf474ddc2bf" translate="yes" xml:space="preserve">
          <source>isn't given, the formatted output is written to &lt;code&gt;STDOUT&lt;/code&gt; . Several POD files can be processed in the same &lt;b&gt;pod2man&lt;/b&gt; invocation (saving module load and compile times) by providing multiple pairs of</source>
          <target state="translated">지정되지 않은 경우 형식화 된 출력은 &lt;code&gt;STDOUT&lt;/code&gt; 에 작성됩니다 . 여러 POD 파일을 여러 쌍을 제공 하여 동일한 &lt;b&gt;pod2man&lt;/b&gt; 호출 (모듈로드 및 컴파일 시간 절약) 에서 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="464bc0306867e48eb03dffa3c82d60e097b5207c" translate="yes" xml:space="preserve">
          <source>isn't given, the formatted output is written to &lt;code&gt;STDOUT&lt;/code&gt; . Several POD files can be processed in the same &lt;b&gt;pod2text&lt;/b&gt; invocation (saving module load and compile times) by providing multiple pairs of</source>
          <target state="translated">지정되지 않은 경우 형식화 된 출력은 &lt;code&gt;STDOUT&lt;/code&gt; 에 작성됩니다 . 여러 POD 파일을 여러 쌍을 제공 하여 동일한 &lt;b&gt;pod2text&lt;/b&gt; 호출 (모듈로드 및 컴파일 시간 절약) 로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="96d2a4fbb9059f5330274f55be6262e3cbc96904" translate="yes" xml:space="preserve">
          <source>issue 21. See &lt;a href=&quot;http://interglacial.com/tpj/21/&quot;&gt;http://interglacial.com/tpj/21/&lt;/a&gt;</source>
          <target state="translated">이슈 21. &lt;a href=&quot;http://interglacial.com/tpj/21/&quot;&gt;http://interglacial.com/tpj/21/&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="f1da083affe279217f988b36f92bb98ac176b46e" translate="yes" xml:space="preserve">
          <source>issymlink.U</source>
          <target state="translated">issymlink.U</target>
        </trans-unit>
        <trans-unit id="45098fc2aa4e6608f56f987d63d68920609dbbd1" translate="yes" xml:space="preserve">
          <source>isvstring</source>
          <target state="translated">isvstring</target>
        </trans-unit>
        <trans-unit id="073c2d116dfe6c35185754930917fb5ca91ecdec" translate="yes" xml:space="preserve">
          <source>isweak</source>
          <target state="translated">isweak</target>
        </trans-unit>
        <trans-unit id="6c5522ca8af86fc5069b737bb8892b3ea61002c2" translate="yes" xml:space="preserve">
          <source>it</source>
          <target state="translated">it</target>
        </trans-unit>
        <trans-unit id="05a4caf354063cd0b1c1282164b973f1a8b3ca03" translate="yes" xml:space="preserve">
          <source>it as though it were a two-dimensional one. This is actually the way almost all C multidimensional arrays work as well.</source>
          <target state="translated">마치 마치 2 차원적인 것처럼 보입니다. 이것은 실제로 거의 모든 C 다차원 배열이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="61d4d6f86f6911f9c0b355a4b638b81c72da1544" translate="yes" xml:space="preserve">
          <source>it depends</source>
          <target state="translated">때에 따라 다르지</target>
        </trans-unit>
        <trans-unit id="e9ed3745b6da2ff65c1330a469e0e606269e1aea" translate="yes" xml:space="preserve">
          <source>it does any key lookups. Anything more complicated than a simple scalar variable must use methods 2 or 3 below. However, a &quot;simple scalar&quot; includes an identifier that itself uses method 1 recursively. Therefore, the following prints &quot;howdy&quot;.</source>
          <target state="translated">모든 키 조회를 수행합니다. 간단한 스칼라 변수보다 복잡한 것은 아래의 방법 2 또는 3을 사용해야합니다. 그러나 &quot;단순 스칼라&quot;에는 방법 1을 재귀 적으로 사용하는 식별자가 포함됩니다. 따라서 다음은 &quot;howdy&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ba8e66e3faac8aa41508246830eac4c0ce1367d9" translate="yes" xml:space="preserve">
          <source>it does.</source>
          <target state="translated">그렇습니다.</target>
        </trans-unit>
        <trans-unit id="0586fd2e9ea179909692618fde703704590b2778" translate="yes" xml:space="preserve">
          <source>it doesn't make sense for &lt;code&gt;$result&lt;/code&gt; to be tainted.</source>
          <target state="translated">&lt;code&gt;$result&lt;/code&gt; 가 오염되는 것은 이치에 맞지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67860f13d2c0675d8e22bfdbbcae1da9fb06bf2d" translate="yes" xml:space="preserve">
          <source>it has been determined whether or not it is part of a POD paragraph). The parameter &lt;code&gt;$text&lt;/code&gt; is the input line; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number of the corresponding text line.</source>
          <target state="translated">POD 단락의 일부인지 여부가 결정되었습니다.) &lt;code&gt;$text&lt;/code&gt; 매개 변수 는 입력 행입니다. &lt;code&gt;$line_num&lt;/code&gt; 매개 변수 는 해당 텍스트 행의 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="3870d4bae6a615c7d0c3110b61ef4d9f15473beb" translate="yes" xml:space="preserve">
          <source>it has no prototype (&lt;code&gt;PROTOTYPE&lt;/code&gt; field is missing).</source>
          <target state="translated">프로토 타입이 없습니다 ( &lt;code&gt;PROTOTYPE&lt;/code&gt; 필드가 누락되었습니다).</target>
        </trans-unit>
        <trans-unit id="1690d6efd12aa7c091debf143ad3278ea0ef7e39" translate="yes" xml:space="preserve">
          <source>it is executed directly instead of via your system's command shell (see below).</source>
          <target state="translated">시스템의 명령 셸을 통하지 않고 직접 실행됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="0c696ff0d66734bc1af537a36f453902c087a5ec" translate="yes" xml:space="preserve">
          <source>it is implemented, they just need to know</source>
          <target state="translated">구현되어 있으면 알 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aff30627b547c2a01a9bb55f014f8a4f50a64aa" translate="yes" xml:space="preserve">
          <source>it is necessary to make a note of their addresses--thus the two variables &lt;code&gt;sva&lt;/code&gt; and &lt;code&gt;svb&lt;/code&gt; .</source>
          <target state="translated">주소를 적어 둘 필요가 있습니다. 따라서 두 변수 &lt;code&gt;sva&lt;/code&gt; 및 &lt;code&gt;svb&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e9959c9fffd7b05f3976705116788c5f70c5388" translate="yes" xml:space="preserve">
          <source>it is necessary to use either this:</source>
          <target state="translated">다음 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="310129d7662f2f9acf2e335aff9582946ee14a1c" translate="yes" xml:space="preserve">
          <source>it is not currently executed (see &lt;code&gt;DEPTH&lt;/code&gt; );</source>
          <target state="translated">현재 실행되지 않습니다 ( &lt;code&gt;DEPTH&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0a9795eca7a07fa1ec5f54c4aca84e9b6ddd94be" translate="yes" xml:space="preserve">
          <source>it is probably because your LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). The reason this causes a problem is quite subtle. The file libdl.so.1.0 actually *only* contains functions which generate 'stub interception failed' errors! The runtime linker intercepts links to &quot;/usr/lib/libdl.so.1.0&quot; and links in internal implementations of those functions instead. [Thanks to Tim Bunce for this explanation.]</source>
          <target state="translated">LD_LIBRARY_PATH 환경 변수에 / usr / lib에 대한 심볼릭 링크 디렉토리 (예 : / lib)가 포함되어있을 수 있습니다. 이것이 문제를 일으키는 이유는 매우 미묘합니다. libdl.so.1.0 파일은 실제로 * 전용 *에는 '스텁 차단 실패'오류를 생성하는 함수가 포함되어 있습니다! 런타임 링커는 &quot;/usr/lib/libdl.so.1.0&quot;에 대한 링크를 인터셉트하고 대신 해당 함수의 내부 구현에 링크합니다. [이 설명을 해주신 Tim Bunce에게 감사드립니다.]</target>
        </trans-unit>
        <trans-unit id="612612823271c4dd6d5f3ffd06e4c196c2f4cc3b" translate="yes" xml:space="preserve">
          <source>it is the parser who called the handler. The second line will print backtrace and die if &lt;code&gt;Carp&lt;/code&gt; was available. The third line will be executed only if &lt;code&gt;Carp&lt;/code&gt; was not available.</source>
          <target state="translated">핸들러를 호출 한 것은 파서입니다. 두 번째 줄은 &lt;code&gt;Carp&lt;/code&gt; 를 사용할 수있는 경우 역 추적을 인쇄하고 죽습니다 . 세 번째 줄은 &lt;code&gt;Carp&lt;/code&gt; 를 사용할 수없는 경우에만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b58c9409bf16cf04174e7afa22fe71b231a9b517" translate="yes" xml:space="preserve">
          <source>it means you need to (re)run the</source>
          <target state="translated">그것은 당신이 (재) 실행해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8f446b862762106f931a1429d6239d02e83adc85" translate="yes" xml:space="preserve">
          <source>it prints two lines of output, a perhaps more useful outcome.</source>
          <target state="translated">두 줄의 출력을 인쇄하여 더 유용한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a6a63104db0674a31400a90bd3f6dedc040f2d3" translate="yes" xml:space="preserve">
          <source>it really means</source>
          <target state="translated">정말 의미합니다</target>
        </trans-unit>
        <trans-unit id="13fd5928c332d6966fcfc1b3936835e1f2fdd3ce" translate="yes" xml:space="preserve">
          <source>it should match, we would use the &lt;b&gt;anchor&lt;/b&gt; metacharacters &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; . The anchor &lt;code&gt;^&lt;/code&gt; means match at the beginning of the string and the anchor &lt;code&gt;$&lt;/code&gt; means match at the end of the string, or before a newline at the end of the string. Some examples:</source>
          <target state="translated">일치해야합니다. 우리는 &lt;b&gt;앵커&lt;/b&gt; 메타 문자 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 를 사용 합니다. 앵커 &lt;code&gt;^&lt;/code&gt; 는 문자열의 시작에서 일치를 의미하고 앵커 &lt;code&gt;$&lt;/code&gt; 는 문자열의 끝에서 또는 문자열의 끝에서 개행 이전에 일치하는 것을 의미합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="e296f0161e64279421db490742dbd931d8bc8114" translate="yes" xml:space="preserve">
          <source>it uses.</source>
          <target state="translated">사용합니다.</target>
        </trans-unit>
        <trans-unit id="9740d8c8a2509877b0874f04a9fb40b6504cad81" translate="yes" xml:space="preserve">
          <source>it was given. There are a few types of Iterators available by default, all sub-classes of &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;. Choosing which iterator to use is the responsibility of the</source>
          <target state="translated">그것은 주어졌다. &lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt; 의 모든 서브 클래스 인 기본적으로 사용 가능한 반복자 유형이 몇 가지 있습니다 . 사용할 반복자를 선택하는 것은</target>
        </trans-unit>
        <trans-unit id="90f05049b267c672ac20306b59373a3c6dd17d68" translate="yes" xml:space="preserve">
          <source>it will be opened for reading. Likewise, the second argument will be written to. If the second argument does not exist but the parent directory does exist, then it will be created. Trying to copy a file into a non-existent directory is an error. Trying to copy a file on top of itself is also an error. &lt;code&gt;copy&lt;/code&gt; will not overwrite read-only files.</source>
          <target state="translated">읽기 위해 열립니다. 마찬가지로, 두 번째 주장이 쓰여질 것입니다. 두 번째 인수는 존재하지 않지만 상위 디렉토리는 존재하면 작성됩니다. 존재하지 않는 디렉토리로 파일을 복사하려고하면 오류가 발생합니다. 파일 자체를 복사하려고하면 오류가 발생합니다. &lt;code&gt;copy&lt;/code&gt; 는 읽기 전용 파일을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85077e36260e1c964f3bb3d589eff39a4e93a0b6" translate="yes" xml:space="preserve">
          <source>it will still be a gv.</source>
          <target state="translated">여전히 gv가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="25c14feb4e8e18138f532db9509b63ad8f630a23" translate="yes" xml:space="preserve">
          <source>it would be better to keep a hash around like %USER_VARS and have variable references actually refer to entries in that hash:</source>
          <target state="translated">% USER_VARS와 같이 해시를 유지하고 변수 참조가 실제로 해당 해시의 항목을 참조하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e5c94463c2fd1216a37265c6eb1ebb573441081f" translate="yes" xml:space="preserve">
          <source>it).</source>
          <target state="translated">it).</target>
        </trans-unit>
        <trans-unit id="7ab962e80665cb9cc68421c37b838570afc27fae" translate="yes" xml:space="preserve">
          <source>it.</source>
          <target state="translated">it.</target>
        </trans-unit>
        <trans-unit id="0a0be36bcf81cae54b4e92e27a7da272f28892ba" translate="yes" xml:space="preserve">
          <source>it; and it also doubles as a note about why it's being skipped. So in the first codeblock above, read the code as &quot;skip if MSWin -- (otherwise) test whether &lt;code&gt;thing($foo)&lt;/code&gt; is &lt;code&gt;thing($bar)&lt;/code&gt; &quot; or for the second case, &quot;skip unless MSWin...&quot;.</source>
          <target state="translated">그것; 또한 왜 건너 뛰는 지에 대한 메모로도 두 배가됩니다. 따라서 위의 첫 번째 코드 블록에서 &quot;MSWin if skip-(그렇지 않으면) &lt;code&gt;thing($foo)&lt;/code&gt; 가 &lt;code&gt;thing($bar)&lt;/code&gt; &quot; 인지 여부를 테스트 하거나 두 번째 경우에는 &quot;skip if MSWin ...&quot;이라고 코드를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="90665ca6c8810138a69c5d8421143bbaa3be9fa1" translate="yes" xml:space="preserve">
          <source>italic</source>
          <target state="translated">italic</target>
        </trans-unit>
        <trans-unit id="939d66a4b75f040c931e31b7a89333e45cd668cc" translate="yes" xml:space="preserve">
          <source>iterate</source>
          <target state="translated">iterate</target>
        </trans-unit>
        <trans-unit id="bef4aaaa11015ef79d88f3701f4c69ad690eb4c7" translate="yes" xml:space="preserve">
          <source>iterator</source>
          <target state="translated">iterator</target>
        </trans-unit>
        <trans-unit id="4131f600eefaae3bd0bdca31fdfbd0ee66fd34df" translate="yes" xml:space="preserve">
          <source>iterator factory</source>
          <target state="translated">반복자 공장</target>
        </trans-unit>
        <trans-unit id="3bdff15b39ed0956a3ac055e7cb35e717df3ac4f" translate="yes" xml:space="preserve">
          <source>iterators</source>
          <target state="translated">iterators</target>
        </trans-unit>
        <trans-unit id="02b745e9b5e2fad4405c0c56805599232ff0da14" translate="yes" xml:space="preserve">
          <source>ithreads</source>
          <target state="translated">ithreads</target>
        </trans-unit>
        <trans-unit id="729ee8658c32bfd976df663131e9d855fadb0bd2" translate="yes" xml:space="preserve">
          <source>its parent classes are called (in depth-first, left-to-right order).</source>
          <target state="translated">부모 클래스는 (깊이 우선, 왼쪽에서 오른쪽 순서로) 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="81f3fb4eaedb1a632822e8e071eaf79b0daa2a96" translate="yes" xml:space="preserve">
          <source>itself is perfectly fine and probably best to quote from, provided you can find a suitable quote there.</source>
          <target state="translated">거기에서 적절한 인용문을 찾을 수 있다면 그 자체로는 완벽하고 훌륭하며 인용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a6597c4b9bc3a39747ccb10ba2dc28b25654f99e" translate="yes" xml:space="preserve">
          <source>itself, or the UNIX error message when it is not (i.e.</source>
          <target state="translated">자체 또는 그렇지 않은 경우 UNIX 오류 메시지 (예 :</target>
        </trans-unit>
        <trans-unit id="a448ee962c26966eb9ffb37083bad9b8255c68a0" translate="yes" xml:space="preserve">
          <source>itself. &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; was made available for hashes, and weak references now call uvar &lt;code&gt;get&lt;/code&gt; magic after a weakref has been cleared. The first feature is used to make field hashes intercept their keys upon access. The second one triggers garbage collection.</source>
          <target state="translated">그 자체. &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 는 해시에 사용할 수있게되었으며 약한 참조는 약한 참조 가 지워진 후 uvar &lt;code&gt;get&lt;/code&gt; 마법 이라고 부릅니다 . 첫 번째 기능은 필드 해시가 액세스 할 때 키를 가로채는 데 사용됩니다. 두 번째는 가비지 수집을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="9080b7d46b4fc0390c228c28d01f17857e481e91" translate="yes" xml:space="preserve">
          <source>itself. This implements standard prototype processing. It can be changed, for a particular subroutine, by &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;.</source>
          <target state="translated">그 자체. 표준 프로토 타입 처리를 구현합니다. 특정 서브 루틴의 경우 &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; 에 의해 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e65c84ea5ae8f9cb5f144e8560472c4a38ee73a9" translate="yes" xml:space="preserve">
          <source>itself: &lt;code&gt;NaN&lt;/code&gt; != &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">자체 : &lt;code&gt;NaN&lt;/code&gt; ! = &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e42ca91c60743cbedfdb7a86d0e6ca643050fa2" translate="yes" xml:space="preserve">
          <source>itself; you'll need some other means, (like &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; or &lt;a href=&quot;#casespec()&quot;&gt;casespec()&lt;/a&gt; to get the full mapping.</source>
          <target state="translated">그 자체; 전체 매핑을 얻으려면 &lt;a href=&quot;#charprop()&quot;&gt;charprop ()&lt;/a&gt; 또는 &lt;a href=&quot;#casespec()&quot;&gt;casespec ()&lt;/a&gt; 과 같은 다른 방법이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="5c2dd944dde9e08881bef0894fe7b22a5c9c4b06" translate="yes" xml:space="preserve">
          <source>j</source>
          <target state="translated">j</target>
        </trans-unit>
        <trans-unit id="ccb3219ddb6265babc86f9f9b3767241cd3c266d" translate="yes" xml:space="preserve">
          <source>jhi!at!iki.fi</source>
          <target state="translated">jhi!at!iki.fi</target>
        </trans-unit>
        <trans-unit id="89bd3e10c41e1404acf15c04b11b8f2b9abbc72b" translate="yes" xml:space="preserve">
          <source>jhi@iki.fi</source>
          <target state="translated">jhi@iki.fi</target>
        </trans-unit>
        <trans-unit id="b8c394cc17419bc3809e014896111af95fe7d3a9" translate="yes" xml:space="preserve">
          <source>job to watch CPAN, you could list all modules that need updating. First a quick and dirty way:</source>
          <target state="translated">CPAN을 살펴 보려면 업데이트가 필요한 모든 모듈을 나열 할 수 있습니다. 먼저 빠르고 더러운 방법 :</target>
        </trans-unit>
        <trans-unit id="c455b38e076228392d1c751d14fe95da50519334" translate="yes" xml:space="preserve">
          <source>join</source>
          <target state="translated">join</target>
        </trans-unit>
        <trans-unit id="5f399a3111bea0589bf7db3e0dfaba80af64407b" translate="yes" xml:space="preserve">
          <source>join EXPR,LIST</source>
          <target state="translated">EXPR, LIST 가입</target>
        </trans-unit>
        <trans-unit id="62d2c6aa803cca4cf9c65aa3e227bf0b61706b76" translate="yes" xml:space="preserve">
          <source>join is the same as catfile.</source>
          <target state="translated">join은 catfile과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ca46fff3e67ab1620d4b1bde0a7edc21da9ca6b3" translate="yes" xml:space="preserve">
          <source>json_backend</source>
          <target state="translated">json_backend</target>
        </trans-unit>
        <trans-unit id="d95b79cfc988b3b165ceb830a9c8932d1b52cf18" translate="yes" xml:space="preserve">
          <source>just</source>
          <target state="translated">just</target>
        </trans-unit>
        <trans-unit id="eb0fc5922423716c9914d354f8212f007cc1f6ca" translate="yes" xml:space="preserve">
          <source>just like perl itself:</source>
          <target state="translated">펄 자체처럼 :</target>
        </trans-unit>
        <trans-unit id="f9d5ea726b7acb7a642a990df1dd7b92e603dab0" translate="yes" xml:space="preserve">
          <source>just the inverse of &lt;code&gt;:crlf&lt;/code&gt; : other layers which would affect the binary nature of the stream are also removed or disabled.</source>
          <target state="translated">스트림의 이진 특성에 영향을 줄 수있는 &lt;code&gt;:crlf&lt;/code&gt; : 다른 레이어 의 역수 도 제거되거나 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="13fbd79c3d390e5d6585a21e11ff5ec1970cff0c" translate="yes" xml:space="preserve">
          <source>k</source>
          <target state="translated">k</target>
        </trans-unit>
        <trans-unit id="725ad17778a9ca9c4dcb68f53d1af1a0f509df54" translate="yes" xml:space="preserve">
          <source>k*pi/n</source>
          <target state="translated">k*pi/n</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="e2929051408c4d0d174e1354d7182008186218cd" translate="yes" xml:space="preserve">
          <source>key replacement</source>
          <target state="translated">키 교체</target>
        </trans-unit>
        <trans-unit id="0ec928f0548a391077ef8e978657769f625ace95" translate="yes" xml:space="preserve">
          <source>keylen</source>
          <target state="translated">keylen</target>
        </trans-unit>
        <trans-unit id="a9d95efcc011e377892f55ea4ef1cf8af1bde1da" translate="yes" xml:space="preserve">
          <source>keypv</source>
          <target state="translated">keypv</target>
        </trans-unit>
        <trans-unit id="5944ae25418ceabcf285dca1d721b77888dac89b" translate="yes" xml:space="preserve">
          <source>keys</source>
          <target state="translated">keys</target>
        </trans-unit>
        <trans-unit id="163ff7ee9e20183b56bf466efd2816a9b2392c0c" translate="yes" xml:space="preserve">
          <source>keys ARRAY</source>
          <target state="translated">키 배열</target>
        </trans-unit>
        <trans-unit id="63c866479b55938ab0686f9368e0bdc3b1e2f798" translate="yes" xml:space="preserve">
          <source>keys EXPR</source>
          <target state="translated">EXPR 키</target>
        </trans-unit>
        <trans-unit id="a39fdcb0ec2b35fbb1b985ec7492d546a128c563" translate="yes" xml:space="preserve">
          <source>keys HASH</source>
          <target state="translated">키 해시</target>
        </trans-unit>
        <trans-unit id="4401f84be4185188a39d2f59b42a57a00108ee4e" translate="yes" xml:space="preserve">
          <source>keys and values are NULL terminated. Unfortunately when Perl writes to DBM databases it doesn't use NULL termination, so your Perl application will have to manage NULL termination itself. When you write to the database you will have to use something like this:</source>
          <target state="translated">키와 값은 NULL로 종료됩니다. 불행히도 Perl은 DBM 데이터베이스에 쓸 때 NULL 종료를 사용하지 않으므로 Perl 애플리케이션은 NULL 종료 자체를 관리해야합니다. 데이터베이스에 쓸 때는 다음과 같은 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a2a3d72597603ea8cff70de3f7051f49cb67f9f" translate="yes" xml:space="preserve">
          <source>keys and values.</source>
          <target state="translated">키와 값.</target>
        </trans-unit>
        <trans-unit id="6589889c96d31e938e419098b015444a16a2c3a2" translate="yes" xml:space="preserve">
          <source>kflags</source>
          <target state="translated">kflags</target>
        </trans-unit>
        <trans-unit id="c80f5bc166cd6739ba9ba6d94acabc0aa01494da" translate="yes" xml:space="preserve">
          <source>kill</source>
          <target state="translated">kill</target>
        </trans-unit>
        <trans-unit id="a4bc7bbb272a294f330eb938da9fb51c2fcc02c3" translate="yes" xml:space="preserve">
          <source>kill SIGNAL</source>
          <target state="translated">신호 제거</target>
        </trans-unit>
        <trans-unit id="504bcebca3affd57921d61d9a779cae627657943" translate="yes" xml:space="preserve">
          <source>kill SIGNAL, LIST</source>
          <target state="translated">SIGNAL, LIST 종료</target>
        </trans-unit>
        <trans-unit id="23b08d7df16abcdad774dace7145903fd2c37725" translate="yes" xml:space="preserve">
          <source>kill(3)</source>
          <target state="translated">kill(3)</target>
        </trans-unit>
        <trans-unit id="8c834f073d4d1ae81525a98626e15bf01e8a71bd" translate="yes" xml:space="preserve">
          <source>kind of session by using the arguments &lt;code&gt;/fs&lt;/code&gt;, &lt;code&gt;/pm&lt;/code&gt; or &lt;code&gt;/win&lt;/code&gt; switches of the command &lt;code&gt;start&lt;/code&gt; (of</source>
          <target state="translated">종류 세션의 인수를 사용하여 &lt;code&gt;/fs&lt;/code&gt; , &lt;code&gt;/pm&lt;/code&gt; 또는 &lt;code&gt;/win&lt;/code&gt; 명령의 스위치 &lt;code&gt;start&lt;/code&gt; (의</target>
        </trans-unit>
        <trans-unit id="97accafb53377fd569bc568d3ffe8da985a568ef" translate="yes" xml:space="preserve">
          <source>know</source>
          <target state="translated">know</target>
        </trans-unit>
        <trans-unit id="dd21e4f392e3c1d0f7571bd4b34164706b1a24c3" translate="yes" xml:space="preserve">
          <source>know with absolute certainty</source>
          <target state="translated">확실하게 알다</target>
        </trans-unit>
        <trans-unit id="263c649e2937afe094a801dc2f1f8ff91cdebe67" translate="yes" xml:space="preserve">
          <source>known_to_exist</source>
          <target state="translated">known_to_exist</target>
        </trans-unit>
        <trans-unit id="4a8d3339c1aceb6e28d45d54ff0a8e537fcb31e8" translate="yes" xml:space="preserve">
          <source>ksh527rt.zip</source>
          <target state="translated">ksh527rt.zip</target>
        </trans-unit>
        <trans-unit id="07c342be6e560e7f43842e2e21b774e61d85f047" translate="yes" xml:space="preserve">
          <source>l</source>
          <target state="translated">l</target>
        </trans-unit>
        <trans-unit id="64c65374dbab6fe3762748196d9d3a9610e2e5a9" translate="yes" xml:space="preserve">
          <source>label</source>
          <target state="translated">label</target>
        </trans-unit>
        <trans-unit id="d6658a9defae77f1757cb09d67b818757cd24486" translate="yes" xml:space="preserve">
          <source>lack</source>
          <target state="translated">lack</target>
        </trans-unit>
        <trans-unit id="ff1aba81fe7b089d82562a718b3ef9c7213d6698" translate="yes" xml:space="preserve">
          <source>langinfo(3)</source>
          <target state="translated">langinfo(3)</target>
        </trans-unit>
        <trans-unit id="931a14650ec8c7a040f2eefd85a897f9590dc3c8" translate="yes" xml:space="preserve">
          <source>langinfo.h</source>
          <target state="translated">langinfo.h</target>
        </trans-unit>
        <trans-unit id="e11523c5ff23fc1600aca2d8ee5adb542c5ce4b3" translate="yes" xml:space="preserve">
          <source>language</source>
          <target state="translated">language</target>
        </trans-unit>
        <trans-unit id="07fd754169cbc14f32d8424ed7ff8efb4e828cf8" translate="yes" xml:space="preserve">
          <source>language code</source>
          <target state="translated">언어 코드</target>
        </trans-unit>
        <trans-unit id="71d7102c1da6fbbced9f583db6704477f11ced56" translate="yes" xml:space="preserve">
          <source>language_territory</source>
          <target state="translated">language_territory</target>
        </trans-unit>
        <trans-unit id="0265a28be8ae180d9d231879cc522733ad7d4408" translate="yes" xml:space="preserve">
          <source>languages</source>
          <target state="translated">languages</target>
        </trans-unit>
        <trans-unit id="2f1e0b0dc470f71151ce6738e9f7be38a0687dde" translate="yes" xml:space="preserve">
          <source>large enough to take one return value.</source>
          <target state="translated">하나의 반환 값을 취할 수있을만큼 큽니다.</target>
        </trans-unit>
        <trans-unit id="741ba1f0f1533ece02fff2b65d8dc483692f9691" translate="yes" xml:space="preserve">
          <source>larry (at) wall.org</source>
          <target state="translated">larry (at) wall.org</target>
        </trans-unit>
        <trans-unit id="213ed3ea453bf610688ff8041e0a3b7b6abb5e6e" translate="yes" xml:space="preserve">
          <source>last</source>
          <target state="translated">last</target>
        </trans-unit>
        <trans-unit id="b30b6273b59dad174d1c29542b336882ec42ce47" translate="yes" xml:space="preserve">
          <source>last EXPR</source>
          <target state="translated">마지막 EXPR</target>
        </trans-unit>
        <trans-unit id="8d3bc2f9e8b72940971c417ffcb4831427b7f071" translate="yes" xml:space="preserve">
          <source>last LABEL</source>
          <target state="translated">마지막 라벨</target>
        </trans-unit>
        <trans-unit id="6fbebf65db8c9e119786b6069e55d8a57449239d" translate="yes" xml:space="preserve">
          <source>last successful match</source>
          <target state="translated">마지막으로 성공한 경기</target>
        </trans-unit>
        <trans-unit id="6fc4291b99bc40e0a1e6058f237b9032e2a2cb98" translate="yes" xml:space="preserve">
          <source>last_error()</source>
          <target state="translated">last_error()</target>
        </trans-unit>
        <trans-unit id="5f4c3aef2b495c636e2cc379a207951285dc8022" translate="yes" xml:space="preserve">
          <source>laszlo.molnar@eth.ericsson.se</source>
          <target state="translated">laszlo.molnar@eth.ericsson.se</target>
        </trans-unit>
        <trans-unit id="d54c2aa2f61603022c71493f093f0c718419ca13" translate="yes" xml:space="preserve">
          <source>layer</source>
          <target state="translated">layer</target>
        </trans-unit>
        <trans-unit id="388d8a5d86f4ff95a659c127ad269f1e2328643c" translate="yes" xml:space="preserve">
          <source>layer uses native &quot;handle&quot; IO rather than a Unix-like numeric file descriptor layer. Known to be buggy in this release (5.14).</source>
          <target state="translated">layer는 Unix와 같은 숫자 파일 디스크립터 레이어가 아닌 네이티브 &quot;handle&quot;IO를 사용합니다. 이 릴리스에서 버그가있는 것으로 알려져 있습니다 (5.14).</target>
        </trans-unit>
        <trans-unit id="9f422a843a976db035a8ac6578fed83f92e8401c" translate="yes" xml:space="preserve">
          <source>layer uses the native &quot;handle&quot; IO rather than the unix-like numeric file descriptor layer. Known to be buggy as of perl 5.8.2.</source>
          <target state="translated">layer는 유닉스 계열의 숫자 파일 디스크립터 계층이 아닌 기본 &quot;핸들&quot;IO를 사용합니다. 펄 기준으로 버그가있는 것으로 알려짐 5.8.2.</target>
        </trans-unit>
        <trans-unit id="668165d561c62f330e96b629c4cdbaaa6a959900" translate="yes" xml:space="preserve">
          <source>layers</source>
          <target state="translated">layers</target>
        </trans-unit>
        <trans-unit id="7a01ac075bef9978a02e0d617581075e7ef656ff" translate="yes" xml:space="preserve">
          <source>lc</source>
          <target state="translated">lc</target>
        </trans-unit>
        <trans-unit id="981c93d3cfc093341a5e23cfb2960d27a0bd9b18" translate="yes" xml:space="preserve">
          <source>lc EXPR</source>
          <target state="translated">lc EXPR</target>
        </trans-unit>
        <trans-unit id="03dac16c5a7ea4584e45233fb1fe739d834da705" translate="yes" xml:space="preserve">
          <source>lcfirst</source>
          <target state="translated">lcfirst</target>
        </trans-unit>
        <trans-unit id="4bf10c7c0cf1b946d82e323d34632248cbe61a5a" translate="yes" xml:space="preserve">
          <source>lcfirst EXPR</source>
          <target state="translated">lcfirst EXPR</target>
        </trans-unit>
        <trans-unit id="b9a7e2303793d6c9a795bf7a60a5c58ebb7bae1d" translate="yes" xml:space="preserve">
          <source>ld.script</source>
          <target state="translated">ld.script</target>
        </trans-unit>
        <trans-unit id="593b743b207e10ff55ec63e71a46c07909d0880a" translate="yes" xml:space="preserve">
          <source>le</source>
          <target state="translated">le</target>
        </trans-unit>
        <trans-unit id="2543258632dcde1c9dda11f400265f9020598acd" translate="yes" xml:space="preserve">
          <source>leaves drive as it is.</source>
          <target state="translated">그대로 드라이브를 떠납니다.</target>
        </trans-unit>
        <trans-unit id="bee3025990c10dd732e7c46a8b2b715a1dcda3b5" translate="yes" xml:space="preserve">
          <source>leaves the &lt;code&gt;%hash&lt;/code&gt; empty rather than with its original contents.</source>
          <target state="translated">잎 &lt;code&gt;%hash&lt;/code&gt; 원래 내용보다는 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="12c0f1fbadc4046b5f2bb9e063b227ef8750d9d6" translate="yes" xml:space="preserve">
          <source>left</source>
          <target state="translated">left</target>
        </trans-unit>
        <trans-unit id="4737fa4317b3dbfbe0793f4d77a61ff4da1af746" translate="yes" xml:space="preserve">
          <source>leftmost</source>
          <target state="translated">leftmost</target>
        </trans-unit>
        <trans-unit id="2f936e05c77962997bd534a0c03a5b28d0a9e6e7" translate="yes" xml:space="preserve">
          <source>legitimately return &lt;code&gt;-1&lt;/code&gt; . The proper way to handle such calls is to assign &lt;code&gt;$!=0&lt;/code&gt; before the call, then check the value of &lt;code&gt;$!&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; .</source>
          <target state="translated">합법적으로 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다. 이러한 호출을 처리하는 올바른 방법 은 호출 전에 &lt;code&gt;$!=0&lt;/code&gt; 을 할당 한 다음 &lt;code&gt;$!&lt;/code&gt; 의 값을 확인하는 것입니다 . 만약 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fb3cd5ef7f4ba25ee7e799860a861432c55551d" translate="yes" xml:space="preserve">
          <source>legitimately return &lt;code&gt;-1&lt;/code&gt; . The proper way to handle such calls is to assign &lt;code&gt;$!=0&lt;/code&gt; before the call, then check the value of &lt;code&gt;$!&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; .</source>
          <target state="translated">합법적으로 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다. 이러한 호출을 처리하는 올바른 방법 은 호출 전에 &lt;code&gt;$!=0&lt;/code&gt; 을 할당 한 다음 &lt;code&gt;$!&lt;/code&gt; 의 값을 확인하는 것입니다 . 만약 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a573b540d2dde90ba6da3b9d6286c8ec60c10044" translate="yes" xml:space="preserve">
          <source>len</source>
          <target state="translated">len</target>
        </trans-unit>
        <trans-unit id="3d54973f528b01019a58a52d34d518405a01b891" translate="yes" xml:space="preserve">
          <source>length</source>
          <target state="translated">length</target>
        </trans-unit>
        <trans-unit id="53200d1265f64527de5997006b46bed16c623ba8" translate="yes" xml:space="preserve">
          <source>length EXPR</source>
          <target state="translated">길이 EXPR</target>
        </trans-unit>
        <trans-unit id="12126f713e2c6e2b378ad7286a6bc4fa4da0d2f3" translate="yes" xml:space="preserve">
          <source>length()</source>
          <target state="translated">length()</target>
        </trans-unit>
        <trans-unit id="17ad2831729fd442f864db7688784dfbf7955cba" translate="yes" xml:space="preserve">
          <source>length-item</source>
          <target state="translated">length-item</target>
        </trans-unit>
        <trans-unit id="0b439cf4e10f87567e60f4b7818ecd57383dc7f0" translate="yes" xml:space="preserve">
          <source>less</source>
          <target state="translated">less</target>
        </trans-unit>
        <trans-unit id="78efad5671f5e78b02faa6a4a581a424dceb0730" translate="yes" xml:space="preserve">
          <source>less - perl pragma to request less of something</source>
          <target state="translated">less-펄 프라그 마가 적은 것을 요청</target>
        </trans-unit>
        <trans-unit id="02f3496dc7765194620a1d6fcb556b38dd666197" translate="yes" xml:space="preserve">
          <source>less time</source>
          <target state="translated">적은 시간</target>
        </trans-unit>
        <trans-unit id="4c213394c05bbaa2e6986dee2a278be573c9f3eb" translate="yes" xml:space="preserve">
          <source>less(1) manpage</source>
          <target state="translated">less (1) 맨 페이지</target>
        </trans-unit>
        <trans-unit id="111d45df9732173914935953b636771bd1fe2f90" translate="yes" xml:space="preserve">
          <source>lets us evaluate individual Perl strings, and then extract variables for coercion into C types. The following program,</source>
          <target state="translated">개별 Perl 문자열을 평가 한 다음 강제 유형 변수를 C 유형으로 추출합니다. 다음 프로그램</target>
        </trans-unit>
        <trans-unit id="ad60c535ff88e85bf0254452fe3934f24e9668d5" translate="yes" xml:space="preserve">
          <source>level</source>
          <target state="translated">level</target>
        </trans-unit>
        <trans-unit id="bb1350a57d9ad1cedc41dbe6c123e723b0969cc3" translate="yes" xml:space="preserve">
          <source>level &lt;code&gt;PerlIO *&lt;/code&gt; is a pointer to a &lt;code&gt;PerlIOl *&lt;/code&gt; - i.e. a pointer to a pointer to the struct. This allows the application level &lt;code&gt;PerlIO *&lt;/code&gt; to remain constant while the actual &lt;code&gt;PerlIOl *&lt;/code&gt; underneath changes. (Compare perl's &lt;code&gt;SV *&lt;/code&gt; which remains constant while its &lt;code&gt;sv_any&lt;/code&gt; field changes as the scalar's type changes.) An IO stream is then in general represented as a pointer to this linked-list of &quot;layers&quot;.</source>
          <target state="translated">레벨 &lt;code&gt;PerlIO *&lt;/code&gt; 는 &lt;code&gt;PerlIOl *&lt;/code&gt; 에 대한 포인터입니다. 즉, 구조체에 대한 포인터입니다. 이를 통해 응용 프로그램 레벨 &lt;code&gt;PerlIO *&lt;/code&gt; 는 일정하게 유지되고 실제 &lt;code&gt;PerlIOl *&lt;/code&gt; 는 변경됩니다. ( &lt;code&gt;sv_any&lt;/code&gt; 의 유형이 변경됨에 따라 sv_any 필드가 변하는 동안 perl의 &lt;code&gt;SV *&lt;/code&gt; 를 비교하십시오 .) IO 스트림은 일반적으로이 링크 된 &quot;레이어&quot;목록에 대한 포인터로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a34b2d4b71d3ddc27cc52fb35135ac1c5dbe44f" translate="yes" xml:space="preserve">
          <source>level. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\$a)&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a)&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\\$a)&lt;/a&gt;&lt;/code&gt; is not.</source>
          <target state="translated">수평. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\$a)&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a)&lt;/a&gt;&lt;/code&gt; 과 동일하지만 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock(\\$a)&lt;/a&gt;&lt;/code&gt; 은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="743e8359279cf7f0547f8ae5b735a7cf348aa31e" translate="yes" xml:space="preserve">
          <source>level:</source>
          <target state="translated">level:</target>
        </trans-unit>
        <trans-unit id="f560237bb64a4ed60f6ec30a321ae364eeccfc8d" translate="yes" xml:space="preserve">
          <source>levels deep, as if the &lt;code&gt;dumpDepth&lt;/code&gt; option had been temporarily set to</source>
          <target state="translated">수준은 깊은의 같은 경우 &lt;code&gt;dumpDepth&lt;/code&gt; 의 옵션이 일시적으로 설정했다</target>
        </trans-unit>
        <trans-unit id="87c2760ff0fd836e950d1f3773814e8602f382f6" translate="yes" xml:space="preserve">
          <source>lewart!at!uiuc.edu</source>
          <target state="translated">lewart!at!uiuc.edu</target>
        </trans-unit>
        <trans-unit id="7f9b3be17a93e598368695b2b13dcc4f05f4fa36" translate="yes" xml:space="preserve">
          <source>lexical scope</source>
          <target state="translated">어휘 범위</target>
        </trans-unit>
        <trans-unit id="a98b7cb4e1d62107700706f49e9bed1cbf5694db" translate="yes" xml:space="preserve">
          <source>lexical variables created with my(). Typically it would be the first declaration in a file included by the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. You can switch into a package in more than one place; it merely influences which symbol table is used by the compiler for the rest of that block. You can refer to variables and filehandles in other packages by prefixing the identifier with the package name and a double colon: &lt;code&gt;$Package::Variable&lt;/code&gt; . If the package name is null, the &lt;code&gt;main&lt;/code&gt; package is assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; .</source>
          <target state="translated">my ()로 작성된 어휘 변수. 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 연산자에 포함 된 파일의 첫 번째 선언입니다 . 여러 곳에서 패키지로 전환 할 수 있습니다. 이는 컴파일러가 해당 블록의 나머지 부분에 사용하는 기호 테이블에 영향을 미칩니다. 패키지 이름과 이중 콜론으로 &lt;code&gt;$Package::Variable&lt;/code&gt; 접두사 $ Package :: Variable 을 붙여서 다른 패키지의 변수 및 파일 핸들을 참조 할 수 있습니다 . 패키지 이름이 null이면 &lt;code&gt;main&lt;/code&gt; 패키지로 가정됩니다. 즉, &lt;code&gt;$::sail&lt;/code&gt; 은 &lt;code&gt;$main::sail&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e71249801b330ab4aa5e2053a29f296dbb0e328f" translate="yes" xml:space="preserve">
          <source>lexically-scoped variables, which are created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. Typically it would be the first declaration in a file included by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. You can switch into a package in more than one place, since this only determines which default symbol table the compiler uses for the rest of that block. You can refer to identifiers in other packages than the current one by prefixing the identifier with the package name and a double colon, as in &lt;code&gt;$SomePack::var&lt;/code&gt; or &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; . If package name is omitted, the &lt;code&gt;main&lt;/code&gt; package as assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; (as well as to &lt;code&gt;$main'sail&lt;/code&gt; , still seen in ancient code, mostly from Perl 4).</source>
          <target state="translated">로 생성되는 변수, 어휘 적 범위의 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 에 포함 된 파일의 첫 번째 선언입니다 . 컴파일러가 해당 블록의 나머지 블록에 사용하는 기본 심볼 테이블 만 결정하므로 둘 이상의 위치에서 패키지로 전환 할 수 있습니다. &lt;code&gt;$SomePack::var&lt;/code&gt; 또는 &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; 과 같이 식별자에 패키지 이름과 이중 콜론을 접두어로 붙여 현재 패키지가 아닌 다른 패키지의 식별자를 참조 할 수 있습니다 . 패키지 이름을 생략하면 &lt;code&gt;main&lt;/code&gt; 패키지가 가정됩니다. 즉, &lt;code&gt;$::sail&lt;/code&gt; 은 &lt;code&gt;$main::sail&lt;/code&gt; 과 같습니다.( 대부분의 코드는 Perl 4에서 여전히 볼 수있는 &lt;code&gt;$main'sail&lt;/code&gt; 뿐만 아니라 ).</target>
        </trans-unit>
        <trans-unit id="3d04adc74c945063bcc590f133adcf214df94a9c" translate="yes" xml:space="preserve">
          <source>lexically-scoped variables, which are created with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. Typically it would be the first declaration in a file included by &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. You can switch into a package in more than one place, since this only determines which default symbol table the compiler uses for the rest of that block. You can refer to identifiers in other packages than the current one by prefixing the identifier with the package name and a double colon, as in &lt;code&gt;$SomePack::var&lt;/code&gt; or &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; . If package name is omitted, the &lt;code&gt;main&lt;/code&gt; package as assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt; (as well as to &lt;code&gt;$main'sail&lt;/code&gt; , still seen in ancient code, mostly from Perl 4).</source>
          <target state="translated">로 생성되는 변수, 어휘 적 범위의 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . 일반적으로 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 에 포함 된 파일의 첫 번째 선언입니다 . 컴파일러가 해당 블록의 나머지 블록에 사용하는 기본 심볼 테이블 만 결정하므로 둘 이상의 위치에서 패키지로 전환 할 수 있습니다. &lt;code&gt;$SomePack::var&lt;/code&gt; 또는 &lt;code&gt;ThatPack::INPUT_HANDLE&lt;/code&gt; 과 같이 식별자에 패키지 이름과 이중 콜론을 접두어로 붙여 현재 패키지가 아닌 다른 패키지의 식별자를 참조 할 수 있습니다 . 패키지 이름을 생략하면 &lt;code&gt;main&lt;/code&gt; 패키지가 가정됩니다. 즉, &lt;code&gt;$::sail&lt;/code&gt; 은 &lt;code&gt;$main::sail&lt;/code&gt; 과 같습니다.( 대부분의 코드는 Perl 4에서 여전히 볼 수있는 &lt;code&gt;$main'sail&lt;/code&gt; 뿐만 아니라 ).</target>
        </trans-unit>
        <trans-unit id="f8df771d8fad6fc4d6a6e0fdcf32235fee4d432f" translate="yes" xml:space="preserve">
          <source>lha -mraxe x perl-$VERSION-bin.lha</source>
          <target state="translated">lha -mraxe x perl- $ VERSION-bin.lha</target>
        </trans-unit>
        <trans-unit id="9d062bafff17ba8b9a1215c4c51485134d509d91" translate="yes" xml:space="preserve">
          <source>lib</source>
          <target state="translated">lib</target>
        </trans-unit>
        <trans-unit id="b2f1aa4618f8511782e93f2b2456425e658657ba" translate="yes" xml:space="preserve">
          <source>lib - manipulate @INC at compile time</source>
          <target state="translated">lib-컴파일시 @INC 조작</target>
        </trans-unit>
        <trans-unit id="3e4e355eb6719577404ce98223a2b88d539b0d05" translate="yes" xml:space="preserve">
          <source>lib and lib</source>
          <target state="translated">lib와 lib</target>
        </trans-unit>
        <trans-unit id="2f44e7def4cb27180b53a038d394266e50a43a80" translate="yes" xml:space="preserve">
          <source>lib.exe is normally used to build libraries, but link.exe with the /lib option also works, so change win32/config.vc to use it instead:</source>
          <target state="translated">lib.exe는 일반적으로 라이브러리를 빌드하는 데 사용되지만 / lib 옵션을 사용하여 link.exe도 작동하므로 win32 / config.vc를 변경하여 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70070d20d4c6e863f10cb8b6749cc4b4efaf6027" translate="yes" xml:space="preserve">
          <source>lib/</source>
          <target state="translated">lib/</target>
        </trans-unit>
        <trans-unit id="6e588d0eb09843bb85142c36159b59cc3a27a40b" translate="yes" xml:space="preserve">
          <source>lib/Config.pm</source>
          <target state="translated">lib/Config.pm</target>
        </trans-unit>
        <trans-unit id="88d614c0b84efc336051bce3e13eb562d0b8f337" translate="yes" xml:space="preserve">
          <source>lib/ExtUtils</source>
          <target state="translated">lib/ExtUtils</target>
        </trans-unit>
        <trans-unit id="6cb8d15061262831ec39b62c9b20c092a3811f47" translate="yes" xml:space="preserve">
          <source>lib/ExtUtils/typemap</source>
          <target state="translated">lib/ExtUtils/typemap</target>
        </trans-unit>
        <trans-unit id="b5f40c50a611e165a0d206a1e6ef0db737b90e30" translate="yes" xml:space="preserve">
          <source>lib/File.Copy.t</source>
          <target state="translated">lib/File.Copy.t</target>
        </trans-unit>
        <trans-unit id="359125af2199801e53d858f9b4a05dcfff8322c6" translate="yes" xml:space="preserve">
          <source>lib/File/Find/taint.t will complain if '.' is in your PATH. The PATH test is triggered because cwd calls `fullpath -t`.</source>
          <target state="translated">lib / File / Find / taint.t는 '.' 당신의 경로에 있습니다. cwd가`fullpath -t`를 호출하기 때문에 PATH 테스트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="90bdcb6812853a7d5bb4ee449e1c2c3938e5b2d9" translate="yes" xml:space="preserve">
          <source>lib/Foo/Bar.pm</source>
          <target state="translated">lib/Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ee16f92d5b61d6587e8d9ccdeea55a375ff6035b" translate="yes" xml:space="preserve">
          <source>lib/Net/Ping/t/450_service.t</source>
          <target state="translated">lib/Net/Ping/t/450_service.t</target>
        </trans-unit>
        <trans-unit id="d42828e03450bbbdcf272afa864cdef4d3a51548" translate="yes" xml:space="preserve">
          <source>lib/Net/Ping/t/510_ping_udp.t</source>
          <target state="translated">lib/Net/Ping/t/510_ping_udp.t</target>
        </trans-unit>
        <trans-unit id="c3d52f60d978ab23a551b74a528a88ef76b18b9a" translate="yes" xml:space="preserve">
          <source>lib/Tie/File/t/09_gen_rs</source>
          <target state="translated">lib/Tie/File/t/09_gen_rs</target>
        </trans-unit>
        <trans-unit id="4c33170bdd26012203a6bd904dd58f36f73a7acd" translate="yes" xml:space="preserve">
          <source>lib/encoding.pm</source>
          <target state="translated">lib/encoding.pm</target>
        </trans-unit>
        <trans-unit id="7c2f483f24dee82ab5e37fd3f7bc02bfb93f9406" translate="yes" xml:space="preserve">
          <source>lib/filehand.t</source>
          <target state="translated">lib/filehand.t</target>
        </trans-unit>
        <trans-unit id="7a322f1fd2b67495d6c867548d84c9ad2bdbe5bf" translate="yes" xml:space="preserve">
          <source>lib/io_pipe.t</source>
          <target state="translated">lib/io_pipe.t</target>
        </trans-unit>
        <trans-unit id="3a9b601afa6c15ad5a349cf79626adae81beecac" translate="yes" xml:space="preserve">
          <source>lib/io_sock.t</source>
          <target state="translated">lib/io_sock.t</target>
        </trans-unit>
        <trans-unit id="825cd0dceebc1d8a0d92ad3966e3ba313c1b1a28" translate="yes" xml:space="preserve">
          <source>lib/lib.pm</source>
          <target state="translated">lib/lib.pm</target>
        </trans-unit>
        <trans-unit id="923b9d7545d00ab27b36e6bb97d33d75634fd485" translate="yes" xml:space="preserve">
          <source>lib/locale</source>
          <target state="translated">lib/locale</target>
        </trans-unit>
        <trans-unit id="0c546992c69ba3886efe8a1a342e4bdbdd95501f" translate="yes" xml:space="preserve">
          <source>lib/locale.t</source>
          <target state="translated">lib/locale.t</target>
        </trans-unit>
        <trans-unit id="d1217cb3b51bf20fe9331bf068816bab61666762" translate="yes" xml:space="preserve">
          <source>lib/open2.t</source>
          <target state="translated">lib/open2.t</target>
        </trans-unit>
        <trans-unit id="7ba11ac14c123959f471691ad31f8b9e84071f76" translate="yes" xml:space="preserve">
          <source>lib/open3.t</source>
          <target state="translated">lib/open3.t</target>
        </trans-unit>
        <trans-unit id="dca0301922534d763ca928ed51e26d8d7783ac18" translate="yes" xml:space="preserve">
          <source>lib/os2_base.t</source>
          <target state="translated">lib/os2_base.t</target>
        </trans-unit>
        <trans-unit id="b8a31ed89dabfffde341b60fd6def6e2c4cc790d" translate="yes" xml:space="preserve">
          <source>lib/perl5</source>
          <target state="translated">lib/perl5</target>
        </trans-unit>
        <trans-unit id="6ba6abb3f64776aa2bb42c96ddc804d4f76ad985" translate="yes" xml:space="preserve">
          <source>lib/strict.pm</source>
          <target state="translated">lib/strict.pm</target>
        </trans-unit>
        <trans-unit id="cf7fc3fcb8b41426b779c987cf3aca145cf46d4c" translate="yes" xml:space="preserve">
          <source>lib/strict.t</source>
          <target state="translated">lib/strict.t</target>
        </trans-unit>
        <trans-unit id="ddf8ccfcb95095226146ff022a9d2f0be94e8d6a" translate="yes" xml:space="preserve">
          <source>lib/syslog.pl</source>
          <target state="translated">lib/syslog.pl</target>
        </trans-unit>
        <trans-unit id="1166bbdf921fa064d4af52b7666490126994f4a9" translate="yes" xml:space="preserve">
          <source>lib/unicore</source>
          <target state="translated">lib/unicore</target>
        </trans-unit>
        <trans-unit id="cb9a2c1b60529371b5aabb0dec31114a2cd72447" translate="yes" xml:space="preserve">
          <source>lib/unicore/To/Foo.pl</source>
          <target state="translated">lib/unicore/To/Foo.pl</target>
        </trans-unit>
        <trans-unit id="2747fd594c4b9098dce15bd69891f3bc7497352a" translate="yes" xml:space="preserve">
          <source>lib/utf8_heavy.pl</source>
          <target state="translated">lib/utf8_heavy.pl</target>
        </trans-unit>
        <trans-unit id="24de2ffa9a7f68a0eaa022fb4d1fc4463cfa7e32" translate="yes" xml:space="preserve">
          <source>libc.U</source>
          <target state="translated">libc.U</target>
        </trans-unit>
        <trans-unit id="9a7905485cd7dad121e13853f453e6168bd685d8" translate="yes" xml:space="preserve">
          <source>libc.so</source>
          <target state="translated">libc.so</target>
        </trans-unit>
        <trans-unit id="ee31a39d4f700ded23ada0ac425f08d9e326043b" translate="yes" xml:space="preserve">
          <source>libcrypt.a</source>
          <target state="translated">libcrypt.a</target>
        </trans-unit>
        <trans-unit id="bb4b26014a9639424988e36bd9e9631832ba04ee" translate="yes" xml:space="preserve">
          <source>libfoo.so.x.y</source>
          <target state="translated">libfoo.so.x.y</target>
        </trans-unit>
        <trans-unit id="9829f920f0965cefd46bd5339f19e3726df34195" translate="yes" xml:space="preserve">
          <source>libname.*</source>
          <target state="translated">libname.*</target>
        </trans-unit>
        <trans-unit id="6084610ec2669c79b3e40c2f469167b5d6ed050c" translate="yes" xml:space="preserve">
          <source>libnetcfg</source>
          <target state="translated">libnetcfg</target>
        </trans-unit>
        <trans-unit id="90297287291496c46cc19f11bcc1f29641bcddf1" translate="yes" xml:space="preserve">
          <source>libnetcfg - configure libnet</source>
          <target state="translated">libnetcfg-libnet 구성</target>
        </trans-unit>
        <trans-unit id="63602837884f246bbae970ebe1bf1483d5d73d94" translate="yes" xml:space="preserve">
          <source>libperl and Prebinding</source>
          <target state="translated">libperl과 프리 바인딩</target>
        </trans-unit>
        <trans-unit id="f7ae8185c2b40033375a90176334bf18119d8934" translate="yes" xml:space="preserve">
          <source>libperl.U</source>
          <target state="translated">libperl.U</target>
        </trans-unit>
        <trans-unit id="4c488f9ca04f4580fea44d70fa258f265b01e0cc" translate="yes" xml:space="preserve">
          <source>libperl.a</source>
          <target state="translated">libperl.a</target>
        </trans-unit>
        <trans-unit id="ce9ec3d509b9cb6dfb7bd31e34ac9c1c393f59bd" translate="yes" xml:space="preserve">
          <source>libperl.a equivalent to be linked to dynamic extensions.</source>
          <target state="translated">libperl. 동적 확장에 연결되는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5125c991d100a81bb2ab1cf4fc9d757db8bfc62" translate="yes" xml:space="preserve">
          <source>libperl.so</source>
          <target state="translated">libperl.so</target>
        </trans-unit>
        <trans-unit id="db5e46f473e00611def3d06a7cfd97ddab2aa182" translate="yes" xml:space="preserve">
          <source>libperl.so.xxx</source>
          <target state="translated">libperl.so.xxx</target>
        </trans-unit>
        <trans-unit id="ca2af9f2d6220fa51e710bd922000bfeed15c0dc" translate="yes" xml:space="preserve">
          <source>libpth.U</source>
          <target state="translated">libpth.U</target>
        </trans-unit>
        <trans-unit id="bbb082b7d49e9ad809e7f9a2a142296533c655d0" translate="yes" xml:space="preserve">
          <source>libraries for these Perl modules in the places where Perl builder can find it. Use the perl builder: change to an empty directory, create a &quot;dummy&quot;</source>
          <target state="translated">Perl 빌더가 찾을 수있는 위치에 이러한 Perl 모듈의 라이브러리. 펄 빌더를 사용하십시오. 빈 디렉토리로 변경하고 &quot;더미&quot;를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8880a921e4238ca055e788428a2b131cc2e7f2b9" translate="yes" xml:space="preserve">
          <source>library and the CPAN module Devel::Symdump make use of this.</source>
          <target state="translated">라이브러리 및 CPAN 모듈 Devel :: Symdump가이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f7cc5c519e417b541aeee641af55dc3a4f0071e" translate="yes" xml:space="preserve">
          <source>library provides some of the features of &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;, but avoids loading most modules and uses as few core features as possible.</source>
          <target state="translated">라이브러리는 &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; 의 일부 기능을 제공 하지만 대부분의 모듈을로드하지 않고 가능한 한 적은 핵심 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1e947160fbbc3e7ddc94d7fbd4dacb40584ed854" translate="yes" xml:space="preserve">
          <source>library, it combines the features of the</source>
          <target state="translated">도서관, 그것은의 기능을 결합</target>
        </trans-unit>
        <trans-unit id="9077bdb27b2b8fc9d2176658752393ca1567f26a" translate="yes" xml:space="preserve">
          <source>library.</source>
          <target state="translated">library.</target>
        </trans-unit>
        <trans-unit id="0778ef88b4665f4828dc51d97a9ae6838afa94b7" translate="yes" xml:space="preserve">
          <source>libs.U</source>
          <target state="translated">libs.U</target>
        </trans-unit>
        <trans-unit id="144fc6d389a583f77c5db29ae574196dcd379d0e" translate="yes" xml:space="preserve">
          <source>libscan</source>
          <target state="translated">libscan</target>
        </trans-unit>
        <trans-unit id="655f1ebeeea52ff6ced2d5d719c659190eb535f6" translate="yes" xml:space="preserve">
          <source>libswanted.</source>
          <target state="translated">libswanted.</target>
        </trans-unit>
        <trans-unit id="d2b824675a5f9e2232ba65db94d4f79ecf3f41d5" translate="yes" xml:space="preserve">
          <source>lies with its &lt;code&gt;NOFILE&lt;/code&gt; define on some systems, so you may have to set</source>
          <target state="translated">일부 시스템에서 정의 된 &lt;code&gt;NOFILE&lt;/code&gt; 과 함께 있으므로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="595dc278b205ed9d7c9ccf298b931232c9af0f83" translate="yes" xml:space="preserve">
          <source>like PAD_SET_CUR, but without the save</source>
          <target state="translated">PAD_SET_CUR과 같지만 저장하지 않음</target>
        </trans-unit>
        <trans-unit id="e95ce206fd1a318d3e2f9217a8174734c6d41c1c" translate="yes" xml:space="preserve">
          <source>like a function, therefore it</source>
          <target state="translated">함수처럼</target>
        </trans-unit>
        <trans-unit id="e75ea1c71ebd23a635b7661517fc60719e8aaa98" translate="yes" xml:space="preserve">
          <source>like compound statements, but aren't--they're just TERMs in an expression--and thus need an explicit termination when used as the last item in a statement.</source>
          <target state="translated">복합 명령문과 유사하지만 표현식의 TERM 일 뿐이므로 명령문의 마지막 항목으로 사용될 때 명시적인 종료가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="37f4b3cd257d5cd56ad06fcb46e522be8648e4d5" translate="yes" xml:space="preserve">
          <source>like numbers; using an array as though it were a scalar; if your subroutines recurse more than 100 deep; and innumerable other things.</source>
          <target state="translated">같은 숫자; 스칼라 인 것처럼 배열을 사용하는 것; 서브 루틴이 100 회 이상 반복되는 경우; 그리고 수많은 다른 것들.</target>
        </trans-unit>
        <trans-unit id="0bda6e11e3d8223f3fcb2ce089532445618666fd" translate="yes" xml:space="preserve">
          <source>like script.</source>
          <target state="translated">스크립트처럼.</target>
        </trans-unit>
        <trans-unit id="16edf2fbf12671a4b8e8311124a75cf929f82f3d" translate="yes" xml:space="preserve">
          <source>like this:</source>
          <target state="translated">이처럼 :</target>
        </trans-unit>
        <trans-unit id="7c4d7e807c0f90aca43d9fe1a786427248bc77ec" translate="yes" xml:space="preserve">
          <source>like to use double quotes, except that in this particular situation, you can just use symbolic references instead, as in case 6.</source>
          <target state="translated">이 특별한 상황에서는 대신 6과 같이 기호 참조를 사용할 수 있다는 점을 제외하고 큰 따옴표를 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="3dd3164fb4c19bfd6a7a909b343e98a2715ee1fe" translate="yes" xml:space="preserve">
          <source>likely</source>
          <target state="translated">likely</target>
        </trans-unit>
        <trans-unit id="c50ed56476fa6fe2fc32cf117ca281f12027cc8b" translate="yes" xml:space="preserve">
          <source>limits itself to real numbers, but an extra &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement brings full complex support, along with a full set of mathematical functions typically associated with and/or extended to complex numbers.</source>
          <target state="translated">자체를 실수로 제한하지만, 여분의 구문을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하면 복잡한 숫자와 일반적으로 연관되거나 확장 된 수학 함수의 전체 세트와 함께 완전한 복잡한 지원이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="264f39cab871e4cfd65b3a002f7255888bb5ed97" translate="yes" xml:space="preserve">
          <source>line</source>
          <target state="translated">line</target>
        </trans-unit>
        <trans-unit id="ee6d4c6d5ba67c8947633c21df6ef3227697ec48" translate="yes" xml:space="preserve">
          <source>line (split into two lines above) contains optimizer information. In the example shown, the optimizer found that the match should contain a substring &lt;code&gt;de&lt;/code&gt; at offset 1, plus substring &lt;code&gt;gh&lt;/code&gt; at some offset between 3 and infinity. Moreover, when checking for these substrings (to abandon impossible matches quickly), Perl will check for the substring &lt;code&gt;gh&lt;/code&gt; before checking for the substring &lt;code&gt;de&lt;/code&gt; . The optimizer may also use the knowledge that the match starts (at the &lt;code&gt;first&lt;/code&gt;</source>
          <target state="translated">line (위의 두 줄로 분리)에는 옵티 마이저 정보가 들어 있습니다. 표시된 예에서 옵티마이 저는 일치 에 오프셋 1에 하위 문자열 &lt;code&gt;de&lt;/code&gt; 와 3과 무한대 사이에 일부 오프셋에 substring &lt;code&gt;gh&lt;/code&gt; 가 포함되어야 함을 발견했습니다 . 또한 이러한 하위 문자열을 확인할 때 (불가능한 일치를 빨리 포기하기 위해) Perl은 하위 문자열 &lt;code&gt;de&lt;/code&gt; 를 확인하기 전에 하위 문자열 &lt;code&gt;gh&lt;/code&gt; 를 확인합니다 . 옵티마이 저는 경기가 시작된다는 지식을 사용할 수도 있습니다 ( &lt;code&gt;first&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5cff435ab18a0c579f485626794be0f63bb4f09" translate="yes" xml:space="preserve">
          <source>line 13 is where the action is, so let's continue down to there via the letter '&lt;b&gt;c&lt;/b&gt;', which by the way, inserts a 'one-time-only' breakpoint at the given line or sub routine:</source>
          <target state="translated">13 행은 작업이 수행되는 위치이므로 문자 ' &lt;b&gt;c&lt;/b&gt; ' 를 통해 계속 진행해 봅시다 . 그런데 주어진 행이나 하위 루틴에 '한 번만'중단 점을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5d4e605b7f432bb8eb53818c4166fc813e3df040" translate="yes" xml:space="preserve">
          <source>line ends with &quot;\015\012&quot;, and strip what you don't need from the output. This applies especially to socket I/O and autoflushing, discussed next.</source>
          <target state="translated">줄은 &quot;\ 015 \ 012&quot;로 끝나고 출력에서 ​​필요없는 것을 제거합니다. 이는 다음에 논의 할 소켓 I / O 및 자동 세척에 특히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="edd5e2ef9789c510bbe128704d9a7e7e3a40e4ec" translate="yes" xml:space="preserve">
          <source>line within the string.</source>
          <target state="translated">문자열 내 줄.</target>
        </trans-unit>
        <trans-unit id="c6289336f78366e3f6883b22aef27803c8a7ebe5" translate="yes" xml:space="preserve">
          <source>lines in list context. When performing open, close, or any other operation besides &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on files, or even when talking about the handle, do</source>
          <target state="translated">목록 컨텍스트의 줄. 파일에서 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 이외의 열기, 닫기 또는 기타 작업을 수행 하거나 핸들에 대해 말할 때도</target>
        </trans-unit>
        <trans-unit id="205e5d4f320847b243dd453a04b92b3be65db4ad" translate="yes" xml:space="preserve">
          <source>lines indented. You can do something like this:</source>
          <target state="translated">줄 들여 쓰기. 다음과 같이 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="893b6bbee2e15aca199ac12f4ec7f3df9dd66111" translate="yes" xml:space="preserve">
          <source>link OLDFILE,NEWFILE</source>
          <target state="translated">OLDFILE, NEWFILE 링크</target>
        </trans-unit>
        <trans-unit id="0bd588874c06c526798eba96d6fe06b8a35dbd20" translate="yes" xml:space="preserve">
          <source>lint, splint</source>
          <target state="translated">보풀, 부목</target>
        </trans-unit>
        <trans-unit id="38b62be4bddaa5661c7d6b8e36e28159314df5c7" translate="yes" xml:space="preserve">
          <source>list</source>
          <target state="translated">list</target>
        </trans-unit>
        <trans-unit id="28d839de275cc2a482580b54daa9f1746f8afd3b" translate="yes" xml:space="preserve">
          <source>list as parameters. It will return the corresponding threads object, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if thread creation failed.</source>
          <target state="translated">매개 변수로 나열하십시오. 해당 스레드 객체를 반환하거나 스레드 생성에 실패한 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f85c5f6f515fbe630e0696ceae1fdb9ade45ddad" translate="yes" xml:space="preserve">
          <source>list option</source>
          <target state="translated">리스트 옵션</target>
        </trans-unit>
        <trans-unit id="912fff8dfa7230c9dbc1aafaee034c4c28b60135" translate="yes" xml:space="preserve">
          <source>list. (No parameters are modified, and there can be keys in the</source>
          <target state="translated">명부. (매개 변수가 수정되지 않으며 키가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2147a9e5f9e89b70810c82ff8e12817130d6ca10" translate="yes" xml:space="preserve">
          <source>listen</source>
          <target state="translated">listen</target>
        </trans-unit>
        <trans-unit id="97b87c18960b2a4b1aa17d3d60a1e2f067cb6abb" translate="yes" xml:space="preserve">
          <source>listen SOCKET,QUEUESIZE</source>
          <target state="translated">SOCKET, QUEUESIZE 듣기</target>
        </trans-unit>
        <trans-unit id="6eccfbe291f324971af6784befbc212824e44176" translate="yes" xml:space="preserve">
          <source>listing</source>
          <target state="translated">listing</target>
        </trans-unit>
        <trans-unit id="61edd61d4a7f28bee492d0997de8c193d478da66" translate="yes" xml:space="preserve">
          <source>lists all of the perl release versions we got the CoreList for.</source>
          <target state="translated">CoreList를 얻은 모든 펄 릴리즈 버전을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="f7d6ae69a9d9939d5b81776dd44d0b872ad9cead" translate="yes" xml:space="preserve">
          <source>lists all of the perl releases and when they were released</source>
          <target state="translated">모든 펄 릴리즈와 릴리즈시기를 표시합니다</target>
        </trans-unit>
        <trans-unit id="bf9d5a0c63cc1fc18dff839271fcc51b66b70299" translate="yes" xml:space="preserve">
          <source>lists all the files that are skipped due to your &lt;code&gt;MANIFEST.SKIP&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;MANIFEST.SKIP&lt;/code&gt; 파일 로 인해 건너 뛴 모든 파일을 나열 합니다.</target>
        </trans-unit>
        <trans-unit id="78bebc9e06a6bb16d146b4c83c431c4203e08d0a" translate="yes" xml:space="preserve">
          <source>lists all versions of the given module (or the matching modules, in case you used a module regexp) in the perls Module::CoreList knows about.</source>
          <target state="translated">perls Module :: CoreList가 알고있는 지정된 모듈 (또는 모듈 정규 표현식을 사용한 경우 일치하는 모듈)의 모든 버전을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b82e8dc76d2fa200f820190cf7479ebc1fa8a830" translate="yes" xml:space="preserve">
          <source>lists the first version bundle of each named feature given</source>
          <target state="translated">주어진 각 명명 된 기능의 첫 번째 버전 번들을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d1e347c1c3866cd9970a92c783f2374e855dfc81" translate="yes" xml:space="preserve">
          <source>listval</source>
          <target state="translated">listval</target>
        </trans-unit>
        <trans-unit id="a568a4ea954740f26f018035ad22bd41cdf0373e" translate="yes" xml:space="preserve">
          <source>literal string</source>
          <target state="translated">리터럴 문자열</target>
        </trans-unit>
        <trans-unit id="aadf46ad52b563db141c6a8b633250cb09e7740c" translate="yes" xml:space="preserve">
          <source>little-endian</source>
          <target state="translated">little-endian</target>
        </trans-unit>
        <trans-unit id="3c01627cf1f82343852c754d030ad8d0be18a589" translate="yes" xml:space="preserve">
          <source>ln</source>
          <target state="translated">ln</target>
        </trans-unit>
        <trans-unit id="cf7069ab52b9c27c85a59ee69245b2ba15153409" translate="yes" xml:space="preserve">
          <source>ln -s /usr/bin/yacc /usr/local/bin/byacc</source>
          <target state="translated">ln -s / usr / bin / yacc / usr / local / bin / byacc</target>
        </trans-unit>
        <trans-unit id="f846b4e0eb20fc2b44a3afedf8b1b609fc0fca6f" translate="yes" xml:space="preserve">
          <source>lns.U</source>
          <target state="translated">lns.U</target>
        </trans-unit>
        <trans-unit id="5dbc716c4600097b85b9e51d6aeb77a4363b03ed" translate="yes" xml:space="preserve">
          <source>load</source>
          <target state="translated">load</target>
        </trans-unit>
        <trans-unit id="3d8b45aabc48663acb50c783dcbd10a487867965" translate="yes" xml:space="preserve">
          <source>load_file</source>
          <target state="translated">load_file</target>
        </trans-unit>
        <trans-unit id="d931ba99f1cad82cf3a02b00a20a3f743f4ee781" translate="yes" xml:space="preserve">
          <source>load_json_string</source>
          <target state="translated">load_json_string</target>
        </trans-unit>
        <trans-unit id="bd8a4ef9325f42d52a1f59df9bc59169ed33632d" translate="yes" xml:space="preserve">
          <source>load_string</source>
          <target state="translated">load_string</target>
        </trans-unit>
        <trans-unit id="b4efc8581e40d4d5a86d685e30ad1f651200415c" translate="yes" xml:space="preserve">
          <source>load_yaml_string</source>
          <target state="translated">load_yaml_string</target>
        </trans-unit>
        <trans-unit id="045e2b94f169be3f08f90975694f8e56dc61553f" translate="yes" xml:space="preserve">
          <source>loaded by the full name.</source>
          <target state="translated">전체 이름으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="f75ac2bde00caf8de4fa91abaeb94784e5f4eab9" translate="yes" xml:space="preserve">
          <source>loaded from the prescribed path.</source>
          <target state="translated">규정 된 경로에서로드됩니다.</target>
        </trans-unit>
        <trans-unit id="66fa096aca860773a9d6550be668afcc4230e726" translate="yes" xml:space="preserve">
          <source>loaded into memory may be found. Running &lt;code&gt;make test&lt;/code&gt; becomes meaningless, since the test are checking a previous build of perl (this situation is detected and reported by</source>
          <target state="translated">메모리에로드 된 것을 찾을 수 있습니다. &lt;code&gt;make test&lt;/code&gt; 에서 이전 빌드의 perl을 확인하므로 make 테스트 실행 은 의미가 없습니다 (이 상황은</target>
        </trans-unit>
        <trans-unit id="19e743edea24c4104fc7fe924db8d02f050e371f" translate="yes" xml:space="preserve">
          <source>loaded into memory, so this will work even for gigantic files.</source>
          <target state="translated">메모리에로드되므로 거대한 파일에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2c5d6b3e71d391fb38863da485679ad7763ae3b1" translate="yes" xml:space="preserve">
          <source>loading Pod::Simple (or any Pod::Simple-based class). If you try loading Pod::Simple::Debug after &amp;amp;Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will throw a fatal error to the effect that &quot;It's too late to call Pod::Simple::Debug&quot;.</source>
          <target state="translated">Pod :: Simple (또는 모든 Pod :: Simple 기반 클래스)로드 &amp;amp; Pod :: Simple :: DEBUG가 이미 정의 된 후 Pod :: Simple :: Debug를로드하려고하면 Pod :: Simple :: Debug에서 &quot;Pod :: Simple을 호출하기에는 너무 늦습니다.&quot;라는 치명적인 오류가 발생합니다. : 디버그 &quot;.</target>
        </trans-unit>
        <trans-unit id="40231aeb561483c2e9b7f30ccfb552f54ea27351" translate="yes" xml:space="preserve">
          <source>loading Pod::Usage, e.g.:</source>
          <target state="translated">Pod :: Usage 로딩 : 예 :</target>
        </trans-unit>
        <trans-unit id="52c558e9f725f5eecc9cc18448c82dff5fda24be" translate="yes" xml:space="preserve">
          <source>lobal.</source>
          <target state="translated">lobal.</target>
        </trans-unit>
        <trans-unit id="939bb46a04c3640c8c427e92b1b557e882e2d2a0" translate="yes" xml:space="preserve">
          <source>local</source>
          <target state="translated">local</target>
        </trans-unit>
        <trans-unit id="0cbe83985a317bab5abeb5d93600be89b7c5646f" translate="yes" xml:space="preserve">
          <source>local $Carp::RefArgFormatter = sub { require Data::Dumper; Data::Dumper::Dump($_[0]); # not necessarily safe };</source>
          <target state="translated">로컬 $ Carp :: RefArgFormatter = sub {필수 Data :: Dumper; Data :: Dumper :: Dump ($ _ [0]); # 반드시 안전 할 필요는 없음};</target>
        </trans-unit>
        <trans-unit id="909cbe434e5f5b8da8ff01039ce1157dbfef1f18" translate="yes" xml:space="preserve">
          <source>local EXPR</source>
          <target state="translated">로컬 EXPR</target>
        </trans-unit>
        <trans-unit id="0e038a42cca30122c3324dfda646d3f079374dd5" translate="yes" xml:space="preserve">
          <source>locale</source>
          <target state="translated">locale</target>
        </trans-unit>
        <trans-unit id="7151be2e63c3df71d6e8d99768469da377d7fa3e" translate="yes" xml:space="preserve">
          <source>locale - Perl pragma to use or avoid POSIX locales for built-in operations</source>
          <target state="translated">로케일-내장 조작에 POSIX 로케일을 사용하거나 피하기위한 Perl pragma</target>
        </trans-unit>
        <trans-unit id="1526fa886e4977a40dd22b26ef4633fd869bd50f" translate="yes" xml:space="preserve">
          <source>locale(3)</source>
          <target state="translated">locale(3)</target>
        </trans-unit>
        <trans-unit id="86aeaf8b02747cdecdb29ee87a018a9a2691796a" translate="yes" xml:space="preserve">
          <source>locales</source>
          <target state="translated">locales</target>
        </trans-unit>
        <trans-unit id="f25bccd744fab3255bb82bac88c618963868a33f" translate="yes" xml:space="preserve">
          <source>localtime</source>
          <target state="translated">localtime</target>
        </trans-unit>
        <trans-unit id="e7279c8fdf3a31ca3fe4bd189153443f4e05d1ab" translate="yes" xml:space="preserve">
          <source>localtime EXPR</source>
          <target state="translated">현지 시간 EXPR</target>
        </trans-unit>
        <trans-unit id="e728eb1d2aa50c88d1b5113f3c08c408b33f7c6f" translate="yes" xml:space="preserve">
          <source>localtime() has the same range as &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt;, but because time zone rules change its accuracy for historical and future times may degrade but usually by no more than an hour.</source>
          <target state="translated">localtime ()의 범위는 &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; 과 동일 하지만 시간대 규칙이 변경되므로 과거 및 미래 시간의 정확도가 저하 될 수 있지만 대개 1 시간을 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87acf50613d511daa509bb42f0542f5b1c19c877" translate="yes" xml:space="preserve">
          <source>locates an auto/$module directory by searching @INC</source>
          <target state="translated">@INC를 검색하여 auto / $ module 디렉토리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e117797422d35ce52f036963c7e9603e9955b5c7" translate="yes" xml:space="preserve">
          <source>lock</source>
          <target state="translated">lock</target>
        </trans-unit>
        <trans-unit id="1919d11e33aa63b6546864f63b6597f39b8a192c" translate="yes" xml:space="preserve">
          <source>lock THING</source>
          <target state="translated">물건을 잠그다</target>
        </trans-unit>
        <trans-unit id="4fd9900cf61416fbc707cdb91586e771328338b2" translate="yes" xml:space="preserve">
          <source>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function by this name (before any calls to it), that function will be called instead. If you are not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; this does nothing. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">lock ()은 &quot;약한 키워드&quot;입니다. 즉,이 이름으로 함수를 정의한 경우 (호출하기 전에) 해당 함수가 대신 호출됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 가 아닌 경우 : : 공유 이것은 아무것도하지 않습니다. &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abe78de368255b02f9df70ea914e277e25b6377a" translate="yes" xml:space="preserve">
          <source>lock() is a &quot;weak keyword&quot; : this means that if you've defined a function by this name (before any calls to it), that function will be called instead. If you are not under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; this does nothing. See &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">lock ()은 &quot;약한 키워드&quot;입니다. 즉,이 이름으로 함수를 정의한 경우 (호출하기 전에) 해당 함수가 대신 호출됩니다. &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 가 아닌 경우 : : 공유 이것은 아무것도하지 않습니다. &lt;a href=&quot;../threads/shared&quot;&gt;threads :: shared를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="863f64ee1d9d5efee40adfed316ef446406844eb" translate="yes" xml:space="preserve">
          <source>lock_hash() locks an entire hash and any hashes it references recursively, making all keys and values read-only. No value can be changed, no keys can be added or deleted.</source>
          <target state="translated">lock_hash ()는 전체 해시와 재귀 적으로 참조하는 모든 해시를 잠그고 모든 키와 값을 읽기 전용으로 만듭니다. 값을 변경할 수 없으며 키를 추가하거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e20cbb081d83245b2bb382d13f9e870688dc039" translate="yes" xml:space="preserve">
          <source>lock_hash() locks an entire hash, making all keys and values read-only. No value can be changed, no keys can be added or deleted.</source>
          <target state="translated">lock_hash ()는 전체 해시를 잠그고 모든 키와 값을 읽기 전용으로 만듭니다. 값을 변경할 수 없으며 키를 추가하거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ef7ffb55ca09d3d5d38cd41fdec246b7fc33293" translate="yes" xml:space="preserve">
          <source>lockf(3) does not provide shared locking, and requires that the filehandle be open for writing (or appending, or read/writing).</source>
          <target state="translated">lockf (3)은 공유 잠금을 제공하지 않으며 쓰기 (또는 추가 또는 읽기 / 쓰기)를 위해 파일 핸들이 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7babc233de26ab19ead1b9c278128d5c434910ee" translate="yes" xml:space="preserve">
          <source>log</source>
          <target state="translated">log</target>
        </trans-unit>
        <trans-unit id="54eea61dc30d30177daa813ed0f7f137bf06484b" translate="yes" xml:space="preserve">
          <source>log EXPR</source>
          <target state="translated">EXPR 기록</target>
        </trans-unit>
        <trans-unit id="38dd66928079819674d735fcd8176fe58a1d7607" translate="yes" xml:space="preserve">
          <source>logical</source>
          <target state="translated">logical</target>
        </trans-unit>
        <trans-unit id="2736fab291f04e69b62d490c3c09361f5b82461a" translate="yes" xml:space="preserve">
          <source>login</source>
          <target state="translated">login</target>
        </trans-unit>
        <trans-unit id="bd3027fa569ea15ca76d84db21c67e2d514c1a5a" translate="yes" xml:space="preserve">
          <source>long</source>
          <target state="translated">long</target>
        </trans-unit>
        <trans-unit id="964256f0b5a7ed1218974634ed187c4c92086abb" translate="yes" xml:space="preserve">
          <source>long long</source>
          <target state="translated">오랫동안</target>
        </trans-unit>
        <trans-unit id="7d84a9b5ce80cfa867e1b0ac7d47e4d29748d95d" translate="yes" xml:space="preserve">
          <source>longdblfio.U</source>
          <target state="translated">longdblfio.U</target>
        </trans-unit>
        <trans-unit id="e09315fa02d775f3e707a7af455093a1c240583b" translate="yes" xml:space="preserve">
          <source>look</source>
          <target state="translated">look</target>
        </trans-unit>
        <trans-unit id="1f7270b39ba4bb2153715c2af7ce320c7e916470" translate="yes" xml:space="preserve">
          <source>look like it's in Bracket Notation, then we compile it into a sub, replace the string in the %Lexicon with the new coderef, and then we return &amp;amp;$new_sub($lh, ...parameters...).</source>
          <target state="translated">대괄호 표기법에있는 것처럼 보이면 하위로 컴파일하고 % Lexicon의 문자열을 새 코드 참조로 바꾼 다음 &amp;amp; $ new_sub ($ lh, ... parameters ...)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea4a55106332cc0e3e98059d31fe812e8daa531" translate="yes" xml:space="preserve">
          <source>look like it's in Bracket Notation, we return it (after replacing it with a scalarref, in its %Lexicon).</source>
          <target state="translated">대괄호 표기법에있는 것처럼 보이면 반환합니다 (% Lexicon에서 스칼라 참조로 바꾼 후).</target>
        </trans-unit>
        <trans-unit id="449d83a43fb8f44703b6233399d95013a4f778c2" translate="yes" xml:space="preserve">
          <source>looks</source>
          <target state="translated">looks</target>
        </trans-unit>
        <trans-unit id="d348e2927721192d9116c1514b2bf2fc9569cebe" translate="yes" xml:space="preserve">
          <source>looks_like_number</source>
          <target state="translated">looks_like_number</target>
        </trans-unit>
        <trans-unit id="1df823e482339eb6067f4134408b0b8b28411a78" translate="yes" xml:space="preserve">
          <source>loop</source>
          <target state="translated">loop</target>
        </trans-unit>
        <trans-unit id="26ac4aa37ac3a8c344fa2f4dc185d3cd479310b1" translate="yes" xml:space="preserve">
          <source>loses</source>
          <target state="translated">loses</target>
        </trans-unit>
        <trans-unit id="dcf6aa5497e08b90320d9690984d4484444426af" translate="yes" xml:space="preserve">
          <source>lot</source>
          <target state="translated">lot</target>
        </trans-unit>
        <trans-unit id="ee0f49a57ae240afc1fdf80f72c423ec5f89a8ae" translate="yes" xml:space="preserve">
          <source>low surrogate</source>
          <target state="translated">낮은 대리</target>
        </trans-unit>
        <trans-unit id="4bd963634a0c819a99b8db72f5c098cd1267dff4" translate="yes" xml:space="preserve">
          <source>low surrogates</source>
          <target state="translated">낮은 대리모</target>
        </trans-unit>
        <trans-unit id="346e3ee198e98146993894d3de8ecab1a86c3e80" translate="yes" xml:space="preserve">
          <source>lower</source>
          <target state="translated">lower</target>
        </trans-unit>
        <trans-unit id="ebfdec641529d4b59a54e18f8b0e9730f85939fb" translate="yes" xml:space="preserve">
          <source>ls</source>
          <target state="translated">ls</target>
        </trans-unit>
        <trans-unit id="d9ce6d596c2632648fbd8ae6abcd3839f4cbb692" translate="yes" xml:space="preserve">
          <source>lseektype.U</source>
          <target state="translated">lseektype.U</target>
        </trans-unit>
        <trans-unit id="f2b316c5eafa6a056cc0e67989b8ce0c3cc03333" translate="yes" xml:space="preserve">
          <source>lstat</source>
          <target state="translated">lstat</target>
        </trans-unit>
        <trans-unit id="b54245096d5a4f9a2027cbfb28564d6c86ecc831" translate="yes" xml:space="preserve">
          <source>lstat DIRHANDLE</source>
          <target state="translated">lstat DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="c54191eaa53899f1ea11fa61b91001f8f60c7ebb" translate="yes" xml:space="preserve">
          <source>lstat EXPR</source>
          <target state="translated">lstat EXPR</target>
        </trans-unit>
        <trans-unit id="9e33e8fdda61ba945a2beddf3e01162c9c5ee7ca" translate="yes" xml:space="preserve">
          <source>lstat FILEHANDLE</source>
          <target state="translated">lstat 파일 핸들</target>
        </trans-unit>
        <trans-unit id="5f3acfbeb4f6fa5007dd1137ab1e96149af87281" translate="yes" xml:space="preserve">
          <source>lt</source>
          <target state="translated">lt</target>
        </trans-unit>
        <trans-unit id="18b585d78a0bf7afe6b384a11fedeb39b40868ae" translate="yes" xml:space="preserve">
          <source>lwp-request</source>
          <target state="translated">lwp-request</target>
        </trans-unit>
        <trans-unit id="38d66abc1f9579784448422d6ef39d1f7b4a9a86" translate="yes" xml:space="preserve">
          <source>lxlite</source>
          <target state="translated">lxlite</target>
        </trans-unit>
        <trans-unit id="31d03f8441e634cf0d99448eb5ca7fb3a9fe93d9" translate="yes" xml:space="preserve">
          <source>lynx</source>
          <target state="translated">lynx</target>
        </trans-unit>
        <trans-unit id="056d9d3521478c299c29bed581f1dbf09b2a149a" translate="yes" xml:space="preserve">
          <source>lynx.exe</source>
          <target state="translated">lynx.exe</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="ef3e064abfa5be0f0367ed020edf5681b79671ea" translate="yes" xml:space="preserve">
          <source>m modifier (//m): Treat string as a set of multiple lines. &lt;code&gt;'.'&lt;/code&gt; matches any character except &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match at the start or end of</source>
          <target state="translated">m 수정 자 (// m) : 문자열을 여러 줄로 처리합니다. &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 제외한 모든 문자와 일치합니다 . &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 는 시작 또는 끝에서 일치 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d369c164073498644b846b81b69cc5f2c8e49c37" translate="yes" xml:space="preserve">
          <source>m//</source>
          <target state="translated">m//</target>
        </trans-unit>
        <trans-unit id="efd431e9222340418322dc8973ecdf9d041d4b17" translate="yes" xml:space="preserve">
          <source>made further support of WinCE port.</source>
          <target state="translated">WinCE 포트를 추가로 지원했습니다.</target>
        </trans-unit>
        <trans-unit id="29328b216c9d886a2b144cfaf368cc216c4398ba" translate="yes" xml:space="preserve">
          <source>madler@alumni.caltech.edu</source>
          <target state="translated">madler@alumni.caltech.edu</target>
        </trans-unit>
        <trans-unit id="b40981aab75932c5b2f555f50769d878e44913d7" translate="yes" xml:space="preserve">
          <source>magic</source>
          <target state="translated">magic</target>
        </trans-unit>
        <trans-unit id="b7161d3acd757800a629497aac7ae100d1b7c5ec" translate="yes" xml:space="preserve">
          <source>magic is called from &lt;code&gt;hv_fetch_common&lt;/code&gt; and &lt;code&gt;hv_delete_common&lt;/code&gt; through the function &lt;code&gt;hv_magic_uvar_xkey&lt;/code&gt; , which defines the interface. The call happens for hashes with &quot;uvar&quot; magic if the &lt;code&gt;ufuncs&lt;/code&gt; structure has equal values in the &lt;code&gt;uf_val&lt;/code&gt; and &lt;code&gt;uf_set&lt;/code&gt; fields. Hashes are unaffected if (and as long as) these fields hold different values.</source>
          <target state="translated">매직은 인터페이스를 정의하는 &lt;code&gt;hv_magic_uvar_xkey&lt;/code&gt; 함수를 통해 &lt;code&gt;hv_fetch_common&lt;/code&gt; 및 &lt;code&gt;hv_delete_common&lt;/code&gt; 에서 호출 됩니다. &lt;code&gt;ufuncs&lt;/code&gt; 구조가 &lt;code&gt;uf_val&lt;/code&gt; 및 &lt;code&gt;uf_set&lt;/code&gt; 필드 에서 동일한 값을 갖는 경우 &quot; uvar &quot;매직이있는 해시에 대한 호출이 발생 합니다. 이러한 필드가 다른 값을 보유하는 한 해시는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="079bca4a77639199d9427705b1cf84c0a19765df" translate="yes" xml:space="preserve">
          <source>mail(1)</source>
          <target state="translated">mail(1)</target>
        </trans-unit>
        <trans-unit id="eeef5463e27b68c50752d7ef6cafa5c83c09c659" translate="yes" xml:space="preserve">
          <source>mailing list.</source>
          <target state="translated">메일 링리스트.</target>
        </trans-unit>
        <trans-unit id="7af2ad103447ffa690c8bf6319632e78d6f0d6c9" translate="yes" xml:space="preserve">
          <source>mailx(1)</source>
          <target state="translated">mailx(1)</target>
        </trans-unit>
        <trans-unit id="b28b7af69320201d1cf206ebf28373980add1451" translate="yes" xml:space="preserve">
          <source>main</source>
          <target state="translated">main</target>
        </trans-unit>
        <trans-unit id="5821eb27d7b71c9078000da31a5a654c97e401b9" translate="yes" xml:space="preserve">
          <source>make</source>
          <target state="translated">make</target>
        </trans-unit>
        <trans-unit id="9e69b01eeaaedb92e327eadc021b5cbd52d18cd7" translate="yes" xml:space="preserve">
          <source>make alone puts all relevant files into directories that are named by the macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and INST_MAN3DIR. All these default to something below ./blib if you are</source>
          <target state="translated">make만으로 모든 관련 파일을 매크로 INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR 및 INST_MAN3DIR로 명명 된 디렉토리에 넣습니다. 이 모든 기본값은 ./blib 아래에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1414dbd638a7bbedecef3cb42a63b4bb33b205a" translate="yes" xml:space="preserve">
          <source>make even Unix programmers &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; your binary streams, or open them with &lt;code&gt;:raw&lt;/code&gt; , but that's the only way to get at them portably anyway.</source>
          <target state="translated">심지어 유닉스 프로그래머가 할 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 바이너리 스트림, 또는 그들을 열 &lt;code&gt;:raw&lt;/code&gt; ,하지만 이식 어쨌든 그들을 얻을 수있는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="0d2b3e56a2cf0fb81a8aabdc9bbedad97cba9aad" translate="yes" xml:space="preserve">
          <source>make inst_perl by default writes some documentation of what has been done into the file &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt;. This can be bypassed by calling make pure_inst_perl.</source>
          <target state="translated">기본적으로 make inst_perl은 &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt; 파일에 수행 된 작업에 대한 문서를 작성 합니다. make pure_inst_perl을 호출하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac56d2d6c13acc3594f87eb880d15f820a757b2" translate="yes" xml:space="preserve">
          <source>make install</source>
          <target state="translated">설치하다</target>
        </trans-unit>
        <trans-unit id="9c18e5a4d2fb6411ebee37c34f994e64f9e94356" translate="yes" xml:space="preserve">
          <source>make install by default writes some documentation of what has been done into the file &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt;. This feature can be bypassed by calling make pure_install.</source>
          <target state="translated">기본적으로 make install은 &lt;code&gt;$(INSTALLARCHLIB)/perllocal.pod&lt;/code&gt; 파일에 수행 된 작업에 대한 문서를 작성 합니다. make pure_install을 호출하여이 기능을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b634bb60968f9245e0b837dbb860fc9ffa16de85" translate="yes" xml:space="preserve">
          <source>make test</source>
          <target state="translated">시험하다</target>
        </trans-unit>
        <trans-unit id="40662a75d2fa6f986ff7fbe892d23df6bb7f669d" translate="yes" xml:space="preserve">
          <source>make testdb</source>
          <target state="translated">testdb를 만들다</target>
        </trans-unit>
        <trans-unit id="4ecb1448927b482d2e8630e628eb858e97dc0d70" translate="yes" xml:space="preserve">
          <source>make them</source>
          <target state="translated">그들을 만들</target>
        </trans-unit>
        <trans-unit id="d91e90d7b776eb0d1d15817fe6d9b9372c6ca037" translate="yes" xml:space="preserve">
          <source>make use of the new qr// construct to pre-compile the regexes they use (whereas &lt;code&gt;extract_tagged&lt;/code&gt; uses standard string variable interpolation to create tag-matching patterns).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 는 표준 문자열 변수 보간을 사용하여 태그 일치 패턴을 생성 하는 반면 새로운 qr // 구문을 사용하여 사용하는 정규 표현식 을 사전 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="07526accda1c04050bb9f1a4a62f07c9471df9de" translate="yes" xml:space="preserve">
          <source>make.U</source>
          <target state="translated">make.U</target>
        </trans-unit>
        <trans-unit id="2cbb62d014b07c1a418026eadfae3d532ee66600" translate="yes" xml:space="preserve">
          <source>make_set_make=&lt;code&gt;#&lt;/code&gt; # If your make program handles this for you,</source>
          <target state="translated">make_set_make = &lt;code&gt;#&lt;/code&gt; # make 프로그램이이를 처리하면,</target>
        </trans-unit>
        <trans-unit id="fd96c8498d2dc48d3f78f6335afc6ed3167f9b8c" translate="yes" xml:space="preserve">
          <source>make_set_make=&lt;code&gt;MAKE=$make&lt;/code&gt; # if it doesn't.</source>
          <target state="translated">그렇지 않다면 make_set_make = &lt;code&gt;MAKE=$make&lt;/code&gt; #</target>
        </trans-unit>
        <trans-unit id="e7f82c3f566634f9aff062dc010c174e747e8a43" translate="yes" xml:space="preserve">
          <source>makefile.ce</source>
          <target state="translated">makefile.ce</target>
        </trans-unit>
        <trans-unit id="4639a6cdf16268dfbcbc2737352c50221d37ade4" translate="yes" xml:space="preserve">
          <source>makemakerdflt_target</source>
          <target state="translated">makemakerdflt_target</target>
        </trans-unit>
        <trans-unit id="b7c7ada5c449e7874dd51a68b3d5e3334a63dd58" translate="yes" xml:space="preserve">
          <source>makes $this an alias for $that, @this an alias for @that, %this an alias for %that, &amp;amp;this an alias for &amp;amp;that, etc. Much safer is to use a reference. This:</source>
          <target state="translated">$ this를 $ that에 대한 별칭, @this를 @that에 대한 별칭, % this에 대한 별칭, &amp;amp; this에 대한 별칭 등으로 만듭니다. 참조를 사용하는 것이 훨씬 안전합니다. 이:</target>
        </trans-unit>
        <trans-unit id="cdfc243f5581fcd0011d9aa44285de89f3c7df86" translate="yes" xml:space="preserve">
          <source>makes 2 copies of $large_string (one for $copy and another for the quotes), whereas</source>
          <target state="translated">$ large_string의 사본 2 개 (하나는 $ copy 용이고 다른 하나는 따옴표 용)를 만드는 반면</target>
        </trans-unit>
        <trans-unit id="83d231e9f1a700e735290aed581501d7d6b03c61" translate="yes" xml:space="preserve">
          <source>makes Perl use the PATH environment variable to search for the program unless the name of the program contains path separators.</source>
          <target state="translated">프로그램 이름에 경로 구분 기호가없는 경우 Perl은 PATH 환경 변수를 사용하여 프로그램을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a67bd44e2ab0599fe88c8688792d8ffd48560740" translate="yes" xml:space="preserve">
          <source>makes Tk event loop run when waiting for user input (i.e., during &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; method).</source>
          <target state="translated">사용자 입력을 기다릴 때 (즉, &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 메소드 동안 ) Tk 이벤트 루프를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="27400b1510032cb064769829374860147cea9dd5" translate="yes" xml:space="preserve">
          <source>makes the command line stand out by using termcap data. The argument to &lt;code&gt;ornaments&lt;/code&gt; should be 0, 1, or a string of a form &lt;code&gt;&quot;aa,bb,cc,dd&quot;&lt;/code&gt; . Four components of this string should be names of</source>
          <target state="translated">termcap 데이터를 사용하여 명령 행을 돋보이게합니다. &lt;code&gt;ornaments&lt;/code&gt; 대한 인수 는 0, 1 또는 &lt;code&gt;&quot;aa,bb,cc,dd&quot;&lt;/code&gt; 형식의 문자열이어야합니다 . 이 문자열의 네 가지 구성 요소는</target>
        </trans-unit>
        <trans-unit id="0639604e49ec4ac0f7eb55dc4af289d8dc7167a4" translate="yes" xml:space="preserve">
          <source>makes this layer available, although</source>
          <target state="translated">이 레이어를 사용할 수 있지만</target>
        </trans-unit>
        <trans-unit id="d6c675249ee9adbb1c9a261647a95be4a6a19ac1" translate="yes" xml:space="preserve">
          <source>maketext_filter</source>
          <target state="translated">maketext_filter</target>
        </trans-unit>
        <trans-unit id="aec3541d23c3a9a173e7827c3070f5f73393d1e0" translate="yes" xml:space="preserve">
          <source>making clear how the parameters are actually passed to &lt;code&gt;foo&lt;/code&gt; .</source>
          <target state="translated">매개 변수가 실제로 &lt;code&gt;foo&lt;/code&gt; 에 전달되는 방법을 명확하게합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1aeea708e4eb994e02aebaa248131fc82125c0" translate="yes" xml:space="preserve">
          <source>malloc() may want to subdivide a bigger bucket into smaller buckets. If only a part of the deceased bucket is left unsubdivided, the rest is kept as an element of a linked list. This field gives the total size of these chunks.</source>
          <target state="translated">malloc ()은 더 큰 버킷을 더 작은 버킷으로 세분 할 수 있습니다. 사망 한 버킷의 일부만 세분화되지 않은 경우 나머지는 연결된 목록의 요소로 유지됩니다. 이 필드는 이러한 청크의 총 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a76da154fe4a39e34c734b4cb5bf0dd07eb6ae3" translate="yes" xml:space="preserve">
          <source>malloc(0), realloc(0), calloc(0, 0) are non-portable. To be portable allocate at least one byte. (In general you should rarely need to work at this low level, but instead use the various malloc wrappers.)</source>
          <target state="translated">malloc (0), realloc (0), calloc (0, 0)은 이식 할 수 없습니다. 휴대용이 되려면 1 바이트 이상을 할당하십시오. (일반적으로이 낮은 수준에서 작업 할 필요는 없지만 다양한 malloc 랩퍼를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="222c4a1e90126e2bfcc4b636a85b99c97fd45171" translate="yes" xml:space="preserve">
          <source>malloc.c</source>
          <target state="translated">malloc.c</target>
        </trans-unit>
        <trans-unit id="8596070207a7af9e2362faacf985b07bd76e5e93" translate="yes" xml:space="preserve">
          <source>malloc.o</source>
          <target state="translated">malloc.o</target>
        </trans-unit>
        <trans-unit id="095a5ce7f546af45133c8dc13868feb3acd7faf2" translate="yes" xml:space="preserve">
          <source>mallocsrc.U</source>
          <target state="translated">mallocsrc.U</target>
        </trans-unit>
        <trans-unit id="8175e3c8753aeb1696959f72ede260ebf3ea14c5" translate="yes" xml:space="preserve">
          <source>man</source>
          <target state="translated">man</target>
        </trans-unit>
        <trans-unit id="1c078d0bf4b8dd2e699b069f52b58d7001d16869" translate="yes" xml:space="preserve">
          <source>man page for details.</source>
          <target state="translated">자세한 내용은 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="194c36c280a775b2ab3c6204dbb72dea5795ab10" translate="yes" xml:space="preserve">
          <source>man(1)</source>
          <target state="translated">man(1)</target>
        </trans-unit>
        <trans-unit id="b716e508bc702ecd96357df137bb55e7d7979571" translate="yes" xml:space="preserve">
          <source>man(5)</source>
          <target state="translated">man(5)</target>
        </trans-unit>
        <trans-unit id="6208d80a4c0588585c80b00796bde79230ebcf13" translate="yes" xml:space="preserve">
          <source>man(7)</source>
          <target state="translated">man(7)</target>
        </trans-unit>
        <trans-unit id="a3d5158a4aaa199267a8ea6269070ad8aee11093" translate="yes" xml:space="preserve">
          <source>man1dir.U</source>
          <target state="translated">man1dir.U</target>
        </trans-unit>
        <trans-unit id="5bdc3c414d10b0ba2f02bd89b3aa370710faefed" translate="yes" xml:space="preserve">
          <source>man3dir.U</source>
          <target state="translated">man3dir.U</target>
        </trans-unit>
        <trans-unit id="7519267064103f8587f3413cf85843cf6d5b51d6" translate="yes" xml:space="preserve">
          <source>man_url_postfix</source>
          <target state="translated">man_url_postfix</target>
        </trans-unit>
        <trans-unit id="3b4afef27bb9c55d4b3898de6def46e2bd5cde2d" translate="yes" xml:space="preserve">
          <source>man_url_prefix</source>
          <target state="translated">man_url_prefix</target>
        </trans-unit>
        <trans-unit id="967c38874059d9c308cfa6fc765c16a4bc26c1d7" translate="yes" xml:space="preserve">
          <source>manext</source>
          <target state="translated">manext</target>
        </trans-unit>
        <trans-unit id="11208e62cf970ecedb0289935540a9e036a965ed" translate="yes" xml:space="preserve">
          <source>mangle the names according to the scheme of new perl and copy the DLLs to these names;</source>
          <target state="translated">새로운 perl의 체계에 따라 이름을 맹 글링하고 DLL을 이러한 이름으로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="70f62c5995ffc0a3d8482ebc9cb103ec54f10822" translate="yes" xml:space="preserve">
          <source>manifypods</source>
          <target state="translated">manifypods</target>
        </trans-unit>
        <trans-unit id="cf1b33c2d9cb1cb8c907a395cf2d9daa37137777" translate="yes" xml:space="preserve">
          <source>manifypods_target</source>
          <target state="translated">manifypods_target</target>
        </trans-unit>
        <trans-unit id="0bd558ad5a573716c4a7500ed4950000799f0e6e" translate="yes" xml:space="preserve">
          <source>manpage</source>
          <target state="translated">manpage</target>
        </trans-unit>
        <trans-unit id="8e402ff24e7c6da97aa72971b48ed83bd2075972" translate="yes" xml:space="preserve">
          <source>manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="translated">다음과 같이 &quot;빈&quot;프로그램의 맨 페이지 :</target>
        </trans-unit>
        <trans-unit id="8fa0fbe8ca06dbd114197c43c3e2ca36a4dd604e" translate="yes" xml:space="preserve">
          <source>manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="translated">맨 페이지. perl 내에서 &lt;code&gt;iconv&lt;/code&gt; 쉘 유틸리티 를 호출하는 한 가지 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="109e419351c9d9b869f96b375f5b2571c17c6c46" translate="yes" xml:space="preserve">
          <source>manpath</source>
          <target state="translated">manpath</target>
        </trans-unit>
        <trans-unit id="0c2876386539d906bac3a839a472cb5f4cd8a5ad" translate="yes" xml:space="preserve">
          <source>mansrc.U</source>
          <target state="translated">mansrc.U</target>
        </trans-unit>
        <trans-unit id="6cadfcb71363f4d7fc9f2fab3fbedb185b558f8c" translate="yes" xml:space="preserve">
          <source>mantissa() and exponent() return the said parts of the BigFloat as BigInts such that:</source>
          <target state="translated">mantissa () 및 exponent ()는 BigFloat의 해당 부분을 BigInts로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9c1dd14bb9ad9842019c5e71e79ebfe090ea86ba" translate="yes" xml:space="preserve">
          <source>mantissa(), exponent() and parts()</source>
          <target state="translated">가수 (), 지수 () 및 부품 ()</target>
        </trans-unit>
        <trans-unit id="37fcf1fa5d0a864017cd95b422637963af01817c" translate="yes" xml:space="preserve">
          <source>manual pages.</source>
          <target state="translated">매뉴얼 페이지.</target>
        </trans-unit>
        <trans-unit id="f25470201a131e127feab62862c4c9a8b033b071" translate="yes" xml:space="preserve">
          <source>many</source>
          <target state="translated">many</target>
        </trans-unit>
        <trans-unit id="ef49cb3336572ee03ae671c687d0c1aa65f08ca5" translate="yes" xml:space="preserve">
          <source>many-colored</source>
          <target state="translated">many-colored</target>
        </trans-unit>
        <trans-unit id="9208f9af655701e0391c8136db59433892d1977a" translate="yes" xml:space="preserve">
          <source>many.</source>
          <target state="translated">many.</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="7ae7c2d920d4746221d2021411af1be6f94a2b1e" translate="yes" xml:space="preserve">
          <source>map BLOCK LIST</source>
          <target state="translated">차단 목록</target>
        </trans-unit>
        <trans-unit id="252b6dc296dd87752c7fc87bc48e8a3a3ae93df2" translate="yes" xml:space="preserve">
          <source>map EXPR,LIST</source>
          <target state="translated">EXPR, LIST지도</target>
        </trans-unit>
        <trans-unit id="821b7db1bf69055d3819db82de2c55389a73409b" translate="yes" xml:space="preserve">
          <source>mapping</source>
          <target state="translated">mapping</target>
        </trans-unit>
        <trans-unit id="d060c381b2b7e474f3327039365d540bdd00ae54" translate="yes" xml:space="preserve">
          <source>marcus.harnisch (at) gmx.net</source>
          <target state="translated">marcus.harnisch (at) gmx.net</target>
        </trans-unit>
        <trans-unit id="db947d9543645af5118ec8eb4a4ca3b85f177330" translate="yes" xml:space="preserve">
          <source>marker or a &quot;package Name;&quot;-style specification.</source>
          <target state="translated">마커 또는 &quot;패키지 이름&quot;스타일 사양.</target>
        </trans-unit>
        <trans-unit id="f81924e45a3409b8f19c0c8c0ccc8adb925131f4" translate="yes" xml:space="preserve">
          <source>markers. The original MANIFEST.SKIP is saved as MANIFEST.SKIP.bak.</source>
          <target state="translated">마커. 원래 MANIFEST.SKIP은 MANIFEST.SKIP.bak으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="453a611042ddc2540cd6e814ad412629e5dbe987" translate="yes" xml:space="preserve">
          <source>mask (MASK)</source>
          <target state="translated">마스크 (MASK)</target>
        </trans-unit>
        <trans-unit id="c3b8534fda7efd1489afb5fd6145c2c0ee4c5741" translate="yes" xml:space="preserve">
          <source>match any of its subsections:</source>
          <target state="translated">하위 섹션과 일치</target>
        </trans-unit>
        <trans-unit id="f757168687a351b24f3d7929cacb9c38a3f6d2ba" translate="yes" xml:space="preserve">
          <source>match at the start of the string. Thus the first quantifier has to match everything up to the first &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;. The second minimal quantifier matches just one &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; and the third quantifier matches the rest of the string.</source>
          <target state="translated">문자열의 시작 부분에서 일치합니다. 따라서 첫 번째 정량자는 모든 것을 첫 번째 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 까지 일치시켜야합니다 . 두 번째 최소 수량 자는 단 하나의 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 과 일치하고 세 번째 수량자는 나머지 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0923e6d77fc5fe3e77019fe165e62059bca66c51" translate="yes" xml:space="preserve">
          <source>match is chosen if the</source>
          <target state="translated">일치하는 경우</target>
        </trans-unit>
        <trans-unit id="ab40f8ad7e88d02d55d990bcb5fbfb20c5681919" translate="yes" xml:space="preserve">
          <source>match is of zero length.</source>
          <target state="translated">일치 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="0d82094c1c07e4a73c286a3d423db8f6e4f8dc59" translate="yes" xml:space="preserve">
          <source>match is what is matched by &lt;code&gt;\w&lt;/code&gt; . Thus zero-length matches alternate with one-character-long matches.</source>
          <target state="translated">match는 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 것입니다 . 따라서 길이가 0 인 일치 문자는 1 자 길이의 일치 문자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="04818134b60c58c656e4b991d38166d6f3076c39" translate="yes" xml:space="preserve">
          <source>match of this pattern. This effectively means that the regex engine &quot;skips&quot; forward to this position on failure and tries to match again, (assuming that there is sufficient room to match).</source>
          <target state="translated">이 패턴과 일치합니다. 이것은 정규식 엔진이 실패 할 때이 위치로 &quot;건너 뛰고&quot;다시 일치 시키려고한다는 것을 의미합니다 (충분할 공간이 충분하다고 가정).</target>
        </trans-unit>
        <trans-unit id="2aeb93bd6b0ddbe1b2affadead65a4a0403777df" translate="yes" xml:space="preserve">
          <source>match the current Perl interpreter's version ID, suppressing</source>
          <target state="translated">현재 Perl 인터프리터의 버전 ID와 일치</target>
        </trans-unit>
        <trans-unit id="632d2ed159e13f1f7bc205ac4fd10f5389ed2386" translate="yes" xml:space="preserve">
          <source>match the current Perl interpreter's version id, suppressing</source>
          <target state="translated">현재 Perl 인터프리터의 버전 ID와 일치하여</target>
        </trans-unit>
        <trans-unit id="f743d4858548a263762a36939a95c6da7ebf0d4d" translate="yes" xml:space="preserve">
          <source>match()</source>
          <target state="translated">match()</target>
        </trans-unit>
        <trans-unit id="9e7284baae613a8be9f37e0730061d6f042d8cb6" translate="yes" xml:space="preserve">
          <source>match, it will</source>
          <target state="translated">일치, 그것은</target>
        </trans-unit>
        <trans-unit id="a84c1c52c5a0ad6ba6d17b82c8afb7e48375a135" translate="yes" xml:space="preserve">
          <source>match.c</source>
          <target state="translated">match.c</target>
        </trans-unit>
        <trans-unit id="3269d7265825aa798534517571d41a494aee9d44" translate="yes" xml:space="preserve">
          <source>match:</source>
          <target state="translated">match:</target>
        </trans-unit>
        <trans-unit id="f0ba4ba845edb2f7aae00a27910035ffbe2d4394" translate="yes" xml:space="preserve">
          <source>match_attributes</source>
          <target state="translated">match_attributes</target>
        </trans-unit>
        <trans-unit id="bef3c6a271cefa51790a544a7f9ec2bab5650c92" translate="yes" xml:space="preserve">
          <source>matched regex is used. Delimiters other than '/' may be used for both this operator and the following ones. The leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; can be omitted if the delimiter is '/'.</source>
          <target state="translated">일치하는 정규식이 사용됩니다. '/'이외의 구분 기호는이 연산자와 다음 연산자 모두에 사용될 수 있습니다. 구분 기호가 '/'인 경우 선행 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac80938af61d76d029e10bff3eeaa4d9936caf68" translate="yes" xml:space="preserve">
          <source>matched regular expression is used instead. In this case, only the &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; flags on the empty pattern are honored; the other flags are taken from the original pattern. If no match has previously succeeded, this will (silently) act instead as a genuine empty pattern (which will always match).</source>
          <target state="translated">대신 일치하는 정규식이 사용됩니다. 이 경우 빈 패턴 의 &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 플래그 만 적용됩니다 . 다른 플래그는 원래 패턴에서 가져옵니다. 이전에 일치 한 항목이 없으면이 패턴은 (정확하게) 대신 실제 빈 패턴 (항상 일치 함)으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc01360a67b29b124b5c4fb0c967ca385d1fe670" translate="yes" xml:space="preserve">
          <source>matched with zero-length</source>
          <target state="translated">길이가 0 인 것과 일치</target>
        </trans-unit>
        <trans-unit id="9f3e9242c63870528e4600bc635fca8f0f5d6e9c" translate="yes" xml:space="preserve">
          <source>matches</source>
          <target state="translated">matches</target>
        </trans-unit>
        <trans-unit id="49da147fbc1f65bec45fdffd10ec7c4b66da5f3d" translate="yes" xml:space="preserve">
          <source>matches a DNA sequence such that it either ends in &lt;code&gt;AAG&lt;/code&gt; , or some other base pair combination and &lt;code&gt;C&lt;/code&gt; . Note that the form is &lt;code&gt;(?(?&amp;lt;=AA)G|C)&lt;/code&gt; and not &lt;code&gt;(?((?&amp;lt;=AA))G|C)&lt;/code&gt;; for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.</source>
          <target state="translated">&lt;code&gt;AAG&lt;/code&gt; 또는 다른 염기쌍 조합 및 &lt;code&gt;C&lt;/code&gt; 로 끝나도록 DNA 서열과 일치합니다 . 형태는 &lt;code&gt;(?(?&amp;lt;=AA)G|C)&lt;/code&gt; 가 아닌 &lt;code&gt;(?((?&amp;lt;=AA))G|C)&lt;/code&gt; 이며; lookahead, lookbehind 또는 code assertion의 경우 조건부 주위의 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1ee14db482234ce9b2680f4f1530b16ee389867" translate="yes" xml:space="preserve">
          <source>matches a chunk of non-parentheses, possibly included in parentheses themselves.</source>
          <target state="translated">괄호 자체에 포함될 수있는 비 괄호 덩어리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3babeacfb57a1f18f60b79e9f2e4dd3547207ea0" translate="yes" xml:space="preserve">
          <source>matches any four character string which begins with a and ends with d.</source>
          <target state="translated">a로 시작하고 d로 끝나는 4 개의 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="15bb6a71934f5939f8a50dcc56e36bba9679039e" translate="yes" xml:space="preserve">
          <source>matches any single character other than a close square bracket or a minus sign/dash.</source>
          <target state="translated">닫는 대괄호 나 빼기 기호 / 대시 이외의 모든 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b44ccf9fc2b923e2e3c4186c16014a27d5a8ac30" translate="yes" xml:space="preserve">
          <source>matches any single printable alphanumeric ASCII character.</source>
          <target state="translated">인쇄 가능한 단일 영숫자 ASCII 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3b42764c7627f67dcaba67e6658bbee63ee5b1a5" translate="yes" xml:space="preserve">
          <source>matches any string that ends with the string &quot;bdc&quot; including the string &quot;bdc&quot; (without quotes).</source>
          <target state="translated">문자열 &quot;bdc&quot;(따옴표없이)를 포함하여 문자열 &quot;bdc&quot;로 끝나는 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8bc98179220f92e19a1a58c53a9bd45d54ffdbd9" translate="yes" xml:space="preserve">
          <source>matches the character control-</source>
          <target state="translated">캐릭터 컨트롤과 일치</target>
        </trans-unit>
        <trans-unit id="b617fbb7b175fdd37c20c95f64db0a36c2293892" translate="yes" xml:space="preserve">
          <source>matches the format of the output produced by method</source>
          <target state="translated">메소드에 의해 생성 된 출력 형식과 일치</target>
        </trans-unit>
        <trans-unit id="9d19065b9d7370cf3c8d6c06d5f9d37ea4be7671" translate="yes" xml:space="preserve">
          <source>matches the literal character &quot;#&quot;. To specify a literal white space character, you can escape it with a backslash, like:</source>
          <target state="translated">리터럴 문자 &quot;#&quot;와 일치합니다. 리터럴 공백 문자를 지정하려면 다음과 같이 백 슬래시로 이스케이프 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf2447768fbf2bf4b2e2e933543695b5244c31c" translate="yes" xml:space="preserve">
          <source>matches upper case things. You can avoid surprises by making the components into instances of this construct by compiling them:</source>
          <target state="translated">대문자와 일치합니다. 컴포넌트를 컴파일하여 컴포넌트를이 구문의 인스턴스로 만들어서 놀라움을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3fffffacfc445c265f143813f75c8f495ac85c" translate="yes" xml:space="preserve">
          <source>matches()</source>
          <target state="translated">matches()</target>
        </trans-unit>
        <trans-unit id="c504956e0c725a398bfd8daa901c16a757fa596e" translate="yes" xml:space="preserve">
          <source>matches, because &lt;code&gt;\N{TAMIL SYLLABLE KAU}&lt;/code&gt; is a named sequence consisting of the two characters matched against. Like the other instance where a bracketed class can match multiple characters, and for similar reasons, the class must not be inverted, and the named sequence may not appear in a range, even one where it is both endpoints. If these happen, it is a fatal error if the character class is within an extended &lt;a href=&quot;#Extended-Bracketed-Character-Classes&quot;&gt;(?[...]) &lt;/a&gt; class; and only the first code point is used (with a &lt;code&gt;regexp&lt;/code&gt; -type warning raised) otherwise.</source>
          <target state="translated">일치 때문에 &lt;code&gt;\N{TAMIL SYLLABLE KAU}&lt;/code&gt; 에 대해 일치 두 문자로 이루어진 시퀀스라는 것이다. 대괄호로 묶은 클래스가 여러 문자와 일치 할 수있는 다른 인스턴스와 마찬가지로, 비슷한 이유로 클래스를 뒤집어서는 안되며 명명 된 시퀀스는 범위, 두 끝점 인 범위에도 표시되지 않을 수 있습니다. 이러한 상황이 발생하면 문자 클래스가 확장 &lt;a href=&quot;#Extended-Bracketed-Character-Classes&quot;&gt;(? [...])&lt;/a&gt; 클래스 내에 있으면 치명적인 오류입니다 . 그렇지 않으면 첫 번째 코드 포인트 만 사용됩니다 ( &lt;code&gt;regexp&lt;/code&gt; 유형 경고가 발생 함).</target>
        </trans-unit>
        <trans-unit id="1cef80f4af3762f8acb0c8194e31a9dba7622c98" translate="yes" xml:space="preserve">
          <source>math.h</source>
          <target state="translated">math.h</target>
        </trans-unit>
        <trans-unit id="0706025b2bbcec1ed8d64822f4eccd96314938d0" translate="yes" xml:space="preserve">
          <source>max</source>
          <target state="translated">max</target>
        </trans-unit>
        <trans-unit id="f437d0830962615d329585b8ef177af37610c3a6" translate="yes" xml:space="preserve">
          <source>max_exec_len</source>
          <target state="translated">max_exec_len</target>
        </trans-unit>
        <trans-unit id="493a03ab2084312252ebbf79ad1dea22b9c876c0" translate="yes" xml:space="preserve">
          <source>maximal match</source>
          <target state="translated">최대 경기</target>
        </trans-unit>
        <trans-unit id="6df17187720d1ee015cb9c87f10272784fdb90e6" translate="yes" xml:space="preserve">
          <source>maxopen</source>
          <target state="translated">maxopen</target>
        </trans-unit>
        <trans-unit id="85ce459f8b54d83030c84994d26698ee633e8e8a" translate="yes" xml:space="preserve">
          <source>maxstr</source>
          <target state="translated">maxstr</target>
        </trans-unit>
        <trans-unit id="f458ef050c0ca014fb8f2fdb27ac9b5f69123cfd" translate="yes" xml:space="preserve">
          <source>may</source>
          <target state="translated">may</target>
        </trans-unit>
        <trans-unit id="00dde7e4bcf57be92c2134af6a202a4c7c8c848d" translate="yes" xml:space="preserve">
          <source>may also be expressed as either of:</source>
          <target state="translated">다음 중 하나로 표현 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adb0f7026052c31c6cf256420da26be99c3c65e2" translate="yes" xml:space="preserve">
          <source>may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">또한 특수 값 &lt;code&gt;none&lt;/code&gt; 으로 설정 될 수 있습니다 .이 경우 C &amp;lt;&amp;gt; 텍스트 주위에 따옴표가 추가되지 않습니다 (그러나 글꼴은 여전히 ​​troff 출력으로 변경됨).</target>
        </trans-unit>
        <trans-unit id="0ebe475a2d8b3a20ed9e93385b169f98908585ef" translate="yes" xml:space="preserve">
          <source>may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">또한 특수 값 &lt;code&gt;none&lt;/code&gt; 으로 설정 될 수 있습니다 .이 경우 C &amp;lt;&amp;gt; 텍스트 주위에 따옴표가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e91b6ec2168ed3aab916a99a798fdf733920f81b" translate="yes" xml:space="preserve">
          <source>may also be used to create a skeleton pure Perl module. See the &lt;b&gt;-X&lt;/b&gt; option.</source>
          <target state="translated">스켈레톤 순수 Perl 모듈을 만드는 데 사용될 수도 있습니다. &lt;b&gt;-X&lt;/b&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cfd27998f76697059adfb326f43ad858caa7059" translate="yes" xml:space="preserve">
          <source>may be NULL.</source>
          <target state="translated">NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33043a9fa22b41b4c6ac896111ccbaf62cc4a49e" translate="yes" xml:space="preserve">
          <source>may be a variable containing a code reference (in this case</source>
          <target state="translated">코드 참조를 포함하는 변수 일 수 있습니다 (이 경우</target>
        </trans-unit>
        <trans-unit id="ddec87a1f187c4d9316f5612b310194f0cb15447" translate="yes" xml:space="preserve">
          <source>may be a variable that contains a code reference.</source>
          <target state="translated">코드 참조를 포함하는 변수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5633babe75c2fba985f3afda654bc7adbab1ef3a" translate="yes" xml:space="preserve">
          <source>may be an unknown concept to some readers. The ISO 8601 standard defines that weeks begin on a Monday and week 1 of the year is the week that includes both January 4th and the first Thursday of the year. In other words, if the first Monday of January is the 2nd, 3rd, or 4th, the preceding days of the January are part of the last week of the preceding year. Week numbers range from 1 to 53.</source>
          <target state="translated">일부 독자에게는 알려지지 않은 개념 일 수 있습니다. ISO 8601 표준은 주가 1 월 4 일과 첫째 주 목요일을 포함하는 주와 그 해의 주 1에서 시작하는 주를 정의합니다. 즉, 1 월 첫 번째 월요일이 2 일, 3 일 또는 4 일인 경우 1 월의 전일은 전년도 마지막 주에 속합니다. 주 번호는 1에서 53 사이입니다.</target>
        </trans-unit>
        <trans-unit id="620555f380a18af4bd9b7ffcf6fcbb4d729e2b7b" translate="yes" xml:space="preserve">
          <source>may be better to avoid namespace conflict.</source>
          <target state="translated">네임 스페이스 충돌을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b16d2b73013f40d6be654ee941657374d7a6c7cc" translate="yes" xml:space="preserve">
          <source>may be called immediately, even before this function has returned.</source>
          <target state="translated">이 함수가 반환되기 전에 즉시 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01fdf6f3b149c78a69c314df24371c68b8a9d66" translate="yes" xml:space="preserve">
          <source>may be closer to the conjectural</source>
          <target state="translated">추측에 더 가깝다</target>
        </trans-unit>
        <trans-unit id="8aa5be6aba6ead8c673905a3dcd0c6a264703b5a" translate="yes" xml:space="preserve">
          <source>may be contained in the current directory, or in the home directory. Because this file is sourced in by Perl and may contain arbitrary commands, for security reasons, it must be owned by the superuser or the current user, and writable by no one but its owner.</source>
          <target state="translated">현재 디렉토리 또는 홈 디렉토리에 포함될 수 있습니다. 이 파일은 Perl에 의해 제공되며 보안상의 이유로 임의의 명령을 포함 할 수 있으므로 수퍼 유저 또는 현재 사용자가 소유해야하며 소유자 만이 아닌 사람이 쓸 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc813d4cd4ffa7c7d85e1f0cd24c06e64f3ecb37" translate="yes" xml:space="preserve">
          <source>may be either null or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</source>
          <target state="translated">키와 연관된 값이 없음을 표시하기 위해 null 또는 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 일 수 있습니다 . 이것은 널이 아닌 값과 마찬가지로 체인을 따라 키 값의 존재보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d2e64a32b347cd1852fb2ca8b5a92cd685b5142a" translate="yes" xml:space="preserve">
          <source>may be either the name of an encoding or an</source>
          <target state="translated">인코딩 이름이거나</target>
        </trans-unit>
        <trans-unit id="d0e4afe33850115d15d23bc351fa60444ff005a4" translate="yes" xml:space="preserve">
          <source>may be empty.</source>
          <target state="translated">비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="082c1d60436b887adb588f21fb8ea006b7e859aa" translate="yes" xml:space="preserve">
          <source>may be needed if you change your codepage</source>
          <target state="translated">코드 페이지를 변경하면 필요할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8c2925aa16e7b49e1bb20df5d9c41ab876a112dd" translate="yes" xml:space="preserve">
          <source>may be optimized to</source>
          <target state="translated">에 최적화 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="59a447a3f4fc5d32399811c9cccb0b4c9956f41d" translate="yes" xml:space="preserve">
          <source>may be rendered as: &quot;magic is enabled if you set &lt;code&gt;$Currency&lt;/code&gt; to '</source>
          <target state="translated">&quot; &lt;code&gt;$Currency&lt;/code&gt; 를 '</target>
        </trans-unit>
        <trans-unit id="c617289a4345e3f601ec6da0eb0a234d7d3e338e" translate="yes" xml:space="preserve">
          <source>may be the name &lt;code&gt;:locale&lt;/code&gt; . This is for very specialized applications, and is documented in &lt;a href=&quot;#The-%3alocale-sub-pragma&quot;&gt;The :locale sub-pragma&lt;/a&gt; below.</source>
          <target state="translated">이름은 &lt;code&gt;:locale&lt;/code&gt; 일 수 있습니다 . 이것은 매우 특수한 응용 프로그램을위한 것이며 아래 &lt;a href=&quot;#The-%3alocale-sub-pragma&quot;&gt;의 : locale 하위 pragma에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb5ba8300233c06ee33f2092ef458d662a7286b" translate="yes" xml:space="preserve">
          <source>may be used to enter one line of program. If &lt;b&gt;-e&lt;/b&gt; is given, Perl will not look for a filename in the argument list. Multiple &lt;b&gt;-e&lt;/b&gt; commands may be given to build up a multi-line script. Make sure to use semicolons where you would in a normal program.</source>
          <target state="translated">한 줄의 프로그램을 입력하는 데 사용될 수 있습니다. 경우 &lt;b&gt;-e가&lt;/b&gt; 주어 펄은 인수 목록에서 파일 이름을 찾을 수 없습니다. 여러 줄 스크립트를 작성하기 위해 여러 개의 &lt;b&gt;-e&lt;/b&gt; 명령이 제공 될 수 있습니다. 일반적인 프로그램에서 세미콜론을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91c85eab0a37caa5e5ee3e84d621bd38427c1f01" translate="yes" xml:space="preserve">
          <source>may contain variables, which will be interpolated every time the pattern search is evaluated, except for when the delimiter is a single quote. (Note that &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , and &lt;code&gt;$|&lt;/code&gt; are not interpolated because they look like end-of-string tests.) Perl will not recompile the pattern unless an interpolated variable that it contains changes. You can force Perl to skip the test and never recompile by adding a &lt;code&gt;/o&lt;/code&gt; (which stands for &quot;once&quot;) after the trailing delimiter. Once upon a time, Perl would recompile regular expressions unnecessarily, and this modifier was useful to tell it not to do so, in the interests of speed. But now, the only reasons to use &lt;code&gt;/o&lt;/code&gt; are one of:</source>
          <target state="translated">구분 기호가 작은 따옴표 인 경우를 제외하고 패턴 검색이 평가 될 때마다 보간되는 변수를 포함 할 수 있습니다. ( &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; 및 &lt;code&gt;$|&lt;/code&gt; 은 문자열 끝 테스트처럼 보이기 때문에 보간되지 않습니다.) Perl은 변경이 포함 된 보간 변수가 없으면 패턴을 다시 컴파일하지 않습니다. 후행 분리 문자 뒤에 &lt;code&gt;/o&lt;/code&gt; ( &quot;한 번&quot;을 의미)를 추가하여 Perl이 테스트를 건너 뛰도록하고 다시 컴파일하지 않도록 할 수 있습니다 . 옛날 옛적에 Perl은 불필요하게 정규 표현식을 다시 컴파일 할 것이고,이 수정자는 속도를 위해 그렇게하지 말라고 알려주는 데 유용했습니다. 그러나 이제 &lt;code&gt;/o&lt;/code&gt; 를 사용해야하는 유일한 이유 는 다음 중 하나입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
